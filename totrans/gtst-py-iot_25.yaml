- en: Recognizing Humans with Jarvis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now  we have understood in the last chapter how multiple layers of conditions
    can be clubbed together to get the functionality that is desired. We have just
    completed the first step in making Jarvis work for you. Now, it's time to make
    it even more capable.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will make it control more electronics at your home, which
    can be controlled autonomously without you telling anything to the system. So
    without delay, let's get straight into it and see what we have in our bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Turn on the light Jarvis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the basic functionalities of a smart home is to turn on the lights for
    you whenever you are around. It is one of the most basic things that any system
    can do for you. We will start off by turning on the light as soon as you come
    inside the room, thereafter, we will make the system more and more intelligent.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first thing we need to do is recognize whether you are in a room or
    not. There are multiple ways to do that. One important characteristic of life
    is the presence of movement. You may say plants don't move, well they do; they
    grow, don't they? So detecting movement can be a key step in detecting whether
    someone is there or not!
  prefs: []
  type: TYPE_NORMAL
- en: 'This step will not be so difficult for you, as we have already interfaced this
    sensor previously. We are talking about the good old PIR sensor. So the sensor
    will sense any movement in the area. If there is any movement, then Jarvis will
    switch on the lights. I am sure this is something you can do by yourself by now.
    You can still refer to the code and the circuit diagram here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d18f3ec7-4d2a-452c-bf98-a522f1c87325.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are simply turning on the light as soon as the motion
    is detected, but the problem is that it will only switch on the light for the
    time the motion is there. What does that mean? Simple, while there is some movement,
    will keep the lights on and as soon as the movement stops, it will switch off
    the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be a very good code for a person who wants to lose weight, but for
    most of us, it will be annoying. So, let''s include a small loop, which we have
    used in the previous chapter and make this a little better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, in this program, all we have done is we have added a `for` loop, which switches
    on the light for a set amount of time. How long that time will be can be toggled
    by changing the value of the variable `TIME`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more interesting part in that loop which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Why did we do this you might wonder? Whenever the light will be switched on,
    it will remain on for 5 minutes. Then, it will switch off and wait for movement
    to occur. So, essentially, the problem with this code will be that if you are
    in the room and the light switches on, then for 5 minutes it will see if there
    is any motion detected or not. There is a chance that you will be in motion when
    it searches for the motion after 5 minutes. But for most of the time, it won't
    be the case. So we are detecting the movement using the PIR sensor. Whenever movement
    is detected, the value of `M_final` is incremented using the line `M_final = M_final
    + 1`, thereby increasing the time until which the light will be switched on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you must have figured that the PIR sensor is not the most idealistic
    sensor for us to switch the lights on or off. Mostly because, although the motion
    is one of the best indicators of presence, there can be times when you might not
    move at all, for example, while resting, reading a book, watching a movie, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do now? Well, we can do a little trick. Remember in the last chapter
    we used our proximity sensor to sense whether a person has crossed a specific
    area or not? We will implant a similar logic here; but rather than just copy pasting
    the code, we will improve it and make it even better.
  prefs: []
  type: TYPE_NORMAL
- en: 'So rather than using one single IR proximity sensor, we will be using two of
    these things. The mounting will be as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ec73b93a-776b-4d21-b548-77a79d33417a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it is very evident that whenever a person walks in from the door side to
    the room side the **Sensor 1** will show a lower reading when detecting a body.
    Then, while he is walking towards the room side, **Sensor 2** will show a similar
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: If first **Sensor 1** is triggered and thereafter **Sensor 2** is triggered,
    then we can safely assume that the person is travelling from the door side to
    the room side. Similarly, if the opposite is happening, then it is understood
    that the person is walking out of the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is fairly simple. But how do we implement it in a real-life situation?
    Firstly, we need to connect the circuit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f26bc00c-738b-49c4-b2d2-9ab5ea6176f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once that is done, upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what are we doing here. As always, most of the syntax is very
    simple and straightforward. The most important part is the logic. So, let's understand
    in proper steps as to what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we are taking the value of the IR proximity
    sensor and calculating the distance corresponding to it and storing that value
    in a variable called `F1`. Once that is done, we are stopping for a brief period
    of `0.1` seconds using the `time.sleep(0.1)` function. Thereafter, we are taking
    the reading from the same sensor again and storing the value in a variable called
    `F2`. Why are we doing this? We have already understood that in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once the value of `F1` and `F0` is acquired, we will calculate the difference
    to find out whether someone has passed through it or not. If no one has passed,
    then the reading will almost be the same and the difference will not be considerable.
    However, if a person does pass, then the reading will be considerable and that
    value will be stored in a variable called `F0_final`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the `F0` or the difference in distance between the first and
    the second reading is more than 10 centimeters, then the `if` condition will be
    true. Once true, it will set the value of the `Time0` variable as the current
    value of time. The `time.time()` function will make a note of the exact time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll perform the exact same step for **Sensor 2** as well. There is nothing
    new to tell here; it's all self explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once all of this is done, we compare `if Time1 > Time0`. Why are we comparing
    it? Because `Time0` is the time noted for **Sensor 1**. If the person is moving
    inside, then **Sensor 1** would be the first one to be triggered and then the
    **Sensor 2** would be triggered. Hence, the time noted would be greater for **Sensor
    2** and relatively earlier for **Sensor 1**. If that happens, then we can assume
    that the person is coming inside. Well, if a person is coming inside, then we
    simply need to switch the light on, which is exactly what we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when a person is going out, the first sensor to be triggered would
    be **Sensor 2**, thereafter **Sensor 1** will be triggered. Making the time noted
    for `Time1` earlier than `Time2`; hence, whenever this condition is true, we will
    know that the person is moving out of the room and the lights can be switched
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and mount it near the door and see how it reacts. I'm sure this will
    be way better than what we had done through PIR. Have fun with it and try to find
    any flaws that it might have.
  prefs: []
  type: TYPE_NORMAL
- en: Perfecting motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Were you able to find any flaws in the previous code? They are not hard to find;
    the code works brilliantly when it's only a single person in the room. If this
    is installed somewhere where multiple people are coming and going, then it might
    be challenging. This is because whenever a person moves outside, the light will
    be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that the problem is evident, it''s time to make the code even more better.
    To do this, the hardware will remain exactly the same; we simply need to make
    the code smarter. Let''s see how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is something really basic. We have declared a variable called `PCount`.
    This variable is declared to count the number of people who are there inside a
    room or a home. As you can see in the first few lines of the code, we have declared
    the value of `PCount` as `0`. We are assuming that once we start this, the number
    of people inside would be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the condition `if Time1 > Time0:` is satisfied, the `PCount` value
    is incremented by `1`. As we all know, the condition will only be true when a
    person is walking inside the home.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when a person is walking outside, the condition `if Time1 < Time0:`
    is true; whenever that happens, the value of `PCount` is decremented by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have started counting the number of people in the room, we are now
    applying the condition, which will turn on if the number of `PCount` is more than
    `0`. Hence, the light will be on for the time when the number of people inside
    the home is more than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In a very similar fashion, the lights will be turned off if the value of `PCount`
    or the number of people inside the home gets to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, nailed!
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the intensity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have controlled a lot of light now. It's time that we control our fans and
    other air circulation systems. Whenever we talk about fans or any other air circulation
    devices, then essentially we are talking about motors. As we have learned earlier,
    motors are simple devices, which can be controlled every easily using a motor
    driver. But as you know, back then we were controlling DC motors. DC motors are
    extremely simple devices. But when we talk about our household appliances, then
    most of these devices will be working on AC or alternating current. I am assuming
    that you must be aware of what that is and how it is different from DC.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know that the motors used in our households are working on AC,
    you must also think about the fact that their control mechanism will be much different
    to DC motors. You are right, if you thought so. However, the good thing about
    electronics is, nothing is really difficult or complicated. The basics are pretty
    much the same. So, let's see how we can control the speed of the motors in AC
    supply.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen earlier, we can simply have a PWM signal given to the DC motor
    and the motor will run at the speed of the average voltage as a result of the
    PWM signal. Now, you must be thinking that this can be applied to AC as well.
    The thing is, yes it can be done if you want to control a light or similar devices,
    which do not have any major change in the characteristics in case the wave form
    is distorted. However, when we are talking about any other component, then we
    come across a big problem. The AC wave form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e6c88285-4f38-493f-8a73-ab5d0a621507.png)'
  prefs: []
  type: TYPE_IMG
- en: This basically means that the potential is changing periodically. In most of
    the households, this is 50 times per second. Now, imagine if we have a PWM-controlled
    device that is switching the circuit that only lets the power supply to pass at
    certain intervals. Then, the different parts of the sinusoidal waves would be
    passed on to the final output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d3c74564-5890-4819-8bd8-c37da64c8c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding PWM, fortunately the PWM signal has matched
    with the phase of the AC power; however, due to this, only the positive end of
    the phase is being transferred to the final output and not the negative end. This
    will cause a severe problem to our load and there is a very good chance that the
    appliance that is connected will not work.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3d28446a-d7a4-4893-85e7-87dfa8a9a994.png)'
  prefs: []
  type: TYPE_IMG
- en: We have another example in which the PWM is random and it lets random parts
    of the wave pass by. In this, we can clearly see that randomly any part of the
    wave is being transferred and the positive and negative end voltage is not in
    sync, which again will be a huge problem. Hence, instead of using PWM, we use
    something really interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that is most commonly used is called **phase fired control**. Sometimes
    it is also called phase angle control or phase cutting. What it essentially does
    is, it cuts the wave at certain parts of the phase letting the rest of the wave
    cross by. Confused? Let me show you here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/047edc17-d0c2-4d67-9659-cf416b3bb5af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as you can see the phase behind the second half of the AC wave is getting
    chopped and is not getting passed in the final output. This makes the final output
    to be only 50% of the overall input. What this technique does is, it maintains
    the AC nature of the power supply while still being able to reduce the overall
    resulting voltage. Likewise, as you can see in the next diagram, the wave is getting
    chopped after 75% of the wave has already passed. This results in the output being
    relatively lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3b77b2b6-78b7-4683-b2c7-eea349d43a3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you must be asking, how did we actually go ahead and do this? It is done
    by a relatively complex circuit that detects the phase angle of the wave and then
    opens or controls a triac, which is a high power bi-directional semiconductor.
    This leads the power supply to pass or to be stopped at certain phases. We will
    leave the exact working of this circuit for the next time as it is fairly complex
    and will not be relevant to this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now coming to the basic point, we know what phase cutting is, we also know that
    triac is the basic device that lets us do that. But how do we go ahead and do
    it using Raspberry Pi is the question.
  prefs: []
  type: TYPE_NORMAL
- en: So firstly, we will need an AC-dimmer module. This module already has all the
    components of phase detection and chopping. So all we need to do is simply control
    it using simple PWM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though I might not have to demonstrate how to connect the circuit or what the
    code should be, for the sake of understanding, let''s connect a light bulb to
    our Arduino using this module and then control the bulb. Now, the first thing
    to remember is that the load should be a bulb and not anything else such as an
    LED light. So go ahead and connect the circuit as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/26e340ef-6b20-41d1-9951-8d8bd3b1850c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this is done, go ahead and upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the attached light will start to glow very faintly first and will
    increase the intensity gradually until it reaches 100%. That is how simple it
    is to control such a complex process.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent temperature control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the basics are done, let's go ahead and build something meaningful
    using this system. Isn't it difficult to set your air-conditioner to the perfect temperature?
    No matter what you do, you end up feeling not in the most comfortable spot. This
    happens due to physiological changes in the body temperature over the course of
    the day.
  prefs: []
  type: TYPE_NORMAL
- en: When you wake up, your body temperature is relatively low. It is as much as
    1° F, which is lower than the normal body temperature. As the day progresses,
    the body temperature rises until the time you hit the bed. Once you sleep, again
    your body temperature starts to dip reaching its lowest point around 4:00-6:00
    am in the morning. That's the reason why what might feel warm while you go to
    bed, can be pretty cold when you wake up. Modern air-conditioners have something
    called a sleep mode. What this does is, it simply increases the temperature through
    the night. So that you do not feel cold at any point. But then again, how well
    it works is also a question.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we know the robotics very well, we will go ahead and make a system
    of our own that will take care of everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, we will connect both the air-conditioner and your fan together
    so that they can both work in tandem and make you sleep well. Now, before jumping
    straight into it, I would like you to see the ratings that are mentioned on the
    relay. As you can see, the relay can handle only 250V and 5 ampere. Now, if you
    go through the brochure of your air-conditioner, you will easily understand why
    I am showing all of this to you. The power consumption of the air-conditioner
    will be much higher than what your relays can handle. So, if you try to run your
    air conditioner using the normal relays, then you will surely end up blowing the
    relay. There might be a chance that your appliance will be of a lower current
    rating than your relay. But with any device that has motors in it just keep in
    mind that the initial power consumption of that device is much higher than the
    nominal power consumption. Hence, if your air-conditioner needs 10 ampere nominal,
    then the starting load may be as much as 15 ampere. You must be thinking, it''s
    not a problem, why don''t we just purchase a relay that has a higher rating. Well,
    correct! That''s exactly what we will be doing. But the naming of electronics
    can be tricky at times. The devices that deal with a higher-power higher-voltage
    electro-mechanical switching is generally called contractor instead of relay.
    Technically, they have the same working principal; However, there are construction
    differences, which at this point would not be our concern. So we will be using
    a contractor for the air conditioner switching and a dimmer for the fan speed
    control. Now that this has been cleared up, let''s go ahead and attach the hardware
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/44f748e3-7a93-46e6-afa7-765a6447d0ad.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic used here is pretty basic. Let''s see what it is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we are taking the value of `humidity` and `temperature`. So far so good,
    but can we take it a step further and make it even more intelligent? The previous
    logic must have helped you sleep better, but can we make it just perfect for you?
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple indicators in our body that give us an idea of what the state
    of the body is. For example, if you are tired, you will probably not be walking
    very fast or talking very loud. Instead, you would be doing the opposite! Similarly,
    there are multiple factors that indicate how our sleep cycle is going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these factors are: body temperature, respiration rate, REM sleep, and
    body movements. Measuring the exact body temperature or respiration rate and REM
    sleep is something of a challenge. But when we talk about body movements, I think
    we have already perfected it. So based on the body movements, we will be sensing
    how well we are sleeping and what kind of temperature adjustment is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, whenever someone is sleeping and starts feeling cold, the body
    will go to a fetal position and will move much less. This happens automatically.
    However, when a person is comfortable, there are some inevitable movements such
    as changing sides and movement of arms or legs. This does not happen when a person
    is feeling cold. So with these movements we can figure out whether a person is
    feeling cold or not. Now that we have understood the physiological changes of
    the body, let's try to build a program around it and see what we can achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, firstly, we need to connect the circuit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/48c7ea27-075b-4caa-9601-797e8dc31680.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this is done, go ahead and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what is going on under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you will see is that we have a condition: `if H,= 6 && H<= 22:`.
    This condition will only be true if the time frame is between 10 o'clock in the
    morning and  6 o'clock in the night. That is because this is the time when we
    generally sleep. Hence, the logic under this head will only work if it's time
    to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: The second condition is `if M <= 58`, which will be true only when the time
    is between `0` and `58` minutes. So when the time is `M = 59`, then this condition
    will not work. We will see the reason for having this logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thereafter, we are calculating the time and storing the value in a variable
    called `M`. We are also calculating the humidity and temperature values and storing
    it in variables called `temperature` and `humidity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, in this line, we are implementing a condition which will be true if the
    reading from the PIR is high. That is, there is some motion that will be detected.
    Whenever this happens, the `Movement` variable will be incremented by `1`. Finally,
    we are using the `time.sleep(10)` function to wait for `10` seconds. This is done
    as the PIR might be high for a momentary period. In that case, the condition will
    be true over and over again which in turn will increment the value of `Movement`
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Our purpose of incrementing the value of `Movement` is to count the number of
    times the person has moved. Hence, incrementing it multiples times in one single
    time will defy the objective.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have another condition, which says `if temperature < 28`. Not much explanation
    is needed for when the condition will be true. So whenever the condition is true
    and if the counted number of `Movement` is more than `5`, the value of `Duty`
    will be incremented by `10`. Therefore, we are sending the PWM to the AC dimmer,
    which in turn will increase the speed of the fan. Finally, we are resetting the
    value of `Movement` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: So essentially, we are just counting the number of movements. This movement
    is counted only if the temperature is less than 28° C. If the movement is more
    than `5`, then we will increase the speed of the fan by 10%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous section, the logic will only work when the time is between `0`
    and `58`, that is, the time in which the counting will happen. When the value
    of `M` is `59`, then the condition `if Movement = 0` will be checked, and if true,
    then the value of `Duty` will be decremented by `10`. This in turn will reduce
    the speed of the fan by 10%. Also, once this condition is executed, the value
    of `Movement` will be reset to `0`. So then a new cycle can start for the next
    hour.
  prefs: []
  type: TYPE_NORMAL
- en: Now what it basically means is that counting will happen on an hourly basis.
    If the `Movement` is more than `5` then immediately the value of the `Duty` would
    be increased. However, if that is not the case, then the program will wait until
    the minute approaches the value of `59` and whenever that happens, it will check
    whether there is any movement, in which case, the fan speed will be decreased.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All of this code is very straightforward. If the temperature is less than `22`,
    then the AC will be switched off. Furthermore, if the temperature is equal to
    or more than `24`, and time is between 10:00 p.m. and 6:00 a.m., then the AC will
    be turned on. Finally, if the temperature is more than `27`, then the fan will
    be switch on to 100% speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are making sure by using the condition `for H > 7 && H <20` that
    during this time the AC is always switched off. Also, if `H = 20`, then the AC
    should be turned on so that the room is cooled before you are ready to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you would have understood by now, we can control any AC electrical appliances
    as per our needs. We have understood switching and have also perfected the way
    we can vary the intensity of light and the speed of fans. But did you notice one
    thing? Sooner or later as our system gets more and more complex, the number of
    GPIOs needed will increase. There will come a moment when you will want to have
    more and more devices connected to your Raspberry Pi; however, you will not be
    able to do so due to lack of physical ports.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very common situation in electronics. As always, there is a solution
    for this problem as well. This solution is known as a multiplexer. The basic job
    of a multiplexer is to multiply the number of ports in any computer system. Now
    you must be thinking, how is it able to do so?
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept is extremely simple. Let''s first look at the diagram of a multiplexer
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aea10593-2bf8-4d57-9d45-65505431998a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see that there are two ends to the multiplexer—one
    being the signal output lines and the other opposite to it. The first thing we
    need to understand is that the multiplexer is a bidirectional device, that is,
    it sends the data from the multiplexer to the connected devices and also vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, firstly, we have the power line, which is pretty basic. It is there to
    power up the multiplexer itself. Then, we have **Signal Lines**, which have two
    ports, the **Sig** and **EN**. **EN** stands for enable, which means that until
    the time **EN** is not high, the data communication will not happen either way.
    Then we have something called **Sig**. This is the port that is connected to the
    GPIO of Raspberry Pi for data communication. Next we have the selection line.
    As you can see, we have four ports for it, namely, **S0**, **S1**, **S2**, and **S3**.
    The selection lines have a purpose of selecting a particular port that needs to
    be selected. The following is a table that will clarify what exactly is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **S0** | **S1** | **S3** | **S4** | **Selected output** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | C0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | C1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | C2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | C3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | C4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | C5 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | C6 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | C7 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | C8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | C9 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | C10 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | C11 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | C12 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | C13 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | C14 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | C15 |'
  prefs: []
  type: TYPE_TB
- en: In the preceding table, you can see that by using various logic combinations
    on the selection lines, various lines can be addressed. Let's say, for example,
    we have the following sequence on the selection pins—S0 = 1, S1 = 0, S2 = 1, S3
    = 1\. If this is the input on the selection pins from Raspberry Pi, then the pin
    number C13 will be selected. This basically means that now C13 can communicate
    the data to and from the pin **Sig** for the multiplexer. Also, we must remember
    that the enable pin must be high for the data transfer to happen.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, we can go ahead and address all the 16 pins of the multiplexer.
    Hence, if we see it logically, then by using six pins of Raspberry Pi, we can
    go ahead and utilize 16 GPIOs. Now that we have understood the basics of multiplexing,
    let's go ahead and try using one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d1d03c85-d1df-49df-8adb-5f7c95c895ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the hardware is connected, let''s go ahead and upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, what we are essentially doing is, triggering the selection lines one by
    one to address every single port where the LED is connected. Whenever that happens,
    the LED corresponding to it glows. Also, the reason it glows is because the signal
    port `Sig` is connected to 3.3V of Raspberry Pi. Hence, send a logic high to whichever
    port it is connected to.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the basic ways in which the multiplexer works. This can be incredibly
    useful when we will be using multiple devices and sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we enabled Jarvis to automate your home appliances under different
    conditions, also applying various properties to the system. So go on and try many
    other scenarios under which you can enhance your home automation system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enable Jarvis IoT, thus controlling the appliances
    from your mobile phone using Wi-Fi and the internet.
  prefs: []
  type: TYPE_NORMAL

- en: Making a Robotic Arm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are where most of us have wanted to be since the start of this book.
    Making a robotic arm! In this chapter, we will learn the concepts behind the working
    of a robotic arm. Undoubtedly, we will also be making a robotic arm for our personal
    use as well that can do limitless things for us.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of a robotic arm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you see a human body, then one of the most distinctive parts that makes us
    able to be different than most other species is the arm. It is the part of the
    body that we use to do most of the work.
  prefs: []
  type: TYPE_NORMAL
- en: The human arm is a very complex mechanism of joints and muscles that work in
    tandem to give it the dexterity that we know it for. Take an example of our shoulder
    joint. If you pay attention, then you will notice that it has the ability to move
    up and down, right and left, and even rotate on its own axis, and all this while
    it just has one single joint, which we know as a ball joint.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about a robotic arm on a robot, we are undoubtedly talking about
    a complex arrangement of actuators with the body, otherwise known as a chassis,
    to get the desired motion in a three-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand some of the basic parts of any robotic arm. The first
    parts are the actuators. We can use motors to control the robotic arm; however,
    as we have studied earlier, using the motors we have used before will not be the
    ideal solution for it as it cannot hold its position neither does it have a feedback
    mechanism. So we are left with only one option, that is, to use servo motors.
    As we know, they have a handful of torque and have the ability to know where it
    is and to hold its position for as long as we want.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the robot is the chassis, that is, the part that holds all
    the motors together and provides structural support to the robot. This has to
    be made in such a way that it provides motion in all the desirable axis to any
    given joint. This is important as a single servo can only provide motion in one
    single axis. However, there are multiple places in which complex arrangement can
    be used to make the robot traverse in multiple axes. Also, the chassis should
    be rigid, which is extremely important. As we all know, all the material on this
    planet have certain level of flexibility. Also, the construction of the material
    depends on how noncompliant the material would be. This serves a very important
    purpose of repeatability.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is repeatability? As you might have seen in industries or any manufacturing
    units, the robots are installed and they do the same task over and over again.
    This is possible as the robots are programmed to perform a specific set of functions
    under specific circumstances. Now, let's say that the chassis of the robot is
    not rigid. In such a case, even if the servos are 100% precise and get to the
    exact same position over and over again, still the robot may actually differ from
    its actual goal position. This happens as there may be some flexibility in the
    chassis, which is why the final position may differ. Hence, a right chassis is
    a must. It becomes even more important when we are talking about large robots,
    as even the slightest of deformation can lead to a very large change in the final
    position of the arm.
  prefs: []
  type: TYPE_NORMAL
- en: One very common terminology which we use while talking about the robot arm is
    the end effector. This is basically the end of the robot arm, which will be doing
    all the final work for us. End effector in the case of a real human arm can be
    considered the hand. This is at the top of the arm and all the movement of the
    arm is basically to articulate the position of the hand in a three-dimensional
    space. Also, it is the hand that picks up the objects or does the necessary physical
    action. Hence, the term end effector.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as the robotic arm is moving in a three dimensional space, it becomes a
    real big problem to define the axis in which the motion is happening. Hence, instead
    of using the axis to define the motion, we generally use the type of motion being
    performed, which gives us a realistic idea of what the motion is and in which
    axis it may be on. To analyze the motion, we use the concept of **Yaw Pitch and
    Roll** (**YPR**).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3627647f-ae6b-419e-a164-3f5eaa509cf8.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram will clear most of the doubts about YPR. This concept
    is generally used in aircrafts; however, it is an essential part of a robotic
    hand as well. So, as you can see from the preceding figure, when the nose of the
    plane goes up or down, it will be considered as pitch movement. Similarly, if
    the aircraft changes the heading, then the **Yaw** can be considered to change
    accordingly—the **Yaw** is nothing but the movement of aircraft in the *y* axis.
    Finally, we have something called **Roll**. It is used to understand the angel
    of rotation. As you can see, all these three entities are independent to each
    other and chasing any of it will not have any effect on the other. This concept
    is also useful as no matter what the orientation of the aircraft is, the YPR would
    still be unchanged and very much understandable. Hence, we take this concept straight
    from the aircraft directly to our robots.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, how can we forget about the processing unit? It is the unit that commands
    all the actuators and does the coordination and the decision making. This processing
    unit in our case is Raspberry Pi, which will command all the actuators. All of
    these preceding components make up a robotic arm.
  prefs: []
  type: TYPE_NORMAL
- en: Degrees of freedom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not every robotic arm is the same. They have different load ratings, that is,
    the maximum load that the end effector can take, the speed and reach, that is,
    how far the end effector can reach. However, one very important part of a robotic
    arm is the number of motors it has. So, for every axis, you need at least one
    motor to make the robot traverse in that axis. For example, a human arm has three-dimensional
    freedom in the shoulder joint. Hence, to mimic that joint, you will need a motor
    for every axis, that is, a minimum of three motors are required for the arm to
    move in all the three axis, independently. Similarly, when we talk about the elbow
    joint of our hand, it can only traverse in two dimensions. That is the closing
    and opening of the arm and the finally the rotation of the arm—the elbow does
    not move in the third dimension. Hence, to replicate its motion, we need at least
    two motors, so that we an move the robot in the *w* axis.
  prefs: []
  type: TYPE_NORMAL
- en: From what we have understood so far, we can safely assume that the more the
    number of motors, the more dexterous the robot would also be. This is mostly the
    case; however, you may use multiple motors to make the robot turn in a single
    axis itself. In such a scenario, the basic concept of counting the number of actuators
    to determine the dexterity of the robot will not work. So how do we determine
    how dexterous the robot is?
  prefs: []
  type: TYPE_NORMAL
- en: We have a concept called **degrees of freedom** (**DOF**). If I go by the standard
    definition, then I can be very sure that you will be left confused as to what
    it actually means. If you are not convinced, then try finding out on Google yourself.
    A DOF, in very simple and plain English, is a joint that can independently move
    on any given axis. So, for example, if we are talking about a shoulder joint,
    then we have movement in all the three axis. Hence, the degrees of freedom would
    be three. Now, let's take into consideration the elbow joint of our arm. As it
    can only move in pitch and roll, hence there are two DOFs that we end up with.
    If we connect the shoulder joint with the elbow joint, then the DOF will be added
    up and the whole system would be called to have six DOFs. Keep in mind that this
    definition is a very simplified one. There are multiple complexities that you
    will encounter should you choose to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Now, most of the robotic arms that you will encounter would be having close
    to six DOFs. Though you may say that it is less than what human arms have, in
    practicality, it does most of the work and obviously having less DOFs means less
    number of motors leading to lower cost and obviously lower complexity in programming.
    Hence, we try to use as few DOFs as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a2bb6d91-ba4e-46da-ab66-3d9495652574.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, in the preceding diagram, you can see a typical robotic arm which has six
    DOFs. The base actuator marked by number **1** gives the freedom of rolling and
    altering the pitch. The elbow actuators marked by number **2** add only one DOF
    of the pitch to the robot. Furthermore, joint number **3** is has the ability
    to travel in **Pitch & Roll**. Finally, we have the end actuator as the gripper
    here; the gripper in itself has one DOF. So, cumulatively, we can say that the
    robot is a six-DOF robot.
  prefs: []
  type: TYPE_NORMAL
- en: Power house
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one unit that we have been using in all our projects, but I want to
    emphasize on it in this chapter. This unit is the power unit. The reason we are
    talking about it is because in this chapter we will be controlling multiple servos.
    When we are talking about multiple servos, naturally we will be talking about
    a lot of power consumption. In the robot arm, we have six servo motors. Now, depending
    upon the make and model of the motor, the power consumption will vary. But keeping
    yourself on a safer side and assuming every servo's power consumption to be around
    1 amp would be a good idea. Most of the power supply you would be using might
    not be able to give you this much of burst current. So what should we do?
  prefs: []
  type: TYPE_NORMAL
- en: We can take the easy approach of taking a higher power output. But, instead,
    we can take the unconventional route. We can have a battery that can deliver this
    much of power when needed. But, the question is, will any battery solve our purpose?
    Obviously, the answer would be no.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple types of batteries that exist. These batteries can be distinguished
    based on the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power to weight ratio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum charge and discharge rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chemical composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are covered in detail in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Voltage is the overall potential difference that the battery can create. Every
    battery has a specific voltage that it delivers. One thing to remember is that
    this voltage will vary slightly based on the charge condition of the battery.
    That is, when a 12V battery is fully charged, it may be giving an output of 12.6V.
    However, when it gets fully discharged, it may reach up to 11.4V. So, what battery
    voltage means is the nominal voltage that the battery would be providing.
  prefs: []
  type: TYPE_NORMAL
- en: Capacity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the second parameter is the capacity. Generally, when you buy a battery,
    you will see its capacity in **milliampere hour** (**mAh**) or in **ampere hours**
    (**Ah**). This is a very simple term. Let me explain this term to you using an
    example. Let's say you have a battery with a capacity of 5 Ah. Now, if I draw
    5 amperes continuously for 1 hour, then the battery will be completely discharged.
    On the contrary, if I draw 10 amperes continuously, then the battery will be discharged
    in half an hour. With this, we can also derive the overall power that the battery
    has using the following simple formula: *Overall Power in Watts* = *Nominal Voltage
    of Battery x Overall battery capacity of battery in amperes*
  prefs: []
  type: TYPE_NORMAL
- en: Hence, if you have a battery of 12V, which has a capacity of 10 Ah, then the
    overall capacity in watts will be 120 watts.
  prefs: []
  type: TYPE_NORMAL
- en: Power-to-weight ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weight plays a very crucial role in robotics and if we increase the weight of
    the robot, then the force required to move it can exponentially go up. Hence,
    the concept of power to weight ratio comes into play. We always prefer a battery,
    which is extremely lightweight and delivers a large sum of power in respect to
    the weight. The equation for the power-to-weight ratio can be defined as follows: *Power
    to weight ratio in watt hour/kg* = *Maximum Power in watts / Overall weight of
    battery in kg.*
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's say a battery is providing a power of 500 watts and the weight is
    5 kg, then the power to weight ratio will be 100 Wh/kg. The higher the power to
    weight ratio, the better the battery is.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum charge and discharge rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is perhaps one of the most crucial parts of the battery. Often the batteries
    are capable of running the robot for a span of 1 hour. However, the power consumption
    of robots is not constant. Let's say for 90% of the time, our robotic arm is consuming
    2 amperes of power, so the battery capacity is of 2 Ah. However, at some points
    of time during the operation, the robot needs all the motors to work on peak power.
    The peak power consumption of the robot is around 6 amperes. Now, the question
    is, will the battery of 2 Ah be able to provide 6 amperes power to the robot?
  prefs: []
  type: TYPE_NORMAL
- en: This is a very practical challenge. You may say, it is better to go with a battery
    that is much bigger than a 2 Ah battery. But, as you know, it will increase the
    weight phenomenally. So what's the solution?
  prefs: []
  type: TYPE_NORMAL
- en: There is something called peak discharge current. This is denoted by *C* rating.
    So, if our battery is of 1 C rating then a 2 Ah battery will only be able to give
    us a maximum of 2 Ah of power supply at any given time. However, if the battery
    is of 10 C rating, then it should be able to provide a burst power supply of up
    to 20 amperes. These days, you can find batteries that can give a burst power
    supply of up to 100 C or even more. The reason we have this is because the peak
    power consumption of robots can be exponentially higher than their constant power
    consumption. If, at any point, the battery is not able to pull ample amount of
    power, then the robot would behave erroneously and can even shut down.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this story is the charge rating. This is the maximum charge
    current that you can provide to the battery. It is also denoted by the same C
    rating. So, if the C rating is 0.5, then you can provide a max of 1 ampere of
    charge to a 2 Ah battery.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the fastest you can charge a battery would be in 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Chemical composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of batteries that you can find on the market these
    are broadly segregated by their chemical composition. All of these batteries have
    their own pros and cons. Hence, we cannot say that one is better than the other.
    It is always a trade-off between various factors. The following is a list of batteries
    you can find on the market along with their pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Battery** | **Peak power output** | **Power-to-weight ratio** | **Price**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Wet cell | Low | Extremely low | Cheapest |'
  prefs: []
  type: TYPE_TB
- en: '| Nickel metal hydride | Medium | Low | Cheap |'
  prefs: []
  type: TYPE_TB
- en: '| Lithium ion | High | Good | High |'
  prefs: []
  type: TYPE_TB
- en: '| Lithium polymer | Extremely high | Extremely good | Extremely high |'
  prefs: []
  type: TYPE_TB
- en: As you can see from this table, the peak power output is something which we
    highly want and so is the good power-to-weight ratio; hence, spending a good amount
    of money on a lithium polymer battery makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: These batteries, at a minimum, have a 20 C rating with a power-to-weight ratio
    around five times higher than the normal wet cell batteries. However, they can
    be up to 10 times more expensive than the normal wet cell batteries.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know which batteries to choose for those higher current requirements.
    A lithium polymer battery of 11.1V and 2200 mAh will not cost you more than $20
    and will provide you with immense power that you may never need. So, we have the
    power supply issue sorted. Now it's time to go ahead and make the robotic hand
    operational.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The robotic arm kit is a fairly easy one to procure from eBay or Amazon. This
    is not very difficult to assemble and will require a few hours to prepare. Some
    of the robotic arm kits might not ship with servo motors, in which case, you may
    have to order it separately. I would say go for the kit that comes bundled with
    the servos, as there can be compatibility issues if you choose to order servos
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, these servos will work using PWM and it''s not hard to control
    them either. So, let''s go straight onto it and see what we can do. Once you have
    assembled the robotic arm kit, connect the wires of the servos as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3a2a8a1f-c77f-4279-b01b-093d65b5da18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, firstly, we need to know what are the maximum physical limits of every
    single servo connected on our robot. There are various techniques to do that.
    The very basic one is to measure it physically. This method can be good but you
    won''t be able to ever utilize the full potential of the servo motor as you would
    be having some degree of error in measuring. Hence, the value you put in the servo
    will be slightly less than what you think it can go to. The second method is by
    manually feeding the data and finding out the exact angle. So, let''s go ahead
    with the second way of doing things and upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what this code is doing. This code may look pretty elaborate,
    but what it is doing is extremely simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding line of code, we are printing the statement for the user
    `select servo from 1-6`. When the user enters a value of the servo, this value
    gets stored in a variable `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `if` condition here checks for the value of `j`. If in this line, `j=1`,
    then it will run the code corresponding to the servo number `1`. Inside this code,
    the first line will print `select value to rotate`. Once this is done, the program
    will then wait for user input. Once the user inputs any value, then it will be
    stored in a variable called `I`. Thereafter, using the `cvt_angle(i)` function, the
    value which the user has input into the system will be converted to its corresponding
    duty cycle value. This duty cycle value will be fetched to the `pwm1.ChangeDutyCycle()` argument
    thereby giving the robot that very certain angle in the particular joint that
    you want. Due to the `time.sleep(2)` function, the servo will wait to go over
    to the next line. Thereafter, we are using the line `pwm1.ChangeDutyCycle(cvt_angle(90))`,
    which will bring it back to 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: You may ask, why are we doing this? This is for a very important reason. Let's
    say you have given it a command to go beyond its physical limit. If that's the
    case, then the servo will keep on trying to move in that direction no matter what. However,
    due to the physical constrain, it will not be able to go ahead. Once this happens,
    then, within a few seconds, you will see blue smoke coming out of your servo indicating
    its death. The problem is that making such type of errors is very easy and the
    loss is quite noticeable. Hence, to prevent this, we quickly bring it back to
    the central position where it does not have any possibility of burning up.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as per the preceding code, the same is done for servos 1-6 through the
    robot. Now that you know what is happening, it's time to take a pen and a paper
    and start giving servos the angular values. Do remember that the final goal of
    this code is to find out the maximum limits. So, let's start doing it starting
    from 90 degrees onwards. Give it a value on either side and not down until which
    value you can take it. Make a list on a paper as we will require it for our next
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Making the robot safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous part of the chapter, with our multiple attempts, we have been
    able to find the maximum positions for each of the servos. Now it's time to use
    these values. In this chapter, we will be programming the servos for what its
    absolute maximums are. In this program, we will make sure that servos will never
    need to travel even a degree beyond the defined parameters on both the sides.
    If the user gives a value beyond it, then it will simply choose to ignore the
    user inputs instead of causing self damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s see how to get it done. There are some parts of this program, where
    the numeric values have been bold. These are the values that you need to replace
    with the values which we have noted in the previous section of this chapter. For
    example, for servo 1, the values noted down are `23` and `170` as the maximum
    values for either side. Hence, the change in the code will be from `if a[0] <
    160 and a[0] > 30` to `ifa[0] < 170 and a[0] > 23`. Similarly, for every servo,
    the same procedure has to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, in this code, we have done something very rudimentary. You can safely say
    that all we have done is put the `ChangeDutyCycle()` function inside an `if` statement.
    This `if` statement will govern whether the servo will move or stay still in its
    own position. To some, it may seem very naive to have this program in a special
    section. But, trust me, it is not. This statement will now be used as a part of
    every program from here on. All the code written for the movement of the servos
    will have to check the final values going to the servos through this `if` statement;
    hence, a basic visualization of code is extremely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the explanation is done, it's time for you to give different commands
    and see whether they are working within the safe working limits.
  prefs: []
  type: TYPE_NORMAL
- en: Programming multiple frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we have learned the basics of how to make sure that
    the robot is working under safe limits. In this chapter, we will be looking at
    how a robot can be made to do different activities at a click of a button, instead
    of typing the values one by one.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will need to understand some advanced concepts of motion. Whenever
    you watch any video or play any video games, then you must have come across the
    term **frames per second** (**FPS**). If you haven't heard this term, then let
    me explain it for you. Every video made right now is actually made by still images.
    These still images are captured by cameras that click 25-30 times in a second.
    When these images are played back on the screen at the same rate at which they
    are captured, it forms a smooth video.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in robots, we do have the concept of frames. These frames, however,
    are not images but instead multiple steps that the robot has to follow to achieve
    a specific motion. In a simple robotic program, there could be simply two frames,
    that is, the initial frame and the final frame. These two frames will correspond
    to the initial position or the final position.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the real world, this is not always possible, as whenever the robot
    goes directly from the initial position to the final position, it tends a specific
    path with a specific curvature. However, there can be obstacles in that path or
    this path would not be desired as the path that needs to be followed could be
    a different one. Hence, we need frames. These frames not only define the robot's
    motion from the initial position to the final position, but also break down the
    transition from these two positions into multiple steps making the robot follow
    the desired path.
  prefs: []
  type: TYPE_NORMAL
- en: This can be referred as frame programming, which we will cover in this chapter.
    One thing to keep in mind is that more the number of frames, smoother will be
    the functioning of the robot. Do you remember the CCTV footage we saw? We could
    say it's not smooth and has a lot of jerkiness. This is due to the low frame rate
    of the CCTV camera. Instead of working on 30 FPS, they work on 15 FPS. This is
    done to reduce the storage space of the video. However, if you see the latest
    videos, there are some games and videos with much higher frame rate than normal.
    Some of our latest camera works on 60 FPS, making the video even smoother and
    enjoyable to watch. The same will be the case with the robot. The more the number
    of frames, the smoother and controlled the motion would be. However, make sure
    you don't go into overkill.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to move from one position to another, we will have to put the values of
    the angles of every single servos in the very beginning. Once fetched, it will
    automatically start to execute these values one by one. To do this, go ahead and
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, you can see that we have replicated the previous program with
    some very minor changes. So, let''s see what these changes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are taking the input values for each servo and storing it in a different
    list. For servo 1, the list `a` will be used; similarly, `b` will be used for
    servo 2, and so on until `f`. In the preceding lines of code, the robot will prompt
    the user to fill in the six frame values for `motor 1`. Then, it will ask six
    values for `motor 2` and similarly until `motor 6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The entire program for giving PWM to the servo is concentrated in this for loop.
    This loop will check the value of `i` and increment it every time. The value of
    `i` will start from `1` and the loop will run and increment the value of `i` until
    it reaches `6`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line of the program, the value contained in the list is headed based
    on the value of `1`. So, for the first time it will read the value of `a[1]`,
    which will correspond to the first value of the list `a[]`. This value should
    be between the safe working limits, hence the `if` loop. If it is within safe
    working limits, then the program in the `if` condition will work, else it won''t.
    Inside the `if` loop, we have a simple statement: `pwm1.ChangeDutyCycle(cvt_angle(a[I]))`.
    This will simply take the value of `a[1]` and convert it into the corresponding
    PWM value and fetch it to the `ChangeDutyCycle()` function, which will change
    the PWM for servo 1.'
  prefs: []
  type: TYPE_NORMAL
- en: A similar program is made for the rest of the servos as well going on from servo
    1 to servo 6\. Hence, all of these will read the values of their corresponding
    list one by one and change the angle of the servo the way the user has programmed
    it. Furthermore, as the loop gets executed, the value of `i` will increase, hence
    making the program read the different values fetched in the list. Every value
    of the servo in the list will correspond to a different frame, hence parsing the
    robot through it.
  prefs: []
  type: TYPE_NORMAL
- en: So go ahead and have some fun making your robot do some awesome moves. Just
    take care that you be gentle to it!
  prefs: []
  type: TYPE_NORMAL
- en: Speed control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's amazing to have made a robotic arm so easily, and with just a bit of code,
    we are now able to control it the way we want. However, there is one problem you
    might have noticed, that is, the robot is moving the way we want but not at the
    speed at which we want it to move. This is a very common problem while using the
    digital PWM-based servos.
  prefs: []
  type: TYPE_NORMAL
- en: These servos do not have a built-in speed control. Their control system is programmed
    to move the servo as fast as they can to reach the goal position. Hence, to control
    the speed, we will have to play with the program itself and give it a smooth linear
    progression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The speed control can be done through a few different techniques. So, without
    much talking, let''s go and see the code. Before you write it, read it and go
    through the code once and then see the following explanation to it. Thereafter,
    you will have a better idea of what we are doing. This will make writing the code
    faster and easier. So, let''s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, there are quite a few things. We should go through them one
    by one to have an understanding of it. So, let''s see what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined six new variables with the name `prev0` to `prev5` and
    all of them have been allowed a value of `90`. The term `prev` here stands for
    previous, so this will be there to indicate the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After the code line `for i in range 6`, we have the preceding line of code,
    which is basically checking the value of `a[i]` with `prev0`. Similarly, it is
    checking the values of `b[i]` with `prev1` and so on. Until the time all of these
    are not true the `while` loop will be true and will loop the program inside it
    until the condition is not false. That is, all the `prev` values are exactly equal
    to the values of the corresponding values of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this may seem a little odd to you, but, trust me, it will be quite useful,
    which we will see in a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, here comes the real deal. This is the main program that will control the
    speed of the servo. In this, the first line is simple; it will check whether the
    value given to it is valid, that is, between the safe limits. Once that is done,
    it will then check whether the value of `a[Ii]` is less than or greater than the
    previous value. If it is greater than `a[i]`, then it will take in the previous
    value and decrement it with the speed specified by the user. If it is less than
    the value of `a[i]`, then it will increment the previous value with the speed
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you look at it, the code is simply incrementing or decrementing the previous
    value every time the `while` loop is running. Now, the `while` loop will run until
    the value of `prev` is equal to the corresponding list value. That is, the loop
    will keep incrementing the value until it reaches the specified position.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, lower the value of the speed, lower will be the increments every single
    time, thereby slowing down the speed all together.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same process which will happen for all other servos as well. It
    may sound very complicated, but it is not! Programming is easy and will continue
    to remain easy each time you break it down into small pieces and understand them
    one by one!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the basics of robotic arm, its power source,
    and its programming. With a very simple program, we were able to find out the
    limits of the servos and then apply these limits to make sure the servo did not
    damage itself. We got a basic idea of what frames are and did some programming
    based on frames. Finally, we also went ahead and controlled the speed of the servo
    using our very own program on a basic level.
  prefs: []
  type: TYPE_NORMAL

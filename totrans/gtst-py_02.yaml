- en: Built-in Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Data! Data! Data!" he cried impatiently. "I can''t make bricks without clay."– Sherlock
    Holmes – The Adventure of the Copper Beeches'
  prefs: []
  type: TYPE_NORMAL
- en: Everything you do with a computer is managing data. Data comes in many different
    shapes and flavors. It's the music you listen to, the movies you stream, the PDFs
    you open. Even the source of the chapter you're reading at this very moment is
    just a file, which is data.
  prefs: []
  type: TYPE_NORMAL
- en: Data can be simple, an integer number to represent an age, or complex, like
    an order placed on a website. It can be about a single object or about a collection
    of them. Data can even be about data, that is, metadata. Data that describes the
    design of other data structures or data that describes application data or its
    context. In Python, *objects are abstraction for data*, and Python has an amazing
    variety of data structures that you can use to represent data, or combine them
    to create your own custom data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python objects' structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability and immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in data types: numbers, strings, sequences, collections, and mapping
    types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collections module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the specifics, I want you to be very clear about objects
    in Python, so let's talk a little bit more about them. As we already said, everything
    in Python is an object. But what really happens when you type an instruction like
    `age = 42` in a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: If you go to [http://pythontutor.com/](http://pythontutor.com/), you can type
    that instruction into a text box and get its visual representation. Keep this
    website in mind; it's very useful to consolidate your understanding of what goes
    on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens is that an object is created. It gets an `id`, the `type`
    is set to `int` (integer number), and the `value` to `42`. A name `age` is placed
    in the global namespace, pointing to that object. Therefore, whenever we are in
    the global namespace, after the execution of that line, we can retrieve that object
    by simply accessing it through its name: `age`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to move house, you would put all the knives, forks, and spoons
    in a box and label it *cutlery*. Can you see it''s exactly the same concept? Here''s
    a screenshot of what it may look like (you may have to tweak the settings to get
    to the same view):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1fc9375-219c-4c7e-a1fa-76f8e7b8e03b.png)'
  prefs: []
  type: TYPE_IMG
- en: So, for the rest of this chapter, whenever you read something such as `name
    = some_value`, think of a name placed in the namespace that is tied to the scope
    in which the instruction was written, with a nice arrow pointing to an object
    that has an `id`, a `type`, and a `value`. There is a little bit more to say about
    this mechanism, but it's much easier to talk about it over an example, so we'll
    get back to this later.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable or immutable? That is the question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A first fundamental distinction that Python makes on data is about whether or
    not the value of an object changes. If the value can change, the object is called
    **mutable**, while if the value cannot change, the object is called **immutable**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important that you understand the distinction between mutable and
    immutable because it affects the code you write, so here''s a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, on the line `#A`, have I changed the value of age? Well,
    no. But now it''s `43` (I hear you say...). Yes, it''s `43`, but `42` was an integer
    number, of the type `int`, which is immutable. So, what happened is really that
    on the first line, `age` is a name that is set to point to an `int` object, whose
    value is `42`. When we type `age = 43`, what happens is that another object is
    created, of the type `int` and value `43` (also, the `id` will be different),
    and the name `age` is set to point to it. So, we didn''t change that `42` to `43`.
    We actually just pointed `age` to a different location: the new `int` object whose
    value is `43`. Let''s see the same code also printing the IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we print the IDs by calling the built-in `id` function. As you
    can see, they are different, as expected. Bear in mind that `age` points to one
    object at a time: `42` first, then `43`. Never together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the same example using a mutable object. For this example,
    let''s just use a `Person` object, that has a property `age` (don''t worry about
    the class declaration for now; it''s there only for completeness):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I set up an object `fab` whose `type` is `Person` (a custom class).
    On creation, the object is given the `age` of `42`. I'm printing it, along with
    the object `id`, and the ID of `age` as well. Notice that, even after I change
    `age` to be `25`, the ID of `fab` stays the same (while the ID of `age` has changed,
    of course). Custom objects in Python are mutable (unless you code them not to
    be). Keep this concept in mind; it's very important. I'll remind you about it
    throughout the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by exploring Python's built-in data types for numbers. Python was
    designed by a man with a master's degree in mathematics and computer science,
    so it's only logical that it has amazing support for numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python integers have an unlimited range, subject only to the available virtual
    memory. This means that it doesn''t really matter how big a number you want to
    store is: as long as it can fit in your computer''s memory, Python will take care
    of it. Integer numbers can be positive, negative, and 0 (zero). They support all
    the basic mathematical operations, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should be easy to understand. Just notice one important
    thing: Python has two division operators, one performs the so-called **true division**
    (`/`), which returns the quotient of the operands, and the other one, the so-called
    **integer division** (`//`), which returns the *floored* quotient of the operands.
    It might be worth noting that in Python 2 the division operator `/` behaves differently
    than in Python 3\. See how that is different for positive and negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interesting example. If you were expecting a `-1` on the last line,
    don''t feel bad, it''s just the way Python works. The result of an integer division
    in Python is always rounded towards minus infinity. If, instead of flooring, you
    want to truncate a number to an integer, you can use the built-in `int` function,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the truncation is done toward `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an operator to calculate the remainder of a division. It''s called
    a modulo operator, and it''s represented by a percentage (`%`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice feature introduced in Python 3.6 is the ability to add underscores
    within number literals (between digits or base specifiers, but not leading or
    trailing). The purpose is to help make some numbers more readable, like for example `1_000_000_000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean algebra is that subset of algebra in which the values of the variables
    are the truth values: true and false. In Python, `True` and `False` are two keywords
    that are used to represent truth values. Booleans are a subclass of integers,
    and behave respectively like `1` and `0`. The equivalent of the `int` class for
    Booleans is the `bool` class, which returns either `True` or `False`. Every built-in
    Python object has a value in the Boolean context, which means they basically evaluate
    to either `True` or `False` when fed to the `bool` function. We''ll see all about
    this in [Chapter 3](ef39b6a7-bb42-4484-84a1-56dd5375ca64.xhtml), *Iterating and
    Making Decisions*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean values can be combined in Boolean expressions using the logical operators
    `and`, `or`, and `not`. Again, we''ll see them in full in the next chapter, so
    for now let''s just see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `True` and `False` are subclasses of integers when you try
    to add them. Python upcasts them to integers and performs the addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Upcasting** is a type conversion operation that goes from a subclass to its
    parent. In the example presented here, `True` and `False`, which belong to a class
    derived from the integer class, are converted back to integers when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Real numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Real numbers, or floating point numbers, are represented in Python according
    to the IEEE 754 double-precision binary floating-point format, which is stored
    in 64 bits of information divided into three sections: sign, exponent, and mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quench your thirst for knowledge about this format on Wikipedia: [http://en.wikipedia.org/wiki/Double-precision_floating-point_format](http://en.wikipedia.org/wiki/Double-precision_floating-point_format).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, programming languages give coders two different formats: single and
    double precision. The former takes up 32 bits of memory, and the latter 64\. Python
    supports only the double format. Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the calculation of the area, I wrapped the `radius ** 2` within braces. Even
    though that wasn't necessary because the power operator has higher precedence
    than the multiplication one, I think the formula reads more easily like that.
    Moreover, should you get a slightly different result for the area, don't worry.
    It might depend on your OS, how Python was compiled, and so on. As long as the
    first few decimal digits are correct, you know it's a correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sys.float_info` struct sequence holds information about how floating point
    numbers will behave on your system. This is what I see on my box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a few considerations here: we have 64 bits to represent float numbers.
    This means we can represent at most `2 ** 64 == 18,446,744,073,709,551,616` numbers
    with that amount of bits. Take a look at the `max` and `epsilon` values for the
    float numbers, and you''ll realize it''s impossible to represent them all. There
    is just not enough space, so they are approximated to the closest representable
    number. You probably think that only extremely big or extremely small numbers
    suffer from this issue. Well, think again and try the following in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What does this tell you? It tells you that double precision numbers suffer from
    approximation issues even when it comes to simple numbers like `0.1` or `0.3`.
    Why is this important? It can be a big problem if you're handling prices, or financial
    calculations, or any kind of data that needs not to be approximated. Don't worry,
    Python gives you the **decimal** type, which doesn't suffer from these issues;
    we'll see them in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python gives you complex numbers support out of the box. If you don't know what
    complex numbers are, they are numbers that can be expressed in the form *a + ib*
    where *a* and *b* are real numbers, and *i* (or *j* if you're an engineer) is
    the imaginary unit, that is, the square root of *-1*. *a* and *b* are called,
    respectively, the *real* and *imaginary* part of the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually unlikely you''ll be using them, unless you''re coding something
    scientific. Let''s see a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Fractions and decimals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish the tour of the number department with a look at fractions and
    decimals. Fractions hold a rational numerator and denominator in their lowest
    forms. Let''s see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Although they can be very useful at times, it's not that common to spot them
    in commercial software. Much easier instead, is to see decimal numbers being used
    in all those contexts where precision is everything; for example, in scientific
    and financial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that arbitrary precision decimal numbers come at
    a price in performance, of course. The amount of data to be stored for each number
    is far greater than it is for fractions or floats as well as the way they are
    handled, which causes the Python interpreter much more work behind the scenes.
    Another interesting thing to note is that you can get and set the precision by
    accessing `decimal.getcontext().prec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example with decimal numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we construct a `Decimal` number from a `float`, it takes on
    all the approximation issues `float` may come from. On the other hand, when the
    `Decimal` has no approximation issues (for example, when we feed an `int` or a
    `string` representation to the constructor), then the calculation has no quirky
    behavior. When it comes to money, use decimals.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to built-in numeric types. Let's now look at
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with immutable sequences: strings, tuples, and bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings and bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Textual data in Python is handled with `str` objects, more commonly known as
    **strings**. They are immutable sequences of **Unicode code points**. Unicode
    code points can represent a character, but can also have other meanings, such
    as formatting data, for example. Python, unlike other languages, doesn't have
    a `char` type, so a single character is rendered simply by a string of length
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unicode is an excellent way to handle data, and should be used for the internals
    of any application. When it comes to storing textual data though, or sending it
    on the network, you may want to encode it, using an appropriate encoding for the
    medium you''re using. The result of an encoding produces a `bytes` object, whose
    syntax and behavior is similar to that of strings. String literals are written
    in Python using single, double, or triple quotes (both single or double). If built
    with triple quotes, a string can span on multiple lines. An example will clarify
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In `#A` and `#B`, we print `str4`, first implicitly, and then explicitly, using
    the `print` function. A nice exercise would be to find out why they are different.
    Are you up to the challenge? (hint: look up the `str` function.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings, like any sequence, have a length. You can get this by calling the
    `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Encoding and decoding strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `encode`/`decode` methods, we can encode Unicode strings and decode
    bytes objects. **UTF-8** is a variable length character encoding, capable of encoding
    all possible Unicode code points. It is the dominant encoding for the web. Notice
    also that by adding a literal `b` in front of a string declaration, we''re creating
    a *bytes* object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When manipulating sequences, it's very common to have to access them at one
    precise position (indexing), or to get a subsequence out of them (slicing). When
    dealing with immutable sequences, both operations are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'While indexing comes in one form, a zero-based access to any position within
    the sequence, slicing comes in different forms. When you get a slice of a sequence,
    you can specify the `start` and `stop` positions, and the `step`. They are separated
    with a colon (`:`) like this: `my_sequence[start:stop:step]`. All the arguments
    are optional, `start` is inclusive, and `stop` is exclusive. It''s much easier
    to show an example, rather than explain them further in words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Of all the lines, the last one is probably the most interesting. If you don't
    specify a parameter, Python will fill in the default for you. In this case, `start`
    will be the start of the string, `stop` will be the end of the string, and `step`
    will be the default `1`. This is an easy and quick way of obtaining a copy of
    the string `s` (same value, but different object). Can you find a way to get the
    reversed copy of a string using slicing (don't look it up; find it for yourself)?
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the features strings have is the ability to be used as a template. There
    are several different ways of formatting a string, and for the full list of possibilities,
    I encourage you to look up the documentation. Here are some common examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you can see four different ways of formatting stings.
    The first one, which relies on the `%` operator, is deprecated and shouldn't be
    used any more. The current, modern way to format a string is by using the `format` string
    method. You can see, from the different examples, that a pair of curly braces
    acts as a placeholder within the string. When we call `format`, we feed it data
    that replaces the placeholders. We can specify indexes (and much more) within
    the curly braces, and even names, which implies we'll have to call `format` using
    keyword arguments instead of positional ones.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `greet_positional_idx` is rendered differently by feeding different
    data to the call to `format`. Apparently, I'm into Python and coffee... big surprise!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last feature I want to show you is a relatively new addition to Python
    (Version 3.6) and it''s called **formatted string literals**. This feature is
    quite cool: strings are prefixed with `f`, and contain replacement fields surrounded
    by curly braces. Replacement fields are expressions evaluated at runtime, and
    then formatted using the `format` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Check out the official documentation to learn everything about string formatting
    and how powerful it can be.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last immutable sequence type we''re going to see is the tuple. A **tuple**
    is a sequence of arbitrary Python objects. In a tuple, items are separated by
    commas. They are used everywhere in Python, because they allow for patterns that
    are hard to reproduce in other languages. Sometimes tuples are used implicitly;
    for example, to set up multiple variables on one line, or to allow a function
    to return multiple different objects (usually a function returns one object only,
    in many other languages), and even in the Python console, you can use tuples implicitly
    to print multiple elements with one single instruction. We''ll see examples for
    all these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the membership operator `in` can also be used with lists, strings,
    dictionaries, and, in general, with collection and sequence objects.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to create a tuple with one item, we need to put that comma after
    the item. The reason is that without the comma that item is just itself wrapped
    in braces, kind of in a redundant mathematical expression. Notice also that on
    assignment, braces are optional so `my_tuple = 1, 2, 3` is the same as `my_tuple
    = (1, 2, 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that tuple assignment allows us to do, is *one-line swaps*, with
    no need for a third temporary variable. Let''s see first a more traditional way
    of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s see how we would do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the line that shows you the Pythonic way of swapping two values.
    Do you remember what I wrote in [Chapter 1](1bcb5c5b-39cb-4561-846f-363111c7a2bc.xhtml),
    *A Gentle Introduction to Python*? A Python program is typically one-fifth to
    one-third the size of equivalent Java or C++ code, and features like one-line
    swaps contribute to this. Python is elegant, where elegance in this context also
    means economy.
  prefs: []
  type: TYPE_NORMAL
- en: Because they are immutable, tuples can be used as keys for dictionaries (we'll
    see this shortly). To me, tuples are Python's built-in data that most closely
    represent a mathematical vector. This doesn't mean that this was the reason for
    which they were created though. Tuples usually contain an heterogeneous sequence
    of elements, while on the other hand, lists are most of the times homogeneous.
    Moreover, tuples are normally accessed via unpacking or indexing, while lists
    are usually iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutable sequences differ from their immutable sisters in that they can be changed
    after creation. There are two mutable sequence types in Python: lists and byte
    arrays. I said before that the dictionary is the king of data structures in Python.
    I guess this makes the list its rightful queen.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python lists are mutable sequences. They are very similar to tuples, but they
    don''t have the restrictions of immutability. Lists are commonly used to storing
    collections of homogeneous objects, but there is nothing preventing you from store
    heterogeneous collections as well. Lists can be created in many different ways.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, I showed you how to create a list using different techniques.
    I would like you to take a good look at the line that says `Python is magic`,
    which I am not expecting you to fully understand at this point (unless you cheated
    and you're not a novice!). That is called a **list ****comprehension**, a very
    powerful functional feature of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating lists is good, but the real fun comes when we use them, so let''s
    see the main methods they gift us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives you a roundup of a list''s main methods. I want to
    show you how powerful they are, using `extend` as an example. You can extend lists
    using any sequence type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what are the most common operations you can do with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines in the preceding code are quite interesting because they
    introduce us to a concept called **operator ****overloading**. In short, it means
    that operators such as `+`, `-`. `*`, `%`, and so on, may represent different
    operations according to the context they are used in. It doesn't make any sense
    to sum two lists, right? Therefore, the `+` sign is used to concatenate them.
    Hence, the `*` sign is used to concatenate the list to itself according to the
    right operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a step further and see something a little more interesting.
    I want to show you how powerful the `sorted` method can be and how easy it is
    in Python to achieve results that require a great deal of effort in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code deserves a little explanation. First of all, `a` is a list
    of tuples. This means each element in `a` is a tuple (a 2-tuple, to be precise).
    When we call `sorted(some_list)`, we get a sorted version of `some_list`. In this
    case, the sorting on a 2-tuple works by sorting them on the first item in the
    tuple, and on the second when the first one is the same. You can see this behavior
    in the result of `sorted(a)`, which yields `[(1, 2), (1, 3), ...]`. Python also
    gives us the ability to control which element(s) of the tuple the sorting must
    be run against. Notice that when we instruct the `sorted` function to work on
    the first element of each tuple (by `key=itemgetter(0)`), the result is different:
    `[(1, 3), (1, 2), ...]`. The sorting is done only on the first element of each
    tuple (which is the one at position 0). If we want to replicate the default behavior
    of a simple `sorted(a)` call, we need to use `key=itemgetter(0, 1)`, which tells
    Python to sort first on the elements at position 0 within the tuples, and then
    on those at position 1\. Compare the results and you''ll see they match.'
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, I included an example of sorting only on the elements at position
    1, and the same but in reverse order. If you have ever seen sorting in Java, I
    expect you to be quite impressed at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: The Python sorting algorithm is very powerful, and it was written by Tim Peters
    (we've already seen this name, can you recall when?). It is aptly named **Timsort**,
    and it is a blend between **merge** and **insertion ****sort** and has better
    time performances than most other algorithms used for mainstream programming languages.
    Timsort is a stable sorting algorithm, which means that when multiple records
    have the same key, their original order is preserved. We've seen this in the result
    of `sorted(a, key=itemgetter(0))`, which has yielded `[(1, 3), (1, 2), ...]`,
    in which the order of those two tuples has been preserved because they have the
    same value at position 0.
  prefs: []
  type: TYPE_NORMAL
- en: Byte arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To conclude our overview of mutable sequence types, let's spend a couple of
    minutes on the `bytearray` type. Basically, they represent the mutable version
    of `bytes` objects. They expose most of the usual methods of mutable sequences
    as well as most of the methods of the `bytes` type. Items are integers in the
    range [0, 256).
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to intervals, I''m going to use the standard notation for open/closed
    ranges. A square bracket on one end means that the value is included, while a
    round brace means it''s excluded. The granularity is usually inferred by the type
    of the edge elements so, for example, the interval [3, 7] means all integers between
    3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and
    7 exclusive (hence 4, 5, and 6). Items in a `bytearray` type are integers between
    0 and 256; 0 is included, 256 is not. One reason intervals are often expressed
    like this is to ease coding. If we break a range *[a, b)* into *N* consecutive
    ranges, we can easily represent the original one as a concatenation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[a,k[1])+[k[1],k[2])+[k[2],k[3])+...+[k[N-1],b)*'
  prefs: []
  type: TYPE_NORMAL
- en: The middle points (*k[i]*) being excluded on one end, and included on the other
    end, allow for easy concatenation and splitting when intervals are handled in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example with the `bytearray `type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, there are a few ways to create a `bytearray`
    object. They can be useful in many situations; for example, when receiving data
    through a socket, they eliminate the need to concatenate data while polling, hence
    they can prove to be very handy. On the line `#A`, I created a `bytearray` named
    as `name` from the bytes literal `b'Lina'` to show you how the `bytearray` object
    exposes methods from both sequences and strings, which is extremely handy. If
    you think about it, they can be considered as mutable strings.
  prefs: []
  type: TYPE_NORMAL
- en: Set types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python also provides two set types, `set` and `frozenset`. The `set` type is
    mutable, while `frozenset` is immutable. They are unordered collections of immutable
    objects. **Hashability** is a characteristic that allows an object to be used
    as a set member as well as a key for a dictionary, as we'll see very soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the official documentation: <q>An object is hashable if it has a hash
    value which never changes during its lifetime, and can be compared to other objects. Hashability
    makes an object usable as a dictionary key and a set member, because these data
    structures use the hash value internally. All of Python’s immutable built-in objects
    are hashable while mutable containers are not.</q>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects that compare equally must have the same hash value. Sets are very commonly
    used to test for membership, so let''s introduce the `in` operator in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see two different ways to create a set. One creates
    an empty set and then adds elements one at a time. The other creates the set using
    a list of numbers as an argument to the constructor, which does all the work for
    us. Of course, you can create a set from a list or tuple (or any iterable) and
    then you can add and remove members from the set as you please.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at iterable objects and iteration in the next chapter. For now, just
    know that iterable objects are objects you can iterate on in a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating a set is by simply using the curly braces notation,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice I added some duplication to emphasize that the resulting set won''t
    have any. Let''s see an example about the immutable counterpart of the set type,
    `frozenset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `frozenset` objects are quite limited in respect of their mutable
    counterpart. They still prove very effective for membership test, union, intersection,
    and difference operations, and for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping types – dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the built-in Python data types, the dictionary is easily the most interesting
    one. It's the only standard mapping type, and it is the backbone of every Python
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary maps keys to values. Keys need to be hashable objects, while values
    can be of any arbitrary type. Dictionaries are mutable objects. There are quite
    a few different ways to create a dictionary, so let me give you a simple example
    of how to create a dictionary equal to `{''A'': 1, ''Z'': -1}` in five different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you noticed those double equals? Assignment is done with one equal, while
    to check whether an object is the same as another one (or five in one go, in this
    case), we use double equals. There is also another way to compare objects, which
    involves the `is` operator, and checks whether the two objects are the same (if
    they have the same ID, not just the value), but unless you have a good reason
    to use it, you should use the double equals instead. In the preceding code, I
    also used one nice function: `zip`. It is named after the real-life zip, which
    glues together two things taking one element from each at a time. Let me show
    you an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, I have created the same list in two different ways,
    one more explicit, and the other a little bit more Pythonic. Forget for a moment
    that I had to wrap the `list` constructor around the `zip` call (the reason is
    because `zip` returns an iterator, not a `list`, so if I want to see the result
    I need to exhaust that iterator into something—a list in this case), and concentrate
    on the result. See how `zip` has coupled the first elements of its two arguments
    together, then the second ones, then the third ones, and so on and so forth? Take
    a look at your pants (or at your purse, if you're a lady) and you'll see the same
    behavior in your actual zip. But let's go back to dictionaries and see how many
    wonderful methods they expose for allowing us to manipulate them as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice how accessing keys of a dictionary, regardless of the type of operation
    we're performing, is done through square brackets. Do you remember strings, lists,
    and tuples? We were accessing elements at some position through square brackets
    as well, which is yet another example of Python's consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now three special objects called dictionary views: `keys`, `values`,
    and `items`. These objects provide a dynamic view of the dictionary entries and
    they change when the dictionary changes. `keys()` returns all the keys in the
    dictionary, `values()` returns all the values in the dictionary, and `items()`
    returns all the *(key, value)* pairs in the dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation: "*Keys and values are iterated over
    in an arbitrary order which is non-random, varies across Python implementations,
    and depends on the dictionary’s history of insertions and deletions. If keys,
    values and items views are iterated over with no intervening modifications to
    the dictionary, the order of items will directly correspond.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough with this chatter; let''s put all this down into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to notice in the preceding code. First, notice how we're
    creating a dictionary by iterating over the zipped version of the string `'hello'`
    and the list `[0, 1, 2, 3, 4]`. The string `'hello'` has two `'l'` characters
    inside, and they are paired up with the values `2` and `3` by the `zip` function.
    Notice how in the dictionary, the second occurrence of the `'l'` key (the one
    with value `3`), overwrites the first one (the one with value `2`). Another thing
    to notice is that when asking for any view, the original order is now preserved,
    while before Version 3.6 there was no guarantee of that.
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.6, the `dict` type has been reimplemented to use a more compact
    representation. This resulted in dictionaries using 20% to 25% less memory when
    compared to Python 3.5\. Moreover, in Python 3.6, as a side effect, dictionaries
    are natively ordered. This feature has received such a welcome from the community
    that in 3.7 it has become a legit feature of the language rather than an implementation
    side effect. A `dict` is ordered if it remembers the order in which keys were
    first inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how these views are fundamental tools when we talk about iterating
    over collections. Let''s take a look now at some other methods exposed by Python''s
    dictionaries; there''s plenty of them and they are very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All these methods are quite simple to understand, but it''s worth talking about
    that `None`, for a moment. Every function in Python returns `None`, unless the
    `return` statement is explicitly used to return something else, but we''ll see
    this when we explore functions. `None` is frequently used to represent the absence
    of a value, and it is quite commonly used as a default value for arguments in
    function declaration. Some inexperienced coders sometimes write code that returns
    either `False` or `None`. Both `False` and `None` evaluate to `False` in a Boolean
    context so it may seem there is not much difference between them. But actually,
    I would argue there is quite an important difference: `False` means that we have
    information, and the information we have is `False`. `None` means *no information*.
    And no information is very different from information that is `False`. In layman''s
    terms, if you ask your mechanic,  *Is my car ready?*, there is a big difference
    between the answer, *No, it''s not* (`False`) and, *I have no idea* (`None`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last method I really like about dictionaries is `setdefault`. It behaves
    like `get`, but also sets the key with the given value if it is not there. Let''s
    see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re now at the end of this tour. Test your knowledge about dictionaries
    by trying to foresee what `d` looks like after this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if you don't get it immediately. I just wanted to encourage you
    to experiment with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our tour of built-in data types. Before I discuss some considerations
    about what we've seen in this chapter, I want to take a peek briefly at the `collections`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The collections module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Python general purpose built-in containers (`tuple`, `list`, `set`, and
    `dict`) aren''t enough, we can find specialized container datatypes in the `collections`
    module. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | Factory function for creating tuple subclasses with named
    fields |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | List-like container with fast appends and pops on either end |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | Dictionary-like class for creating a single view of multiple
    mappings |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | Dictionary subclass for counting hashable objects |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | Dictionary subclass that remembers the order entries were
    added |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | Dictionary subclass that calls a factory function to supply
    missing values |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict` | Wrapper around dictionary objects for easier dictionary subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UserList` | Wrapper around list objects for easier list subclassing |'
  prefs: []
  type: TYPE_TB
- en: '| `UserString` | Wrapper around string objects for easier string subclassing
    |'
  prefs: []
  type: TYPE_TB
- en: We don't have the room to cover all of them, but you can find plenty of examples
    in the official documentation, so here I'll just give a small example to show
    you `namedtuple`, `defaultdict`, and `ChainMap`.
  prefs: []
  type: TYPE_NORMAL
- en: namedtuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `namedtuple` is a tuple-like object that has fields accessible by attribute
    lookup as well as being indexable and iterable (it''s actually a subclass of `tuple`).
    This is sort of a compromise between a full-fledged object and a tuple, and it
    can be useful in those cases where you don''t need the full power of a custom
    object, but you want your code to be more readable by avoiding weird indexing.
    Another use case is when there is a chance that items in the tuple need to change
    their position after refactoring, forcing the coder to refactor also all the logic
    involved, which can be very tricky. As usual, an example is better than a thousand
    words (or was it a picture?). Say we are handling data about the left and right
    eyes of a patient. We save one value for the left eye (position 0) and one for
    the right eye (position 1) in a regular tuple. Here''s how that might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s pretend we handle `vision` objects all the time, and at some point
    the designer decides to enhance them by adding information for the combined vision,
    so that a `vision` object stores data in this format: *(left eye, combined, right
    eye)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you see the trouble we''re in now? We may have a lot of code that depends
    on `vision[0]` being the left eye information (which it still is) and `vision[1]`
    being the right eye information (which is no longer the case). We have to refactor
    our code wherever we handle these objects, changing `vision[1]` to `vision[2]`,
    and it can be painful. We could have probably approached this a bit better from
    the beginning, by using a `namedtuple`. Let me show you what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If within our code, we refer to the left and right eyes using `vision.left`
    and `vision.right`, all we need to do to fix the new design issue is to change
    our factory and the way we create instances. The rest of the code won''t need
    to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can see how convenient it is to refer to those values by name rather than
    by position. After all, a wise man once wrote, *Explicit is better than implicit* (can
    you recall where? Think *Zen* if you can't...). This example may be a little extreme;
    of course, it's not likely that our code designer will go for a change like this,
    but you'd be amazed to see how frequently issues similar to this one happen in
    a professional environment, and how painful it is to refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `defaultdict` data type is one of my favorites. It allows you to avoid
    checking if a key is in a dictionary by simply inserting it for you on your first
    access attempt, with a default value whose type you pass on creation. In some
    cases, this tool can be very handy and shorten your code a little. Let''s see
    a quick example. Say we are updating the value of `age`, by adding one year. If
    `age` is not there, we assume it was `0` and we update it to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see how it would work with a `defaultdict` data type. The second
    line is actually the short version of a four-lines-long `if` clause that we would
    have to write if dictionaries didn''t have the `get` method (we''ll see all about
    `if` clauses in [Chapter 3](ef39b6a7-bb42-4484-84a1-56dd5375ca64.xhtml), *Iterating
    and Making Decisions)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we just need to instruct the `defaultdict` factory that we want an
    `int` number to be used in case the key is missing (we'll get `0`, which is the
    default for the `int` type). Also, notice that even though in this example there
    is no gain on the number of lines, there is definitely a gain in readability,
    which is very important. You can also use a different technique to instantiate
    a `defaultdict` data type, which involves creating a factory object. To dig deeper,
    please refer to the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ChainMap` is an extremely nice data type which was introduced in Python 3.3\.
    It behaves like a normal dictionary but according to the Python documentation:
    "*is provided for quickly linking a number of mappings so they can be treated
    as a single unit<q>"</q>.* This is usually much faster than creating one dictionary
    and running multiple update calls on it. `ChainMap` can be used to simulate nested
    scopes and is useful in templating. The underlying mappings are stored in a list.
    That list is public and can be accessed or updated using the maps attribute. Lookups
    search the underlying mappings successively until a key is found. By contrast,
    writes, updates, and deletions only operate on the first mapping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common use case is providing defaults, so let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: I just love how Python makes your life easy. You work on a `ChainMap` object,
    configure the first mapping as you want, and when you need a complete dictionary
    with all the defaults as well as the customized items, you just feed the `ChainMap`
    object to a `dict` constructor. If you have never coded in other languages, such
    as Java or C++, you probably won't be able to appreciate fully how precious this
    is, and how Python makes your life so much easier. I do, I feel claustrophobic
    every time I have to code in some other language.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically not a built-in data type, as you have to import them from the `enum`
    module, but definitely worth mentioning, are enumerations. They were introduced
    in Python 3.4, and though it is not that common to see them in professional code
    (yet), I thought I'd give you an example anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official definition goes like this: "*An enumeration is a set of* *sy**mbolic*
    *names (members) bound to unique, constant values. Within an enumeration, the
    members can be compared by identity, and the enumeration itself can be iterated
    over*."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you need to represent traffic lights. In your code, you might resort to
    doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing special about the preceding code. It''s something, in fact,
    that is very common to find. But, consider doing this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring for a moment the (relative) complexity of a class definition, you can
    appreciate how this might be more advantageous. The data structure is much cleaner,
    and the API it provides is much more powerful. I encourage you to check out the
    official documentation to explore all the great features you can find in the `enum`
    module. I think it's worth exploring, at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it. Now you have seen a very good proportion of the data structures that
    you will use in Python. I encourage you to take a dive into the Python documentation
    and experiment further with each and every data type we've seen in this chapter.
    It's worth it, believe me. Everything you'll write will be about handling data,
    so make sure your knowledge about it is rock solid.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leap into [Chapter 3](ef39b6a7-bb42-4484-84a1-56dd5375ca64.xhtml), *Iterating
    and Making Decisions*, I'd like to share some final considerations about different
    aspects that to my mind are important and not to be neglected.
  prefs: []
  type: TYPE_NORMAL
- en: Small values caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discussed objects at the beginning of this chapter, we saw that when
    we assigned a name to an object, Python creates the object, sets its value, and
    then points the name to it. We can assign different names to the same value and
    we expect different objects to be created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `a` and `b` are assigned to two `int` objects, which
    have the same value but they are not the same object, as you can see, their `id`
    is not the same. So let''s do it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Oh, oh! Is Python broken? Why are the two objects the same now? We didn't do
    `a = b = 5`, we set them up separately. Well, the answer is performances. Python
    caches short strings and small numbers, to avoid having many copies of them clogging
    up the system memory. Everything is handled properly under the hood so you don't
    need to worry a bit, but make sure that you remember this behavior should your
    code ever need to fiddle with IDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, Python provides you with several built-in data types and sometimes,
    if you''re not that experienced, choosing the one that serves you best can be
    tricky, especially when it comes to collections. For example, say you have many
    dictionaries to store, each of which represents a customer. Within each customer
    dictionary, there''s an `''id'': ''code''` unique identification code. In what
    kind of collection would you place them? Well, unless I know more about these
    customers, it''s very hard to answer. What kind of access will I need? What sort
    of operations will I have to perform on each of them, and how many times? Will
    the collection change over time? Will I need to modify the customer dictionaries
    in any way? What is going to be the most frequent operation I will have to perform
    on the collection?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can answer the preceding questions, then you will know what to choose.
    If the collection never shrinks or grows (in other words, it won''t need to add/delete
    any customer object after creation) or shuffles, then tuples are a possible choice.
    Otherwise, lists are a good candidate. Every customer dictionary has a unique
    identifier though, so even a dictionary could work. Let me draft these options
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Some customers we have there, right? I probably wouldn't go with the tuple option,
    unless I wanted to highlight that the collection is not going to change. I'd say
    usually a list is better, as it allows for more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor to keep in mind is that tuples and lists are ordered collections.
    If you use a dictionary (prior to Python 3.6) or a set, you lose the ordering,
    so you need to know if ordering is important in your application.
  prefs: []
  type: TYPE_NORMAL
- en: What about performances? For example, in a list, operations such as insertion
    and membership can take *O(n)*, while they are *O(1)* for a dictionary. It's not
    always possible to use dictionaries though, if we don't have the guarantee that
    we can uniquely identify each item of the collection by means of one of its properties,
    and that the property in question is hashable (so it can be a key in `dict`).
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering what *O(n)* and *O(1)* mean, please Google `big O notation`.
    In this context, let's just say that if performing an operation *Op* on a data
    structure takes *O(f(n))*, it would mean that *Op* takes at most a time *t ≤ c
    * f(n)*  to complete, where *c* is some positive constant, *n* is the size of
    the input, and *f* is some function. So, think of *O(...)* as an upper bound for
    the running time of an operation (it can be used also to size other measurable
    quantities, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Another way of understanding if you have chosen the right data structure is
    by looking at the code you have to write in order to manipulate it. If everything
    comes easily and flows naturally, then you probably have chosen correctly, but
    if you find yourself thinking your code is getting unnecessarily complicated,
    then you probably should try and decide whether you need to reconsider your choices.
    It's quite hard to give advice without a practical case though, so when you choose
    a data structure for your data, try to keep ease of use and performance in mind
    and give precedence to what matters most in the context you are in.
  prefs: []
  type: TYPE_NORMAL
- en: About indexing and slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw slicing applied on strings. Slicing,
    in general, applies to a sequence: tuples, lists, strings, and so on. With lists,
    slicing can also be used for assignment. I''ve almost never seen this used in
    professional code, but still, you know you can. Could you slice dictionaries or
    sets? I hear you scream, *Of course not!*. Excellent; I see we''re on the same
    page here, so let''s talk about indexing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one characteristic about Python indexing I haven''t mentioned before.
    I''ll show you by way of an example. How do you address the last element of a
    collection? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list `a` has 10 elements, because of the 0-index positioning system
    of Python, the first one is at position 0 and the last one is at position 9\.
    In the preceding example, the elements are conveniently placed in a position equal
    to their value: `0` is at position 0, `1` at position 1, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to fetch the last element, we need to know the length of the whole
    list (or tuple, or string, and so on) and then subtract `1`. Hence: `len(a) -
    1`. This is so common an operation that Python provides you with a way to retrieve
    elements using **negative ****indexing**. This proves very useful when you do
    data manipulation. Here''s a nice diagram about how indexing works on the string
    `"HelloThere"` (which is Obi-Wan Kenobi sarcastically greeting General Grievous):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e8c4254-1bea-4d26-836d-04e6d6cfb597.png)'
  prefs: []
  type: TYPE_IMG
- en: Trying to address indexes greater than **9** or smaller than **-10** will raise
    an `IndexError`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: About the names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that, in order to keep the examples as short as possible,
    I have called many objects using simple letters, like `a`, `b`, `c`, `d`, and
    so on. This is perfectly OK when you debug on the console or when you show that
    `a + b == 7`, but it's bad practice when it comes to professional coding (or any
    type of coding, for that matter). I hope you will indulge me if I sometimes do
    it; the reason is to present the code in a more compact way.
  prefs: []
  type: TYPE_NORMAL
- en: In a real environment though, when you choose names for your data, you should
    choose them carefully and they should reflect what the data is about. So, if you
    have a collection of `Customer` objects, `customers` is a perfectly good name
    for it. Would `customers_list`, `customers_tuple`, or `customers_collection` work
    as well? Think about it for a second. Is it good to tie the name of the collection
    to the datatype? I don't think so, at least in most cases. So I'd say if you have
    an excellent reason to do so, go ahead; otherwise, don't. The reason is, once
    that `customers_tuple` starts being used in different places of your code, and
    you realize you actually want to use a list instead of a tuple, you're up for
    some fun refactoring (also known as **wasted time**). Names for data should be
    nouns, and names for functions should be verbs. Names should be as expressive
    as possible. Python is actually a very good example when it comes to names. Most
    of the time you can just guess what a function is called if you know what it does.
    Crazy, huh?
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 2* of *Meaningful Names* of *Clean Code*, *Robert C. Martin*, *Prentice
    Hall* is entirely dedicated to names. It''s an amazing book that helped me improve
    my coding style in many different ways, and is a must-read if you want to take
    your coding to the next level.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored the built-in data types of Python. We've seen
    how many there are and how much can be achieved by just using them in different
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen number types, sequences, sets, mappings, collections (and a special
    guest appearance by `Enum`), we've seen that everything is an object, we've learned
    the difference between mutable and immutable, and we've also learned about slicing
    and indexing (and, proudly, negative indexing as well).
  prefs: []
  type: TYPE_NORMAL
- en: We've presented simple examples, but there's much more that you can learn about
    this subject, so stick your nose into the official documentation and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Most of all, I encourage you to try out all the exercises by yourself, get your
    fingers using that code, build some muscle memory, and experiment, experiment,
    experiment. Learn what happens when you divide by zero, when you combine different
    number types into a single expression, when you manage strings. Play with all
    data types. Exercise them, break them, discover all their methods, enjoy them,
    and learn them very, very well.
  prefs: []
  type: TYPE_NORMAL
- en: If your foundation is not rock solid, how good can your code be? And data is
    the foundation for everything. Data shapes what dances around it.
  prefs: []
  type: TYPE_NORMAL
- en: The more you progress with the book, the more it's likely that you will find
    some discrepancies or maybe a small typo here and there in my code (or yours).
    You will get an error message, something will break. That's wonderful! When you
    code, things break all the time, you debug and fix all the time, so consider errors
    as useful exercises to learn something new about the language you're using, and
    not as failures or problems. Errors will keep coming up until your very last line
    of code, that's for sure, so you may as well start making your peace with them
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about iterating and making decisions. We'll see how actually
    to put those collections to use, and take decisions based on the data we're presented
    with. We'll start to go a little faster now that your knowledge is building up,
    so make sure you're comfortable with the contents of this chapter before you move
    to the next one. Once more, have fun, explore, break things. It's a very good
    way to learn.
  prefs: []
  type: TYPE_NORMAL

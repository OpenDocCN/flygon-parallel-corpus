["```py\n# data.science.example.py\ndef do_report(data_source):\n    # fetch and prepare data\n    data = fetch_data(data_source)\n    parsed_data = parse_data(data)\n    filtered_data = filter_data(parsed_data)\n    polished_data = polish_data(filtered_data)\n\n    # run algorithms on data\n    final_data = analyse(polished_data)\n\n    # create and return report\n    report = Report(final_data)\n    return report\n```", "```py\n# matrix.multiplication.nofunc.py\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\n\nc = [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]\n     for r in a]\n```", "```py\n# matrix.multiplication.func.py\n# this function could also be defined in another module\ndef matrix_mul(a, b):\n    return [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]\n            for r in a]\n\na = [[1, 2], [3, 4]]\nb = [[5, 1], [2, 1]]\nc = matrix_mul(a, b)\n```", "```py\n# vat.py\nprice = 100  # GBP, no VAT\nfinal_price1 = price * 1.2\nfinal_price2 = price + price / 5.0\nfinal_price3 = price * (100 + 20) / 100.0\nfinal_price4 = price + price * 0.2\n```", "```py\n# vat.function.py\ndef calculate_price_with_vat(price, vat):\n    return price * (100 + vat) / 100\n```", "```py\n# scoping.level.1.py\ndef my_function():\n    test = 1  # this is defined in the local scope of the function\n    print('my_function:', test)\n\ntest = 0  # this is defined in the global scope\nmy_function()\nprint('global:', test)\n```", "```py\n$ python scoping.level.1.py\nmy_function: 1\nglobal: 0\n```", "```py\n# scoping.level.2.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        test = 2  # inner scope\n        print('inner:', test)\n\n    inner()\n    print('outer:', test)\n\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.py\ninner: 2\nouter: 1\nglobal: 0\n```", "```py\n# scoping.level.2.nonlocal.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        nonlocal test\n        test = 2  # nearest enclosing scope (which is 'outer')\n        print('inner:', test)\n\n    inner()\n    print('outer:', test)\n\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.nonlocal.py\ninner: 2\nouter: 2\nglobal: 0\n```", "```py\n# scoping.level.2.global.py\ndef outer():\n    test = 1  # outer scope\n    def inner():\n        global test\n        test = 2  # global scope\n        print('inner:', test)\n\n    inner()\n    print('outer:', test)\n\ntest = 0  # global scope\nouter()\nprint('global:', test)\n```", "```py\n$ python scoping.level.2.global.py\ninner: 2\nouter: 1\nglobal: 2\n```", "```py\n# key.points.argument.passing.py\nx = 3\n```", "```py\ndef func(y):\n    print(y)\nfunc(x)  # prints: 3\n```", "```py\n# key.points.assignment.py\nx = 3\ndef func(x):\n    x = 7  # defining a local x, not changing the global one\nfunc(x)\nprint(x)  # prints: 3\n```", "```py\n# key.points.mutable.py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this affects the caller!\n\nfunc(x)\nprint(x)  # prints: [1, 42, 3]\n```", "```py\n# key.points.mutable.assignment.py\nx = [1, 2, 3]\ndef func(x):\n    x[1] = 42  # this changes the caller!\n    x = 'something else'  # this points x to a new string object\n\nfunc(x)\nprint(x)  # still prints: [1, 42, 3]\n```", "```py\n# arguments.positional.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(1, 2, 3)  # prints: 1 2 3\n```", "```py\n# arguments.keyword.py\ndef func(a, b, c):\n    print(a, b, c)\nfunc(a=1, c=2, b=3)  # prints: 1 3 2\n```", "```py\n# arguments.default.py\ndef func(a, b=4, c=88):\n    print(a, b, c)\n\nfunc(1)  # prints: 1 4 88\nfunc(b=5, a=7, c=9)  # prints: 7 5 9\nfunc(42, c=9)  # prints: 42 4 9\nfunc(42, 43, 44)  # prints: 42, 43, 44\n```", "```py\n# arguments.default.error.py\ndef func(a, b=4, c=88):\n    print(a, b, c)\nfunc(b=1, c=2, 42)  # positional argument after keyword one\n```", "```py\n$ python arguments.default.error.py\n File \"arguments.default.error.py\", line 4\n func(b=1, c=2, 42) # positional argument after keyword one\n ^\nSyntaxError: positional argument follows keyword argument\n```", "```py\n# arguments.variable.positional.py\ndef minimum(*n):\n    # print(type(n))  # n is a tuple\n    if n:  # explained after the code\n        mn = n[0]\n        for value in n[1:]:\n            if value < mn:\n                mn = value\n        print(mn)\n\nminimum(1, 3, -7, 9)  # n = (1, 3, -7, 9) - prints: -7\nminimum()             # n = () - prints: nothing\n```", "```py\n# arguments.variable.positional.unpacking.py\ndef func(*args):\n    print(args)\n\nvalues = (1, 3, -7, 9)\nfunc(values)   # equivalent to: func((1, 3, -7, 9))\nfunc(*values)  # equivalent to: func(1, 3, -7, 9)\n```", "```py\n# arguments.variable.keyword.py\ndef func(**kwargs):\n    print(kwargs)\n\n# All calls equivalent. They print: {'a': 1, 'b': 42}\nfunc(a=1, b=42)\nfunc(**{'a': 1, 'b': 42})\nfunc(**dict(a=1, b=42))\n```", "```py\n# arguments.variable.db.py\ndef connect(**options):\n    conn_params = {\n        'host': options.get('host', '127.0.0.1'),\n        'port': options.get('port', 5432),\n        'user': options.get('user', ''),\n        'pwd': options.get('pwd', ''),\n    }\n    print(conn_params)\n    # we then connect to the db (commented out)\n    # db.connect(**conn_params)\n\nconnect()\nconnect(host='127.0.0.42', port=5433)\nconnect(port=5431, user='fab', pwd='gandalf')\n```", "```py\n$ python arguments.variable.db.py\n{'host': '127.0.0.1', 'port': 5432, 'user': '', 'pwd': ''}\n{'host': '127.0.0.42', 'port': 5433, 'user': '', 'pwd': ''}\n{'host': '127.0.0.1', 'port': 5431, 'user': 'fab', 'pwd': 'gandalf'}\n```", "```py\n# arguments.keyword.only.py\ndef kwo(*a, c):\n    print(a, c)\n\nkwo(1, 2, 3, c=7)  # prints: (1, 2, 3) 7\nkwo(c=4)  # prints: () 4\n# kwo(1, 2)  # breaks, invalid syntax, with the following error\n# TypeError: kwo() missing 1 required keyword-only argument: 'c'\n\ndef kwo2(a, b=42, *, c):\n    print(a, b, c)\n\nkwo2(3, b=7, c=99)  # prints: 3 7 99\nkwo2(3, c=13)  # prints: 3 42 13\n# kwo2(3, 23)  # breaks, invalid syntax, with the following error\n# TypeError: kwo2() missing 1 required keyword-only argument: 'c'\n```", "```py\n# arguments.all.py\ndef func(a, b, c=7, *args, **kwargs):\n    print('a, b, c:', a, b, c)\n    print('args:', args)\n    print('kwargs:', kwargs)\n\nfunc(1, 2, 3, *(5, 7, 9), **{'A': 'a', 'B': 'b'})\nfunc(1, 2, 3, 5, 7, 9, A='a', B='b')  # same as previous one\n```", "```py\n$ python arguments.all.py\na, b, c: 1 2 3\nargs: (5, 7, 9)\nkwargs: {'A': 'a', 'B': 'b'}\n```", "```py\n# arguments.all.kwonly.py\ndef func_with_kwonly(a, b=42, *args, c, d=256, **kwargs):\n    print('a, b:', a, b)\n    print('c, d:', c, d)\n    print('args:', args)\n    print('kwargs:', kwargs)\n\n# both calls equivalent\nfunc_with_kwonly(3, 42, c=0, d=1, *(7, 9, 11), e='E', f='F')\nfunc_with_kwonly(3, 42, *(7, 9, 11), c=0, d=1, e='E', f='F')\n```", "```py\n$ python arguments.all.kwonly.py\na, b: 3 42\nc, d: 0 1\nargs: (7, 9, 11)\nkwargs: {'e': 'E', 'f': 'F'}\n```", "```py\n# additional.unpacking.py\ndef additional(*args, **kwargs):\n    print(args)\n    print(kwargs)\n\nargs1 = (1, 2, 3)\nargs2 = [4, 5]\nkwargs1 = dict(option1=10, option2=20)\nkwargs2 = {'option3': 30}\nadditional(*args1, *args2, **kwargs1, **kwargs2)\n```", "```py\n$ python additional.unpacking.py\n(1, 2, 3, 4, 5)\n{'option1': 10, 'option2': 20, 'option3': 30}\n```", "```py\n# arguments.defaults.mutable.py\ndef func(a=[], b={}):\n    print(a)\n    print(b)\n    print('#' * 12)\n    a.append(len(a))  # this will affect a's default value\n    b[len(a)] = len(a)  # and this will affect b's one\n\nfunc()\nfunc()\nfunc()\n```", "```py\n$ python arguments.defaults.mutable.py\n[]\n{}\n############\n[0]\n{1: 1}\n############\n[0, 1]\n{1: 1, 2: 2}\n############\n```", "```py\n# arguments.defaults.mutable.intermediate.call.py\nfunc()\nfunc(a=[1, 2, 3], b={'B': 1})\nfunc()\n```", "```py\n$ python arguments.defaults.mutable.intermediate.call.py\n[]\n{}\n############\n[1, 2, 3]\n{'B': 1}\n############\n[0]\n{1: 1}\n############\n```", "```py\n# arguments.defaults.mutable.no.trap.py\ndef func(a=None):\n    if a is None:\n        a = []\n    # do whatever you want with `a` ...\n```", "```py\n# return.none.py\ndef func():\n    pass\nfunc()  # the return of this call won't be collected. It's lost.\na = func()  # the return of this one instead is collected into `a`\nprint(a)  # prints: None\n```", "```py\n# return.single.value.py\ndef factorial(n):\n    if n in (0, 1):\n        return 1\n    result = n\n    for k in range(2, n):\n        result *= k\n    return result\n\nf5 = factorial(5)  # f5 = 120\n```", "```py\n# return.single.value.2.py from functools import reduce\nfrom operator import mul\n\ndef factorial(n):\n    return reduce(mul, range(1, n + 1), 1)\n\nf5 = factorial(5)  # f5 = 120\n```", "```py\n# return.multiple.py\ndef moddiv(a, b):\n    return a // b, a % b\n\nprint(moddiv(20, 7))  # prints (2, 6)\n```", "```py\n>>> numbers = [4, 1, 7, 5]\n>>> sorted(numbers)  # won't sort the original `numbers` list\n[1, 4, 5, 7]\n>>> numbers  # let's verify\n[4, 1, 7, 5]  # good, untouched\n```", "```py\n>>> numbers.sort()  # this will act on the list\n>>> numbers\n[1, 4, 5, 7]\n```", "```py\n# recursive.factorial.py\ndef factorial(n):\n    if n in (0, 1):  # base case\n        return 1\n    return factorial(n - 1) * n  # recursive case\n```", "```py\n# filter.regular.py\ndef is_multiple_of_five(n):\n    return not n % 5\n\ndef get_multiples_of_five(n):\n    return list(filter(is_multiple_of_five, range(n)))\n```", "```py\n# filter.lambda.py\ndef get_multiples_of_five(n):\n    return list(filter(lambda k: not k % 5, range(n)))\n```", "```py\n# lambda.explained.py\n# example 1: adder\ndef adder(a, b):\n    return a + b\n\n# is equivalent to:\nadder_lambda = lambda a, b: a + b\n\n# example 2: to uppercase\ndef to_upper(s):\n    return s.upper()\n\n# is equivalent to:\nto_upper_lambda = lambda s: s.upper()\n```", "```py\n# func.attributes.py\ndef multiplication(a, b=1):\n    \"\"\"Return a multiplied by b. \"\"\"\n    return a * b\n\nspecial_attributes = [\n    \"__doc__\", \"__name__\", \"__qualname__\", \"__module__\",\n    \"__defaults__\", \"__code__\", \"__globals__\", \"__dict__\",\n    \"__closure__\", \"__annotations__\", \"__kwdefaults__\",\n]\n\nfor attribute in special_attributes:\n    print(attribute, '->', getattr(multiplication, attribute))\n```", "```py\n$ python func.attributes.py\n__doc__ -> Return a multiplied by b.\n__name__ -> multiplication\n__qualname__ -> multiplication\n__module__ -> __main__\n__defaults__ -> (1,)\n__code__ -> <code object multiplication at 0x10caf7660, file \"func.attributes.py\", line 1>\n__globals__ -> {...omitted...}\n__dict__ -> {}\n```", "```py\n__closure__ -> None\n__annotations__ -> {}\n__kwdefaults__ -> None\n```", "```py\n# primes.py\nfrom math import sqrt, ceil\n\ndef get_primes(n):\n    \"\"\"Calculate a list of primes up to n (included). \"\"\"\n    primelist = []\n    for candidate in range(2, n + 1):\n        is_prime = True\n        root = ceil(sqrt(candidate))  # division limit\n        for prime in primelist:  # we try only the primes\n            if prime > root:  # no need to check any further\n                break\n            if candidate % prime == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primelist.append(candidate)\n    return primelist\n```", "```py\n# docstrings.py\ndef square(n):\n    \"\"\"Return the square of a number n. \"\"\"\n    return n ** 2\n\ndef get_username(userid):\n    \"\"\"Return the username of a user given their id. \"\"\"\n    return db.get(user_id=userid).username\n```", "```py\ndef connect(host, port, user, password):\n    \"\"\"Connect to a database.\n\n    Connect to a PostgreSQL database directly, using the given\n    parameters.\n\n    :param host: The host IP.\n    :param port: The desired port.\n    :param user: The connection username.\n    :param password: The connection password.\n    :return: The connection object.\n    \"\"\"\n    # body of the function here...\n    return connection\n```", "```py\nfrom mymodule import myfunc as better_named_func \n```", "```py\nfrom datetime import datetime, timezone  # two imports on the same line\nfrom unittest.mock import patch  # single import\n\nimport pytest  # third party library\n\nfrom core.models import (  # multiline import\n    Exam,\n    Exercise,\n    Solution,\n)\n```", "```py\n\u251c\u2500\u2500 func_from.py\n\u251c\u2500\u2500 func_import.py\n\u251c\u2500\u2500 lib\n \u251c\u2500\u2500 funcdef.py\n \u2514\u2500\u2500 __init__.py\n\n```", "```py\n# funcdef.py\ndef square(n): \n    return n ** 2 \ndef cube(n): \n    return n ** 3 \n\n# func_import.py import lib.funcdef \nprint(lib.funcdef.square(10)) \nprint(lib.funcdef.cube(10)) \n\n# func_from.py\nfrom lib.funcdef import square, cube \nprint(square(10)) \nprint(cube(10)) \n```", "```py\nfrom .mymodule import myfunc \n```"]
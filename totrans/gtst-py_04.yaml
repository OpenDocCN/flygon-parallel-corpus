- en: Functions, the Building Blocks of Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create architecture is to put in order. Put what in order? Functions and
    objects." – Le Corbusier
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen that everything is an object in Python,
    and functions are no exception. But, what exactly is a function? A **function**
    is a sequence of instructions that perform a task, bundled as a unit. This unit
    can then be imported and used wherever it's needed. There are many advantages
    to using functions in your code, as we'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions—what they are and why we should use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes and name resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function signatures—input parameters and return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive and anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing objects for code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I believe the saying, *a picture is worth one thousand words*, is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b4903c1d-cfdd-4893-a1f1-e7657a132673.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input arguments and produce output values. Both
    of these are optional, as we'll see in the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A function in Python is defined by using the `def` keyword, after which the
    name of the function follows, terminated by a pair of parentheses (which may or
    may not contain input parameters), and a colon (`:`) signals the end of the function
    definition line. Immediately afterwards, indented by four spaces, we find the
    body of the function, which is the set of instructions that the function will
    execute when called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the indentation by four spaces is not mandatory, but it is the amount
    of spaces suggested by **PEP 8**, and, in practice, it is the most widely used
    spacing measure.
  prefs: []
  type: TYPE_NORMAL
- en: A function may or may not return an output. If a function wants to return an
    output, it does so by using the `return` keyword, followed by the desired output.
    If you have an eagle eye, you may have noticed the little ***** after **Optional**
    in the output section of the preceding diagram. This is because a function always
    returns something in Python, even if you don't explicitly use the `return` clause.
    If the function has no `return` statement in its body, or no value is given to
    the `return` statement itself, the function returns  `None`. The reasons behind
    this design choice are outside the scope of an introductory chapter, so all you
    need to know is that this behavior will make your life easier. As always, thank
    you, Python.
  prefs: []
  type: TYPE_NORMAL
- en: Why use functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are among the most important concepts and constructs of any language,
    so let me give you a few reasons why we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: They reduce code duplication in a program. By having a specific task taken care
    of by a nice block of packaged code that we can import and call whenever we want,
    we don't need to duplicate its implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They hide the implementation details from their users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve traceability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a few examples to get a better understanding of each point.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing code duplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate primes up to a limit, as we did in the previous chapter. You have a
    nice algorithm to calculate them, so you copy and paste it to wherever you need.
    One day, though, your friend, *B. Riemann*, gives you a better algorithm to calculate
    primes, which will save you a lot of time. At this point, you need to go over
    your whole code base and replace the old code with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a bad way to go about it. It's error-prone, you never know
    what lines you are chopping out or leaving in by mistake, when you cut and paste
    code into other code, and you may also risk missing one of the places where prime
    calculation is done, leaving your software in an inconsistent state where the
    same action is performed in different places in different ways. What if, instead
    of replacing code with a better version of it, you need to fix a bug, and you
    miss one of the places? That would be even worse.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should you do? Simple! You write a function, `get_prime_numbers(upto)`,
    and use it anywhere you need a list of primes. When *B. Riemann* comes to you
    and gives you the new code, all you have to do is replace the body of that function
    with the new implementation, and you're done! The rest of the software will automatically
    adapt, since it's just calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Your code will be shorter, it will not suffer from inconsistencies between old
    and new ways of performing a task, or undetected bugs due to copy-and-paste failures
    or oversights. Use functions, and you'll only gain from it, I promise.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are also very useful for splitting long or complex tasks into smaller
    ones. The end result is that the code benefits from it in several ways, for example,
    readability, testability, and reuse. To give you a simple example, imagine that
    you're preparing a report. Your code needs to fetch data from a data source, parse
    it, filter it, polish it, and then a whole series of algorithms needs to be run
    against it, in order to produce the results that will feed the `Report` class.
    It's not uncommon to read procedures like this that are just one big `do_report(data_source)` function.
    There are tens or hundreds of lines of code that end with `return report`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These situations are slightly more common in scientific code, which tend to
    be brilliant from an algorithmic point of view, but sometimes lack the touch of
    experienced programmers when it comes to the style in which they are written.
    Now, picture a few hundred lines of code. It''s very hard to follow through, to
    find the places where things are changing context (such as finishing one task
    and starting the next one). Do you have the picture in your mind? Good. Don''t
    do it! Instead, look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be very easy
    to debug each of the single data outputs in the `do_report` function. Moreover,
    it's even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts you need to suspend). Code like this is
    easier to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding implementation details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's stay with the preceding example to talk about this point as well. You
    can see that, by going through the code of the `do_report` function, you can get
    a pretty good understanding without reading one single line of implementation.
    This is because functions hide the implementation details. This feature means
    that, if you don't need to delve into the details, you are not forced to, in the
    way you would if `do_report` was just one big, fat function. In order to understand
    what was going on, you would have to read every single line of code. With functions,
    you don't need to. This reduces the time you spend reading the code and since,
    in a professional environment, reading code takes much more time than actually
    writing it, it's very important to reduce it by as much as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Improving readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coders sometimes don't see the point in writing a function with a body of one
    or two lines of code, so let's look at an example that shows you why you should
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to multiply two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e838ad6-e5e9-46a0-993e-6ba47929a5a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Would you prefer to have to read this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or would you prefer this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's much easier to understand that `c` is the result of the multiplication
    between `a` and `b` in the second example. It's much easier to read through the
    code and, if you don't need to modify that multiplication logic, you don't even
    need to go into the implementation details. Therefore, readability is improved
    here while, in the first snippet, you would have to spend time trying to understand
    what that complicated list comprehension is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Improving traceability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have written an e-commerce website. You have displayed the
    product prices all over the pages. Imagine that the prices in your database are
    stored with no VAT (sales tax), but you want to display them on the website with
    VAT at 20%. Here''s a few ways of calculating the VAT-inclusive price from the
    VAT-exclusive price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All these four different ways of calculating a VAT-inclusive price are perfectly
    acceptable, and I promise you I have found them all in my colleagues' code, over
    the years. Now, imagine that you have started selling your products in different
    countries and some of them have different VAT rates, so you need to refactor your
    code (throughout the website) in order to make that VAT calculation dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: How do you trace all the places in which you are performing a VAT calculation?
    Coding today is a collaborative task and you cannot be sure that the VAT has been
    calculated using only one of those forms. It's going to be hell, believe me.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write a function that takes the input values, `vat` and `price`
    (VAT-exclusive), and returns a VAT-inclusive price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now you can import that function and use it in any place in your website where
    you need to calculate a VAT-inclusive price, and when you need to trace those
    calls, you can search for `calculate_price_with_vat`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` is a percentage value (for example, 19, 20, or 23).
  prefs: []
  type: TYPE_NORMAL
- en: Scopes and name resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you remember when we talked about scopes and namespaces in [Chapter 1](1bcb5c5b-39cb-4561-846f-363111c7a2bc.xhtml), *A
    Gentle Introduction to Python*? We''re going to expand on that concept now. Finally,
    we can talk about functions and this will make everything easier to understand.
    Let''s start with a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I have defined the `test` name in two different places in the previous example.
    It is actually in two different scopes. One is the global scope (`test = 0`),
    and the other is the local scope of the `my_function` function (`test = 1`). If
    you execute the code, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s clear that `test = 1` shadows the `test = 0` assignment in `my_function`.
    In the global context, `test` is still `0`, as you can see from the output of
    the program, but we define the `test` name again in the function body, and we
    set it to point to an integer of value `1`. Both the two `test` names therefore
    exist, one in the global scope, pointing to an `int` object with a value of `0`,
    the other in the `my_function` scope, pointing to an `int` object with a value
    of `1`. Let''s comment out the line with `test = 1`. Python searches for the `test` name
    in the next enclosing namespace (recall the **LEGB** rule: **local**, **enclosing**,
    **global**, **built-in** described in [Chapter 1](1bcb5c5b-39cb-4561-846f-363111c7a2bc.xhtml),
    *A Gentle Introduction to Python*) and, in this case, we will see the value `0`
    printed twice. Try it in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s raise the stakes here and level up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have two levels of shadowing. One level is in the
    function `outer`, and the other one is in the function `inner`. It is far from
    rocket science, but it can be tricky. If we run the code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try commenting out the `test = 1` line. Can you figure out what the result will
    be? Well, when reaching the `print('outer:', test)` line, Python will have to
    look for `test` in the next enclosing scope, therefore it will find and print
    `0`, instead of `1`. Make sure you comment out `test = 2` as well, to see whether
    you understand what happens, and whether the LEGB rule is clear, before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that Python gives you the ability to define a function
    in another function. The inner function's name is defined within the namespace
    of the outer function, exactly as would happen with any other name.
  prefs: []
  type: TYPE_NORMAL
- en: The global and nonlocal statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to the preceding example, we can alter what happens to the shadowing
    of the test name by using one of these two special statements: `global` and `nonlocal`.
    As you can see from the previous example, when we define `test = 2` in the `inner` function,
    we overwrite `test` neither in the `outer` function nor in the global scope. We
    can get read access to those names if we use them in a nested scope that doesn''t
    define them, but we cannot modify them because, when we write an assignment instruction,
    we''re actually defining a new name in the current scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we change this behavior? Well, we can use the `nonlocal` statement.
    According to the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The nonlocal statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce it in the `inner` function, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how in the body of the `inner` function, I have declared the `test`
    name to be `nonlocal`. Running this code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wow, look at that result! It means that, by declaring `test` to be `nonlocal`
    in the `inner` function, we actually get to bind the `test` name to the one declared
    in the `outer` function. If we removed the `nonlocal test` line from the `inner` function
    and tried the same trick in the `outer` function, we would get a `SyntaxError`,
    because the `nonlocal` statement works on enclosing scopes excluding the global
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a way to get to that `test = 0` in the global namespace then? Of course,
    we just need to use the `global` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have now declared the `test` name to be `global`, which will basically
    bind it to the one we defined in the global namespace (`test = 0`). Run the code
    and you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the name affected by the `test = 2` assignment is now the `global`
    one. This trick would also work in the `outer` function because, in this case,
    we're referring to the global scope. Try it for yourself and see what changes,
    get comfortable with scopes and name resolution, it's very important. Also, could
    you tell what happens if you defined `inner` outside `outer` in the preceding
    examples?
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all possible type of parameters, let''s make sure you have
    a clear understanding of what passing a parameter to a function means. There are
    three key points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing is nothing more than assigning an object to a local variable
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an object to an argument name inside a function doesn't affect the
    caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a mutable object argument in a function affects the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at an example for each of these points.
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following code. We declare a name, `x`, in the global scope,
    then we declare a function, `func(y)`, and finally we call it, passing `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When `func` is called with `x`, within its local scope, a name, `y`, is created,
    and it''s pointed to the same object `x` is pointing to. This is better clarified
    by the following figure (don''t worry about Python 3.3, this is a feature that
    hasn''t changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/01591ef9-a866-4954-880d-44fabb616a9e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The right part of the preceding figure depicts the state of the program when
    execution has reached the end, after `func` has returned (`None`). Take a look
    at the Frames column, and note that we have two names, `x` and `func`, in the
    global namespace (Global frame), pointing to an `int` (with a value of **3**)
    and to a `function` object, respectively. Right beneath it, in the rectangle titled
    `func`, we can see the function''s local namespace, in which only one name has
    been defined: `y`. Because we have called `func` with `x` (line **5** in the left
    part of the figure), `y` is pointing to the same object that `x` is pointing to.
    This is what happens under the hood when an argument is passed to a function.
    If we had used the name `x` instead of `y` in the function definition, things
    would have been exactly the same (only maybe a bit confusing at first), there
    would be a local `x` in the function, and a global `x` outside, as we saw in the
    *Scopes and name resolution* section previously in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in a nutshell, what really happens is that the function creates, in its
    local scope, the names defined as arguments and, when we call it, we basically
    tell Python which objects those names must be pointed toward.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to argument names doesn't affect the caller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is something that can be tricky to understand at first, so let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when the `x = 7` line is executed, within the local scope
    of the `func` function, the name, `x`, is pointed to an integer with a value of
    `7`, leaving the global `x` unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a mutable affects the caller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the final point, and it''s very important because Python apparently
    behaves differently with mutables (just apparently, though). Let''s look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Wow, we actually changed the original object! If you think about it, there is
    nothing weird in this behavior. The `x` name in the function is set to point to
    the caller object by the function call and within the body of the function, we're
    not changing `x`, in that we're not changing its reference, or, in other words,
    we are not changing the object `x` is pointing to. We're accessing that object's
    element at position 1, and changing its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember point #2 under the *Input parameters* section: *Assigning an object
    to an argument name within a function doesn''t affect the caller*. If that is
    clear to you, the following code should not be surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the two lines I have highlighted. At first, like before, we just
    access the caller object again, at position 1, and change its value to number
    `42`. Then, we reassign `x` to point to the `'something else'` string. This leaves
    the caller unaltered and, in fact, the output is the same as that of the previous
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to play around with this concept, and experiment with prints
    and calls to the `id` function until everything is clear in your mind. This is
    one of the key aspects of Python and it must be very clear, otherwise you risk
    introducing subtle bugs into your code. Once again, the Python Tutor website ([http://www.pythontutor.com/](http://www.pythontutor.com/))
    will help you a lot by giving you a visual representation of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of input parameters and how they behave,
    let's see how we can specify them.
  prefs: []
  type: TYPE_NORMAL
- en: How to specify input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five different ways of specifying input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable positional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable keyword arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword-only arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Positional arguments are read from left to right and they are the most common
    type of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is not much else to say. They can be as numerous as you want and they
    are assigned by position. In the function call, `1` comes first, `2` comes second,
    and `3` comes third, therefore they are assigned to `a`, `b`, and `c`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments and default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Keyword arguments** are assigned by keyword using the `name=value` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Keyword arguments are matched by name, even when they don't respect the definition's
    original position (we'll see that there is a limitation to this behavior later,
    when we mix and match different types of arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'The counterpart of keyword arguments, on the definition side, is **default
    values**. The syntax is the same, `name=value`, and allows us to not have to provide
    an argument if we are happy with the given default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The are two things to notice, which are very important. First of all, you cannot
    specify a default argument on the left of a positional one. Second, note how in
    the examples, when an argument is passed without using the `argument_name=value`
    syntax, it must be the first one in the list, and it is always assigned to `a`.
    Notice also that passing values in a positional fashion still works, and follows
    the function signature order (last line of the example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try and scramble those arguments and see what happens. Python error messages
    are very good at telling you what''s wrong. So, for example, if you tried something
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This informs you that you've called the function incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Variable positional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may want to pass a variable number of positional arguments to
    a function, and Python provides you with the ability to do it. Let''s look at
    a very common use case, the `minimum` function. This is a function that calculates
    the minimum of its input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we specify a parameter prepending a `*` to its name, we
    are telling Python that that parameter will be collecting a variable number of
    positional arguments, according to how the function is called. Within the function,
    `n` is a tuple. Uncomment `print(type(n))` to see for yourself and play around
    with it for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed how we checked whether `n` wasn't empty with a simple `if n:`?
    This is because collection objects evaluate to `True` when non-empty, and otherwise
    `False` in Python. This is true for tuples, sets, lists, dictionaries, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note is that we may want to throw an error when we call the
    function with no arguments, instead of silently doing nothing. In this context,
    we're not concerned about making this function robust, but in understanding variable
    positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make another example to show you two things that, in my experience,
    are confusing to those who are new to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a good look at the last two lines of the preceding example. In the first
    one, we call `func` with one argument, a four-elements tuple. In the second example,
    by using the `*` syntax, we''re doing something called **unpacking**, which means
    that the four-elements tuple is unpacked, and the function is called with four
    arguments: `1, 3, -7, 9`.'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is part of the magic Python does to allow you to do amazing things
    when calling functions dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Variable keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variable keyword arguments are very similar to variable positional arguments.
    The only difference is the syntax (`**` instead of `*`) and that they are collected
    in a dictionary. Collection and unpacking work in the same way, so let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the calls are equivalent in the preceding example. You can see that adding
    a `**` in front of the parameter name in the function definition tells Python
    to use that name to collect a variable number of keyword parameters. On the other
    hand, when we call the function, we can either pass `name=value` arguments explicitly,
    or unpack a dictionary using the same `**` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why being able to pass a variable number of keyword parameters is
    so important may not be evident at the moment, so, how about a more realistic
    example? Let''s define a function that connects to a database. We want to connect
    to a default database by simply calling this function with no parameters. We also
    want to connect to any other database by passing the function the appropriate
    arguments. Before you read on, try to spend a couple of minutes figuring out a
    solution by yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the function, we can prepare a dictionary of connection parameters
    (`conn_params`) using default values as fallbacks, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code, but we''re not concerned with that right now. Running the
    preceding code yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the correspondence between the function calls and the output. Notice how
    default values are overridden according to what was passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-only arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python 3 allows for a new type of parameter: the **keyword-only** parameter.
    We are going to study them only briefly as their use cases are not that frequent.
    There are two ways of specifying them, either after the variable positional arguments,
    or after a bare `*`. Let''s see an example of both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, the function, `kwo`, takes a variable number of positional arguments
    (`a`) and a keyword-only one, `c`. The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to the function, `kwo2`, which differs from `kwo` in that it
    takes a positional argument, `a`, a keyword argument, `b`, and then a keyword-only
    one, `c`. You can uncomment the third call to see the error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to specify different types of input parameters, let's
    see how you can combine them in function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can combine input parameters, as long as you follow these ordering rules:'
  prefs: []
  type: TYPE_NORMAL
- en: When defining a function, normal positional arguments come first (`name`), then
    any default arguments (`name=value`), then the variable positional arguments (`*name` or
    simply `*`), then any keyword-only arguments (either `name` or `name=value` form
    is good), and then any variable keyword arguments (`**name`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, when calling a function, arguments must be given in the
    following order: positional arguments first (`value`), then any combination of
    keyword arguments (`name=value`), variable positional arguments (`*name`), and
    then variable keyword arguments (`**name`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this can be a bit tricky when left hanging in the theoretical world,
    let''s look at a couple of quick examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the order of the parameters in the function definition, and that the two
    calls are equivalent. In the first one, we''re using the unpacking operators for
    iterables and dictionaries, while in the second one we''re using a more explicit
    syntax. The execution of this yields the following (I printed only the result
    of one call, the other one being the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at an example with keyword-only arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that I have highlighted the keyword-only arguments in the function declaration.
    They come after the `*args` variable positional argument, and it would be the
    same if they came right after a single `*` (in which case there wouldn't be a
    variable positional argument).
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this yields the following (I printed only the result of one
    call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: One other thing to note is the names I gave to the variable positional and keyword
    arguments. You're free to choose differently, but be aware that `args` and `kwargs`
    are the conventional names given to these parameters, at least generically.
  prefs: []
  type: TYPE_NORMAL
- en: Additional unpacking generalizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the recent new features, introduced in Python 3.5, is the ability to
    extend the iterable (`*`) and dictionary (`**`) unpacking operators to allow unpacking
    in more positions, an arbitrary number of times, and in additional circumstances. I''ll
    present you with an example concerning function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we defined a simple function that prints its input
    arguments, `args` and `kwargs`. The new feature lies in the way we call this function.
    Notice how we can unpack multiple iterables and dictionaries, and they are correctly
    coalesced under `args` and `kwargs`. The reason why this feature is important
    is that it allows us not to have to merge `args1` with `args2`, and `kwargs1`
    with `kwargs2` in the code. Running the code produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to PEP 448 ([https://www.python.org/dev/peps/pep-0448/](https://www.python.org/dev/peps/pep-0448/)) to
    learn the full extent of this new feature and see further examples.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the trap! Mutable defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing to be very aware of with Python is that default values are created
    at `def` time, therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Both parameters have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s interesting, isn''t it? While this behavior may seem very weird at first,
    it actually makes sense, and it''s very handy, for example, when using memoization
    techniques (Google an example of that, if you''re interested). Even more interesting
    is what happens when, between the calls, we introduce one that doesn''t use defaults,
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that, by using the preceding technique, if `a` isn't passed when calling
    the function, you always get a brand new, empty list.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough with the input, let's look at the other side of the coin, the output.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The return values of functions are one of those things where Python is ahead
    of most other languages. Functions are usually allowed to return one object (one
    value) but, in Python, you can return a tuple, and this implies that you can return
    whatever you want. This feature allows a coder to write software that would be
    much harder to write in any other language, or certainly more tedious. We've already
    said that to return something from a function we need to use the `return` statement,
    followed by what we want to return. There can be as many return statements as
    needed in the body of a function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if within the body of a function we don't return anything,
    or we invoke a bare `return` statement, the function will return `None`. This
    behavior is harmless and, even though I don't have the room here to go into detail
    explaining why Python was designed like this, let me just tell you that this feature
    allows for several interesting patterns, and confirms Python as a very consistent
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'I say it''s harmless because you are never forced to collect the result of
    a function call. I''ll show you what I mean with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the whole body of the function is composed only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation. When it is
    executed, nothing happens. It is useful as a placeholder when a statement is required
    syntactically, but no code needs to be executed. In other languages, we would
    probably just indicate that with a pair of curly brackets (`{}`), which define
    an *empty scope*, but in Python, a scope is defined by indenting code, therefore
    a statement such as `pass` is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the first call of the `func` function returns a value (`None`)
    which we don't collect. As I said before, collecting the return value of a function
    call is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, that''s good but not very interesting so, how about we write an interesting
    function? Remember that in [Chapter 1](1bcb5c5b-39cb-4561-846f-363111c7a2bc.xhtml),
    *A Gentle Introduction to Python*, we talked about the factorial of a function.
    Let''s write our own here (for simplicity, I will assume the function is always
    called correctly with appropriate values so I won''t sanity-check the input argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have two points of return. If `n` is either `0` or `1` (in Python
    it''s common to use the `in` type of check, as I did instead of the more verbose
    `if n == 0 or n == 1:`), we return `1`. Otherwise, we perform the required calculation
    and we return `result`. Let''s try to write this function a little bit more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I know what you''re thinking: one line? Python is elegant, and concise! I think
    this function is readable even if you have never seen `reduce` or `mul`, but if
    you can''t read it or understand it, set aside a few minutes and do some research
    on the Python documentation until its behavior is clear to you. Being able to
    look up functions in the documentation and understand code written by someone
    else is a task every developer needs to be able to perform, so take this as a
    challenge.'
  prefs: []
  type: TYPE_NORMAL
- en: To this end, make sure you look up the `help` function, which proves quite helpful
    when exploring with the console.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike in most other languages, in Python it''s very easy to return multiple
    objects from a function. This feature opens up a whole world of possibilities
    and allows you to code in a style that is hard to reproduce with other languages.
    Our thinking is limited by the tools we use, therefore when Python gives you more
    freedom than other languages, it is actually boosting your own creativity as well.
    To return multiple values is very easy, you just use tuples (either explicitly
    or implicitly). Let''s look at a simple example that mimics the `divmod` built-in
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I could have wrapped the highlighted part in the preceding code in brackets,
    making it an explicit tuple, but there's no need for that. The preceding function
    returns both the result and the remainder of the division, at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the source code for this example, I have left a simple example of a test
    function to make sure my code is doing the correct calculation.
  prefs: []
  type: TYPE_NORMAL
- en: A few useful tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing functions, it''s very useful to follow guidelines so that you
    write them well. I''ll quickly point some of them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions should do one thing**: Functions that do one thing are easy to
    describe in one short sentence. Functions that do multiple things can be split
    into smaller functions that do one thing. These smaller functions are usually
    easier to read and understand. Remember the data science example we saw a few
    pages ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be small**: The smaller they are, the easier it is to test
    them and to write them so that they do one thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The fewer input parameters, the better**: Functions that take a lot of arguments
    quickly become harder to manage (among other issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be consistent in their return values**: Returning `False`
    or `None` is not the same thing, even if within a Boolean context they both evaluate
    to `False`. `False` means that we have information (`False`), while `None` means
    that there is no information. Try writing functions that return in a consistent
    way, no matter what happens in their body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions shouldn''t have side effects**: In other words, functions should
    not affect the values you call them with. This is probably the hardest statement
    to understand at this point, so I''ll give you an example using lists. In the
    following code, note how `numbers` is not sorted by the `sorted` function, which
    actually returns a sorted copy of `numbers`. Conversely, the `list.sort()` method
    is acting on the `numbers` object itself, and that is fine because it is a method
    (a function that belongs to an object and therefore has the rights to modify it):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Follow these guidelines and you'll write better functions, which will serve
    you well.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function calls itself to produce a result, it is said to be **recursive**.
    Sometimes recursive functions are very useful in that they make it easier to write
    code. Some algorithms are very easy to write using the recursive paradigm, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it's usually up to the programmer to choose the best approach
    for the case at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a recursive function usually has two sections: one where the return
    value depends on a subsequent call to itself, and one where it doesn''t (called
    a base case).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider the (hopefully familiar by now) `factorial`
    function, *N!*. The base case is when *N* is either `0` or `1`. The function returns
    `1` with no need for further calculation. On the other hand, in the general case,
    *N!* returns the product *1 * 2 * ... * (N-1) * N*. If you think about it, *N!*
    can be rewritten like this: *N! = (N-1)! * N*. As a practical example, consider
    *5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write this down in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When writing recursive functions, always consider how many nested calls you
    make, since there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions are used a lot when writing algorithms and they can be really
    fun to write. As an exercise, try to solve a couple of simple problems using both
    a recursive and an iterative approach.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last type of functions that I want to talk about are **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner that does the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want a list of all the numbers up to *N* that are multiples
    of five. Imagine that you want to filter those out using the `filter` function,
    which takes a function and an iterable and constructs a filter object that you
    can iterate on, from those elements of iterables for which the function returns
    `True`. Without using an anonymous function, you would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use `is_multiple_of_five` to filter the first `n` natural numbers.
    This seems a bit excessive, the task is simple and we don''t need to keep the
    `is_multiple_of_five` function around for anything else. Let''s rewrite it using
    a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is exactly the same but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form: `func_name = lambda [parameter_list]:
    expression`. A function object is returned, which is equivalent to this: `def
    func_name([parameter_list]): return expression`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another couple of examples of equivalent functions defined in
    the two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that I assigned
    what is returned by the `lambda` expressions to a name (`adder_lambda`, `to_upper_lambda`),
    but there is no need for that when you use lambdas in the way we did in the `filter`
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Function attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every function is a fully-fledged object and, as such, they have many attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows a part
    of them and how to display their value for an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'I used the built-in `getattr` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to get an attribute at runtime using its string name. Running this
    script yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: I have omitted the value of the `__globals__` attribute, as it was too big.
    An explanation of the meaning of this attribute can be found in the *Callable **types*
    section of the *Python Data Model* documentation page ([https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)).
    Should you want to see all the attributes of an object, just call `dir(object_name)`
    and you'll be given the list of all of its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a lot of built-in functions. They are available anywhere and
    you can get a list of them by inspecting the `builtins` module with `dir(__builtins__)`,
    or by going to the official Python documentation. Unfortunately, I don't have
    the room to go through all of them here. We've already seen some of them, such
    as `any`, `bin`, `bool`, `divmod`, `filter`, `float`, `getattr`, `id`, `int`,
    `len`, `list`, `min`, `print`, `set`, `tuple`, `type`, and `zip`, but there are
    many more, which you should read at least once. Get familiar with them, experiment,
    write a small piece of code for each of them, and make sure you have them at your
    finger tips so that you can use them when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: One final example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off this chapter, how about one last example? I was thinking
    we could write a function to generate a list of prime numbers up to a limit. We've
    already seen the code for this so let's make it a function and, to keep it interesting,
    let's optimize it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that you don''t need to divide it by all numbers from *2* to *N*-1
    to decide whether a number, *N*, is prime. You can stop at *√N*. Moreover, you
    don''t need to test the division for all numbers from *2* to *√N*, you can just
    use the primes in that range. I''ll leave it to you to figure out why this works,
    if you''re interested. Let''s see how the code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The code is the same as in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the `primelist` result list to get the primes for the division. We calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have served our
    purpose as well, the formula I chose is cleaner and requires me to use a couple
    of imports, which I wanted to show you. Check out the functions in the `math`
    module, they are very interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm a big fan of code that doesn't need documentation. When you program correctly,
    choose the right names and take care of the details, your code should come out
    as self-explanatory and documentation should not be needed. Sometimes a comment
    is very useful though, and so is some documentation. You can find the guidelines
    for documenting Python in *PEP 257 - Docstring conventions* ([https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)),
    but I'll show you the basics here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is documented with strings, which are aptly called **docstrings**. Any
    object can be documented, and you can use either one-line or multiline docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but clearly state its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Using triple double-quoted strings allows you to expand easily later on. Use
    sentences that end in a period, and don't leave blank lines before or after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, I have documented a fictitious `connect` function,
    using the Sphinx notation, in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Sphinx** is probably the most widely used tool for creating Python documentation.
    In fact, the official Python documentation was written with it. It''s definitely
    worth spending some time checking it out.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know a lot about functions, let's look at how to use them. The
    whole point of writing functions is to be able to reuse them later, and in Python,
    this translates to importing them into the namespace where you need them. There
    are many different ways to import objects into a namespace, but the most common
    ones are `import module_name` and `from module_name import function_name`. Of
    course, these are quite simplistic examples, but bear with me for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: The `import module_name` form finds the `module_name` module and defines a name
    for it in the local namespace where the `import` statement is executed. The `from
    module_name import identifier` form is a little bit more complicated than that,
    but basically does the same thing. It finds `module_name` and searches for an
    attribute (or a submodule) and stores a reference to `identifier` in the local
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both forms have the option to change the name of the imported object using
    the `as` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to give you a flavor of what importing looks like, here''s an example
    from a test module of one of my projects (notice that the blank lines between
    blocks of imports follow the guidelines from PEP 8 at [https://www.python.org/dev/peps/pep-0008/#imports](https://www.python.org/dev/peps/pep-0008/#imports):
    standard library, third party, and local code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When you have a structure of files starting in the root of your project, you
    can use the dot notation to get to the object you want to import into your current
    namespace, be it a package, a module, a class, a function, or anything else. The
    `from module import` syntax also allows a catch-all clause, `from module import
    *`, which is sometimes used to get all the names from a module into the current
    namespace at once, but it's frowned upon for several reasons, such as performance
    and the risk of silently shadowing other names. You can read all that there is
    to know about imports in the official Python documentation but, before we leave
    the subject, let me give you a better example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have defined a couple of functions: `square(n)` and `cube(n)`
    in a module, `funcdef.py`, which is in the `lib` folder. You want to use them
    in a couple of modules that are at the same level of the `lib` folder, called
    `func_import.py` and `func_from.py`. Showing the tree structure of that project
    produces something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Before I show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put a `__init__.py` module
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two things to note about the `__init__.py` file. First of all, it
    is a fully-fledged Python module so you can put code into it as you would with
    any other module. Second, as of Python 3.3, its presence is no longer required
    to make a folder be interpreted as a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Both these files, when executed, print `100` and `1000`. You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The imports we''ve seen so far are called **absolute**, that is, they define
    the whole path of the module that we want to import, or from which we want to
    import an object. There is another way of importing objects into Python, which
    is called a **relative import**. It''s helpful in situations where we want to
    rearrange the structure of large packages without having to edit sub-packages,
    or when we want to make a module inside a package able to import itself. Relative
    imports are done by adding as many leading dots in front of the module as the
    number of folders we need to backtrack, in order to find what we''re searching
    for. Simply put, it is something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For a complete explanation of relative imports, refer to PEP 328 ([https://www.python.org/dev/peps/pep-0328/](https://www.python.org/dev/peps/pep-0328/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of functions. They are extremely important
    and, from now on, we'll use them basically everywhere. We talked about the main
    reasons for using them, the most important of which are code reuse and implementation
    hiding.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a function object is like a box that takes optional inputs and produces
    outputs. We can feed input values to a function in many different ways, using
    positional and keyword arguments, and using variable syntax for both types.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should know how to write a function, document it, import it into your
    code, and call it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to see how to deal with files and how to persist
    data in several different ways and formats.
  prefs: []
  type: TYPE_NORMAL

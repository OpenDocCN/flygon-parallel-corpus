- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to build upon the skills we learned in the last
    chapter in order to create special list implementations. We are still sticking
    to linear structures. We will get to more complex data structures in the coming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some applications of stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A stack is a data structure that is often likened to a stack of plates. If
    you have just washed a plate, you put it on top of the stack. When you need a
    plate, you take it off the top of the stack. So the last plate to be added to
    the stack will be the first to be removed from the stack. Thus, a stack is a **last
    in, first out** (**LIFO**) structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9b6f83e-4f80-4394-8403-1be5aec87197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure depicts a stack of plates. Adding a plate to the pile is
    only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two primary operations that are done on stacks: `push` and `pop`.
    When an element is added to the top of the stack, it is pushed onto the stack.
    When an element is taken off the top of the stack, it is popped off the stack.
    Another operation which is used sometimes is `peek`, which makes it possible to
    see the element on the stack without popping it off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacks are used for a number of things. One very common usage for stacks is
    to keep track of the return address during function calls. Let''s imagine that
    we have the following little program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When the program execution gets to the call to `a()`, it first pushes the address
    of the following instruction onto the stack, then jumps to `a`. Inside `a`, `b()`
    is called, but before that, the return address is pushed onto the stack. Once
    in `b()` and the function is done, the return address is popped off the stack,
    which takes us back to `a()`. When `a` has completed, the return address is popped
    off the stack, which takes us back to the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacks are actually also used to pass data between functions. Say you have
    the following function call somewhere in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What is going to happen is that `14, ''eggs'', ''ham''` and `''spam''` will
    be pushed onto the stack, one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ada829bd-7a36-417d-8b9c-0c959bd9e8ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the code jumps into the function, the values for `a, b, c, d` will be
    popped off the stack. The `spam` element will be popped off first and assigned
    to `d`, then `"ham"` will be assigned to `c`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Stack implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us study an implementation of a stack in Python. We start off by creating
    a `node` class, just as we did in the previous chapter with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be familiar to you by now: a node holds data and a reference to
    the next item in a list. We are going to implement a stack instead of a list,
    but the same principle of nodes linked together still applies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at the `stack` class. It starts off similar to a singly linked
    list. We need to know the node at the top of the stack. We would also like to
    keep track of the number of nodes in the stack. So we will add these fields to
    our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Push operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `push` operation is used to add an element to the top of the stack. Here
    is an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, there is no existing node after creating our new node.
    Thus `self.top` will point to this new node. The else part of the `if` statement
    guarantees that this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c66894e-0d5c-43ff-af8d-bc571afa8205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a scenario where we have an existing stack, we move `self.top` so that it
    points to the newly created node. The newly created node must have its **next**
    pointer, pointing to the node that used to be the top node on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6eb72349-1b93-4d2c-ae5e-775a76109b02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need a `pop` method to remove the top element from the stack. As we
    do so, we need to return the topmost element as well. We will make the stack return
    `None` if there are no more elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing to pay attention to here is the inner `if` statement. If the top
    node has its **next** attribute pointing to another node, then we must set the
    top of the stack to now point to that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e832ddc2-57ec-4252-ab91-d1031c910468.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When there is only one node in the stack, the `pop` operation will proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/068806f4-31b6-4dd2-8e06-1fe00b7a30a3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Removing such a node results in `self.top` pointing to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42040b37-cc5f-4fb9-9e0b-f9789f7200aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Peek
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we said earlier, we could also add a `peek` method. This will just return
    the top of the stack without removing it from the stack, allowing us to look at
    the top element without changing the stack itself. This operation is very straightforward.
    If there is a top element, return its data, otherwise return `None` (so that the
    behavior of `peek` matches that of `pop`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Bracket-matching application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us look at an example of how we can use our stack implementation. We
    are going to write a little function that will verify whether a statement containing
    brackets--(, [, or {--is balanced, that is, whether the number of closing brackets
    matches the number of opening brackets. It will also ensure that one pair of brackets
    really is contained in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function parses each character in the statement passed to it. If it gets
    an open bracket, it pushes it onto the stack. If it gets a closing bracket, it
    pops the top element off the stack and compares the two brackets to make sure
    their types match: ( should match ), [ should match ], and { should match }. If
    they don''t, we return `False`, otherwise we continue parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have got to the end of the statement, we need to do one last check.
    If the stack is empty, then we are fine and we can return `True`. But if the stack
    is not empty, then we have some opening bracket which does not have a matching
    closing bracket and we shall return `False`. We can test the bracket-matcher with
    the following little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the first of the three statements should match. And when we run the code,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/348b931f-31df-4d67-a398-4e9d96f6db4f.png)'
  prefs: []
  type: TYPE_IMG
- en: '`True`, `False`, `False`. The code works. In summary, the `push` and `pop`
    operations of the stack data structure attract a **O**(*1*). The stack data structure
    is simply enough but is used to implement a whole range of functionality in the
    real world. The back and forward buttons on the browser are made possible by stacks.
    To be able to have undo and redo functionality in word processors, stacks are
    also used.'
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another special type of list is the queue data structure. This data structure
    is no different from the regular queue you are accustomed to in real life. If
    you have stood in line at an airport or to be served your favorite burger at your
    neighborhood shop, then you should know how things work in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are also a very fundamental and important concept to grasp since many
    other data structures are built on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way a queue works is that the first person to join the queue usually gets
    served first, all things being equal. The acronym FIFO best explains this. **FIFO**
    stands for **first in, first out**. When people are standing in a queue waiting
    for their turn to be served, service is only rendered at the front of the queue.
    The only time people exit the queue is when they have been served, which only
    occurs at the very front of the queue. By strict definition, it is illegal for
    people to join the queue at the front where people are being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76e5d4fd-9702-49c6-ba06-ae510f3137f4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To join the queue, participants must first move behind the last person in the
    queue. The length of the queue does not matter. This is the only legal or permitted
    way by which the queue accepts new entrants.
  prefs: []
  type: TYPE_NORMAL
- en: As human as we are, the queues that we form do not conform to strict rules.
    It may have people who are already in the queue deciding to fall out or even have
    others substituting for them. It is not our intent to model all the dynamics that
    happen in a real queue. Abstracting what a queue is and how it behaves enables
    us to solve a plethora of challenges, especially in computing.
  prefs: []
  type: TYPE_NORMAL
- en: We shall provide various implementations of a queue but all will revolve around
    the same idea of FIFO. We shall call the operation to add an element to the queue
    enqueue. To remove an element from the queue, we will create a `dequeue` operation.
    Anytime an element is enqueued, the length or size of the queue increases by one.
    Conversely, dequeuing items reduce the number of elements in the queue by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the two operations, the following table shows the effect of
    adding and removing elements from a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  prefs: []
  type: TYPE_TB
- en: '| `Queue()` | 0 | `[]` | Queue object created |'
  prefs: []
  type: TYPE_TB
- en: '| `Enqueue` "Mark" | 1 | `[''mark'']` | Mark added to queue |'
  prefs: []
  type: TYPE_TB
- en: '| `Enqueue` "John" | 2 | `[''mark'',''john'']` | John added to queue |'
  prefs: []
  type: TYPE_TB
- en: '| `Size()` | 2 | `[''mark'',''john'']` | Number of items in queue returned
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Dequeue()` | 1 | `[''mark'']` | John is dequeued and returned |'
  prefs: []
  type: TYPE_TB
- en: '| `Dequeue()` | 0 | `[]` | Mark is dequeued and returned |'
  prefs: []
  type: TYPE_TB
- en: List-based queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To put into code everything discussed about queues to this point, let''s go
    ahead and implement a very simple queue using Python''s `list` class. This is
    to help us develop quickly and learn about queues. The operations that must be
    performed on the queue are encapsulated in the `ListQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the initialization method `__init__`, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `zero`. The more interesting methods are the `enqueue` and `dequeue`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enqueue` operation or method uses the `insert` method of the `list` class
    to insert items (or data) at the front of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Do note how we implement insertions to the end of the queue. Index 0 is the
    first position in any list or array. However, in our implementation of a queue
    using a Python list, the array index 0 is the only place where new data elements
    are inserted into the queue. The `insert` operation will shift existing data elements
    in the list by one position up and then insert the new data in the space created
    at index 0\. The following figure visualizes this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/acda141e-486b-4998-acf8-d12153b3b79e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make our queue reflect the addition of the new element, the size is increased
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We could have used Python's `shift` method on the list as another way of implementing
    the "insert at 0". At the end of the day, an implementation is the overall objective
    of the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dequeue` operation is used to remove items from the queue. With reference
    to the introduction to the topic of queues, this operation captures the point
    where we serve the customer who joined the queue first and also waited the longest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python `list` class has a method called `pop()`. The `pop` method does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes the last item from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the removed item from the list back to the user or code that called
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last item in the list is popped and saved in the `data` variable. In the
    last line of the method, the data is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the tunnel in the following figure as our queue. To perform a `dequeue`
    operation, the node with data `1` is removed from the front of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6aa30ff3-231a-4368-b56d-b03352d05ef9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting elements in the queue are as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fcfb8cff-59f5-476f-bdd6-05a3c74ee882.jpg)What can we say about the
    `enqueue` operation? It is highly inefficient in more than one way. The method
    has to first shift all the elements by one space. Imagine when there are 1 million
    elements in a list which need to be shifted around anytime a new element is being
    added to the queue. This will generally make the enqueue process very slow for
    large lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yet another implementation of a queue is to use two stacks. Once more, the
    Python `list` class will be used to simulate a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `queue` class sets the two instance variables to empty lists upon
    initialization. These are the stacks that will help us implement a queue. The
    stacks in this case are simply Python lists that allow us to call `push` and `pop`
    methods on them.
  prefs: []
  type: TYPE_NORMAL
- en: The `inbound_stack` is only used to store elements that are added to the queue.
    No other operation can be performed on this stack.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enqueue` method is what adds elements to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The method is a simple one that only receives the `data` the client wants to
    append to the queue. This data is then passed to the `append` method of the `inbound_stack`
    in the `queue` class. Furthermore, the `append` method is used to mimic the `push`
    operation, which pushes elements to the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `enqueue` data onto the `inbound_stack`, the following code does justice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A command-line output of the `inbound_stack` inside the queue is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dequeue` operation is a little more involved than its `enqueue` counterpart
    operation. New elements added to our queue end up in the `inbound_stack`. Instead
    of removing elements from the `inbound_stack`, we shift our attention to the `outbound_stack`.
    As we said, elements can be deleted from our queue only through the `outbound_stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement first checks whether the `outbound_stack` is empty or not.
    If it is not empty, we proceed to remove the element at the front of the queue
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `outbound_stack` is empty instead, all the elements in the `inbound­_stack`
    are moved to the `outbound_stack` before the front element in the queue is popped
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop will continue to be executed as long as there are elements
    in the `inbound_stack`.
  prefs: []
  type: TYPE_NORMAL
- en: The statement `self.inbound_stack.pop()` will remove the latest element that
    was added to the `inbound_stack` and immediately pass the popped data to the `self.outbound_stack.append()`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, our `inbound_stack` was filled with the elements **5**, **6** and
    **7**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c9f8597-491f-473c-b03a-931f030741ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After executing the body of the `while` loop, the `outbound_stack` looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9f482bd-7bd5-4c63-9587-bb17ff0eecd6.jpg)![](assets/a8cd8bb4-4c0e-47a5-95c1-0e2ced3edb1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last line in the `dequeue` method will return `5` as the result of the
    `pop` operation on the `outbound_stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves the `outbound_stack` with only two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18c49954-4199-454a-bec0-f7619ad6113c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next time the `dequeue` operation is called, the `while` loop will not be
    executed because there are no elements in the `outbound_stack`, which makes the
    outer `if` statement fail.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop` operation is called right away in that case so that only the element
    in the queue that has waited the longest is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical run of code to use this queue implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code sample adds elements to a queue and prints out the elements within
    the queue. The `dequeue` method is called, after which a change in the number
    of elements is observed when the queue is printed out again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a queue with two stacks is a popular question posed during interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Node-based queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a Python list to implement a queue is a good starter to get the feel of
    how queues work. It is completely possible for us to implement our own queue data
    structure by utilizing our knowledge of pointer structures.
  prefs: []
  type: TYPE_NORMAL
- en: A queue can be implemented using a doubly linked list, and `insertion` and `deletion`
    operations on this data structure have a time complexity of **O**(*1*).
  prefs: []
  type: TYPE_NORMAL
- en: The definition for the `node` class remains the same as the `Node` we defined
    when we touched on doubly linked list, The doubly linked list can be treated as
    a queue if it enables a FIFO kind of data access, where the first element added
    to the list is the first to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Queue class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `queue` class is very similar to that of the doubly linked `list` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`self.head` and `self.tail` pointers are set to `None` upon creation of an
    instance of the `queue` class. To keep a count of the number of nodes in `Queue`,
    the `count` instance variable is maintained here too and set to `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Elements are added to a `Queue` object via the `enqueue` method. The elements
    in this case are the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `enqueue` method code is the same code already explained in the `append`
    operation of the doubly linked list. It creates a node from the data passed to
    it and appends it to the tail of the queue, or points both `self.head` and `self.tail`
    to the newly created node if the queue is empty. The total count of elements in
    the queue is increased by the line `self.count += 1.`
  prefs: []
  type: TYPE_NORMAL
- en: Dequeue operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other operation that makes our doubly linked list behave as a queue is the
    `dequeue` method. This method is what removes the node at the front of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the first element pointed to by `self.head`, an `if` statement is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`current` is initialized by pointing it to `self.head`. If `self.count` is
    1, then it means only one node is in the list and invariably the queue. Thus,
    to remove the associated node (pointed to by `self.head`), the `self.head` and
    `self.tail` variables are set to `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, the queue has many nodes, then the head pointer is shifted
    to point to `self.head`'s next node.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` statement is run, the method returns the node that was pointed
    to by `head`. `self.count` is decremented by one in either way the `if` statement
    execution path flows.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with these methods, we have successfully implemented a queue, borrowing
    heavily from the idea of a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Remember also that the only things transforming our doubly linked list into
    a queue are the two methods, namely `enqueue` and `dequeue`.
  prefs: []
  type: TYPE_NORMAL
- en: Application of queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues are used to implement a variety of functionalities in computer land.
    For instance, instead of providing each computer on a network with its own printer,
    a network of computers can be made to share one printer by queuing what each printer
    wants to print. When the printer is ready to print, it will pick one of the items
    (usually called jobs) in the queue to print out.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems also queue processes to be executed by the CPU. Let's create
    an application that makes use of a queue to create a bare-bones media player.
  prefs: []
  type: TYPE_NORMAL
- en: Media player queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most music player software allows users the chance to add songs to a playlist.
    Upon hitting the play button, all the songs in the main playlist are played one
    after the other. The sequential playing of the songs can be implemented with queues
    because the first song to be queued is the first song that is played. This aligns
    with the FIFO acronym. We shall implement our own playlist queue that plays songs
    in the FIFO manner.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, our media player queue will only allow for the addition of tracks
    and a way to play all the tracks in the queue. In a full-blown music player, threads
    would be used to improve how the queue is interacted with, while the music player
    continues to be used to select the next song to be played, paused, or even stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `track` class will simulate a musical track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length is a random number between 5 and 10\. The random module provides
    the `randint` method to enable us generate the random numbers. The class represents
    any MP3 track or file that contains music. The random length of a track is used
    to simulate the number of seconds it takes to play a song or track.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a few tracks and print out their lengths, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Your output may be different depending on the random length generated for the
    two tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our queue. Using inheritance, we simply inherit from the
    `queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A call is made to properly initialize the queue by making a call to `super`.
    This class is essentially a queue that holds a number of track objects in a queue.
    To add tracks to the queue, an `add_track` method is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The method passes a `track` object to the `enqueue` method of the queue `super`
    class. This will, in effect, create a `Node` using the `track` object (as the
    node's data) and point either the tail, if the queue is not empty, or both head
    and tail, if the queue is empty, to this new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the tracks in the queue are played sequentially from the first track
    added to the last (FIFO), then the `play` function has to loop through the elements
    in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`self.count` keeps count of when a track is added to our queue and when tracks
    have been dequeued. If the queue is not empty, a call to the `dequeue` method
    will return the node (which houses the `track` object) at the front of the queue.
    The `print` statement then accesses the title of the track through the `data`
    attribute of the node. To further simulate the playing of a track, the `time.sleep()`
    method halts program execution till the number of seconds of the track has elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node''s `track` object through the
    data property of the node which is returned by the call to `dequeue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46c48a15-546f-44d7-b5d2-0a916532f052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see, instead of our `node` object just storing just any data, it stores
    tracks in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our music player for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We create five track objects with random words as titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output should be different from what you get on your machine due to the
    random length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an instance of the `MediaPlayerQueue` class is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The tracks will be added and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing the track, the system also pauses
    for the number of seconds equal to that of the length of the track.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used our knowledge of linking nodes together to create other
    data structures, namely stacks and queues. We have seen how these data structures
    closely mimic stacks and queues in the real world. Concrete implementations, together
    with their varying types, have been shown. We later applied the concept of stacks
    and queues to write real-life programs.
  prefs: []
  type: TYPE_NORMAL
- en: We shall consider trees in the next chapter. The major operations on a tree
    will be discussed, likewise the different spheres in which to apply the data structure.
  prefs: []
  type: TYPE_NORMAL

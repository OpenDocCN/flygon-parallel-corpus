- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tree is a hierarchical form of data structure. When we dealt with lists, queues,
    and stacks, items followed each other. But in a tree, there is a *parent-child*
    relationship between items.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize what trees look like, imagine a tree growing up from the ground.
    Now remove that image from your mind. Trees are normally drawn downward, so you
    would be better off imagining the root structure of the tree growing downward.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of every tree is the so-called *root node*. This is the ancestor
    of all other nodes in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Trees are used for a number of things, such as parsing expressions, and searches.
    Certain document types, such as XML and HTML, can also be represented in a tree
    form. We shall look at some of the uses of trees in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Terms and definitions of trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees and binary search trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider some terms associated with trees.
  prefs: []
  type: TYPE_NORMAL
- en: To understand trees, we need to first understand the basic ideas on which they
    rest. The following figure contains a typical tree consisting of character nodes
    lettered **A** through to **M**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ecea614b-c914-4a6d-a097-aa3b3f11da67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a list of terms associated with a Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: Each circled alphabet represents a node. A node is any structure
    that holds data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root node**: The root node is the only node from which all other nodes come.
    A tree with an undistinguishable root node cannot be considered as a tree. The
    root node in our tree is the node A.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub-tree**: A sub-tree of a tree is a tree with its nodes being a descendant
    of some other tree. Nodes F, K, and L form a sub-tree of the original tree consisting
    of all the nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree**: The number of sub-trees of a given node. A tree consisting of only
    one node has a degree of 0\. This one tree node is also considered as a tree by
    all standards. The degree of node A is 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf node**: This is a node with a degree of 0\. Nodes J, E, K, L, H, M,
    and I are all leaf nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: The connection between two nodes. An edge can sometimes connect a
    node to itself, making the edge appear as a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: A node in the tree with other connecting nodes is the parent of
    those nodes. Node B is the parent of nodes D, E, and F.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child**: This is a node connected to its parent. Nodes B and C are children
    of node A, the parent and root node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sibling**: All nodes with the same parent are siblings. This makes the nodes
    B and C siblings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level**: The level of a node is the number of connections from the root node.
    The root node is at level 0\. Nodes B and C are at level 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height of a tree**: This is the number of levels in a tree. Our tree has
    a height of 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. The depth of node H is 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall begin our treatment of trees by considering the node in a tree and
    abstracting a class.
  prefs: []
  type: TYPE_NORMAL
- en: Tree nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as was the case with other data structures that we encountered, such as
    lists and stacks, trees are built up of nodes. But the nodes that make up a tree
    need to contain data about the parent-child relationship that we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now look at how to build a binary tree `node` class in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just like in our previous implementations, a node is a container for data and
    holds references to other nodes. Being a binary tree node, these references are
    to the left and the right children.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this class out, we first create a few nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we connect the nodes to each other. We let `n1` be the root node with
    `n2` and `n3` as its children. Finally, we hook `n4` as the left child to `n2`,
    so that we get a few iterations when we traverse the left sub-tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our tree structure set up, we are ready to traverse it. As mentioned
    previously, we shall traverse the left sub-tree. We print out the node and move
    down the tree to the next left node. We keep doing this until we have reached
    the end of the left sub-tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you will probably have noticed, this requires quite a bit of work in the
    client code, as you have to manually build up the tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary tree is one in which each node has a maximum of two children. Binary
    trees are very common and we shall use them to build up a BST implementation in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is an example of a binary tree with 5 being the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24dfae79-0a28-407a-af32-db8491f991a7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each child is identified as being the right or left child of its parent. Since
    the parent node is also a node by itself, each node will hold a reference to a
    right and left node even if the nodes do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: A regular binary tree has no rules as to how elements are arranged in the tree.
    It only satisfies the condition that each node should have a maximum of two children.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **binary search tree** (**BST**) is a special kind of a binary tree. That
    is, it is a tree that is structurally a binary tree. Functionally, it is a tree
    that stores its nodes in such a way to be able to search through the tree efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a structure to a BST. For a given node with a value, all the nodes
    in the left sub-tree are less than or equal to the value of that node. Also, all
    the nodes in the right sub-tree of this node are greater than that of the parent
    node. As an example, consider the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7916505-4ac0-48c2-af08-e7759443935c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of a BST. Testing our tree for the properties of a BST,
    you realize that all the nodes in the left sub-tree of the root node have a value
    less than 5\. Likewise, all the nodes in the right sub-tree have a value that
    is greater than 5\. This property applies to all the nodes in a BST, with no exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d79ef04-0fb1-4ad6-ac1b-adcfbb3ab621.png)'
  prefs: []
  type: TYPE_IMG
- en: Despite the fact that the preceding figure looks similar to the previous figure,
    it does not qualify as a BST. Node 7 is greater than the root node 5; however,
    it is located to the left of the root node. Node 4 is to the right sub-tree of
    its parent node 7, which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search tree implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us begin our implementation of a BST. We will want the tree to hold a reference
    to its own root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That's all that is needed to maintain the state of a tree. Let's examine the
    main operations on the tree in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search tree operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are essentially two operations that are needful for having a usable BST.
    These are the `insert` and `remove` operations. These operations must occur with
    the one rule that they must maintain the principle that gives the BST its structure.
  prefs: []
  type: TYPE_NORMAL
- en: Before we tackle the insertion and removal of nodes, let's discuss some equally
    important operations that will help us better understand the `insert` and `remove`
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the minimum and maximum nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the BST makes looking for the node with the maximum and minimum
    values very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the node with smallest value, we start our traversal from the root
    of the tree and visit the left node each time we reach a sub-tree. We do the opposite
    to find the node with the biggest value in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c229180d-2172-4729-bdfb-c90772604353.png)'
  prefs: []
  type: TYPE_IMG
- en: We move down from node 6 to 3 to 1 to get to the node with smallest value. Likewise,
    we go down 6, 8 to node 10, which is the node with the largest value.
  prefs: []
  type: TYPE_NORMAL
- en: This same means of finding the minimum and maximum nodes applies to sub-trees
    too. The minimum node in the sub-tree with root node 8 is 7\. The node within
    that sub-tree with the maximum value is 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that returns the minimum node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method. The method to return the
    maximum node does the opposite, where `current.left_child` now becomes `current.right_child`.
  prefs: []
  type: TYPE_NORMAL
- en: It takes **O**(*h*) to find the minimum or maximum value in a BST, where *h*
    is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the operations on a BST is the need to insert data as nodes. Whereas
    in our first implementation, we had to insert the nodes ourselves, here we are
    going to let the tree be in charge of storing its data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make a search possible, the nodes must be stored in a specific way.
    For each given node, its left child node will hold data that is less than its
    own value, as already discussed. That node's right child node will hold data greater
    than that of its parent node.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a new BST of integers by starting with the data 5\. To
    do this, we will create a node with its data attribute set to 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to add the second node with value 3, 3 is compared with 5, the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d212c46e-6046-4151-bb46-cf1ed26e4051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since 5 is greater than 3, it will be put in the left sub-tree of node 5\.
    Our BST will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0e1ead82-8fb4-4ae6-a8de-d0b1578f7bf9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tree satisfies the BST rule, where all the nodes in the left sub-tree are
    less than its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add another node of value 7 to the tree, we start from the root node with
    value 5 and do a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0225066-e12d-48d9-8d42-cd8da6f62f91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since 7 is greater than 5, the node with value 7 is situated to the right of
    this root.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we want to add a node that is equal to an existing node? We
    will simply add it as a left node and maintain this rule throughout the structure.
  prefs: []
  type: TYPE_NORMAL
- en: If a node already has a child in the place where the new node goes, then we
    have to move down the tree and attach it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another node with value 1\. Starting from the root of the tree,
    we do a comparison between 1 and 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13de8d9e-97ba-4834-9756-cf31e34a95eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The comparison reveals that 1 is less than 5, so we move our attention to the
    left node of 5, which is the node with value 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3621290e-d166-4e10-9c5f-824992152daa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We compare 1 with 3 and since 1 is less than 3, we move a level below node
    3 and to its left. But there is no node there. Therefore, we create a node with
    the value 1 and associate it with the left pointer of node 3 to obtain the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9c6c705-4546-4627-9866-f3c30baf1fae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have been dealing only with nodes that contain only integers or numbers.
    For numbers, the idea of greater than and lesser than are clearly defined. Strings
    would be compared alphabetically, so there are no major problems there either.
    But if you want to store your own custom data types inside a BST, you would have
    to make sure that your class supports ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a function that enables us to add data as nodes to the BST.
    We begin with a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you will be used to the fact that we encapsulate the data in a node.
    This way, we hide away the `node` class from the client code, who only needs to
    deal with the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A first check will be to find out whether we have a root node. If we don''t,
    the new node becomes the root node (we cannot have a tree without a root node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we walk down the tree, we need to keep track of the current node we are
    working on, as well as its parent. The variable `current` is always used for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn''t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we take care of the greater than or equal case. If the current node doesn''t
    have a right child node, then the new node is inserted as the right child node.
    Otherwise, we move down and continue looking for an insertion point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Insertion of a node in a BST takes **O**(*h*), where h is the height of the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important operation on a BST is the `deletion` or `removal` of nodes.
    There are three scenarios that we need to cater for during this process. The node
    that we want to remove might have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: No children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we simply detach it from its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/226a56a7-c9ba-47f9-b04b-e7cd9aff5349.png)'
  prefs: []
  type: TYPE_IMG
- en: Because node A has no children, we will simply dissociate it from its parent,
    node Z.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, when the node we want to remove has one child, the parent
    of that node is made to point to the child of that particular node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0c13358-279e-485a-8d1f-1ea43fe7e18e.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to remove node 6, which has as its only child, node 5, we point the
    left pointer of node 9 to node 5\. The relationship between the parent node and
    child has to be preserved. That is why we need to take note of how the child node
    is connected to its parent (which is the node about to be deleted). The child
    node of the deleted node is stored. Then we connect the parent of the deleted
    node to that child node.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complex scenario arises when the node we want to delete has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42141387-d400-4f4b-8ea8-774c2df6d9f0.png)'
  prefs: []
  type: TYPE_IMG
- en: We cannot simply replace node 9 with either node 6 or 13\. What we need to do
    is to find the next biggest descendant of node 9\. This is node 12\. To get to
    node 12, we move to the right node of node 9\. And then move left to find the
    leftmost node. Node 12 is called the in-order successor of node 9\. The second
    step resembles the move to find the maximum node in a sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: We replace the value of node 9 with the value 12 and remove node 12\. In removing
    node 12, we end up with a simpler form of node removal that has been addressed
    previously. Node 12 has no children, so we apply the rule for removing nodes without
    children accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `node` class does not have reference to a parent. As such, we need to use
    a helper method to search for and return the node with its parent node. This method
    is similar to the `search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We pass the parent and the found node to `parent` and `node` respectively with
    the line `parent, node = self.get_node_with_parent(data)`. It is helpful to know
    the number of children that the node we want to delete has. That is the purpose
    of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we need to begin handling the various conditions under which a
    node can be deleted. The first part of the `if` statement handles the case where
    the node has no children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`if parent:` is used to handle cases where there is a BST that has only one
    node in the whole of the three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where the node about to be deleted has only one child, the `elif`
    part of the `if` statement does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`next_node` is used to keep track of where the single node pointed to by the
    node we want to delete is. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as there exists a left node, `leftmost_node.left_child`
    will evaluate to `True` and the `while` loop will run. When we get to the leftmost
    node, it will either be a leaf node (meaning that it will have no child node)
    or have a right child.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the node about to be removed with the value of the in-order successor
    with `node.data = leftmost_node.data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. That is because the in-order successor can only have a right child
    as its only child.
  prefs: []
  type: TYPE_NORMAL
- en: The `remove` operation takes **O**(*h*), where h is the height of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the `insert` method organizes data in a specific way, we will follow
    the same procedure to find the data. In this implementation, we will simply return
    the data if it was found or `None` if the data wasn''t found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to start searching at the very top, that is, at the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We may have passed a leaf node, in which case the data doesn''t exist in the
    tree and we return `None` to the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also have found the data, in which case we return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the rules for how data is stored in the BST, if the data we are searching
    for is less than that of the current node, we need to go down the tree to the
    left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we only have one option left: the data we are looking for is greater than
    the data held in the current node, which means we go down the tree to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write some client code to test how the BST works. We create
    a tree and insert a few numbers between 1 and 10\. Then we search for all the
    numbers in that range. The ones that exist in the tree get printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tree traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visiting all the nodes in a tree can be done depth first or breadth first. These
    modes of traversal are not peculiar to only binary search trees but trees in general.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this traversal mode, we follow a branch (or edge) to its limit before recoiling
    upwards to continue traversal. We will be using the recursive approach for the
    traversal. There are three forms of depth-first traversal, namely `in-order`,
    `pre-order`, and `post-order`.
  prefs: []
  type: TYPE_NORMAL
- en: In-order traversal and infix notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of us are probably used to this way of representing an arithmetic expression,
    since this is the way we are normally taught in schools. The operator is inserted
    (infixed) between the operands, as in `3 + 4`. When necessary, parentheses can
    be used to build a more complex expression: `(4 + 5) * (5 - 3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this mode of traversal, you would visit the left sub-tree, the parent node,
    and finally the right sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive function to return an in-order listing of nodes in a tree is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We visit the node by printing the node and making two recursive calls with `current.left_child`
    and `current.right_child`.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-order traversal and prefix notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prefix notation is commonly referred to as Polish notation. Here, the operator
    comes before its operands, as in `+ 3 4`. Since there is no ambiguity of precedence,
    parentheses are not required: `* + 4 5 - 5 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: To traverse a tree in pre-order mode, you would visit the node, the left sub-tree,
    and the right sub-tree node, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix notation is well known to LISP programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive function for this traversal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note the order in which the recursive call is made.
  prefs: []
  type: TYPE_NORMAL
- en: Post-order traversal and postfix notation.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Postfix or **reverse Polish notation** (**RPN**) places the operator after
    its operands, as in `3 4 +`. As is the case with Polish notation, there is never
    any confusion over the precedence of operators, so parentheses are never needed:
    `4 5 + 5 3 - *`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this mode of traversal, you would visit the left sub-tree, the right sub-tree,
    and lastly the root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `post-order` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Breadth-first traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This kind of traversal starts from the root of a tree and visits the node from
    one level of the tree to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/798e2ee2-65c7-4c0a-bfea-165a880ed447.png)'
  prefs: []
  type: TYPE_IMG
- en: The node at level 1 is node 4\. We visit this node by printing out its value.
    Next, we move to level 2 and visit the nodes on that level, which are nodes 2
    and 8\. On the last level, level 3, we visit nodes 1, 3, 5, and 10.
  prefs: []
  type: TYPE_NORMAL
- en: The complete output of such a traversal is 4, 2, 8, 1, 3, 5, and 10.
  prefs: []
  type: TYPE_NORMAL
- en: This mode of traversal is made possible by using a queue data structure. Starting
    with the root node, we push it into a queue. The node at the front of the queue
    is accessed (dequeued) and either printed and stored for later use. The left node
    is added to the queue followed by the right node. Since the queue is not empty,
    we repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: A dry run of the algorithm will enqueue the root node 4, dequeue, and access,
    or visit the node. Nodes 2 and 8 are enqueued as they are the left and right nodes
    respectively. Node 2 is dequeued in order to be visited. Its left and right nodes,
    1 and 3, are enqueued. At this point, the node at the front of the queue is 8\.
    We dequeue and visit node 8, after which we enqueue its left and right nodes.
    So the process continues until the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We enqueue the root node and keep a list of the visited nodes in the `list_of_nodes`
    list. The `dequeue` class is used to maintain a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the number of elements in the `traversal_queue` is greater than zero, the
    body of the loop is executed. The node at the front of the queue is popped off
    and appended to the `list_of_nodes` list. The first `if` statement will `enqueue`
    the left child node of the `node` provided a left node exists. The second `if`
    statement does the same for the right child node.
  prefs: []
  type: TYPE_NORMAL
- en: The `list_of_nodes` is returned in the last statement.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of a binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shall now briefly look at what makes a BST a better idea than using a list
    for data that needs to be searched. Let us assume that we have the following dataset:
    5, 3, 7, 1, 4, 6, and 9\. Using a list, the worst-case scenario would require
    you to search through the entire list of seven elements before finding the search
    term:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/720691f5-6681-473f-a80c-1f1cdba24822.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Searching for 9 requires six jumps.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a tree, the worst-case scenario is three comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ace39d6e-f99f-432c-96fa-258b74bd400c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Searching for 9 requires two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, however, that if you insert the elements into the tree in the order
    1, 2, 3, 5, 6, 7, 9, then the tree would not be more efficient than the list.
    We would have to balance the tree first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/260a95e2-481f-4441-b0dc-991d1aafed8b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So not only is it important to use a BST but choosing a self-balancing tree
    helps to improve the `search` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Expression trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tree structure is also used to parse arithmetic and Boolean expressions.
    For example, the expression tree for `3 + 4` would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3bff613-f1df-495f-8f23-3b101b9b8633.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a slightly more complex expression, `(4 + 5) * (5-3)`, we would get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf51f42d-d166-483b-93ff-0c22004c45da.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Parsing a reverse Polish expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to build up a tree for an expression written in postfix notation.
    Then we will calculate the result. We will use a simple tree implementation. To
    keep it really simple, since we are going to grow the tree by merging smaller
    trees, we only need a tree node implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to build the tree, we are going to enlist the help of a stack. You
    will see why soon. But for the time being, let us just create an arithmetic expression
    and set up our stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since Python is a language that tries hard to have sensible defaults, its `split()`
    method splits on whitespace by default. (If you think about it, this is most likely
    what you would expect as well.) The result is going to be that expr is a list
    with the values 4, 5, +, 5, 3, - and *.
  prefs: []
  type: TYPE_NORMAL
- en: Each element of the expr list is going to be either an operator or an operand.
    If we get an operand then we embed it in a tree node and push it onto the stack.
    If we get an operator, on the other hand, then we embed the operator into a tree
    node and pop its two operands into the node's left and right children. Here we
    have to take care to ensure that the first pop goes into the right child, otherwise
    we will have problems with subtraction and division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to build the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we perform a conversion from string to int in the case of an operand.
    You could use `float()` instead, if you wanted to support floating point operands.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this operation, we should have one single element in the stack,
    and that holds the full tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now want to be able to evaluate the expression. We build the following
    little function to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This function is very simple. We pass in a node. If the node contains an operand,
    then we simply return that value. If we get an operator, however, then we perform
    the operation that the operator represents, on the node's two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to pop the root node off the stack and pass it into the `calc()`
    function and we should have the result of the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Running this program should yield the result 18, which is the result of `(4
    + 5) * (5 - 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we mentioned that if nodes are inserted into the tree in a sequential
    order, then the tree behaves more or less like a list, that is, each node has
    exactly one child node. We normally would like to reduce the height of the tree
    as much as possible, by filling up each row in the tree. This process is called
    balancing the tree.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of types of self-balancing trees, such as red-black trees,
    AA trees, and scapegoat trees. These balance the tree during each operation that
    modifies the tree, such as insert or delete.
  prefs: []
  type: TYPE_NORMAL
- en: There are also external algorithms that balance a tree. The benefit of these
    is that you wouldn't need to balance the tree on every single operation, but could
    rather leave balancing to the point when you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we shall briefly introduce the heap data structure. A heap is
    a specialization of a tree in which the nodes are ordered in a specific way. Heaps
    are divided into max and min heaps. In a max heap, each parent node must always
    be greater than or equal to its children. It follows that the root node must be
    the greatest value in the tree. A min heap is the opposite. Each parent node must
    be less than or equal to both its children. As a consequence, the root node holds
    the lowest value.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps are used for a number of different things. For one, they are used to implement
    priority queues. There is also a very efficient sorting algorithm, called heap
    sort, that uses heaps. We are going to study these in depth in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at tree structures and some example uses of
    them. We studied binary trees in particular, which is a subtype of trees where
    each node has at most two children.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how a binary tree can be used as a searchable data structure with
    a BST. We saw that, in most cases, finding data in a BST is faster than in a linked
    list, although this is not the case if the data is inserted sequentially, unless
    of course the tree is balanced.
  prefs: []
  type: TYPE_NORMAL
- en: The breadth- and depth-first search traversal modes were also implemented using
    queue recursion.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how a binary tree can be used to represent an arithmetic or
    a Boolean expression. We built up an expression tree to represent an arithmetic
    expression. We showed how to use a stack to parse an expression written in RPN,
    build up the expression tree, and finally traverse it to get the result of the
    arithmetic expression.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mentioned heaps, a specialization of a tree structure. We have tried
    to at least lay down the theoretical foundation for the heap in this chapter,
    so that we can go on to implement heaps for different purposes in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL

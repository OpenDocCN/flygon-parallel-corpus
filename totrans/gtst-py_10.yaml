- en: Hashing and Symbol Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously looked at lists, where items are stored in sequence and accessed
    by index number. Index numbers work well for computers. They are integers so they
    are fast and easy to manipulate. However, they don't always work so well for us.
    If we have an address book entry, for example, with index number 56, that number
    doesn't tell us much. There is nothing to link a particular contact with number
    56\. It just happens to be the next available position in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to look at a similar structure: a dictionary.
    A dictionary uses a keyword instead of an index number. So, if that contact was
    called *James*, we would probably use the keyword *James* to locate the contact.
    That is, instead of accessing the contact by calling *contacts [56]*, we would
    use *contacts ["james"]*.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are often built using hash tables. As the name suggests, hash tables
    rely on a concept called **hashing**. That is where we are going to begin our
    discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different functions with elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hashing is the concept of converting data of arbitrary size into data of fixed
    size. A little bit more specifically, we are going to use this to turn strings
    (or possibly other data types) into integers. This possibly sounds more complex
    than it is so let's look at an example. We want to hash the expression `hello
    world`, that is, we want to get a numeric value that we could say *represents*
    the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `ord()` function, we can get the ordinal value of any character.
    For example, the `ord(''f'')` function gives 102\. To get the hash of the whole
    string, we could just sum the ordinal numbers of each character in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/52c1ad6d-2e2e-45a3-93da-6ce146981c11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This works fine. However, note that we could change the order of the characters
    in the string and get the same hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the sum of the ordinal values of the characters would be the same for the
    string `gello xorld` as well, since `g` has an ordinal value which is one less
    than that of `h`, and x has an ordinal value that is one greater than that of
    `w`, hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/e3d188b5-0976-477b-8921-37f6bf72d9e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect hashing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A perfect hashing function is one in which each string (as we are limiting the
    discussion to strings for now) is guaranteed to be unique. In practice, hashing
    functions normally need to be very fast, so trying to create a function that will
    give each string a unique hash value is normally not possible. Instead, we live
    with the fact that we sometimes get collisions (two or more strings having the
    same hash value), and when that happens, we come up with a strategy for resolving
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, we can at least come up with a way to avoid some of the collisions.
    We could, for example, add a multiplier, so that the hash value for each character
    becomes the multiplier value, multiplied by the ordinal value of the character.
    The multiplier then increases as we progress through the string. This is shown
    in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this function on the strings that we used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8414fd29-b1a2-4984-b8d9-df385915fc59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the last row is the result of multiplying the values in rows 2 and
    3 such that 104 x 1 equals 104, as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we get different hash values for our strings. Of course, this doesn''t
    mean that we have a perfect hash. Let us try the strings `ad` and `ga`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There we still get the same hash value for two different strings. As we have
    said before, this doesn't have to be a problem, but we need to devise a strategy
    for resolving collisions. We shall look at that shortly, but first we will study
    an implementation of a hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **hash table** is a form of list where elements are accessed by a keyword
    rather than an index number. At least, this is how the client code will see it.
    Internally, it will use a slightly modified version of our hashing function in
    order to find the index position in which the element should be inserted. This
    gives us fast lookups, since we are using an index number which corresponds to
    the hash value of the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a class to hold hash table items. These need to have a
    key and a value, since our hash table is a key-value store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a very simple way to store items. Next, we start working on the
    hash table class itself. As usual, we start off with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The hash table uses a standard Python list to store its elements. We could equally
    well have used the linked list that we developed previously, but right now our
    focus is on understanding the hash table, so we shall use what is at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the size of the hash table to 256 elements to start with. Later, we
    will look at strategies for how to grow the table as we begin filling it up. We
    now initialize a list containing 256 elements. These elements are often referred
    to as slots or buckets. Finally, we add a counter for the number of actual hash
    table elements we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3a6bc6fe-7231-4fee-bd5b-6be6fba0a9c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to notice the difference between the size and count of a table.
    Size of a table refers to the total number of slots in the table (used or unused).
    Count of the table, on the other hand, simply refers to the number of slots that
    are filled, or put another way, the number of actual key-value pairs we have added
    to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add our hashing function to the table. It will be similar
    to what we evolved in the section on hashing functions, but with a slight difference:
    we need to ensure that our hashing function returns a value between 1 and 256
    (the size of the table). A good way of doing so is to return the remainder of
    dividing the hash by the size of the table, since the remainder is always going
    to be an integer value between 0 and 255.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the hashing function is only meant to be used internally by the class, we
    put an underscore(`_`) at the beginning of the name to indicate this. This is
    a normal Python convention for indicating that something is meant for internal
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the time being, we are going to assume that keys are strings. We shall discuss
    how one can use non-string keys later. For now, just bear in mind that the `_hash()` function
    is going to generate the hash value of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Putting elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We add elements to the hash with the `put()` function and retrieve with the `get()`
    function. First, we will look at the implementation of the `put()` function. We
    start by embedding the key and the value into the `HashItem` class and computing
    the hash of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to find an empty slot. We start at the slot that corresponds to
    the hash value of the key. If that slot is empty, we insert our item there.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the slot is not empty and the key of the item is not the same as
    our current key, then we have a collision. This is where we need to figure out
    a way to handle a conflict. We are going to do this by adding one to the previous
    hash value we had and getting the remainder of dividing this value by the size
    of the hash table. This is a linear way of resolving collisions and it is quite
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22dd9b2d-b701-452b-925e-4208a688ce80.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have found our insertion point. If this is a new element (that is, it contained
    `None` previously), then we increase the count by one. Finally, we insert the
    item into the list at the required position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Getting elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of the `get()` method should return the value that corresponds
    to a key. We also have to decide what to do in the event that the key does not
    exist in the table. We start by calculating the hash of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simply start looking through the list for an element that has the key
    we are searching for, starting at the element which has the hash value of the
    key that was passed in. If the current element is not the correct one, then, just
    like in the `put()` method, we add one to the previous hash value and get the
    remainder of dividing this value by the size of the list. This becomes our new
    index. If we find an element that contains `None`, we stop looking. If we find
    our key, we return the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d58b265-70e8-4da9-8a91-370070916d43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we decide what to do if the key was not found in the table. Here we
    will choose to return `None`. Another good alternative may be to raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Testing the hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our hash table, we create a `HashTable`, put a few elements in it,
    then try to retrieve these. We will also try to `get()` a key that does not exist.
    Remember the two strings ad and ga which returned the same hash value by our hashing
    function? For good measure, we throw those in as well, just to see that the collision
    is properly resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, looking up the key worst returns `None`, since the key does
    not exist. The keys `ad` and `ga` also return their corresponding values, showing
    that the collision between them is dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: Using [] with the hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `put()` and `get()` methods doesn''t look very good, however. We
    want to be able to treat our hash table as a list, that is, we would like to be
    able to use `ht["good"]` instead of `ht.get("good")`. This is easily done with
    the special methods `__setitem__()` and `__getitem__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test code can now look like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also print the number of elements in the hash table. This is
    useful for our next discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Non-string keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, it makes more sense to just use strings for the keys. However,
    if necessary, you could use any other Python type. If you create your own class
    that you want to use as a key, you will probably want to override the special
    `__hash__()` function for that class, so that you get reliable hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you would still have to calculate the modulo (%) of the hash value
    and the size of the hash table to get the slot. That calculation should happen
    in the hash table and not in the key class, since the table knows its own size
    (the key class should not know anything about the table that it belongs to).
  prefs: []
  type: TYPE_NORMAL
- en: Growing a hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, the hash table's size was set to 256\. Obviously, as we add
    elements to the list, we begin to fill up the empty slots. At some point, all
    the slots will be filled up and the table will be full. To avoid this, we can
    grow the table when it is getting full.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we compare the size and the count. Remember that `size` held the
    total number of slots and `count` the number of those slots that contained elements?
    Well, if `count` equals `size` then we have filled up the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash table''s load factor gives us an indication of how large a portion
    of the available slots are being used. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb6128dd-4fa3-454f-8a3a-e6618c78605b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the load factor approaches 1, we need to grow the table. In fact, we should
    do it before it gets there in order to avoid gets becoming too slow. A value of
    0.75 may be a good value in which to grow the table.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how much to grow the table by. One strategy would be to
    simply double the size of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Open addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collision resolution mechanism we used in our example, linear probing, is
    an example of an open addressing strategy. Linear probing is really simple since
    we use a fixed interval between our probes. There are other open addressing strategies
    as well but they all share the idea that there is an array of slots. When we want
    to insert a key, we check whether the slot already has an item or not. If it does,
    we look for the next available slot.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a hash table that contains 256 slots, then 256 is the maximum number
    of elements in that hash. Moreover, as the load factor increases, it will take
    longer to find the insertion point for the new element.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these limitations, we may prefer to use a different strategy to resolve
    collisions, such as chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chaining is a strategy for resolving conflicts and avoiding the limit to the
    number of elements in a hash table. In chaining, the slots in the hash table are
    initialized with empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27c7922b-721c-462c-b364-80c3f9043576.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When an element is inserted, it will be appended to the list that corresponds
    to that element''s hash value. That is, if you have two elements that both have
    the hash value 1167, these two elements will both be added to the list that exists
    in slot 1167 of the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0a9e8cd-66ef-4a1f-9d71-426b40f86976.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a list of entries with hash value 51.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining then avoids conflict by allowing multiple elements to have the same
    hash value. It also avoids the problem of insertions as the load factor increases,
    since we don't have to look for a slot. Moreover, the hash table can hold more
    values than the number of available slots, since each slot holds a list that can
    grow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if a particular slot has many items, searching them can get very
    slow, since we have to do a linear search through the list until we find the element
    that has the key we want. This can slow down retrieval, which is not good, since
    hash tables are meant to be efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da74b737-63a5-4d5f-83c0-e1ca96b57b91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram demonstrates a linear search through list items until
    we find a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using lists in the table slots, we could use another structure that
    allows for fast searching. We have already looked at **binary search trees** (**BSTs**).
    We could simply put an (initially empty) BST in each slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc74e411-b929-4117-816f-03466949e072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Slot 51 holds a BST which we search for the key. But we would still have a
    potential problem: depending on the order in which the items were added to the
    BST, we could end up with a search tree that is as inefficient as a list. That
    is, each node in the tree has exactly one child. To avoid this, we would need
    to ensure that our BST is self-balancing.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbol tables are used by compilers and interpreters to keep track of the symbols
    that have been declared and information about them. Symbol tables are often built
    using hash tables, since it is important to efficiently retrieve a symbol in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example. Suppose we have the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two symbols, name and age. They belong to a namespace, which could
    be `__main__`, but it could also be the name of a module if you placed it there.
    Each symbol has a value; name has the value `Joe` and age has the value `27`.
    A symbol table allows the compiler or the interpreter to look these values up.
    The symbols name and age become the keys in our hash table. All the other information
    associated with it, such as the value, become part of the value of the symbol
    table entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only variables are symbols, but functions and classes as well. They will
    all be added to our symbol table, so that when any one of them needs to be accessed,
    they are accessible from the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d9af336-8933-481d-ac37-6241657bfd7d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, each module that is loaded has its own symbol table. The symbol
    table is given the name of that module. This way, modules act as namespaces. We
    can have multiple symbols called age, as long as they exist in different symbol
    tables. To access either one, we access it through the appropriate symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c21ded3a-54f5-4e40-ae10-437dec4e39ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at hash tables. We looked at how to write a
    hashing function to turn string data into integer data. Then we looked at how
    we can use hashed keys to quickly and efficiently look up the value that corresponds
    to a key.
  prefs: []
  type: TYPE_NORMAL
- en: We also noticed how hashing functions are not perfect and that several strings
    can end up having the same hash value. This led us to look at collision resolution
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at growing a hash table and how to look at the load factor of the
    table in order to determine exactly when to grow the hash.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of the chapter, we studied symbol tables, which often are
    built using hash tables. Symbol tables allow a compiler or an interpreter to look
    up a symbol (variable, function, class, and so on) that has been defined and retrieve
    all information about it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about graphs and other algorithms.
  prefs: []
  type: TYPE_NORMAL

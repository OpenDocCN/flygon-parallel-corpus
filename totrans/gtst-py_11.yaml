- en: Graphs and Other Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about graphs. This is a concept that comes
    from the branch of mathematics called graph theory.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are used to solve a number of computing problems. They also have much
    less structure than other data structures we have looked at and things like traversal
    can be much more unconventional, as we shall see.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what graphs are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know the types of graphs and their constituents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know how to represent a graph and traverse it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a fundamental idea of what priority queues are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to implement a priority queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to determine the ith smallest element in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graph is a set of vertices and edges that form connections between the vertices.
    In a more formal approach, a graph G is an ordered pair of a set V of vertices
    and a set E of edges given as `G = (V, E)` in formal mathematical notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a graph is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/314da5e8-4407-450b-b87c-582443b5a40e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now go through some definitions of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node or vertex**: A point, usually represented by a dot in a graph. The vertices
    or nodes are A, B, C, D, and E.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: This is a connection between two vertices. The line connecting A
    and B is an example of an edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: When an edge from a node is incident on itself, that edge forms a
    loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree of a vertex**: This is the number of vertices that are incident on
    a given vertex. The degree of vertex B is `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adjacency**: This refers to the connection(s) between a node and its neighbor.
    The node C is adjacent to node A because there is an edge between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: A sequence of vertices where each adjacent pair is connected by an
    edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed and undirected graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphs can be classified based on whether they are undirected or directed.
    An undirected graph simply represents edges as lines between the nodes. There
    is no additional information about the relationship between the nodes than the
    fact that they are connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a00af33a-cce6-410c-87a6-b3a8127808a5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a directed graph, the edges provide orientation in addition to connecting
    nodes. That is, the edges, which will be drawn as lines with an arrow, will point
    in which direction the edge connects the two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fa6d3a7d-d3ba-4c05-bf97-2ff2cc3ee21e.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrow of an edge determines the flow of direction. One can only move from
    **A** to **B** in the preceding diagram. Not **B** to **A**.
  prefs: []
  type: TYPE_NORMAL
- en: Weighted graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A weighted graph adds a bit of extra information to the edges. This can be
    a numerical value that indicates something. Let''s say, for example, that the
    following graph indicates different ways to get from point **A** to point **D**.
    You can either go straight from **A** to **D**, or choose to pass through **B**
    and **C**. Associated with each edge is the amount of time in minutes the journey
    to the next node will take:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/297e002c-8a8f-467a-a1c8-ef7abeaa99c0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps the journey **AD** would require you to ride a bike (or walk). **B**
    and **C** might represent bus stops. At **B** you would have to change to a different
    bus. Finally, **CD** may be a short walk to reach **D**.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, **AD** and **ABCD** represent two different paths. **A** path
    is simply a sequence of edges that you *pass through* between two nodes. Following
    these paths, you see that the total journey **AD** takes **40** minutes, whereas
    the journey **ABCD** takes **25** minutes. If your only concern is time, you would
    be better off traveling along **ABCD**, even with the added inconvenience of changing
    buses.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that edges can be directed and may hold other information, such as
    time taken or whatever other value the move along a path is associated with, indicates
    something interesting. In previous data structures that we have worked with, the
    *lines* we have drawn between nodes have simply been connectors. Even when they
    had arrows pointing from a node to another, that was easy to represent in the
    node class by using `next` or `previous`, `parent` or `child`.
  prefs: []
  type: TYPE_NORMAL
- en: With graphs, it makes sense to see edges as objects just as much as nodes. Just
    like nodes, edges can contain extra information that is necessary to follow a
    particular path.
  prefs: []
  type: TYPE_NORMAL
- en: Graph representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs can be represented in two main forms. One way is to use an adjacency
    matrix and the other is to use an adjacency list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall be working with the following figure to develop both types of representation
    for graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae318786-366f-4a2f-858c-bbf6dd4b14e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Adjacency list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple list can be used to present a graph. The indices of the list will
    represent the nodes or vertices in the graph. At each index, the adjacent nodes
    to that vertex can be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e8839a93-3591-4613-8321-298d514d2271.png)'
  prefs: []
  type: TYPE_IMG
- en: The numbers in the box represent the vertices. Index **0** represents vertex
    **A**, with its adjacent nodes being **B** and **C**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a list for the representation is quite restrictive because we lack the
    ability to directly use the vertex labels. A dictionary is therefore more suited.
    To represent the graph in the diagram, we can use the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we easy establish that vertex **A** has the adjacent vertices **B** and
    **C**. Vertex F has vertex **C** as its only neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach by which a graph can be represented is by using an adjacency
    matrix. A matrix is a two-dimensional array. The idea here is to represent the
    cells with a 1 or 0 depending on whether two vertices are connected by an edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an adjacency list, it should be possible to create an adjacency matrix.
    A sorted list of keys of graph is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of the keys is used to provide the dimensions of the matrix which
    are stored in `cols` and `rows`. These values in `cols` and `rows` are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We then set up a `cols` by `rows` array, filling it with zeros. The `edges_list`
    variable will store the tuples that form the edges of in the graph. For example,
    an edge between node A and B will be stored as (A, B).
  prefs: []
  type: TYPE_NORMAL
- en: 'The multidimensional array is filled using a nested for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The neighbors of a vertex are obtained by `graph[key]`. The key in combination
    with the `neighbor` is then used to create the tuple stored in `edges_list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the iteration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What needs to be done now is to fill the our multidimensional array by using
    1 to mark the presence of an edge with the line `adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `matrix_elements` array has its `rows` and `cols` starting from A through
    to E with the indices 0 through to 5\. The `for` loop iterates through our list
    of tuples and uses the `index` method to get the corresponding index where an
    edge is to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency matrix produced looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At column 1 and row 1, the 0 there represents the absence of an edge between
    A and A. On column 2 and row 3, there is an edge between C and B.
  prefs: []
  type: TYPE_NORMAL
- en: Graph traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since graphs don't necessarily have an ordered structure, traversing a graph
    can be more involving. Traversal normally involves keeping track of which nodes
    or vertices have already been visited and which ones have not. A common strategy
    is to follow a path until a dead end is reached, then walking back up until there
    is a point where there is an alternative path. We can also iteratively move from
    one node to another in order to traverse the full graph or part of it. In the
    next section, we will discuss breadth and depth-first search algorithms for graph
    traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The breadth-first search algorithm starts at a node, chooses that node or vertex
    as its root node, and visits the neighboring nodes, after which it explores neighbors
    on the next level of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram as a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a504a846-1f62-4eda-a404-e822ab78931b.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram is an example of an undirected graph. We continue to use this type
    of graph to help make explanation easy without being too verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency list for the graph is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In trying to traverse this graph breadth first, we will employ the use of a
    queue. The algorithm creates a list to store the nodes that have been visited
    as the traversal process proceeds. We shall start our traversal from node A.
  prefs: []
  type: TYPE_NORMAL
- en: Node A is queued and added to the list of visited nodes. Afterward, we use a
    `while` loop to effect traversal of the graph. In the `while` loop, node A is
    dequeued. Its unvisited adjacent nodes B, G, and D are sorted in alphabetical
    order and queued up. The queue will now contain the nodes B, D, and G. These nodes
    are also added to the list of visited nodes. At this point, we start another iteration
    of the `while` loop because the queue is not empty, which also means we are not
    really done with the traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Node B is dequeued. Out of its adjacent nodes A, F, and E, node A has already
    been visited. Therefore, we only enqueue the nodes E and F in alphabetical order.
    Nodes E and F are then added to the list of visited nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our queue now holds the following nodes at this point: D, G, E, and F. The
    list of visited nodes contains A, B, D, G, E, F.'
  prefs: []
  type: TYPE_NORMAL
- en: Node D is dequeued but all of its adjacent nodes have been visited so we simply
    dequeue it. The next node at the front of the queue is G. We dequeue node G but
    we also find out that all its adjacent nodes have been visited because they are
    in the list of visited nodes. Node G is also dequeued. We dequeue node E too because
    all of its nodes have been visited. The only node in the queue now is node F.
  prefs: []
  type: TYPE_NORMAL
- en: Node F is dequeued and we realize that out of its adjacent nodes B, D, and C,
    only node C has not been visited. We then enqueue node C and add it to the list
    of visited nodes. Node C is dequeued. Node C has the adjacent nodes F and H but
    F has already been visited, leaving node H. Node H is enqueued and added to the
    list of visited nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last iteration of the `while` loop will lead to node H being dequeued.
    Its only adjacent node C has already been visited. Once the queue is completely
    empty, the loop breaks.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the traversing the graph in the diagram is A, B, D, G, E, F, C,
    H.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for a breadth-first search is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we want to find out whether a set of nodes are in the list of visited nodes,
    we use the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
    This uses the set object's difference method to find the nodes that are in `adj_nodes`
    but not in `visited_vertices`.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case scenario, each vertex or node and edge will be traversed,
    thus the time complexity of the algorithm is `O(|V| + |E|)`, where `|V|` is the
    number of vertices or nodes while `|E|` is the number of edges in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, this algorithm traverses the depth of any particular
    path in the graph before traversing its breadth. As such, child nodes are visited
    first before sibling nodes. It works on finite graphs and requires the use of
    a stack to maintain the state of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm begins by creating a list to store the visited nodes. The `graph_stack`
    stack variable is used to aid the traversal process. For continuity's sake, we
    are using a regular Python list as a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting node, called `root`, is passed with the graph''s adjacency matrix,
    graph. `root` is pushed onto the stack. `node = root` holds the first node in
    the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The body of the `while` loop will be executed provided the stack is not empty.
    If `node` is not in the list of visited nodes, we add it. All adjacent nodes to
    `node` are collected by `adj_nodes = graph[node]`. If all the adjacent nodes have
    been visited, we pop that node from the stack and set `node` to `graph_stack[-1]`.
    `graph_stack[-1]` is the top node on the stack. The `continue` statement jumps
    back to the beginning of the while loop's test condition.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, not all the adjacent nodes have been visited, the nodes
    that are yet to be visited are obtained by finding the difference between the
    `adj_nodes` and `visited_vertices` with the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  prefs: []
  type: TYPE_NORMAL
- en: The first item within `sorted(remaining_elements)` is assigned to `first_adj_node`,
    and pushed onto the stack. We then point the top of the stack to this node.
  prefs: []
  type: TYPE_NORMAL
- en: When the `while` loop exists, we will return the `visited_vertices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dry running the algorithm will prove useful. Consider the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d0766e9-a5f6-44e9-94e9-430d7e17d19e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The adjacency list of such a graph is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Node A is chosen as our beginning node. Node A is pushed onto the stack and
    added to the `visisted_vertices` list. In doing so, we mark it as having been
    visited. The stack `graph_stack` is implemented with a simple Python list. Our
    stack now has A as its only element. We examine node A''s adjacent nodes B and
    S. To test whether all the adjacent nodes of A have been visited, we use the if
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If all the nodes have been visited, we pop the top of the stack. If the stack
    `graph_stack` is not empty, we assign the node on top of the stack to `node` and
    start the beginning of another execution of the body of the `while` loop. The
    statement `set(adj_nodes).issubset(set(visited_vertices))` will evaluate to `True`
    if all the nodes in `adj_nodes` are a subset of `visited_vertices`. If the if
    statement fails, it means that some nodes remain to be visited. We obtain that
    list of nodes with `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the diagram, nodes **B** and **S** will be stored in `remaining_elements`.
    We will access the list in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We sort `remaining_elements` and return the first node to `first_adj_node`.
    This will return B. We push node B onto the stack by appending it to the `graph_stack`.
    We prepare node B for access by assigning it to `node`.
  prefs: []
  type: TYPE_NORMAL
- en: On the next iteration of the `while` loop, we add node B to the list of `visited
    nodes`. We discover that the only adjacent node to B, which is A, has already
    been visited. Because all the adjacent nodes of B have been visited, we pop it
    off the stack, leaving node A as the only element on the stack. We return to node
    A and examine whether all of its adjacent nodes have been visited. The node A
    now has S as the only unvisited node. We push S to the stack and begin the whole
    process again.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the traversal is A-B-S-C-D-E-H-G-F.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first searches find application in solving maze problems, finding connected
    components, and finding the bridges of a graph, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful graph methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, you are concerned with finding a path between two nodes. You may
    also want to find all the paths between nodes. Another useful method would be
    to find the shortest path between nodes. In an unweighted graph, this would simply
    be the path with the lowest number of edges between them. In a weighted graph,
    as you have seen, this could involve calculating the total weight of passing through
    a set of edges.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in a different situation, you may want to find the longest or shortest
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Priority queues and heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A priority queue is basically a type of queue that will always return items
    in order of priority. This priority could be, for example, that the lowest item
    is always popped off first. Although it is called a queue, priority queues are
    often implemented using a heap, since it is very efficient for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that, in a store, customers queue in a line where service is only rendered
    at the front of the queue. Each customer will spend some time in the queue to
    get served. If the waiting times for the customers in the queue are 4, 30, 2,
    and 1, then the average time spent in the queue becomes `(4 + 34 + 36 + 37)/4`,
    which is `27.75`. However, if we change the order of service such that customers
    with the least amount of waiting time are served first, then we obtain a different
    average waiting time. In doing so, we calculate our new average waiting time by
    `(1 + 3 + 7 + 37)/4`, which now equals `12`, a better average waiting time. Clearly,
    there is merit to serving the customers from the least waiting time upward. This
    method of selecting the next item by priority or some other criterion is the basis
    for creating priority queues.
  prefs: []
  type: TYPE_NORMAL
- en: A heap is a data structure that satisfies the heap property. The heap property
    states that there must be a certain relationship between a parent node and its
    child nodes. This property must apply through the entire heap.
  prefs: []
  type: TYPE_NORMAL
- en: In a min heap, the relationship between parent and children is that the parent
    must always be less than or equal to its children. As a consequence of this, the
    lowest element in the heap must be the root node.
  prefs: []
  type: TYPE_NORMAL
- en: In a max heap, on the other hand, the parent is greater than or equal to its
    child or its children. It follows from this that the largest value makes up the
    root node.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from what we just mentioned, heaps are trees and, to be more
    specific, binary trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we are going to use a binary tree, we will actually use a list to
    represent it. This is possible because the heap will store a complete binary tree.
    A complete binary tree is one in which each row must be fully filled before starting
    to fill the next row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69b6c928-300f-4b6f-a4f3-5e4d84c63cae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the math with indexes easier, we are going to leave the first item
    in the list (index 0) empty. After that, we place the tree nodes into the list,
    from top to bottom, left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/908ee528-61fc-4fe4-8ed4-f9c34a763f6f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you observe carefully, you will notice that you can retrieve the children
    of any node n very easily. The left child is located at `2n` and the right child
    is located at `2n + 1`. This will always hold true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at a min heap implementation. It shouldn''t be difficult
    to reverse the logic in order to get a max heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We initialize our heap list with a zero to represent the dummy first element
    (remember that we are only doing this to make the math simpler). We also create
    a variable to hold the size of the heap. This would not be necessary as such,
    since we could check the size of the list, but we would always have to remember
    to reduce it by one. So we chose to keep a separate variable instead.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inserting an item is very simple in itself. We add the new element to the end
    of the list (which we understand to be the bottom of the tree). Then we increment
    the size of the heap by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But after each insert, we need to float the new element up if needed. Bear
    in mind that the lowest element in the min heap needs to be the root element.
    We first create a helper method called `float` that takes care of this. Let us
    look at how it is meant to behave. Imagine that we have the following heap and
    want to insert the value `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e6a9c152-f5f6-4ca7-a420-cb01171a9ff2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The new element has occupied the last slot in the third row or level. Its index
    value is **7**. Now we compare that value with its parent. The parent is at index
    `7/2 = 3` (integer division). That element holds **6** so we swap the **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1646d43e-9a53-45d8-813b-7deece8019e7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our new element has been swapped and moved up to index **3**. We have not reached
    the top of the heap yet (`3 / 2 > 0`), so we continue. The new parent of our element
    is at index `3/2 = 1`. So we compare and, if necessary, swap again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1653f9b-b5d1-4651-a409-efb01743a112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the final swap, we are left with the heap looking as follows. Notice
    how it adheres to the definition of a heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9ef20a5-3355-455b-a953-453641987aa6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here follows an implementation of what we have just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to loop until we have reached the root node so that we can keep
    floating the element up as high as it needs to go. Since we are using integer
    division, as soon as we get below 2, the loop will break out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare parent and child. If the parent is greater than the child, swap the
    two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s not forget to move up the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This method ensures that the elements are ordered properly. Now we just need
    to call this from our `insert` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice the last line in insert calls the `float()` method to reorganize the
    heap as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Pop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like insert, `pop()` is by itself a simple operation. We remove the root
    node and decrement the size of the heap by one. However, once the root has been
    popped off, we need a new root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this as simple as possible, we just take the last item in the list
    and make it the new root. That is, we move it to the beginning of the list. But
    now we might not have the lowest element at the top of the heap, so we perform
    the opposite of the float operation: we let the new root node sink down as required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with insert, let us have a look at how the whole operation is meant
    to work on an existing heap. Imagine the following heap. We pop off the `root`
    element, leaving the heap temporarily rootless:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1eb8cd9b-d17d-4c76-8854-5bb8ca4edb34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we cannot have a rootless heap, we need to fill this slot with something.
    If we choose to move up one of the children, we will have to figure out how to
    rebalance the entire tree structure. So instead, we do something really interesting.
    We move up the very last element in the list to fill the position of the `root`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85ef095d-22b3-450c-87b7-6e51d530ac49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now this element clearly is not the lowest in the heap. This is where we begin
    to sink it down. First we need to determine where to sink it down. We compare
    the two children, so that the lowest element will be the one to float up as the
    root sinks down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13caacb4-06e6-4206-823c-720d634f2268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The right child is clearly less. Its index is **3**, which represents the root
    index `* 2 + 1`. We go ahead and compare our new root node with the value at this
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c99e234d-5ac4-4f47-8083-768d443bb116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our node has jumped down to index **3**. We need to compare it to the lesser
    of its children. However, now we only have one child, so we don''t need to worry
    about which child to compare against (for a min heap, it is always the lesser
    child):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/601969bf-ac39-4be8-8160-e2ec826e6e9a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is no need to swap here. Since there are no more rows either, we are done.
    Notice again how, after the `sink()` operation is completed, our heap adheres
    to the definition of a heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can begin implementing this. Before we do the `sink()` method itself,
    notice how we need to determine which of the children to compare our parent node
    against. Well, let us put that selection in its own little method, just to make
    the code look a little simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We may get beyond the end of the list, in which case we return the index of
    the left child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we simply return the index of the lesser of the two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the `sink` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we are going to loop so that we can sink our element down as far
    as is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to know which of the left or the right child to compare against.
    This is where we make use of the `minindex()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in the `float()` method, we compare parent and child to see whether
    we need to swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to make sure that we move down the tree so that we don''t get stuck
    in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing remaining now is to implement `pop()` itself. This is very straightforward
    as the grunt work is performed by the `sink()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Testing the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we just need some code to test the heap. We begin by creating our heap
    and inserting some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the heap list, just to inspect how the elements are ordered. If
    you redraw this as a tree structure, you should notice that it meets the required
    properties of a heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will pop off the items, one at a time. Notice how the items come out
    in a sorted order, from lowest to highest. Also notice how the heap list changes
    after each pop. It is a good idea to take out a pen and paper and to redraw this
    list as a tree after each pop, to fully understand how the `sink()` method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the chapter on sorting algorithms, we will reorganize the code for the heap
    sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the min heap working properly and understand how it works, it
    should be a simple task to implement a max heap. All you have to do is to reverse
    the logic.
  prefs: []
  type: TYPE_NORMAL
- en: Selection algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection algorithms fall under a class of algorithms that seek to answer the
    problem of finding the ith-smallest element in a list. When a list is sorted in
    ascending order, the first element in the list will be the smallest item in the
    list. The second element in the list will be the second-smallest element in the
    list. The last element in the list will be the last-smallest element in the list
    but that will also qualify as the largest element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In creating the heap data structure, we have come to the understanding that
    a call to the `pop` method will return the smallest element in the heap. The first
    element to pop off a min heap is the first-smallest element in the list. Similarly,
    the seventh element to be popped off the min heap will be the seventh-smallest
    element in the list. Therefore, to find the ith-smallest element in a list will
    require us to pop the heap *i* number of times. That is a very simple and efficient
    way of finding the ith-smallest element in a list.
  prefs: []
  type: TYPE_NORMAL
- en: But in [Chapter 14](d284cb2f-9636-47b1-b416-c84eb5be9fd2.xhtml), *Selection
    Algorithms*, we will study another approach by which we can find the ith-smallest
    element in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Selection algorithms have applications in filtering out noisy data, finding
    the median, smallest, and largest elements in a list, and can even be applied
    in computer chess programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs and heaps have been treated in this chapter. We looked at ways to represent
    a graph in Python using lists and dictionaries. In order to traverse the graph,
    we looked at breadth-first searches and depth-first searches.
  prefs: []
  type: TYPE_NORMAL
- en: We then switched our attention to heaps and priority queues to understand their
    implementation. The chapter ended with using the concept of a heap to find the
    ith-smallest element in a list.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of graphs is very complicated and just one chapter will not do justice
    to it. The journey with nodes will end with this chapter. The next chapter will
    usher us into the arena of searching and the various means by which we can efficiently
    search for items in lists.
  prefs: []
  type: TYPE_NORMAL

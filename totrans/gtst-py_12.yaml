- en: Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the data structures that have been developed in the preceding chapters,
    one critical operation performed on all of them is searching. In this chapter,
    we shall explore the different strategies that can be used to find elements in
    a collection of items.
  prefs: []
  type: TYPE_NORMAL
- en: One other important operation that makes use of searching is sorting. It is
    virtually impossible to sort without some variant of a search operation. The "how
    of searching" is also important as it has a bearing on how quick a sorting algorithm
    ends up performing.
  prefs: []
  type: TYPE_NORMAL
- en: Searching algorithms are categorized under two broad types. One category assumes
    that the list of items to apply the searching operation on, has already been sorted
    whiles the other does not.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of a search operation is heavily influenced by whether the items
    about to be searched have already been sorted or not as we will see in the subsequent
    topics too.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us focus our discussions on linear search, performed on a typical Python
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d36496b-cfbd-4da0-8a58-8d7731f4d253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding list has elements that are accessible through the list index.
    To find an element in the list we employ the linear searching technique. This
    technique traverses the list of elements, by using the index to move from the
    beginning of the list to the end. Each element is examined and if it does not
    match the search item, the next item is examined. By hopping from one item to
    its next, the list is traversed sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: In treating the sections in this chapter and others, we use a list with integers
    to enhance our understanding since integers lend themselves to easy comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list containing elements **60**, **1**, **88**, **10**, and **100** is an
    example of an unordered list. The items in the list have no order by magnitude.
    To perform a search operation on such a list, one proceeds from the very first
    item, compares that with the search item. If a match is not made the next element
    in the list is examined. This continues till we reach the last element in the
    list or until a match is made.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `search` function takes as parameters, the list that houses our data and
    the item that we are looking for called the **search term**.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the array is obtained and determines the number of times the `for`
    loop is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On every pass of the `for` loop, we test if the search term is equal to the
    item that the index points to. If true, then there is no need to proceed with
    the search. We return the position where the match occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If the loop runs to the end of the list with no match being made, `None` is
    returned to signify that there is no such item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In an unordered list of items, there is no guiding rule for how elements are
    inserted. This therefore impacts the way the search is done. The lack of order
    means that we cannot rely on any rule to perform the search. As such, we must
    visit the items in the list one after the other. As can be seen in the following
    image, the search for the term **66**, starts from the first element and moves
    to next element in the list. Thus **60** compared with **66** and if it is not
    equal, we compare **66** with **1**, **88** and so on till we find the search
    term in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9bdc438d-d8b8-4a41-9ce1-f1a8aff57e33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The unordered linear search has a worst case running time of `O(n)`. All the
    elements may need to be visited before finding the search term. This will be the
    case if the search term is located at the last position of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case where the elements of a list have been already sorted, our search
    algorithm can be improved. Assuming the elements have been sorted in ascending
    order, the search operation can take advantage of the ordered nature of the list
    to make search more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is reduced to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move through the list sequentially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a search item is greater than the object or item currently under inspection
    in the loop, then quit and return None.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the process of iterating through the list, if the search term is greater
    than the current item, then there is no need to continue with the search.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19f35cd9-f5ea-41cf-96af-cae60034e6fe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the search operation starts and the first element is compared with (**5**),
    no match is made. But because there are more elements in the list the search operation
    moves on to examine the next element. A more compelling reason to move on is that
    we know the search item may match any of the elements greater than **2**.
  prefs: []
  type: TYPE_NORMAL
- en: After the 4th comparison, we come to the conclusion that the search term, can
    not be found in any position above where **6** is located. In other words, if
    the current item is greater than the search term, then it means there is no need
    to further search the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement now caters for this check. The `elif` portion tests the condition
    where `ordered_list[i] > term`. The method returns `None` if the comparison evaluates
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line in the method returns `None` because the loop may go through the
    list and still not find any element matching the search term.
  prefs: []
  type: TYPE_NORMAL
- en: The worst case time complexity of an ordered linear search is `O(n)`. In general,
    this kind of search is considered inefficient especially when dealing with large
    data sets.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary search is a search strategy used to find elements within a list by
    consistently reducing the amount of data to be searched and thereby increasing
    the rate at which the search term is found.
  prefs: []
  type: TYPE_NORMAL
- en: To use a binary search algorithm, the list to be operated on must have already
    been sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The *binary* term carries a number of meanings and helps us put our minds in
    the right frame to understand the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A binary decision has to be made at each attempt to find an item in the list.
    One critical decision is to guess which part of the list is likely to house the
    item we are looking for. Would the search term be in the first half of second
    half of the list, that is, if we always perceive the list as being comprised of
    two parts?
  prefs: []
  type: TYPE_NORMAL
- en: Instead of moving from one cell of the list to the other, if we employ the use
    of an educated guessing strategy, we are likely to arrive at the position where
    the item will be found much faster.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, lets take it that we want to find the middle page of a 1000 page
    book. We already know that every book has its pages numbered sequentially from
    1 upwards. So it figures that the 500th page should be found right at the middle
    of the book, instead of moving and flipping from page 1, 2 to reach the 500th
    page. Let's say we decide to now look for the page 250\. We can still use our
    strategy to find the page easily. We guess that page 500 cuts the book in half.
    Page 250, will lay to the left of the book. No need to worry about whether we
    can find 250th page between page 500 and 1000 because it can never be found there.
    So using page 500 as reference, we can open to about half of the pages that lay
    between the 1st and 500th page. That brings us closer to finding the 250th page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the algorithm for conducting a binary search on an ordered
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we have to find the position where the item **10** is located
    in the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b70fb7b0-21da-4886-82f4-436f7390ad50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm uses a `while` loop to iteratively adjust the limits in the list
    within which to find a search term. So far as the difference between the starting
    index, `index_of_first_element` and the `index_of_last_element` index is positive,
    the `while` loop will run.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm first finds the mid point of the list by adding the index of the
    first element (**0**) to that of the last (**4**) and dividing it by **2** to
    find the middle index, `mid_point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, **10** is not found at the middle position or index in the list.
    If we were searching for **120**, we would have had to adjust the `index_of_first_element`
    to `mid_point +1`. But because **10** lies on the other side of the list, we adjust
    `index_of_last_element` to `mid_point-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14511500-0b46-4755-855d-80fd775aad4f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With our new index of `index_of_first_element` and `index_of_last_element` now
    being **0** and **1** respectively, we compute the mid `(0 + 1)/2`, which equals
    `0`. The new midpoint is **0** , We find the middle item and compare with the
    search item,Â `ordered_list[0]` which yields the value **10**. Voila! Our search
    term is found.
  prefs: []
  type: TYPE_NORMAL
- en: This reduction of our list size by half, by re-adjusting the index of the `index_of_first_element`
    and `index_of_last_element` continues as long as `index_of_first_element` is less
    than `index_of_last_element`. When this fails to be the case it is most likely
    that our search term is not in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation here is an iterative one. We can also develop a recursive
    variant of the algorithm by applying the same principle of shifting the pointers
    that mark the beginning and ending of the search list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this recursive implementation of the binary search algorithm and
    its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There only distinction between the recursive binary search and the iterative
    binary search is the function definition and also the way in which `mid_point`
    is calculated. The calculation for the `mid_point` after the `((last_element_index
    - first_element_index) / 2)` operation must add its result to `first_element_index`.
    That way we define the portion of the list to attempt the search.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm has a worst time complexity of `O(log n)`. The half-ing
    of the list on each iteration follows a log n of the number of elements progression.
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that in `log x` is assumed to be referring to log base
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another variant of the binary search algorithm that may closely be
    said to mimic more, how humans perform search on any list of items. It is still
    based off trying to make a good guess of where in a sorted list of items, a search
    item is likely to be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the following list of items for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a934a442-62ab-4a5b-bbf4-8bab3c197e09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To find **120**, we know to look at the right hand portion of the list. Our
    initial treatment of binary search would typically examine the middle element
    first in order to determine if it matches the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more human thing would be to pick a middle element in a such a way as to
    not only split the array in half but to get as close as possible to the search
    term. The middle position was calculated for using the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We shall replace this formula with a better one that brings us close to the
    search term. `mid_point` will receive the return value of the `nearest_mid` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `nearest_mid` function takes as arguments, the list on which to perform
    the search. The `lower_bound_index` and `upper_bound_index` parameters represent
    the bounds in the list within which we are hoping to find the search term. `search_value`
    represents the value being searched for.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are used in the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Given our search list, **44**, **60**, **75**, **100**, **120**, **230** and
    **250**, the `nearest_mid` will be computed with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It can now be seen that, the `mid_point` will receive the value **5**, which
    is the index of the location of our search term. A binary search would have chosen
    **100** as the mid which will require another run of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more visual illustration of how a typical binary search differs from an interpolation
    is given as follows. For a typical binary search finds the midpoint like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/698b4f5c-a425-4e73-a34e-be589ffb03ca.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One can see that the midpoint is actually standing approximately in the middle
    of the preceding list. This is as a result of dividing by list 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interpolation search on the other hand would move like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6b7460b-0e68-44c8-bf82-0feb97a17fae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In interpolation search, our midpoint is swayed more to the left or right. This
    is caused by the effect of the multiplier used when dividing to obtain the midpoint.
    From the preceding image, our midpoint has been skewed to the right.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the interpolation algorithm remains the same as that of the
    binary search except for the way the mid position is calculated for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `nearest_mid` function makes use of a multiplication operation. This can
    produce values that are greater than the `upper_bound_index` or lower than the
    `lower_bound_index`. When this occurs, it means the search term, `term`, is not
    in the list. `None` is therefore returned to represent this.
  prefs: []
  type: TYPE_NORMAL
- en: So what happens when `ordered_list[mid_point]` does not equal the search them?
    Well, we must now re-adjust the `index_of_first_element` and `index_of_last_element`
    such that the algorithm will focus on the part of the array that is likely to
    contain the search term. This is like exactly what we did in the binary search.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the search term is greater than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_first_element` variable to point to the index
    `mid_point + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: The following image shows how the adjustment occurs. The `index_of_first_element`
    is adjusted and pointed to the index of `mid_point+1.`
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21370208-8cfb-43ed-8074-00e953845d80.jpg)The image only illustrates
    the adjustment of the midpoint. In interpolation rarely does the midpoint divide
    the list in 2 equal halves.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the search term is lesser than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_last_element` variable to point to the index
    `mid_point - 1`. This logic is captured in the else part of the if statement `index_of_last_element
    = mid_point - 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fedd86bd-8262-4578-97f9-25e3baf39778.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image shows the effect of the recalculation of `index_of_last_element` on
    the position of the midpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a more practical example to understand the inner workings of both
    the binary search and interpolation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the list with elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At index 0 is stored 2 and at index 7 is found the value 77\. Now, assume that
    we want to find the element 2 in the list. How will the two different algorithms
    go about it?
  prefs: []
  type: TYPE_NORMAL
- en: If we pass this list to the interpolation `search` function, the `nearest_mid`
    function will return a value equal to `0`. Just by one comparison, we would have
    found the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the binary search algorithm would need three comparisons
    to arrive at the search term as illustrated in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/672dbf08-20a0-4dbd-ba05-04fa1160a0d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The first `mid_point` calculated is `3`. The second `mid_point` is `1` and the
    last `mid_point` where the search term is found is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary search and interpolation search operations are better in performance
    than both ordered and unordered linear search functions. Because of the sequential
    probing of elements in the list to find the search term, ordered and unordered
    linear search have a time complexity of `O(n)`. This gives very poor performance
    when the list is large.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search operation on the other hand, slices the list in two, anytime
    a search is attempted. On each iteration, we approach the search term much faster
    than in a linear strategy. The time complexity yields `O(log n)`. Despite the
    speed gain in using binary search, it is most it can not be used on an unsorted
    list of items neither is it advised to be used for list of small sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to get to the portion of the list that houses a search term determines
    to a large extent, how well a search algorithm will perform. In the interpolation
    search algorithm, the mid is calculated for which gives a higher probability of
    obtaining our search term. The time complexity of the interpolation search is
    `O( log ( log n))`. This gives rise to a faster search compared to its variant,
    binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined two breeds of search algorithms. The implementation
    of both linear and binary search algorithms have been discussed and their comparisons
    drawn. The binary search variant, interpolation search has also been treated in
    this section. Knowing which kind of search operation to use will be relevant in
    subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we shall use the knowledge that we have gained to enable
    us perform sorting operations on a list of items.
  prefs: []
  type: TYPE_NORMAL

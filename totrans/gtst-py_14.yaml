- en: Selection Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One interesting set of algorithms related to finding elements in an unordered
    list of items is selection algorithms. In doing so, we shall be answering questions
    that have to do with selecting the median of a set of numbers and selecting the
    ith-smallest or -largest element in a list, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Items in a list may undergo statistical enquiries such as finding the mean,
    median, and mode values. Finding the mean and mode values do not require the list
    to be ordered. However, to find the median in a list of numbers, the list must
    first be ordered. Finding the median requires one to find the element in the middle
    position of the ordered list. But what if we want to find the last-smallest item
    in the list or the first-smallest item in the list?
  prefs: []
  type: TYPE_NORMAL
- en: To find the ith-smallest number in an unordered list of items, the index of
    where that item occurs is important to obtain. But because the elements have not
    been sorted, it is difficult to know whether the element at index 0 in a list
    is really the first-smallest number.
  prefs: []
  type: TYPE_NORMAL
- en: A pragmatic and obvious thing to do when dealing with unordered lists is to
    first sort the list. Once the list is sorted, one is assured that the zeroth element
    in the list will house the first-smallest element in the list. Likewise, the last
    element in the list will house the last-smallest element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that perhaps the luxury of sorting before performing the search cannot
    be afforded. Is it possible to find the ith-smallest element without having to
    sort the list in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we examined the quick sort algorithm. The quick sort
    algorithm allows us to sort an unordered list of items but has a way of preserving
    the index of elements as the sorting algorithm runs. Generally speaking, the quick
    sort algorithm does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Selects a pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partitions the unsorted list around the pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively sorts the two halves of the partitioned list using *step 1* and
    *step 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One interesting and important fact is that after every partitioning step, the
    index of the pivot will not change even after the list has become sorted. It is
    this property that enables us to be able to work with a not-so-fully sorted list
    to obtain the ith-smallest number. Because randomized selection is based on the
    quick sort algorithm, it is generally referred to as quick select.
  prefs: []
  type: TYPE_NORMAL
- en: Quick select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quick select algorithm is used to obtain the ith-smallest element in an
    unordered list of items, in this case, numbers. We declare the main method of
    the algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `quick_select` function takes as parameters the index of the first element
    in the list as well as the last. The ith element is specified by the third parameter
    `k`. Values greater or equal to zero (0) are allowed in such a way that when `k`
    is 0, we know to search for the first-smallest item in the list. Others like to
    treat the `k` parameter so that it maps directly with the index that the user
    is searching for, so that the first-smallest number maps to the 0 index of a sorted
    list. It's all a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: A method call to the partition function, `split = partition(array_list, left,
    right),` returns the `split` index. This index of `split` array is the position
    in the unordered list where all elements between `right` to `split-1` are less
    than the element contained in the array `split`, while all elements between `split+1`
    to `left` are greater.
  prefs: []
  type: TYPE_NORMAL
- en: When the `partition` function returns the `split` value, we compare it with
    `k` to find out if the `split` corresponds to the kth items.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `split` is less than `k`, then it means that the kth-smallest item should
    exist or be found between `split+1` and `right`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6955997-f9c9-42dc-bbb7-520ecb2d38c8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, a split within an imaginary unordered list occurs
    at index 5, while we are searching for the second-smallest number. Since 5<2 yields
    `false`, a recursive call to return `quick_select(array_list, left, split-1, k)`
    is made so that the other half of the list is searched:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `split` index was less than `k`, then we would make a call to `quick_select`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dec66f50-c35c-4fdd-9b7c-37b5820141b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partition step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The partition step is exactly like we had in the quick sort algorithm. There
    are a couple of things worthy of note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An if statement has been inserted at the beginning of the function definition
    to cater for situations where `first_index` is equal to `last_index`. In such
    cases, it means there is only one element in our sublist. We therefore simply
    return any of the function parameters, in this case, `first_index`.
  prefs: []
  type: TYPE_NORMAL
- en: The first element is always chosen as the pivot. This choice to make the first
    element the pivot is a random decision. It often does not yield a good split and
    subsequently a good partition. However, the ith element will eventually be found
    even though the pivot is chosen at random.
  prefs: []
  type: TYPE_NORMAL
- en: The `partition` function returns the pivot index pointed to by `less_than_pivot_index`,
    as we saw in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, you will need to follow the program execution with a pencil
    and paper to get a better feel of how the split variable is being used to determine
    the section of the list to search for the ith-smallest item.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worst-case performance of a randomized selection algorithm is **O**(*n²*).
    It is possible to improve on a section of the randomized selection algorithm to
    obtain a worst-case performance of **O**(*n*). This kind of algorithm is called
    **deterministic selection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general approach to the deterministic algorithm is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a pivot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split a list of unordered items into groups of five elements each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort and find the median of all the groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 1* and *step 2* recursively to obtain the true median of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the true median to partition the list of unordered items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recurse into the part of the partitioned list that may contain the ith-smallest
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pivot selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, in the random selection algorithm, we selected the first element
    as the pivot. We shall replace that step with a sequence of steps that enables
    us to obtain the true or approximate median. This will improve the partitioning
    of the list about the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now study the code for the partition function. The `nearest_median`
    variable stores the true or approximate median of a given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `unsorted_array` parameter has only one element, `first_index` and `last_index`
    will be equal. `first_index` is therefore returned anyway.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the list size is greater than one, we call the `median_of_medians`
    function with the section of the array, demarcated by `first_index` and `last_index`.
    The return value is yet again stored in `nearest_median`.
  prefs: []
  type: TYPE_NORMAL
- en: Median of medians
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `median_of_medians` function is responsible for finding the approximate
    median of any given list of items. The function uses recursion to return the true
    median:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function begins by splitting the list, `elems`, into groups of five elements
    each. This means that if `elems` contains 100 items, there will be 20 groups created
    by the statement `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)],`
    with each containing exactly five elements or fewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An empty array is created and assigned to `medians,` which stores the medians
    in each of the five element arrays assigned to `sublists`.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop iterates over the list of lists inside `sublists`. Each sublist
    is sorted, the median found, and stored in the `medians` list.
  prefs: []
  type: TYPE_NORMAL
- en: The `medians.append(sorted(sublist)[len(sublist)/2])` statement will sort the
    list and obtain the element stored in its middle index. This becomes the median
    of the five-element list. The use of an existing sorting function will not impact
    the performance of the algorithm due to the list's small size.
  prefs: []
  type: TYPE_NORMAL
- en: We understood from the outset that we would not sort the list in order to find
    the ith-smallest element, so why employ Python's sorted method? Well, since we
    are sorting a very small list of five elements or fewer, the impact of that operation
    on the overall performance of the algorithm is considered negligible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thereafter, if the list now contains five or fewer elements, we shall sort
    the `medians` list and return the element located in its middle index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If, on the other hand, the size of the list is greater than five, we recursively
    call the `median_of_medians` function again, supplying it with the list of the
    medians stored in `medians`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, the following list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21,
    22, 25, 24, 14]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break this list into groups of five elements each with the code statement
    `sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]`, to obtain the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18,
    23], [21, 22, 25, 24, 14]]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting each of the five-element lists and obtaining their medians produces
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[3, 12, 9, 19, 22]*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the list is five elements in size, we only return the median of the sorted
    list, or we would have made another call to the `median_of_median` function.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have obtained the approximate median, the `get_index_of_nearest_median`
    function takes the bounds of the list indicated by the `first` and `last` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we only return the first index if there is only one element in
    the list. The `arraylist[first:second]` returns an array with index 0 up to the
    size of the `list -1`. When we find the index of the median, we lose the portion
    in the list where it occurs because of the new range indexing the `[first:second]`
    code returns. Therefore, we must add whatever index is returned by `arraylist[first:second]`
    to `first` to obtain the true index where the median was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We then swap the first element in `unsorted_array` with `index_of_nearest_median`,
    using the swap function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The utility function to swap two array elements is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our approximate median is now stored at `first_index` of the unsorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The partition function continues as it would in the code of the quick select
    algorithm. After the partitioning step, the array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a8dca81-e1c7-41c1-9eda-1f7f98110b05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you will have already observed, the main function of the deterministic selection
    algorithm looks exactly the same as its random selection counterpart. After the
    initial `array_list` has been partitioned about the approximate median, a comparison
    with the kth element is made.
  prefs: []
  type: TYPE_NORMAL
- en: If `split` is less than `k`, then a recursive call to `deterministic_select(array_list,
    split + 1, right, k)` is made. This will look for the kth element in that half
    of the array. Otherwise the function call to `deterministic_select(array_list,
    left, split-1, k)` is made.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has examined ways to answer the question of how to find the ith-smallest
    element in a list. The trivial solution of simply sorting a list to perform the
    operation of finding the ith-smallest has been explored.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the possibility of not necessarily sorting the list before we
    can determine the ith-smallest element. The random selection algorithm allows
    us to modify the quick sort algorithm to determine the ith-smallest element.
  prefs: []
  type: TYPE_NORMAL
- en: To further improve upon the random selection algorithm so that we can obtain
    a time complexity of **O**(*n*), we embark on finding the median of medians to
    enable us find a good split during partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter, we will change our focus and take a deep dive into Python's
    OOP concepts.
  prefs: []
  type: TYPE_NORMAL

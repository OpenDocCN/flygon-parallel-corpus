- en: When Objects Are Alike
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*, inheritance allows us to create is a relationships between
    two or more classes, abstracting common logic into superclasses and managing specific
    details in the subclass. In particular, we''ll be covering the Python syntax and
    principles for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from built-in types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism and duck typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special built-in class named `object`. This class provides very
    little in terms of data and behaviors (the behaviors it does provide are all double-underscore
    methods intended for internal use only), but it does allow Python to treat all
    objects in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can openly state that our class derives from
    `object` using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is inheritance! This example is, technically, no different from our very
    first example in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, since Python 3 automatically inherits from `object` if we don't explicitly
    provide a different **superclass**. A superclass, or parent class, is a class
    that is being inherited from. A subclass is a class that is inheriting from a
    superclass. In this case, the superclass is `object`, and `MySubClass` is the
    subclass. A subclass is also said to be derived from its parent class or that
    the subclass extends the parent.
  prefs: []
  type: TYPE_NORMAL
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses between the class name and the colon that
    follows. This is all we have to do to tell Python that the new class should be
    derived from the given superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a simple contact manager that tracks the name and email address of several people.
    The `Contact` class is responsible for maintaining a list of all contacts in a
    class variable, and for initializing the name and address for an individual contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example introduces us to **class variables**. The `all_contacts` list,
    because it is part of the class definition, is shared by all instances of this
    class. This means that there is only one `Contact.all_contacts` list. We can also
    access it as `self.all_contacts` from within any method on an instance of the
    `Contact` class. If a field can't be found on the object (via `self`), then it
    will be found on the class and will thus refer to the same single list.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with this syntax, for if you ever *set* the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated just with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple class that allows us to track a couple of pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and email address in their `__init__`, but
    that only suppliers have a functional order method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, now our `Supplier` class can do everything a contact can do (including adding
    itself to the list of `all_contacts`) and all the special things it needs to handle
    as a supplier. This is the beauty of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Extending built-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One interesting use of this kind of inheritance is adding functionality to
    built-in classes. In the `Contact` class seen earlier, we are adding contacts
    to a list of all contacts. What if we also wanted to search that list by name?
    Well, we could add a method on the `Contact` class to search it, but it feels
    like this method actually belongs to the list itself. We can do this using inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of instantiating a normal list as our class variable, we create a new
    `ContactList` class that extends the built-in `list` data type. Then, we instantiate
    this subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you wondering how we changed the built-in syntax `[]` into something we
    can inherit from? Creating an empty list with `[]` is actually a shortcut for
    creating an empty list using `list()`; the two syntaxes behave identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In reality, the `[]` syntax is actually so-called **syntactic sugar** that
    calls the `list()` constructor under the hood. The `list` data type is a class
    that we can extend. In fact, the list itself extends the `object` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As a second example, we can extend the `dict` class, which is, similar to the
    list, the class that is constructed when using the `{}` syntax shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to test in the interactive interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Most built-in types can be similarly extended. Commonly extended built-ins are
    `object`, `list`, `set`, `dict`, `file`, and `str`. Numerical types such as `int`
    and `float` are also occasionally inherited from.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and super
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `Contact` class allows only a name and an
    email address. This may be sufficient for most contacts, but what if we want to
    add a phone number for our close friends?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, we can do this easily by just setting a `phone` attribute on the contact
    after it is constructed. But if we want to make this third variable available
    on initialization, we have to override `__init__`. Overriding means altering or
    replacing a method of the superclass with a new method (with the same name) in
    the subclass. No special syntax is needed to do this; the subclass''s newly created
    method is automatically called instead of the superclass''s method. As shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Any method can be overridden, not just `__init__`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated, as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts`
    list we have created on the `Contact` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really need is a way to execute the original `__init__` method on the
    `Contact` class from inside our new class. This is what the `super` function does;
    it returns the object as an instance of the parent class, allowing us to call
    the parent method directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example first gets the instance of the parent object using `super`, and
    calls `__init__` on that object, passing in the expected arguments. It then does
    its own initialization, namely, setting the `phone` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: A `super()` call can be made inside any method. Therefore, all methods can be
    modified via overriding and calls to `super`. The call to `super` can also be
    made at any point in the method; we don't have to make the call as the first line.
    For example, we may need to manipulate or validate incoming parameters before
    forwarding them to the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple inheritance is a touchy subject. In principle, it''s simple: a subclass
    that inherits from more than one parent class is able to access functionality
    from both of them. In practice, this is less useful than it sounds and many expert
    programmers recommend against using it.'
  prefs: []
  type: TYPE_NORMAL
- en: As a humorous rule of thumb, if you think you need multiple inheritance, you're
    probably wrong, but if you know you need it, you might be right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest and most useful form of multiple inheritance is called a **mixin**.
    A mixin is a superclass that is not intended to exist on its own, but is meant
    to be inherited by some other class to provide extra functionality. For example,
    let''s say we wanted to add functionality to our `Contact` class that allows sending
    an email to `self.email`. Sending email is a common task that we might want to
    use on many other classes. So, we can write a simple mixin class to do the emailing
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we won't include the actual email logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class doesn''t do anything special (in fact, it can barely function as
    a standalone class), but it does allow us to define a new class that describes
    both a `Contact` and a `MailSender`, using multiple inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. We can test this new hybrid to see the mixin
    at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Contact` initializer is still adding the new contact to the `all_contacts`
    list, and the mixin is able to send mail to `self.email`, so we know that everything
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'This wasn''t so hard, and you''re probably wondering what the dire warnings
    about multiple inheritance are. We''ll get into the complexities in a minute,
    but let''s consider some other options we had for this example, rather than using
    a mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: We could have used single inheritance and added the `send_mail` function to
    the subclass. The disadvantage here is that the email functionality then has to
    be duplicated for any other classes that need an email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a standalone Python function for sending an email, and just call
    that function with the correct email address supplied as a parameter when the
    email needs to be sent (this would be my choice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could have explored a few ways of using composition instead of inheritance.
    For example, `EmailableContact` could have a `MailSender` object as a property
    instead of inheriting from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could monkey patch (we'll briefly cover monkey patching in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*) the `Contact` class to have a `send_mail`
    method after the class has been created. This is done by defining a function that
    accepts the `self` argument, and setting it as an attribute on an existing class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance works all right when mixing methods from different classes,
    but it gets very messy when we have to call methods on the superclass. There are
    multiple superclasses. How do we know which one to call? How do we know what order
    to call them in?
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take. An address is a collection of strings
    representing the street, city, country, and other related details of the contact.
    We could pass each of these strings as a parameter into the `Friend` class's `__init__`
    method. We could also store these strings in a tuple, dictionary, or dataclass
    and pass them into `__init__` as a single argument. This is probably the best
    course of action if there are no methods that need to be added to the address.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to create a new `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__` method in
    our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in [Chapter
    15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml), *Object-Oriented Design*. Composition
    is a perfectly viable solution to this problem and allows us to reuse `Address`
    classes in other entities, such as buildings, businesses, or organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, inheritance is also a viable solution, and that''s what we want to
    explore. Let''s add a new class that holds an address. We''ll call this new class
    `AddressHolder` instead of `Address` because inheritance defines an is a relationship.
    It is not correct to say a `Friend` class is an `Address` class, but since a friend
    can have an `Address` class, we can argue that a `Friend` class is an `AddressHolder` class.
    Later, we could create other entities (companies, buildings) that also hold addresses.
    Then again, such convoluted naming is a decent indication we should be sticking
    with composition, rather than inheritance. But for pedagogical purposes, we''ll
    stick with inheritance. Here''s our `AddressHolder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We just take all the data and toss it into instance variables upon initialization.
  prefs: []
  type: TYPE_NORMAL
- en: The diamond problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__` methods,
    both of which need to be initialized. And they need to be initialized with different
    arguments. How do we do this? Well, we could start with a naive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we directly call the `__init__` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is possible for a superclass to go uninitialized if we neglect to
    explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. Imagine trying to insert
    data into a database that has not been connected to, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more insidious possibility is a superclass being called multiple times because
    of the organization of the class hierarchy. Look at this inheritance diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa756ecd-f4b1-4ece-b1ec-50fc35c748fa.png)'
  prefs: []
  type: TYPE_IMG
- en: The `__init__` method from the `Friend` class first calls `__init__` on `Contact`,
    which implicitly initializes the `object` superclass (remember, all classes derive
    from `object`). `Friend` then calls `__init__` on `AddressHolder`, which implicitly
    initializes the `object` superclass *again*. This means the parent class has been
    set up twice. With the `object` class, that's relatively harmless, but in some
    situations, it could spell disaster. Imagine trying to connect to a database twice
    for every request!
  prefs: []
  type: TYPE_NORMAL
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, and then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, and then `Object`?
  prefs: []
  type: TYPE_NORMAL
- en: The order in which methods can be called can be adapted on the fly by modifying
    the `__mro__` (**Method Resolution Order**) attribute on the class. This is beyond
    the scope of this book. If you think you need to understand it, we recommend *Expert
    Python Programming*, *Tarek Ziadé*, *Packt Publishing*, or read the original documentation
    (beware, it's deep!) on the topic at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a second contrived example, which illustrates this problem more
    clearly. Here, we have a base class that has a method named `call_me`. Two subclasses
    override that method, and then another subclass extends both of these using multiple
    inheritance. This is called diamond inheritance because of the diamond shape of
    the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad8de812-f1cd-43b8-86d2-0c1b13a40b49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s convert this diagram to code; this example shows when the methods are
    called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This example ensures that each overridden `call_me` method directly calls the
    parent method with the same name. It lets us know each time a method is called
    by printing the information to the screen. It also updates a static variable on
    the class to show how many times it has been called. If we instantiate one `Subclass`
    object and call the method on it once, we get the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can clearly see the base class's `call_me` method being called twice.
    This could lead to some pernicious bugs if that method is doing actual work, such
    as depositing into a bank account, twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing to keep in mind with multiple inheritance is that we only want to
    call the `next` method in the class hierarchy, not the `parent` method. In fact,
    that next method may not be on a parent or ancestor of the current class. The
    `super` keyword comes to our rescue once again. Indeed, `super` was originally
    developed to make complicated forms of multiple inheritance possible. Here is
    the same code written using `super`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The change is pretty minor; we only replaced the naive direct calls with calls
    to `super()`, although the bottom subclass only calls `super` once rather than
    having to make the calls for both the left and right. The change is easy enough,
    but look at the difference when we execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Looks good; our base method is only being called once. But what is `super()`
    actually doing here? Since the `print` statements are executed after the `super`
    calls, the printed output is in the order each method is actually executed. Let's
    look at the output from back to front to see who is calling what.
  prefs: []
  type: TYPE_NORMAL
- en: First, `call_me` of `Subclass` calls `super().call_me()`, which happens to refer
  prefs: []
  type: TYPE_NORMAL
- en: to `LeftSubclass.call_me()`. The `LeftSubclass.call_me()` method then calls
    `super().call_me()`, but in this case, `super()` is referring to `RightSubclass.call_me()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pay particular attention to this**: the `super` call is *not* calling the
    method on the superclass of `LeftSubclass` (which is `BaseClass`). Rather, it
    is calling `RightSubclass`, even though it is not a direct parent of `LeftSubclass`!
    This is the *next* method, not the parent method. `RightSubclass` then calls `BaseClass`
    and the `super` calls have ensured each method in the class hierarchy is executed
    once.'
  prefs: []
  type: TYPE_NORMAL
- en: Different sets of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is going to make things complicated as we return to our `Friend` multiple
    inheritance example. In the `__init__` method for `Friend`, we were originally
    calling `__init__` for both parent classes, *with different sets of arguments*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How can we manage different sets of arguments when using `super`? We don't necessarily
    know which class `super` is going to try to initialize first. Even if we did,
    we need a way to pass the `extra` arguments so that subsequent calls to `super`,
    on other subclasses, receive the right arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, if the first call to `super` passes the `name` and `email` arguments
    to `Contact.__init__`, and `Contact.__init__` then calls `super`, it needs to
    be able to pass the address-related arguments to the `next` method, which is `AddressHolder.__init__`.
  prefs: []
  type: TYPE_NORMAL
- en: This problem manifests itself anytime we want to call superclass methods with
    the same name, but with different sets of arguments. Most often, the only time
    you would want to call a superclass with a completely different set of arguments
    is in `__init__`, as we're doing here. Even with regular methods, though, we may
    want to add optional parameters that only make sense to one subclass or set of
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the only way to solve this problem is to plan for it from the beginning.
    We have to design our base class parameter lists to accept keyword arguments for
    any parameters that are not required by every subclass implementation. Finally,
    we must ensure the method freely accepts unexpected arguments and passes them
    on to its `super` call, in case they are necessary to later methods in the inheritance
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s function parameter syntax provides all the tools we need to do this,
    but it makes the overall code look cumbersome. Have a look at the proper version
    of the `Friend` multiple inheritance code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've changed all arguments to keyword arguments by giving them an empty string
    as a default value. We've also ensured that a `**kwargs` parameter is included
    to capture any additional parameters that our particular method doesn't know what
    to do with. It passes these parameters up to the next class with the `super` call.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw`, or `kwargs`).
    When we call a different method (for example, `super().__init__`) with a `**kwargs`
    syntax, it unpacks the dictionary and passes the results to the method as normal
    keyword arguments. We'll cover this in detail in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example does what it is supposed to do. But it's starting to look
    messy, and it is difficult to answer the question, *What arguments do we need
    to pass into* `Friend.__init__`? This is the foremost question for anyone planning
    to use the class, so a docstring should be added to the method to explain what
    is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, even this implementation is insufficient if we want to *reuse*
    variables in parent classes. When we pass the `**kwargs` variable to `super`,
    the dictionary does not include any of the variables that were included as explicit
    keyword arguments. For example, in `Friend.__init__`, the call to `super` does
    not have `phone` in the `kwargs` dictionary. If any of the other classes need
    the `phone` parameter, we need to ensure it is in the dictionary that is passed.
    Worse, if we forget to do this, it will be extremely frustrating to debug because
    the superclass will not complain, but will simply assign the default value (in
    this case, an empty string) to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to ensure that the variable is passed upward. Assume the
    `Contact` class does, for some reason, need to be initialized with a `phone` parameter,
    and the `Friend` class will also need access to it. We can do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't include `phone` as an explicit keyword argument. Instead, leave it in
    the `kwargs` dictionary. `Friend` can look it up using the `kwargs['phone'] ` syntax.
    When it passes `**kwargs` to the `super` call, `phone` will still be in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    before passing it to `super`, using the standard dictionary `kwargs['phone'] =
    phone` syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    using the `kwargs.update` method. This is useful if you have several arguments
    to update. You can create the dictionary passed into `update` using either the
    `dict(phone=phone)` constructor, or the dictionary `{''phone'': phone}` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make `phone` an explicit keyword argument, but pass it to the super call explicitly
    with the `super().__init__(phone=phone, **kwargs)` syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered many of the caveats involved with multiple inheritance in Python.
    When we need to account for all possible situations, we have to plan for them
    and our code will get messy. Basic multiple inheritance can be handy but, in many
    cases, we may want to choose a more transparent way of combining two disparate
    classes, usually using composition or one of the design patterns we'll be covering
    in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml), *Design Patterns
    I,* and [Chapter 23](3e7c30d8-a939-4a5e-9eb4-53d9f24a0306.xhtml), *Design Patterns
    II*.
  prefs: []
  type: TYPE_NORMAL
- en: I have wasted entire days of my life trawling through complex multiple inheritance
    hierarchies trying to figure out what arguments I need to pass into one of the
    deeply nested subclasses. The author of the code tended not to document his classes
    and often passed the kwargs—Just in case they might be needed someday. This was
    a particularly bad example of using multiple inheritance when it was not needed.
    Multiple inheritance is a big fancy term that new coders like to show off, but
    I recommend avoiding it, even when you think it's a good choice. Your future self
    and other coders will be glad they understand your code when they have to read
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We were introduced to polymorphism in [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*. It is a showy name describing a simple concept: different
    behaviors happen depending on which subclass is being used, without having to
    explicitly know what the subclass actually is. As an example, imagine a program
    that plays audio files. A media player might need to load an `AudioFile` object
    and then `play` it. We can put a `play()` method on the object, which is responsible
    for decompressing or extracting the audio and routing it to the sound card and
    speakers. The act of playing an `AudioFile` could feasibly be as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. While `.wav` files are stored uncompressed, `.mp3`,
    `.wma`, and `.ogg` files all utilize totally different compression algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example,
    `WavFile` and `MP3File`. Each of these would have a `play()` method that would
    be implemented differently for each file to ensure that the correct extraction
    procedure is followed. The media player object would never need to know which
    subclass of `AudioFile` it is referring to; it just calls `play()` and polymorphically
    lets the object take care of the actual details of playing. Let''s look at a quick
    skeleton showing how this might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All audio files check to ensure that a valid extension was given upon initialization.
    But did you notice how the `__init__` method in the parent class is able to access
    the `ext` class variable from different subclasses? That's polymorphism at work.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in the next chapter). The fact that the `AudioFile`
    parent class doesn't actually store a reference to the `ext` variable doesn't
    stop it from being able to access it on the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See how `AudioFile.__init__` is able to check the file type without actually
    knowing which subclass it is referring to?
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism seem less awesome because of duck
    typing. Duck typing in Python allows us to use *any* object that provides the
    required behavior without forcing it to be a subclass. The dynamic nature of Python
    makes this trivial. The following example does not extend `AudioFile`, but it
    can be interacted with in Python using the exact same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our media player can play this object just as easily as one that extends `AudioFile`.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code, but if all that
    is being shared is the public interface, duck typing is all that is required.
    This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just because an object satisfies a particular interface (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. For example, our chess AI object from [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*, may have a `play()` method that moves a chess piece.
    Even though it satisfies the interface, this class would likely break in spectacular
    ways if we tried to plug it into a media player!
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write`
    method if the code that is going to interact with the fake object will not be
    calling it. More succinctly, duck typing doesn't need to provide the entire interface
    of an object that is available; it only needs to fulfill the interface that is
    actually accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While duck typing is useful, it is not always easy to tell in advance if a class
    is going to fulfill the protocol you require. Therefore, Python introduced the
    idea of **abstract base classes** (**ABC**s). Abstract base classes define a set
    of methods and properties that a class must implement in order to be considered
    a duck-type instance of that class. The class can extend the abstract base class
    itself in order to be used as an instance of that class, but it must supply all
    the appropriate methods.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's rarely necessary to create new abstract base classes, but
    we may find occasions to implement instances of existing ABCs. We'll cover implementing
    ABCs first, and then briefly see how to create your own, should you ever need
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Using an abstract base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the abstract base classes that exist in the Python standard library
    live in the `collections` module. One of the simplest ones is the `Container`
    class. Let''s inspect it in the Python interpreter to see what methods this class
    requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__`. You can issue `help(Container.__contains__)` to see
    what the function signature should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `__contains__` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see whether the container holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is implemented by `list`, `str`, and `dict` to indicate whether
    or not a given value is *in* that data structure. However, we can also define
    a silly container that tells us whether a given value is in the set of odd integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the interesting part: we can instantiate an `OddContainer` object and
    determine that, even though we did not extend `Container`, the class is a `Container`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create is a relationships without the overhead of writing the code to set
    up inheritance (or worse, multiple inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: 'One cool thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__` method. Any class that has a `__contains__` method
    is a `Container` and can therefore be queried by the `in` keyword, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating an abstract base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier, it''s not necessary to have an abstract base class to enable
    duck typing. However, imagine we were creating a media player with third-party
    plugins. It is advisable to create an abstract base class in this case to document
    what API the third-party plugins should provide (documentation is one of the stronger
    use cases for ABCs). The `abc` module provides the tools you need to do this,
    but I''ll warn you in advance, this utilizes some of Python''s most arcane concepts,
    as demonstrated in the following block of code::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a complicated example that includes several Python features that won't
    be explained until later in this book. It is included here for completeness, but
    you do not need to understand all of it to get the gist of how to create your
    own ABC.
  prefs: []
  type: TYPE_NORMAL
- en: The first weird thing is the `metaclass` keyword argument that is passed into
    the class where you would normally see the list of parent classes. This is a seldom-used
    construct from the mystic art of metaclass programming. We won't be covering metaclasses
    in this book, so all you need to know is that by assigning the `ABCMeta` metaclass,
    you are giving your class superhero (or at least superclass) abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `@abc.abstractmethod` and `@abc.abstractproperty` constructs.
    These are Python decorators. We'll discuss those in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml),
    *Python Design Patterns I*. For now, just know that by marking a method or property
    as being abstract, you are stating that any subclass of this class must implement
    that method or supply that property in order to be considered a proper member
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'See what happens if you implement subclasses that do, or don''t, supply those
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Wav` class fails to implement the abstract attributes, it is not
    possible to instantiate that class. The class is still a legal abstract class,
    but you'd have to subclass it to actually do anything. The `Ogg` class supplies
    both attributes, so it instantiates cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the `MediaLoader` ABC, let's dissect that `__subclasshook__` method.
    It is basically saying that any class that supplies concrete implementations of
    all the abstract attributes of this ABC should be considered a subclass of `MediaLoader`,
    even if it doesn't actually inherit from the `MediaLoader` class.
  prefs: []
  type: TYPE_NORMAL
- en: More common object-oriented languages have a clear separation between the interface
    and the implementation of a class. For example, some languages provide an explicit
    `interface` keyword that allows us to define the methods that a class must have
    without any implementation. In such an environment, an abstract class is one that
    provides both an interface and a concrete implementation of some, but not all,
    methods. Any class can explicitly state that it implements a given interface.
  prefs: []
  type: TYPE_NORMAL
- en: Python's ABCs help to supply the functionality of interfaces without compromising
    on the benefits of duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying the magic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can copy and paste the subclass code without understanding it if you want
    to make abstract classes that fulfill this particular contract. We''ll cover most
    of the unusual syntaxes in the book, but let''s go over it line by line to get
    an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator marks the method as a class method. It essentially says that
    the method can be called on a class instead of an instantiated object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This defines the `__subclasshook__` class method. This special method is called
    by the Python interpreter to answer the question: Is the class `C` a subclass
    of this class?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We check to see whether the method was called specifically on this class, rather
    than, say, a subclass of this class. This prevents, for example, the `Wav` class
    from being thought of as a parent class of the `Ogg` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'All this line does is get the set of methods and properties that the class
    has, including any parent classes in its class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This line uses set notation to see whether the set of abstract methods in this
    class has been supplied in the candidate class. Note that it doesn't check to
    see whether the methods have been implemented; just if they are there. Thus, it's
    possible for a class to be a subclass and yet still be an abstract class itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If all the abstract methods have been supplied, then the candidate class is
    a subclass of this class and we return `True`. The method can legally return one
    of the three values: `True`, `False`, or `NotImplemented`. `True` and `False`
    indicate that the class is, or isn''t, definitively a subclass of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If any of the conditionals have not been met (that is, the class is not `MediaLoader`
    or not all abstract methods have been supplied), then return `NotImplemented`.
    This tells the Python machinery to use the default mechanism (does the candidate
    class explicitly extend this class?) for subclass detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we can now define the `Ogg` class as a subclass of the `MediaLoader`
    class without actually extending the `MediaLoader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to tie everything we've learned together with a larger example. We'll
    be developing an automated grading system for programming assignments, similar
    to that employed at Dataquest or Coursera. The system will need to provide a simple
    class-based interface for course writers to create their assignments and should
    give a useful error message if it does not fulfill that interface. The writers
    need to be able to supply their lesson content and to write custom answer checking
    code to make sure their students got the answer right. It will also be nice for
    them to have access to the students' names to make the content seem a little friendlier.
  prefs: []
  type: TYPE_NORMAL
- en: The grader itself will need to keep track of which assignment the student is
    currently working on. A student might make several attempts at an assignment before
    they get it right. We want to keep track of the number of attempts so the course
    authors can improve the content of the more difficult lessons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the interface that the course authors will need to
    use. Ideally, it will require the course authors to write a minimal amount of
    extra code besides their lesson content and answer checking code. Here is the
    simplest class I could come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, that particular course author may be a little naive in how they
    do their answer checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with an abstract base class that defines this interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This ABC defines the two required abstract methods and provides the magic `__subclasshook__`
    method to allow a class to be perceived as a subclass without having to explicitly
    extend it (I usually just copy and paste this code. It isn't worth memorizing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that the `IntroToPython` class fulfills this interface using
    `issubclass(IntroToPython, Assignment)`, which should return `True`. Of course,
    we can explicitly extend the `Assignment` class if we prefer, as seen in this
    second assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This course author, unfortunately, is also rather naive. The `exec` call will
    execute the student's code right inside the grading system, giving them access
    to the entire system. Obviously, the first thing they will do is hack the system
    to make their grades 100%. They probably think that's easier than doing the assignments
    correctly!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a class that manages how many attempts the student has
    made at a given assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This class uses composition instead of inheritance. At first glance, it would
    make sense for these methods to exist on the `Assignment` superclass. That would
    eliminate the annoying `lesson` method, which just proxies through to the same
    method on the assignment object. It would certainly be possible to put all this
    logic directly on the `Assignment` abstract base class, or even to have the ABC
    inherit from this `AssignmentGrader` class. In fact, I would normally recommend
    that, but in this case, it would force all course authors to explicitly extend
    the class, which violates our request that content authoring be as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can start to put together the `Grader` class, which is responsible
    for managing which assignments are available and which one each student is currently
    working on. The most interesting part is the register method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code block includes the initializer, which includes two dictionaries we'll
    discuss in a minute. The `register` method is a bit complex, so we'll dissect
    it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first odd thing is the parameter this method accepts: `assignment_class`.
    This parameter is intended to be an actual class, not an instance of the class.
    Remember, classes are objects, too, and can be passed around like other classes.
    Given the `IntroToPython` class we defined earlier, we might register it without
    instantiating it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The method first checks whether that class is a subclass of the `Assignment`
    class. Of course, we implemented a custom `__subclasshook__` method, so this includes
    classes that do not explicitly subclass `Assignment`. The naming is, perhaps,
    a bit deceitful! If it doesn't have the two required methods, it raises an exception.
    Exceptions are a topic we'll cover in detail in the next chapter; for now, just
    assume that it makes the program get angry and quit.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we generate a random identifier to represent that specific assignment.
    We store the `assignment_class` in a dictionary indexed by that ID, and return
    the ID so that the calling code can look that assignment up in the future. Presumably,
    another object would then place that ID in a course syllabus of some sort so students
    do the assignments in order, but we won't be doing that for this part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The `uuid` function returns a specially formatted string called a universally
    unique identifier, also known as a globally unique identifier. It essentially
    represents an extremely large random number that is almost, but not quite, impossible
    to conflict with another similarly generated identifier. It is a great, quick,
    and clean way to create an arbitrary ID to keep track of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have the `start_assignment` function, which allows a student to
    start working on an assignment given the ID of that assignment. All it does is
    construct an instance of the `AssignmentGrader` class we defined earlier and plop
    it in a dictionary stored on the `Grader` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we write a couple of proxy methods that get the lesson or check
    the code for whatever assignment the student is currently working on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a method that gives a summary of a student''s current assignment
    progress. It looks up the assignment object and creates a formatted string with
    all the information we have about that student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. You'll notice that this case study does not use a ton of inheritance,
    which may seem a bit odd given the topic of the chapter, but duck typing is very
    prevalent. It is quite common for Python programs to be designed with inheritance
    that gets simplified into more versatile constructs as it is iterated on. As another
    example, I originally defined the `AssignmentGrader` as an inheritance relationship,
    but realized halfway through that it would be better to use composition, for the
    reasons outlined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a bit of test code that shows all these objects connected together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  prefs: []
  type: TYPE_NORMAL
- en: Now write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never gotten around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships
    and then implement them. Make sure that you also pay attention to the sorts of
    relationships that you actually don't need to use inheritance for. Are there any
    places where you might want to use multiple inheritance? Are you sure? Can you
    see any place where you would want to use a mixin? Try to knock together a quick
    prototype. It doesn't have to be useful or even partially working. You've seen
    how you can test code using `python -i` already; just write some code and test
    it in the interactive interpreter. If it works, write some more. If it doesn't,
    fix it!
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the student grader system in the case study. There is a
    lot missing from it, and not just decent course content! How do students get into
    the system? Is there a curriculum that defines which order they should study lessons
    in? What happens if you change the `AssignmentGrader` to use inheritance, rather
    than composition, on the `Assignment` objects?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to come up with some good use cases for mixins, then experiment
    with them until you realize that there is probably a better design using composition!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance—One of the most
    complicated. Inheritance can be used to add functionality to existing classes
    and built-ins using inheritance. Abstracting similar code into a parent class
    can help increase maintainability. Methods on parent classes can be called using
    `super` and argument lists must be formatted safely for these calls to work when
    using multiple inheritance. Abstract base classes allow you to document what methods
    and properties a class must have to fulfill a particular interface, and even allow
    you to change the very definition of *subclass*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  prefs: []
  type: TYPE_NORMAL

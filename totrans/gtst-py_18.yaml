- en: Expecting the Unexpected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs are very fragile. It would be ideal if code always returned a valid
    result, but sometimes a valid result can't be calculated. For example, it's not
    possible to divide by zero, or to access the eighth item in a five-item list.
  prefs: []
  type: TYPE_NORMAL
- en: In the old days, the only way around this was to rigorously check the inputs
    for every function to make sure they made sense. Typically, functions had special
    return values to indicate an error condition; for example, they could return a
    negative number to indicate that a positive value couldn't be calculated. Different
    numbers might mean different errors occurred. Any code that called this function
    would have to explicitly check for an error condition and act accordingly. A lot
    of developers didn't bother to do this, and programs simply crashed. However,
    in the object-oriented world, this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study **exceptions**, special error objects that only
    need to be handled when it makes sense to handle them. In particular, we will
    cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to cause an exception to occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to recover when an exception has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle different exception types in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up when an exception has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new types of exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the exception syntax for flow control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In principle, an exception is just an object. There are many different exception
    classes available, and we can easily define more of our own. The one thing they
    all have in common is that they inherit from a built-in class called `BaseException`.
    These exception objects become special when they are handled inside the program's
    flow of control. When an exception occurs, everything that was supposed to happen
    doesn't happen, unless it was supposed to happen when an exception occurred. Make
    sense? Don't worry, it will!
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to cause an exception to occur is to do something silly. Chances
    are you''ve done this already and seen the exception output. For example, any
    time Python encounters a line in your program that it can''t understand, it bails
    with `SyntaxError`, which is a type of exception. Here''s a common one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `print` statement was a valid command way back in the Python 2 and earlier
    days, but in Python 3, because `print` is a function, we have to enclose the arguments
    in parentheses. So, if we type the preceding command into a Python 3 interpreter,
    we get `SyntaxError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `SyntaxError`, some other common exceptions are shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, these exceptions are indicators of something wrong in our program
    (in which case, we would go to the indicated line number and fix it), but they
    also occur in legitimate situations. A `ZeroDivisionError` error doesn't always
    mean we received an invalid input. It could also mean we have received a different
    input. The user may have entered a zero by mistake, or on purpose, or it may represent
    a legitimate value, such as an empty bank account or the age of a newborn child.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed all the preceding built-in exceptions end with the name
    `Error`. In Python, the words `error` and `Exception` are used almost interchangeably.
    Errors are sometimes considered more dire than exceptions, but they are dealt
    with in exactly the same way. Indeed, all the error classes in the preceding example
    have `Exception` (which extends `BaseException`) as their superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Raising an exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll get to responding to such exceptions in a minute, but first, let''s
    discover what we should do if we''re writing a program that needs to inform the
    user or a calling function that the inputs are invalid. We can use the exact same
    mechanism that Python uses. Here''s a simple class that adds items to a list only
    if they are even numbered integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This class extends the `list` built-in, as we discussed in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml),
    *Objects in Python*, and overrides the `append` method to check two conditions
    that ensure the item is an even integer. We first check whether the input is an
    instance of the `int` type, and then use the modulus operator to ensure it is
    divisible by two. If either of the two conditions is not met, the `raise` keyword
    causes an exception to occur. The `raise` keyword is followed by the object being
    raised as an exception. In the preceding example, two objects are constructed
    from the built-in `TypeError` and `ValueError` classes. The raised object could
    just as easily be an instance of a new `Exception` class we create ourselves (we'll
    see how shortly), an exception that was defined elsewhere, or even an `Exception`
    object that has been previously raised and handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we test this class in the Python interpreter, we can see that it is outputting
    useful error information when exceptions occur, just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While this class is effective for demonstrating exceptions in action, it isn't
    very good at its job. It is still possible to get other values into the list using
    index notation or slice notation. This can all be avoided by overriding other
    appropriate methods, some of which are magic double-underscore methods.
  prefs: []
  type: TYPE_NORMAL
- en: The effects of an exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an exception is raised, it appears to stop program execution immediately.
    Any lines that were supposed to run after the exception is raised are not executed,
    and unless the exception is dealt with, the program will exit with an error message.
    Take a look at this basic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this function, we see that the first `print` call is executed
    and then the exception is raised. The second `print` function call is never executed,
    nor is the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, if we have a function that calls another function that raises
    an exception, nothing is executed in the first function after the point where
    the second function was called. Raising an exception stops all execution right
    up through the function call stack until it is either handled or forces the interpreter
    to exit. To demonstrate, let''s add a second function that calls the earlier one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function, we see that the first `print` statement executes,
    as well as the first line in the `no_return` function. But once the exception
    is raised, nothing else executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We'll soon see that when the interpreter is not actually taking a shortcut and
    exiting immediately, we can react to and deal with the exception inside either
    method. Indeed, exceptions can be handled at any level after they are initially
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the exception's output (called a traceback) from bottom to top, and
    notice how both methods are listed. Inside `no_return`, the exception is initially
    raised. Then, just above that, we see that inside `call_exceptor`, that pesky
    `no_return` function was called and the exception *bubbled up* to the calling
    method. From there, it went up one more level to the main interpreter, which,
    not knowing what else to do with it, gave up and printed a traceback.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s look at the tail side of the exception coin. If we encounter an
    exception situation, how should our code react to or recover from it? We handle
    exceptions by wrapping any code that might throw one (whether it is exception
    code itself, or a call to any function or method that may have an exception raised
    inside it) inside a `try...except` clause. The most basic syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this simple script using our existing `no_return` function—which,
    as we know very well, always throws an exception—we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `no_return` function happily informs us that it is about to raise an exception,
    but we fooled it and caught the exception. Once caught, we were able to clean
    up after ourselves (in this case, by outputting that we were handling the situation),
    and continue on our way, with no interference from that offensive function. The
    remainder of the code in the `no_return` function still went unexecuted, but the
    code that called the function was able to recover and continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note the indentation around `try` and `except`. The `try` clause wraps any code
    that might throw an exception. The `except` clause is then back on the same indentation
    level as the `try` line. Any code to handle the exception is indented after the
    `except` clause. Then normal code resumes at the original indentation level.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding code is that it will catch any type of exception.
    What if we were writing some code that could raise both `TypeError` and `ZeroDivisionError`?
    We might want to catch `ZeroDivisionError`, but let `TypeError` propagate to the
    console. Can you guess the syntax?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rather silly function that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is tested with the `print` statements that show it behaving as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output shows that if we enter `0`, we get properly mocked.
    If we call with a valid number (note that it's not an integer, but it's still
    a valid divisor), it operates correctly. Yet if we enter a string (you were wondering
    how to get a `TypeError`, weren't you?), it fails with an exception. If we had
    used an empty `except` clause that didn't specify a `ZeroDivisionError`, it would
    have accused us of dividing by zero when we sent it a string, which is not a proper
    behavior at all.
  prefs: []
  type: TYPE_NORMAL
- en: The *bare except* syntax is generally frowned upon, even if you really do want
    to catch all instances of an exception. Use the `except Exception:` syntax to
    explicitly catch all exception types. This tell the reader that you meant to catch
    exception objects and all subclasses of `Exception`. The bare except syntax is
    actually the same as using `except BaseException:`, which actually catches system-level
    exceptions that are very rare to intentionally want to catch, as we'll see in
    the next section. If you really do want to catch them, explicitly use `except
    BaseException:` so that anyone who reads your code knows that you didn't just
    forget to specify what kind of exception you wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even catch two or more different exceptions and handle them with the
    same code. Here''s an example that raises three different types of exception.
    It handles `TypeError` and `ZeroDivisionError` with the same exception handler,
    but it may also raise a `ValueError` error if you supply the number `13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop at the bottom loops over several test inputs and prints the
    results. If you''re wondering about that `end` argument in the `print` statement,
    it just turns the default trailing newline into a space so that it''s joined with
    the output from the next line. Here''s a run of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The number `0` and the string are both caught by the `except` clause, and a
    suitable error message is printed. The exception from the number `13` is not caught
    because it is a `ValueError`, which was not included in the types of exceptions
    being handled. This is all well and good, but what if we want to catch different
    exceptions and do different things with them? Or maybe we want to do something
    with an exception and then allow it to continue to bubble up to the parent function,
    as if it had never been caught?
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need any new syntax to deal with these cases. It''s possible to stack
    the `except` clauses, and only the first match will be executed. For the second
    question, the `raise` keyword, with no arguments, will re-raise the last exception
    if we''re already inside an exception handler. Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last line re-raises the `ValueError` error, so after outputting `No, No,
    not 13!`, it will raise the exception again; we'll still get the original stack
    trace on the console.
  prefs: []
  type: TYPE_NORMAL
- en: If we stack exception clauses like we did in the preceding example, only the
    first matching clause will be run, even if more than one of them fits. How can
    more than one clause match? Remember that exceptions are objects, and can therefore
    be subclassed. As we'll see in the next section, most exceptions extend the `Exception`
    class (which is itself derived from `BaseException`). If we catch `Exception`
    before we catch `TypeError`, then only the `Exception` handler will be executed,
    because `TypeError` is an `Exception` by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: This can come in handy in cases where we want to handle some exceptions specifically,
    and then handle all remaining exceptions as a more general case. We can simply
    catch `Exception` after catching all the specific exceptions and handle the general
    case there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, when we catch an exception, we need a reference to the `Exception` object
    itself. This most often happens when we define our own exceptions with custom
    arguments, but can also be relevant with standard exceptions. Most exception classes
    accept a set of arguments in their constructor, and we might want to access those
    attributes in the exception handler. If we define our own `Exception` class, we
    can even call custom methods on it when we catch it. The syntax for capturing
    an exception as a variable uses the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we run this simple snippet, it prints out the string argument that we passed
    into `ValueError` upon initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen several variations on the syntax for handling exceptions, but we
    still don''t know how to execute code regardless of whether or not an exception
    has occurred. We also can''t specify code that should be executed **only** if
    an exception does **not** occur. Two more keywords, `finally` and `else`, can
    provide the missing pieces. Neither one takes any extra arguments. The following
    example randomly picks an exception to throw and raises it. Then some not-so-complicated
    exception handling code runs that illustrates the newly introduced syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this example—which illustrates almost every conceivable exception
    handling scenario—a few times, we''ll get different output each time, depending
    on which exception `random` chooses. Here are some example runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `print` statement in the `finally` clause is executed no matter
    what happens. This is extremely useful when we need to perform certain tasks after
    our code has finished running (even if an exception has occurred). Some common
    examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up an open database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing an open file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a closing handshake over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finally` clause is also very important when we execute a `return` statement
    from inside a `try` clause. The `finally` handler will still be executed before
    the value is returned without executing any code following the `try...finally`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, pay attention to the output when no exception is raised: both the `else`
    and the `finally` clauses are executed. The `else` clause may seem redundant,
    as the code that should be executed only when no exception is raised could just
    be placed after the entire `try...except` block. The difference is that the `else`
    block will not be executed if an exception is caught and handled. We''ll see more
    on this when we discuss using exceptions as flow control later.'
  prefs: []
  type: TYPE_NORMAL
- en: Any of the `except`, `else`, and `finally` clauses can be omitted after a `try`
    block (although `else` by itself is invalid). If you include more than one, the
    `except` clauses must come first, then the `else` clause, with the `finally` clause
    at the end. The order of the `except` clauses normally goes from most specific
    to most generic.
  prefs: []
  type: TYPE_NORMAL
- en: The exception hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen several of the most common built-in exceptions, and you'll
    probably encounter the rest over the course of your regular Python development.
    As we noticed earlier, most exceptions are subclasses of the `Exception` class.
    But this is not true of all exceptions. `Exception` itself actually inherits from
    a class called `BaseException`. In fact, all exceptions must extend the `BaseException`
    class or one of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key built-in the exception classes, `SystemExit` and `KeyboardInterrupt`,
    that derive directly from `BaseException` instead of `Exception`. The `SystemExit`
    exception is raised whenever the program exits naturally, typically because we
    called the `sys.exit` function somewhere in our code (for example, when the user
    selected an exit menu item, clicked the *Close* button on a window, or entered
    a command to shut down a server). The exception is designed to allow us to clean
    up code before the program ultimately exits. However, we generally don't need
    to handle it explicitly because cleanup code can happen inside a `finally` clause.
  prefs: []
  type: TYPE_NORMAL
- en: If we do handle it, we would normally re-raise the exception, since catching
    it would stop the program from exiting. There are, of course, situations where
    we might want to stop the program exiting; for example, if there are unsaved changes
    and we want to prompt the user if they really want to exit. Usually, if we handle
    `SystemExit` at all, it's because we want to do something special with it, or
    are anticipating it directly. We especially don't want it to be accidentally caught
    in generic clauses that catch all normal exceptions. This is why it derives directly
    from `BaseException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeyboardInterrupt` exception is common in command-line programs. It is
    thrown when the user explicitly interrupts program execution with an OS-dependent
    key combination (normally, *Ctrl* + *C*). This is a standard way for the user
    to deliberately interrupt a running program, and like `SystemExit`, it should
    almost always respond by terminating the program. Also, like `SystemExit`, it
    should handle any cleanup tasks inside the `finally` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class diagram that fully illustrates the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0003cd2e-9b19-4c3c-8280-9c4664984093.png)'
  prefs: []
  type: TYPE_IMG
- en: When we use the `except:` clause without specifying any type of exception, it
    will catch all subclasses of `BaseException`; which is to say, it will catch all
    exceptions, including the two special ones. Since we almost always want these
    to get special treatment, it is unwise to use the `except:` statement without
    arguments. If you want to catch all exceptions other than `SystemExit` and `KeyboardInterrupt`,
    explicitly catch `Exception`. Most Python developers assume that `except:` without
    a type is an error and will flag it in code review. If you really do want to catch
    everything, just explicitly use `except BaseException:`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our own exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, when we want to raise an exception, we find that none of the built-in
    exceptions are suitable. Luckily, it's trivial to define new exceptions of our
    own. The name of the class is usually designed to communicate what went wrong,
    and we can provide arbitrary arguments in the initializer to include additional
    information.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do is inherit from the `Exception` class. We don't even have
    to add any content to the class! We can, of course, extend `BaseException` directly,
    but I have never encountered a use case where this would make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple exception we might use in a banking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last line illustrates how to raise the newly defined exception. We are able
    to pass an arbitrary number of arguments into the exception. Often a string message
    is used, but any object that might be useful in a later exception handler can
    be stored. The `Exception.__init__` method is designed to accept any arguments
    and store them as a tuple in an attribute named `args`. This makes exceptions
    easier to define without needing to override `__init__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if we do want to customize the initializer, we are free to do so.
    Here''s an exception whose initializer accepts the current balance and the amount
    the user wanted to withdraw. In addition, it adds a method to calculate how overdrawn
    the request was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `raise` statement at the end illustrates how to construct this exception.
    As you can see, we can do anything with an exception that we would do with other
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we would handle an `InvalidWithdrawal` exception if one was raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a valid use of the `as` keyword. By convention, most Python coders
    name the exception `e` or the `ex` variable, although, as usual, you are free
    to call it  `exception`, or `aunt_sally` if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons for defining our own exceptions. It is often useful to
    add information to the exception or log it in some way. But the utility of custom
    exceptions truly comes to light when creating a framework, library, or API that
    is intended for access by other programmers. In that case, be careful to ensure
    your code is raising exceptions that make sense to the client programmer. They
    should be easy to handle and clearly describe what went on. The client programmer
    should easily see how to fix the error (if it reflects a bug in their code) or
    handle the exception (if it's a situation they need to be made aware of).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions aren''t exceptional. Novice programmers tend to think of exceptions
    as only useful for exceptional circumstances. However, the definition of exceptional
    circumstances can be vague and subject to interpretation. Consider the following
    two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These two functions behave identically. If `divisor` is zero, an error message
    is printed; otherwise, a message printing the result of division is displayed.
    We could avoid `ZeroDivisionError` ever being thrown by testing for it with an
    `if` statement. Similarly, we can avoid `IndexError` by explicitly checking whether
    or not the parameter is within the confines of the list, and `KeyError` by checking
    whether the key is in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: But we shouldn't do this. For one thing, we might write an `if` statement that
    checks whether or not the index is lower than the parameters of the list, but
    forget to check negative values.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Python lists support negative indexing; `-1` refers to the last element
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, we would discover this and have to find all the places where we
    were checking code. But if we had simply caught `IndexError` and handled it, our
    code would just work.
  prefs: []
  type: TYPE_NORMAL
- en: Python programmers tend to follow a model of *ask forgiveness rather than permission*,
    which is to say, they execute code and then deal with anything that goes wrong.
    The alternative, to *look before you leap*, is generally less popular. There are
    a few reasons for this, but the main one is that it shouldn't be necessary to
    burn CPU cycles looking for an unusual situation that is not going to arise in
    the normal path through the code. Therefore, it is wise to use exceptions for
    exceptional circumstances, even if those circumstances are only a little bit exceptional.
    Taking this argument further, we can actually see that the exception syntax is
    also effective for flow control. Like an `if` statement, exceptions can be used
    for decision making, branching, and message passing.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an inventory application for a company that sells widgets and gadgets.
    When a customer makes a purchase, the item can either be available, in which case
    the item is removed from inventory and the number of items left is returned, or
    it might be out of stock. Now, being out of stock is a perfectly normal thing
    to happen in an inventory application. It is certainly not an exceptional circumstance.
    But what do we return if it's out of stock? A string saying out of stock? A negative
    number? In both cases, the calling method would have to check whether the return
    value is a positive integer or something else, to determine if it is out of stock.
    That seems a bit messy, especially if we forget to do it somewhere in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can raise `OutOfStock` and use the `try` statement to direct program
    flow control. Make sense? In addition, we want to make sure we don''t sell the
    same item to two different customers, or sell an item that isn''t in stock yet.
    One way to facilitate this is to lock each type of item to ensure only one person
    can update it at a time. The user must lock the item, manipulate the item (purchase,
    add stock, count items left...), and then unlock the item. Here''s an incomplete
    `Inventory` example with docstrings that describes what some of the methods should
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We could hand this object prototype to a developer and have them implement
    the methods to do exactly as they say while we work on the code that needs to
    make a purchase. We''ll use Python''s robust exception handling to consider different
    branches, depending on how the purchase was made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to how all the possible exception handling clauses are used to
    ensure the correct actions happen at the correct time. Even though `OutOfStock`
    is not a terribly exceptional circumstance, we are able to use an exception to
    handle it suitably. This same code could be written with an `if...elif...else`
    structure, but it wouldn't be as easy to read or maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use exceptions to pass messages between different methods. For example,
    if we wanted to inform the customer as to what date the item is expected to be
    in stock again, we could ensure our `OutOfStock` object requires a `back_in_stock`
    parameter when it is constructed. Then, when we handle the exception, we can check
    that value and provide additional information to the customer. The information
    attached to the object can be easily passed between two different parts of the
    program. The exception could even provide a method that instructs the inventory
    object to reorder or backorder an item.
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for flow control can make for some handy program designs. The
    important thing to take from this discussion is that exceptions are not a bad
    thing that we should try to avoid. Having an exception occur does not mean that
    you should have prevented this exceptional circumstance from happening. Rather,
    it is just a powerful way to communicate information between two sections of code
    that may not be directly calling each other.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been looking at the use and handling of exceptions at a fairly low level
    of detail—syntax and definitions. This case study will help tie it all in with
    our previous chapters so we can see how exceptions are used in the larger context
    of objects, inheritance, and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we'll be designing a simple central authentication and authorization
    system. The entire system will be placed in one module, and other code will be
    able to query that module object for authentication and authorization purposes.
    We should admit, from the start, that we aren't security experts, and that the
    system we are designing may be full of security holes.
  prefs: []
  type: TYPE_NORMAL
- en: Our purpose is to study exceptions, not to secure a system. It will be sufficient,
    however, for a basic login and permission system that other code can interact
    with. Later, if that other code needs to be made more secure, we can have a security
    or cryptography expert review or rewrite our module, preferably without changing
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the process of ensuring a user is really the person they say
    they are. We'll follow the lead of common web systems today, which use a username
    and private password combination. Other methods of authentication include voice
    recognition, fingerprint or retinal scanners, and identification cards.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization, on the other hand, is all about determining whether a given (authenticated)
    user is permitted to perform a specific action. We'll create a basic permission
    list system that stores a list of the specific people allowed to perform each
    action.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll add some administrative features to allow new users to be
    added to the system. For brevity, we'll leave out editing of passwords or changing
    of permissions once they've been added, but these (highly necessary) features
    can certainly be added in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There's a simple analysis; now let's proceed with design. We're obviously going
    to need a `User` class that stores the username and an encrypted password. This
    class will also allow a user to log in by checking whether a supplied password
    is valid. We probably won't need a `Permission` class, as those can just be strings
    mapped to a list of users using a dictionary. We should have a central `Authenticator`
    class that handles user management and logging in or out. The last piece of the
    puzzle is an `Authorizor` class that deals with permissions and checking whether
    a user can perform an activity. We'll provide a single instance of each of these
    classes in the `auth` module so that other modules can use this central mechanism
    for all their authentication and authorization needs. Of course, if they want
    to instantiate private instances of these classes, for non-central authorization
    activities, they are free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be defining several exceptions as we go along. We'll start with a
    special `AuthException` base class that accepts a `username` and optional `user`
    object as parameters; most of our self-defined exceptions will inherit from this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the `User` class first; it seems simple enough. A new user can
    be initialized with a username and password. The password will be stored encrypted
    to reduce the chances of its being stolen. We''ll also need a `check_password`
    method to test whether a supplied password is the correct one. Here is the class
    in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since the code for encrypting a password is required in both `__init__` and
    `check_password`, we pull it out to its own method. This way, it only needs to
    be changed in one place if someone realizes it is insecure and needs improvement.
    This class could easily be extended to include mandatory or optional personal
    details, such as names, contact information, and birth dates.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write code to add users (which will happen in the as-yet undefined
    `Authenticator` class), we should examine some use cases. If all goes well, we
    can add a user with a username and password; the `User` object is created and
    inserted into a dictionary. But in what ways can all not go well? Well, clearly
    we don't want to add a user with a username that already exists in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we did so, we''d overwrite an existing user''s data and the new user might
    have access to that user''s privileges. So, we''ll need a `UsernameAlreadyExists`
    exception. Also, for security''s sake, we should probably raise an exception if
    the password is too short. Both of these exceptions will extend `AuthException`,
    which we mentioned earlier. So, before writing the `Authenticator` class, let''s
    define these three exception classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `AuthException` requires a username and has an optional user parameter.
    This second parameter should be an instance of the `User` class associated with
    that username. The two specific exceptions we're defining simply need to inform
    the calling class of an exceptional circumstance, so we don't need to add any
    extra methods to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s start on the `Authenticator` class. It can simply be a mapping of
    usernames to user objects, so we''ll start with a dictionary in the initialization
    function. The method for adding a user needs to check the two conditions (password
    length and previously existing users) before creating a new `User` instance and
    adding it to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could, of course, extend the password validation to raise exceptions for
    passwords that are too easy to crack in other ways, if we desired. Now let''s
    prepare the `login` method. If we weren''t thinking about exceptions just now,
    we might just want the method to return `True` or `False`, depending on whether
    the login was successful or not. But we are thinking about exceptions, and this
    could be a good place to use them for a not-so-exceptional circumstance. We could
    raise different exceptions, for example, if the username does not exist or the
    password does not match. This will allow anyone trying to log a user in to elegantly
    handle the situation using a `try`/`except`/`else` clause. So, first we add these
    new exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can define a simple `login` method to our `Authenticator` class that
    raises these exceptions if necessary. If not, it flags the `user` as logged in
    and returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `KeyError` is handled. This could have been handled using `if username
    not in self.users:` instead, but we chose to handle the exception directly. We
    end up eating up this first exception and raising a brand new one of our own that
    better suits the user-facing API.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add a method to check whether a particular username is logged in.
    Deciding whether to use an exception here is trickier. Should we raise an exception
    if the username does not exist? Should we raise an exception if the user is not
    logged in?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer these questions, we need to think about how the method would be accessed.
    Most often, this method will be used to answer the yes/no question, *should I
    allow them access to <something>?* The answer will either be, y*es, the username
    is valid and they are logged in*, or *no, the username is not valid or they are
    not logged in*. Therefore, a Boolean return value is sufficient. There is no need
    to use exceptions here, just for the sake of using an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add a default authenticator instance to our module so that
    the client code can access it easily using `auth.authenticator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This line goes at the module level, outside any class definition, so the `authenticator`
    variable can be accessed as `auth.authenticator`. Now we can start on the `Authorizor`
    class, which maps permissions to users. The `Authorizor` class should not permit
    user access to a permission if they are not logged in, so they''ll need a reference
    to a specific authenticator. We''ll also need to set up the permission dictionary
    upon initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write methods to add new permissions and to set up which users are
    associated with each permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first method allows us to create a new permission, unless it already exists,
    in which case an exception is raised. The second allows us to add a username to
    a permission, unless either the permission or the username doesn't yet exist.
  prefs: []
  type: TYPE_NORMAL
- en: We use `set` instead of `list` for usernames, so that even if you grant a user
    permission more than once, the nature of sets means the user is only in the set
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `PermissionError` error is raised in both methods. This new error doesn''t
    require a username, so we''ll make it extend `Exception` directly, instead of
    our custom `AuthException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add a method to check whether a user has a specific `permission`
    or not. In order for them to be granted access, they have to be both logged into
    the authenticator and in the set of people who have been granted access to that
    privilege. If either of these conditions is unsatisfied, an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two new exceptions in here; they both take usernames, so we''ll define
    them as subclasses of `AuthException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add a default `authorizor` to go with our default authenticator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That completes a basic authentication/authorization system. We can test the
    system at the Python prompt, checking to see whether a user, `joe`, is permitted
    to do tasks in the paint department:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'While verbose, the preceding output shows all of our code and most of our exceptions
    in action, but to really understand the API we''ve defined, we should write some
    exception handling code that actually uses it. Here''s a basic menu interface
    that allows certain users to change or test a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This rather long example is conceptually very simple. The `is_permitted` method
    is probably the most interesting; this is a mostly internal method that is called
    by both `test` and `change` to ensure the user is permitted access before continuing.
    Of course, those two methods are stubs, but we aren't writing an editor here;
    we're illustrating the use of exceptions and exception handlers by testing an
    authentication and authorization framework.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've never dealt with exceptions before, the first thing you need to do
    is look at any old Python code you've written and notice if there are places you
    should have been handling exceptions. How would you handle them? Do you need to
    handle them at all? Sometimes, letting the exception propagate to the console
    is the best way to communicate to the user, especially if the user is also the
    script's coder. Sometimes, you can recover from the error and allow the program
    to continue. Sometimes, you can only reformat the error into something the user
    can understand and display it to them.
  prefs: []
  type: TYPE_NORMAL
- en: Some common places to look are file I/O (is it possible your code will try to
    read a file that doesn't exist?), mathematical expressions (is it possible that
    a value you are dividing by is zero?), list indices (is the list empty?), and
    dictionaries (does the key exist?). Ask yourself whether you should ignore the
    problem, handle it by checking values first, or handle it with an exception. Pay
    special attention to areas where you might have used `finally` and `else` to ensure
    the correct code is executed under all conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Now write some new code. Think of a program that requires authentication and
    authorization, and try writing some code that uses the `auth` module we built
    in the case study. Feel free to modify the module if it's not flexible enough.
    Try to handle
  prefs: []
  type: TYPE_NORMAL
- en: all the exceptions in a sensible way. If you're having trouble coming up with
    something that requires authentication, try adding authorization to the Notepad
    example from [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, or add authorization to the `auth` module itself—it's not a terribly
    useful module if just anybody can start adding permissions! Maybe require an administrator
    username and password before allowing privileges to be added or changed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to think of places in your code where you can raise exceptions.
    It can be in code you've written or are working on; or you can write a new project
    as an exercise. You'll probably have the best luck for designing a small framework
    or API that is meant to be used by other people; exceptions are a terrific communication
    tool between your code and someone else's. Remember to design and document any
    self-raised exceptions as part of the API, or they won't know whether or how to
    handle them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into the gritty details of raising, handling, defining,
    and manipulating exceptions. Exceptions are a powerful way to communicate unusual
    circumstances or error conditions without requiring a calling function to explicitly
    check return values. There are many built-in exceptions and raising them is trivially
    easy. There are several different syntaxes for handling different exception events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, everything we've studied so far will come together as we
    discuss how object-oriented programming principles and structures should best
    be applied in Python applications.
  prefs: []
  type: TYPE_NORMAL

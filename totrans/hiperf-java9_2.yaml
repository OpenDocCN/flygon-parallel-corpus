- en: Chapter 2. Tools for Higher Productivity and Faster Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a JShell Session and Setting Context](img/02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, at the startup, several common packages are imported. You can see
    them by typing the `/l -start` or `/l -all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JShell Commands](img/02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![JShell Commands](img/02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![JShell Commands](img/02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![JShell Commands](img/02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands `/en`, `/res`, and `/rel` have an overlapping functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/en [options]`: This allows to view or change the evaluation context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/res [options]`: This discards all entered snippets and restarts the session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/rel[options]`: This reloads the session the same way the command `/en` does'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the official Oracle documentation ([http://docs.oracle.com/javase/9/tools/jshell.htm](http://docs.oracle.com/javase/9/tools/jshell.htm))
    for more details and possible options.
  prefs: []
  type: TYPE_NORMAL
- en: The command `[/se [setting]` sets configuration information, including the external
    editor, startup settings, and feedback mode. This command is also used to create
    a custom feedback mode with customized prompt, format, and truncation values.
    If no setting is entered, then the current setting for the editor, startup settings,
    and feedback mode are displayed. The documentation referred to earlier describes
    all possible settings in all details.
  prefs: []
  type: TYPE_NORMAL
- en: The JShell is going to be even more helpful when integrated inside of the IDE
    so that a programmer can evaluate expressions on the fly or, even better, they
    can be evaluated automatically the same way the compiler today evaluates the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-Time (AOT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big claim of Java was write-once-run-anywhere. It was achieved by creating
    an implementation of **Java Runtime Environment** (**JRE**) for practically all
    platforms, so the bytecode generated once from the source by Java compiler (`javac`
    tool) could be executed everywhere where JRE was installed, provided the version
    of the compiler `javac` was compatible with the version of JRE.
  prefs: []
  type: TYPE_NORMAL
- en: The first releases of JRE were primarily the interpreters of the bytecode and
    yielded slower performance than some other languages and their compilers, such
    as C and C++. However, over time, JRE was improved substantially and now produces
    quite decent results, on a par with many other popular systems. In big part, it
    is due to the JIT dynamic compiler that converts the bytecodes of the most frequently
    used methods to the native code. Once generated, the compiled methods (the platform-specific
    machine code) is executed as needed without any interpretation, thus decreasing
    the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: To utilize this approach, JRE needs some time for figuring out which methods
    of the application are used most often. The people working in this area of programming
    call them hot methods. This period of discovery, until the peak performance is
    reached, is often called a JVM's warm-up time. It is bigger for the larger and
    more complex Java applications and can be just a few seconds for smaller ones.
    However, even after the peak performance is reached, the application might, because
    of the particular input, start utilizing an execution path never used before and
    calling the methods that were not compiled yet, thus suddenly degrading the performance.
    It can be especially consequential when the code not compiled yet belongs to the
    complex procedures invoked in some rare critical situations, exactly when the
    best possible performance is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The natural solution was to allow the programmer to decide which components
    of the application have to be precompiled into the native machine code--those
    that are more often used (thus decreasing the application''s warm-up time), and
    those that are used not often but have to be executed as quickly as possible (in
    support of the critical situations and stable performance overall). That was the
    motivation of the **Java Enhancement ProposalJEP 295: Ahead-of-Time Compilation**:'
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilers are fast, but Java programs can become so large that it takes
    a long time for the JIT to warm up completely. Infrequently used Java methods
    might never be compiled at all, potentially incurring a performance penalty due
    to repeated interpreted invocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noticing though that already in JIT compiler, it is possible to
    decrease the warm-up time by setting the compilation threshold--how many times
    a method has to be called before it gets compiled into the native code. By default,
    the number is 1,500\. So, if we set it to less than that, the warm-up time will
    be shorter. It can be done using the option `-XX:CompileThreshold` with the `java`
    tool. For example, we can set the threshold to 500 as follows (where `Test` is
    the compiled Java class with the `main()` method in it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The option `-XX:-TieredCompilation` was added to disable the tiered compilation
    because it is enabled by default and does not honor the compilation threshold.
    The possible drawback is that the 500 threshold might be too low and too many
    methods will be compiled, thus slowing down the performance and increasing the
    warm-up time. The best value for this option will vary from application to an
    application and may even depend on the particular data input with the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus Dynamic Compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many higher level programming languages such as C or C++ used AOT compilation
    from the very beginning. They are also called **statically compiled** languages.
    Since AOT (or static) compilers are not constrained by performance requirements
    (at least not as much as the interpreters at runtime, also called **dynamic compilers**),
    they can afford to spend the time producing complex code optimizations. On the
    other hand, the static compilers do not have the runtime (profiling) data, which
    is especially limiting in the case of dynamically typed languages, Java being
    one of them. Since the ability of dynamic typing in Java--downcasting to the subtype,
    querying an object for its type, and other type operations--is one of the pillars
    of object-oriented programming (principle of polymorphism), AOT compilation for
    Java becomes even more limited. Lambda expressions pause another challenge for
    static compilation and are currently not supported yet.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of a dynamic compiler is that it can make assumptions and
    optimize the code accordingly. If the assumption turned out to be wrong, the compiler
    can try another assumption until the performance goal is achieved. Such a procedure
    may slow down the application and/or increase the warm-up time, but it may result
    in a much better performance in the long run. The profile-guided optimization
    can help a static compiler to move along this path too, but it will always remain
    limited in its opportunity to optimize by comparison with a dynamic one.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we should not be surprised that the current AOT implementation in
    JDK 9 is experimental and limited, so far, to 64-bit Linux-based systems only,
    with both Parallel or G1 garbage collection and the only supported module being
    `java.base`. Further, AOT compilation should be executed on the same system or
    a system with the same configuration on which the resulting machine code will
    be executed. Yet, despite all that, the JEP 295 states:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing shows that some applications benefit from AOT-compiled code,
    while others clearly show regressions.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that AOT compilation has been long supported in **Java Micro
    Edition** (**ME**), but more use cases for AOT in **Java Standard Edition** (**SE**)
    are yet to be identified, which was one of the reasons the experimental AOT implementation
    was released with JDK 9-- in order to facilitate the community to try and tell
    about the practical needs.
  prefs: []
  type: TYPE_NORMAL
- en: The AOT Commands and Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The underlying AOT compilation in JDK 9 is based on the Oracle project `Graal`--an
    open source compiler introduced with JDK 8 with a goal of improving the performance
    of the Java dynamic compiler. The AOT group had to modify it, mostly around constants
    processing and optimization. They have also added probabilistic profiling and
    a special inlining policy, thus making Grall more suitable for static compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the existing compiling tool `javac`, a new `jaotc` tool is included
    in the JDK 9 installation. The resulting AOT shared libraries `.so` are generated
    using the `libelf` library--the dependency that is going to be removed in the
    future releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start AOT compilation, a user has to launch `jaotc` and specify classes,
    JAR files, or modules that have to be compiled. The name of the output library
    (that holds the generated machine code) can also be passed as the `jaotc` parameter.
    If not specified, the default name of the output will be `unnamed.so`. As an example,
    let''s look at how the AOT compiler can work with the class `HelloWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will generate the bytecode and produce `HelloWorld.class` using `javac`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use the bytecode from the file `HelloWorld.class` to generate
    machine code into the library `libHelloWorld.so`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute the generated library (on the platform with the same specification
    as the one where `jaotc`was executed) using the `java` tool with an option `-XX:AOTLibrary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The option `-XX:AOTLibrary` allows us to list several AOT libraries separated
    by commas.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `java` tool requires bytecode of all the applications in addition
    to the native code of some of its components. This fact diminishes the alleged
    advantage of static compilation, which some AOT enthusiasts claim, that it protects
    code better from being decompiled. It might be so in the future when bytecode
    will not be required at runtime if the same class or method is in the AOT library
    already. However, as of today, it is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if AOT-compiled methods were used, you can add an option `-XX:+PrintAOT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It will allow you to see the line loaded `./libHelloWorld.so` AOT library in
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: If the source code of a class was changed but not pushed (through the `jaotc`
    tool) into the AOT library, JVM will notice it at runtime because the fingerprint
    of each compiled class is stored with its native code in the AOT library. JIT
    will then ignore the code in the AOT library and use the bytecode instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java` tool in JDK 9 supports a few other flags and options related to
    AOT:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:+/-UseAOT` tells the JVM to use or to ignore AOT-compiled files (by default,
    it is set to use AOT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+/-UseAOTStrictLoading` turns on/off the AOT strict loading; if on, it
    directs JVM to exit if any of the AOT libraries were generated on a platform with
    a configuration different from the current runtime configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JEP 295 describes the `jaotc` tool''s command format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` is a class name or JAR file. The `list` is a colon `:` separated
    list of class names, modules, JAR files, or directories that contain class files.
    The `options` is one or many flags from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--output <file>`: This is the output file name (by default, `unnamed.so`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--class-name <class names>`: This is the list of Java classes to compile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--jar <jar files>`: This is the list of JAR files to compile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--module <modules>`: This is the list of Java modules to compile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--directory <dirs>`: This is the list of directories where you can search
    for files to compile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--search-path <dirs>`: This is the list of directories where to search for
    specified files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-commands <file>`: This is the name of the file with compile commands;
    here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'AOT recognizes two compile commands currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude`: This excludes the compilation of specified methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileOnly`: This compiles only specified methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular expressions are used to specify classes and methods, which are mentioned
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--compile-for-tiered`: This generates profiling code for tiered compilation
    (by default, profiling code is not generated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-with-assertions`: This generates code with Java assertions (by default,
    assertions code is not generated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-threads <number>`: This is the number of compilation threads to
    be used (by default, the smaller value of 16 and number of available CPUs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ignore-errors`: This ignores all exceptions thrown during class loading
    (by default, exits on compilation if class loading throws an exception)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--exit-on-error`: This exits on compilation errors (by default, failed compilation
    is skipped, while the compilation of other methods continues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--info`: This prints information about compilation phases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--verbose`: This prints more details about compilation phases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--debug`: This prints even more details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help`: This prints help information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--version`: This prints version information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-J<flag>`: This passes a flag directly to the JVM runtime system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned already, some applications can improve performance using AOT,
    while others may become slower. Only testing will provide a definite answer to
    the question about the usefulness of AOT for each application. In any case, one
    of the ways to improve performance is to compile and use the AOT library of the
    `java.base` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, the AOT initialization code looks for shared libraries in the `$JAVA_HOME/lib`
    directory or among the libraries listed by the `-XX:AOTLibrary` option. If shared
    libraries are found, they are picked up and used. If no shared libraries can be
    found, AOT will be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lesson, we described two new tools that can help a developer be more
    productive (JShell tool) and help improve Java application performance (`jaotc`
    tool). The examples and steps to use them will help you understand the benefits
    of their usage and get you started in case you decide to try them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will discuss how to monitor Java applications programmatically
    using command-line tools. We will also explore how to improve the application
    performance via multithreading and how to tune the JVM itself after learning about
    the bottlenecks through monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ________ compiler takes Java bytecode and generates a native machine code
    so that the resulting binary file can execute natively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands drops a snippet referenced by a name or on ID?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/d <name or id>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/drop <name or id>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/dr <name or id>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/dp <name or id>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether True or False: Shell is Ahead-of-Time tool that is well-known
    for those who program in Scala, Ruby. It takes a user input, evaluates it, and
    returns the result after sometime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands is used to list the source you have typed in
    JShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/l [<name or id>|-all|-start]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/m [<name or id>|-all|-start]L`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/t [<name or id>|-all|-start]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/v [<name or id>|-all|-start]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following regular expressions ignores all exceptions thrown during
    class loading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--exit-on-error`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`–ignores-errors`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--ignore-errors`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--exits-on-error`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

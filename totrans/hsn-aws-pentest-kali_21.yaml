- en: Pentesting CloudTrail
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渗透测试CloudTrail
- en: AWS CloudTrail is described as an AWS service that helps you enable governance,
    compliance, and operational and risk auditing of your AWS account ([https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html))
    and is basically advertised as the central logging source for API activity in
    an AWS account. CloudTrail is an always-on service in some sense, in that it logs
    read/write API operations to an immutable archive of the last 90 days of logs,
    known as the CloudTrail Event history. We will get more into Event history in
    the *Reconnaissance* section of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudTrail被描述为一项AWS服务，可帮助您启用AWS账户的治理、合规性、运营和风险审计（[https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-user-guide.html)），基本上被宣传为AWS账户中API活动的中央日志来源。CloudTrail在某种意义上是一项始终开启的服务，因为它会将读/写API操作记录到最近90天的日志的不可变存档中，称为CloudTrail事件历史。我们将在本章的*侦察*部分更深入地了解事件历史。
- en: In this chapter, we will take a look at CloudTrail and the features that it
    provides us with as diligent AWS users. We will also look at it from the pentester's
    point of view, covering how to audit CloudTrail best practices in a target account,
    but also how to perform reconnaissance on the environment through CloudTrail,
    how to bypass the CloudTrail service to stay under the radar, and how to disrupt
    any logging mechanisms that are already in place. These topics are beneficial
    to our client because they can help them understand where their blind spots are
    in the environment; however, they can also help us discover more information about
    our attack target, without necessarily needing to make direct API calls to each
    service they are using.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究CloudTrail及其为勤勉的AWS用户提供的功能。我们还将从渗透测试人员的角度来看待它，涵盖如何审计目标账户中的CloudTrail最佳实践，以及如何通过CloudTrail对环境进行侦察，如何绕过CloudTrail服务以避开监视，以及如何破坏已经存在的任何日志记录机制。这些主题对我们的客户很有益，因为它们可以帮助他们了解环境中的盲点；然而，它们也可以帮助我们发现更多关于攻击目标的信息，而不一定需要直接对他们使用的每个服务进行API调用。
- en: 'In this chapter, we''ll cover following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setup, best practices, and auditing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置、最佳实践和审计
- en: Reconnaissance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侦察
- en: Bypassing logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过日志记录
- en: Disrupting trails
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏跟踪
- en: More about CloudTrail
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于CloudTrail的更多信息
- en: Although CloudTrail is meant to be the central logging source for an AWS account,
    the way that it is built leaves some undesirable risks out in the open as new
    AWS services are being developed. The team working at AWS that is creating a new
    service must create the CloudTrail integration with their service to allow its
    API calls to be logged to CloudTrail. Also, because of how fast AWS pushes out
    new services and functionality, there are many services that get released without
    any support for CloudTrail. That list can be found here: [https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html).
    Later in this chapter, we will dive into abusing unsupported services for our
    advantage as an attacker, as any API call that doesn't get logged to CloudTrail
    can do wonders for us as attackers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CloudTrail旨在成为AWS账户的中央日志来源，但它的构建方式使一些不良风险暴露在新的AWS服务开发中。AWS的团队正在创建一个新服务，必须创建与他们的服务集成的CloudTrail，以允许其API调用记录到CloudTrail。此外，由于AWS推出新服务和功能的速度很快，有许多服务发布时没有任何对CloudTrail的支持。可以在这里找到该列表：[https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html)。在本章后面，我们将深入探讨滥用不受支持的服务对我们作为攻击者的优势，因为任何不记录到CloudTrail的API调用对我们作为攻击者来说都是有利的。
- en: CloudTrail is also not the only option for logging in an AWS account. It aggregates
    logs from most AWS services, but some services also offer their own specific kinds
    of logging. These types of log include things such as S3 bucket access logs, Elastic
    Load Balancer access logs, CloudWatch logs, VPC flow logs, and many others. These
    other types of logging exist because they don't record API activity like CloudTrail
    does, but instead they log other types of activity that can be useful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CloudTrail并不是AWS账户中日志记录的唯一选项。它汇总了大多数AWS服务的日志，但一些服务也提供了它们自己特定类型的日志记录。这些类型的日志包括S3存储桶访问日志、弹性负载均衡器访问日志、CloudWatch日志、VPC流量日志等。这些其他类型的日志存在是因为它们不像CloudTrail那样记录API活动，而是记录其他类型的活动，这些活动可能会有用。
- en: Before we get started with CloudTrail pentesting, we will see how to set it
    up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始CloudTrail渗透测试之前，我们将看看如何设置它。
- en: Setup, best practices, and auditing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置、最佳实践和审计
- en: In this section, we will run through setting up a new CloudTrail trail that
    follows all the recommended best practices for the most effective/secure setup.
    We will show the setup steps using the AWS web console, but everything we do is
    also possible through the AWS CLI and we will go through auditing CloudTrail through
    the CLI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍如何设置一个新的CloudTrail跟踪，遵循所有推荐的最有效/安全设置的最佳实践。我们将展示使用AWS Web控制台的设置步骤，但我们所做的一切也可以通过AWS
    CLI实现，我们将通过CLI审计CloudTrail。
- en: Setup
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Lets begin to set up CloudTrail by following these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置CloudTrail，按照以下步骤进行：
- en: 'The first thing we will do is navigate to the CloudTrail service in the AWS
    web console and click the Create trail button on the main page:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是导航到AWS Web控制台中的CloudTrail服务，并在主页面上单击“创建跟踪”按钮：
- en: '![](img/53723408-3f16-4c43-8543-57f5ba0b8904.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53723408-3f16-4c43-8543-57f5ba0b8904.png)'
- en: 'Figure 1: Where to find the Create trail button on the CloudTrail service page'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：在CloudTrail服务页面上找到“创建跟踪”按钮的位置
- en: We are going to name our trail `ExampleTrail`, then the next option we are presented
    with on the page is the first best practice that we will look at. The option asks
    if we would like to apply this trail to all regions, which best practices say
    to say yes, apply my trail to all regions. This is because CloudTrail can operate
    on a per-region basis, so you would in theory need a trail for every single region
    that exists without this option. With this option, we can create a single trail
    that monitors API activity across every region, so we always will have insight
    into our environment, wherever that activity is happening.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next up is the Management events section, where we will want to select All.
    There are two types of event in AWS: management events and data events, where
    management events are essentially the high-level APIs that are being used when
    interacting with AWS and data events can be thought of as interactions with resources
    within an AWS account. An example of a data event would be the `s3:GetObject`
    event, which would be someone accessing an object in S3\. We want to ensure that
    all API activity is being recorded, so selecting All for Management events is
    what should be done.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, we now are in the Data events section. Data events cost a little
    bit more money to record, so it may not always be the right decision to record
    all read and write data activity. Also, if you are only using a single account
    for the trail and an S3 bucket to store the logs, you would essentially be logging
    that CloudTrail is writing logs to its log bucket by recording all S3 data events.
    For this reason, we are going to add a single S3 bucket under data events, which
    would be the bucket-for-lambda-pentesting that we created in the previous chapter.
    Under the Lambda tab of the Data events section, we are going to enable Log all
    current and future invocations so that we can monitor invocation activity for
    all our Lambda functions:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/001dfc21-54b9-4d46-b5a0-2216456f278a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: The current configuration for our new trail'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Under the Storage location section, we are going to check Yes for Create a new
    S3 bucket because we do not have a bucket set up to store our logs yet. We're
    going to name it `example-for-cloudtrail-logs`, then we will click the Advanced link
    to drop-down a few more options that we will want to enable.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log file prefix can be filled in or left blank, as it is just adding something
    to the path of the CloudTrail logs for easier identification/separation if you
    have multiple types of log written to a single bucket.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to check Yes for Encrypt log files with SSE-KMS.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We don''t have a KMS key set up yet, so we''ll also select Yes or Create a
    new KMS key and give it the name `CloudTrail-Encryption-Key`. This will ensure
    that all our CloudTrail log files will be encrypted when they are stored in S3,
    and if we would like, it provides us with the ability to manage permissions on
    who can/can''t decrypt those log files for a more fine-grained permission model:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32503746-96cb-40e5-83bc-047e3629c393.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: The rest of the configuration for our new trail'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll select Yes for Enable log file validation, which tells CloudTrail
    to also write digest files to the S3 bucket alongside the logs, which can then
    be used to determine if our log files have been tampered with since CloudTrail
    delivered them to the S3 bucket. This is important to ensure that we have a trustworthy,
    complete recording of API activity in the account.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the last option, Send SNS notification for every log file delivery, we will
    be selecting No for the time being. CloudTrail logs are written often, and this
    can end up with many SNS notifications being sent, so it is better to take a strategic
    approach to this problem if you are interested in these notifications.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can finish up and click Create in the bottom right to create our new
    trail.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the trail will be created and enabled, at which point it will immediately
    start sending log files and digests to your S3 bucket to be read, verified, exported,
    and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在迹象将被创建和启用，此时它将立即开始发送日志文件和摘要到您的S3存储桶，以便读取、验证、导出等。
- en: You might find it necessary to create more than one trail for organisational
    reasons, such as one that logs management events and one that logs data events.
    Often it is recommended to send these logs to another account altogether, because
    then they will be separated from the account, in the event of a compromise, where
    they will likely be safer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 出于组织原因，您可能需要创建多个迹象，例如一个记录管理事件，一个记录数据事件。通常建议将这些日志发送到另一个账户，因为这样它们将与账户分开，在发生妥协时它们可能会更安全。
- en: Auditing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: Now that we have gone through the process of setting up a new CloudTrail trail,
    we can move away from the AWS web console to the AWS CLI, where we will now cover
    how to audit CloudTrail to ensure that all best practices are being followed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置新的CloudTrail迹象的过程，我们可以离开AWS Web控制台，转到AWS CLI，我们将现在介绍如何审计CloudTrail以确保遵循所有最佳实践。
- en: 'First, we will want to see if there are any active trails in our target account.
    We can do this with the CloudTrail `DescribeTrails` API, which allows us to view
    trails across all AWS regions, even if they are managed by the account''s organization.
    The command will look something like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将要查看目标账户中是否有任何活动的迹象。我们可以使用CloudTrail的`DescribeTrails` API来实现这一点，该API允许我们查看所有AWS区域中的迹象，即使它们是由账户的组织管理的。命令将看起来像这样：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--include-shadow-trails` flag is what allows us to see trails from other
    regions/our organization. The only trails that won't show up are region-specific
    trails outside the region the command is run against, so it is possible there
    is some CloudTrail logging going on and you just need to find it. This would still
    be a poor setup because those logs were not expanded across every region. The
    output of that command will give us most of the information that we are interested
    in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`--include-shadow-trails`标志允许我们查看其他区域/我们组织的迹象。不会显示的唯一迹象是针对命令运行的区域之外的特定区域迹象，因此可能存在一些CloudTrail日志记录，您只需要找到它。这仍然是一个不好的设置，因为这些日志没有扩展到每个区域。该命令的输出将给我们大部分我们感兴趣的信息。'
- en: We'll want to ensure that CloudTrail logging is expanded across all regions
    and we can determine that by looking at the `IsMultiRegionalTrail` key of the
    specific trail we are looking at. It should be set to true. If not, then that
    is something that needs to be remediated. A single multi-regional trail makes
    far more sense than a single trail per region for many reasons, but especially
    because as new AWS regions are released, you'd need to create trails for them,
    whereas a multi-regional trail will automatically cover them as they are added.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保CloudTrail日志记录扩展到所有区域，我们可以通过查看我们正在查看的特定迹象的`IsMultiRegionalTrail`键来确定。它应该设置为true。如果没有，那么这是需要纠正的事情。一个多区域迹象比每个区域一个迹象更有意义，原因有很多，尤其是因为随着新的AWS区域的发布，您需要为它们创建迹象，而多区域迹象将在添加它们时自动覆盖它们。
- en: Then we want to ensure that `IncludeGlobalServiceEvents` is set to `true`, as
    that enables the trail to log API activity for non-region-specific AWS services,
    such as IAM, which is global. We will miss a lot of important activity if this
    is disabled. After that, we want to ensure `LogFileValidationEnabled` is set to
    `true` so that deletion and modification of logs can be detected and verified.
    Then we will look for the `KmsKeyId` key, which, if it is present, will be the
    ARN of the KMS key that is being used to encrypt the log files, and if it is not
    present then that means that the log files aren't being encrypted with SSE-KMS.
    This is another setting that should be added if it is not already present.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要确保`IncludeGlobalServiceEvents`设置为`true`，因为这样可以使迹象记录非特定区域的AWS服务的API活动，例如全局的IAM。如果禁用了这个设置，我们将错过很多重要的活动。之后，我们要确保`LogFileValidationEnabled`设置为`true`，以便可以检测和验证日志的删除和修改。然后我们将寻找`KmsKeyId`键，如果存在，将是用于加密日志文件的KMS密钥的ARN，如果不存在，则意味着日志文件没有使用SSE-KMS进行加密。如果尚未存在，这是另一个应该添加的设置。
- en: 'If we want to determine whether data events have been enabled, we can first
    check by looking at the `HasCustomEventSelectors` key and confirming it is set
    to `true`. If it is `true`, we''ll then want to call the `GetEventSelectors` API
    in the region that the trail was created in to see what has been specified. The
    `ExampleTrail` that we created was created in the `us-east-1` region, so we will
    run the following command to look at event selectors:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确定数据事件是否已启用，我们可以首先通过查看`HasCustomEventSelectors`键来确认它是否设置为`true`。如果是`true`，我们将想要调用在创建迹象的区域中调用`GetEventSelectors`
    API来查看已指定了什么。我们创建的`ExampleTrail`是在`us-east-1`区域创建的，因此我们将运行以下命令来查看事件选择器：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That API call returned the following data:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该API调用返回了以下数据：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The values for the different event selectors tell us what kinds of event are
    being logged by this trail. We can see that `ReadWriteType` is set to `All`, which
    means we are recording both read and write events, and not just one of them. We
    can also see `IncludeManagementEvents` is set to `true`, which means the trail
    is logging management events like we want. Under `DataResources` we can see that
    S3 object logging is enabled for the bucket with the ARN `arn:aws:s3:::bucket-for-lambda-pentesting/`,
    but no others, and that Lambda function invocation logging is enabled for functions
    with `arn:aws:lambda` in their ARN, which means all Lambda functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不同事件选择器的值告诉我们这条迹象记录了哪些类型的事件。我们可以看到`ReadWriteType`设置为`All`，这意味着我们记录了读和写事件，而不仅仅是其中的一个。我们还可以看到`IncludeManagementEvents`设置为`true`，这意味着迹象正在记录我们想要的管理事件。在`DataResources`下，我们可以看到S3对象日志记录已启用，ARN为`arn:aws:s3:::bucket-for-lambda-pentesting/`，但没有其他的，并且Lambda函数调用日志已启用，ARN中包含`arn:aws:lambda`的函数，这意味着所有Lambda函数。
- en: Ideally, read and write events should be logged, management events should be
    logged, and all S3 buckets/Lambda functions should be logged, but that might not
    always be possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have checked the configuration of the trail, we need to make sure
    it is enabled and logging! We can do this with the `GetTrailStatus` API from the
    same region the trail was created in:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It will return output that looks like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The number-one most important thing to look for is that the `IsLogging` key
    is set to `true`. If it is set to `false`, then that means the trail is disabled
    and none of that configuration we just checked even matters, because it is not
    actually logging anything.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Further, we can look at the `LatestDeliveryAttemptTime` and `LatestDeliveryAttemptSucceeded` keys
    to ensure that logs are being delivered correctly. If logs are being delivered,
    then those two values should be the same. If not, then there is something wrong
    that is preventing CloudTrail from delivering those logs to S3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: That essentially wraps up the basics of CloudTrail setup and best practices,
    but it is possible to get even more in-depth and secure by creating a custom policy
    for the KMS encryption key used on the trail and by modifying the S3 bucket policy
    to restrict access to the logs even further, prevent the deletion of logs, and
    more.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now be switching gears to cover how CloudTrail can help us out as an
    attacker. One of the ways it can help us is with reconnaissance and information
    gathering.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not always be able to compromise a user who has the necessary S3
    read permissions and has access to encrypt the data with the KMS key used originally.
    If you don''t have both of those permissions, then you won''t be able to read
    the log files. There might even be other restrictions in place that make it difficult
    for you. To get around this, we can use our `cloudtrail:LookupEvents` permission
    to interact with the CloudTrail Event history. The CloudTrail Event history is
    an always-on, immutable record of read/write management events that is made available
    through the CloudTrail API. These logs can be fetched by using the `LookupEvents`
    API or by visiting the Event history page in the AWS web console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1fc9b2c-1d15-4ec4-bf04-9374ebd25f70.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Where to find CloudTrail Event history in the AWS web console'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Because the CloudTrail Event history is immutable and separate from S3, it can
    be a useful tool for both defenders and attackers. As a defender, if something
    happens and your CloudTrail logs get modified or deleted and you can recover them,
    the CloudTrail Event history could be a useful place to go to find out what happened
    during that time period (if it is in the last 90 days). As an attacker, we can
    use it to gather information about the target environment without needing to access
    S3 or KMS.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the number of logs that get stored in Event history and the incredibly
    slow API calls required to download them, it can be difficult to review large
    amounts of information without some sort of filter. For reasons that can likely
    be attributed to you should use a real trail and not just the Event history; the
    CloudTrail `LookupEvents` API will only return 50 events at a time and is rate-limited
    to one call per-second. In big environments, this means it could take huge amounts
    of time to download all the logs for even just the past day. This leaves us with
    two options: one is to just wait out the download and try to get as many as possible,
    but that is not recommended due to the huge amount of time that may be involved.
    The second option is to inspect and filter the logs prior to downloading them,
    so that there are far fewer to wait on.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We can gather a lot of information from looking at different events in the
    Event history. On a large scale, we can determine what users/services are active
    and what kind of activity they do, and we can learn about their habits in AWS.
    This helps us because we can then use this knowledge during the attack. This way,
    we can stay under the radar by not doing anything that could be out of the ordinary
    in the account. Through the AWS web console, we have gone ahead and selected the
    CloudTrail `CreateTrail` Event that was generated when we set up the trail earlier
    in this chapter. The web console will aggregate the information into an easily
    viewable format, but we can click the View event button that appears in order
    to look at the raw JSON of the request. That JSON looks something like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看事件历史中的不同事件，我们可以收集大量信息。在大规模上，我们可以确定哪些用户/服务是活跃的，以及他们进行了什么样的活动，我们可以了解他们在AWS中的习惯。这对我们有帮助，因为我们可以在攻击中使用这些知识。这样，我们可以通过不做任何可能在账户中不寻常的事情来保持低调。通过AWS
    Web控制台，我们已经选择了在本章前面设置trail时生成的CloudTrail `CreateTrail`事件。Web控制台将信息聚合成一个易于查看的格式，但我们可以点击“查看事件”按钮来查看请求的原始JSON。该JSON看起来像下面这样：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even just from this single event, we can gather quite a bit of information about
    the user and the environment. The first thing we can see is that this API call
    was made by an IAM user along with a list of the user ID, ARN, account ID, access
    key ID used, user name, and whether they were MFA authenticated. Also, the `invokedBy` key
    has the value of `signin.amazonaws.com`, which tells us they were logged into
    the AWS web console when they performed this action, rather than using the CLI.
    Then we can see information about the request itself, which includes what event
    it was, what service that event was for, when the event happened, and then a few
    parameters included in the request. After that we see parameters returned from
    the API in the response, which tell us a little about the newly created CloudTrail
    trail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至仅从这一个事件中，我们就可以收集到关于用户和环境的大量信息。我们可以看到的第一件事是，这个API调用是由一个IAM用户进行的，还有用户ID、ARN、账户ID、使用的访问密钥ID、用户名以及他们是否进行了MFA身份验证的列表。此外，`invokedBy`键的值为`signin.amazonaws.com`，这告诉我们他们在执行此操作时已经登录到AWS
    Web控制台，而不是使用CLI。然后我们可以看到有关请求本身的信息，包括事件是什么，该事件是为哪个服务发生的，事件发生的时间，以及请求中包含的一些参数。之后，我们可以看到API在响应中返回的参数，这些参数告诉我们一些关于新创建的CloudTrail
    trail的信息。
- en: Two of the most important things we skipped over included the IP address that
    the request originated from and the user agent used for the request. The IP will
    tell us where the call came from and with a larger sample set could potentially
    allow us to determine where the users work from, what the office IP address is,
    and more. For example, if we see that multiple users are originating from the
    same IP address during work hours (9am to 5pm), it would be safe to assume that
    they are all at the office or all on a VPN when working with AWS APIs. We then
    know that it would be strange if one of those users started coming from some external
    IP we haven't seen before when we compromise them, so we can build our attack
    plan around that to try and avoid it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略的两个最重要的事情包括请求的来源IP地址和请求使用的用户代理。IP地址将告诉我们呼叫来自何处，并且在更大的样本集中可能允许我们确定用户的工作地点，办公室的IP地址等。例如，如果我们看到多个用户在工作时间（上午9点至下午5点）从同一个IP地址发起，那么可以安全地假设他们都在办公室或者在使用AWS
    API时都在VPN上。然后我们知道，如果其中一个用户开始从我们以前没有见过的外部IP地址发起请求，那将是奇怪的，因此我们可以围绕这一点制定我们的攻击计划，试图避免这种情况。
- en: 'The same thing goes for user agents. In the preceding example event, the user
    agent was `signin.amazonaws.com`, which is the user agent that appears when using
    the AWS web console. If we look at a different event, such as when we used the
    `GetEventSelectors` API from the AWS CLI, we can see that the user agent is much
    more specific:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理也是一样的。在前面的示例事件中，用户代理是`signin.amazonaws.com`，这是在使用AWS Web控制台时出现的用户代理。如果我们看一个不同的事件，比如当我们使用AWS
    CLI中的`GetEventSelectors` API时，我们可以看到用户代理更加具体：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The user agent from this request is set to `aws-cli/1.16.81 Python/3.7.0 Windows/10
    botocore/1.12.71`, which gives us a lot of information about the system the user
    is using. We can see they used version 1.16.81 of the AWS CLI, which is using
    Python version 3.7.0, on Windows 10, and using version 1.12.71 of the botocore
    library. This information on its own gives us an insight into the systems that
    may be in use at our target company, but also it allows us to gather a list of
    known user agents in the environment. With that list, we can then spoof our own
    user agent to look like a known one so that we don't stand out as abnormal in
    our API requests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求的用户代理设置为`aws-cli/1.16.81 Python/3.7.0 Windows/10 botocore/1.12.71`，这为我们提供了关于用户使用的系统的大量信息。我们可以看到他们使用了AWS
    CLI的1.16.81版本，使用的是Python 3.7.0版本，在Windows 10上，并且使用了botocore库的1.12.71版本。这些信息本身就让我们了解到可能在我们目标公司使用的系统，同时也让我们能够收集环境中已知用户代理的列表。有了这个列表，我们可以伪装自己的用户代理，使其看起来像一个已知的用户代理，这样我们在API请求中就不会显得异常。
- en: There are many things you can do by looking through CloudTrail logs/Event history,
    including the small amount of information gathering we did earlier. You could
    also determine what AWS services are in use in the account based on API calls
    made to those services, and you can potentially discover helpful information about
    specific resources in the account. For example, let's say that you don't have
    the `ec2:DescribeInstances` permission, but you have the `ec2:ModifyInstance`
    permission. In theory, you wouldn't be able to get a list of EC2 instances to
    then use the `ec2:ModifyInstance` API on because you don't have access, but you
    could look through CloudTrail logs to find an event where someone interacted with
    an EC2 instance in the past. That event will likely include the instance ID and
    possibly other information that could be helpful to you in discovering those assets
    in the environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看CloudTrail日志/事件历史，您可以做很多事情，包括我们之前进行的少量信息收集。您还可以根据对这些服务的API调用来确定账户中正在使用的AWS服务，并且可能发现有关账户中特定资源的有用信息。例如，假设您没有`ec2:DescribeInstances`权限，但您有`ec2:ModifyInstance`权限。理论上，您将无法获取EC2实例的列表，然后使用`ec2:ModifyInstance`API，因为您没有访问权限，但您可以查看CloudTrail日志，查找过去有人与EC2实例交互的事件。该事件可能包括实例ID和可能对您在发现环境中的资产有帮助的其他信息。
- en: Event history isn't the only place to look for this information either, because
    if you do have the necessary S3 and KMS permissions, you could just download the
    logs straight from the S3 bucket they are delivered to, which would be much quicker
    and much easier to parse than the output of the Event history API. Be careful
    to not trip any wires, though, as activity within that bucket might be being monitored,
    and a bunch of requests to download files from it could potentially look suspicious
    to a defender.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 事件历史并不是查找这些信息的唯一地方，因为如果您具有必要的S3和KMS权限，您可以直接从它们交付的S3存储桶中下载日志，这比事件历史API的输出更快、更容易解析。但要小心不要触发任何警报，因为该存储桶内的活动可能正在被监视，从中下载文件的一系列请求可能会对防御者看起来可疑。
- en: Bypassing logging
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过日志记录
- en: Now we are going to bypass CloudTrail to discover information about an account
    you have gained access to. The first method uses services that aren't supported
    in CloudTrail to gather basic account information and the second method uses some
    of that information to enumerate IAM resources in the account, all without generating
    CloudTrail logs in the target account.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将绕过CloudTrail来发现您已经获得访问权限的账户的信息。第一种方法使用CloudTrail不支持的服务来收集基本账户信息，第二种方法使用其中一些信息来枚举账户中的IAM资源，而不会在目标账户中生成CloudTrail日志。
- en: Unsupported CloudTrail services for attackers and defenders
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击者和防御者的不受支持的CloudTrail服务
- en: 'As we mentioned earlier in this chapter, CloudTrail doesn''t log everything,
    including many services that are completely unsupported. Again, that list of unsupported
    services can be found here: [https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html).
    What this means is that our API calls to these services will not get logged anywhere
    by CloudTrail (including Event history!). Some of these services can prove to
    be very lucrative for us as attackers, so if you compromise a user and find that
    they have access to any of those services, they are worth checking out because
    you can stay under the radar and still benefit greatly. Another big point about
    unsupported CloudTrail services is that that means you can''t create CloudWatch
    Events rules for those API actions, which means you can''t instantly respond to
    events happening in those services.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提到的，CloudTrail并不记录所有内容，包括许多完全不受支持的服务。同样，不受支持服务的列表可以在这里找到：[https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-unsupported-aws-services.html)。这意味着我们对这些服务的API调用将不会被CloudTrail记录在任何地方（包括事件历史！）。其中一些服务对我们作为攻击者可能非常有利，因此如果您攻破了某个用户并发现他们可以访问其中任何服务，那么值得检查，因为您可以保持低调并获得巨大利益。另一个关于不受支持的CloudTrail服务的重要一点是，这意味着您无法为这些API操作创建CloudWatch事件规则，这意味着您无法立即响应这些服务中发生的事件。
- en: As an attacker, if we are looking for compute resources, we can abuse a few
    different unlogged services. At the time of writing, AppStream 2.0, Amplify, and
    Cloud9 all provide us with access to managed EC2 servers in one way or another.
    This means we can spin up servers and interact with them without ever getting
    logged.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，如果我们正在寻找计算资源，我们可以滥用一些不同的未记录服务。在撰写本文时，AppStream 2.0、Amplify和Cloud9都以某种方式为我们提供了对托管的EC2服务器的访问权限。这意味着我们可以启动服务器并与其交互，而不会被记录。
- en: 'As a defender, it is important to ensure that no users have access to these
    services unless necessary. If it is required to provide access to any of the unlogged
    services, then utilize any built-in logging the service may provide and make use
    of some of the other features that IAM provides to monitor this access. If you
    download an IAM credential report, you can see if a service was accessed recently
    by looking in the `access_key_1_last_used_service` and `access_key_2_last_used_service` columns,
    where those unlogged services will still show up. To get an IAM credential report,
    you can run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为防御者，重要的是确保除非必要，否则没有用户可以访问这些服务。如果需要提供对任何未记录服务的访问权限，那么利用服务可能提供的任何内置日志，并利用IAM提供的其他一些功能来监视此访问。如果您下载IAM凭证报告，您可以通过查看`access_key_1_last_used_service`和`access_key_2_last_used_service`列来查看服务最近是否被访问，那些未记录的服务仍然会显示出来。要获取IAM凭证报告，您可以运行以下命令：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another option is to use the IAM `GenerateServiceLastAccessedDetails` and `GetServiceLastAccessDetails`
    APIs to determine when/if a user accessed a certain service, including the services
    that aren''t logged by CloudTrail. To do this, we can first run the generate command
    to generate the report:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用IAM的`GenerateServiceLastAccessedDetails`和`GetServiceLastAccessDetails`API来确定用户何时/是否访问了某个服务，包括CloudTrail未记录的服务。为此，我们可以首先运行生成命令来生成报告：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The value for the ARN argument must be the ARN of an IAM resource, including
    users, groups, roles, and managed policies. This API command should return a `JobId` back
    to you. Then we can get the report by using that ID:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ARN参数的值必须是IAM资源的ARN，包括用户、组、角色和托管策略。这个API命令应该会返回一个`JobId`给你。然后我们可以使用那个ID来获取报告：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The response from that command will include information about whether a resource
    has authenticated to a certain service and when that last authentication took
    place. These APIs won't tell you exactly what kind of activity is going on, but
    you can at least check to see who is trying to access those services.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的响应将包括有关资源是否已经对某个服务进行了身份验证以及上次身份验证发生的时间的信息。这些API不会告诉你正在进行的确切活动，但至少可以检查谁正在尝试访问这些服务。
- en: These APIs also help detect the use of unlogged CloudTrail services for account
    enumeration. The Wired company released an article on research from Rhino Security
    Labs that entailed a method that essentially allows an attacker with keys to gather
    a small amount of AWS account information without getting logged by CloudTrail
    ([https://www.wired.com/story/aws-honeytoken-hackers-avoid/](https://www.wired.com/story/aws-honeytoken-hackers-avoid/)).
    The reason this research is so important is because there are many canary token
    services that rely on CloudTrail to alert when keys have been compromised. Canary
    tokens are typically placed somewhere in an environment and are rigged to set
    off an alarm when used, which would indicate an attacker is in the environment
    and found those tokens. For AWS, canary token providers typically rely on CloudTrail
    for these alarms, but Rhino Security Labs showed that it was possible to bypass
    these alarms and determine whether AWS keys were canary tokens or not while staying
    under the radar.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API还有助于检测未记录的CloudTrail服务用于账户枚举。Wired公司发布了一篇关于Rhino Security Labs研究的文章，该研究涉及一种方法，基本上允许攻击者使用密钥收集少量AWS账户信息，而不会被CloudTrail记录（https://www.wired.com/story/aws-honeytoken-hackers-avoid/）。这项研究之所以如此重要，是因为有许多金丝雀令牌服务依赖于CloudTrail，在密钥被泄露时发出警报。金丝雀令牌通常放置在环境中的某个地方，并设置为在使用时触发警报，这将表明攻击者在环境中并找到了这些令牌。对于AWS，金丝雀令牌提供商通常依赖于CloudTrail来发出这些警报，但Rhino
    Security Labs表明可以绕过这些警报，并确定AWS密钥是否为金丝雀令牌，同时保持低调。
- en: At the time, it was found that some of the most popular canary token providers
    for AWS used a single account to generate these keys *or* would include identifying
    information in the user that indicated they were being used as a canary token.
    This information could then be exposed through verbose error messages returned
    from unsupported CloudTrail services, thus allowing the attacker to identify if
    AWS keys are canary tokens based on the account ID or user name/path without ever
    triggering the alarm the keys were meant to trigger. One project that was vulnerable
    to this attack was `SpaceCrab` by Atlassian.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当时发现，一些最受欢迎的AWS金丝雀令牌提供商使用单个账户生成这些密钥，或者在指示它们正在被用作金丝雀令牌的用户中包含识别信息。这些信息可以通过从不受支持的CloudTrail服务返回的冗长错误消息中暴露出来，从而允许攻击者根据账户ID或用户名/路径来识别AWS密钥是否为金丝雀令牌，而不会触发密钥本来应该触发的警报。Atlassian的`SpaceCrab`项目就是这种攻击的一个受害者。
- en: 'Originally, the default `SpaceCrab` setting would set a path for the IAM user
    it created with `/SpaceCrab/` as the value. An attacker could then run an AWS
    CLI command against an unsupported CloudTrail service, where the user''s ARN would
    get disclosed in an error message. The ARN includes the user''s path, so it was
    clear that the keys were canary tokens created by `SpaceCrab`. The following is
    an example error message returned when running the AppStream `DescribeFleets`
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，默认的`SpaceCrab`设置将IAM用户的路径设置为`/SpaceCrab/`。然后，攻击者可以针对不受支持的CloudTrail服务运行AWS
    CLI命令，用户的ARN将在错误消息中被披露。ARN包括用户的路径，因此很明显这些密钥是由`SpaceCrab`创建的金丝雀令牌。以下是在运行AppStream
    `DescribeFleets`命令时返回的示例错误消息：
- en: '![](img/c581e8bf-a547-4728-a25b-5454b0553d85.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c581e8bf-a547-4728-a25b-5454b0553d85.png)'
- en: 'Figure 5: The IAM user path contained SpaceCrab, disclosing that they were
    canary tokens'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：IAM用户路径包含SpaceCrab，透露了它们是金丝雀令牌
- en: The issue was reported to Atlassian and the vulnerability was fixed. The issue
    was also reported to AWS themselves, but it was rejected because they don't consider
    an ARN to be sensitive information. This is correct, but a user should not be
    able to fetch that information without generating any logs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题已报告给Atlassian并得到解决。问题也报告给了AWS本身，但被拒绝，因为他们不认为ARN是敏感信息。这是正确的，但用户不应该能够在不生成任何日志的情况下获取这些信息。
- en: 'AWS Amplify is another newer service that is unsupported in CloudTrail and
    it outputs similar verbose error messages. The following message was returned
    when trying to run the `ListApps` command without the right permissions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Amplify是另一个在CloudTrail中不受支持的较新的服务，它输出类似的冗长错误消息。在尝试运行`ListApps`命令而没有正确权限时返回了以下消息：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This small attack is essentially timeless if the AWS service output error messages
    like that and if there are services that CloudTrail doesn't support. This same
    attack will likely work for any new service that gets released and isn't logged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AWS服务输出类似的错误消息，并且有一些CloudTrail不支持的服务，这种小型攻击基本上是永恒的。同样的攻击可能适用于任何新发布的并且未被记录的服务。
- en: Even this small amount of information can be helpful to an attacker, because
    they can then use other non-logged attack vectors, such as cross-account IAM user/role
    enumeration, to gather more information ([https://rhinosecuritylabs.com/aws/aws-iam-user-enumeration/](https://rhinosecuritylabs.com/aws/aws-iam-user-enumeration/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这么少的信息对攻击者也有帮助，因为他们可以使用其他未记录的攻击向量，例如跨账户IAM用户/角色枚举，来收集更多信息（[https://rhinosecuritylabs.com/aws/aws-iam-user-enumeration/](https://rhinosecuritylabs.com/aws/aws-iam-user-enumeration/)）。
- en: Bypassing logging through cross-account methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过跨账户方法绕过日志记录
- en: Like we just noted, it is possible to enumerate users and roles in an AWS account
    without any permissions or logs in the target account. All that we need to make
    this happen is our own AWS account and the AWS account ID of our target.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才指出的，可以在AWS账户中枚举用户和角色，而无需目标账户中的任何权限或日志。我们需要的一切就是我们自己的AWS账户和我们目标的AWS账户ID。
- en: Enumerating users
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举用户
- en: Like we covered in the IAM chapter earlier on, an IAM role has a trust policy
    document that specifies what IAM resources/accounts can request temporary credentials
    from it. Behind the scenes, all IAM resources are created uniquely and IAM role
    trust policies recognize that. The reason for this is that, if you specify that
    the user `Mike` can assume a certain role, then `Mike` is deleted; in theory,
    an attacker could create another IAM user named `Mike` and assume that role. In
    practice, that is not the case, because behind the scenes, the roles trust policy
    is referencing a unique user ID rather than just the user name.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前在IAM章节中介绍的那样，IAM角色有一个信任策略文档，指定了哪些IAM资源/账户可以从中请求临时凭证。在幕后，所有IAM资源都是唯一创建的，IAM角色信任策略也认可这一点。这样做的原因是，如果您指定用户`Mike`可以假定某个角色，然后删除`Mike`；理论上，攻击者可以创建另一个名为`Mike`的IAM用户并假定该角色。实际上，情况并非如此，因为在幕后，角色信任策略引用的是唯一用户ID，而不仅仅是用户名。
- en: Because of that conversion from user ARN to a unique user ID behind the scenes,
    IAM will not let you set a trust policy that allows access to a non-existent user.
    Also, roles can be assumed to be cross-account, so you can specify other account
    IDs in the trust policy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在幕后将用户ARN转换为唯一用户ID，IAM不会允许您设置允许访问不存在用户的信任策略。此外，角色可以被假定为跨账户，因此可以在信任策略中指定其他账户ID。
- en: 'Given both those facts, if we as an attacker have the account ID of another
    account, we can essentially brute-force which users exist in their account. This
    process has been automated in a Pacu module named `iam__enum_users`. With Pacu
    open and configured, we can run the following command to enumerate IAM users in
    the account with the ID `000000000000`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这两个事实，如果作为攻击者，我们拥有另一个账户的账户ID，我们基本上可以暴力破解其账户中存在哪些用户。这个过程已经在一个名为`iam__enum_users`的Pacu模块中自动化。使用Pacu打开并配置后，我们可以运行以下命令来枚举具有ID`000000000000`的账户中的IAM用户：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`TestRole` is an IAM role that was created in my own account. Pacu uses that
    role to update the trust policy document for enumeration, so it is important that
    this module is run with your own AWS access keys and you give it the role name
    of a role that those keys have access to update.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestRole`是在我的账户中创建的IAM角色。Pacu使用该角色来更新信任策略文档以进行枚举，因此很重要的是使用您自己的AWS访问密钥运行此模块，并提供具有更新访问权限的角色名称。'
- en: When running the module, your own AWS CloudTrail logs will get flooded with
    `iam:UpdateAssumeRolePolicy` logs, but the target account will not see a thing,
    allowing you to stealthily gather information on the target environment.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该模块时，您自己的AWS CloudTrail日志将被`iam:UpdateAssumeRolePolicy`日志淹没，但目标账户将看不到任何东西，从而允许您悄悄地收集有关目标环境的信息。
- en: 'Using a custom wordlist, we were able to enumerate two users, `Alexa` and `Test`,
    from the target account with the ID `000000000000` (this is just a demo, this
    won''t work for you because `000000000000` is not a real AWS account). The output
    from the Pacu module looks something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义单词列表，我们能够从ID为`000000000000`的目标账户中枚举出两个用户`Alexa`和`Test`（这只是一个演示，对您没有用，因为`000000000000`不是真实的AWS账户）。Pacu模块的输出看起来像这样：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output shows that it found two valid users out of seven total guesses from
    our modified wordlist. At the time of writing, the default wordlist that Pacu
    uses has 1,136 names that it will try.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，从我们修改后的单词列表中的七次猜测中找到了两个有效用户。在撰写本文时，Pacu使用的默认单词列表有1,136个名称。
- en: Enumerating roles
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举角色
- en: It used to be possible to use a similar attack to enumerate what roles exist
    in another AWS account and again, if only the AWS account ID was needed, then
    we could essentially brute-force all the roles that exist. Since the release by
    Rhino Security Labs, AWS has modified the error messages that the STS `AssumeRole`
    API call returns from the API, which means it is no longer possible to determine
    whether a role exists or not with this method. The `iam__enum_assume_role` Pacu
    module was written to exploit this, but no longer works due to this change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以前可以使用类似的攻击来枚举另一个AWS账户中存在的角色，如果只需要AWS账户ID，那么我们基本上可以暴力破解所有存在的角色。由于Rhino Security
    Labs发布后，AWS已经修改了STS `AssumeRole` API调用从API返回的错误消息，这意味着不再可能使用这种方法确定角色是否存在。`iam__enum_assume_role`
    Pacu模块旨在利用此功能，但由于此更改，它不再起作用。
- en: 'On the plus side, a new method was discovered that allows you to enumerate
    roles on a cross-account basis. This method is the same as the method used to
    enumerate cross-account users. Originally this method didn''t work like it does
    now, but some API changes must have been made that now make this enumeration possible.
    A new Pacu module was written to abuse this attack vector and it is named `iam__enum_roles`.
    It works exactly the same as the `iam__enum_users` module, so it can be run with
    essentially the same command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，发现了一种新方法，允许您跨账户基础上枚举角色。这种方法与用于枚举跨账户用户的方法相同。最初，这种方法的工作方式与现在不同，但必须进行了一些API更改，现在使得这种枚举成为可能。编写了一个新的Pacu模块来滥用这种攻击向量，它被命名为`iam__enum_roles`。它的工作方式与`iam__enum_users`模块完全相同，因此可以使用基本相同的命令运行：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The module will enumerate roles that exist in the target account, then try
    to assume those roles to retrieve temporary credentials, in the event its policy
    is misconfigured and will allow you access. Part of that module is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example shows that a few roles were found and that one of them
    was misconfigured to allow us to request credentials for it. At the time of writing,
    the default wordlist that Pacu uses 1,136 names that it will try.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Both user and role enumeration are essentially timeless, such as the verbose
    AWS CLI error messages, because it is exploiting intended functionality and not
    any sort of bug in the API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Disrupting trails
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to disrupt the logging of CloudTrail trails to try and stay
    under the radar during our attack, but they all will likely trigger alerts that
    will expose our activity to someone paying attention. It is still important to
    know about these methods though, because not every account we attack will have
    even the most basic monitoring capabilities (such as GuardDuty), so it would make
    sense to disable any CloudTrail logging in that case. There are partial solutions
    to this problem though; those solutions and their limitations will be discussed
    at the end of this section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Turning off logging
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One easy method to disrupt CloudTrail logging would be to just simply turn
    off any active trails. There is an API made just for this, the `StopLogging` API.
    From the AWS CLI, we can turn off logging for a trail named `test` within our
    account with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command must be run from the region that the target trail was created in,
    otherwise it will return an `InvalidHomeRegionException` error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This same task can also be accomplished with the `detection__detection` Pacu
    module. That Pacu command would look something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You would then be prompted with four different options: disable, delete, minimize,
    or skip. To stop the logging of the trail, we would select disable (dis). Pacu
    would then disable logging for the targeted trail(s).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: More information on GuardDuty can be found in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In either case, if GuardDuty was running, it would trigger a `Stealth:IAMUser/CloudTrailLoggingDisabled` alert
    ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2)),
    indicating that a trail has been disabled. This would expose our unauthorized
    access to the environment and likely shut down our attack if someone was paying
    attention.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Deleting trails/S3 buckets
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another set of options that avoid the `StopLogging` API would be to either
    delete the CloudTrail trail altogether or delete the S3 bucket it is sending its
    logs to. We can delete a trail named `test` from the AWS CLI with the following
    command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This can also be done with Pacu, by running the same command we used earlier
    to disable the trail, but by choosing the delete (del) option instead:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once prompted for what to do to the trail, we would select `del`, which would
    subsequently delete the CloudTrail completely, meaning logging has stopped.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also delete the S3 bucket that a certain trail is delivering logs
    to, which would prevent an active trail from logging anything. This can avoid
    the CloudTrail API completely (if you know what bucket to delete), but it is still
    very noisy because it will leave the trail in an error state. We can use the AWS
    CLI to identify the name of the bucket that the trail is sending logs to, if we
    don''t already know it, with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we would look at the value of the `S3BucketName` key for the trail we
    want to target, which we will say is `cloudtrail_bucket`. We could then delete
    that S3 bucket with the following AWS CLI command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the CloudTrail would keep attempting to deliver logs to that bucket, but
    it will fail, meaning no logs will be written for the duration that the bucket
    is deleted. If you already knew what bucket was being targeted, you wouldn't ever
    need the run any CloudTrail API calls; only the S3 `DeleteBucket` call. There
    is no Pacu module available to perform this task (grabbing the bucket targeted
    by a trail, then deleting it). Afterwards, you could even go ahead and create
    that bucket in your own attacker account and provide the correct cross-account
    write permissions; then you would be supplied all the CloudTrail logs and your
    target account would not be able to access them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Just like disabling a trail, deleting a trail or its target bucket with GuardDuty
    enabled will trigger the `Stealth:IAMUser/CloudTrailLoggingDisabled` alert ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2)),
    indicating that a trail or its bucket has been deleted. Again, this would expose
    our unauthorized access to the environment and likely shut down our attack if
    someone was paying attention.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Minifying trails
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option that avoids disabling or deleting in the target account would
    be to modify a trail to minimize what exactly it is logging. For this example,
    let's say that there is a trail named `test` that is logging for every region;
    it logs global services events, log file validation is enabled, log file encryption
    is enabled, and it logs access to every S3 bucket and Lambda function in the account.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid disabling or deleting this trail, we could use the `UpdateTrail` API
    to remove all the bells and whistles it has set up. We could run the following
    AWS CLI command to disable global service events, change it from a global trail
    to a single-region trail, disable log file encryption, and disable log file validation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By setting the KMS key ID to a blank value, all logs from then on will be unencrypted.
    You could also pick and choose which settings to modify, such as if you want to
    target the `us-west-2` region with a non-global API, and the trail is a global
    trail that was created in `us-east-1`. In that case, all you would need to do
    is include the `--no-is-multi-region-trail` flag and make sure you stay within
    `us-west-2`. If the trail was sending notifications to an SNS topic, you could
    also disable that by setting the topic to a blank string. The same goes for CloudWatch
    logs associated with the trail as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like disabling/deleting a trail, the `detection__disruption` Pacu module
    will automate this process for you. We can run the same command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then when prompted, we select the minimize (`m`) option, which will remove any
    associated SNS topics, disable global service events, change it from a global
    trail to a single-region trail, disable log file validation, remove any associations
    with CloudWatch log groups and the associated role, and remove log file encryption.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Similar to disabling/deleting a trail, with GuardDuty enabled, these types of
    modification have the potential to trigger the `Stealth:IAMUser/CloudTrailLoggingDisabled` ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth2))
    and/or `Stealth:IAMUser/LoggingConfigurationModified` ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth3](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_stealth.html#stealth3))
    alerts, which would likely end up with us getting detected in the environment.
    At the time of writing, we have never seen GuardDuty trigger on this type of attack
    on CloudTrail, though the descriptions for the two finding types seem to indicate
    that they should be triggered, so it is unknown whether this is detected for sure
    or not.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify S3 data and Lambda invocation event settings for the trail, we will
    need to use the `PutEventSelectors` API instead of `UpdateTrail`. We can modify
    the event selectors to remove any selectors for data events (S3/Lambda), so those
    will no longer be logged by the trail. We could also modify `ReadWriteType`, which
    specifies whether the trail should log read events, write events, or both. It
    would be simple to modify that and set it to only record read events, so our malicious
    write events don''t get logged. We could remove all data event logging and only
    record read events by using the following AWS CLI command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside `event_selectors.json`, we would have the following content:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This JSON document tells CloudTrail to only record read events and to not record
    any data events (S3/Lambda). Once this is applied to the trail, it will now log
    information that is missing a majority of the story, allowing us attackers to
    get by log analysis.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Problems with disruption (and some partial solutions)
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem with these types of attack on CloudTrail is that GuardDuty
    is designed to detect them, but there are a few potential bypasses that allow
    us to make changes without being discovered.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The first and most simple bypass would be to detect what the usual activity
    is for the user you have compromised. GuardDuty uses machine learning (more in
    [Chapter 16](14f5f864-8cf1-4232-86f5-8d0fa4ec28e4.xhtml), *GuardDuty*) to detect
    these attacks as being unusual, so if you compromised a user who has a history
    of disabling/deleting/modifying CloudTrail trails, then it might be possible for
    you to do the same without GuardDuty detecting that as an anomaly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Another partial solution would be to modify logs after they are delivered to
    their S3 bucket. If the target is properly utilizing the log file validation setting
    on their trail, would be able to detect this, but if they were not, then it would
    be simple to go into the S3 bucket where the logs are being delivered, where we
    then could modify the logs to remove any traces of our attacker activity. There
    are multiple things that could be put in place to defend against such attack,
    but it might be possible in an environment that you encounter during a pentest.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that deleting/modifying logs in an S3 bucket does
    not mean those logs are deleted/modified in CloudTrail Event history, because
    those logs will stay there immutably for 90 days. CloudTrail Event history can
    be difficult to work with due to its speed and limitations, so in a worst-case-scenario
    (where a defender investigates your activity almost immediately), you still buy
    yourself some time before they can properly inspect your activity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered setting up a CloudTrail Event that follows best
    practices where possible, and also how to audit for the best practices in a target
    environment. CloudTrail is not a perfect service, and we have demonstrated that
    through the use of services that it does not support it is possible to perform
    reconnaissance in an account without ever generating any logs. For this reason,
    it is useful to keep track of what services are unsupported in CloudTrail so that
    you can exploit them as they are released while in a target environment, without
    every showing up in the logs. Cross-account enumeration methods also allow us
    to discover information about our target account without generating logs (in the
    target account), meaning that we can get an understanding of who uses the environment
    and what is used in the environment without making API calls with the compromised
    set of keys. We also showed how we can use Pacu to automate some of our attacks
    on CloudTrail, but also where GuardDuty steps in to try and detect these actions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing GuardDuty in more depth, focusing
    on what it detects and flags and how we can bypass those detections beyond what
    we have discussed in this chapter. These bypasses and an understanding of the
    detection methods used by GuardDuty will allow us to attack an environment with
    force, while still staying stealthy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地讨论GuardDuty，重点关注它检测和标记的内容，以及我们如何绕过本章讨论的内容。这些绕过和对GuardDuty使用的检测方法的理解将使我们能够以强大的力量攻击环境，同时保持隐秘。

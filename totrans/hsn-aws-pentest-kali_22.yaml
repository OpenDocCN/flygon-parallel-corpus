- en: GuardDuty
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GuardDuty
- en: As attackers, it is important to understand what kind of monitoring is going
    on in our target environment, as it can and will shape the entire attack plan.
    If I know that a certain type of monitoring is enabled to trigger whenever XYZ
    happens, then I won't ever perform XYZ because I know that I'll get caught. Instead,
    I'll take another route that is more likely to go under the radar. If I know that
    there is no monitoring in the environment, then I can take the easiest or quickest
    path to my goal without worrying about triggering alerts on certain actions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，了解目标环境中进行了哪种类型的监视是很重要的，因为它可以并将塑造整个攻击计划。如果我知道某种类型的监视已启用以在发生XYZ时触发警报，那么我就不会执行XYZ，因为我知道我会被抓住。相反，我会选择另一条更有可能不被察觉的路线。如果我知道环境中没有监视，那么我可以采取最简单或最快的路径来实现我的目标，而不必担心触发某些操作的警报。
- en: '**Amazon Web Services** (**AWS**) offers a variety of security services, but
    the main security monitoring service is known as **GuardDuty**. It is important
    to note that even in an environment where GuardDuty is disabled, this doesn''t
    100% mean that there isn''t any monitoring going on. This is because there are
    plenty of tools, in-house to AWS as well as third-party tools that provide monitoring
    options. This chapter will cover the AWS service for monitoring, GuardDuty, which
    is a cheap, in-house solution to catch low-hanging fruit within an environment.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务**（**AWS**）提供各种安全服务，但主要的安全监控服务是**GuardDuty**。需要注意的是，即使在禁用GuardDuty的环境中，这并不意味着没有任何监视。这是因为有许多工具，包括AWS内部和第三方工具，提供监视选项。本章将介绍AWS监视服务GuardDuty，这是一个廉价的内部解决方案，用于在环境中捕捉低
    hanging fruit。'
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to GuardDuty and its findings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GuardDuty及其发现简介
- en: Alerting about and reacting to GuardDuty findings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GuardDuty发现的警报和反应
- en: Bypassing GuardDuty
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过GuardDuty
- en: An introduction to GuardDuty and its findings
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GuardDuty及其发现简介
- en: GuardDuty is a continuous monitoring service offered by AWS that identifies
    and alerts about suspicious or unwanted behavior within an account. There are
    currently three data sources that it analyzes, which are **virtual private cloud**
    (**VPC**) flow logs, CloudTrail event logs, and **domain name**** system** (**DNS**) logs.
    Note that VPC flow logging and CloudTrail event logging do not need to be enabled
    on your account for GuardDuty to use them, and there is currently no way to review
    DNS logs in AWS. This means that even if there are no flow logs active in the
    environment and CloudTrail is disabled, GuardDuty will still generate findings
    from VPC flow logs, CloudTrail event logs, and DNS logs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GuardDuty是AWS提供的持续监控服务，可识别并警告账户内的可疑或不需要的行为。目前，它分析三种数据源，即**虚拟私有云**（**VPC**）流日志，CloudTrail事件日志和**域名系统**（**DNS**）日志。请注意，VPC流日志和CloudTrail事件日志不需要在您的账户上启用GuardDuty才能使用它们，目前无法在AWS中查看DNS日志。这意味着即使环境中没有活动的流日志，并且CloudTrail被禁用，GuardDuty仍将从VPC流日志，CloudTrail事件日志和DNS日志生成发现。
- en: It is also important to note that GuardDuty can only ingest DNS logs if the
    requests are routed through AWS DNS resolvers, which is the default for EC2 instances.
    If this is changed and requests are using an alternate DNS resolver, such as Google
    or CloudFlare, then GuardDuty cannot ingest and alert on that DNS data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，GuardDuty只能摄取DNS日志，如果请求通过AWS DNS解析器路由，则EC2实例的默认设置。如果更改了这一设置，并且请求使用其他DNS解析器，例如Google或CloudFlare，则GuardDuty无法摄取和警报该DNS数据。
- en: GuardDuty can be managed cross-account as well, where a single master account
    controls the GuardDuty monitoring and configuration for one or more member accounts.
    If you ever find yourself in the GuardDuty master account of an organization,
    you will potentially be able to manipulate monitoring configuration across every
    account connected with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GuardDuty也可以进行跨账户管理，其中单个主账户控制一个或多个成员账户的GuardDuty监视和配置。如果您发现自己在组织的GuardDuty主账户中，您可能能够操纵与其连接的每个账户的监视配置。
- en: 'For more information on cross-account GuardDuty configurations, visit the AWS
    documentation here: [https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有关跨账户GuardDuty配置的更多信息，请访问AWS文档：[https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html)。
- en: GuardDuty generates findings on a variety of different items. For the most up-to-date
    list, visit [https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html)
    to review the active set of findings that are generated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GuardDuty会针对各种不同的项目生成发现。有关最新列表，请访问[https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html)以查看生成的活动发现集。
- en: 'At a high level, GuardDuty will basically alert you about events that may resemble
    malicious behavior, such as if an EC2 instance is communicating with a known malware
    command and control server, an EC2 instance is communicating with a known Bitcoin
    mining pool, or a known hacking operating system is being used. These alerts can
    then be set up to send notifications to `CloudWatch` Events, where you can then
    react to the findings:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，GuardDuty基本上会警告您可能类似恶意行为的事件，例如如果EC2实例正在与已知的恶意软件命令和控制服务器通信，EC2实例正在与已知的比特币挖矿池通信，或者正在使用已知的黑客操作系统。然后可以设置这些警报以发送通知到`CloudWatch`事件，然后您可以对发现做出反应：
- en: '![](img/88b2176a-6be5-406d-ad42-0b5cf081201b.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88b2176a-6be5-406d-ad42-0b5cf081201b.png)'
- en: A list of sample GuardDuty findings reported in an account in the AWS web console
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Web控制台中报告的账户中的GuardDuty发现示例列表
- en: Most GuardDuty finding types rely on machine learning to establish a baseline
    of normal activity by users in an account. It will alert on something if it is
    outside of that baseline and matches that finding type. Consider an example AWS
    account with two IAM users and GuardDuty enabled. One of those users is frequently
    using the IAM service to manage users, groups, and roles, and to manage the permissions
    of all of those. The other user only uses the EC2 service, even though they have
    permission to do more than that. If both users attempted to enumerate permissions
    of IAM users, groups, or roles, GuardDuty will likely not trigger the IAM user,
    because it is part of that user's baseline to interact with the IAM service like
    that. On the other hand, the EC2 user will likely generate the `Recon:IAMUser/UserPermissions` GuardDuty
    finding type, which indicates a user is trying to enumerate permissions in the
    account (and it breaks the baseline established for them).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: There are many GuardDuty finding types that are very simple and are meant to
    catch low-hanging-fruit from attackers. These types of findings are generally
    simple or obvious enough that you shouldn't be triggering them anyway, even if
    you aren't directly thinking of them. Some of those findings include things such
    as port scanning an EC2 instance, brute-forcing a **secure shell** (**SSH**)/**remote
    desktop protocol** (**RDP**) server, or using Tor for your communications with
    AWS. In this chapter, we are going to focus on the more AWS-specific findings
    and more advanced findings, as the simple finding types are not necessarily within
    the scope of this book and they should be easy to bypass or avoid anyway.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Another important note to consider is how GuardDuty uses machine learning and
    baselines to determine if it should trigger a finding or not. If you are within
    a sandbox environment that is constantly being attacked because you are testing
    out tools and attack methods, it is possible that GuardDuty will detect this activity
    as the baseline for your account. If that is the case, then it may not trigger
    certain findings that you will expect it to because it has established that type
    of activity as normal within the environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Alerting about and reacting to GuardDuty findings
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, GuardDuty will generate findings and make them available on the
    web console. It is also possible to set up a `CloudWatch` Events rule to react
    to these findings as they come in. To do this through the AWS web console, we
    can navigate to the `CloudWatch` Events rule page and create a new rule. For this
    rule, we will select GuardDuty as the service to match, and then GuardDuty Finding
    as the event type to match. Then, we will select some sort of target to send the
    information on findings to. The target could be a variety of things, such as **simple
    notification service** (**SNS**) topic to then text or email the data of the finding
    to the security team, or possibly Lambda function, which then reacts to the finding
    type to try and automatically remediate it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d67e3d8-1d75-4177-9bc4-269b47379648.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: A new CloudWatch Events rule that targets a Lambda function
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows a `CloudWatch` Events rule being created to trigger on
    GuardDuty findings and to target the `ExampleFunction` Lambda function when it
    is triggered. This kind of rule allows you to automate alerting and/or defense
    against findings that GuardDuty is triggering.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: An example Lambda function might parse the data that `CloudWatch` Events sends
    it, determine what finding type was triggered, and then react based on that. For
    example, if GuardDuty alerted that an EC2 instance was making connections to a
    known cryptocurrency-related domain, Lambda function might auto-block outbound
    internet access to that domain in the security group that the EC2 instance lies
    within. You could also add another target to the `CloudWatch` Events rule that
    uses SNS to send a text message to your security team. This way, if cryptocurrency-related
    activity was detected, it will automatically be blocked by Lambda function and
    the security team will be alerted, where they could then decide on what steps
    they should followup with to properly secure the environment again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个Lambda函数可能会解析`CloudWatch` Events发送的数据，确定触发了什么类型的发现，然后根据此做出反应。例如，如果GuardDuty发出警报，EC2实例正在连接到已知的与加密货币相关的域，Lambda函数可能会自动阻止该域的出站互联网访问，该域位于EC2实例所在的安全组中。您还可以向`CloudWatch`
    Events规则添加另一个目标，该规则使用SNS向您的安全团队发送短信。这样，如果检测到与加密货币相关的活动，Lambda函数将自动阻止，并且安全团队将收到警报，然后他们可以决定应该采取什么步骤来适当地再次保护环境。
- en: Bypassing GuardDuty
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过GuardDuty
- en: There are many findings that GuardDuty triggers on, and with that, there are
    many ways to bypass those detections so that you do not get caught. Not everything
    can get bypassed, but as an attacker, you should at least understand what GuardDuty
    is looking for so that you can actively work to avoid or bypass it as you attack
    an environment. It is possible that just a single GuardDuty alert on your activity
    could shut down your access to the account, but it is also possible that no one
    is really paying attention to the alerts as they come in, so you won't need to
    worry as much in that situation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GuardDuty触发的发现有很多，因此有很多方法可以绕过这些检测，以便您不会被抓住。并非所有事情都可以被绕过，但作为攻击者，您至少应该了解GuardDuty正在寻找什么，以便在攻击环境时积极努力避免或绕过它。有可能您的活动只会触发一个GuardDuty警报，就会关闭您对账户的访问权限，但也有可能没有人真正关注警报的到来，所以在那种情况下您就不需要太担心。
- en: If you wanted to get really advanced with it, you could also purposely trigger
    certain GuardDuty alerts to send any listening defenders on wild goose chases,
    while you are secretly doing something else in the environment. Along with this,
    if you know that the target account is using `CloudWatch` Events to trigger on
    GuardDuty findings, you can even use the `CloudWatch` Events `PutEvents` API to
    supply completely fake GuardDuty findings that may break the target of the `CloudWatch`
    Events rule because it contains unexpected data. Also, you could send data in
    the correct format, but just with false information, as it could really confuse
    a defender and/or their automation when trying to remediate the finding.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想真的变得更加先进，您还可以故意触发某些GuardDuty警报，以便在您悄悄在环境中做其他事情的同时，让任何倾听的防御者陷入困境。此外，如果您知道目标账户正在使用`CloudWatch`
    Events来触发GuardDuty发现，您甚至可以使用`CloudWatch` Events `PutEvents` API提供完全虚假的GuardDuty发现，这可能会破坏`CloudWatch`
    Events规则的目标，因为它包含意外的数据。此外，您还可以以正确的格式发送数据，但只是带有错误的信息，这可能会让防御者和/或他们的自动化在尝试修复发现时感到困惑。
- en: Bypassing everything with force
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用强制绕过一切
- en: The first bypass we will look at is not really a bypass, but it will prevent
    GuardDuty from alerting about us. This includes either disabling monitoring for
    the GuardDuty detectors in the account or deleting them altogether. You likely
    should not use this method because of how destructive it is and how much of an
    impact it could potentially have on the environment you are attacking, but it
    is good to know it is an option. Bear in mind that this example only targets a
    single region, but it may be necessary to run these commands across every region,
    as GuardDuty must be enabled on a per-region basis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的第一个绕过方法实际上并不是一个绕过方法，但它将阻止GuardDuty对我们的警报。这包括在账户中禁用GuardDuty探测器的监控或完全删除它们。您可能不应该使用这种方法，因为它具有破坏性，并且可能对您正在攻击的环境产生重大影响，但知道这是一个选择是很好的。请记住，这个例子只针对单个区域，但可能需要在每个区域运行这些命令，因为GuardDuty必须基于每个区域启用。
- en: 'We could identify existing GuardDuty detectors with the `ListDetectors` command,
    such as in the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ListDetectors`命令识别现有的GuardDuty探测器，例如以下内容：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we find one in the current region, we could disable it by running the following
    command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在当前区域找到一个，我们可以通过运行以下命令来禁用它：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the detector in our current region will no longer monitor and report on
    any findings.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们当前区域的探测器将不再监视和报告任何发现。
- en: 'We could even take this a step further and delete the detector, rather than
    disable it. We could do this with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步删除探测器，而不是禁用它。我们可以使用以下命令来做到这一点：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that it doesn't exist, there is no way that it can be monitoring us.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它不存在了，就没有办法监视我们了。
- en: Bypassing everything with IP whitelisting
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用IP白名单绕过一切
- en: 'The best and most effective way to bypass all of GuardDuty is to just add your
    own attacker IP address to the list of trusted IP addresses in the target account.
    It is a simple process and GuardDuty doesn''t trigger anything to do with the
    enumeration or modification of GuardDuty settings, so it will likely fly under
    the radar, even in more modern, advanced environments. If we look at the Lists tab
    of GuardDuty in the AWS web console, we will see something similar to the following
    screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过GuardDuty的最佳和最有效的方法就是将您自己的攻击者IP地址添加到目标账户的受信任IP地址列表中。这是一个简单的过程，GuardDuty不会触发任何与GuardDuty设置的枚举或修改有关的内容，因此它很可能会在更现代、先进的环境中悄悄进行，甚至不会引起注意。如果我们在AWS网络控制台的Lists选项卡中查看GuardDuty，我们将看到类似以下截图的内容：
- en: '![](img/5cc880c9-d125-4dd2-bda0-897a23429f0a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cc880c9-d125-4dd2-bda0-897a23429f0a.png)'
- en: Showing GuardDuty's trusted IP lists and threat lists in the AWS web console
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS网络控制台中显示GuardDuty的受信任IP列表和威胁列表
- en: In this screenshot, we can see that there is a section for Trusted IP lists and
    Threat lists. Respectively, they are basically a way to whitelist and blacklist
    IP addresses, telling GuardDuty to either ignore findings from these IP addresses
    (whitelist) or to trigger on everything from these IP addresses (blacklist).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，我们可以看到有一个受信任的IP列表和威胁列表的部分。它们分别是白名单和黑名单IP地址的一种方式，告诉GuardDuty要么忽略这些IP地址的发现（白名单），要么对这些IP地址的一切触发警报（黑名单）。
- en: As an attacker, this is amazing. We can whitelist our own IP address without
    triggering any alerts in the process, then go nuts in the environment without
    worrying about GuardDuty from that point on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，这太棒了。我们可以在不触发任何警报的情况下将我们自己的IP地址列入白名单，然后在环境中肆无忌惮，而不用担心从那时起GuardDuty。
- en: 'There is a problem that you may encounter when trying to add yourself as a
    trusted IP and that is that there is a maximum of one trusted IP list per-region
    allowed by GuardDuty. This means that if our target is already utilizing the trusted
    IP list, we''ll have to modify our attack slightly. The first thing to do will
    be to determine whether they are, in fact, using the trusted IP list or not. Note
    that GuardDuty monitors on a per-region basis, so it may be necessary to repeat
    these steps for each GuardDuty detector in each available region. We can do this
    by running the following AWS **command-line interface** (**CLI**) command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试将自己添加为受信任的IP时，可能会遇到一个问题，即GuardDuty允许每个区域最多一个受信任的IP列表。这意味着如果我们的目标已经使用受信任的IP列表，我们将不得不稍微修改我们的攻击。首先要做的是确定他们是否实际上使用了受信任的IP列表。请注意，GuardDuty基于每个区域进行监视，因此可能需要针对每个可用区域中的每个GuardDuty检测器重复这些步骤。我们可以通过运行以下AWS命令行界面（CLI）命令来做到这一点：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should return the ID of the GuardDuty detector in the current region.
    In our example, that turns out to be `e2b19kks31n78f00931ma8b081642901`. If no
    detector IDs are returned, then that means GuardDuty is not enabled in the current
    region, which is good news if you are trying to bypass it! Then we will check
    this detector to see if there is already a trusted IP list associated with it,
    using the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回当前区域的GuardDuty检测器的ID。在我们的示例中，结果是`e2b19kks31n78f00931ma8b081642901`。如果没有返回检测器ID，那意味着GuardDuty在当前区域未启用，如果您试图绕过它，这是个好消息！然后我们将检查这个检测器，看看它是否已经有一个与之关联的受信任IP列表，使用以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If there is already a trusted IP set in place, its ID will be returned, and
    if not, an empty list will be returned. The first scenario we will look at will
    assume that they are not using a trusted IP list already. This is the best-case
    scenario for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经有一个受信任的IP集合，它的ID将被返回，如果没有，将返回一个空列表。我们将首先看一下的情况假设他们还没有使用受信任的IP列表。这对我们来说是最理想的情况。
- en: 'To start off this attack, we will need to create a text file locally on our
    computer that contains the IP address that we want to whitelist. We''ll be naming
    this the `ip-whitelist.txt` file. Then, because GuardDuty requires the file containing
    the IP whitelist to be hosted in S3, we will upload this file to an S3 bucket
    within our own attack account and expose the file publicly. The reason for this
    is so that we are always in control of the whitelist that is being used and we
    could even modify it as needed during an engagement. For this example, we''ll
    say that we are using the `bucket-for-gd-whitelist` S3 bucket. First, we''ll upload
    our file to the bucket with this command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这次攻击，我们需要在我们的计算机上创建一个文本文件，其中包含我们想要列入白名单的IP地址。我们将把这个文件命名为`ip-whitelist.txt`。然后，因为GuardDuty要求包含IP白名单的文件必须托管在S3中，我们将把这个文件上传到我们自己攻击账户中的一个S3存储桶，并公开暴露这个文件。这样做的原因是我们始终控制着所使用的白名单，甚至在参与过程中可能需要修改它。在这个示例中，我们将说我们使用`bucket-for-gd-whitelist`
    S3存储桶。首先，我们将使用以下命令将我们的文件上传到存储桶中：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will want to make sure that our file is publicly readable, so that
    GuardDuty can read it as needed when it is set as the whitelist. We can do this
    with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保我们的文件是公开可读的，这样GuardDuty在设置为白名单时可以随时读取它。我们可以使用以下命令来做到这一点：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Bear in mind that the settings on the bucket itself or your account may prevent
    public objects, so if you receive an access denied message when running this command
    or it does not seem to be working, ensure that the bucket or account public access
    settings are correctly configured to allow public objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，存储桶本身或您的帐户的设置可能会阻止公共对象，因此如果在运行此命令时收到访问被拒绝的消息，或者似乎无法工作，请确保存储桶或帐户的公共访问设置已正确配置以允许公共对象。
- en: Now our file should be publicly accessible at this URL (for this example only): [https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt](https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的文件应该可以在此URL公开访问（仅供本示例使用）：[https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt](https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt)。
- en: 'Next, we will create the new trusted IP list for the GuardDuty detector we
    identified earlier with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下命令为我们之前确定的GuardDuty检测器创建新的受信任IP列表：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If this was successful, you should receive a response that includes the ID of
    the newly-created trusted IP set. Now, that's it. Your IP is in an active trusted
    IP list for GuardDuty in the current region, meaning that GuardDuty will not generate
    findings for it (from the GuardDuty Lists page).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一步成功，你应该会收到一个包含新创建的受信任IP集合ID的响应。现在就是这样。你的IP地址已经在当前区域的GuardDuty的受信任IP列表中，这意味着GuardDuty不会为它生成发现（从GuardDuty列表页面）。
- en: 'As you may have guessed, there''s a Pacu module to automate this process. From
    Pacu, we can use the `guardduty__whitelist_ip` module to do this across every
    region. We can use the following command to do so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，Pacu有一个模块可以自动化这个过程。从Pacu，我们可以使用`guardduty__whitelist_ip`模块在每个区域执行此操作。我们可以使用以下命令来做到这一点：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When that is complete, Pacu will have whitelisted your IP address in GuardDuty
    across every AWS region.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Pacu将在每个AWS区域中将您的IP地址列入GuardDuty的白名单。
- en: Now we are going to look at a scenario where the target AWS account already
    has a GuardDuty trusted IP list setup. We can't just add another list, because
    there is a maximum of one trusted IP list per GuardDuty detector. There are a
    couple different ways we could handle this. After we run the `ListIPSets` command
    and see that there is, in fact, a trusted IP list set up, we could just go ahead
    and delete the existing IP set, then implement one that whitelists our own IP.
    If you are using Pacu, and Pacu detects an existing trusted IP set, it will prompt
    you to delete it and create your own or skip that detector. The only problem with
    this is that deleting an existing trusted IP whitelist may have unintended consequences
    in the environment, which means we might draw more attention to ourselves than
    necessary when trying to stay stealthy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一个场景，目标AWS账户已经设置了GuardDuty的信任IP列表。我们不能只是添加另一个列表，因为每个GuardDuty检测器最多只能有一个信任的IP列表。我们可以用几种不同的方式来处理这个问题。在运行`ListIPSets`命令并看到确实设置了信任的IP列表之后，我们可以直接删除现有的IP集，然后实施一个将我们自己的IP列入白名单的IP集。如果您使用Pacu，并且Pacu检测到已经存在的信任IP集，它将提示您删除它并创建您自己的IP集，或者跳过该检测器。唯一的问题是，删除现有的信任IP白名单可能会在环境中产生意想不到的后果，这意味着在试图保持隐蔽时，我们可能会引起比必要更多的注意。
- en: 'Another option we have is to update the current trusted IP list to include
    our own IP, as well as all the IPs that were there originally. To do this, let''s
    take the IP set ID that we collected from the `ListIPSets` API call and run the
    `GetIPSet` command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个选择，即将当前的信任IP列表更新为包括我们自己的IP，以及原来存在的所有IP。为了做到这一点，让我们从`ListIPSets` API调用中收集到的IP集ID，并运行`GetIPSet`命令：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run that command on the trusted IP list we just created earlier in this
    section, the output will look like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在本节早些时候创建的信任IP列表上运行该命令，输出将如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll consider this trusted IP list as one we haven't seen before (even though
    we set it up ourselves). What we will want to do is to visit the URL and download
    the current list, then we will modify the list to include our own attacker IP
    address. Once that is done, we will go through the same process as earlier, where
    we upload this file to our own personal S3 bucket and make the file publicly readable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个信任的IP列表视为我们以前没有见过的列表（尽管我们自己设置了它）。我们需要做的是访问URL并下载当前的列表，然后修改列表以包括我们自己的攻击者IP地址。完成后，我们将按照之前的过程，将这个文件上传到我们自己的个人S3存储桶，并使文件公开可读。
- en: 'Once that is done, we will then use the `UpdateIPSet` API instead of the `CreateIPSet`
    API like we did earlier. We can update the existing trusted IP list with our new
    one with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将使用`UpdateIPSet` API而不是之前使用的`CreateIPSet` API。我们可以使用以下命令更新现有的信任IP列表为我们的新列表：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we will have updated the trusted IP list with our own IP address without
    removing any IPs that were already whitelisted, thus not creating any ruckus in
    the environment that might get us noted.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经用我们自己的IP地址更新了信任的IP列表，而不会删除任何已经列入白名单的IP，因此不会在环境中引起任何骚动，可能会引起注意。
- en: As a responsible (and smart) attacker, there is one more step we must follow.
    That step is at the very end of the AWS engagement/penetration test/attack, where
    we restore the original whitelist, so that the configuration doesn't look strange
    when viewing it, and our IP is no longer stored in a list they have access to.
    To do this, we should save the URL that was originally associated with the trusted
    IP list until the end of the engagement, and then use the `UpdateIPSet` API again
    to restore it back to that URL. By doing this, our IP is whitelisted with GuardDuty
    for the duration of the engagement, then we leave the environment when are done
    without any major modifications to the resources in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个负责任的（聪明的）攻击者，我们还需要跟进一步。这一步是在AWS的参与/渗透测试/攻击的最后，我们恢复原始的白名单，这样在查看时配置看起来不会很奇怪，我们的IP也不再存储在他们可以访问的列表中。为了做到这一点，我们应该保存最初与信任的IP列表相关联的URL，直到参与结束，然后再次使用`UpdateIPSet`
    API将其恢复到该URL。通过这样做，我们的IP在参与期间被GuardDuty列入白名单，然后在完成后离开环境，而不对其中的资源进行任何重大修改。
- en: One more important note is that if the account you are attacking has GuardDuty
    controlled by another external master account, you will not be able to modify
    the trusted IP list settings. Only the master account can do that when managing
    the GuardDuty cross-account. When a master account uploads a trusted IP list,
    this list is then applied to all GuardDuty members that belong to that master,
    which is amazing for an attacker who has compromised a GuardDuty master account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，如果您攻击的账户有另一个外部主账户控制的GuardDuty，您将无法修改信任的IP列表设置。只有主账户在管理GuardDuty跨账户时才能做到这一点。当主账户上传信任的IP列表时，这个列表将被应用到属于该主账户的所有GuardDuty成员身上，这对于已经攻破了GuardDuty主账户的攻击者来说是很棒的。
- en: Bypassing EC2 instance credential exfiltration alerts
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过EC2实例凭据外泄警报
- en: 'This section is going to focus on a single GuardDuty finding type: `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`.
    The AWS documentation describes that this finding will be triggered when credentials
    that were created exclusively for an EC2 instance through an instance launch role
    are being used from an external IP address ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)).
    Basically, when an EC2 instance is launched and an IAM instance profile is attached
    to it, GuardDuty expects the credentials for that role to only ever be used within
    that single instance, or at least that''s what it makes it sound like, but we''ll
    get into that soon.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注单个GuardDuty发现类型：`UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`。AWS文档描述了当专门为EC2实例通过实例启动角色创建的凭据从外部IP地址使用时，将触发此发现（[https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)）。基本上，当启动EC2实例并附加IAM实例配置文件时，GuardDuty期望该角色的凭据只能在该单个实例中使用，或者至少是这样的，但我们很快就会讨论这个问题。
- en: The reason this finding gets its own section in this chapter is because of how
    common the scenarios where you have the possibility to trigger it come up in AWS
    engagements. The most common way to gather these credentials that we have found
    during penetration tests is by gaining server-side request forgery on an EC2 instance
    that has an IAM instance profile attached. You can then make an HTTP request to
    the EC2 metadata URL ([http://169.254.169.254/](http://169.254.169.254/)) and
    request those credentials. In this scenario, you don't have command execution
    on the server, so you are required to exfiltrate the credentials that you acquire
    to use them. This is where the GuardDuty finding steps in and identifies that
    the EC2 instance credentials are coming from an external IP address.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发现之所以在本章中有自己的部分，是因为在AWS的参与中，出现了有可能触发它的情况非常普遍。我们在渗透测试中发现的获取这些凭据的最常见方法是在具有IAM实例配置文件的EC2实例上获得服务器端请求伪造。然后，您可以向EC2元数据URL（[http://169.254.169.254/](http://169.254.169.254/)）发出HTTP请求并请求这些凭据。在这种情况下，您无法在服务器上执行命令，因此需要将获取的凭据外泄以使用它们。这就是GuardDuty发现介入并识别EC2实例凭据来自外部IP地址的地方。
- en: Although this GuardDuty finding is one of the most common ones to encounter
    when attacking an environment, it is also one of the easiest to completely bypass.
    The important thing to note is that when the documentation says, "*are being used
    from* *an external IP address,"* it refers to an IP address that is external to
    all of EC2 and does not mean external to the EC2 instance that the IAM instance
    profile is attached to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个GuardDuty发现是在攻击环境中遇到的最常见的之一，但它也是最容易完全绕过的之一。需要注意的重要事情是，当文档说，“*正在使用* *外部IP地址时，”它指的是一个对所有EC2都是外部的IP地址，并不是指EC2实例附加的IAM实例配置文件外部的IP地址。
- en: Given that information, the bypass is simple. All we need to do is launch an
    EC2 instance in our own attacker account (in the same region as the server we
    SSRF'd if we know it, so that the source IP is within the regions range), configure
    the credentials with the AWS CLI, Pacu, and so on, and get hacking. For Pacu,
    you will just need to run the `set_keys` command and input the access key ID,
    secret access key, and session token that you stole from the target EC2 instance
    and then you will be able to run any module or API command without worrying about
    the GuardDuty `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` alert.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些信息，绕过很简单。我们只需要在我们自己的攻击者帐户中启动一个EC2实例（如果我们知道的话，可以在与我们SSRF的服务器相同的区域中启动，以便源IP在区域范围内），使用AWS
    CLI，Pacu等配置凭据，然后开始入侵。对于Pacu，您只需要运行`set_keys`命令，并输入从目标EC2实例窃取的访问密钥ID，秘密访问密钥和会话令牌，然后您就可以运行任何模块或API命令，而不必担心GuardDuty
    `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`警报。
- en: 'To start this EC2 instance in our own account running Ubuntu Server 18.04 LTS,
    we can run the following command, after replacing `<your ec2 ssh key name>` with
    the name of an SSH key that you created in AWS EC2 (you will need to modify the
    image ID and region parameter values to run this command in a region other than
    `us-east-1`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们自己的帐户中启动此EC2实例，运行Ubuntu Server 18.04 LTS，我们可以运行以下命令，然后用您在AWS EC2中创建的SSH密钥的名称替换`<your
    ec2 ssh key name>`（您需要修改镜像ID和区域参数值以在`us-east-1`以外的区域运行此命令）：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `userdata.txt` file should contain the following contents, which will install
    `Python3`, `Pip3`, `Git`, the AWS CLI, and `Pacu`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`userdata.txt`文件应包含以下内容，将安装`Python3`，`Pip3`，`Git`，AWS CLI和`Pacu`：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the instance is launched, you can then SSH into it with the SSH key you
    provided on the command line. Then, we can run the following commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 启动实例后，您可以使用在命令行中提供的SSH密钥进行SSH连接。然后，我们可以运行以下命令：
- en: '`sudo su`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo su`'
- en: '`cd /root/pacu`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd /root/pacu`'
- en: '`python3 pacu.py`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`python3 pacu.py`
- en: '`set_keys`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_keys`'
- en: At this point, you will be prompted to input your role's credentials into Pacu
    so that you can get started. If the `/root/pacu` folder does not exist when you
    try to change directories to it, it is possible the instance is still installing
    the various software defined in the user data script. Wait a minute or two and
    check again. If it still doesn't show up, review the contents of the file at `/var/log/cloud-init-output.log` and
    see if there were any errors that occurred during the installation of any of the
    preceding software, or if it is still running.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您将被提示将您的角色凭据输入Pacu，以便您可以开始。如果在尝试更改目录到`/root/pacu`时不存在该文件夹，则可能实例仍在安装用户数据脚本中定义的各种软件。等一两分钟然后再次检查。如果仍然没有显示，请查看`/var/log/cloud-init-output.log`文件的内容，看看在安装任何前述软件期间是否有任何错误，或者它是否仍在运行。
- en: Now, as long as you stay within this instance you don't need to worry about
    the GuardDuty finding being alerted about, but if you move to outside of the EC2
    IP range, it will likely trigger on your first API call.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要您留在这个实例内部，您就不需要担心GuardDuty发现的警报，但是如果您移动到EC2 IP范围之外，很可能会在您的第一个API调用时触发警报。
- en: Another important point to make is that the `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` GuardDuty
    alert only targets EC2 instances in your account. This means that if you happen
    to gain access to credentials through a server hosted by some other AWS service,
    this GuardDuty alert is not paying attention to what you do with those credentials.
    This means that if you happen to gain remote code execution on a Lambda function
    and you steal the credentials from the environment variables, you can exfiltrate
    those to any system and use them without worrying about getting detected by this
    particular GuardDuty finding type. The same goes for AWS Glue development endpoints;
    if you steal credentials from the metadata API of a Glue development endpoint,
    you can exfiltrate them anywhere without worry, as GuardDuty is not tracking them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的观点是，`UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` GuardDuty警报只针对您账户中的EC2实例。这意味着，如果您通过某些其他AWS服务托管的服务器获得了凭据，这个GuardDuty警报不会关注您对这些凭据的使用。这意味着，如果您在Lambda函数上获得了远程代码执行，并从环境变量中窃取了凭据，您可以将其转移到任何系统并使用，而不用担心被这种特定的GuardDuty发现类型检测到。对于AWS
    Glue开发端点也是一样；如果您从Glue开发端点的元数据API中窃取了凭据，您可以将其转移到任何地方而不用担心，因为GuardDuty不会追踪它们。
- en: Glue is an interesting example because development endpoints basically seem
    to be EC2 instances launched in someone else's account (owned by AWS themselves),
    with some modifications, of course. That means that credential exfiltration from
    a Glue development endpoint might actually trigger a GuardDuty alert in the AWS-owned
    AWS account that it was actually launched in, but that doesn't matter to us attackers
    because our target will not have this information themselves.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Glue是一个有趣的例子，因为开发端点基本上似乎是在别人的账户中启动的EC2实例（由AWS自己拥有），当然有一些修改。这意味着从Glue开发端点中窃取凭据实际上可能会触发AWS自己拥有的AWS账户中的GuardDuty警报，但这对我们攻击者来说并不重要，因为我们的目标不会拥有这些信息。
- en: Bypassing operating system (PenTest) alerts
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绕过操作系统（渗透测试）警报
- en: There are three GuardDuty alerts under the `PenTest` category of findings types.
    These findings are `PenTest:IAMUser/KaliLinux`, `PenTest:IAMUser/ParrotLinux`,
    and `PenTest:IAMUser/PentooLinux`, which alert when AWS API calls are made from
    a Kali Linux server, Parrot Linux server, or Pentoo Linux server, respectively.
    These are rather simple to bypass, as long as you know what is causing them to
    get detected.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PenTest`发现类型的GuardDuty警报下有三个警报。这些发现是`PenTest:IAMUser/KaliLinux`、`PenTest:IAMUser/ParrotLinux`和`PenTest:IAMUser/PentooLinux`，当从Kali
    Linux服务器、Parrot Linux服务器或Pentoo Linux服务器发出AWS API调用时会触发警报。只要您知道是什么导致了这些警报被检测到，就很容易绕过它们。
- en: Regardless of the client you are using to interact with the API, whether that
    is one of the SDKs from the various languages that are supported (such as Java,
    Python, or Node.js), the AWS CLI (which uses Python behind the scenes), the AWS
    web console, or just raw HTTP requests, you will always have a user agent that
    describes your operating system and version, along with other software and their
    versions that are in use when making the request. This user agent string is then
    logged by CloudTrail, like we saw in [Chapter 15](88017977-3b7b-4e4f-b4fe-60fa603200f3.xhtml),
    *Pentesting CloudTrial*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用什么客户端与API交互，无论是来自受支持的各种语言的SDK（如Java、Python或Node.js），AWS CLI（在后台使用Python），AWS
    web控制台，还是原始的HTTP请求，您都将始终有一个用户代理来描述您的操作系统和版本，以及在进行请求时使用的其他软件及其版本。然后，CloudTrail会记录这个用户代理字符串，就像我们在[第15章](88017977-3b7b-4e4f-b4fe-60fa603200f3.xhtml)中看到的那样，*渗透测试CloudTrial*。
- en: 'Here''s an example user agent that is sent when using the AWS CLI on Kali Linux:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali Linux上使用AWS CLI时发送的示例用户代理如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This user agent tells us a few things:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户代理告诉我们一些事情：
- en: The AWS CLI, version 1.16.89, was used to make the request.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CLI，版本为1.16.89，进行了请求。
- en: The AWS CLI is using Python version 3.6.8 behind the scenes.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI在后台使用Python版本3.6.8。
- en: The operating system is Kali Linux with a kernel version of 4.19.0, running
    AMD 64.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统是带有4.19.0内核版本的Kali Linux，运行在AMD 64上。
- en: Python is using version 1.12.79 of the `botocore` library.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python正在使用`botocore`库的1.12.79版本。
- en: 'Here''s an example user agent that is sent when using the AWS CLI on Parrot
    Linux:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Parrot Linux上使用AWS CLI时发送的示例用户代理如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This user agent tells us a few things:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户代理告诉我们一些事情：
- en: The AWS CLI, version 1.16.93, was used to make the request.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CLI，版本为1.16.93，进行了请求。
- en: The AWS CLI is using Python version 3.6.8 behind the scenes.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI在后台使用Python版本3.6.8。
- en: The operating system is Parrot Linux with a kernel version of 4.19.0, running
    AMD 64.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统是带有4.19.0内核版本的Parrot Linux，运行在AMD 64上。
- en: Python is using version 1.12.83 of the `botocore` library.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python正在使用`botocore`库的1.12.83版本。
- en: 'An example user agent that is sent when using the AWS CLI on Pentoo Linux can
    be seen as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pentoo Linux上使用AWS CLI时发送的示例用户代理如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This user agent tells us a few things:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户代理告诉我们一些事情：
- en: The AWS CLI, version 1.16.93, was used to make the request.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CLI，版本为1.16.93，进行了请求。
- en: The AWS CLI is using Python version 2.7.14 behind the scenes.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI在后台使用Python版本2.7.14。
- en: The operating system is Pentoo Linux with a kernel version of 4.17.11.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统是带有4.17.11内核版本的Pentoo Linux。
- en: Python is using version 1.12.83 of the `botocore` library.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python正在使用`botocore`库的1.12.83版本。
- en: 'When using the AWS web console, most CloudTrail logs will use the following
    user agent:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AWS web控制台时，大多数CloudTrail日志将使用以下用户代理：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This user agent tells us that the user is logged into the AWS web console, rather
    than using another method of interacting with the API.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户代理告诉我们用户是登录到AWS web控制台，而不是使用其他与API交互的方法。
- en: For the Kali, Parrot, and Pentoo Linux user agents, we can see that they all
    contain their respective operating system names (`kali`, `parrot`, `pentoo`).
    This is essentially all that GuardDuty is looking for to identify the use of these
    operating systems, when reporting on the `PenTest` finding types that it offers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'To get your own user agent, you can make any AWS request to the API that will
    get logged in CloudTrail, then you can view the details of that CloudTrail event
    to see what user agent was logged. If you are using the Python `boto3` library
    to interact with the AWS API, you can use the following line of code to print
    out what your user agent is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To avoid these GuardDuty checks, even if we are using Kali Linux, Parrot Linux,
    or Pentoo Linux, we simply need to modify the user agent we are using before we
    make requests to the AWS API. As long as GuardDuty doesn't detect `kali`, `parrot`,
    or `pentoo` in our user agent, then we are alright.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows a small example of how we might detect any of
    these operating systems, how to change the user agent in that scenario, and then
    how to successfully make a request with a modified user agent. This code is following
    the same Python 3 with `boto3` pattern that we have followed throughout the book:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Essentially, all this code is doing is checking whether `kali`, `parrot`, or
    `pentoo` are in the user agent string of our client, and if so, changing that
    to a known, safe user agent. This modification to our request will allow us to
    completely bypass the PenTest/user agent checks that GuardDuty makes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Although it was this easy to bypass these GuardDuty checks with the `boto3`
    library directly, it is a bit trickier (though, not impossible) when working with
    the AWS CLI. You will also need to add this code to any other piece of software
    that you are using, in order to ensure that you are never detected during your
    attack; however, luckily, Pacu takes this into consideration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: When launching Pacu (`python3 pacu.py`), this check for Kali, Parrot, and Pentoo
    Linux is performed for you automatically. If Pacu detects that you are running
    any of those operating systems, then it will automatically select a known safe
    user agent from a list it stores locally, and it will use this new user agent
    for any and all AWS requests that Pacu makes. This check will apply to the entire
    Pacu session that is created, so you will only see the warning that the change
    was made when you create your Pacu session. If you move that session to another
    computer, it will keep the user agent it chose originally, so all requests show
    up as consistent in CloudTrail.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'On Pacu''s startup, when you create a new session on one of the three operating
    systems we have been looking at, you will see something like the following message:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42d02d1d-c7d8-48e1-aa21-2cd0dbf870a6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Built-in GuardDuty defense in Pacu
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Now, anyone who inspects the CloudTrail logs will see that we are using Windows
    10, not Kali Linux. That means GuardDuty will see the same thing and not trigger
    any of those findings on us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Although these findings are listed under the `PenTest` GuardDuty category, which
    doesn't necessarily sound malicious, these checks are some of the most important
    ones we can work to bypass. This is because the use of any of these three operating
    systems will look highly suspicious to a defender who knows that they are not
    normally (or ever) used in their environment, which means our attack will likely
    be investigated and stopped within a short time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When modifying our user agent in situations like this, it might not always make
    sense to use a seemingly random user agent as our replacement. Let's say that
    we compromised an account that strictly uses the AWS Java SDK for their API calls,
    but we compromise a user and change our user agent to reflect that we are using
    the Python `boto3` library. This will look suspicious to any defender paying attention
    to this kind of thing. This type of detection is highly unreliable due to the
    user agent being in control of the user, so it probably will not be something
    that you encounter often, but it might be smart to pay attention anyway.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下修改我们的用户代理时，可能并不总是有意义使用一个看似随机的用户代理作为我们的替代。比如说，我们妥协了一个严格使用AWS Java SDK进行API调用的帐户，但我们妥协了一个用户并更改了我们的用户代理以反映我们使用Python
    `boto3`库。这将引起任何留意这种事情的防御者的怀疑。由于用户代理由用户控制，这种类型的检测非常不可靠，所以你可能不经常遇到，但还是值得注意。
- en: To beat any user agent detection, we could potentially review the CloudTrail
    logs of our target account to find the previous API calls that were made from
    the user that we compromised. Then, we could copy that user agent and use it as
    our own, killing two birds with one stone. We will hide the fact that we are on
    Kali, Parrot, or Pentoo Linux, and we will fit into the norm of the environment
    by using a user agent that has been seen before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了击败任何用户代理检测，我们可能需要审查目标帐户的CloudTrail日志，以找到我们已经妥协的用户之前进行的API调用。然后，我们可以复制该用户代理并将其用作我们自己的，一举两得。我们将隐藏我们使用Kali、Parrot或Pentoo
    Linux的事实，并通过使用以前见过的用户代理来适应环境的规范。
- en: Other simple bypasses
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他简单的规避方法
- en: Similarly to what we have previously discussed, there are many different things
    that GuardDuty checks for, so each one might require its own individual bypass.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的类似，GuardDuty检查了许多不同的事情，因此每一种可能都需要其自己的规避方法。
- en: 'The simplest rules we can follow to bypass the `low-hanging-fruit` checks include
    the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循的最简单的规则来规避`low-hanging-fruit` 检查包括以下内容：
- en: Don't use the Tor network to communicate with AWS
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用Tor网络与AWS通信
- en: Don't port scan from or to an EC2 instance
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从EC2实例扫描端口
- en: Don't brute-force SSH/RDP servers
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴力破解SSH/RDP服务器
- en: Don't communicate with known bad networks, hosts, or IPs
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要与已知的恶意网络、主机或IP通信
- en: There are some others that we should keep in mind, though.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的事情我们应该记住。
- en: Cryptocurrency
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币
- en: If we want to mine cryptocurrency (which you should never do during a legitimate
    PenTest), we will want to look at the `CryptoCurrency:EC2/BitcoinTool.B!DNS` and
    `CryptoCurrency:EC2/BitcoinTool.B` GuardDuty alerts. These alerts trigger on network
    activity that are associated with domains and IP addresses that are known to be
    associated with cryptocurrency-related activity ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html)).
    This means that we can bypass this by avoiding direct connections to known cryptocurrency-related
    domains and IP addresses, such as exchanges and mining pools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要挖掘加密货币（在合法的渗透测试期间绝对不应该这样做），我们将要查看`CryptoCurrency:EC2/BitcoinTool.B!DNS` 和`CryptoCurrency:EC2/BitcoinTool.B` GuardDuty警报。这些警报会触发与已知与加密货币相关的活动相关的域名和IP地址的网络活动（[https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html)）。这意味着我们可以通过避免直接连接到已知的与加密货币相关的域名和IP地址，如交易所和矿池，来规避这一点。
- en: Behavior
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为
- en: Bypassing the GuardDuty Behavior checks can also be rather simple.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 规避GuardDuty行为检查也可能非常简单。
- en: To bypass the `Behavior:EC2/NetworkPortUnusual` finding, which triggers when
    an EC2 instance is communicating with a remote host on an unusual port, we will
    just need to ensure that any malware command and control we are doing is using
    a common port, such as `80` (HTTP) or `443` (HTTPS), rather than some random high-numbered
    port.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要规避`Behavior:EC2/NetworkPortUnusual` 发现，当EC2实例与不寻常端口上的远程主机通信时触发，我们只需要确保我们正在执行的任何恶意软件命令和控制使用常见端口，如`80`（HTTP）或`443`（HTTPS），而不是一些随机的高端口。
- en: The `Behavior:EC2/TrafficVolumeUnusual` GuardDuty finding triggers when there
    is an unusually large amount of network traffic being sent to a remote host. As
    a defender, this could be an indication of data exfiltration from within your
    internal network. As an attacker, we could bypass this finding when exfiltrating
    data by limiting our outbound bandwidth, so that there never is a high volume
    of traffic happening at once. Instead, there will be a small amount of traffic
    volume over an extended period of time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Behavior:EC2/TrafficVolumeUnusual` GuardDuty发现在向远程主机发送异常大量网络流量时触发。作为防御者，这可能表明内部网络中存在数据外泄的迹象。作为攻击者，我们可以通过限制出站带宽来规避这一发现，以便一次性发生的流量量不会很大。相反，会在较长时间内发生少量的流量。'
- en: ResourceConsumption
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResourceConsumption
- en: The `ResourceConsumption:IAMUser/ComputeResources` GuardDuty finding triggers
    when an API is detected that aims to launch computer resources into the account
    (EC2). We could bypass this finding type by avoiding the usage of the `RunInstances`
    EC2 API within a region monitored by GuardDuty. If every region is not being monitored,
    we could just launch our EC2 instances in an unmonitored region; however, if every
    region is being monitored, then we could bypass this by just completely avoiding
    the API call or by using another AWS service to launch the servers that we need.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceConsumption:IAMUser/ComputeResources` GuardDuty发现在检测到旨在将计算资源（EC2）启动到帐户中的API时触发。我们可以通过避免在GuardDuty监控的区域使用`RunInstances`
    EC2 API来规避这一发现类型。如果每个区域都没有被监控，我们可以在未被监控的区域启动我们的EC2实例；然而，如果每个区域都被监控，那么我们可以通过完全避免API调用或使用其他AWS服务来启动我们需要的服务器来规避这一点。'
- en: We could do this by using one of the many services within AWS that also launch
    servers, some of which include **Lightsail** instances, Glue development endpoints,
    or **AppStream** instances. In these cases, we will still have servers launched
    within the target account, but they won't be detected by GuardDuty because we've
    avoided the `RunInstances` EC2 API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用AWS内的许多服务之一来做到这一点，这些服务也会启动服务器，其中一些包括**Lightsail**实例、Glue开发端点或**AppStream**实例。在这些情况下，我们仍然会在目标账户内启动服务器，但它们不会被GuardDuty检测到，因为我们已经避免了`RunInstances`
    EC2 API。
- en: Stealth
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐蔽
- en: 'We have already covered the two CloudTrail-related GuardDuty finding types,
    but there is also a third one under the **s****tealth** category: `Stealth:IAMUser/PasswordPolicyChange`.
    This will trigger when an accounts password policy is weakened, such as if the
    minimum password length changes from 15 characters to 8 characters. To avoid this
    finding, we simply should not touch the password strength requirements within
    an account that we are attacking.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了GuardDuty发现类型中与CloudTrail相关的两种，但在**隐蔽**类别下还有第三种：`Stealth:IAMUser/PasswordPolicyChange`。当账户的密码策略被削弱时，比如最小密码长度从15个字符变为8个字符时，就会触发这个发现。为了避免这种情况，我们简单地不应该触碰我们正在攻击的账户内的密码强度要求。
- en: Trojan
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特洛伊木马
- en: Most of the findings within the Trojan category of GuardDuty can be avoided
    by never communicating with known bad IP addresses and domains, which is easy
    to do. However, one finding, `Trojan:EC2/DNSDataExfiltration`, is a bit different.
    This finding triggers when an EC2 instance is discovered to be exfiltrating data
    through DNS queries. To avoid this, we can simply decide against the method of
    DNS data exfiltration when within a compromised EC2 instance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GuardDuty的特洛伊木马类别中的大多数发现可以通过永远不与已知的恶意IP地址和域通信来避免，这很容易做到。然而，有一个发现，`Trojan:EC2/DNSDataExfiltration`，有点不同。当发现EC2实例通过DNS查询外泄数据时，就会触发这个发现。为了避免这种情况，我们可以简单地决定不在受损的EC2实例内使用DNS数据外泄的方法。
- en: Also, as discussed previously, GuardDuty can only read DNS logs for DNS requests
    that use the AWS DNS servers. It might be possible to customize your malware to
    use alternate DNS resolvers (other than the EC2 default of AWS DNS) for your DNS
    exfiltration, which will completely bypass GuardDuty, because the traffic will
    never be seen by it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如之前讨论的，GuardDuty只能读取使用AWS DNS服务器的DNS请求的DNS日志。可能可以定制你的恶意软件使用替代DNS解析器（而不是AWS
    DNS的EC2默认值）进行DNS外泄，这将完全绕过GuardDuty，因为它永远不会看到这些流量。
- en: Others
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他
- en: There are other GuardDuty finding categories that we did not discuss, and that
    is because they are generally more difficult to bypass and require a situation-specific
    attack, or they are wrapped into another topic we have discussed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他GuardDuty发现类别我们没有讨论，这是因为它们通常更难绕过，需要特定情况下的攻击，或者它们被包含在我们已经讨论过的另一个主题中。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: GuardDuty, in its current state, is in its early stages and looks for a lot
    of low-hanging fruit to detect malicious activity in an environment. Many of these
    checks (and sometimes all of them) are simple to bypass and/or avoid during the
    attack process against an AWS environment. Although this chapter tried to cover
    all of what is known about GuardDuty right now, the service is being slowly updated
    and improved on as time goes by. This is especially because of the machine learning
    involved in its detection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，GuardDuty处于早期阶段，并且在环境中检测恶意活动时寻找很多低 hanging fruit。这些检查中的许多（有时甚至全部）都很容易在攻击AWS环境的过程中绕过和/或避免。尽管本章试图涵盖目前对GuardDuty的所有了解，但随着时间的推移，该服务正在慢慢更新和改进。这主要是因为其中涉及到机器学习。
- en: Because of where GuardDuty is at, it likely is not a great catch-all solution,
    so when you are attacking an AWS environment, it is important to keep in mind
    that it might not be the only thing that is watching you. Even if you are attacking
    an environment with GuardDuty alongside another monitoring tool, it will still
    be useful and practical to try and bypass GuardDuty as much as possible, so that
    you aren't caught because of some low-hanging fruit, or you are caught because
    of a much more advanced monitoring setup within the environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GuardDuty的位置，它可能不是一个很好的应对一切的解决方案，所以当你攻击AWS环境时，重要的是要记住它可能不是唯一监视你的东西。即使你在攻击一个有GuardDuty和另一个监控工具的环境，尽量绕过GuardDuty仍然是有用和实际的，这样你就不会因为一些低
    hanging fruit 而被抓住，或者因为环境中更先进的监控设置而被抓住。

- en: Using Pacu for AWS Pentesting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have used Pacu throughout this book, this chapter will take the
    approach of discussing Pacu from the ground up. Ideally, at the end of this chapter,
    you should understand and be able to utilize the majority of Pacu's offered functionality.
    That means that you'll be able to take advantage of some of the more advanced
    features of Pacu and can contribute your own modules and research to the project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll dive deeper into the AWS exploitation toolkit, Pacu,
    where we will develop an understanding of the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What Pacu is, why it is important, and how to set it up
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands that are offered by Pacu and how we can use them for our benefit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can automate our own tasks and add them to Pacu as a module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short introduction into PacuProxy and its purpose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything in the pentesting field, it is helpful to automate things as much
    as possible, where possible. This allows us to perform attacks and enumeration
    of an environment without requiring the manual work of running multiple AWS **command-line
    interface** (**CLI**) commands over and over again across different environments.
    This kind of toolage allows us to save time, allowing us more time to spend on
    the manual aspect of our testing process. Sometimes these tools are involved and
    complicated though, and a thorough understanding of the tool and its target are
    required to utilize it to its full potential. That's why this chapter was written,
    to help you get a better understanding of what Pacu has to offer and how you can
    best take advantage of those offerings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Pacu history
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start from the very beginning, Pacu is an offensive AWS exploitation framework,
    written by a small group of developers and researchers at Rhino Security Labs.
    Open source and available on GitHub under the BSD-3 license ([https://github.com/RhinoSecurityLabs/pacu](https://github.com/RhinoSecurityLabs/pacu)),
    Pacu and its modules are written in Python 3.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The original idea for Pacu was born out of an accumulation of research within
    Rhino's penetration testing team. It was found that more and more clients are
    using cloud server providers, such as AWS, and that there were a lot of unexplored
    areas that seemed ripe for exploitation. As ideas, attack vectors, and scripts
    piled up within the Rhino team, it became clear that some sort of framework was
    required to aggregate all of this research and make it easy to work with. Being
    penetration testers, it was also decided that it should be able to handle projects
    and pentests well, even if separate ones are being worked on simultaneously.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: After an internal proposal and prototype of the proposed project, Pacu was accepted
    and the team began the process that resulted in what Pacu is today. To mirror
    similar projects and to ensure Pacu stays up to date with the evolving services
    of AWS and associated attack vectors, Pacu was developed with extensibility in
    mind. This was to allow for easy, external contribution to the project, as well
    as a simple, managed infrastructure that handled problems and allowed for easy
    solutions to those problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Pacu
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that is needed when setting up Pacu is to ensure that Git,
    Python 3, and Pip 3 are installed. When that''s done, you can follow a simple
    three-step process to get Pacu installed and running. From the CLI of your operating
    system (we are using Kali Linux), run the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that Pacu is not officially supported for Windows operating systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Now Pacu should start up and go through the process of configuration and database
    creation. It should first tell you that it created a new `settings.py` file, followed
    by a message that it created a new local database file. Finally, it will ask you
    for a name for your new Pacu session. In this example, we named the session `ExampleSession`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f8f0c4-6a29-47af-bf15-92b8ef57e024.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Pacu being started for the first time on Kali Linux
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Now our new session is created; `session` within Pacu is essentially a way to
    isolate data, activity, and credentials between different projects that you are
    working on. Pacu uses a local SQLite database to manage sessions and the data
    within them, and it allows the creation of any number of sessions. As a pentester,
    sessions can be thought of as engagements or companies, in the sense that you
    can be working on two different AWS pentests at once, so you will need two Pacu
    sessions to separate the two. Each Pacu session will then hold all the data, activity,
    and credentials that belong to that specific engagement or company. This allows
    you to work with the same data across multiple different uses of Pacu, requiring
    fewer API calls to the AWS API, meaning you are that much more hidden in the logs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了新的会话；Pacu中的`session`本质上是一种在您正在进行的不同项目之间隔离数据、活动和凭据的方式。Pacu使用本地SQLite数据库来管理会话和其中的数据，并允许创建任意数量的会话。作为渗透测试人员，会话可以被视为参与或公司，因为您可以同时在两个不同的AWS渗透测试中工作，因此您需要两个Pacu会话来分隔这两个。然后，每个Pacu会话将保存属于该特定参与或公司的所有数据、活动和凭据。这使您可以在Pacu的多个不同用途中使用相同的数据，需要更少的API调用到AWS
    API，这意味着您在日志中更隐蔽。
- en: The `SQLAlchemy` Python library is used to manage interaction between Pacu and
    the database, but we will jump into that later on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`SQLAlchemy` Python库用于管理Pacu与数据库之间的交互，但我们稍后会详细介绍。'
- en: The next thing you should see is a large output of help information from Pacu
    that explains the different commands and abilities that Pacu has enabled. We'll
    skip that for now and come back to it later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该会看到Pacu输出了大量的帮助信息，解释了Pacu具有的不同命令和功能。我们现在将跳过这一部分，稍后再回来。
- en: 'After that, if you are running Kali Linux like we are, you should see a message
    that is similar to the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果你像我们一样在运行Kali Linux，你应该会看到类似以下的消息：
- en: '![](img/a04cee23-563a-4bf9-be70-84f20df56a59.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a04cee23-563a-4bf9-be70-84f20df56a59.png)'
- en: Built-in GuardDuty defense in Pacu
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu中的内置GuardDuty防御
- en: Just as we discussed in [Chapter 16](14f5f864-8cf1-4232-86f5-8d0fa4ec28e4.xhtml),
    *GuardDuty*, this message is shown because Pacu detects that it is running on
    a Kali Linux host. GuardDuty can detect when AWS API calls are made from a Kali
    Linux server, and flags an alert based on that, so Pacu automatically resolves
    this by modifying the user agent that is sent to the AWS servers. As a result,
    GuardDuty won't alert us immediately when we start attacking. This same check
    and solution process applies to Parrot and Pentoo Linux as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第16章](14f5f864-8cf1-4232-86f5-8d0fa4ec28e4.xhtml)中讨论的那样，*GuardDuty*，这条消息是因为Pacu检测到它正在运行在Kali
    Linux主机上。GuardDuty可以检测到AWS API调用是否来自Kali Linux服务器，并根据此标记警报，因此Pacu通过修改发送到AWS服务器的用户代理自动解决了这个问题。因此，当我们开始攻击时，GuardDuty不会立即警报我们。同样的检查和解决方案过程也适用于Parrot和Pentoo
    Linux。
- en: 'After that, you should land in the Pacu CLI, which looks like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该会进入Pacu CLI，看起来像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This line is waiting for us to enter a command, and it is showing us that we
    are in the `ExampleSession` Pacu session, without any AWS keys set. For most of
    Pacu''s functionality, a set of AWS keys is required, so we will go ahead and
    add some in with the `set_keys` Pacu command. While running this, we will be asked
    for the key alias, access key ID, secret access key, and session token of our
    AWS credentials. As we have previously discussed in the book, the session token
    field is optional, because only temporary AWS credentials use a session token.
    Regular IAM users only have an access key ID and secret access key, so in that
    case, you will leave the session token field empty. The key alias is an arbitrary
    name that we can assign to the set of access keys that we are adding in. It is
    for our (and Pacu''s) reference only, so choose something that makes sense to
    you. The following screenshot shows the output and input provided when running
    the `set_keys` command to add our AWS access tokens in the Pacu database. In our
    example, we chose `ExampleUser`, because that is the username of the user that
    the keys were created for:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行正在等待我们输入命令，并且它显示我们在`ExampleSession` Pacu会话中，没有设置任何AWS密钥。对于Pacu的大部分功能，需要一组AWS密钥，因此我们将使用`set_keys`
    Pacu命令添加一些。在运行此命令时，我们将被要求输入密钥别名、访问密钥ID、秘密访问密钥和AWS凭据的会话令牌。正如我们之前在书中讨论过的那样，会话令牌字段是可选的，因为只有临时AWS凭据使用会话令牌。常规IAM用户只有访问密钥ID和秘密访问密钥，因此在这种情况下，您将留空会话令牌字段。密钥别名是我们可以分配给正在添加的访问密钥集的任意名称。这仅供我们（和Pacu）参考，因此选择一个对您有意义的名称。以下截图显示了在Pacu数据库中运行`set_keys`命令添加我们的AWS访问令牌时提供的输出和输入。在我们的示例中，我们选择了`ExampleUser`，因为这是为其创建密钥的用户的用户名。
- en: '![](img/b6ebcbb3-d9b8-4d24-a573-daee72dd788c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6ebcbb3-d9b8-4d24-a573-daee72dd788c.png)'
- en: Adding our example user to the Pacu database
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的示例用户添加到Pacu数据库
- en: As you can see, we have named the set of keys as `ExampleUser`, which then replaced
    `No Keys Set` at the Pacu CLI prompt, which indicates that the `ExampleUser` key
    pair is our active set. The active set of keys is used for any authentication
    that Pacu makes with the AWS APIs. You can add additional sets of keys with the
    same `set_keys` command, but with a different key alias. If you specify an existing
    key alias when setting a pair of keys, it will overwrite any existing values under
    that key alias with what you input.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将密钥集命名为`ExampleUser`，然后在Pacu CLI提示符处替换了`No Keys Set`，这表明`ExampleUser`密钥对是我们的活动集。活动密钥集用于Pacu与AWS
    API进行任何身份验证。您可以使用相同的`set_keys`命令添加其他密钥集，但使用不同的密钥别名。如果在设置一对密钥时指定了现有的密钥别名，它将用您输入的内容覆盖该密钥别名下的任何现有值。
- en: 'If we wanted to swap between key pairs while within Pacu, we can use the aptly
    named `swap_keys` Pacu command. This will allow us to choose from a list of key
    pairs we have set up within this Pacu session. Let''s say that for this example
    we have `ExampleUser` and `SecondExampleUser` set up as key pairs within Pacu
    and we want to switch from `ExampleUser` to `SecondExampleUser`. All we will need
    to do is run the `swap_keys` command and select our desired key pair:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Pacu中切换密钥对，我们可以使用名为`swap_keys`的Pacu命令。这将允许我们从在此Pacu会话中设置的密钥对列表中进行选择。假设在此示例中，我们已经在Pacu中设置了`ExampleUser`和`SecondExampleUser`作为密钥对，并且我们想要从`ExampleUser`切换到`SecondExampleUser`。我们只需要运行`swap_keys`命令并选择我们想要的密钥对即可：
- en: '![](img/f459a94e-9572-4b29-85c4-dc9777c24727.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f459a94e-9572-4b29-85c4-dc9777c24727.png)'
- en: Swapping between Pacu keys within a session
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话中切换Pacu密钥
- en: As you can see in the preceding screenshot, `ExampleUser` on the Pacu CLI changed
    to `SecondExampleUser`, which indicates that we have a new set of activated AWS
    keys.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，Pacu CLI上的`ExampleUser`已更改为`SecondExampleUser`，这表明我们有了一组新的激活的AWS密钥。
- en: Pacu is essentially set up and ready to go at this point, but there are a few
    more things that we can do to customize our session if we wish, but we will cover
    that in the next section as we pass by those commands.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此时Pacu基本上已经设置好并准备就绪，但如果我们愿意，我们还可以做一些事情来定制我们的会话，但我们将在下一节中介绍这些命令。
- en: Pacu commands
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pacu命令
- en: 'Pacu has a variety of CLI commands that allow for flexible customization and
    interaction with your current session and any available modules that Pacu offers.
    In its current state, Pacu offers the following commands:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu具有各种CLI命令，允许灵活定制和与当前会话以及Pacu提供的任何可用模块进行交互。在当前状态下，Pacu提供以下命令：
- en: '`list/ls`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list/ls`'
- en: '`search`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`'
- en: '`help`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`'
- en: '`whoami`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whoami`'
- en: '`data`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`'
- en: '`services`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`'
- en: '`regions`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regions`'
- en: '`update_regions`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_regions`'
- en: '`set_regions`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_regions`'
- en: '`run/exec`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run/exec`'
- en: '`set_keys`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_keys`'
- en: '`swap_keys`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap_keys`'
- en: '`import_keys`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import_keys`'
- en: '`exit/quit/Ctrl+C`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit/quit/Ctrl+C`'
- en: '`aws`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws`'
- en: '`proxy`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy`'
- en: The following subsections will cover each of these commands, including a description,
    usage examples, and real-world use cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节将介绍这些命令，包括描述、使用示例和实际用例。
- en: list/ls
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: list/ls
- en: 'The `list` and `ls` commands are the same, and they list all the available
    Pacu modules, along with their categories. The following screenshot shows part
    of the output that is returned when running the `ls` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`和`ls`命令是相同的，它们列出所有可用的Pacu模块，以及它们的类别。以下截图显示了运行`ls`命令时返回的部分输出：'
- en: '![](img/dddc4680-b77a-4155-994a-8178fe373ca2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dddc4680-b77a-4155-994a-8178fe373ca2.png)'
- en: Some of the modules and categories returned when running ls or list
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行ls或list时返回的一些模块和类别
- en: search [[cat]egory] <search term>
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: search [[cat]egory] <search term>
- en: The `search` command does exactly what you might think – it searches modules.
    It is essentially the same as the `ls` command by returning the categories and
    modules, but it also returns a one-line description of each module that was searched
    to give you a better idea of what a certain module does. The reason for this is
    that the output of a search will almost certainly be smaller than just running
    `ls`, so there is room for a more specific output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`命令正是你所想的 - 它搜索模块。它基本上与`ls`命令相同，通过返回类别和模块，但它还返回每个搜索的模块的一行描述，以便让您更好地了解某个模块的功能。其原因是搜索的输出几乎肯定比仅运行`ls`要小，因此有更具体的输出空间。'
- en: You can also search by category to list all the modules within that category
    by using the `cat` or `category` keyword as the section string in your search.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过类别搜索来列出该类别中的所有模块，方法是在搜索中使用`cat`或`category`关键字作为部分字符串。
- en: 'This following example will return all the modules that have `ec2` in their
    name:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将返回名称中包含`ec2`的所有模块：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This following example will return all the modules that are in the `PERSIST` category:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将返回`PERSIST`类别中的所有模块：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because `category` can also be specified as `cat`, the shorthand way of getting
    all the modules in the `PERSIST` category will appear as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`category`也可以被指定为`cat`，获取`PERSIST`类别中所有模块的简便方法如下：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows the output of the `search cat PERSIST` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`search cat PERSIST`命令的输出：
- en: '![](img/8b2cd999-c152-43c0-a9b1-e53993f20c90.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b2cd999-c152-43c0-a9b1-e53993f20c90.png)'
- en: All modules in the PERSIST category are returned
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 返回PERSIST类别中的所有模块
- en: help
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: help
- en: The `help` command simply outputs the help information for Pacu, which includes
    available commands and descriptions for each one. This prints the same data that
    is auto-printed on every Pacu startup.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`help`命令简单地输出Pacu的帮助信息，其中包括可用命令和每个命令的描述。这打印了在每次Pacu启动时自动打印的相同数据。'
- en: help <module name>
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: help <module name>
- en: The `help` command also has another variation, where you can provide a module
    name and it will return the help information for that specific module. This data
    includes a long description (longer than the one-line description that shows up
    when you `search` a module), prerequisite modules, credits to who wrote the module,
    and all the available or required arguments. It's always a good idea to read the
    help documentation for a specific module before moving forward and using it because
    of the features and quirks you might miss otherwise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`help`命令还有另一种变体，您可以提供模块名称，它将返回该特定模块的帮助信息。这些数据包括长描述（比搜索模块时显示的一行描述更长），先决条件模块，编写模块的人员，以及所有可用或必需的参数。在继续使用特定模块之前阅读特定模块的帮助文档总是一个好主意，因为您可能会错过一些功能和怪癖。'
- en: 'The following screenshot shows the `help` output for the `iam__enum_permissions` module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`iam__enum_permissions`模块的`help`输出：
- en: '![](img/af996bc7-d0b1-412f-9b8d-32d118abe09a.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af996bc7-d0b1-412f-9b8d-32d118abe09a.png)'
- en: The help output for the iam__enum_permissions module
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: iam__enum_permissions模块的帮助输出
- en: whoami
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: whoami
- en: 'The `whoami` command will output all the information about the current set
    of active AWS keys. This means that if our active set is the `SecondExampleUser` user,
    then I will see information for that user and no one else. The following screenshot
    shows the output of the `whoami` command as the `SecondExampleUser` user:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`whoami`命令将输出有关当前活动AWS密钥集的所有信息。这意味着如果我们的活动集是`SecondExampleUser`用户，那么我将只看到该用户的信息，而不是其他人的。以下屏幕截图显示了`whoami`命令作为`SecondExampleUser`用户的输出：'
- en: '![](img/cb7934a5-1125-4c2c-b548-d3db068f499d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/cb7934a5-1125-4c2c-b548-d3db068f499d.png)
- en: '*Figure 8*: The output of whoami for the SecondExampleUser user'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8*：SecondExampleUser用户的whoami输出'
- en: 'As you can see, almost everything is empty or null. This is because no modules
    have yet been run in the current session. As modules are run that provide information
    within this list, it will get filled in. As an example, I just ran the `iam__detect_honeytokens` module,
    which fills in some identifying information about my user. The following screenshot
    shows the updated output of the `whoami` command after collecting this information:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，几乎所有内容都是空的或null。这是因为在当前会话中尚未运行任何模块。随着运行提供此列表中信息的模块，它将被填充。举个例子，我刚刚运行了`iam__detect_honeytokens`模块，它填写了有关我的用户的一些标识信息。以下屏幕截图显示了收集此信息后`whoami`命令的更新输出：
- en: '![](img/14bfe22a-46c8-4778-95e4-d5afe4ebfb41.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/14bfe22a-46c8-4778-95e4-d5afe4ebfb41.png)
- en: Some of the output that has been populated from the iam__detect_honeytokens
    module
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从iam__detect_honeytokens模块填充的部分输出
- en: We can see that the `UserName`, `Arn`, and `AccountId` fields have been updated,
    because that is the information that the `iam__detect_honeytokens` module fetches
    when it is run. Other modules fill in different information within this output,
    but the `iam__enum_permissions` module will fill out the most, because it enumerates
    a large amount of information about the current user and saves them to the local
    database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`UserName`，`Arn`和`AccountId`字段已更新，因为这是`iam__detect_honeytokens`模块在运行时获取的信息。其他模块在此输出中填入不同的信息，但`iam__enum_permissions`模块将填写最多的信息，因为它枚举了有关当前用户的大量信息并将其保存到本地数据库。
- en: data
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: 'The `data` command will output all data that is stored in the currently active
    session, which includes AWS service data that has been enumerated, as well as
    configuration settings that have been defined during the duration of the session.
    The following screenshot shows the output of the `data` command at the point that
    we are at right now (that is, not having enumerated any AWS service data yet):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`命令将输出存储在当前活动会话中的所有数据，其中包括已枚举的AWS服务数据，以及在会话期间定义的配置设置。以下屏幕截图显示了我们目前所处位置的`data`命令的输出（即，尚未枚举任何AWS服务数据）：'
- en: '![](img/28418fa3-18f0-449e-8eac-7c0404bbe52e.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/28418fa3-18f0-449e-8eac-7c0404bbe52e.png)
- en: '*Figure 10*: The output of the data command without having enumerated any AWS
    data'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10*：没有枚举任何AWS数据的数据命令的输出'
- en: We can see both AWS keys that we have added to our session, some identifying
    information about the session, our modified user agent (because we are on Kali
    Linux), our active set of keys, session regions (discussed under the `set_regions` command
    section), and proxy data (discussed under the `proxy` command section).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们添加到会话中的两个AWS密钥，会话的一些标识信息，我们修改后的用户代理（因为我们在Kali Linux上），我们活跃的密钥集，会话区域（在`set_regions`命令部分讨论），以及代理数据（在`proxy`命令部分讨论）。
- en: 'If I run the `run ec2__enum --instances` command to enumerate EC2 instances
    in my target account, I should be able to fill up some EC2 data in the database,
    which will change the output of the `data` command. The following screenshot shows
    the new output of the `data` command, after enumerating EC2 instances:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行`run ec2__enum --instances`命令来枚举目标帐户中的EC2实例，我应该能够在数据库中填充一些EC2数据，这将改变`data`命令的输出。以下屏幕截图显示了枚举EC2实例后`data`命令的新输出：
- en: '![](img/6d2b75b7-d1e6-492b-b645-9c110e309ad3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6d2b75b7-d1e6-492b-b645-9c110e309ad3.png)
- en: The new output of the data command, after enumerating EC2 instances
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举EC2实例后数据命令的新输出
- en: services
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'The `services` command will output any AWS service that has data stored in
    the database. Given that we only have enumerated EC2 instances, EC2 should be
    the only service that has data stored in the database:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`services`命令将输出存储在数据库中的任何AWS服务。鉴于我们只枚举了EC2实例，EC2应该是唯一在数据库中存储数据的服务：'
- en: '![](img/7c0feb06-9f71-48dd-aee3-0391a2ca3a05.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7c0feb06-9f71-48dd-aee3-0391a2ca3a05.png)
- en: The services command showing us that there is EC2 data in the database
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务命令向我们显示数据库中存在EC2数据
- en: This command goes nicely with the alternate form of the `data` command, which
    is explained in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与`data`命令的另一种形式很搭配，该形式在下一节中有解释。
- en: data <service>|proxy
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据<服务>|代理
- en: 'This version of the `data` command allows you to request more specific information
    than the broad `data` command, especially because as multiple services and data
    types are stored in the database, the `data` command''s output can become rather
    large. We can pass this command any AWS service that has data in the database
    to get information on that particular service, or we can pass it the `proxy` keyword
    to get information on `PacuProxy` (as outlined under the `proxy` command section).
    We know that `services` output `EC2` as the only service we have data for, so
    we can run `data EC2` to fetch the associated EC2 data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`data`命令允许您请求比广泛的`data`命令更具体的信息，特别是因为在数据库中存储了多个服务和数据类型，`data`命令的输出可能会变得相当大。我们可以向该命令传递任何在数据库中具有数据的AWS服务，以获取有关该特定服务的信息，或者我们可以传递`proxy`关键字以获取有关`PacuProxy`的信息（如在`proxy`命令部分中概述）。我们知道`services`输出`EC2`是我们唯一具有数据的服务，因此我们可以运行`data
    EC2`来获取相关的EC2数据：
- en: '![](img/18a2833d-61c7-4e68-a1d0-6dde243ab8d0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/18a2833d-61c7-4e68-a1d0-6dde243ab8d0.png)
- en: Fetching EC2 data with the data command
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据命令获取EC2数据
- en: We can also run `data proxy`, but we won't get into that until later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以运行`data proxy`，但我们要等到以后再讨论。
- en: regions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域
- en: 'The `regions` command will list all the regions that Pacu supports, which generally
    is every public region available to AWS users. This command can help when running
    modules against a certain set of regions, or when using the `set_regions` command,
    which will be discussed in a later section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b1c50c-e561-4d7b-87ef-bfa0dfc9677f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: All the regions that are supported at this time are listed when running the
    regions command
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: update_regions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `update_regions` command generally does not need to be run by a regular
    Pacu user, but it is important to understand what it does for when you think you
    might need to use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs a bash script that will do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Use `python3 -m pip install --upgrade botocore` to update your botocore Python3
    library to the latest available version.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `python3 -m pip show botocore` to locate the botocore installation folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it will read the `endpoints.json` file that is stored in the botocore
    folder to parse out what services are available and what regions are supported
    for those services.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it will save that parsed data to the `./modules/service_regions.json` file
    in the Pacu folder.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pacu uses this as its guide for supported services and regions. The Pacu developers
    will update the region list along with any updates that are pushed to the GitHub
    repository, but there may be times between two Pacu updates that new regions become
    supported. In that case, it might make sense to run the `update_regions` command,
    but otherwise, you probably can leave it to the developers. The following screenshot
    shows the output of running the `update_regions` command, which fetches the latest
    version of the botocore Python library, then extracts the most up-to-date region
    list from it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5e472f-8c1f-47d5-be28-d896b271e3d0.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Botocore being updated by the update_regions command
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: set_regions <region> [<region>...]
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `set_regions` command is one of the most important to understand while learning
    to use Pacu. When used correctly, it can greatly reduce the amount of API calls
    that are made to a target environment, ultimately keeping our footprint in the
    environment smaller.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The `set_regions` command is what controls the value of the `session regions` configuration
    option. Basically, this command is used to tell Pacu that you only want to target
    region's *x*, *y*, and *z* in your current session. An example scenario of where
    this could come in handy is when you are attacking an environment that only uses
    a couple of regions for its entire infrastructure. By default, Pacu will prompt
    you to ensure whether you would like to target every region when running a module
    with the `--regions` argument omitted, but why do that if you already know that
    only a couple of the regions will have valid results? Ultimately, it ends up in `wasted` API
    calls that risk us being detected by a defender and provide us virtually no benefit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `set_regions` command, you supply it one or more AWS regions
    (which are listed in the output of the `regions` command). Then, Pacu will only
    ever target those regions with API calls. If you know that your target only uses
    EC2 in two regions, `us-west-2` and `us-east-1`, then you will run `set_regions
    us-west-2 us-east-1`, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87072c16-8f31-4f3e-8d03-69ae743dba24.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Setting our session regions to us-west-2 and us-east-1
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we want, we can run the `data` command again, which will have a different
    value for `session_regions` than we saw earlier. It will now contain two strings: `us-west-2` and
    `us-east-1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: When session regions are set, Pacu will react accordingly when running a module.
    When you run a module that accepts `--regions` as an argument, but omit that argument,
    Pacu will first fetch all the supported regions for the service that is being
    targeted, then compare that list to the list of session regions set by the user.
    Then, it will only target regions that are in both lists. This prevents you from
    ever running a module against a region that is not supported by the specific AWS
    service, and it prevents you from ever running a module against any regions that
    you did not intend.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设置会话区域后，Pacu在运行模块时会做出相应的反应。当运行接受“--regions”作为参数的模块，但省略该参数时，Pacu将首先获取被定位的服务的所有支持的区域，然后将该列表与用户设置的会话区域列表进行比较。然后，它只会定位两个列表中都存在的区域。这可以防止您对不受特定AWS服务支持的区域运行模块，并防止您对任何您不打算运行模块的区域运行模块。
- en: 'The set of session regions can be changed at any time and the `all` keyword
    can be used to go back to targeting every region (the default). It will be used
    just like a region is, as `set_regions all`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 会话区域集可以随时更改，“all”关键字可用于返回到目标每个区域（默认）。它将像区域一样使用，如“set_regions all”：
- en: '![](img/21f9406b-955e-4c16-b441-a2087b10ea12.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/21f9406b-955e-4c16-b441-a2087b10ea12.png)
- en: A warning that we are targeting every AWS region, prior to using the set_regions
    command to modify our targets
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用set_regions命令修改我们的目标之前，我们正在针对每个AWS区域发出警告
- en: run/exec <module name>
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: run/exec <模块名称>
- en: The `run` and `exec` commands do the same thing, in that they run modules. Let's
    say we want to run the `ec2__enum` module. We could first run `help ec2__enum` to
    get some information about it, including what arguments are supported. Then, we
    could run the module with `run` or `exec` and pass any arguments in with that
    command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: “run”和“exec”命令做同样的事情，即运行模块。假设我们想运行“ec2__enum”模块。我们可以首先运行“help ec2__enum”来获取一些关于它的信息，包括支持的参数。然后，我们可以使用“run”或“exec”运行模块，并通过该命令传递任何参数。
- en: 'If we wanted to enumerate EC2 instances in the `us-east-1` region, we could
    run the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要枚举“us-east-1”区域中的EC2实例，我们可以运行以下命令：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/b798613a-9831-4b8b-9ca8-bfa250874c96.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b798613a-9831-4b8b-9ca8-bfa250874c96.png)
- en: Running the ec2__enum module with the instances and regions arguments
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实例和区域参数运行ec2__enum模块
- en: As you can see, we specified the `--instances` argument to only enumerate EC2
    instances, and we specified the `--regions` argument to only enumerate EC2 instances
    in the `us-east-1` region.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们指定了“--instances”参数，只枚举EC2实例，并指定了“--regions”参数，只枚举“us-east-1”区域中的EC2实例。
- en: The preceding screenshot also brings up another important point of module output
    – the module summary section. Every module has a module summary and the point
    of this is to provide output from the module in a small section of output. Sometimes,
    depending on the configuration of the module that you are running, the output
    can span multiple screens and potentially be so long that it goes beyond your
    Terminal's history. To help try and solve this problem, module summaries were
    introduced to provide a summary of the findings or actions that the module performed
    throughout its execution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图还提出了模块输出的另一个重要点-模块摘要部分。每个模块都有一个模块摘要，其目的是在一个小的输出部分中提供模块的输出。有时，根据您运行的模块的配置，输出可能跨越多个屏幕，并且可能如此之长，以至于超出了您的终端历史记录。为了帮助解决这个问题，引入了模块摘要，以提供模块在执行过程中的发现或操作的摘要。
- en: set_keys
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: set_keys
- en: We've used the `set_keys` command a few times now throughout this book. This
    command is used to add sets of keys to the current Pacu session, or to update
    any existing sets of keys. As we've seen before, if you run the `set_keys` command
    without any keys already set, you will be setting up the first or default set
    of keys in Pacu. After that, the `set_keys` command will automatically try and
    update the active set of keys with the default values it supplies, but you can
    change that to add another set of keys by modifying the key alias that you are
    prompted for.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中已经多次使用了“set_keys”命令。此命令用于向当前Pacu会话添加密钥集，或更新任何现有的密钥集。如前所述，如果您在没有设置任何密钥的情况下运行“set_keys”命令，您将设置Pacu中的第一个或默认密钥集。之后，“set_keys”命令将自动尝试使用它提供的默认值更新活动密钥集，但您可以通过修改提示的密钥别名来更改以添加另一个密钥集。
- en: The key alias associated with a set of keys is essentially only for yourself,
    so you can identify what keys they are when it is ready. Usually, this means it
    makes the most sense to set the key alias to the name of the user or role who
    owns the keys. In other situations, it might make more sense to describe the access
    that the set of keys was provided. Say that a client who are doing a pentest for
    sends you two sets of keys, one that has administrator level access and one that
    has developer level access. In that case, it could make more sense to name them
    `Administrator` and `Developer`, or something along those lines, rather than what
    their usernames are.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与一组密钥相关联的密钥别名实质上仅供您自己使用，因此当准备好时，您可以识别它们是什么密钥。通常，这意味着将密钥别名设置为拥有密钥的用户或角色的名称是最合理的。在其他情况下，可能更有意义的是描述提供的密钥集的访问权限。假设一位客户发送给您两组密钥，一组具有管理员级别访问权限，另一组具有开发人员级别的访问权限。在这种情况下，将它们命名为“管理员”和“开发人员”，或者类似的名称，而不是他们的用户名，可能更有意义。
- en: As you may have already noticed, any place that Pacu is storing your secret
    access key and it needs to be reflected onto the screen, Pacu will censor that
    value. This is so that secret access keys are not logged to the Pacu command/error
    log, so that any other logs or over-the-shoulder peekers do not have access either.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，Pacu存储您的秘密访问密钥的任何地方，它需要反映到屏幕上，Pacu将对该值进行审查。这样秘密访问密钥就不会被记录到Pacu命令/错误日志中，这样任何其他日志或偷窥者也无法访问。
- en: swap_keys
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换密钥
- en: We've also already looked at the `swap_keys` command, but this command is useful
    when working with a session that contains multiple sets of active keys. By running
    `swap_keys`, you will be presented with a list of available keys that you have
    previously added to your session, from which you then can choose which becomes
    the active set. The active set is the set of keys that is used to authenticate
    to AWS when running any modules that do so.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过 `swap_keys` 命令，但是当使用包含多组活动密钥的会话时，这个命令非常有用。通过运行 `swap_keys`，您将看到一个可用密钥列表，您可以选择其中一个成为活动密钥集。活动密钥集是在运行任何需要进行身份验证的AWS模块时使用的密钥集。
- en: import_keys <profile name>|--all
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: import_keys <profile name>|--all
- en: 'The `import_keys` command is meant to make it a bit easier to bridge the gap
    between Pacu and the AWS CLI. This command will import credential profiles from
    the AWS CLI and create a new set of keys in the active session with that information.
    If we want to import a single AWS CLI profile, you can just name it in the command,
    like in the following screenshot, where `import_keys default` is run:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`import_keys` 命令旨在使Pacu和AWS CLI之间的桥梁更加容易。此命令将从AWS CLI导入凭据配置文件，并在活动会话中创建一个新的密钥集。如果要导入单个AWS
    CLI配置文件，可以在命令中直接命名，就像下面的屏幕截图中运行 `import_keys default` 一样：'
- en: '![](img/ac5d1799-fb00-43b6-acb4-d76a73d61450.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac5d1799-fb00-43b6-acb4-d76a73d61450.png)'
- en: Importing the keys for the default profile of the AWS CLI
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 导入AWS CLI默认配置文件的密钥
- en: As shown in the preceding screenshot, we imported the `default` AWS CLI profile
    as the `imported-default` key alias to indicate that these keys were imported,
    and the profile name was `default`. We can also see that the active key set switched
    from `SecondExampleUser` to `imported-default`. We could just use the `swap_keys` command
    to switch them back if required.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们将 `default` AWS CLI配置文件导入为 `imported-default` 键别名，以指示这些密钥已被导入，并且配置文件名称为
    `default`。我们还可以看到活动密钥集从 `SecondExampleUser` 切换到 `imported-default`。如果需要，我们可以使用
    `swap_keys` 命令将它们切换回来。
- en: 'We can also use the `--all` flag instead of an AWS CLI profile name, to which
    Pacu will import every AWS CLI profile that it can find:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `--all` 标志而不是AWS CLI配置文件名称，Pacu将导入它可以找到的每个AWS CLI配置文件：
- en: '![](img/f3e45c17-beba-42cf-b7de-5778c061baab.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3e45c17-beba-42cf-b7de-5778c061baab.png)'
- en: Importing multiple key pairs from the AWS CLI with the --all argument
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 --all 参数从AWS CLI导入多个密钥对
- en: exit/quit/Ctrl + C
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exit/quit/Ctrl + C
- en: 'Entering the `exit` or `quit` commands, or pressing the *Ctrl* + *C* keys on
    your keyboard, will cause Pacu to exit gracefully if you are at the main menu:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `exit` 或 `quit` 命令，或按下键盘上的 *Ctrl* + *C* 键，如果您在主菜单上，Pacu将会优雅地退出：
- en: '![](img/84c2dcd7-79d2-4ed2-ab73-eab27ae7f84e.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84c2dcd7-79d2-4ed2-ab73-eab27ae7f84e.png)'
- en: Quitting Pacu and returning to my Terminal
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 退出Pacu并返回到我的终端
- en: '*Ctrl* + *C* also has another use; when a module is mid-execution and *Ctrl*
    + *C* is pressed, that module''s execution will exit, and you will drop back to
    the main Pacu CLI. The following screenshot shows the use of *Ctrl* + *C* to exit
    the execution of the `ec2__enum` module (`^C` is how *Ctrl* + *C* shows up in
    the Terminal):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *C* 还有另一个用途；当模块正在执行时按下 *Ctrl* + *C*，该模块的执行将退出，您将返回到主要的Pacu CLI。以下屏幕截图显示了使用
    *Ctrl* + *C* 退出 `ec2__enum` 模块的执行（`^C` 是 *Ctrl* + *C* 在终端中显示的方式）：'
- en: '![](img/b6ee2ff2-9bc4-472f-917f-3e39beddfe14.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6ee2ff2-9bc4-472f-917f-3e39beddfe14.png)'
- en: Using the *Ctrl* + *C* key combination to exit the ec2__enum module
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *C* 组合键退出ec2__enum模块
- en: aws <command>
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: aws <command>
- en: The `aws` command is a little different than the other Pacu commands. This is
    essentially a command that directly integrates the AWS CLI into Pacu, so you can
    run AWS CLI commands without needing to exit out of Pacu. The way it works is
    if Pacu detects a command that is run that starts with `aws` as the first word,
    it will drop the entire command to the bash shell on the host. This means you
    can treat any `aws` command within Pacu as if it were a `bash` command, because
    it is. This allows you to pipe or redirect the output of your AWS CLI command
    to wherever you need it on the system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws` 命令与其他Pacu命令有些不同。这本质上是一个直接将AWS CLI集成到Pacu中的命令，因此您可以在不退出Pacu的情况下运行AWS CLI命令。它的工作方式是，如果Pacu检测到以
    `aws` 开头的命令作为第一个单词运行，它将把整个命令传递到主机上的bash shell。这意味着您可以将Pacu中的任何 `aws` 命令视为 `bash`
    命令，因为它就是。这使您可以将AWS CLI命令的输出管道或重定向到系统上需要的任何位置。'
- en: Something extremely important to note is that Pacu and the AWS CLI use two separate
    methods of credential storage. Pacu handles its credentials independently, and
    the AWS CLI handles its credentials separately. This means that if you are within
    Pacu with `SecondExampleUser` as your active set of keys, the AWS CLI will **not**
    use those same credentials, unless you specify it correctly within the AWS CLI.
    The AWS CLI will act normally, as if you ran it from the `bash` command line,
    so that means the `default` AWS CLI profile will be used automatically, unless
    you specify a separate profile with the `--profile` argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，Pacu和AWS CLI使用两种不同的凭据存储方法。Pacu独立处理其凭据，而AWS CLI单独处理其凭据。这意味着，如果您在Pacu中使用
    `SecondExampleUser` 作为活动密钥集，AWS CLI将**不会**使用相同的凭据，除非您在AWS CLI中正确指定。AWS CLI将正常运行，就好像您从
    `bash` 命令行中运行它一样，这意味着将自动使用 `default` AWS CLI配置文件，除非您使用 `--profile` 参数指定其他配置文件。
- en: 'The following screenshot shows the `aws ec2 describe-instances` command being
    run from within Pacu, and because it is passed to the bash shell, it is then piped
    into `grep` so that the output can be searched for the `ImageId` word and we can
    see the image ID of the EC2 instance that was found:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了在Pacu中运行 `aws ec2 describe-instances` 命令，并且因为它被传递到bash shell，然后被传递到
    `grep`，以便可以搜索 `ImageId` 一词，并且我们可以看到找到的EC2实例的镜像ID：
- en: '![](img/ad90bcfd-220b-49fc-aec1-5c9d19c3ce68.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad90bcfd-220b-49fc-aec1-5c9d19c3ce68.png)'
- en: Grepping ImageId from the output of an ec2 describe-instances API call
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从ec2 describe-instances API调用的输出中提取ImageId
- en: We didn't specify an AWS CLI profile to use, so it automatically used the default
    profile, not the `SecondExampleUser` Pacu key pair.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定要使用的AWS CLI配置文件，因此它自动使用了默认配置文件，而不是`SecondExampleUser`的Pacu密钥对。
- en: proxy <command>
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: proxy <command>
- en: 'The `proxy` command is associated with the built-in command and control feature
    known as `PacuProxy`. The `proxy` command accepts a few different sub-commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy`命令与内置的命令和控制功能`PacuProxy`相关联。`proxy`命令接受几个不同的子命令：'
- en: '`start <ip> [port]`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start <ip> [port]`'
- en: '`stop`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`'
- en: '`kill <agent_id>`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill <agent_id>`'
- en: '`list/ls`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list/ls`'
- en: '`use none|<agent_id>`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use none|<agent_id>`'
- en: '`shell <agent_id> <command>`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell <agent_id> <command>`'
- en: '`fetch_ec2_keys <agent_id>`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_ec2_keys <agent_id>`'
- en: '`stager sh|ps`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stager sh|ps`'
- en: We aren't going to dive deep into what each of these commands do, but we will
    look at PacuProxy in the *An introduction to PacuProxy* section at the end of
    this chapter at a higher level. This is because `PacuProxy` is still in development
    and the current release version is not necessarily final, but the overarching
    theme and goal of it is staying the same. If you are interested in reading about
    the more advanced offerings of Pacu and PacuProxy, you can visit the *Advanced
    Capabilities* section of the Pacu Wiki on GitHub here: [https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities](https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入研究这些命令各自的功能，但我们将在本章末尾的*PacuProxy简介*部分更深入地了解PacuProxy。这是因为`PacuProxy`仍在开发中，当前发布版本不一定是最终版本，但其总体主题和目标保持不变。如果您有兴趣了解Pacu和PacuProxy的更高级功能，可以访问GitHub上Pacu
    Wiki的*高级功能*部分：[https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities](https://github.com/RhinoSecurityLabs/pacu/wiki/Advanced-Capabilities)。
- en: These proxy commands will be used when trying to deal with compromised EC2 hosts
    within a target AWS account, but we'll explore that later.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试处理目标AWS帐户中受损的EC2主机时，将使用这些代理命令，但我们稍后会探讨这一点。
- en: Creating a new module
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新模块
- en: Pacu was designed to allow external contribution to itself and the modules included
    with it. That's why it was built the way it was and released under the BSD-3 open
    source license. It is written in Python3 so all of its modules are written in
    Python3 as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu旨在允许外部对其自身和其中包含的模块进行贡献。这就是为什么它是以这种方式构建的，并在BSD-3开源许可下发布的原因。它是用Python3编写的，因此它的所有模块也都是用Python3编写的。
- en: Pacu comes with a template that is stored in the `./modules/template.py` file,
    which makes it easy to get started on your own modules. It includes everything
    that is required to make your module work, along with some examples of how you
    might use different APIs exposed by the Pacu core program to make building your
    module easier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu带有一个模板，存储在`./modules/template.py`文件中，这使得您可以轻松开始编写自己的模块。它包括使您的模块工作所需的一切，以及一些示例，说明您可以如何使用Pacu核心程序公开的不同API来使构建您的模块更容易。
- en: The API
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: 'Before getting started, it is useful to understand what methods are available
    to you through the Pacu core API. Some of the more important methods are listed
    here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，了解通过Pacu核心API可用的方法是很有用的。以下是一些更重要的方法：
- en: '`session/get_active_session`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session/get_active_session`'
- en: '`get_proxy_settings`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_proxy_settings`'
- en: '`print/input`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print/input`'
- en: '`key_info`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key_info`'
- en: '`fetch_data`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_data`'
- en: '`get_regions`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_regions`'
- en: '`install_dependencies`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install_dependencies`'
- en: '`get_boto3_client/get_boto3_resource`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_boto3_client/get_boto3_resource`'
- en: session/get_active_session
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: session/get_active_session
- en: The `session` variable is created at the beginning of the main function of every
    Pacu module. It is defined by calling the `get_active_session` Pacu API (which
    is imported as `pacu_main`). This variable contains all the information about
    the current Pacu session, including authentication information, AWS service data,
    and really anything else that is stored by Pacu.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`session`变量是在每个Pacu模块的主函数开始时创建的。通过调用`get_active_session` Pacu API（导入为`pacu_main`）来定义。此变量包含有关当前Pacu会话的所有信息，包括身份验证信息、AWS服务数据以及Pacu存储的任何其他信息。'
- en: 'You could copy all the data that is stored for the EC2 service with something
    like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式复制存储在EC2服务中的所有数据：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you could make modifications to `ec2_data`, and when you are ready to
    write that to the database, you can use the `update` method on `session`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以对`ec2_data`进行修改，当您准备将其写入数据库时，可以在`session`上使用`update`方法：
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line essentially updates the `EC2` section of the `pacu_main.database` database
    with what is stored in `ec2_data`. It is best to treat the session object as if
    the data is immutable, and then to update it at the end, after you have made your
    data modifications. This prevents issues with the database content when the module
    encounters an error during execution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码实际上是使用`ec2_data`中存储的内容更新`pacu_main.database`数据库中的`EC2`部分。最好将会话对象视为数据不可变，然后在最后进行更新，以防止模块在执行过程中遇到错误时出现数据库内容问题。
- en: get_proxy_settings
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: get_proxy_settings
- en: The `pacu_main.get_proxy_settings` method is used to pull information about
    `PacuProxy` in the current session. This method will likely not be used in any
    normal use case module and will likely make more sense in a `PacuProxy` specific
    module that needs to interact with/read from the proxy settings of the session.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`pacu_main.get_proxy_settings`方法用于获取当前会话中`PacuProxy`的信息。这种方法在任何正常使用情况下的模块中可能不会被使用，并且在需要与会话的代理设置进行交互/读取的`PacuProxy`特定模块中可能更有意义。'
- en: print/input
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print/input
- en: The `print` and `input` methods are imported from `pacu_main`, and they are
    used to override the default `print` and `input` methods that come with Python.
    Both overrides allow for any text or output that is printed to the screen to also
    be written to the Pacu activity log. They add a few arguments as well, which let
    you customize how things will be printed. For instance, perhaps you just want
    to print something to the command log, but not the screen; in this case, you could
    use the `output='file'` argument. Or, maybe you want to only print to the output
    to the screen, but keep it out of the command log, in which case you could use
    the `output='screen'` argument.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`和`input`方法是从`pacu_main`导入的，并且用于覆盖Python默认的`print`和`input`方法。这两个覆盖允许将打印到屏幕的任何文本或输出写入Pacu活动日志。它们还添加了一些参数，让您可以自定义打印方式。例如，也许您只想将某些内容打印到命令日志，而不是屏幕；在这种情况下，您可以使用`output=''file''`参数。或者，也许您只想将输出打印到屏幕，但不要将其记录到命令日志中，在这种情况下，您可以使用`output=''screen''`参数。'
- en: The `print` command will also accept JSON dictionaries as its value, where it
    will then use the `json` library to dump the output in a formatted, easy-to-read
    view. In these cases where the output is a dictionary, the `print` function will
    recursively scan the dictionary for any occurrences of `SecretAccessKey`. If it
    finds any, it will censor the value of it prior to printing or logging, so that
    your secret keys are not logged to the Pacu screen/command log in cleartext.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`命令还将接受JSON字典作为其值，然后使用`json`库将输出转储为格式化的、易于阅读的视图。在这些情况下，输出是字典时，`print`函数将递归扫描字典，查找`SecretAccessKey`的任何出现。如果找到任何内容，它将在打印或记录之前对其进行审查，以便您的秘密密钥不以明文形式记录到Pacu屏幕/命令日志中。'
- en: key_info
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: key_info
- en: The `key_info` method is used to fetch information about the active set of AWS
    keys in your current session. The data returned closely resembles the output of
    the `whoami` command in the Pacu CLI, but this provides a programmatic interface
    for retrieving the data. You could set the value of the variable named `user` to
    `key_info()`, where you will then be able to access identifying information for
    the current user (such as name, ARN, and account ID), as well as permissions that
    have been enumerated from the `iam__enum_permissions` module.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_info`方法用于获取当前会话中活动的AWS密钥集的信息。返回的数据与Pacu CLI中`whoami`命令的输出非常相似，但这提供了一个用于检索数据的编程接口。您可以将名为`user`的变量的值设置为`key_info()`，然后就可以访问当前用户的标识信息（如名称、ARN和帐户ID），以及从`iam__enum_permissions`模块枚举的权限。'
- en: fetch_data
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fetch_data
- en: The `fetch_data` method is used to allow module developers to write modules
    with a specific goal in mind. For example, someone who is writing a module that
    changes a setting on EC2 instances shouldn't have to worry about enumerating EC2
    instances. They should be able to just assume the data is available and write
    their code to work with it like that. Behind the scenes, the `fetch_data` function
    takes the arguments you pass in, which include the data being requested, the module
    that enumerates that data if it isn't available, and any additional arguments
    to pass to that module when running it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch_data`方法用于允许模块开发人员以特定目标编写模块。例如，编写一个更改EC2实例设置的模块的人不应该担心枚举EC2实例。他们应该能够假设数据可用，并编写代码以便与之一起使用。在幕后，`fetch_data`函数接受您传递的参数，包括请求的数据、如果数据不可用则枚举该数据的模块，以及在运行该模块时传递给该模块的任何其他参数。'
- en: 'Let''s consider the following block of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码块：
- en: '[PRE8]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On the first line, we see that an `if` statement is checking if the return value
    of `fetch_data` is false, and then reporting that the prerequisite module did
    not run successfully, so it is quitting the current module.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们看到一个`if`语句正在检查`fetch_data`的返回值是否为false，然后报告先决条件模块未成功运行，因此正在退出当前模块。
- en: If you wanted to work with EC2 security groups in your own module, you will
    use this code block to fetch that data. First, the `fetch_data` method will check
    the local Pacu database to see if it has enumerated anything for EC2 security
    groups yet. If it has, it will return `true` and the module-writer can assume
    that data is in the database now. If `fetch_data` does not find the data in the
    database, it will then run the module that is passed in as the second argument,
    with the flags passed in as the third argument. In this case, if EC2 security
    groups are not found, it will run the `ec2__enum` module and pass it the `--security-groups` argument.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在自己的模块中使用EC2安全组，您将使用此代码块来获取该数据。首先，`fetch_data`方法将检查本地Pacu数据库，看它是否已经枚举了EC2安全组的任何内容。如果有，它将返回`true`，模块编写者可以假设数据现在在数据库中。如果`fetch_data`在数据库中找不到数据，它将运行作为第二个参数传递的模块，并使用作为第三个参数传递的标志。在这种情况下，如果找不到EC2安全组，它将运行`ec2__enum`模块，并传递`--security-groups`参数。
- en: The module will then execute and enumerate the required data. If it is successful
    it will return `true` and the original module will continue its own execution.
    However, if it is not successful, it will return `false` to indicate that it could
    not enumerate the necessary data for a reason that should be displayed to the
    user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后模块将执行并枚举所需的数据。如果成功，它将返回`true`，原始模块将继续执行。但是，如果不成功，它将返回`false`，表示无法枚举必要的数据，应向用户显示原因。
- en: get_regions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取区域
- en: The `get_regions` method is provided so that as a module developer, you never
    need to worry about what regions you need or want to target. All you need to do
    is write your module as if every single time it runs, it runs against a list of
    regions. You can use `get_regions` to fetch that list of regions and you only
    need to provide it with an AWS service name. The line `get_regions('EC2')` will
    return all regions that support the EC2 service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_regions`方法是为了让模块开发者不需要担心需要或想要定位的区域。你只需要编写你的模块，就好像每次运行时都会针对一系列区域运行一样。你可以使用`get_regions`来获取区域列表，只需要提供一个AWS服务名称。`get_regions(''EC2'')`将返回支持EC2服务的所有区域。'
- en: If the user has set session regions with the `set_regions` command, then `get_regions('EC2')` will
    return only the regions that support EC2 and are in the list of session regions.
    For this reason, you never really need to think about regions as a module developer,
    you just need to assume that there could be any number that you might need to
    target and that you aren't provided with this information at the time of writing
    your module.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户使用`set_regions`命令设置了会话区域，那么`get_regions('EC2')`将只返回支持EC2并在会话区域列表中的区域。因此，作为模块开发者，你实际上不需要考虑区域，只需要假设可能需要定位任意数量的区域，并且在编写模块时没有提供这些信息。
- en: install_dependencies
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: install_dependencies
- en: The `install_dependencies` method is essentially deprecated, because at the
    time of writing, only one module uses it and there has been talk of plans to integrate
    this functionality in a different way. Right now, it is used to install external
    dependencies that a module requires.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`install_dependencies`方法基本上已经被弃用，因为在撰写本文时，只有一个模块使用它，并且已经有计划以不同的方式整合这个功能。目前，它用于安装模块所需的外部依赖。'
- en: For example, the one module that uses this method is the `s3__bucket_finder` module
    that uses Git to clone a third-party tool that it uses, and it also downloads
    a wordlist that it requires. This can be helpful if a dependency is another Git
    repository itself, or is too large to regularly include in Pacu.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这种方法的模块之一是`s3__bucket_finder`模块，它使用Git克隆一个第三方工具，并下载一个它所需的单词列表。如果一个依赖项本身是另一个Git存储库，或者太大而无法定期包含在Pacu中，这可能是有帮助的。
- en: Due to the lack of use of this method and other safety concerns, this feature
    will likely be removed from Pacu soon.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法的使用缺乏和其他安全问题，这个功能很可能很快就会从Pacu中移除。
- en: get_boto3_client/get_boto3_resource
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: get_boto3_client/get_boto3_resource
- en: The `get_boto3_client` and `get_boto3_resource` methods allow you to interact
    with the boto3 Python library without having to worry about a bunch of configuration
    options. Due to the requirements for `PacuProxy`, the GuardDuty Kali/Parrot/Pentoo
    user agent bypass, and authentication, all the complicated configuration options
    have been abstracted from what module developers see. On the back side, it is
    still possible to modify those configurations if you really need to, but it is
    highly unlikely that a module will require this type of granularity.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_boto3_client`和`get_boto3_resource`方法允许你与boto3 Python库进行交互，而无需担心一大堆配置选项。由于`PacuProxy`、GuardDuty
    Kali/Parrot/Pentoo用户代理绕过和身份验证的要求，所有复杂的配置选项都已经从模块开发者看到的内容中抽象出来。在后台，仍然可以修改这些配置，但是模块很少需要这种粒度的配置。'
- en: 'These functions make it so that creating a `boto3` client in a single region
    could begin with this following mess:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使得在单个区域创建`boto3`客户端可以从以下混乱开始：
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And you can turn it into this much cleaner, shorter line of code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它转换成更简洁、更短的代码行：
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both of those lines of code essentially do the same thing within Pacu, but the
    first one is much longer and requires lots of information that you shouldn't have
    to worry about as a module developer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pacu中，这两行代码本质上是做同样的事情，但第一行要长得多，并且需要很多你作为模块开发者不必担心的信息。
- en: Module structure and implementation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块结构和实现
- en: It is easy to learn about the Pacu module structure by just reviewing the content
    in the template module file that is included with Pacu. Each line and section
    in this file is commented to describe what it is doing and why you would do it
    that way. If you're more into a concrete example, then it might make sense to
    check out the code of some of the enumeration modules, as they tend to be a bit
    simpler, and they all interact with the database.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Pacu附带的模板模块文件中的内容，可以很容易了解Pacu模块结构。该文件中的每一行和部分都有注释，描述了它在做什么以及为什么要这样做。如果你更喜欢具体的例子，那么检查一些枚举模块的代码可能是有意义的，因为它们往往更简单，并且它们都与数据库交互。
- en: 'Let''s say we wanted to write a module that enumerates what buckets exist in
    the account, and then save that information to the Pacu database. Overall, this
    should be a pretty simple module to make. We''ll go one step further, and even
    consider that have a script written that enumerates S3 buckets and prints them
    out already. That script might look something like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个模块，枚举账户中存在的存储桶，并将该信息保存到Pacu数据库中。总的来说，这应该是一个非常简单的模块。我们将进一步进行一步，甚至考虑已经编写了一个枚举S3存储桶并打印出它们的脚本。该脚本可能如下所示：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a very simple script with some small error handling, but it is not very
    flexible in its usage, as currently it will only use the default AWS CLI profile
    to authenticate, because no credentials were specified when creating the boto3
    client.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的脚本，带有一些小的错误处理，但在使用上并不是非常灵活，因为目前它只会使用默认的AWS CLI配置文件进行身份验证，因为在创建boto3客户端时没有指定凭据。
- en: 'Now, let''s take a look at a clean module template. This is what the template
    looks like after removing all the commands and some of the example script that
    we won''t be using:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个干净的模块模板。这是在删除所有命令和一些我们不会使用的示例脚本后模板的样子：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have already filled in the `module_info` variable with the necessary data
    that explains our S3 enumeration module, so all we need to do now is port our
    code over. Also, we have removed any imports from `pacu_main` that weren't going
    to be used in this module, such as the `input` override. This is because we won't
    be asking the user for input in the module, but we will be printing text, so we
    are keeping the `print` override.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经填写了`module_info`变量，其中包含解释我们的S3枚举模块所需的数据，所以现在我们只需要移植我们的代码。此外，我们已经从`pacu_main`中删除了任何在此模块中不会使用的导入，例如`input`覆盖。这是因为我们不会在模块中要求用户输入，但我们会打印文本，所以我们保留`print`覆盖。
- en: If we go back to the original S3 script that we have, we can basically just
    copy over the try/except block into the Pacu module's `main` method. Then, we
    will need to make a couple of changes. We don't want to create a boto3 client
    with `boto3.client` anymore, but instead, we want to use `pacu_main.get_boto3_client`,
    so we will replace `client = boto3.client('s3')` with `client = pacu_main.get_boto3_client('s3')`.
    You may have noticed at the top of the `from botocore.exceptions import ClientError` template
    file, which means we can change our error handling from `botocore.exceptions.ClientError` to
    `ClientError` and it will work the same as before.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们原来的S3脚本，我们基本上只需将try/except块复制到Pacu模块的`main`方法中。然后，我们需要做一些更改。我们不再想用`boto3.client`创建一个boto3客户端，而是想使用`pacu_main.get_boto3_client`，所以我们将`client
    = boto3.client('s3')`替换为`client = pacu_main.get_boto3_client('s3')`。您可能已经注意到在模板文件的顶部`from
    botocore.exceptions import ClientError`，这意味着我们可以将我们的错误处理从`botocore.exceptions.ClientError`更改为`ClientError`，它将像以前一样工作。
- en: Instead of printing out the buckets, we want to store them somewhere that we
    can reference in the summary, in the function, and within the Pacu database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想打印出存储桶，而是想将它们存储在某个地方，以便我们可以在摘要中引用，在函数中引用，并在Pacu数据库中引用。
- en: To do this, we will declare a `data` variable that will hold all the relevant
    data during the module's execution, and it will have a `Buckets` key that holds
    the bucket information returned from AWS.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将声明一个`data`变量，它将在模块执行期间保存所有相关数据，并且它将有一个`Buckets`键，该键保存从AWS返回的存储桶信息。
- en: 'Now our S3 script has changed from what we previously saw to the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的S3脚本已经从之前看到的内容改变为以下内容：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have the list of bucket names, so we will use the `session` variable
    to store them in the database. In this case, we don't care about what S3 data
    was already stored in the database, because we are enumerating a new list rather
    than updating anything existing. For this reason, we don't need to copy the data
    out of the database, update it, and then put it back in. We can just overwrite
    it with our update.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储桶名称的列表，所以我们将使用`session`变量将它们存储在数据库中。在这种情况下，我们不关心数据库中已经存储的S3数据，因为我们正在枚举一个新列表，而不是更新任何现有的内容。因此，我们不需要将数据从数据库中复制出来，更新它，然后再放回去。我们可以直接用我们的更新覆盖它。
- en: 'This will look something like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将看起来像这样：
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once that is complete, the database will hold an object with a list of S3 buckets
    in the S3 section, and will be fetchable for any user of the current session.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，数据库将保存一个包含S3部分中S3存储桶列表的对象，并且对当前会话的任何用户都可以获取。
- en: 'Now the module is done. To integrate it into Pacu, we can just create a new
    folder named `s3__enum` in the modules folder of Pacu (because that''s what we
    named it in the `module_info` section), save the module script as `main.py` within
    that folder, create an empty `__init__.py` file in that folder as well, and start
    Pacu up. We should not be able to see our module when listing them or searching
    through them, which means we should also now be able to execute it and receive
    valid results:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块已经完成。要将其集成到Pacu中，我们只需在Pacu的模块文件夹中创建一个名为`s3__enum`的新文件夹（因为我们在`module_info`部分中命名为这样），将模块脚本保存为该文件夹中的`main.py`，在该文件夹中也创建一个空的`__init__.py`文件，然后启动Pacu。我们现在应该能够在列出模块或搜索模块时看到我们的模块，这意味着我们现在也能够执行它并接收有效的结果：
- en: '![](img/79831874-b3d2-4189-9228-0962625218fd.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79831874-b3d2-4189-9228-0962625218fd.png)'
- en: Searching for and running our new module
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索并运行我们的新模块
- en: It is simple, but within minutes we were able to convert a regular Python script
    to a Pacu module with very little trouble.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但在几分钟内，我们就能够将一个普通的Python脚本转换为一个Pacu模块，几乎没有什么麻烦。
- en: 'The final code of the entire module turned out to look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 整个模块的最终代码看起来是这样的：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, as a final note, if we run the `services` command within the same session
    we were working in earlier, it should now contain data for both EC2 and S3, as
    expected:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后注意一点，如果我们在之前的同一个会话中运行`services`命令，它现在应该包含EC2和S3的数据，正如预期的那样：
- en: '![](img/96714861-a45d-4d2b-8c0f-15f566bcdc4f.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96714861-a45d-4d2b-8c0f-15f566bcdc4f.png)'
- en: Services outputs both EC2 and S3 because they each have data in the database
    now
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在输出EC2和S3，因为它们现在都在数据库中有数据
- en: This also means we could run the `data S3` command to fetch any S3 data if we
    were so inclined.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们可以运行`data S3`命令来获取任何S3数据，如果我们愿意的话。
- en: An introduction to PacuProxy
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PacuProxy简介
- en: '**PacuProxy** has been brought up a number of times in this book, but usually
    it has been casually glanced over. This is because PacuProxy aims to solve a very
    specific problem when attacking AWS environments that is generally beyond the
    security posture of most companies moving to the cloud. At a very basic level,
    PacuProxy is just another command and control framework, such as PowerShell Empire
    and Meterpreter, but PacuProxy is more cloud-oriented than other similar tools.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**PacuProxy**在本书中已经多次提到，但通常只是随意地提及。这是因为PacuProxy旨在解决攻击AWS环境时的一个非常特定的问题，这通常超出了大多数转向云端的公司的安全姿态。在非常基本的层面上，PacuProxy只是另一个命令和控制框架，例如PowerShell
    Empire和Meterpreter，但PacuProxy比其他类似工具更加面向云端。'
- en: The important feature of PacuProxy (outside of just general C2 features, such
    as payload generation, agent handling, and modules) is that it directly integrates
    into Pacu's workflow. This means that when you compromise a server, such as an
    EC2 instance, you can use PacuProxy as your C2 channel and basically proxy your
    Pacu traffic through the compromised instance. This allows you to use all the
    features that Pacu offers from your own computer, but all the traffic is routed
    through the compromised host. When a defender looks at the logs and notices your
    malicious traffic, the compromised EC2 instance will show up as the source of
    the traffic, which will look a lot less suspicious than a random IP address they
    are unfamiliar with.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: PacuProxy的重要特性（除了一般的C2功能，如负载生成、代理处理和模块）是它直接集成到Pacu的工作流程中。这意味着当您妥协了一个服务器，比如一个EC2实例，您可以使用PacuProxy作为您的C2通道，基本上通过受损的实例代理您的Pacu流量。这使您可以从自己的计算机使用Pacu提供的所有功能，但所有流量都经过受损的主机。当防御者查看日志并注意到您的恶意流量时，受损的EC2实例将显示为流量的来源，这看起来比一个他们不熟悉的随机IP地址更不可疑。
- en: PacuProxy also has its own set of modules that can be run, along with the ability
    to integrate functionality into normal Pacu modules. One example is the `systemsmanager__rce_ec2` module.
    The module abuses the AWS Systems Manager service to try and execute code remotely
    on EC2 instances, but integration with PacuProxy is built in, so if you run that
    module without specifying what command to run on an instance and you have PacuProxy
    listening, it will automatically generate a one-line stager and execute that on
    the host, giving you full control of it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: PacuProxy也有自己的一套模块，可以运行，并且可以将功能集成到普通的Pacu模块中。一个例子是`systemsmanager__rce_ec2`模块。该模块滥用AWS
    Systems Manager服务，试图在EC2实例上远程执行代码，但与PacuProxy的集成已经内置，因此如果您运行该模块而没有指定要在实例上运行的命令，并且您有PacuProxy在监听，它将自动生成一个一行的分段，并在主机上执行，使您完全控制它。
- en: An example of a PacuProxy specific module is stealing credentials from the EC2
    metadata service. You could run the module and it will make HTTP requests to the
    metadata service on that server to fetch any credentials that might live there,
    then create a new set of keys within Pacu, using those credentials. Then, you'd
    be able to route all those requests through the compromised host, never alerting
    GuardDuty or anyone else that a compromise has happened, even though everything
    is installed and being run on your own host machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PacuProxy特定模块的一个例子是从EC2元数据服务中窃取凭据。您可以运行该模块，它将向该服务器的元数据服务发出HTTP请求，以获取可能存在的任何凭据，然后在Pacu中创建一组新的密钥，使用这些凭据。然后，您可以通过受损的主机路由所有这些请求，从未警告GuardDuty或其他人发生了妥协，即使一切都安装并在您自己的主机上运行。
- en: PacuProxy is still in the early stages of what was in mind when it was first
    created, so the more technical details have been withheld in this section, because
    any of those that are supplied may become outdated soon.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: PacuProxy仍处于最初创建时设想的早期阶段，因此本节中已隐瞒了更多技术细节，因为其中任何一个提供的细节可能很快就会过时。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Pacu offers a wide range of capabilities and the ability to extend upon existing
    functionality. It was the first modular attack tool created for penetration testing
    AWS environments, and due to its backing should be in development for a long time
    to come. It is a great asset to take advantage of when attacking AWS environments,
    but it is not a catch-all, so it is important to learn the fundamentals of attacking
    AWS as well, rather than relying on someone else to automate everything for you.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu提供了广泛的功能和扩展现有功能的能力。它是为渗透测试AWS环境而创建的第一个模块化攻击工具，由于有人支持，它应该会长时间发展下去。在攻击AWS环境时，它是一个很好的资产，但它并非万能，因此重要的是要学习攻击AWS的基础知识，而不是依赖别人为您自动化一切。
- en: Pacu is still in active development, so features may change, be added, or be
    removed since the time of writing, so it is important to take that into account
    when running into issues. The Pacu developers are available to respond to issues
    and pull requests that are opened in GitHub, so that is likely to be the best
    resource for support with running Pacu.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Pacu仍在积极开发中，因此自编写以来，功能可能已经发生变化，添加或删除，因此在遇到问题时考虑这一点是很重要的。Pacu的开发人员可以回应在GitHub中打开的问题和拉取请求，因此这可能是运行Pacu时获得支持的最佳资源。
- en: In this chapter, we covered the basic usage of Pacu and the commands that it
    offers. We also took a look at writing our first module for it. Hopefully, you
    can walk away from this chapter and be able to use Pacu efficiently and effectively
    to perform various attacks during your AWS pentests.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Pacu的基本用法和提供的命令。我们还看了一下为其编写我们的第一个模块。希望您能从本章中学到如何有效地使用Pacu，在AWS渗透测试期间执行各种攻击。
- en: In the next chapter, we are going to take it a step further and cover the process
    of an AWS pentest from start to beginning. This will help us get a grasp on real-world
    AWS pentesting scenarios, how and when we will use tools such as Pacu, and how
    to work around our client's needs and desires.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨并覆盖从头到尾进行AWS渗透测试的过程。这将帮助我们了解真实世界的AWS渗透测试场景，以及我们何时如何使用Pacu等工具，以及如何满足客户的需求和愿望。

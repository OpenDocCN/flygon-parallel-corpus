- en: Basics of Continuous Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付的基础知识
- en: Arguably the most important part of software is actually getting it delivered
    and ready to use for the end users. **Continuous Delivery** (**CD**) is the point
    at which you deliver a software product to your end users and is the basis of
    this chapter. A product is only useful if your intended users can actually use
    it. Throughout this chapter, we will discuss the deployment pipeline and tie in
    the concept of automation and CD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，软件的最重要部分实际上是将其交付并准备供最终用户使用。持续交付（CD）是您将软件产品交付给最终用户的时刻，也是本章的基础。只有当您的预期用户实际上可以使用产品时，产品才有用。在本章中，我们将讨论部署流水线，并结合自动化和CD的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Problems delivering software
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付软件的问题
- en: Configuration management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: Deployment pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署流水线
- en: Deployment scripting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署脚本
- en: Deployment ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署生态系统
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you understand the concept of automation and continuous
    integration. If you feel unsure about either of these topics, read [Chapter 1](69088250-887a-4306-ac24-fcda17be315b.xhtml), *CI/CD
    with Automated Testing*, and [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),
    *Basics of Continuous Integration,* before reading this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假定您了解自动化和持续集成的概念。如果您对这些主题中的任何一个感到不确定，请先阅读[第1章](69088250-887a-4306-ac24-fcda17be315b.xhtml)，“自动化测试的CI/CD”和[第2章](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml)，“持续集成的基础知识”，然后再阅读本章。
- en: The code files for this chapter can be found at [https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml](https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml](https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml)找到。
- en: Problems delivering software
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交付软件的问题
- en: There are a number of things that can go wrong when trying to deliver a software
    product to your end users, and we will look at several scenarios that affect delivering
    software. One possible scenario is that developers are working on a new feature
    but the new feature may not actually pass CI build stages or may not behave in
    the intended way initially proposed by product owners. Another possible scenario
    is that the intended audience was not properly understood, which would affect
    the usage of the end product by users. Another possible scenario is that the software
    product was not properly decoupled and was put together with bubblegum and tape,
    with many regressions occurring with new feature requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试将软件产品交付给最终用户时，可能会出现许多问题，我们将看看影响软件交付的几种情况。一个可能的情况是开发人员正在开发一个新功能，但新功能可能实际上无法通过CI构建阶段，或者可能不像产品所有者最初提出的那样运行。另一个可能的情况是，预期的受众没有得到适当的理解，这将影响用户对最终产品的使用。另一个可能的情况是，软件产品没有得到适当的解耦，并且是用泡泡糖和胶带拼凑在一起的，新功能请求会导致许多回归问题。
- en: What do we mean by delivering software?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们所说的交付软件是什么意思？
- en: There can be much argument about what delivering software actually means. For
    the purposes of this chapter, what is meant is that the actual software product
    has been delivered to the intended user—not just that the software product was
    approved by the **quality assurance** (**QA**) department as working.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件交付实际意味着什么可能会有很多争论。在本章中，所指的是实际的软件产品已交付给预期的用户，而不仅仅是软件产品被质量保证（QA）部门批准为有效。
- en: Common release anti-patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的发布反模式
- en: There exists some common release anti-patterns that you should avoid, such as
    deploying software manually, manual configuration management, and different environment
    configurations for each environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些常见的发布反模式，您应该避免，例如手动部署软件，手动配置管理以及每个环境的不同环境配置。
- en: Deploying software manually
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动部署软件
- en: This type of anti-pattern is common and can lead to bottlenecks in the delivery
    of software. The day of software delivery is stressful and error prone. Tom from
    operations starts his day by copying software artifacts from the version control
    system into a production environment. Tom copies files through the **File Transmission
    Protocol** (**FTP**) but forgets to add a new configuration file and the login
    page does not work anymore. Tom has to talk to the developer team and ask whether
    there are new configuration files that have been added, and waits for several
    hours to get a response.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的反模式很常见，可能会导致软件交付中的瓶颈。软件交付的那一天是充满压力和错误的。运维人员Tom的一天是从将软件构件从版本控制系统复制到生产环境开始的。Tom通过文件传输协议（FTP）复制文件，但忘记添加一个新的配置文件，登录页面不再工作。Tom不得不与开发团队交谈，询问是否添加了新的配置文件，并等待数小时才得到回复。
- en: Once Tom gets the new configuration file, he uploads it to the production environment.
    The Login page works now, but some pages are loading with weird image placement
    and irregularities. Tom pings the UI/UX team and finds out that a CSS file is
    missing in the production environment. Tom uploads the CSS file and now the page
    loads correctly. Tom asks the customer success team whether they can further test
    the new changes in the production environment and finally calls it a day around
    7 PM.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Tom得到了新的配置文件，他将其上传到生产环境。现在登录页面可以工作了，但一些页面加载时出现了奇怪的图像放置和不规则性。Tom联系了UI/UX团队，发现生产环境中缺少一个CSS文件。Tom上传了CSS文件，现在页面可以正确加载了。Tom询问客户成功团队是否可以进一步测试生产环境中的新更改，最终在晚上7点左右结束了一天的工作。
- en: If there exists a long document detailing the delivery of a software product,
    this can indicate a manual process. This further complicates delivering a product
    because mistakes anywhere in the process can lead to more issues. If a delivery
    tends to be unpredictable, this can point to this anti-pattern as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一份详细描述软件产品交付的长文档，这可能表明存在手动流程。这进一步使产品的交付变得更加复杂，因为在整个过程中的任何错误都可能导致更多问题。如果交付变得不可预测，这也可能指向这种反模式。
- en: Deployment automation to the rescue
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自动化来拯救
- en: As we discussed in [Chapter 1](69088250-887a-4306-ac24-fcda17be315b.xhtml),
    *CI/CD with Automated Testing*, automation is the process in which an action is
    done in a repeatable and automated fashion. Software delivery should be an automated
    process as this will help ensure the consistent practice and behavior of software
    delivery. We will look at tools later on in this chapter that will help you automate
    the software delivery processes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](69088250-887a-4306-ac24-fcda17be315b.xhtml)中讨论的那样，*自动化测试的CI/CD*，自动化是一个行为以可重复和自动化的方式完成的过程。软件交付应该是一个自动化的过程，因为这将有助于确保软件交付的一致实践和行为。我们将在本章后面看到一些工具，这些工具将帮助您自动化软件交付流程。
- en: Manual configuration management
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动配置管理
- en: This type of anti-pattern can be frustrating to operations personnel, as they
    will be the last to know about new behaviors in a product. If the day of software
    delivery is the first time the operations team has seen the new feature, then
    they may be in for a surprise in software behavior. Cindy, an operations team
    member, has been tasked with delivering software and notices that the install
    script is completely broken because it cannot communicate with the **Identification**
    (**ID**) server. Cindy sends log messages to the development team and finds out
    that one of the client secrets for the ID server has changed and that the install
    script needs to use this new value in order to properly connect.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式可能会让运维人员感到沮丧，因为他们将是最后一个了解产品新行为的人。如果软件交付的当天是运维团队第一次看到新功能，那么他们可能会对软件行为感到惊讶。辛迪是运维团队的成员，她被委托交付软件，并注意到安装脚本完全失效，因为它无法与**识别**（ID）服务器通信。辛迪向开发团队发送日志消息，发现ID服务器的一个客户端密钥已更改，并且安装脚本需要使用这个新值才能正确连接。
- en: This type of problem could have been mitigated had Cindy been aware of this
    new change in the ID server, but the developers were working with another environment
    and the QA department was given this information to test the new feature, but
    no one thought to pass this information to operations until they encountered the
    issue on the day of delivery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果辛迪意识到ID服务器的这个新变化，这种问题可能会得到缓解，但开发人员正在另一个环境中工作，QA部门得到了这个信息来测试新功能，但直到交付当天他们才遇到这个问题，没有人想到将这个信息传递给运维部门。
- en: Configuration management automation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理自动化
- en: We will discuss tools that can help with configuration management issues, such
    as those encountered previously. Using the proper tooling, operations/DevOps personnel
    can quickly get the right environment configuration for each environment, including
    the production environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论可以帮助解决配置管理问题的工具，比如之前遇到的问题。使用适当的工具，运维/DevOps人员可以快速获得每个环境的正确环境配置，包括生产环境。
- en: How a production environment differs from other environments
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境与其他环境的不同之处
- en: This type of anti-pattern can be especially challenging because of all the changes
    that have been tested in development, and a staging environment may behave erratically
    in production. For example, Travis works as a tester in the QA department and
    has been testing the staging environment since the inception of the new feature.
    Billy, an operations person, has not been able to see the new feature as the staging
    environment is completely different to the production environment. Billy also
    notices that the production environment data is missing critical information shown
    in the staging environment. Billy contacts the development team and finds out
    that a database migration script must be run for the new feature to work in production.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式可能特别具有挑战性，因为在开发中测试了所有的更改，暂存环境在生产环境中可能表现不稳定。例如，特拉维斯在QA部门担任测试员，自新功能推出以来一直在测试暂存环境。比利是一名运维人员，由于暂存环境与生产环境完全不同，他无法看到新功能。比利还注意到生产环境中缺少在暂存环境中显示的关键信息。比利联系开发团队，发现必须运行数据库迁移脚本才能使新功能在生产环境中运行。
- en: The production environment should be the same as the staging environment
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境应该与暂存环境相同
- en: All the environments, including testing, staging, and production, should all
    have the necessary migration scripts and any other software assets to prevent
    production breakages, and the development team should make sure to point operations
    to any changes in script files or clearly mark such changes in a shared document.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境，包括测试、暂存和生产环境，都应该有必要的迁移脚本和任何其他软件资产，以防止生产环境的故障，并且开发团队应该确保将操作指向脚本文件的任何更改，或者在共享文档中清楚地标记这些更改。
- en: How to conduct a software release
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行软件发布
- en: There are some important steps to consider when doing a software release, such
    as doing frequent releases to avoid introducing too many changes at once and making
    sure that releases are automated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行软件发布时，有一些重要的步骤需要考虑，比如频繁发布以避免一次引入太多的更改，并确保发布是自动化的。
- en: Frequent releases
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁发布
- en: A software release must be frequent. Big software releases tend to be riddled
    with issues, so it is best to make the deltas (changes) between releases small.
    By increasing the frequency of software releases, you also get the benefit of
    faster feedback. Large software releases tend to take longer, and critical feedback
    may not get delivered as fast.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 软件发布必须频繁。大型软件发布往往充斥着问题，因此最好使发布之间的增量（更改）较小。通过增加软件发布的频率，您还可以获得更快的反馈。大型软件发布往往需要更长的时间，关键反馈可能无法及时传达。
- en: Automated releases
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布
- en: Manual releases are problematic because they are not repeatable. Each time a
    manual release is done, it will be different because of configuration changes,
    changes in the software, and changes in the environment. Manual release steps
    are riddled with mistakes as each step is manual and can lead to cascading mistakes.
    A good example of the hazards of manual changes is when **Amazon Web Services**
    (**AWS**), the most popular cloud provider, suffered a major outage in the eastern
    US region because an operations person entered the wrong command in a series of
    steps in a manual process. Automation is the key to software releases because
    they ensure repeatability and control over the software delivery process. We will
    look at deployment scripting tools further in this chapter to help with automating
    software deliveries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 手动发布存在问题，因为它们不可重复。每次进行手动发布时，由于配置更改、软件更改和环境更改，都会有所不同。手动发布步骤充满错误，因为每个步骤都是手动的，可能导致级联错误。手动更改的危险的一个很好的例子是，当最受欢迎的云提供商亚马逊网络服务（AWS）在美国东部地区遭受重大故障时，因为运维人员在手动流程的一系列步骤中输入了错误的命令。自动化是软件发布的关键，因为它确保了软件交付流程的可重复性和控制。在本章中，我们将进一步探讨部署脚本工具，以帮助自动化软件交付。
- en: The benefits of automation in delivering software
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化在交付软件方面的好处
- en: As we illustrated previously, automation is important in software delivery as
    it ensures the repeatability, reliability, and predictability of a software release.
    Catastrophic events can be avoided or mitigated by having an automated software
    delivery process instead of a long manual process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所阐述的，自动化在软件交付中非常重要，因为它确保了软件发布的可重复性、可靠性和可预测性。通过自动化软件交付流程，可以避免或减轻灾难性事件，而不是通过漫长的手动流程。
- en: Team empowerment
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队赋能
- en: The QA department can safely select older versions of software releases to test
    regressions if automation is in place. Operations personnel can run the scripts
    used in staging and not encounter issues because of environment-level differences.
    With an automated software process, operations personnel can safely roll back
    a release in case of disaster in the delivery process. Also, as we talked about
    in the [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),  *Basics of Continuous
    Integration*, automation can help bring push button releases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动化已经实施，QA部门可以安全地选择旧版本的软件发布来测试回归。运维人员可以运行在暂存中使用的脚本，而不会因为环境级别的差异而遇到问题。通过自动化软件流程，运维人员可以在交付过程中出现灾难时安全地回滚发布。此外，正如我们在[第2章](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml)中所讨论的，自动化可以帮助实现一键式发布。
- en: Error reduction
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少错误
- en: Automation can help reduce errors that manual processes can create. As we saw
    earlier, configuration management issues can lead to poor software delivery. Manual
    software releases cannot effectively ensure repeatability and therefore are error
    prone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化可以帮助减少手动流程可能造成的错误。正如我们之前所看到的，配置管理问题可能导致软件交付不佳。手动软件发布无法有效地确保可重复性，因此容易出错。
- en: Stress reduction
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减轻压力
- en: Another benefit is reduced stress by all personnel during software delivery
    days. Manual processes tend to create undue stress as whoever is doing the manual
    process must be diligent and not make any mistakes in the delivery process. An
    automated delivery process is great in that it ensures that each run will be executed
    in the same manner. A mistake in an manual process might require support from
    senior personnel in fixing issues.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是在软件交付期间减少所有人员的压力。手动流程往往会造成不必要的压力，因为执行手动流程的人必须要细心，不能在交付过程中犯任何错误。自动交付流程非常好，因为它确保每次运行都会以相同的方式执行。手动流程中的错误可能需要高级人员的支持来解决问题。
- en: Configuration management
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: Configuration files that hold important information, such as client secrets
    and passwords, must be managed properly and must be kept with sync in other environments.
    Each environment may have different environment variables that must be used and
    passed into the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包含重要信息的配置文件，如客户端密钥和密码，必须得到妥善管理，并且必须在其他环境中保持同步。每个环境可能有不同的环境变量，必须被使用并传递到应用程序中。
- en: What does configuration management mean anyway?
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理到底意味着什么？
- en: Configuration management can be briefly described as the process by which all
    software artifacts that are pertinent to each given project—as well as any relationships
    between the software artifacts—are retrieved, stored, identified, and modified.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理可以简要描述为检索、存储、识别和修改与每个给定项目相关的所有软件工件以及软件工件之间的任何关系的过程。
- en: Version control
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: Version control is the means of keeping revisions between all software artifacts.
    Version control is very important to configuration management as any changes to
    files that contain environment files should be under version control.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是保持所有软件工件之间修订的手段。版本控制对于配置管理非常重要，因为任何包含环境文件的文件的更改都应该在版本控制下。
- en: Tony, a member of the development team, has been using a properties file that
    has not been put under source control and has been making changes to the **single
    sign-on** (**SSO**) flow in the product. Tony accidentally deletes the file and
    loses all the client IDs and secrets that are necessary during the SSO flow. Tony
    must now go to different API portals and regenerate the client secret for some
    of the properties, as they are only shown once during creation, and now he must
    notify other members of the team to update their properties files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼是开发团队的一员，他一直在使用一个未纳入源代码控制的属性文件，并且一直在对产品中的单点登录（SSO）流程进行更改。托尼不小心删除了文件，并且丢失了在SSO流程中必要的所有客户端ID和密钥。现在，托尼必须去不同的API门户，并重新生成一些属性的客户端密钥，因为它们在创建时只显示一次，现在他必须通知团队的其他成员更新他们的属性文件。
- en: Example properties file
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例属性文件
- en: 'I have added a sample properties file that has client secret information and
    authentication secret information. This is necessary for the given environment
    to run properly but should not be checked into source control, it is here for
    demonstration purposes only:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了一个示例属性文件，其中包含客户端秘密信息和身份验证秘密信息。这对于给定的环境正常运行是必要的，但不应该检入源代码控制，这里仅用于演示目的。
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `TOKEN_SECRET` environment variable is only seen once, so if it is lost,
    then you must regenerate it in the API portal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`TOKEN_SECRET`环境变量只能看到一次，所以如果丢失了，那么你必须在API门户中重新生成它。'
- en: Version control management tools
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制管理工具
- en: 'Here is a list of version control management tools:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个版本控制管理工具的列表：
- en: '**Git** ([https://git-scm.com/](https://git-scm.com/)): Git is a distributed
    version control system'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git** ([https://git-scm.com/](https://git-scm.com/)): Git是一个分布式版本控制系统'
- en: '**Mercurial** ([https://www.mercurial-scm.org/](https://www.mercurial-scm.org/)):
    Mercurial is also a distributed version control system'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mercurial** ([https://www.mercurial-scm.org/](https://www.mercurial-scm.org/)):
    Mercurial也是一个分布式版本控制系统'
- en: '**Subversion** ([https://subversion.apache.org/](https://subversion.apache.org/)):
    Subversion is considered a centralized version control system'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Subversion** ([https://subversion.apache.org/](https://subversion.apache.org/)):
    Subversion被认为是一个集中式版本控制系统'
- en: '**Fossil** ([https://www.fossil-scm.org/](https://www.fossil-scm.org/)): Fossil
    is a distributed version control system like Git although lesser known'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fossil** ([https://www.fossil-scm.org/](https://www.fossil-scm.org/)): Fossil是一个分布式版本控制系统，类似于Git，尽管知名度较低'
- en: Version control practices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制实践
- en: An important practice is to keep everything that you possibly can under version
    control to avoid losing important work in a software product. Network files, configuration
    files, deployments scripts, database scripts, build scripts, and any other artifact
    that is important for your application to properly run should be under version
    control, or else you risk losing critical data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的做法是尽可能将所有东西都放在版本控制下，以避免在软件产品中丢失重要工作。网络文件、配置文件、部署脚本、数据库脚本、构建脚本以及任何其他对应用程序正常运行很重要的工件都应该在版本控制下，否则你会冒着丢失关键数据的风险。
- en: Conducting software check-ins often
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常进行软件检查
- en: It is important to do check-ins into your main branch often, or else you risk
    introducing breaking changes into your codebase. Additionally, frequent check-ins
    help developers stay mindful of bringing in small changes at any given time. Large
    sweeping changes to a codebase should be avoided as they are harder to test and
    can bring regressions. Frequent check-ins are also beneficial because breaking
    changes will be noticed much faster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 经常检查主分支非常重要，否则你会冒着在代码库中引入破坏性更改的风险。此外，频繁的检查可以帮助开发人员随时注意带入小的更改。应避免对代码库进行大规模的更改，因为这样更难测试并且可能会引起回归。频繁的检查也是有益的，因为破坏性更改会更快地被注意到。
- en: Writing descriptive and meaningful commit messages
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写描述性和有意义的提交消息
- en: Use descriptive commit messages that include issue tracking information, such
    as a Jira issue, for example, that clearly describe the intent of the commit.
    Avoid writing commit messages that are vague, such as `Fixed bug` or `Wrapped
    up`, as these types of commit messages are not useful and are not helpful to developers
    later on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包括问题跟踪信息的描述性提交消息，比如Jira问题，清楚地描述提交的意图。避免编写模糊的提交消息，比如`修复错误`或`完成`，因为这些类型的提交消息是没有用的，对开发人员以后也没有帮助。
- en: Here is a sample descriptive commit message [DEV-1003] added a new navigation
    link to the Parts Supply list. A test case for the new navigation was also added. This
    is clearly more descriptive. Additionally, in Jira, when you provide an issue
    such as DEV-1003, it will create a link in the Jira issue that references the
    work on this issue. Also, if you create a pull request and put `git commit` with
    the Jira issue, it will link your pull requests with the issue.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例描述性提交消息[DEV-1003]，添加了一个新的导航链接到零部件供应列表。还添加了一个新导航的测试用例。这显然更加描述性。此外，在Jira中，当你提供一个像DEV-1003这样的问题时，它会在Jira问题中创建一个引用此问题的链接。此外，如果你创建一个拉取请求并在`git
    commit`中放入Jira问题，它将把你的拉取请求与问题链接起来。
- en: Dependency management
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: It is common for applications to have third-party dependencies that are critical
    to the software product. Dependency management is an important part of any application
    and different programming languages handle dependency management differently.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常具有对软件产品至关重要的第三方依赖项。依赖管理是任何应用程序的重要部分，不同的编程语言以不同的方式处理依赖管理。
- en: Example Node.js dependency file and Gopkg.toml dependency file
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例Node.js依赖文件和Gopkg.toml依赖文件
- en: 'Here is a `Gopkg.toml` file that has version and package information for each
    dependency in the repository:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Gopkg.toml`文件，其中包含存储库中每个依赖项的版本和包信息。
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dependency management like this is important because third-party dependencies
    can easily bring breaking changes to an application, and API changes in a third-party
    dependency can break critical behavior in any running application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样管理依赖是很重要的，因为第三方依赖项很容易给应用程序带来破坏性更改，第三方依赖项中的API更改可能会破坏任何正在运行的应用程序中的关键行为。
- en: Managing software components
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理软件组件
- en: Usually, software projects will start with a monolithic build that has all the
    working components in one layer. As an application grows in size and maturity,
    the layers of an application will break into services or different layers and
    this is where having separate build pipelines becomes necessary. Perhaps an ID
    service is used for authentication in an application and perhaps an admin service
    is run in a separate build pipeline for an administrative portal. Microservices
    architecture is a continuation of this service level componentization of an application,
    where each microservice has a clear and focused purpose in an application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件项目将以单片构建开始，所有工作组件都在一个层中。随着应用程序的规模和成熟度的增长，应用程序的层将分解为服务或不同的层，这就是需要单独的构建流水线的地方。也许一个ID服务用于应用程序中的身份验证，也许一个管理服务在单独的构建流水线中运行用于管理门户。微服务架构是应用程序的服务级组件化的延续，其中每个微服务在应用程序中有一个清晰而专注的目的。
- en: Software configuration management
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件配置管理
- en: Configuration is an important part of any application and should be treated
    with the same level of care as your business-level logic that you use in your
    code. Configuration therefore needs to be properly managed and tested just like
    your source code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是任何应用程序的重要部分，应该像您在代码中使用的业务逻辑一样小心对待。因此，配置需要像源代码一样得到适当的管理和测试。
- en: Configurability and flexibility concepts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可配置性和灵活性概念
- en: At first thought, it may seem appropriate to make configuration as flexible
    as you can. *Why not make a system as flexible as possible, and allow it to adapt
    to any type of environment?* This is commonly known as an anti-pattern of *ultimate
    configurability*, meaning that a configuration can behave like a programming language
    and can be made to behave in any manner. Configuration management done in this
    way can bring a software project to its knees as its users will come to expect
    such flexibility as necessary. It is more useful to set some constraints in place
    for your configuration management. Constraints can help rein in the effects of
    too much flexibility in a configured environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一想，似乎将配置尽可能灵活是合适的。*为什么不尽可能地使系统灵活，并允许它适应任何类型的环境呢？*这通常被称为*终极可配置性*的反模式，意味着配置可以像编程语言一样行为，并且可以被制作成任何方式。以这种方式进行的配置管理可能会使软件项目陷入困境，因为其用户将期望这种灵活性是必要的。为您的配置管理设置一些约束更有用。约束可以帮助控制配置环境中过度灵活性的影响。
- en: Specific types of configuration
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定类型的配置
- en: 'Here is a list of possible types of configuration that an application can utilize:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序可以利用的可能类型的配置列表：
- en: 'Configuration can be pulled and incorporated into application binaries at **build
    time**:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可以在**构建时间**中被拉取并合并到应用程序二进制文件中：
- en: Languages such as C/C++ and Rust can do such build-time configuration
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像C/C++和Rust这样的语言可以进行构建时配置
- en: 'Configuration can be injected at **package time** when creating assemblies
    or gems:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建组件或gems时，配置可以在**打包时间**注入：
- en: Languages such as C#, Java, and Ruby can use such configuration options
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像C#、Java和Ruby这样的语言可以使用这样的配置选项
- en: 'Configuration can be done at **deployment time **meaning a deployment script
    or installer can fetch any necessary information as needed, or the deployment
    script can ask a user to pass such information:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可以在**部署时间**进行，意味着部署脚本或安装程序可以根据需要获取任何必要的信息，或者部署脚本可以要求用户传递这样的信息：
- en: We will look at this later in the book with the Jenkins, Travis, and CircleCI
    tools
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本书的后面使用Jenkins、Travis和CircleCI工具进行讨论
- en: 'Configuration can be done at **startup time or** **runtime**,meaning when an
    application is launching:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可以在**启动时间或** **运行时**进行，意味着应用程序启动时：
- en: Languages like Node.js often inject environment variables when a Node.js server
    is running
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Node.js这样的语言在Node.js服务器运行时通常会注入环境变量
- en: Configuration management across applications
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨应用程序的配置管理
- en: 'Configuration management becomes more complicated when you take configuration
    across different applications. There are tools that can help with configuration
    across application boundaries, and here is a list of such tools:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当您跨不同应用程序进行配置时，配置管理变得更加复杂。有一些工具可以帮助跨应用程序边界进行配置，以下是这样的工具列表：
- en: CFEngine ([https://cfengine.com/](https://cfengine.com/))
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CFEngine ([https://cfengine.com/](https://cfengine.com/))
- en: Puppet ([https://puppet.com/](https://puppet.com/))
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet ([https://puppet.com/](https://puppet.com/))
- en: Chef ([https://www.chef.io/chef/](https://www.chef.io/chef/))
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef ([https://www.chef.io/chef/](https://www.chef.io/chef/))
- en: Ansible ([https://www.ansible.com/](https://www.ansible.com/))
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible ([https://www.ansible.com/](https://www.ansible.com/))
- en: Docker with Kubernetes ([https://www.docker.com/](https://www.docker.com/))
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker with Kubernetes ([https://www.docker.com/](https://www.docker.com/))
- en: Environment management
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境管理
- en: The hardware, software, infrastructure, and any external systems that an application
    depends on can be thought of as the environment of the application. The creation
    of any environment should be done in a fully automated manner because the ability
    to reproduce an environment is important, as we will illustrate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序依赖的硬件、软件、基础设施和任何外部系统可以被视为应用程序的环境。任何环境的创建都应该以完全自动化的方式进行，因为能够复制环境是重要的，我们将会说明。
- en: Manual environment setup
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动环境设置
- en: 'The manual setup of infrastructure can be problematic for several reasons:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 手动设置基础设施可能会出现几个问题：
- en: A manually set up server instance may be configured to suit a single operations
    person. This operations person may be gone from an organization, leaving core
    infrastructure broken.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动设置的服务器实例可能被配置以适应单个运维人员。这个运维人员可能已经离开组织，导致核心基础设施破损。
- en: Fixing a manually set up environment may take a long time, and fixing issues
    in such an environment is not reproducible and repeatable, for that matter.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复手动设置的环境可能需要很长时间，而在这样的环境中解决问题是不可重现和可重复的。
- en: Manually setup environments may not be capable of being copied for testing purposes.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动设置的环境可能无法复制以进行测试。
- en: Important configuration information for environments
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境的重要配置信息
- en: 'Here is a list of important configuration information that all environments
    need:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所有环境都需要的重要配置信息列表：
- en: Third-party dependency and software packages that need to be installed on each
    environment
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在每个环境上安装的第三方依赖和软件包
- en: Networking topology information
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拓扑信息
- en: External services necessary for an application to run, such as a database service
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序运行所需的外部服务，如数据库服务
- en: Application data or seed data to get a fresh environment set up and running
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序数据或种子数据，以便设置和运行新环境
- en: Containerized environments
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化环境
- en: Tools such as Docker and Kubernetes have risen in popularity because of their
    ability to isolate environment-level information and to create reproducible/repeatable
    environments. Using Docker, you can declare all of your external services, such
    as Redis and MongoDB.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 像Docker和Kubernetes这样的工具因其隔离环境级别信息和创建可重现/可重复环境的能力而变得越来越受欢迎。使用Docker，您可以声明所有外部服务，如Redis和MongoDB。
- en: 'Here is an example of `docker-compose` YML script for the API workshop repo
    ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是API研讨会存储库（[https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)）的`docker-compose`
    YML脚本示例：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have declared a database as well as a caching service (Redis) and an API
    that all run as an isolated container, all of which can have environment-level
    information such as environment variables, that can be configured separately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个数据库，以及一个缓存服务（Redis）和一个API，它们都作为独立的容器运行，所有这些都可以具有环境级别的信息，比如环境变量，可以单独配置。
- en: Deployment pipeline
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署管道
- en: We spoke about the importance of CI in [Chapter 2](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml),
    *Basics of Continuous Integration*, and while CI is an important productivity
    enhancer, it is mainly useful for development teams. It is common to see bottlenecks
    in software life cycles with QA and operations teams when waiting for fixes or
    updated documentation. QA can be left waiting for a good build by the development
    team. Development teams may also receive bug reports many weeks after they have
    completed a new feature. All of these situations lead to non-deployable software,
    which ultimately leads to software that you cannot deliver to your end users.
    Creating push button deployment builds that can be deployed to testing, staging,
    and production environments can help alleviate such issues, as we noted previously.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](1f431ec3-84d5-4132-b542-01d1fe63a205.xhtml)中谈到了CI的重要性，*持续集成的基础知识*，虽然CI是一个重要的生产力增强器，但它主要对开发团队有用。在等待修复或更新文档时，软件生命周期中常见的瓶颈是QA和运维团队。QA可能需要等待开发团队的良好构建。开发团队可能在完成新功能后的几周内收到错误报告。所有这些情况都会导致无法部署的软件，最终导致无法交付给最终用户的软件。创建可以部署到测试、分级和生产环境的一键式部署构建可以帮助缓解这些问题，正如我们之前所指出的。
- en: What is a deployment pipeline?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署管道是什么？
- en: A deployment pipeline can be thought of as end-to-end automation of build, deploy,
    test, and release processes. A deployment pipeline can also be thought of as the
    process for getting software that is written by developers into the hands of your
    users.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 部署管道可以被认为是构建、部署、测试和发布过程的端到端自动化。部署管道也可以被认为是将开发人员编写的软件交到用户手中的过程。
- en: Deployment pipeline practices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署管道实践
- en: In this section, we will discuss some deployment pipeline practices to follow,
    such as building binaries once, handling deployments the same way in each environment,
    and making a commit stage in a deployment pipeline.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些部署管道实践，比如只编译一次二进制文件，以相同的方式处理每个环境中的部署，并在部署管道中设置提交阶段。
- en: Building binaries once
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只编译一次二进制文件
- en: 'Binaries that are compiled multiple times can be problematic for several reasons:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多次编译的二进制文件可能会出现问题，原因有几个：
- en: Binaries can have different contexts at each run, which will introduce unpredictability
    to your system
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制文件在每次运行时可能具有不同的上下文，这会给系统引入不可预测性
- en: Statically compiled languages, such as C/C++, can have different compiler versions
    on each run
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态编译语言，如C/C++，每次运行可能具有不同的编译器版本
- en: Third-party software may have different version specified on different compilation
    execution contexts
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方软件可能在不同的编译执行上下文中指定不同的版本
- en: Compiling binaries multiple times also leads to an inefficient deployment pipeline
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多次编译二进制文件也会导致低效的部署管道
- en: Recompiling binaries can also be time consuming
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编译二进制文件也可能很耗时
- en: It is better to compile binaries once during compile time if you can do so.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以的话，最好在编译时只编译一次二进制文件。
- en: Deployment should be done the same way in every environment
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在每个环境中应该以相同的方式进行部署
- en: Developers commonly deploy their software all the time when you consider a CI
    build that runs on each source code check-in. QA/testers will not deploy as often,
    and operations even less so. Deploying to a production environment will be done
    much less frequently than for a development environment, and for good reason.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到每次源代码检入时都会运行CI构建，开发人员通常会经常部署他们的软件。QA/测试人员不会那么频繁地部署，运维人员更少。与开发环境相比，部署到生产环境的频率要低得多，这是有充分理由的。
- en: A deployment script should be created that can be run for development, staging,
    and production environments. Any changes that are necessary in each environment
    can be managed with a properties files that is managed in version control. You
    can use, for example, an environment variable in the deployment script to differentiate
    the different environments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应该创建一个部署脚本，可以在开发、分级和生产环境中运行。每个环境中需要的任何更改都可以通过在版本控制中管理的属性文件来管理。例如，您可以在部署脚本中使用环境变量来区分不同的环境。
- en: Commit stage – first step of the deployment pipeline
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交阶段-部署管道的第一步
- en: The first stage of a deployment pipeline is the commit stage or whenever developers
    check in code to version control. As soon as code is checked in to a CI build
    pipeline, the build pipeline should compile any code if necessary, run a suite
    of unit tests (hopefully some exist) and integration tests, create any binaries
    if needed for the deployment pipeline later on, run static analysis tooling to
    check the health of the codebase, and prepare any build artifacts needed later
    for the deployment pipeline.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 部署流水线的第一个阶段是提交阶段，或者说是开发人员将代码提交到版本控制时。一旦代码提交到CI构建流水线，构建流水线应该在必要时编译任何代码，运行一套单元测试（希望有一些存在）和集成测试，如果需要为后续部署流水线创建任何二进制文件，则创建任何二进制文件，运行静态分析工具来检查代码库的健康状况，并准备后续部署流水线所需的任何构建工件。
- en: There are some other metrics that are important for the commit stage build to
    look at, such as code coverage, duplication in the code base, cyclomatic complexity
    (measures the complexity in codebase), monitoring a large number of warning messages,
    and code style (usually reported by a linting tool).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段构建的其他重要指标包括代码覆盖率、代码库中的重复代码、圈复杂度（衡量代码库中的复杂性）、监控大量警告消息以及代码风格（通常由代码检查工具报告）。
- en: If the commit build stage passes, then we can think of it as the first gate
    to pass through, albeit an important one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交构建阶段通过，那么我们可以将其视为通过的第一个关卡，尽管这是一个重要的关卡。
- en: Test gates
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试关卡
- en: In extreme programming, developers create acceptance tests that serve as functional-level
    tests that test a certain aspect of a software system. An example would be a user
    logging in to a system and a user logging out of a system. Another example would
    be a user going to their profile and updating information. Such tests are much
    broader than unit and integration tests and so they uncover system-level issues
    if they exist.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在极限编程中，开发人员创建验收测试，这些测试作为功能级别的测试，测试软件系统的某个方面。例如，用户登录系统和用户退出系统。另一个例子是用户访问其个人资料并更新信息。这些测试比单元测试和集成测试要广泛得多，因此如果存在系统级问题，它们会揭示出来。
- en: Acceptance tests build stage
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试构建阶段
- en: Running a suite of acceptance tests should be the second gate of a deployment
    pipeline. The acceptance tests also serve as a regression test suite to verify
    that new features have not been introduced into the system. During this stage,
    any test failures that occur in the acceptance test suite need to be evaluated
    on a case-by-case basis. The failure may be due to intentional behavior changes
    in the system, and so the acceptance test suite needs to be updated or the failure
    may represent a regression that needs to be addressed. Either way, the acceptance
    test suite must be fixed as soon as possible. The acceptance tests act as another
    gate in order for the deployment pipeline to progress down the line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一套验收测试应该是部署流水线的第二个关卡。验收测试还充当回归测试套件，以验证新功能是否已引入系统。在此阶段，验收测试套件中发生的任何测试失败都需要逐案评估。失败可能是由于系统中的有意行为更改，因此需要更新验收测试套件，或者失败可能代表需要解决的回归。无论哪种情况，都必须尽快修复验收测试套件。验收测试充当了部署流水线继续前进的另一个关卡。
- en: Manual testing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试
- en: Acceptance tests do provide a level of assurance that a system behaves as it
    should, but only a human can detect anomalies in a system. QA/testers can perform
    user-level testing of a system to ensure the proper usability of a system. The
    testers can also perform exploratory testing of a system. The automated acceptance
    test suite helps free up time for the testers to perform this higher-value testing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试确实提供了系统行为应该如何的一定程度的保证，但只有人类才能发现系统中的异常。质量保证/测试人员可以对系统进行用户级测试，以确保系统的正确可用性。测试人员还可以对系统进行探索性测试。自动化验收测试套件有助于释放测试人员的时间，以进行这种更高价值的测试。
- en: Nonfunctional testing
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能测试
- en: Nonfunctional testing is aptly named because these types of tests are not functional
    requirements of a system. Instead, nonfunctional tests test things such as capacity
    and security in a system. Failures in this step of the deployment pipeline may
    not need to mark a build as a failure but can simply serve as decision-making
    metrics on a build.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能测试的命名恰如其分，因为这些类型的测试不是系统的功能要求。相反，非功能测试测试系统中的容量和安全性等方面。在部署流水线的这一步中，失败可能不需要将构建标记为失败，而只是作为构建的决策指标。
- en: Release preparation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布准备
- en: There is always an associated risk when conducting a release, and so it is best
    to have processes in place when conducting a software release. Problems that occur
    during a release will be prevented but they can be mitigated by having processes
    set up during a release.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 进行发布时总会伴随一定的风险，因此最好在进行软件发布时建立相应的流程。发布过程中出现的问题可以通过建立流程来预防或减轻。
- en: 'Here are some possible steps to follow during a release:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布过程中可能要遵循的一些步骤如下：
- en: Create a release plan that both involves and is created by everyone involved
    in delivering a product
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个涉及并由所有参与产品交付的人员共同创建的发布计划
- en: Automate as much of the release process as possible to prevent mistakes
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能自动化发布流程，以防止错误发生
- en: Releases should be rehearsed often in production like environments to help debug
    possible issues that may occur
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中经常排练发布，以帮助调试可能出现的问题
- en: Set up processes to migrate any production data that is being used and to migrate
    configuration information in case of a rollback (reverting a release back a version)
    or upgrading a system
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立流程，以迁移正在使用的任何生产数据，并在回滚（将发布回滚到上一个版本）或升级系统时迁移配置信息
- en: Automating release processes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布流程
- en: Try to automate as much of a release process as you can, as the more automation
    in place, the more control you have over the release process. Manual steps tend
    to be error prone and can lead to unexpected outcomes. Any changes that occur
    in a production environment need to be locked down properly, meaning changes are
    done via automated processes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量自动化尽可能多的发布流程，因为自动化越多，您对发布流程的控制就越多。手动步骤往往容易出错，并可能导致意外结果。在生产环境中发生的任何更改都需要得到适当的锁定，这意味着更改是通过自动化流程完成的。
- en: Conducting rollbacks
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行回滚
- en: Release days tend to be stressful because mistakes that occur during the release
    process can create hard-to-detect issues, or the new system that is being released
    may have defects. Rehearsing releases can help mitigate such issues and can help
    people quickly solve issues that they may encounter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 发布日往往会很紧张，因为在发布过程中发生的错误可能会导致难以检测的问题，或者正在发布的新系统可能存在缺陷。排练发布可以帮助减轻这些问题，并可以帮助人们快速解决可能遇到的问题。
- en: The best strategy is to have a previous version of a software system ready before
    the release and after the release in case you have to roll back the system to
    a previous version; this excludes any necessary data migration or configuration.
    As another viable alternative, you can redeploy a known good version of an application.
    The rollback should be able to be done at a click of a button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布之前和发布之后，最佳策略是准备好软件系统的先前版本，以防需要将系统回滚到先前版本；这不包括任何必要的数据迁移或配置。作为另一种可行的选择，您可以重新部署已知的良好版本的应用程序。回滚应该能够通过点击按钮完成。
- en: Deployment scripting
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署脚本
- en: Deployment scripting is necessary because the software written by development
    teams is not just run on their IDE or local environment but instead needs to be
    run during the deployment pipeline. Deployment scripting refers to the particular
    build tooling you use to write scripts for the deployment pipeline.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 部署脚本是必要的，因为开发团队编写的软件不仅在他们的IDE或本地环境中运行，而是需要在部署流水线期间运行。部署脚本是指您用于编写部署流水线脚本的特定构建工具。
- en: Overview of build tools
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工具概述
- en: 'There are already many build tools, and each come with their own pros and cons. Here
    is a small list of build tools:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有许多构建工具，每个都有其优缺点。以下是一小部分构建工具的列表：
- en: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)):
    Make is a language-agnostic build tool that has been used for a long time'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Make** ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))：Make是一种与语言无关的构建工具，已经使用了很长时间'
- en: '**Maven** ([https://maven.apache.org/](https://maven.apache.org/)): Maven is
    a build tool primarily used for Java projects'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven** ([https://maven.apache.org/](https://maven.apache.org/))：Maven是主要用于Java项目的构建工具'
- en: '**MSBuild** ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)): MSBuild
    is a build tool primarily used for the .NET family of programming languages'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSBuild** ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild))：MSBuild是主要用于.NET编程语言系列的构建工具'
- en: '**Rake** ([https://ruby.github.io/rake/](https://ruby.github.io/rake/)): Rake
    is a Make-like build tool that was originally intended for Ruby'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rake** ([https://ruby.github.io/rake/](https://ruby.github.io/rake/))：Rake是一个类似于Make的构建工具，最初是为Ruby而设计的'
- en: '**Gulp.js** ([https://gulpjs.com/](https://gulpjs.com/)): A build tool that
    is used for frontend web development'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gulp.js** ([https://gulpjs.com/](https://gulpjs.com/))：用于前端网页开发的构建工具'
- en: '**Stack** ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)): A
    build tool that is used for Haskell environments'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stack** ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/))：用于Haskell环境的构建工具'
- en: Deployment scripting concepts
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署脚本概念
- en: Regardless of whatever build tool you use, you need to follow certain practices
    when conducting deployment scripting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用什么构建工具，进行部署脚本时都需要遵循某些实践。
- en: Writing a script for each stage in the deployment pipeline
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为部署流水线的每个阶段编写脚本
- en: During the commit stage of a deployment pipeline, you will have actions that
    the deployment script will need to do. For example, you might need to compile
    any source files, run a suite of unit and integration tests, and run a linting
    tool that checks code style and perhaps a static analysis tool. All of these steps
    might require using different tools, so writing a script that does all of this
    is best. Depending on the particular actions of the script, you might want to
    further break down a script into subscripts that perform focused actions. During
    the acceptance test stage, your script might run the entire acceptance test suite
    and additionally generate some reports and metrics about the tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署流水线的提交阶段，您将需要部署脚本执行的操作。例如，您可能需要编译任何源文件，运行一套单元和集成测试，并运行一个检查代码风格和静态分析工具的代码检查工具。所有这些步骤可能需要使用不同的工具，因此编写一个执行所有这些操作的脚本是最好的。根据脚本的特定操作，您可能希望进一步将脚本分解为执行专注操作的子脚本。在验收测试阶段，您的脚本可能会运行整个验收测试套件，并额外生成一些关于测试的报告和指标。
- en: Every environment should use the same scripts
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个环境应该使用相同的脚本
- en: You should use the same exact script in all the environments, as this will ensure
    that the build and deployment process is being done the same way in each environment.
    If you have a different script for each environment, then you cannot ensure that
    the particular script being run is behaving the same way in a different environment.
    The deployment scripts that developers run in their local environments should
    be the same as those run in other environments, or else you risk environment leakage.
    What we mean here is that the developers environment might have specific environment
    variables set than the deployment script or each environment, such as development,
    staging, and production, might have different environment variables set, which
    will make debugging harder when issues arise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The deployment process should not change on each run
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deployment process should remain the same on each run that is done. In mathematics,
    there is a term called **idempotent**, which basically states a certain operation
    can be done multiple times with the same outcome. If your deployment process changes
    on any given run then you cannot guarantee the behavior of each run, which in
    turn will make troubleshooting much more difficult.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Deployment scripting best practices
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section discusses deployment scripting best practices, such as making sure
    to test only known good foundations, testing environment configuration, using
    relative paths, and removing manual processes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Testing only known good foundations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should not be testing source code that cannot even compile and you should
    not bother to run any acceptance tests when the unit and integration tests are
    failing. Basically, there must exist a known good baseline for any of the additional
    stages of the deployment process to be run and to continue.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Testing the environment configuration
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the deployment pipeline is going through each stage and subsequently passes
    through each stage, it is good to check that the respective stage is functioning
    correctly. The tests you do for the associated stage can be thought of as **smoke**
    tests. For example, checking that a website is up and running by accessing the
    URL, and checking that a record in a database can still be fetched.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Using relative paths
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to use relative paths over absolute paths. A developer might have
    a certain filesystem or folder structure that does not exist in the environment
    where the deployment pipeline is running, so it is best to use relative paths
    so as not to create unintended breakages. It may be difficult at times to do this,
    but it is best to follow it as much as you can. Docker containers can map folder
    structures for each container; for example, if a Docker container is spawned on
    a particular part of the deployment pipeline, it can be mapped to a certain relative
    folder structure as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Removing manual processes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid making build scripts that contain a list of steps you must do to finish
    a particular part of a deployment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of possible steps in a manual process:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Copy all of the images from the root of the project into the `static/build`
    folder
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a manual migration of data on a new production release
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If someone has to SSH into a box and run a script, this could be problematic
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any steps that must be done manually can quickly become out of date in a document,
    so the easiest instruction to follow is, if you have to do an action a second
    time, to make an automated process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Deployment ecosystem
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly go over some tools that can help you in your
    deployment pipeline and that serve different purposes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure tooling
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly mentioned Chef earlier in the chapter; Chef is a great tool to use
    to automate standing up infrastructure in a reliable manner. It is difficult without
    the proper tools to make sure that each new environment that you set up is done
    in the same manner. Potentially, you could create new environments that have different
    configurations, which can be very problematic when troubleshooting.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Cloud providers and tooling
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three main cloud providers all have their own associated tooling:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS** ([https://aws.amazon.com/](https://aws.amazon.com/)): AWS has a suite
    of tools for CI/CD:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeCommit** is a fully managed source control service. For more information,
    refer to [https://aws.amazon.com/codecommit/](https://aws.amazon.com/codecommit/).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeDeploy** is a service that automates software deployments to a variety
    of compute services, including Amazon EC2, AWS Lambda, and instances running on-premises.
    For more information, refer to [https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure** ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)):
    Visual Studio Team Services is an end-to-end CI/CD service. For more information,
    refer to [https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google App Engine** ([https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/)):
    Google App Engine is more agnostic than the other cloud providers.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Jenkins, Travis, and CircleCI/CD tooling with all of the major cloud
    providers, although Microsoft Azure and AWS have created their own CI/CD tooling
    that you can use as well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD, as we have seen, centers around the concept of automation. Throughout this
    chapter, we have learned about what delivering software means. We first examined
    the common issues that arise when delivering software. We also discussed configuration
    management in detail and the roles that version control and dependency management
    play in any configuration. We also looked at the deployment pipeline and took
    an in-depth look at the different build stages. In the deployment scripting section,
    we looked at some build tools that exist and set some best practices to follow.
    Lastly, we briefly looked at the deployment ecosystem and some of the cloud providers.
    In the next chapter, we will discuss the problems of communication among different
    teams, how to communicate pain points to other team members, sharing responsibility
    among different teams, demonstrating to stakeholders why CI/CD is important, and
    how to get approval for CI/CD with business stakeholders.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we mean by delivering software?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some common release anti-patterns.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some benefits of automation when delivering software.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does configuration management even mean?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you write descriptive and meaningful commit messages?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deployment pipeline?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should deployment be done the same way in each environment?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider reading the book *DevOps: Continuous Delivery, Integration, and Deployment
    with DevOps*, by *Packt Publishing*, to get a more in-depth understanding of CD.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL

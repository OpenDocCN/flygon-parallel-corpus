- en: '*Chapter 10*: Mesh Skinning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deforming a mesh to match an animated pose is called skinning. In order to
    implement skinning, you first need to declare a mesh class. Once you have declared
    a mesh class, it can be deformed using a shader (GPU skinning) or just with C++
    code (CPU skinning). Both of these skinning methods are covered in this chapter.
    By the end of this chapter, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how a skinned mesh is different from a non-skinned mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the entire skinning pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a skeleton class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the bind pose of a skeleton from a glTF file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a skinned mesh class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load skinned meshes from a gLTF file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement CPU skinning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement GPU skinning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A mesh is made up of several vertices. Normally, each vertex has at least a
    position, a normal, and maybe a texture coordinate. This is the definition of
    a vertex for a simple static mesh. This definition has the following vertex components:'
  prefs: []
  type: TYPE_NORMAL
- en: The position (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The normal (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The texture coordinate (`vec2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important information:'
  prefs: []
  type: TYPE_NORMAL
- en: The model used to demonstrate skinning in this chapter is the Godot mannequin
    from GDQuest. It's an MIT-licensed model and you can find it on GitHub a[t https://github.com/GDQuest/godot-3d-mannequ](https://github.com/GDQuest/godot-3d-mannequin)in.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a mesh is modeled, it''s modeled in a certain pose. For characters, this
    is often a *T* pose or an *A* pose. The modeled mesh is static. The following
    figure shows the *T* pose for the Godot mannequin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The Godot mannequin''s T pose'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: The Godot mannequin''s T pose'
  prefs: []
  type: TYPE_NORMAL
- en: Once a mesh is modeled, a skeleton is created in the mesh. Each vertex in the
    mesh is assigned to one or more bones of the skeleton. This process is called
    rigging. The skeleton is created in a pose that fits inside the mesh; this is
    the **bind pose** of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Visualizing the bind pose of the mesh and skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Visualizing the bind pose of the mesh and skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: The bind pose and the rest pose are usually the same, but that is not always
    the case. In this book, we will treat the two as separate poses. The preceding
    figure shows the bind pose of the skeleton rendered on top of the character mesh.
    In the next section, you will explore how a mesh such as this can be skinned.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding skinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skinning is the process of specifying which vertex should be deformed by which
    bone. One vertex can be influenced by multiple bones. Rigid skinning refers to
    associating each vertex with exactly one bone. Smooth skinning associates vertices
    with multiple bones.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the vertex-to-bone mapping is done per vertex. This means each vertex
    knows which bones it belongs to. Some file formats, store this relationship in
    reverse, where each bone contains a list of vertices it affects. Both approaches
    are valid; throughout the rest of this book, the mapping is done per vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'To (rigid) skin a mesh, assign each vertex to a bone. To assign a joint to
    a vertex in code, add a new attribute to each vertex. This attribute is just an
    integer that holds the index of the bone that deforms the vertex. In the following
    figure, all the triangles that should be assigned to the lower-left arm bone are
    colored darker than the rest of the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Isolating the lower arm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: Isolating the lower arm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a second to review the vertex transformation pipeline in a little
    more detail. Here, the concept of **space** is introduced. Space refers to transforming
    a vertex by a matrix. For example, if you have a projection matrix, it would transform
    a vertex into NDC space. The vertex transformation pipeline is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When a mesh is created, all its vertices are in what is called model space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model space vertex is multiplied by the model matrix, which puts it into world
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A world space vertex is multiplied by the view matrix to put it into camera
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A camera space vertex is multiplied by the projection matrix to move it into
    NDC space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To skin a mesh, a new skinning step needs to be added to the vertex transformation
    pipeline. The skinning step moves the vertex from skin space to model space. This
    means the new step comes before any other steps in the transformation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skin space vertices can be moved back into model space if they are multiplied
    by the current animation pose. This transformation is covered in detail in the
    *Implementing CPU skinning* section of this chapter. Once the vertex is back in
    model space, it should already be animated. The animation pose matrix transformation
    does the actual animation. An animated vertex transformation pipeline works like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: A mesh is loaded—all of its vertices are in model space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model space vertex is multiplied by the skin matrix to move it into skin space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kin space vertex is multiplied by the pose matrix to move it back into model
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model space vertex is multiplied by the model matrix, which puts it into world
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A world space vertex is multiplied by the view matrix to put it into camera
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A camera space vertex is multiplied by the projection matrix to move it into
    NDC space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To skin a mesh, each vertex needs to be transformed into skin space. When a
    vertex in skin space is transformed by the world transform of the joint it belongs
    to, the vertex should end up in model space, assuming the pose that is used is
    the bind pose.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will explore the skinning pipeline with practical
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring rigid skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To skin a mesh, each vertex needs to be multiplied by the inverse bind pose
    transform of the joint it belongs to. To find the inverse bind pose transform
    of a joint, find the world transform of the joint, then invert it. When a matrix
    (or transform) is multiplied by its inverse, the result is always identity.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying the vertices of a skin space mesh by the world space transformation
    of a joint in bind pose undoes the original inverse bind pose multiplication,
    `inverse bind pose * bind pose = identity`. However, multiplying by a different
    pose results in the vertices being offset from the bind pose by the delta between
    the two poses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how a vertex is moved into skin space visually. For example,
    multiplying all the vertices in the Godot mannequin forearm by the inverse bind
    pose of the forearm bone puts only the forearm triangles into skin space. This
    leaves the mesh looking as it does in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The lower-arm mesh transformed by the inverse bind pose'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: The lower-arm mesh transformed by the inverse bind pose'
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the vertices from skin space back to model space, apply the transformation
    of each bone in the pose sequentially until the target bone is reached. The following
    figure demonstrates the six steps that need to be taken from the root bone to
    the forearm bone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Visualizing the transform chain to the lower arm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Visualizing the transform chain to the lower arm'
  prefs: []
  type: TYPE_NORMAL
- en: In code, all the transforms that need to be taken to reach a bone can be accumulated
    using matrix multiplication. Alternatively, if you use the `Transform` structs,
    you can use the combine method. Moving the vertex back into model space is done
    only once with the accumulated matrix or transform.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the mesh into skin space is done by multiplying each vertex by
    the inverse bind pose of the joint it belongs to. How can you get the inverse
    bind pose matrix of a bone? Using the bind pose, find the world transform of the
    bone, turn it into a matrix, and invert the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the Godot mannequin in skin space. Seeing a mesh
    such as this indicates an error in the skinning pipeline. The most common reason
    for seeing a mesh such as this is that there has been an error in the multiplication
    order of the inverse bind pose and animated pose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: The full mesh multiplied by the inverse bind pose'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: The full mesh multiplied by the inverse bind pose'
  prefs: []
  type: TYPE_NORMAL
- en: The skinning implementation discussed so far is called rigid skinning. With
    rigid skinning, each vertex is influenced by only one bone. In the following section,
    you will begin to explore smooth skinning, which makes skinned meshes look better
    by assigning multiple bone influences to a single vertex.
  prefs: []
  type: TYPE_NORMAL
- en: The rigid skinning pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore the pipeline that each vertex must go through. The following
    figure shows the transformation pipeline of a static mesh compared to a rigid
    skinned mesh. The order of steps in the following diagram is left to right, following
    the arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: The vertex skinning pipelines'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: The vertex skinning pipelines'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **rigid skinned vertex pipeline** shown in the preceding figure works as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the vertex into skin space by multiplying it by the inverse bind pose matrix
    of the joint it is assigned to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply the skinned vertex by the animated joint's world matrix. This results
    in the vertex being in local space again, but it is deformed to the animated pose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the vertex is in the animated local position, put it through the normal
    model view projection transformation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring smooth skinning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with rigid skinning is bending joints. Since each vertex belongs
    to one bone, vertices that are in joints such as the elbow do not bend naturally.
    Breaks in a mesh at joints such as in the elbow can be avoided by assigning different
    vertices of a triangle to different bones. The resulting mesh doesn't maintain
    its volume well and looks awkward.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid skinning isn't free; it introduces additional matrix multiplications to
    each vertex. This can be optimized down to just one additional multiplication,
    which is covered in the next chapter. In the following section, you will explore
    smooth skinning.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring smooth skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary problem with rigid skinning is that it can create visual breaks
    in a mesh, as shown in the following figure. Even if these artifacts are addressed,
    deformation around bendable joints does not look good when smooth-skinned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: A visible artifact of rigid skinning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: A visible artifact of rigid skinning'
  prefs: []
  type: TYPE_NORMAL
- en: Smooth skinning has fewer artifacts and maintains its volume better than rigid
    skinning. The idea behind smooth skinning is that more than one bone can influence
    a vertex. Each influence also has a weight. The weight is used to blend the skinned
    vertices into a combined, final vertex. All weights must add up to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Think of smooth skinning as skinning a mesh multiple times and blending the
    results. How many influences a bone can have has a big impact here. Generally,
    after four bones, the influence of each additional bone is not visible. This is
    convenient as it lets you use the `ivec4` and `vec4` structs to add influences
    and weights to vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a mesh that is skinned with the middle vertices
    attached to the top bone on the left and the bottom bone on the right. These are
    the two skinned positions that need to be blended. If each pose has a weight of
    `0.5`, the final interpolated vertex position will be halfway between the vertices.
    This is shown in the middle diagram of the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Assigning multiple joints to a vertex'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Assigning multiple joints to a vertex'
  prefs: []
  type: TYPE_NORMAL
- en: Averaging joint influences on a vertex is called smooth skinning, or **linear
    blend skinning** (**LBS**). It has a few artifacts, but it's the standard way
    to skin characters. Currently, LBS is the most popular way to implement skinned
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding support for smooth skinning, the final vertex structure now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The position (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The normal (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The texture coordinate (`vec2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The joint influences (`ivec4`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The influence weights (`vec4`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: glTF supports attaching skinned meshes to arbitrary nodes and those nodes can
    be animated. This adds an extra step to calculating the skin matrix. To avoid
    this extra step, we will ignore the mesh pivot and assume that all the mesh node
    global transforms are at the origin. This is a safe assumption to make so long
    as a single glTF file is assumed to only contain one skinned mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Smooth skinning is currently the standard form used in game animation. Most
    games use four bones per vertex and work similarly to what you will implement
    in this chapter. In the following section, you will implement a `Skeleton` class
    to help keep track of some of the different data needed to skin a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing skeletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When animating a model, there are several things to keep track of, such as the
    animated pose or inverse bind pose. The concept of a skeleton is to combine data
    that is shared between animated models into a single structure.
  prefs: []
  type: TYPE_NORMAL
- en: Both the bind pose and inverse bind pose are shared among all instances of a
    character. That is, if there are 15 characters on screen, each of them has a unique
    animated pose, but they all share the same rest pose, bind pose, inverse bind
    pose, and joint names.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will implement a new class—the `Skeleton` class.
    This `Skeleton` class contains all the shared data that two animated meshes might
    need. It also keeps track of the rest pose, bind pose, inverse bind pose, and
    joint names. Some engines call the skeleton an armature or a rig.
  prefs: []
  type: TYPE_NORMAL
- en: The Skeleton class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Skeleton` class contains the rest pose and bind pose of a character, the
    name for every joint of the character, and—most importantly—the inverse bind pose.
    Since the inverse bind pose involves inverting matrices, it should only be calculated
    once. Follow these steps to declare the new `Skeleton` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Skeleton.h`. Declare the `Skeleton` class in this file.
    Add a rest pose, a bind pose, the inverse bind pose, and the joint names for the
    current animated model to the `Skeleton` class. The inverse bind pose should be
    implemented as a vector of matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a helper function, `UpdateInverseBindPose`. This function updates the inverse
    bind pose matrix any time that the bind pose is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a default constructor and a convenience constructor. Also, declare
    methods to set the rest pose, bind pose, and joint names of the skeleton and helper
    functions to retrieve references to all the variables of the skeleton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Think of the `Skeleton` class as a helper class—it puts the bind pose, inverse
    bind pose, rest pose, and joint names into an easy-to-manage object. The skeleton
    is shared; you can have many characters, each with a unique animated pose, but
    they can all share the same skeleton. In the following section, you will implement
    the `Skeleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Skeleton class implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The inverse bind pose is stored in the skeleton as an array of matrices. Any
    time the bind pose of the skeleton is updated, the inverse bind pose should be
    re-calculated as well. To find the inverse bind pose, find the world space matrix
    of every joint in the skeleton, then invert the world space joint matrix. Create
    a new file, `Skeleton.cpp`. Then, implement the skeleton constructors. Take the
    following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two constructors—the default constructor does not do anything. The other
    convenience constructor takes a rest pose, a bind pose, and the joint names. It
    calls the `Set` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Set` method, which should set the internal pose, bind pose, and
    joint names of the skeleton. Once the bind pose is set, call the `UpdateInverseBindPose`
    function to populate the inverse bind pose matrix palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `UpdateInverseBindPose` function next. Make sure that the matrix
    vector has the right size, then loop through all of the joints in the bind pose.
    Get the world space transform of each joint, convert it into a matrix, and invert
    the matrix. This inverted matrix is the inverse bind pose matrix for the joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the simple getter and setter functions in the `Skeleton` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to get around returning references by providing explicit getter
    functions, such as `Transform GetBindPoseTransform(unsigned int index)`. This
    makes more sense to do after you have worked through the next chapter, where you
    learn how to optimize the animation data. For now, it's more valuable to have
    access to these references and not modify them.
  prefs: []
  type: TYPE_NORMAL
- en: To generate an inverse bind pose matrix, you don't have to convert the transform
    into a matrix and then invert it; you could invert the transform and then convert
    it into a matrix. The performance delta between the two is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: The `Skeleton` class keeps track of the bind pose, inverse bind pose, and joint
    names of an animated model. This data can be shared between all the animated instances
    of a model. In the next section, you will implement bind pose loading from glTF
    files. The glTF format does not store the actual bind pose.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading the bind pose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now ready to load the bind pose from a glTF file, but there is a problem.
    glTF files don't store the bind pose. Instead, for each skin that a glTF file
    contains, it stores a matrix array that holds the inverse bind pose matrix for
    each joint that affects the skin.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the inverse bind pose matrices like this is good for optimization, which
    will make more sense in the next chapter, but for now, it is something we have
    to deal with. So, how do you get the bind pose?
  prefs: []
  type: TYPE_NORMAL
- en: To get the bind pose, load the rest pose and convert each transform in the rest
    pose into a world space transform. This makes sure that if a skin didn't provide
    an inverse bind pose matrix for a joint, a good default value is available.
  prefs: []
  type: TYPE_NORMAL
- en: Next, loop through each skinned mesh in the `.gltf` file. For each skinned mesh,
    invert the inverse bind pose matrix of each joint. Inverting the inverse bind
    pose matrix results in the bind pose matrix. Convert the bind pose matrix into
    a transform that can be used in the bind pose.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works, but all the joint transforms are in world space. You need to convert
    each joint so that it is local to the parent of the joint. Take the following
    steps to implement the `LoadBindPose` function in `GLTFLoader.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `LoadBindPose` function by building a vector of transforms.
    Populate the vector of transforms with the global transform of each joint in the
    rest pose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through every skinned mesh in the glTF file. Read the `inverse_bind_matrices`
    accessor into a large vector of float values. The vector needs to contain the
    `contain numJoints * 16` elements since each matrix is a 4x4 matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For each joint in the skin, get the inverse bind matrix. Invert the inverse
    bind pose matrix to get the bind pose matrix. Convert the bind pose matrix into
    a transform. Store this world space transform in the `worldBindPose` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert each joint so that it is relative to its parent. To move a joint into
    the space of another joint—that is, to make it relative to another joint—combine
    the world transform of the joint with the inverse world transform of its parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reconstructing the bind pose is not ideal, but it is a quirk of glTF that you
    have to deal with. By using the rest pose as the default joint values, any joint
    that does not have an inverse bind pose matrix still has a valid default orientation
    and size.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to load the bind pose of an animated mesh from
    a glTF file. In the next section, you will create a convenience function to load
    a skeleton from a glTF file with only one function call.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading a skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to implement one more loading function—the `LoadSkeleton` function.
    This is a convenience function that loads a skeleton without having to call three
    separate functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `LoadSkeleton` function in `GLTFLoader.cpp`. Don''t forget to
    add the function declaration to `GLTFLoader.h`. The function returns a new skeleton
    by calling the existing `LoadPose`, `LoadBindPose`, and `LoadJointNames` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `LoadSkeleton` function is just a helper function that allows you to initialize
    a skeleton with a single function call. In the next section, you will implement
    a `Mesh` class, which will let you display animated meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of a mesh is dependent on the game (or engine) that implements
    it. It's beyond the scope of this book to implement a comprehensive mesh class.
    Instead, in this section, you will declare a naive version of a mesh that stores
    some data on the CPU and the GPU and provides a way to sync the two together.
  prefs: []
  type: TYPE_NORMAL
- en: The Mesh class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the most basic implementation of a mesh? Each vertex has a position,
    a normal, and some texture coordinates. To skin the mesh, each vertex also has
    four bones that might influence it and weights to determine how much each bone
    influences the vertex by. Meshes usually use an index array, but this is optional.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will implement both CPU and GPU skinning. To skin a mesh
    on the CPU, you need to keep an additional copy of the pose and normal data, as
    well as a matrix palette to use for skinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Mesh.h`, to declare the `Mesh` class in. Follow these steps
    to declare the new `Mesh` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start declaring the `Mesh` class. It should maintain a copy of the mesh data
    on the CPU as well as on the GPU. Store vectors for the position, normal, tex
    coordinates, weights, and influences that define each vertex. Include an optional
    vector for indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the vectors listed in the preceding code also needs to be set appropriate
    attributes. Create `Attribute` pointers for each one, as well as an index buffer
    pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an additional copy of the pose and normal data, as well as a matrix palette
    to use for CPU skinning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add declarations for the constructor, copy constructor, and assignment operator,
    as well as the destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare getter functions for all the attributes that the mesh contains. These
    functions return the vector references. The vector references are not read-only;
    you use these when loading meshes to populate the mesh data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `CPUSkin` function, which applies CPU mesh-skinning. To skin a
    mesh, you need both a skeleton and an animated pose. Declare the `UpdateOpenGLBuffers`
    function, which syncs the vectors holding data to the GPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare functions to bind, draw, and unbind the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This `Mesh` class is not production-ready, but it's easy to work with and will
    work for the rest of this book. In the next section, you will start implementing
    the `Mesh` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Mesh class implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Mesh` class contains two copies of the same data. It keeps all the vertex
    data on the CPU side in vectors and on the GPU side in vertex buffer objects.
    The intended use of this class is to edit the CPU-side vertices, then sync the
    changes to the GPU with the `UpdateOpenGLBuffers` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Mesh.cpp`; you will implement the `Mesh` class in this
    file. Follow these steps to implement the `Mesh` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the default constructor, which needs to make sure all the attributes
    (and the index buffer) are allocated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the copy constructor. Create the buffers in the same way that you
    did for the constructor, then call the assignment operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the assignment operator, which will copy out the CPU-side members
    (all of the vectors) and then call the `UpdateOpenGLBuffers` function to upload
    the attribute data to the GPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the destructor, making sure you delete all the data that the constructors
    had allocated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Mesh` getter functions. These functions return references to
    vectors. The references are expected to be edited after they are returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `UpdateOpenGLBuffers` function by calling `Set` on each of the
    attribute objects. If one of the CPU-side vectors has a size of `0`, then there
    is nothing to set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Bind` function. This takes integers that are bind slot indices.
    If the bind slot is valid (that is, it''s `0` or greater), the `BindTo` function
    of the attribute is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Draw` and `DrawInstanced` functions, which call the appropriate
    global `::Draw` and `::DrawInstanced` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `UnBind` function, which also takes integer bind slots for arguments
    but calls `UnBindFrom` on the attribute objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Mesh` class contains vectors to hold the CPU data and attributes to copy
    that data to the GPU. It provides a simple interface to render an entire mesh.
    In the following section, you will learn how to implement CPU skinning to animate
    a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CPU skinning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is easier to understand skinning by implementing it on the CPU first, without
    having to worry about shaders. In this section, you will create a CPU-skinning
    reference implementation. GPU skinning is covered later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important information:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU skinning is useful if the platform you are developing for has a limited
    number of uniform registers or a small uniform buffer.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing CPU skinning, you need to keep two copies of the animated
    mesh. The `mPosition` and `mNormal` vectors do not change. The result of the skinned
    positions and normals is stored in `mSkinnedPosition` and `mSkinnedNormal`. These
    vectors are then synced to the position and normal attributes to draw.
  prefs: []
  type: TYPE_NORMAL
- en: To skin a vertex, you need to calculate the skin transform. The skin transform
    needs to transform the vertex by the inverse bind pose, then by the current animated
    pose. You can do this by calling the inverse function on the bind pose transform,
    then combine it with the pose transform.
  prefs: []
  type: TYPE_NORMAL
- en: For each vertex, `ivec4` in the `mInfluences` vector contains the joint IDs
    that affect the vertex. You need to transform the vertex by all four joints, which
    means you skin the mesh four times—once to each bone that influences the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Not every joint contributes in the same way to the final vertex. For each vertex,
    `vec4` stored in `mWeights` contains a scalar value of `0` to `1`. These values
    are used to blend the skinned vertices together. If a joint does not influence
    the vertex, its weight is `0` and it has no effect on the final skinned mesh.
  prefs: []
  type: TYPE_NORMAL
- en: The content of the weights is expected to be normalized in a way that if all
    the weights are added together, they equal `1`. This way, the weights can be used
    to blend, since they all add up to an influence of `1`. For example, (`0.5`, `0.5`,
    `0`, `0`) would be valid, but (`0.6`, `0.5`, `0`, `0`) would not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement CPU skinning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `CPUSkin` function. Make sure the skinned vectors have
    enough storage space and get the bind pose from the skeleton. Next, loop through
    each vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the skin transform. Transform both the first vertex and normal influences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this process for the other three joints that might influence the current
    vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By this point, you have skinned the vertex four times—once to each bone that
    influences it. Next, you need to combine these into the final vertex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Blend the skinned positions and normal using `mWeights`. Set the position and
    normal attributes as the newly updated skinned positions and normals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's unpack what's happening here. This is the basic skinning algorithm. Every
    vertex has a `vec4` value called weights and an `ivec4` value called influences.
    Each vertex has four joints that influence it and four weights. A weight could
    be `0` if the joint has no influence on the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: The `x`, `y`, `z`, and `w` components of the `ivec4` influences are indices
    in the animated pose and inverse bind pose matrix arrays. The `x`, `y`, `z`, and
    `w` components of the `vec4` weights are scalar weights to apply to the same component
    of the `ivec4` influences.
  prefs: []
  type: TYPE_NORMAL
- en: Loop through all the vertices. For each vertex, transform the position and the
    normal of the vertex by the skin transform of each joint that affects the vertex.
    The skin transform is the combination of the inverse bind pose and the pose transformations.
    This means you will end up skinning the vertex four times. Scale each transformed
    position or normal by the weight of the joint it belongs to and add all four values
    together. The resulting sum is the skinned position or normal.
  prefs: []
  type: TYPE_NORMAL
- en: This is the skinning algorithm; it stays the same no matter how it is expressed.
    There are several ways to represent the joint transformations, such as using `Transform`
    objects, matrices, and dual quaternions. No matter what the representation is,
    the algorithm stays the same. In the following section, you will learn how to
    implement the skinning algorithm using matrices instead of `Transform` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Skinning with matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The common way to skin a vertex is to linearly blend matrices into a single
    skin matrix, then transform the vertex by this skin matrix. To do this, use the
    inverse bind pose stored in the skeleton and get the matrix palette from the pose.
  prefs: []
  type: TYPE_NORMAL
- en: To build a skin matrix, multiply the pose matrix by the inverse bind pose. Remember,
    the vertex should be transformed by the inverse bind pose first, then the animated
    pose. With right-to-left multiplication, this puts the inverse bind pose on the
    right side.
  prefs: []
  type: TYPE_NORMAL
- en: Multiply the matrices together for each joint that affects the current vertex,
    then scale the resulting matrix by the weight of the vertex. Once all the matrices
    are scaled, add them together. The resulting matrix is the skin matrix that can
    be used to transform both the vertex position and normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code re-implements the `CPUSkin` function using matrix palette
    skinning. This code is very similar to the shader code that you will need to implement
    to run skinning on the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The code for skinning with matrices looks a little different, but it's still
    the same skinning algorithm. Instead of transforming each vertex four times and
    scaling the results, the matrices are scaled and added together. The result is
    a single skin matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the vertex is only transformed once, four new matrix multiplications
    are introduced. The number of required operations is about the same, so why implement
    matrix palette skinning? When you implement GPU skinning, it's easy to use GLSL's
    built-in matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you implemented a `Mesh` class. The Mesh class uses the following
    vertex format:'
  prefs: []
  type: TYPE_NORMAL
- en: The position (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The normal (`vec3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The texture coordinates `(vec2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The influences (`ivec4`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The weights (`vec4`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this definition, you can render a skinned mesh. In the following section,
    you will learn how to load a mesh from a glTF file.
  prefs: []
  type: TYPE_NORMAL
- en: glTF – loading meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a functional `Mesh` class, you can, in theory, skin the mesh
    on the CPU. However, there is one problem—you can't actually load a mesh from
    a glTF file yet. Let's address this next.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new helper function, `MeshFromAttributes`. This is only
    a helper function, so there is no need to expose it to the header file. glTF stores
    a mesh as a collection of primitives and each primitive is a collection of attributes.
    These attributes contain the same information as our attribute class, such as
    positions, normals, weights, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `MeshFromAttribute` helper function takes a mesh and a `cgltf_attribute`
    function, along with some additional data required for parsing. The attribute
    contains one of our mesh components, such as the position, normal, UV coordinate,
    weights, or influences. This attribute provides the appropriate mesh data.
  prefs: []
  type: TYPE_NORMAL
- en: All values are read in as floating-point numbers, but the joint influences that
    affect the vertex are stored as integers. Don't cast the float to an int directly;
    there is a chance that due to a precision issue, the cast will return the wrong
    number. Instead, convert the float into an integer by adding 0.5 then casting.
    That way, the integer truncation always brings it to the correct number.
  prefs: []
  type: TYPE_NORMAL
- en: gLTF stores the indices that affect a joint relative to the joints array of
    the skin that is being parsed, not the node hierarchy. The `joints` array, in
    turn, is a pointer to a node. You can this node pointer and use the `GetNodeIndex`
    function to convert it into an index in the node hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement mesh loading from a glTF file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `MeshFromAttribute` function in the `GLTFHelpers` namespace.
    Start the implementation by figuring out how many attributes the current component
    has:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the data out of the provided accessor using the `GetScalarValues` helper
    function. Create references to the position, normal, texture coordinate, influences,
    and weights vectors of the mesh; the `MeshFromAttribute` function will write to
    these references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through all the values in the current accessor and assign them to the
    appropriate vector based on the accessor type. The position, texture coordinates,
    and weights components can all be found by reading the data from the values vector
    and assigning them directly to the appropriate vector in the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After reading in the normal, check its squared length. If the normal is invalid,
    return a valid vector and consider logging an error. If the normal is valid, normalize
    it before pushing it into the normals vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Read in the joints that influence the current vertex. These joints are stored
    as floating-point numbers. Convert them into integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `GetNodeIndex` helper function to convert the joint indices so that
    they go from being relative to the `joints` array to being relative to the skeleton
    hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that even the invalid nodes have a value of `0`. Any negative joint
    indices will break the skinning implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A **mesh** in gLTF is made up of **primitives**. A primitive contains attributes
    such as positions and normals. Every primitive in glTF is expressed as a mesh
    in the framework you've created so far since it doesn't have a concept of sub-meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `MeshFromAttribute` function now finished, implement the `LoadMeshes`
    function next. This is the function used to load the actual mesh data; it needs
    to be declared in `GLTFLoader.h` and implemented in `GLTFLoader.cpp`. Follow these
    steps to implement the `LoadMeshes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `LoadMeshes` function, first, loop through all of the nodes
    in the glTF file. Only process nodes that have both a mesh and a skin; any other
    nodes should be skipped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through all the primitives in the glTF file. Create a new mesh for each
    primitive. Loop through all the attributes in the primitive and populate the mesh
    data by calling the `MeshFromAttribute` helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the primitive contains indices. If it does, the index buffer
    of the mesh needs to be filled out as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The mesh is complete. Call the `UpdateOpenGLBuffers` function to make sure
    the mesh can be rendered and return the resulting vector of meshes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Since glTF stores an entire scene, not just a mesh, it supports multiple meshes—each
    one is made up of primitives, which are the actual triangles. Primitives in glTF
    can be thought of as sub-meshes. The glTF loader presented here assumes that a
    file contains a single model only. In the next section, you will learn how to
    move mesh skinning from the CPU to the GPU using shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GPU skinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created some basic shaders in [*Chapter 6*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104),
    *Building an Abstract Renderer and OpenGL*—the `static.vert` shader and the `lit.frag`
    shader. The `static.vert` shader can be used to display a static, unskinned mesh,
    which is loaded with the `LoadMeshes` function. The `static.vert` shader can even
    display a CPU skinned mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `skinned.vert`. Follow these steps to implement a vertex
    shader that can perform matrix palette skinning. The code is very similar to the
    one used for `static.vert`; the differences are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vertex gets two new components—the joint indices that affect the vertex
    and the weight of each joint. These new components can be stored in `ivec4` and
    `vec4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add two matrix arrays to the shader—each array is `120` in length. This
    length is arbitrary; the shader only needs as many new uniform matrices as the
    skinned mesh has joints. You could configure this automatically by generating
    a new shader string in code every time a skeleton with a new number of bones is
    loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When the main function of the shader runs, calculate a skin matrix. The skin
    matrix is generated the same way as the CPU skinning-example skin matrix. It uses
    the same logic, just in a shader executing on the GPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The mesh should deform before it is placed in the world. Multiply the vertex
    position and normal by the skin matrix before applying the model matrix. All the
    relevant code is highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To add skinning support to the vertex shader, you add two new attributes to
    each vertex that represent up to four joints that can affect the vertex. By using
    the joint and weight attributes, a skin matrix is constructed. To skin the mesh,
    multiply the vertex or normal by the skin matrix before applying the rest of the
    vertex transformation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the difference between a bind pose and a rest pose.
    You also created a `Skeleton` class that contains them both. You learned about
    the general concept of skinning—both rigid (one bone per vertex) and smooth (multiple
    bones per vertex) skinning.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we implemented a primitive mesh class and we covered the process
    of skinning a mesh on both the CPU and GPU, as well as loading a bind pose out
    of a glTF file that does not store bind pose data.
  prefs: []
  type: TYPE_NORMAL
- en: You can now apply the skills you learned. With the skinning code complete, you
    can display fully animated models. The models can be loaded from glTF files, which
    is an open file format specification.
  prefs: []
  type: TYPE_NORMAL
- en: In the downloadable samples for this book, `Chapter10/Sample01` contains a sample
    that draws the rest pose, bind pose, and current animated pose. `Chapter10/Sample02`
    demonstrates how to use both GPU and CPU skinning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to optimize various aspects of the animation
    pipeline. This includes the pose generation and skinning and caching transform
    parent lookups steps.
  prefs: []
  type: TYPE_NORMAL

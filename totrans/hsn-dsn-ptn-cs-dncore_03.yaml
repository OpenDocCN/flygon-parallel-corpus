- en: Modern Software Design Patterns and Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代软件设计模式和原则
- en: In the previous chapter, **object-oriented programming** (**OOP**) was discussed
    in preparation for exploring different patterns. As many patterns rely on concepts
    in OOP, it is important to introduce and/or revisit these concepts. Inheritance
    between classes allows us to define an *is-a-type-of relationship*. This provides
    a higher degree of abstraction. For example, with inheritance it is possible to
    perform comparisons such as a *cat *is a type of *animal* and a *dog* is a type
    of *animal*. Encapsulation provides a way of controlling the visibility and access
    of details of a class. Polymorphism provides the ability to handle different objects
    using the same interface. With OOP, a higher level of abstraction can be achieved,
    providing a more manageable and understandable way to deal with large solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，讨论了**面向对象编程**（**OOP**），为了探索不同的模式做了准备。由于许多模式依赖于OOP中的概念，因此介绍和/或重新访问这些概念非常重要。类之间的继承允许我们定义*是一种类型的关系*。这提供了更高程度的抽象。例如，通过继承，可以进行比较，比如*猫*是一种*动物*，*狗*是一种*动物*。封装提供了一种控制类的细节的可见性和访问性的方法。多态性提供了使用相同接口处理不同对象的能力。通过OOP，可以实现更高级别的抽象，提供了一种更易于管理和理解的方式来处理大型解决方案。
- en: This chapter catalogs and introduces different patterns used in modern software
    development. This book takes a very broad view of what a pattern is. A pattern
    in software development is any solution to a general problem that software programmers
    face during development. They are built from experience on what works and what
    does not. Also, these solutions are trialed and tested by numerous developers
    in various situations. The benefit of using a pattern is based on this past activity
    both in not repeating the effort and in the assurance that the problem will be
    solved without introducing a defect or issue.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章目录和介绍了现代软件开发中使用的不同模式。本书对模式的定义非常宽泛。在软件开发中，模式是软件程序员在开发过程中面临的一般问题的任何解决方案。它们建立在经验之上，是对什么有效和什么无效的总结。此外，这些解决方案经过了许多开发人员在各种情况下的试验和测试。使用模式的好处基于过去的活动，既在不重复努力方面，也在保证问题将被解决而不会引入缺陷或问题方面。
- en: Especially when taking technology-specific patterns into consideration, there
    are too many to cover in a single book so this chapter will highlight specific
    patterns to illustrate different types of pattern. We have tried to pick out the
    commonest and most influential patterns based on our experience. In subsequent
    chapters, specific patterns will be explored in more detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在考虑到技术特定模式时，有太多内容无法在一本书中涵盖，因此本章将重点介绍特定模式，以说明不同类型的模式。我们试图根据我们的经验挑选出最常见和最有影响力的模式。在随后的章节中，将更详细地探讨特定模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Design principles, including SOLID
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括SOLID在内的设计原则
- en: Pattern catalogs, including **Gang of Four** (**GoF**) patterns and **Enterprise
    Integration Pattern** (**EIP**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式目录，包括**四人帮**（**GoF**）模式和**企业集成模式**（**EIP**）
- en: Software development life cycle patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发生命周期模式
- en: Patterns and practices for solution development, cloud development, and service
    development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案开发、云开发和服务开发的模式和实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释这些概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）
- en: .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio，或者您可以使用您喜欢的IDE。要做到这一点，请按照以下说明进行操作：
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明进行安装。Visual Studio有多个版本可供安装。在本章中，我们使用的是Windows版的Visual Studio。
- en: Setting up .NET Core
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，您需要按照以下说明进行操作：
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: Follow the Installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循安装说明和相关库：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到。本章中显示的源代码可能不完整，因此建议检索源代码以运行示例：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2)。
- en: Design principles
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: Arguably, the most important aspect of good software development is software
    design. Developing software solutions that are both functionally accurate and
    easy to maintain is challenging and relies considerably on using good development
    principles. Over time, some decisions that were made early in the project can
    cause solutions to become too costly to maintain and extend, forcing systems to
    be rewritten, while others with a good design can be extended and adapted as business
    requirements and technology change. There are many software development design
    principles and this section will highlight some popular and important ones you
    need to be familiar with.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，良好软件开发最重要的方面是软件设计。开发既功能准确又易于维护的软件解决方案具有挑战性，并且在很大程度上依赖于使用良好的开发原则。随着时间的推移，项目初期做出的一些决定可能导致解决方案变得过于昂贵，无法维护和扩展，迫使系统进行重写，而具有良好设计的其他解决方案可以根据业务需求和技术变化进行扩展和调整。有许多软件开发设计原则，本节将重点介绍一些您需要熟悉的流行和重要原则。
- en: DRY – Don't Repeat Yourself
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY – 不要重复自己
- en: The guiding thought behind the **Don't Repeat Yourself** (**DRY**) principle
    is that duplication is a waste of time and effort. The repetition could take the
    form of processes and code. Handling the same requirement multiple times is a
    waste of effort and creates confusion within a solution. When first viewing this
    principle, it might not be clear how a system could end up duplicating a process
    or code. For example, once someone has determined how to do a requirement, why
    would someone else take the effort to duplicate the same functionality? There
    are many circumstances in which this happens in software development, and understanding
    why this happens is key to understanding the value of this principle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）原则的指导思想是重复是时间和精力的浪费。重复可以采取过程和代码的形式。多次处理相同的需求是一种精力浪费，并在解决方案中造成混乱。首次查看此原则时，可能不清楚系统如何最终会重复处理过程或代码。例如，一旦有人确定了如何满足某个需求，为什么其他人还要努力复制相同的功能？在软件开发中存在许多这种情况，了解为什么会发生这种情况是理解这一原则的价值的关键。'
- en: 'The following are some common causes of code duplication:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码重复的一些常见原因：
- en: '**Lack of understanding**: In large solutions, a developer might not have a
    full understanding of an existing solution and/or does not know how to apply abstraction
    to solve the problem with existing functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解不足**：在大型解决方案中，开发人员可能不完全了解现有解决方案和/或不知道如何应用抽象来解决现有功能的问题。'
- en: '**Copy and paste**: To put this simply, the code is duplicated in multiple
    classes instead of refactoring the solution to allow for multiple classes to access
    the shared functionality.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制粘贴**：简而言之，代码在多个类中重复，而不是重构解决方案以允许多个类访问共享功能。'
- en: KISS – Keep It Simple Stupid
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS – 保持简单愚蠢
- en: Similar to DRY, **Keep It Simple Stupid** (**KISS**) has been an important principle
    in software development for many years. KISS stresses that simplicity should be
    the goal and complexity should be avoided. The key here is to avoid unnecessary
    complexity and thus reduce the chances of things going wrong.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与DRY类似，**保持简单愚蠢**（**KISS**）多年来一直是软件开发中的重要原则。KISS强调简单应该是目标，复杂应该被避免。关键在于避免不必要的复杂性，从而减少出错的可能性。
- en: YAGNI – You Aren't Gonna Need It
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI – 你不会需要它
- en: '**You Aren''t Gonna Need It** (**YAGNI**) simply states that functionality
    should only be added when it is required. Sometimes in software development, there
    is a tendency to *futureproof* a design in case something changes. This can create
    requirements that are actually not needed currently or in the future:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**你不会需要它**（**YAGNI**）简单地表明功能只有在需要时才应该添加。有时在软件开发中，存在一种倾向，即为设计未来可能发生变化的情况而进行*未雨绸缪*。这可能会产生实际上当前或未来实际上不需要的需求：'
- en: '"Always implement things when you actually need them, never when you just foresee
    that you need them."'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “只有在实际需要时才实现事物，而不是在你预见到需要它时实现。”
- en: '*- Ron Jeffries*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*- Ron Jeffries*'
- en: MVP – Minimum Viable Product
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP – 最小可行产品
- en: By taking a **Minimum Viable Product** (**MVP**) approach, the scope of a piece
    of work is limited to the smallest set of requirements in order to produce a functioning
    deliverable. MVP is often combined with Agile software development (see the *Software
    development life cycle patterns* section later in the chapter) by limiting requirements
    to a manageable amount that can be designed, developed, tested, and delivered.
    This approach lends itself well to smaller website or application development,
    where a feature set can be progressed all the way to production in a single development
    cycle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用**最小可行产品**（**MVP**）方法，一项工作的范围被限制在最小的需求集上，以便产生一个可用的交付成果。MVP经常与敏捷软件开发结合使用（请参见本章后面的*软件开发生命周期模式*部分），通过将需求限制在可管理的数量，可以进行设计、开发、测试和交付。这种方法非常适合较小的网站或应用程序开发，其中功能集可以在单个开发周期中进展到生产阶段。
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, MVP will be illustrated in a fictitious scenario where
    the technique will be used to limit the scope of changes as well as to help the
    team focus during the design and requirement gathering phases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中，*实现设计模式 - 基础部分1*，MVP将在一个虚构的场景中进行说明，该技术将被用于限制变更范围，并在设计和需求收集阶段帮助团队集中精力。
- en: SOLID
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID
- en: SOLID is one of the most influential design principles and we will cover it
    in more detail in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*. Actually made up of five design principles,
    the intention of SOLID is to encourage designs that are more maintainable and
    easier to understand. These principles encourage code bases that are easier to
    modify and they reduce the risk of issues being introduced.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是最有影响力的设计原则之一，我们将在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中更详细地介绍它，*实现设计模式-基础部分1*。实际上，SOLID由五个设计原则组成，其目的是鼓励更易于维护和理解的设计。这些原则鼓励更易于修改的代码库，并减少引入问题的风险。
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1,* SOLID will be covered in more detail by being applied
    to a C# application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中，*实现设计模式-基础部分1*，将更详细地介绍SOLID在C#应用中的应用。
- en: Single responsibility principle
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: 'A class should have only one responsibility. The goal of this principle is
    to simplify our classes and logically structure them. Classes with multiple responsibilities
    are harder to understand and modify, as they are more complex. Responsibility
    in this circumstance is simply a reason for the change. Another way of looking
    at responsibility is to define it as a single part of the functionality:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类应该只有一个责任。这一原则的目标是简化我们的类并在逻辑上对其进行结构化。具有多个责任的类更难理解和修改，因为它们更复杂。在这种情况下，责任简单地是变化的原因。另一种看待责任的方式是将其定义为功能的单一部分：
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该有一个，且仅有一个，改变的理由。”
- en: '*- Robert C. Martin*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*- Robert C. Martin*'
- en: Open/closed principle
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: The open/closed principle is best described in terms of OOP. A class should
    be designed with inheritance as a means of extending its functionality. Change,
    in other words, is planned for and considered while the class is being designed.
    By defining and using an interface that the class implements, the open/closed
    principle is applied. The class is *open* for modification, while its description,
    the interface, is *closed *for modification.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则最好用面向对象编程来描述。一个类应该设计为具有继承作为扩展功能的手段。换句话说，在设计类时应该考虑到变化。通过定义并使用类实现的接口，应用了开闭原则。类是*开放*进行修改，而其描述，即接口，是*关闭*进行修改。
- en: Liskov substitution principle
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: Being able to substitute objects at runtime is the basis of the Liskov substitution
    principle. In OOP, if a class inherits from a base class or implements an interface,
    then it can be referenced as an object of the base class or interface. This is
    easier to describe with a simple example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在运行时替换对象是里氏替换原则的基础。在面向对象编程中，如果一个类继承自基类或实现了一个接口，那么它可以被引用为基类或接口的对象。这可以用一个简单的例子来描述。
- en: 'We''ll define an interface for an animal and implement two animals, `Cat` and
    `Dog`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为动物定义一个接口，并实现两种动物，`Cat`和`Dog`，如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can refer to the `Cat` and `Dog` as an animal as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将`Cat`和`Dog`称为动物，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interface segregation principle
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Similar to the single responsibility principle, the interface segregation principle
    states that an interface should be limited to containing only methods that are
    relevant to a single responsibility. By reducing the complexity of the interface,
    the code becomes easier to refactor and understand. An important benefit of adhering
    to this principle in a system is that it aids in decoupling a system by reducing
    the number of dependencies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与单一责任原则类似，接口隔离原则规定接口应该仅包含与单一责任相关的方法。通过减少接口的复杂性，代码变得更容易重构和理解。遵循这一原则在系统中的一个重要好处是通过减少依赖关系来帮助解耦系统。
- en: Dependency inversion principle
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: The **dependency inversion principle** (**DIP**), also referred to as the dependency
    injection principle, states that modules should not depend on details but on abstractions
    instead. This principle encourages writing loosely coupled code to enhance readability
    and maintenance, especially in a large complex code base.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖反转原则**（DIP），也称为依赖注入原则，规定模块不应该依赖于细节，而应该依赖于抽象。这一原则鼓励编写松散耦合的代码，以增强可读性和维护性，特别是在大型复杂的代码库中。'
- en: Software patterns
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件模式
- en: Over the years, many patterns have been compiled into catalogs. This section
    will use two catalogs as an illustration. The first catalog is a collection of
    OOP-related patterns by the **GoF**. The second relates to the integration of
    systems and remains technologically agnostic. At the end of the chapter, there
    are some references for additional catalogs and resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多模式已被编制成目录。本节将以两个目录作为示例。第一个目录是**GoF**的一组与面向对象编程相关的模式。第二个与系统集成相关，保持技术中立。在本章末尾，还有一些额外目录和资源的参考资料。
- en: GoF patterns
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoF模式
- en: 'Potentially, the most influential and well-known OOP collection of patterns
    comes from the *Design Patterns: Elements of Reusable Object-Oriented Software* book
    by *GoF.* The aim of the patterns in the book is on a lower level—that is, object
    creation and interaction—instead of a larger software architecture concern. The
    collection consists of templates that can be applied to particular scenarios with
    the goal of producing solid building blocks while avoiding common pitfalls in
    object-oriented development.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最有影响力和知名度的面向对象编程模式集合来自*GoF*的*可重用面向对象软件元素的设计模式*一书。该书中的模式的目标是在较低级别上，即对象创建和交互，而不是更大的软件架构问题。该集合包括可以应用于特定场景的模板，旨在产生坚实的构建模块，同时避免面向对象开发中的常见陷阱。
- en: '*Erich Gamma, John Vlissides, Richard Helm*, and *Ralph Johnson* are referred
    to as the GoF because of their widely influential publications in the 1990s. The
    book *Design Patterns: Elements of Reusable Object-Oriented Software *has been
    translated into several languages and contains examples in both C++ and Smalltalk.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Erich Gamma, John Vlissides, Richard Helm*和*Ralph Johnson*因在1990年代的广泛有影响的出版物而被称为GoF。书籍*设计模式：可重用面向对象软件的元素*已被翻译成多种语言，并包含C++和Smalltalk的示例。'
- en: 'The collection is broken into three categories: creational patterns, structural
    patterns, and behavioral patterns which will be explained in the following sections.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该收藏分为三类：创建模式、结构模式和行为模式，将在以下部分进行解释。
- en: Creational patterns
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模式
- en: 'The following five patterns are concerned with the instantiation of objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五种模式涉及对象的实例化：
- en: '**Abstract Factory**: A pattern for the creation of objects belonging to a
    family of classes. The specific object is determined at runtime.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**：一种用于创建属于一组类的对象的模式。具体对象在运行时确定。'
- en: '**Builder**: A useful pattern for more complex objects where the construction
    of the object is controlled externally to the constructed class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：用于更复杂对象的有用模式，其中对象的构建由构建类外部控制。'
- en: '**Factory Method**: A pattern for creating objects derived from a class where
    the specific class is determined at runtime.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法**：一种用于在运行时确定特定类的对象的模式。'
- en: '**Prototype**: A pattern for copying or cloning an object.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：用于复制或克隆对象的模式。'
- en: '**Singleton**: A pattern for enforcing only one instance of a class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：用于强制类的仅一个实例的模式。'
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, the Abstract Factory pattern will be explored in more
    detail. In [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*, the Singleton and Factory Method patterns will
    be explored in detail, including using the .NET Core framework support for these
    patterns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中，*实现设计模式 - 基础部分1*，将更详细地探讨抽象工厂模式。在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)中，*实现设计模式
    - 基础部分2*，将详细探讨单例和工厂方法模式，包括使用.NET Core框架对这些模式的支持。
- en: Structural patterns
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构模式
- en: 'The following patterns are concerned with defining relationships between classes
    and objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式涉及定义类和对象之间的关系：
- en: '**Adapter**: A pattern for providing a match between two different classes'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：用于提供两个不同类之间的匹配的模式'
- en: '**Bridge**: A pattern for allowing the implementation details of a class to
    be replaced without requiring the class to be modified'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接**：一种允许替换类的实现细节而无需修改类的模式'
- en: '**Composite**: Used to create a hierarchy of classes in a tree structure'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：用于创建树结构中类的层次结构'
- en: '**Decorator**: A pattern for replacing the functionality of a class at runtime'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：一种用于在运行时替换类功能的模式'
- en: '**Facade**: A pattern used to simplify complex systems'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观**：用于简化复杂系统的模式'
- en: '**Flyweight**: A pattern used to reduce the resource usage for complex models'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元**：用于减少复杂模型的资源使用的模式'
- en: '**Proxy**: A pattern used to represent another object allowing for an additional
    level of control between the calling and called objects'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：用于表示另一个对象，允许在调用和被调用对象之间增加额外的控制级别'
- en: Decorator patterns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'To illustrate a structural pattern, let''s take a closer look at the Decorator
    pattern by using an example. This example will print messages on a console application.
    First, a base message is defined with a corresponding interface:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明结构模式，让我们通过一个示例来更详细地了解装饰器模式。这个示例将在控制台应用程序上打印消息。首先，定义一个基本消息，并附带一个相应的接口：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The base class allows for the storage of a text string and requires that child
    classes implement the `PrintMessage()` method. This will then be extended into
    two new classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基类允许存储文本字符串，并要求子类实现`PrintMessage()`方法。然后将扩展为两个新类。
- en: 'The first class is a `SimpleMessage` that writes the given text to the console:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类是`SimpleMessage`，它将给定文本写入控制台：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second class is an `AlertMessage` that also writes the given text to the
    console but performs a beep as well:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类是`AlertMessage`，它还将给定文本写入控制台，但也执行蜂鸣：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between the two is that the `AlertMessage` class will issue a
    beep instead of only printing the text to the screen like the `SimpleMessage`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于`AlertMessage`类将发出蜂鸣声，而不仅仅像`SimpleMessage`类一样将文本打印到屏幕上。
- en: 'Next, a base decorator class is defined that will contain a reference to a
    `Message` object as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个基本装饰器类，该类将包含对`Message`对象的引用，如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following two classes illustrate the Decorator pattern by providing additional
    functionality for our existing implementation of `Message`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个类通过为现有的`Message`实现提供附加功能来说明装饰器模式。
- en: 'The first is a `NormalDecorator` that prints the message whose foreground is
    green:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`NormalDecorator`，它打印前景为绿色的消息：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ErrorDecorator` uses a red foreground color to make the message more pronounced
    when printed to the console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorDecorator`使用红色前景色，使消息在打印到控制台时更加显著：'
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`NormalDecorator` will print the text in green while the `ErrorDecorator` will
    print the text in red. The important thing with this example is that the decorator
    is extending the behavior of the referenced `Message` object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalDecorator`将以绿色打印文本，而`ErrorDecorator`将以红色打印文本。这个示例的重要之处在于装饰器扩展了引用`Message`对象的行为。'
- en: 'To complete the example, the following shows how new messages can be used:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，以下显示了如何使用新消息：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the example will illustrate how the different Decorator patterns can
    be used to change the referenced functionality as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例将说明如何使用不同的装饰器模式来更改引用功能，如下所示：
- en: '![](img/38b95d57-b790-4f1f-bb20-6984784a8d82.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38b95d57-b790-4f1f-bb20-6984784a8d82.png)'
- en: This is a simplified example but imagine a scenario where a new requirement
    is added to the project. Instead of using the beep sound, the system sound for
    exclamation should be played.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的例子，但想象一种情景，项目中添加了一个新的要求。系统不再使用蜂鸣声，而是应该播放感叹号的系统声音。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we have a structure in place to handle this, the amendment is a one-line
    change as shown in the previous code block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了处理这个的结构，所以修正是一个一行的更改，如前面的代码块所示。
- en: Behavioral patterns
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: 'The following behavioral patterns can be used to define the communication between
    classes and objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行为模式可用于定义类和对象之间的通信：
- en: '**Chain** **of** **Responsibility**: A pattern for handling a request between
    a collection of objects'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**：处理一组对象之间请求的模式'
- en: '**Command**: A pattern used to represent a request'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：用于表示请求的模式'
- en: '**Interpreter**: A pattern for defining syntax or language for instructions
    in a program'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：一种用于定义程序中指令的语法或语言的模式'
- en: '**Iterator**: A pattern for traversing a collection of items without detailed
    knowledge of the elements in a collection'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：一种在不详细了解集合中元素的情况下遍历集合的模式'
- en: '**Mediator**: A pattern for simplifying communication between classes'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中介者**：简化类之间通信的模式'
- en: '**Memento**: A pattern for capturing and storing the state of an object'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：用于捕获和存储对象状态的模式'
- en: '**Observer**: A pattern for allowing objects to be notified of changes to another
    object''s state'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：一种允许对象被通知另一个对象状态变化的模式'
- en: '**State**: A pattern for altering an object''s behavior when its state changes'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：一种在对象状态改变时改变对象行为的模式'
- en: '**Strategy**: A pattern for implementing a collection of algorithms where a
    specific algorithm can be applied at runtime'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：一种在运行时应用特定算法的模式'
- en: '**Template** **Method**: A pattern for defining the steps of an algorithm while
    leaving the implementation details in a subclass'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板方法**：一种定义算法步骤的模式，同时将实现细节留在子类中'
- en: '**Visitor**: A pattern promoting loose coupling between data and functionality,
    allowing for additional operations to be added without requiring changes to the
    data classes'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**：一种促进数据和功能之间松散耦合的模式，允许添加额外操作而无需更改数据类'
- en: Chain of responsibility
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: A useful pattern you need to be familiar with is the Chain of Responsibility
    pattern so we will use it as an example. With this pattern, we will set up a collection
    or chain of classes for handling a request. The idea is the request will pass
    through each class until it is handled. This illustration uses a car service center,
    where each car will pass through the different sections of the center until the
    service is complete.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉的一个有用模式是责任链模式，因此我们将以此为例使用它。使用此模式，我们将设置一个处理请求的集合或链。理念是请求将通过每个类，直到被处理。这个例子使用了一个汽车服务中心，每辆汽车将通过中心的不同部分，直到服务完成。
- en: 'Let''s start by defining a collection of flags that will be used to indicate the
    services required:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一组标志，用于指示所需的服务：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `FlagsAttribute` in C# is a great way of using a bit field to hold a collection
    of flags. The single field will be used to indicate the enum values that are *turned
    on* by using bitwise operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`FlagsAttribute`是使用位字段来保存一组标志的好方法。单个字段将用于指示通过位操作*打开*的枚举值。
- en: 'The `Car` will contain a field to capture what servicing is required and a
    field that returns true when the service has been completed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`将包含一个字段来捕获所需的维护以及一个在服务完成时返回true的字段：'
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One thing to point out is that a `Car` is considered to have its service completed
    once all the requirements have been completed, as represented by the `IsServiceComplete`
    property.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 指出的一件事是，一辆“汽车”被认为在所有要求都完成后其服务已完成，这由“IsServiceComplete”属性表示。
- en: 'An abstract base class will be used to represent each of our service technicians
    in the following manner:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用抽象基类来表示我们的每个服务技术人员，如下所示：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Take note that the service provided by the class that extends the `ServiceHandler`
    class, in other words the technician, is required to be passed in.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由扩展`ServiceHandler`类的类提供的服务，换句话说，技术人员，需要被传递进来。
- en: 'The service will then be performed by using the bitwise `NOT` operation (`~`)
    to *turn off* the bit on the given `Car`, indicating the service is required in
    the `Service` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将使用按位`NOT`操作（`~`）执行服务，*关闭*给定`Car`上的位，指示`Service`方法中需要服务：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If all services have been completed on the car and/or there are no more services,
    the chain is stopped. If there is another service and a car is not ready, then
    the next service handler is called.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果汽车的所有服务都已完成和/或没有更多服务，则停止链条。如果有另一个服务并且汽车还没有准备好，那么将调用下一个服务处理程序。
- en: 'This approach requires the chain to be set and the preceding example shows
    this being done using the `SetNextServiceHandler()` method to set the next service
    to be performed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要设置链条，并且前面的例子显示了使用`SetNextServiceHandler()`方法来设置要执行的下一个服务：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The service specialists include a `Detailer`, `Mechanic`, `WheelSpecialist`,
    and a `QualityControl` engineer. The `ServiceHandler` representing a `Detailer`
    is shown in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务专家包括`Detailer`，`Mechanic`，`WheelSpecialist`和`QualityControl`工程师。代表`Detailer`的`ServiceHandler`在以下代码中显示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The mechanic, whose specialty is tuning the engine, is shown in the following
    code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 专门调校发动机的机械师在以下代码中显示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The wheel specialist is shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了轮胎专家：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And last is quality control, who will take the car for a test drive:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是质量控制，谁将驾驶汽车进行测试：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The service center technicians have been defined, so the next step is to service
    a couple of cars. This will be illustrated in the `Main` code block, starting
    with constructing the required objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 服务中心的技术人员已经定义好了，下一步是为一些汽车提供服务。这将在`Main`代码块中进行说明，首先是构造所需的对象：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step will be to set up the handling order for the different services:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是为不同的服务设置处理顺序：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then two calls will be made to the mechanic, which is the start of the chain
    of responsibility:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将会有两次调用技师，这是责任链的开始：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An important thing to note is the order in which the chain is set. For this
    service center, the mechanic first performs tuning, followed by the wheels being
    aligned. Then, a test drive is performed and after that, the car is worked up
    in detail. Originally, the test drive used to be performed as the last step, but
    the service center determined that, on rainy days, this required the car details
    to be repeated. A bit of a silly example, but it illustrates the benefit of having
    the chain of responsibility defined in a flexible manner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要注意的是链的设置顺序。对于这个服务中心，技师首先进行调整，然后进行车轮定位。然后进行一次试车，之后对车进行详细的工作。最初，试车是作为最后一步进行的，但服务中心确定，在下雨天，这需要重复进行车辆细节。这是一个有点愚蠢的例子，但它说明了以灵活的方式定义责任链的好处。
- en: '![](img/50fb4e09-4160-462b-91f8-2a84ddde769c.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50fb4e09-4160-462b-91f8-2a84ddde769c.png)'
- en: The preceding screenshot shows the display after our two cars have been serviced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了我们的两辆车在接受服务后的显示。
- en: Observer pattern
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'An interesting pattern to explore in more detail is the **Observer pattern**.
    This pattern allows for instances to be informed of when a particular event happens
    in another instance. In this way, there are many observers and a single subject.
    The following diagram illustrates this pattern:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得更详细探讨的有趣模式是**观察者模式**。这种模式允许实例在另一个实例中发生特定事件时被通知。这样，就有许多观察者和一个单一的主题。以下图表说明了这种模式：
- en: '![](img/c945ea79-025c-437f-a14b-f61c6af08216.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c945ea79-025c-437f-a14b-f61c6af08216.png)'
- en: Let's provide an example by creating a simple C# console application that will
    create a single instance of a `Subject` class and multiple `Observer` instances.
    When a quantity value changes in the `Subject` class, we want each `Observer` instance
    to be notified.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的C#控制台应用程序来提供一个例子，该应用程序将创建一个`Subject`类的单个实例和多个`Observer`实例。当`Subject`类中的数量值发生变化时，我们希望每个`Observer`实例都能收到通知。
- en: 'The `Subject` class contains a private quantity field that is updated by a
    public `UpdateQuantity` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`类包含一个私有的数量字段，由公共的`UpdateQuantity`方法更新：'
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to alert any observers, we use the C# keywords, `delegate` and `event`.
    The `delegate` keyword defines the format or handler that will be called. The
    delegate to be used when the quantity is updated is shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知任何观察者，我们使用C#关键字`delegate`和`event`。`delegate`关键字定义了将被调用的格式或处理程序。当数量更新时要使用的委托如下代码所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The delegate defines `QuantityUpdated` to be a method that receives an integer
    and does not return any value. An event is then added to the `Subject` class as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 委托将`QuantityUpdated`定义为一个接收整数并且不返回任何值的方法。然后，事件被添加到`Subject`类中，如下所示：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And, in the `UpdateQuantity` method, it is called as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateQuantity`方法中，它被调用如下：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we will define a method in the `Observer` class that has the
    same signature as the `QuantityUpdated` delegate:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在`Observer`类中定义一个具有与`QuantityUpdated`委托相同签名的方法：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This implementation will be alerted when the quantity of the `Subject` instance
    changes and will print a message to the console in a specific color.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现将在`Subject`实例的数量发生变化时得到通知，并以特定颜色在控制台上打印一条消息。
- en: 'Let''s put these together in a simple application. At the start of the application,
    a single `Subject` and three `Observer` objects will be created:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些放在一个简单的应用程序中。在应用程序开始时，将创建一个`Subject`和三个`Observer`对象：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, each `Observer` instance will register to be alerted by the `Subject` when
    the quantity changes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每个`Observer`实例将注册以在`Subject`的数量发生变化时得到通知：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will update the quantity twice, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将更新数量两次，如下所示：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the application is run, we get three messages printed in different colors
    for each update statement, as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，我们会得到三条不同颜色的消息打印出每个更新语句，如下截图所示：
- en: '![](img/6bd7a38b-7646-41ff-b808-139593727342.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bd7a38b-7646-41ff-b808-139593727342.png)'
- en: This was a simple sample using the C# `event` keyword, but, hopefully, it illustrates
    how this pattern could be used. The advantage here is it loosely couples the subject
    from the observers. The subject does not have to have knowledge of the different
    observers, or even knowledge of whether any exist.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用C# `event`关键字的简单示例，但希望它说明了这种模式如何被使用。这里的优势是它将主题与观察者松散地耦合在一起。主题不必知道不同观察者的情况，甚至不必知道是否存在观察者。
- en: Enterprise integration patterns
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业集成模式
- en: '**Integration** is a discipline of software development that benefits greatly
    from leveraging the knowledge and experience of others. With this in mind, many
    catalogs of EIPs exist, some of which are technology agnostic while others are tailored
    to a particular technology stack. This section will highlight some popular integration
    patterns.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成**是软件开发的一个学科，它极大地受益于利用他人的知识和经验。考虑到这一点，存在许多EIP目录，其中一些是技术无关的，而另一些则专门针对特定的技术堆栈。本节将重点介绍一些流行的集成模式。'
- en: '*Enterprise Integration Patterns*, by *Gregor Hohpe* and *Bobby Woolf*, provides
    a solid resource for many integration patterns across a variety of technologies.
    This book is often referenced when discussing EIPs. The book is available at [https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*企业集成模式*，由*Gregor Hohpe*和*Bobby Woolf*提供了许多技术上的集成模式的可靠资源。在讨论EIP时，经常引用这本书。该书可在[https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/)上获得。'
- en: Topology
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拓扑
- en: 'An important consideration for enterprise integration is the topology of the
    systems being connected. In general, there are two distinct topologies: hub-and-spoke
    and enterprise service bus.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 企业集成的一个重要考虑因素是被连接系统的拓扑。一般来说，有两种不同的拓扑结构：中心枢纽和企业服务总线。
- en: 'A **hub-and-spoke** (hub) topology describes an integration pattern where a
    single component, the hub, is centralized and it communicates with each application
    explicitly. This centralizes the communication so that the hub only needs to know
    about the other applications, as illustrated in the following diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心枢纽**（中心枢纽）拓扑描述了一种集成模式，其中一个单一组件，中心枢纽，是集中的，并且它与每个应用程序进行显式通信。这种集中的通信使得中心枢纽只需要了解其他应用程序，如下图所示：'
- en: '![](img/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png)'
- en: The diagram shows the hub, in blue, as having explicit knowledge of how to communicate
    with the different applications. This means that, when a message is to be sent
    from A to B, it is sent from A to the hub and then forwarded on to B. The advantage
    of this approach for an enterprise is that connectivity to B has to be defined
    and maintained only in one place, the hub. The significance here is that the security
    is controlled and maintained in one central location.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了蓝色的中心枢纽具有如何与不同应用程序通信的明确知识。这意味着，当消息从A发送到B时，它是从A发送到中心枢纽，然后转发到B。对于企业来说，这种方法的优势在于，与B的连接只需要在一个地方，即中心枢纽中定义和维护。这里的重要性在于安全性在一个中心位置得到控制和维护。
- en: 'An **enterprise service bus** (**ESB**) relies on a messaging model comprising
    of publishers and subscribers (Pub-Sub). A publisher submits messages to the bus
    and a subscriber registers to receive published messages. The following diagram
    illustrates this topology:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业服务总线**（**ESB**）依赖于由发布者和订阅者（Pub-Sub）组成的消息模型。发布者向总线提交消息，订阅者注册以接收已发布的消息。以下图表说明了这种拓扑：'
- en: '![](img/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png)'
- en: In the preceding diagram, if a message is to be routed from **A** to **B**,
    **B** subscribes to the ESB for messages published from **A**. When **A** publishes
    a new message, the message is sent to **B**. In practice, the subscription can
    be more complex. For example, in an ordering system, there might be two subscribers
    for priority orders and normal orders. In this situation, priority orders might
    then be handled differently from normal orders.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，如果要将消息从**A**路由到**B**，**B**订阅ESB以接收从**A**发布的消息。当**A**发布新消息时，消息将发送到**B**。在实践中，订阅可能会更加复杂。例如，在订购系统中，可能会有两个订阅者，分别用于优先订单和普通订单。在这种情况下，优先订单可能会与普通订单有所不同。
- en: Patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'If we define an integration between two systems as having distinct steps, we
    can then define patterns in each step. Let''s take a look at the following diagram
    to discuss an integration pipeline:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个系统之间的集成定义为具有不同步骤，那么我们可以在每个步骤中定义模式。让我们看一下以下图表，讨论一下集成管道：
- en: '![](img/b23a2329-2813-437d-8cfa-914e26954910.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b23a2329-2813-437d-8cfa-914e26954910.png)'
- en: 'This pipeline is simplified as there could be more or fewer steps in a pipeline
    depending on the technology used. The purpose of the diagram is to provide some
    context as we look at some common integration patterns. These can be broken into
    categories as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道是简化的，因为根据使用的技术，管道中可能会有更多或更少的步骤。图表的目的是在我们查看一些常见的集成模式时提供一些背景。这些可以分为以下几类：
- en: '**Messaging**: Patterns related to the handling of messages'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**：与消息处理相关的模式'
- en: '**Transformation**: Patterns related to altering message content'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：与改变消息内容相关的模式'
- en: '**Routing**: Patterns related to the exchange of messages'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：与消息交换相关的模式'
- en: Messaging
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: 'Patterns related to messaging can take the form of message construction and
    channels. A channel, in this context, is the endpoint and/or how the message enters
    and exits the integration pipeline. Some examples of construction-related patterns
    are the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与消息相关的模式可以采用消息构造和通道的形式。在这种情况下，通道是端点和/或消息进入和离开集成管道的方式。一些与构造相关的模式的例子如下：
- en: '**Message Sequence**: The message contains a sequence to indicate a particular
    processing order.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息序列**：消息包含一个序列，表示特定的处理顺序。'
- en: '**Correlation Identifier**: The message contains a medium to identify related
    messages.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相关标识符**：消息包含一个标识相关消息的媒介。'
- en: '**Return Address**: The message identifies information about returning a response
    message.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回地址**：消息标识有关返回响应消息的信息。'
- en: '**Expiration**: The message has a finite time that it is considered valid.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期**：消息具有被视为有效的有限时间。'
- en: 'In the *Topology* section, we covered some patterns related to channels but
    the following are additional patterns you should consider in integration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在*拓扑*部分，我们涵盖了一些与通道相关的模式，但以下是您在集成中应考虑的其他模式：
- en: '**Competing Consumers**: Multiple processes could handle the same message.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争消费者**：多个进程可以处理相同的消息。'
- en: '**Selective Consumer**: Consumers use criteria to determine the message to
    process.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性消费者**：消费者使用标准来确定要处理的消息。'
- en: '**Dead Letter Channel**: Handles messages that are not successfully processed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死信通道**：处理未成功处理的消息。'
- en: '**Guaranteed Delivery**: Ensures reliable handling of messages, where no message
    is lost.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠传递**：确保消息的可靠处理，不会丢失任何消息。'
- en: '**Event-driven Consumer:** The handling of messages is based on published events.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动消费者：**消息处理基于已发布的事件。'
- en: '**Polling Consumer:** Handles messages that are retrieved from a source system.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询消费者：**处理从源系统检索的消息。'
- en: Transformation
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'When integrating complex enterprise systems, transformation patterns allow
    for flexibility in how messages are handled in the system. With transformation,
    a message between two applications can be altered and/or enhanced. Here are some
    transformation-related patterns:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成复杂的企业系统时，转换模式允许以系统中处理消息的方式灵活处理。通过转换，可以改变和/或增强两个应用程序之间的消息。以下是一些与转换相关的模式：
- en: '**Content Enricher**: A message is *enriched* by adding information.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容丰富器：**通过添加信息来*丰富*消息。'
- en: '**Canonical Data Model**: A message is transformed into an application-neutral
    message format.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范数据模型：**将消息转换为应用程序中立的消息格式。'
- en: '**Message Translator**: A pattern for translating one message to another.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息转换器：**用于将一条消息转换为另一条消息的模式。'
- en: 'The **Canonical Data Model** (**CDM**) is a good pattern to highlight. With
    this pattern, a message can be exchanged between multiple applications without
    having to perform a translation for each specific message type. This is best shown
    by an example of multiple systems exchanging messages, as illustrated in the following
    diagram:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范数据模型**（**CDM**）是一个很好的模式来强调。通过这种模式，可以在多个应用程序之间交换消息，而无需为每种特定消息类型执行翻译。这最好通过多个系统交换消息的示例来说明，如下图所示：'
- en: '![](img/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png)'
- en: In the diagram, applications **A** and **C** want to send their messages in
    their format to application **B** and **D**. If we used the Message Translator
    pattern, only the process, which is handling the transformation, would need to
    know how to translate from **A** to **B** and from **A** to **D** as well as **C**
    to **B** and **C** to **D**. This becomes increasingly difficult as the number
    of applications increases and when the publisher might not know the details of
    its consumers. With the CDM, source application messages for **A** and **B** are
    translated into a neutral schema X.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，应用程序**A**和**C**希望以它们的格式将它们的消息发送到应用程序**B**和**D**。如果我们使用消息转换器模式，只有处理转换的过程需要知道如何从**A**转换到**B**，从**A**转换到**D**，以及**C**转换到**B**和**C**转换到**D**。随着应用程序数量的增加以及发布者可能不了解其消费者的细节，这变得越来越困难。通过CDM，**A**和**B**的源应用程序消息被转换为中性模式X。
- en: Canonical schema
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 规范模式
- en: A canonical schema is sometimes referred to as a neutral schema, meaning it
    is not aligned directly with a source or destination system. The schema is then
    thought of as being impartial.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 规范模式有时被称为中性模式，意味着它不直接与源系统或目标系统对齐。然后将模式视为中立的。
- en: 'The message in the neutral schema format is then translated to the message
    formats for **B** and **D** as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将中性模式格式的消息转换为**B**和**D**的消息格式，如下图所示：
- en: '![](img/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png)'
- en: 'In the enterprise, this becomes unmanageable without some standards, and fortunately,
    many organizations have been created to produce as well as govern standards in
    many industries, including the following examples (but there are many more!):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中，如果没有一些标准，这将变得难以管理，幸运的是，许多组织已经创建并管理了许多行业的标准，包括以下示例（但还有许多其他！）：
- en: '**Electronic Data Interchange For Administration, Commerce and Transport**
    (**EDIFACT**): An international standard for trade'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向行政、商业和运输的电子数据交换**（**EDIFACT**）：贸易的国际标准'
- en: '**IMS Question and Test Interoperability specification** (**QTI**)**:** Standards
    for the representation of assessment content and results produced by the **Information
    Management System** **(****IMS**) **Global Learning Consortium** (**GLC**)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IMS问题和测试互操作规范**（**QTI**）：由**信息管理系统**（**IMS**）**全球学习联盟**（**GLC**）制定的评估内容和结果的表示标准'
- en: '**Hospitality Industry Technology Integration Standards (HITIS)**: Standards
    for property management systems maintained by the American Hotel and Motel Association'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**酒店业技术整合标准（HITIS）：**由美国酒店和汽车旅馆协会维护的物业管理系统标准'
- en: '**X12 EDI (X12)**: Collection of schemas for health care, insurance, government,
    finance, transportation, and other industries maintained by the Accredited Standards
    Committee X12'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X12 EDI（X12）：由X12认可标准委员会维护的医疗保健、保险、政府、金融、交通运输和其他行业的模式集合
- en: '**Business Process Framework** (**eTOM**): Telecommunications operating model
    maintained by the TM Forum'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务流程框架**（**eTOM**）：由TM论坛维护的电信运营模型'
- en: Routing
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'Routing patterns provide different approaches to handling messages. Here are
    some examples of patterns that fall into this category:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模式提供了处理消息的不同方法。以下是一些属于这一类别的模式示例：
- en: '**Content-based Routing**: The route or destination application(s) is determined
    by the content in the message.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的路由：**路由或目标应用程序由消息中的内容确定。'
- en: '**Message Filtering**: Only messages of interest are forwarded on to the destination
    application(s).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息过滤器：**只有感兴趣的消息才会转发到目标应用程序。'
- en: '**Splitter**: Multiple messages are generated from a single message.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分裂器：**从单个消息生成多个消息。'
- en: '**Aggregator**: A single message is generated from multiple messages.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合器：**从多个消息生成单个消息。'
- en: '**Scatter-Gather**: A pattern for handling a broadcast of multiple messages
    and aggregating the responses into a single message.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分散-聚合：**用于处理多条消息的广播并将响应聚合成单条消息的模式。'
- en: The Scatter-Gather pattern is a very useful pattern and, as it combines both
    the Splitter and Aggregator patterns, it is a great example to explore. With this
    pattern, a more complex business process can be modeled.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 分散-聚合模式是一个非常有用的模式，因为它结合了分裂器和聚合器模式，是一个很好的探索示例。通过这种模式，可以建模更复杂的业务流程。
- en: In our scenario, we will take the fulfillment of an ordering system of widgets.
    The good news is, several vendors, sell widgets, but the price of widgets fluctuates
    often. So, which vendor has the best price changes? Using the Scatter-Gather pattern,
    the ordering system can query multiple vendors, select the best price, and then
    return the result back to the calling system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The Splitter pattern will be used to generate multiple messages to the vendors
    as shown in the following diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4565e5-a899-41d0-8c81-1d050bf2f76f.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'The routing then waits until the vendor responses are received. Once the responses
    have been received, the Aggregator pattern is used to compile the results into
    a single message to the calling application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/451c57f7-ef45-48ee-ae38-abd3ee2493e2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: It is worth noting that there are many variations and circumstances for this
    pattern. The Scatter-Gather pattern might require all vendors to respond or just
    some of them. Another scenario might require a limit on the amount of time the
    process should wait for a response from a vendor. Some messages might take milliseconds
    for a response while other scenarios might take days for a response to be returned.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: An integration engine is software that supports many integration patterns. The
    integration engine can range from locally installed services to cloud-based solutions.
    Some of the more popular engines are Microsoft BizTalk, Dell Boomi, MuleSoft Anypoint
    Platform, IBM WebSphere, and SAS Business Intelligence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Software development life cycle patterns
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many approaches to managing software development and the two most
    common **software development life cycle** (**SDLC**) patterns are **Waterfall** and
    **Agile**. There are many variations of these two SDLC methodologies and often
    an organization will adapt a methodology to fit the project and team(s) as well
    as the company culture.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall and Agile SDLCs patterns are just two examples and there are several
    other patterns for software development that may suit a company's culture, software
    maturity, and industry better than others.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall SDLC
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Waterfall approach comprises distinct phases that a project or piece of
    work goes through sequentially. Conceptually, it is simple to understand and it
    follows patterns used in other industries. The following is an example of the
    different phases:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirements phase**: All requirements to be implemented are gathered and
    documented.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design phase**: Using the documentation produced in the previous step, the
    design that which is to be implemented is completed.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development phase**: Using the design from the previous step, the changes
    are implemented.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing phase**: The changes implemented in the previous step are verified
    against the specified requirements.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment phase**: Once the testing has been completed, the changes performed
    by the project are deployed.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many strengths to the Waterfall model. The model is easy to understand
    and easy to manage, as each phase has a clear definition of what has to be done
    and what has to be delivered out of each phase. By having a series of phases,
    milestones can be defined, allowing for easier reporting on progress. Also, with
    distinct phases, the roles and responsibilities of the resources required can
    be more easily planned.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: But what if something does not go to plan or things change? The Waterfall SDLC
    does have some disadvantages, and many of the disadvantages stem from its lack
    of flexibility for change, or the instances when things are discovered, requiring
    input from a previous step. In Waterfall, if a situation occurs requiring information
    from a previous phase, the previous phase is repeated. This poses several problems.
    As phases might be reported, reporting becomes difficult because a project (that
    had passed a phase or milestone) is now repeating the phase. This could promote
    a *witch-hunt* company culture, where the effort is diverted to finding blame
    rather than measures to prevent recurring issues. Also, resources might no longer
    be available, as they have been moved onto other projects and/or have left the
    company.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果出现了意外情况或事情发生了变化怎么办？瀑布式SDLC确实有一些缺点，其中许多缺点源于其对变更的灵活性不足，或者在发现事情时需要输入之前步骤的情况。在瀑布式中，如果出现需要来自前一阶段信息的情况，前一阶段将被重复。这带来了几个问题。由于阶段可能被报告，因此报告变得困难，因为项目（已通过阶段或里程碑的项目）现在正在重复该阶段。这可能会促进一种“寻找替罪羊”的公司文化，其中努力转向寻找责任，而不是采取措施防止问题再次发生。此外，资源可能不再可用，因为它们已被移至其他项目和/或已离开公司。
- en: 'The following diagram illustrates how the cost and time increase the further
    into the phases that an issue is discovered:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了成本和时间随着问题在各个阶段被发现的时间越晚而增加的情况：
- en: '![](img/0fd85921-da03-4dc6-a7fa-96788393df98.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd85921-da03-4dc6-a7fa-96788393df98.png)'
- en: Because of the cost associated with change, the Waterfall SDLC tends to suit
    smaller projects with a lower risk of change. Larger and more complex projects
    increase the potential for change, as requirements might be altered or the business
    drivers change during the project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变更所带来的成本，瀑布式SDLC倾向于适用于风险较低的较小项目。较大和更复杂的项目增加了变更的可能性，因为在项目进行过程中需求可能会被改变或业务驱动因素发生变化。
- en: Agile SDLC
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷SDLC
- en: The Agile SDLC approach to software development attempts to embrace change and
    uncertainty. This is achieved by using a pattern that allows for change and/or
    the occurrence of issues that are discovered during the life of a project or product
    development. The key concept is to break the project into smaller iterations of
    development, often referred to as development cycles. In each cycle, the basic
    Waterfall stages are repeated so each cycle has requirements, design, development,
    testing, and deployment phase.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷SDLC方法试图接纳变化和不确定性。这是通过使用允许在项目或产品开发过程中发现问题的模式来实现的。关键概念是将项目分解为较小的开发迭代，通常称为开发周期。在每个周期中，基本的瀑布式阶段都会重复，因此每个周期都有需求、设计、开发、测试和部署阶段。
- en: 'This is a simplification but the strategy of breaking the project into cycles
    has several advantages over Waterfall:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简化，但将项目分解为周期的策略比瀑布式具有几个优点：
- en: The impact of shifting business requirements is lessened as the scope is smaller.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着范围变小，业务需求变化的影响减小。
- en: The stakeholders get a visibly working system earlier than with Waterfall. Though
    not complete, this provides value as it allows for feedback to be incorporated
    earlier into a product.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者比瀑布式更早地获得可见的工作系统。虽然不完整，但这提供了价值，因为它允许更早地将反馈纳入产品中。
- en: Resourcing might benefit as the type of resources has fewer fluctuations.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源配置可能会受益，因为资源类型的波动较少。
- en: '![](img/f843873a-17d4-4174-8ca2-3a977d04bf18.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f843873a-17d4-4174-8ca2-3a977d04bf18.png)'
- en: The preceding diagram provides a summary of the two approaches.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上图提供了两种方法的总结。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed major design patterns used in modern software
    development that were introduced in the previous chapter. We started with the
    discussion of various software development principles such as the DRY, KISS, YAGNI,
    MVP, and SOLID programming principles. Then, we covered software development patterns
    including GoF and EIPs. The methodology for SDLC was covered, including Waterfall
    and Agile. The purpose of this chapter was to illustrate how patterns are used
    across all levels of software development.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了现代软件开发中使用的主要设计模式，这些模式是在上一章中介绍的。我们从讨论各种软件开发原则开始，如DRY、KISS、YAGNI、MVP和SOLID编程原则。然后，我们涵盖了软件开发模式，包括GoF和EIPs。我们还涵盖了SDLC的方法，包括瀑布和敏捷。本章的目的是说明模式如何在软件开发的各个层次上使用。
- en: As the software industry matures, patterns emerge as experience evolves, techniques
    grow, and technology advances. Some patterns have been developed to help different
    phases of the SDLC. For example in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*, **Test-driven development** (**TDD**) will be
    explored, where the definitions of tests are used to provide both measurable progress
    as well as clear requirements, during the development phase. As the chapters progress,
    we will discuss higher levels of abstraction in software development, including
    patterns for web development as well as modern architecture patterns for on-premise
    and cloud-based solutions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件行业的成熟，随着经验的积累、技术的进步，模式开始出现。一些模式已经被开发出来，以帮助SDLC的不同阶段。例如，在[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)中，将探讨**测试驱动开发**（TDD），其中测试的定义用于在开发阶段提供可衡量的进展和清晰的需求。随着章节的进展，我们将讨论软件开发中更高层次的抽象，包括Web开发的模式以及面向本地和基于云的解决方案的现代架构模式。
- en: In the next chapter, we will start by building a fictitious application in .NET
    Core. Also, we will explain the various patterns discussed in this chapter, including
    programming principles such as SOLID, and illustrate several GoF patterns.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从在.NET Core中构建一个虚构的应用程序开始。此外，我们将解释本章讨论的各种模式，包括SOLID等编程原则，并说明几种GoF模式。
- en: Questions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: In SOLID, what does the S stand for? What is meant by a responsibility?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SOLID中，S代表什么？责任是什么意思？
- en: 'Which SDLC method is built around cycles: Waterfall or Agile?'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种SDLC方法是围绕循环构建的：瀑布还是敏捷？
- en: Is the Decorator pattern a creational or structural pattern?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰者模式是创建型模式还是结构型模式？
- en: What does Pub-Sub integration stand for?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pub-Sub集成代表什么？

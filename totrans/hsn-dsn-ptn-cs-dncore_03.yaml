- en: Modern Software Design Patterns and Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, **object-oriented programming** (**OOP**) was discussed
    in preparation for exploring different patterns. As many patterns rely on concepts
    in OOP, it is important to introduce and/or revisit these concepts. Inheritance
    between classes allows us to define an *is-a-type-of relationship*. This provides
    a higher degree of abstraction. For example, with inheritance it is possible to
    perform comparisons such as a *cat *is a type of *animal* and a *dog* is a type
    of *animal*. Encapsulation provides a way of controlling the visibility and access
    of details of a class. Polymorphism provides the ability to handle different objects
    using the same interface. With OOP, a higher level of abstraction can be achieved,
    providing a more manageable and understandable way to deal with large solutions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter catalogs and introduces different patterns used in modern software
    development. This book takes a very broad view of what a pattern is. A pattern
    in software development is any solution to a general problem that software programmers
    face during development. They are built from experience on what works and what
    does not. Also, these solutions are trialed and tested by numerous developers
    in various situations. The benefit of using a pattern is based on this past activity
    both in not repeating the effort and in the assurance that the problem will be
    solved without introducing a defect or issue.
  prefs: []
  type: TYPE_NORMAL
- en: Especially when taking technology-specific patterns into consideration, there
    are too many to cover in a single book so this chapter will highlight specific
    patterns to illustrate different types of pattern. We have tried to pick out the
    commonest and most influential patterns based on our experience. In subsequent
    chapters, specific patterns will be explored in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Design principles, including SOLID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern catalogs, including **Gang of Four** (**GoF**) patterns and **Enterprise
    Integration Pattern** (**EIP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software development life cycle patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and practices for solution development, cloud development, and service
    development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the Installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2).
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably, the most important aspect of good software development is software
    design. Developing software solutions that are both functionally accurate and
    easy to maintain is challenging and relies considerably on using good development
    principles. Over time, some decisions that were made early in the project can
    cause solutions to become too costly to maintain and extend, forcing systems to
    be rewritten, while others with a good design can be extended and adapted as business
    requirements and technology change. There are many software development design
    principles and this section will highlight some popular and important ones you
    need to be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: DRY – Don't Repeat Yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The guiding thought behind the **Don't Repeat Yourself** (**DRY**) principle
    is that duplication is a waste of time and effort. The repetition could take the
    form of processes and code. Handling the same requirement multiple times is a
    waste of effort and creates confusion within a solution. When first viewing this
    principle, it might not be clear how a system could end up duplicating a process
    or code. For example, once someone has determined how to do a requirement, why
    would someone else take the effort to duplicate the same functionality? There
    are many circumstances in which this happens in software development, and understanding
    why this happens is key to understanding the value of this principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common causes of code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of understanding**: In large solutions, a developer might not have a
    full understanding of an existing solution and/or does not know how to apply abstraction
    to solve the problem with existing functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy and paste**: To put this simply, the code is duplicated in multiple
    classes instead of refactoring the solution to allow for multiple classes to access
    the shared functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KISS – Keep It Simple Stupid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to DRY, **Keep It Simple Stupid** (**KISS**) has been an important principle
    in software development for many years. KISS stresses that simplicity should be
    the goal and complexity should be avoided. The key here is to avoid unnecessary
    complexity and thus reduce the chances of things going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI – You Aren't Gonna Need It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**You Aren''t Gonna Need It** (**YAGNI**) simply states that functionality
    should only be added when it is required. Sometimes in software development, there
    is a tendency to *futureproof* a design in case something changes. This can create
    requirements that are actually not needed currently or in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Always implement things when you actually need them, never when you just foresee
    that you need them."'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Ron Jeffries*'
  prefs: []
  type: TYPE_NORMAL
- en: MVP – Minimum Viable Product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By taking a **Minimum Viable Product** (**MVP**) approach, the scope of a piece
    of work is limited to the smallest set of requirements in order to produce a functioning
    deliverable. MVP is often combined with Agile software development (see the *Software
    development life cycle patterns* section later in the chapter) by limiting requirements
    to a manageable amount that can be designed, developed, tested, and delivered.
    This approach lends itself well to smaller website or application development,
    where a feature set can be progressed all the way to production in a single development
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, MVP will be illustrated in a fictitious scenario where
    the technique will be used to limit the scope of changes as well as to help the
    team focus during the design and requirement gathering phases.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID is one of the most influential design principles and we will cover it
    in more detail in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*. Actually made up of five design principles,
    the intention of SOLID is to encourage designs that are more maintainable and
    easier to understand. These principles encourage code bases that are easier to
    modify and they reduce the risk of issues being introduced.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1,* SOLID will be covered in more detail by being applied
    to a C# application.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class should have only one responsibility. The goal of this principle is
    to simplify our classes and logically structure them. Classes with multiple responsibilities
    are harder to understand and modify, as they are more complex. Responsibility
    in this circumstance is simply a reason for the change. Another way of looking
    at responsibility is to define it as a single part of the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A class should have one, and only one, reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Robert C. Martin*'
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open/closed principle is best described in terms of OOP. A class should
    be designed with inheritance as a means of extending its functionality. Change,
    in other words, is planned for and considered while the class is being designed.
    By defining and using an interface that the class implements, the open/closed
    principle is applied. The class is *open* for modification, while its description,
    the interface, is *closed *for modification.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to substitute objects at runtime is the basis of the Liskov substitution
    principle. In OOP, if a class inherits from a base class or implements an interface,
    then it can be referenced as an object of the base class or interface. This is
    easier to describe with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define an interface for an animal and implement two animals, `Cat` and
    `Dog`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can refer to the `Cat` and `Dog` as an animal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the single responsibility principle, the interface segregation principle
    states that an interface should be limited to containing only methods that are
    relevant to a single responsibility. By reducing the complexity of the interface,
    the code becomes easier to refactor and understand. An important benefit of adhering
    to this principle in a system is that it aids in decoupling a system by reducing
    the number of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**), also referred to as the dependency
    injection principle, states that modules should not depend on details but on abstractions
    instead. This principle encourages writing loosely coupled code to enhance readability
    and maintenance, especially in a large complex code base.
  prefs: []
  type: TYPE_NORMAL
- en: Software patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, many patterns have been compiled into catalogs. This section
    will use two catalogs as an illustration. The first catalog is a collection of
    OOP-related patterns by the **GoF**. The second relates to the integration of
    systems and remains technologically agnostic. At the end of the chapter, there
    are some references for additional catalogs and resources.
  prefs: []
  type: TYPE_NORMAL
- en: GoF patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Potentially, the most influential and well-known OOP collection of patterns
    comes from the *Design Patterns: Elements of Reusable Object-Oriented Software* book
    by *GoF.* The aim of the patterns in the book is on a lower level—that is, object
    creation and interaction—instead of a larger software architecture concern. The
    collection consists of templates that can be applied to particular scenarios with
    the goal of producing solid building blocks while avoiding common pitfalls in
    object-oriented development.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Erich Gamma, John Vlissides, Richard Helm*, and *Ralph Johnson* are referred
    to as the GoF because of their widely influential publications in the 1990s. The
    book *Design Patterns: Elements of Reusable Object-Oriented Software *has been
    translated into several languages and contains examples in both C++ and Smalltalk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection is broken into three categories: creational patterns, structural
    patterns, and behavioral patterns which will be explained in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following five patterns are concerned with the instantiation of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract Factory**: A pattern for the creation of objects belonging to a
    family of classes. The specific object is determined at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder**: A useful pattern for more complex objects where the construction
    of the object is controlled externally to the constructed class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory Method**: A pattern for creating objects derived from a class where
    the specific class is determined at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: A pattern for copying or cloning an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: A pattern for enforcing only one instance of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns - Basics Part 1*, the Abstract Factory pattern will be explored in more
    detail. In [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*, the Singleton and Factory Method patterns will
    be explored in detail, including using the .NET Core framework support for these
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following patterns are concerned with defining relationships between classes
    and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter**: A pattern for providing a match between two different classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: A pattern for allowing the implementation details of a class to
    be replaced without requiring the class to be modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: Used to create a hierarchy of classes in a tree structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: A pattern for replacing the functionality of a class at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: A pattern used to simplify complex systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**: A pattern used to reduce the resource usage for complex models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: A pattern used to represent another object allowing for an additional
    level of control between the calling and called objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate a structural pattern, let''s take a closer look at the Decorator
    pattern by using an example. This example will print messages on a console application.
    First, a base message is defined with a corresponding interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The base class allows for the storage of a text string and requires that child
    classes implement the `PrintMessage()` method. This will then be extended into
    two new classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first class is a `SimpleMessage` that writes the given text to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second class is an `AlertMessage` that also writes the given text to the
    console but performs a beep as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two is that the `AlertMessage` class will issue a
    beep instead of only printing the text to the screen like the `SimpleMessage`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, a base decorator class is defined that will contain a reference to a
    `Message` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The following two classes illustrate the Decorator pattern by providing additional
    functionality for our existing implementation of `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is a `NormalDecorator` that prints the message whose foreground is
    green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ErrorDecorator` uses a red foreground color to make the message more pronounced
    when printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`NormalDecorator` will print the text in green while the `ErrorDecorator` will
    print the text in red. The important thing with this example is that the decorator
    is extending the behavior of the referenced `Message` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the example, the following shows how new messages can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example will illustrate how the different Decorator patterns can
    be used to change the referenced functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38b95d57-b790-4f1f-bb20-6984784a8d82.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a simplified example but imagine a scenario where a new requirement
    is added to the project. Instead of using the beep sound, the system sound for
    exclamation should be played.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we have a structure in place to handle this, the amendment is a one-line
    change as shown in the previous code block.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following behavioral patterns can be used to define the communication between
    classes and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain** **of** **Responsibility**: A pattern for handling a request between
    a collection of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: A pattern used to represent a request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreter**: A pattern for defining syntax or language for instructions
    in a program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: A pattern for traversing a collection of items without detailed
    knowledge of the elements in a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: A pattern for simplifying communication between classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: A pattern for capturing and storing the state of an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: A pattern for allowing objects to be notified of changes to another
    object''s state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: A pattern for altering an object''s behavior when its state changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: A pattern for implementing a collection of algorithms where a
    specific algorithm can be applied at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template** **Method**: A pattern for defining the steps of an algorithm while
    leaving the implementation details in a subclass'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: A pattern promoting loose coupling between data and functionality,
    allowing for additional operations to be added without requiring changes to the
    data classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A useful pattern you need to be familiar with is the Chain of Responsibility
    pattern so we will use it as an example. With this pattern, we will set up a collection
    or chain of classes for handling a request. The idea is the request will pass
    through each class until it is handled. This illustration uses a car service center,
    where each car will pass through the different sections of the center until the
    service is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a collection of flags that will be used to indicate the
    services required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `FlagsAttribute` in C# is a great way of using a bit field to hold a collection
    of flags. The single field will be used to indicate the enum values that are *turned
    on* by using bitwise operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Car` will contain a field to capture what servicing is required and a
    field that returns true when the service has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One thing to point out is that a `Car` is considered to have its service completed
    once all the requirements have been completed, as represented by the `IsServiceComplete`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract base class will be used to represent each of our service technicians
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Take note that the service provided by the class that extends the `ServiceHandler`
    class, in other words the technician, is required to be passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service will then be performed by using the bitwise `NOT` operation (`~`)
    to *turn off* the bit on the given `Car`, indicating the service is required in
    the `Service` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If all services have been completed on the car and/or there are no more services,
    the chain is stopped. If there is another service and a car is not ready, then
    the next service handler is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach requires the chain to be set and the preceding example shows
    this being done using the `SetNextServiceHandler()` method to set the next service
    to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The service specialists include a `Detailer`, `Mechanic`, `WheelSpecialist`,
    and a `QualityControl` engineer. The `ServiceHandler` representing a `Detailer`
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The mechanic, whose specialty is tuning the engine, is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The wheel specialist is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And last is quality control, who will take the car for a test drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The service center technicians have been defined, so the next step is to service
    a couple of cars. This will be illustrated in the `Main` code block, starting
    with constructing the required objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will be to set up the handling order for the different services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then two calls will be made to the mechanic, which is the start of the chain
    of responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is the order in which the chain is set. For this
    service center, the mechanic first performs tuning, followed by the wheels being
    aligned. Then, a test drive is performed and after that, the car is worked up
    in detail. Originally, the test drive used to be performed as the last step, but
    the service center determined that, on rainy days, this required the car details
    to be repeated. A bit of a silly example, but it illustrates the benefit of having
    the chain of responsibility defined in a flexible manner.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50fb4e09-4160-462b-91f8-2a84ddde769c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the display after our two cars have been serviced.
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting pattern to explore in more detail is the **Observer pattern**.
    This pattern allows for instances to be informed of when a particular event happens
    in another instance. In this way, there are many observers and a single subject.
    The following diagram illustrates this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c945ea79-025c-437f-a14b-f61c6af08216.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's provide an example by creating a simple C# console application that will
    create a single instance of a `Subject` class and multiple `Observer` instances.
    When a quantity value changes in the `Subject` class, we want each `Observer` instance
    to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Subject` class contains a private quantity field that is updated by a
    public `UpdateQuantity` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to alert any observers, we use the C# keywords, `delegate` and `event`.
    The `delegate` keyword defines the format or handler that will be called. The
    delegate to be used when the quantity is updated is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The delegate defines `QuantityUpdated` to be a method that receives an integer
    and does not return any value. An event is then added to the `Subject` class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the `UpdateQuantity` method, it is called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will define a method in the `Observer` class that has the
    same signature as the `QuantityUpdated` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This implementation will be alerted when the quantity of the `Subject` instance
    changes and will print a message to the console in a specific color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put these together in a simple application. At the start of the application,
    a single `Subject` and three `Observer` objects will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, each `Observer` instance will register to be alerted by the `Subject` when
    the quantity changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will update the quantity twice, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is run, we get three messages printed in different colors
    for each update statement, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bd7a38b-7646-41ff-b808-139593727342.png)'
  prefs: []
  type: TYPE_IMG
- en: This was a simple sample using the C# `event` keyword, but, hopefully, it illustrates
    how this pattern could be used. The advantage here is it loosely couples the subject
    from the observers. The subject does not have to have knowledge of the different
    observers, or even knowledge of whether any exist.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise integration patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Integration** is a discipline of software development that benefits greatly
    from leveraging the knowledge and experience of others. With this in mind, many
    catalogs of EIPs exist, some of which are technology agnostic while others are tailored
    to a particular technology stack. This section will highlight some popular integration
    patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Enterprise Integration Patterns*, by *Gregor Hohpe* and *Bobby Woolf*, provides
    a solid resource for many integration patterns across a variety of technologies.
    This book is often referenced when discussing EIPs. The book is available at [https://www.enterpriseintegrationpatterns.com/](https://www.enterpriseintegrationpatterns.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important consideration for enterprise integration is the topology of the
    systems being connected. In general, there are two distinct topologies: hub-and-spoke
    and enterprise service bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **hub-and-spoke** (hub) topology describes an integration pattern where a
    single component, the hub, is centralized and it communicates with each application
    explicitly. This centralizes the communication so that the hub only needs to know
    about the other applications, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows the hub, in blue, as having explicit knowledge of how to communicate
    with the different applications. This means that, when a message is to be sent
    from A to B, it is sent from A to the hub and then forwarded on to B. The advantage
    of this approach for an enterprise is that connectivity to B has to be defined
    and maintained only in one place, the hub. The significance here is that the security
    is controlled and maintained in one central location.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **enterprise service bus** (**ESB**) relies on a messaging model comprising
    of publishers and subscribers (Pub-Sub). A publisher submits messages to the bus
    and a subscriber registers to receive published messages. The following diagram
    illustrates this topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, if a message is to be routed from **A** to **B**,
    **B** subscribes to the ESB for messages published from **A**. When **A** publishes
    a new message, the message is sent to **B**. In practice, the subscription can
    be more complex. For example, in an ordering system, there might be two subscribers
    for priority orders and normal orders. In this situation, priority orders might
    then be handled differently from normal orders.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we define an integration between two systems as having distinct steps, we
    can then define patterns in each step. Let''s take a look at the following diagram
    to discuss an integration pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23a2329-2813-437d-8cfa-914e26954910.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This pipeline is simplified as there could be more or fewer steps in a pipeline
    depending on the technology used. The purpose of the diagram is to provide some
    context as we look at some common integration patterns. These can be broken into
    categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messaging**: Patterns related to the handling of messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformation**: Patterns related to altering message content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: Patterns related to the exchange of messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Patterns related to messaging can take the form of message construction and
    channels. A channel, in this context, is the endpoint and/or how the message enters
    and exits the integration pipeline. Some examples of construction-related patterns
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Sequence**: The message contains a sequence to indicate a particular
    processing order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correlation Identifier**: The message contains a medium to identify related
    messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return Address**: The message identifies information about returning a response
    message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expiration**: The message has a finite time that it is considered valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the *Topology* section, we covered some patterns related to channels but
    the following are additional patterns you should consider in integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Competing Consumers**: Multiple processes could handle the same message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective Consumer**: Consumers use criteria to determine the message to
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dead Letter Channel**: Handles messages that are not successfully processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guaranteed Delivery**: Ensures reliable handling of messages, where no message
    is lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven Consumer:** The handling of messages is based on published events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polling Consumer:** Handles messages that are retrieved from a source system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When integrating complex enterprise systems, transformation patterns allow
    for flexibility in how messages are handled in the system. With transformation,
    a message between two applications can be altered and/or enhanced. Here are some
    transformation-related patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content Enricher**: A message is *enriched* by adding information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canonical Data Model**: A message is transformed into an application-neutral
    message format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Translator**: A pattern for translating one message to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Canonical Data Model** (**CDM**) is a good pattern to highlight. With
    this pattern, a message can be exchanged between multiple applications without
    having to perform a translation for each specific message type. This is best shown
    by an example of multiple systems exchanging messages, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png)'
  prefs: []
  type: TYPE_IMG
- en: In the diagram, applications **A** and **C** want to send their messages in
    their format to application **B** and **D**. If we used the Message Translator
    pattern, only the process, which is handling the transformation, would need to
    know how to translate from **A** to **B** and from **A** to **D** as well as **C**
    to **B** and **C** to **D**. This becomes increasingly difficult as the number
    of applications increases and when the publisher might not know the details of
    its consumers. With the CDM, source application messages for **A** and **B** are
    translated into a neutral schema X.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical schema
  prefs: []
  type: TYPE_NORMAL
- en: A canonical schema is sometimes referred to as a neutral schema, meaning it
    is not aligned directly with a source or destination system. The schema is then
    thought of as being impartial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message in the neutral schema format is then translated to the message
    formats for **B** and **D** as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the enterprise, this becomes unmanageable without some standards, and fortunately,
    many organizations have been created to produce as well as govern standards in
    many industries, including the following examples (but there are many more!):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electronic Data Interchange For Administration, Commerce and Transport**
    (**EDIFACT**): An international standard for trade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMS Question and Test Interoperability specification** (**QTI**)**:** Standards
    for the representation of assessment content and results produced by the **Information
    Management System** **(****IMS**) **Global Learning Consortium** (**GLC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hospitality Industry Technology Integration Standards (HITIS)**: Standards
    for property management systems maintained by the American Hotel and Motel Association'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X12 EDI (X12)**: Collection of schemas for health care, insurance, government,
    finance, transportation, and other industries maintained by the Accredited Standards
    Committee X12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business Process Framework** (**eTOM**): Telecommunications operating model
    maintained by the TM Forum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routing patterns provide different approaches to handling messages. Here are
    some examples of patterns that fall into this category:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-based Routing**: The route or destination application(s) is determined
    by the content in the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Filtering**: Only messages of interest are forwarded on to the destination
    application(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Splitter**: Multiple messages are generated from a single message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregator**: A single message is generated from multiple messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scatter-Gather**: A pattern for handling a broadcast of multiple messages
    and aggregating the responses into a single message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scatter-Gather pattern is a very useful pattern and, as it combines both
    the Splitter and Aggregator patterns, it is a great example to explore. With this
    pattern, a more complex business process can be modeled.
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, we will take the fulfillment of an ordering system of widgets.
    The good news is, several vendors, sell widgets, but the price of widgets fluctuates
    often. So, which vendor has the best price changes? Using the Scatter-Gather pattern,
    the ordering system can query multiple vendors, select the best price, and then
    return the result back to the calling system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Splitter pattern will be used to generate multiple messages to the vendors
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4565e5-a899-41d0-8c81-1d050bf2f76f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The routing then waits until the vendor responses are received. Once the responses
    have been received, the Aggregator pattern is used to compile the results into
    a single message to the calling application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/451c57f7-ef45-48ee-ae38-abd3ee2493e2.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth noting that there are many variations and circumstances for this
    pattern. The Scatter-Gather pattern might require all vendors to respond or just
    some of them. Another scenario might require a limit on the amount of time the
    process should wait for a response from a vendor. Some messages might take milliseconds
    for a response while other scenarios might take days for a response to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: An integration engine is software that supports many integration patterns. The
    integration engine can range from locally installed services to cloud-based solutions.
    Some of the more popular engines are Microsoft BizTalk, Dell Boomi, MuleSoft Anypoint
    Platform, IBM WebSphere, and SAS Business Intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Software development life cycle patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many approaches to managing software development and the two most
    common **software development life cycle** (**SDLC**) patterns are **Waterfall** and
    **Agile**. There are many variations of these two SDLC methodologies and often
    an organization will adapt a methodology to fit the project and team(s) as well
    as the company culture.
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall and Agile SDLCs patterns are just two examples and there are several
    other patterns for software development that may suit a company's culture, software
    maturity, and industry better than others.
  prefs: []
  type: TYPE_NORMAL
- en: Waterfall SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Waterfall approach comprises distinct phases that a project or piece of
    work goes through sequentially. Conceptually, it is simple to understand and it
    follows patterns used in other industries. The following is an example of the
    different phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirements phase**: All requirements to be implemented are gathered and
    documented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design phase**: Using the documentation produced in the previous step, the
    design that which is to be implemented is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development phase**: Using the design from the previous step, the changes
    are implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing phase**: The changes implemented in the previous step are verified
    against the specified requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment phase**: Once the testing has been completed, the changes performed
    by the project are deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many strengths to the Waterfall model. The model is easy to understand
    and easy to manage, as each phase has a clear definition of what has to be done
    and what has to be delivered out of each phase. By having a series of phases,
    milestones can be defined, allowing for easier reporting on progress. Also, with
    distinct phases, the roles and responsibilities of the resources required can
    be more easily planned.
  prefs: []
  type: TYPE_NORMAL
- en: But what if something does not go to plan or things change? The Waterfall SDLC
    does have some disadvantages, and many of the disadvantages stem from its lack
    of flexibility for change, or the instances when things are discovered, requiring
    input from a previous step. In Waterfall, if a situation occurs requiring information
    from a previous phase, the previous phase is repeated. This poses several problems.
    As phases might be reported, reporting becomes difficult because a project (that
    had passed a phase or milestone) is now repeating the phase. This could promote
    a *witch-hunt* company culture, where the effort is diverted to finding blame
    rather than measures to prevent recurring issues. Also, resources might no longer
    be available, as they have been moved onto other projects and/or have left the
    company.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how the cost and time increase the further
    into the phases that an issue is discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd85921-da03-4dc6-a7fa-96788393df98.png)'
  prefs: []
  type: TYPE_IMG
- en: Because of the cost associated with change, the Waterfall SDLC tends to suit
    smaller projects with a lower risk of change. Larger and more complex projects
    increase the potential for change, as requirements might be altered or the business
    drivers change during the project.
  prefs: []
  type: TYPE_NORMAL
- en: Agile SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Agile SDLC approach to software development attempts to embrace change and
    uncertainty. This is achieved by using a pattern that allows for change and/or
    the occurrence of issues that are discovered during the life of a project or product
    development. The key concept is to break the project into smaller iterations of
    development, often referred to as development cycles. In each cycle, the basic
    Waterfall stages are repeated so each cycle has requirements, design, development,
    testing, and deployment phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplification but the strategy of breaking the project into cycles
    has several advantages over Waterfall:'
  prefs: []
  type: TYPE_NORMAL
- en: The impact of shifting business requirements is lessened as the scope is smaller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stakeholders get a visibly working system earlier than with Waterfall. Though
    not complete, this provides value as it allows for feedback to be incorporated
    earlier into a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resourcing might benefit as the type of resources has fewer fluctuations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f843873a-17d4-4174-8ca2-3a977d04bf18.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram provides a summary of the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed major design patterns used in modern software
    development that were introduced in the previous chapter. We started with the
    discussion of various software development principles such as the DRY, KISS, YAGNI,
    MVP, and SOLID programming principles. Then, we covered software development patterns
    including GoF and EIPs. The methodology for SDLC was covered, including Waterfall
    and Agile. The purpose of this chapter was to illustrate how patterns are used
    across all levels of software development.
  prefs: []
  type: TYPE_NORMAL
- en: As the software industry matures, patterns emerge as experience evolves, techniques
    grow, and technology advances. Some patterns have been developed to help different
    phases of the SDLC. For example in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns - Basics Part 1*, **Test-driven development** (**TDD**) will be
    explored, where the definitions of tests are used to provide both measurable progress
    as well as clear requirements, during the development phase. As the chapters progress,
    we will discuss higher levels of abstraction in software development, including
    patterns for web development as well as modern architecture patterns for on-premise
    and cloud-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start by building a fictitious application in .NET
    Core. Also, we will explain the various patterns discussed in this chapter, including
    programming principles such as SOLID, and illustrate several GoF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In SOLID, what does the S stand for? What is meant by a responsibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which SDLC method is built around cycles: Waterfall or Agile?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the Decorator pattern a creational or structural pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does Pub-Sub integration stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

- en: Implementing Design Patterns - Basics Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we introduced and defined a wide range of modern
    patterns and practices pertaining to the **software development life cycle** (**SDLC**),
    from lower-level development patterns to high-level solution architectural patterns.
    This chapter applies some of those patterns in a sample scenario in order to provide
    context and further understanding of the definitions. The scenario is the creation
    of a solution to manage the inventory of an e-commerce bookseller.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario was chosen as it provides enough complexity to illustrate the patterns
    while the concept is relatively simple. The company needs a way of managing their
    inventory, including allowing users to order their products. The organization
    needs to get an application in place, as soon as possible, to allow them to track
    their inventory, but there are many additional features, including allowing customers
    to order products and provide reviews. As the scenario plays out, the number of
    features requested grows to the point where the development team does not know
    where to start. Fortunately, by applying some good practices to help manage the
    expectations and requirements, the development team is able to simplify their
    initial delivery and get back on track. Also, by using patterns, they are able
    to build a solid foundation in order to help the expansion of the solution as
    new features are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the kickoff of a new project and the creation of the
    first release of the application. The following patterns are illustrated in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimal Viable Product** (**MVP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory pattern (Gang of Four)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3).
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Viable Product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the initial phase of starting a new project to build a software
    application. This is sometimes referred to as a project kickoff or project launch,
    where the initial features and capabilities of the application are collected (in
    other words, requirement gathering).
  prefs: []
  type: TYPE_NORMAL
- en: Many approaches, which can be viewed as patterns, exist for the determining
    the features of a software application. Best practices around how to effectively
    model, conduct interviews and workshops, brainstorm and other techniques are outside
    the scope of this book. Instead, one approach, Minimum Viable Product, is described
    to provide an example of what these patterns might contain.
  prefs: []
  type: TYPE_NORMAL
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to use an inventory management application to manage its growing collection of
    books. This new application will be used both by the staff to manage the inventory,
    and by customers to browse and create new orders. The application will need to
    be scalable, and, as an essential system to the business, it is planned to be
    used for a foreseeable future.
  prefs: []
  type: TYPE_NORMAL
- en: The company is broadly broken down into *business users* and the *development
    team,* where business users are primarily concerned with the functionality of
    the system and the development team is concerned about satisfying the requirements,
    as well as keeping a tab on the maintainability of the system. This is a simplification;
    however, organizations are not necessarily so tidily organized, and individuals
    might not fit correctly into one classification or another. For example, a **Business
    Analyst** (**BA**) or **Subject Matter Expert** (**SME**) often represent both
    a business user and a member of the development team.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a technical book, we will mostly view the scenario from the development
    team's perspective and discuss the patterns and practices used to implement the
    inventory management application.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of several meetings, the business and the development teams
    discussed the requirements of the new inventory management system. Progress toward
    defining a clear set of requirements was slow and the vision of the final product
    was not clear. The development team decided to pare down the enormous list of
    requirements to enough functionality that a key individual could start to record
    some inventory information. This would allow for simple inventory management and
    provide a basis that the business could extend upon. Each new set of requirements
    could then be added to the initial release.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Viable Product (MVP)
  prefs: []
  type: TYPE_NORMAL
- en: A Minimum Viable Product is the smallest set of features of an application that
    can still be released and have enough value for a user base.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of the MVP approach is it gives the business and development teams
    a simplified vision of what needs to be delivered by narrowing the scope of an
    application. By reducing the features that will be delivered, the effort in determining
    what needs to be done becomes more focused. In the FlixOne scenario, a meeting's
    value would often degrade into discussing the particulars of a feature that, although
    important for the final version of the product, would require several features
    to be released before it. For example, the design around a customer-facing website
    was distracting the team from focusing on the data to be stored in the inventory
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: MVP is very useful in situations where the complexity of requirements is not
    fully understood and/or the final vision is not well defined. It is important
    though to still maintain a product vision to avoid the risk of developing functionality
    that may not be required in the final version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business and development teams were able to define the following functional
    requirements for the initial inventory management application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application should be a console application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should print a welcome message that includes the version of the assembly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should loop until a quit command is given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a given command is not successful or not understood, then it should print
    a helpful message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application should respond to simple case-insensitive text commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each command should have a short form, of a single character, and a long form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a command has additional parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one should be entered in sequence and submitted with the return key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one should have a prompt `Enter {parameter}:` where `{parameter}` is the
    name of the parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A help command (`?`) should be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints a summary of the commands available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints example usage of each command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quit command (`q`, `quit`) should be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints a farewell message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ends the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An add inventory command (`"a"`, `"addinventory"`) should be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` parameter of type string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should add an entry into the database with the given name and a 0 quantity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An update quantity command (`"u"`, `"updatequantity"`) should be available
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` parameter of type string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quantity` parameter of a positive or negative integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should update the quantity value of the book with the given name by adding
    the given quantity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A get inventory command (`"g"`, `"getinventory"`) should be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns all the books and their quantities in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the following non-functional requirements were defined:'
  prefs: []
  type: TYPE_NORMAL
- en: No security is required other than what was supplied by the operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short form of a command is for usability while the long form of a command
    is for readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FlixOne example is an illustration of how MVP could be used to help focus
    and streamline the SDLC. It is worth emphasizing that the difference between a
    **Proof of Concept** (**PoC**) and an MVP will differ with each organization.
    In this book, a PoC is different from MVP in that the resulting application is
    not viewed as disposable or incomplete. For a commercial product, this would mean
    the end product could be sold, and for an internal enterprise solution, the application
    could add value to the organization.
  prefs: []
  type: TYPE_NORMAL
- en: How does MVP fit with future development?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another benefit to using MVP to focus and contain requirements is its synergy
    with Agile software development. Breaking development cycles into smaller cycles
    of development is a software development technique that has gained popularity
    over traditional Waterfall development. The driving concept is that requirements
    and solutions evolve during the life cycle of an application and involve a collaboration
    between the development team and the end users. Typically, the agile software
    development framework has a short release cycle where new functionality is designed,
    developed, tested, and released. Release cycles are then repeated as the application
    includes additional functionality. MVP fits well within agile development when
    the scope of work fits within a release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum and Kanban are popular software development frameworks based on agile
    software development.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of the initial MVP requirements was kept to a size that could be designed,
    developed, tested, and released with an agile cycle. In the next cycle, additional
    requirements will be added to the application. The challenge is to limit the scope
    of new functionality to what can be accomplished within a cycle. Each new release
    of functionality is limited to essential requirements or to its MVP. The principle
    here is that, by using an iterative approach to software development, the final
    version of the application will have a greater benefit to the end user than by
    using a single release that requires all requirements to be defined up front.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram sums up the difference between Agile and Waterfall software
    development methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different approaches to **test-driven development** (**TDD**) exist, and a *test*
    can vary from a unit test that is run on demand during development, to a unit
    test that is run during the build of a project, to a test script that will be
    run as a part of **user acceptance testing** (**UAT**). Similarly, a *test* can
    be code or a document describing the steps to be performed by a user in order
    to verify a requirement. A reason for this is that there are different views as
    to what TDD is trying to achieve. TDD for some teams is a technique to refine
    requirements before writing code, while others view TDD as a way of measuring
    or validating the code that is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: UAT
  prefs: []
  type: TYPE_NORMAL
- en: UAT is a term used for the activity during the SDLC where the product or project
    is verified to fulfill specified requirements. This is typically performed by
    members of the business or a selection of customers. Depending on the circumstances,
    this phase can be broken further into alpha and beta stages where alpha testing
    is performed by the development team and beta by the end users.
  prefs: []
  type: TYPE_NORMAL
- en: Why did the team choose TDD?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The development team decided to use TDD for several reasons. First, the team
    wanted a way to clearly measure progress during the development process. Second,
    they wanted to be able to reuse the tests in subsequent development cycles in
    order to continue to validate existing functionality while new functionality is
    added. For these reasons, the team will use unit tests to verify that the functionality
    written satisfies the given requirements of the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the basics of TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png)'
  prefs: []
  type: TYPE_IMG
- en: Tests are added and the code base is updated until all the defined tests pass.
    It is important to note that this is repeated. In each iteration, new tests are
    added and the tests are not considered passed until all tests, new and existing,
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: The FlixOne development team decided to incorporate both unit tests and UAT
    into a single agile cycle. At the beginning of each cycle, new acceptance criteria
    would be determined. This would include the functionality to be delivered, as
    well as how it would be verified or accepted at the end of the development cycle.
    These acceptance criteria would then be used to add tests to the project. The
    development team would then build the solution until the new and existing tests
    passed, and then prepare a build for acceptance testing. Then, the acceptance
    testing would be run, and if any issues were detected, the development team would
    define new tests or amend existing tests based on the failures. The application
    would be developed again until all tests passed and a new build would be prepared.
    This would be repeated until acceptance testing passed. Then, the application
    would be deployed and a new development cycle would begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9798b545-4ea5-418d-91d5-5963745c9089.png)'
  prefs: []
  type: TYPE_IMG
- en: The team now has a plan, so let's start coding!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this scenario, we will use the **Microsoft Unit Test** (**MSTest**) framework. This
    section provides some instructions to create the initial project using the .NET
    Core **command-line interface** (**CLI**) tools. These steps could have been completed
    using an **integrated development environment** (**IDE**) such as Visual Studio
    or Visual Studio Code. The instructions are supplied here to illustrate how the
    CLI can be used to complement the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: CLI
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core CLI tools are cross-platform utilities for developing .NET applications
    and are the basis for more sophisticated tooling, such as IDEs. Please see the
    documentation for more information: [https://docs.microsoft.com/en-us/dotnet/core/tools](https://docs.microsoft.com/en-us/dotnet/core/tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this chapter will consist of three projects: a console application,
    a class library, and a test project. Let''s create the solution directory, FlixOne,
    to contain the solution and sub-directories for the three projects. Within the
    created directory, the following command will create a new solution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates creating the directory and solution (note:
    only an empty solution file has been created so far):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The class library, `FlixOne.InventoryManagement`, will contain our business
    entities and logic. In later chapters, we will split these into separate libraries
    but, as our application is still small, they are contained in a single assembly.
    The `dotnet` core CLI command to create the project is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, in the following screenshot, that a new directory is created containing
    the new class library project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7206ccd0-c6be-432b-bd5c-799896c79687.png)'
  prefs: []
  type: TYPE_IMG
- en: 'References should be made from the solution to the new class library with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new console application project, the following command should be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `console` template being restored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4670643-d4de-4934-b042-0772541e3e0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The console application requires a reference to the class library (note: the
    command needs to be run in the directory with the project file that will have
    the reference added to it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `MSTest` project will be created using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the creation of the MSTest project and should
    be run in the same folder as the solution, FlixOne (note the packages restored
    as part of the command containing the required MSTest NuGet packages):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The test project also requires a reference to the class library (note: this
    command needs to be run in the same folder as the MSTest project file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, both the console application and the MSTest project should be added
    to the solution by running the following commands in the same directory as the
    solution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Visually, the solution is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the initial structure of our solution is ready, let's first start by
    adding to our unit test definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Initial unit test definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development team first transcribed the requirements into some basic unit
    tests. As nothing had been designed or written yet, these mostly take the form
    of noting what functionality should be validated. As the design and development
    progress, these tests will also evolve toward completion; for example, there is
    a requirement for adding inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An add inventory command ("a", "addinventory") is available:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` parameter of type string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an entry into the database with the given name and a `0` quantity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To capture this requirement, the development team created the following unit
    test to serve as a placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the application design becomes known and development starts, the existing
    tests will expand and new tests will be created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png)'
  prefs: []
  type: TYPE_IMG
- en: The importance of the inconclusive tests is that they communicate what needs
    to be accomplished to the team and provide a measure as the development proceeds.
    As the development progresses, inconclusive and failing tests will indicate work
    to be undertaken and successful tests will indicate progress toward completing
    the current set of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate our first pattern, let''s walk through the development of the
    help command and the initial console application. The initial version of the console
    application is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the application starts, both a greeting and the result of a help command
    are shown. The application will then process entered commands until the quit command
    is entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the detail of handling commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Until the application solution quits, the application will continue to prompt
    the user for command and, if a command was not successfully handled, then help
    text is shown.
  prefs: []
  type: TYPE_NORMAL
- en: RunCommand(out bool shouldQuit)
  prefs: []
  type: TYPE_NORMAL
- en: C# 7.0 introduces a more fluid syntax for creating `out` parameters. This will
    declare the variables in the scope of the command block. This is illustrated with
    the following, where the `shouldQuit` Boolean is not declared ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: InventoryCommand abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing to point out about the initial console application is that the
    team is using **object-oriented programming** (**OOP**) to create a standard way
    of handling commands. What the team learned from this initial design is that all
    commands will contain a `RunCommand()` method that will return two Booleans indicating
    whether the command was successful and whether the program should terminate. For
    example, the `HelpCommand()` will simply display a help message to the console
    and should not cause the program to end. The two return Booleans would then be
    *true*, to indicate that the command ran successfully and *false, *to indicate
    that the application should not terminate. The following shows the initial version:'
  prefs: []
  type: TYPE_NORMAL
- en: The ... indicates additional statements and, in this particular example, additional `Console.WriteLine()`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QuitCommand` will display a message and then cause the program to end.
    The initial `QuitCommand` was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The team decided to either create an interface that both classes implement,
    or an abstract class that both classes inherit from. Both could have achieved
    the desired dynamic polymorphism but the team chose to use an abstract class as
    all commands will have shared functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OOP and in particular C#, polymorphism is supported in three main ways:
    function overloading, generics, and subtyping or dynamic polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Abstract Factory Design pattern, the team created an abstract class
    that commands would inherit from, `InventoryCommand`. The `InventoryCommand` class
    has a single method, `RunCommand`, that will perform the command and return whether
    the command was successfully executed and whether the application should quit.
    The class is abstract, meaning the class contains one or more abstract methods.
    In this case, the `InternalCommand()` method is abstract and the intent is that
    classes deriving from the `InventoryCommand` class will implement the `InternalCommand`
    method with the specific command functionality. For example, `QuitCommand` will
    extend `InventoryCommand` and provide a concrete implementation for the `InternalCommand()`
    method. The following snippet shows the `InventoryCommand` abstract class with
    the abstract `InternalCommand()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract method would then be implemented in each derived class, as illustrated
    with the `HelpCommand`. The `HelpCommand` simply prints some information to the
    console and then returns `true`, indicating that the command was executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The development team then decided on making two additional changes to the `InventoryCommand`.
    The first thing they did not like was how the `shouldQuit` Boolean was being returned
    as an *out* variable. Thus, they decided to use the new tuples feature of C# 7
    to instead return a single `Tuple<bool,bool>` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tuple
  prefs: []
  type: TYPE_NORMAL
- en: The tuple is a C# type that provides a lightweight syntax for packaging multiple
    values into a single object easily. The disadvantage over defining a class is
    you lose inheritance and other object-oriented functionality. For more information,
    please see [https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples).
  prefs: []
  type: TYPE_NORMAL
- en: The other change was to introduce another abstract class to indicate whether
    the command was a non-terminating command; in other words, a command that does
    not cause the solution to quit or end.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, this command is still abstract as it does not
    implement the `InternalCommand` method of `InventoryCommand`, but it passes a
    false value to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage here is now commands that do not cause the application to end
    – in other words, are non-terminating – now have a simpler definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class diagram shows the inheritance of the `InventoryCommand`
    abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png)'
  prefs: []
  type: TYPE_IMG
- en: There is only one terminating command, `QuitCommand`, while the other commands
    extend the `NonTerminatingCommand` abstract class. It is also worth noting that
    only the `AddInventoryCommand` and `UpdateQuantityCommand` require parameters
    and the use of the `IParameterisedCommand` is explained later in the *Liskov Substitution
    Principle* section. Another subtle point in the diagram is that all the types,
    other than the base `InventoryCommand`, are not public (visible to external assemblies).
    This will become relevant in the *Access modifiers* section later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the team simplifies the code by using patterns, they also use SOLID principles
    to help identify problems. By simplifying the code, the team aims to make the
    code more maintainable and easier for new team members to understand. This approach
    of reviewing the code with a set of principles is very useful in writing concise
    classes that only do what they need to achieve, and putting in a layer of abstraction
    that helps to write code that is easier to modify and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle (SRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first principle that the team applies is the **single responsibility principle**
    (**SRP**). The team identified that the actual mechanism of writing to the console
    is not the responsibility of the `InventoryCommand` classes. Because of this,
    a `ConsoleUserInterface` class is introduced that is responsible for the interaction
    with the user. SRP will help keep the `InventoryCommand` classes smaller and avoid
    situations where the same code is duplicated. For example, the application should
    have a uniform way of prompting the user for information and displaying messages
    and warnings. Instead of repeating this in the `InventoryCommand` classes, this
    logic is encapsulated in the `ConsoleUserInterface` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConsoleUserInteraface` will consist of three methods, as indicated in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method will be used to read input from the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method will print a message to the console using the color green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method will print a message to the console using a dark yellow color
    indicating a warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the `ConsoleUserInterface` class, we can reduce the impact of changes to
    how we interact with the user. As our solution develops, we might find that the
    interface changes from a console to a web application. In theory, we would replace
    the `ConsoleUserInterface` with a `WebUserInterface`. If we had not reduced the
    user interface to a single class, the impact of such a change would most likely
    be more disruptive.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle (OCP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **open/closed principle**, the O in SOLID, is represented by the different
    `InventoryCommand` classes. Instead of having an implementation of the `InventoryCommand`
    class per command, the team could have defined a single class containing multiple
    `if` statements. Each `if` statement would determine what functionality to execute. For
    example, the following illustrates how the team could have broken this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The above method breaks this principle because adding a new command would alter
    the behavior of the code. The idea of the principle is that it is **closed** to
    modification that would *alter* its behavior and instead is **open** to extend
    the class to support additional behavior. This is what is accomplished by having
    the abstract `InventoryCommand` and derived classes (for example, `QuitCommand`,
    `HelpCommand`, and `AddInventoryCommand`). A compelling reason for this, especially
    when combined with the other principles, is that it leads to succinct code that
    is easier to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle (LSP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The commands for quit, help, and get inventory do not require parameters, while
    the `AddInventory` and `UpdateQuantityCommand` do. There are several ways to handle
    this and the team decided to introduce an interface to identify those commands
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By applying the **Liskov substitution principle** (**LSP**), only those commands
    that require parameters should implement the `GetParameters()` method. For example,
    on the `AddInventory` command, the `IParameterisedCommand` is implemented using
    a method defined on the base `InventoryCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetParameter` method on the `InventoryCommand` class simply uses the `ConsoleUserInterface`
    to read a value from the console. The method will be shown later in this chapter.
    In C#, there is handy syntax that shows well how LSP can be used to apply functionality
    to only objects of a specific interface. On the first line of the `RunCommand`
    method, the `is` keyword is used to both test whether the current object implements
    the `IParameterisedCommand` interface as well as cast the object as a new object:
    `parameterisedCommand`. This is shown in bold in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Interface segregation principle (ISP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One approach to handling commands with and without parameters would have been
    to define another method, `GetParameters`, on the `InventoryCommand` abstract
    class, and for those that do not require parameters to just return true to indicate
    that all, in this case no, parameters have been received. For example, the `QuitCommand`,
    `**HelpCommand**`, and `GetInventoryCommand` would all have an implementation
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This would work but it does break the **interface segregation principle** (**ISP**),
    which states that an interface should only contain methods and properties that
    are required. Similar to SRP, which applies to classes, ISP applies to interfaces
    and is effective in keeping interfaces small and focused. In our example, only
    the `AddInventoryCommand` and `UpdateQuantityCommand` classes will implement the
    `InventoryCommand` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**), also referred to as the **dependency
    injection** **principle** (**DIP**), modules should not depend on details but,
    instead, on abstractions. This principle encourages writing loosely coupled code
    to enhance both readability as well as maintenance, especially in a large complex
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we revisit the `ConsoleUserInterface` class that was introduced earlier
    (in the *Single responsibility principle* section), we could use the class without
    the `QuitCommand` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This breaks several SOLID principles, but in regards to DIP, it makes a tight
    coupling between the `QuitCommand` and the `ConsoleUserInterface`. Imagine the
    scenario where the console is no longer the means to display information to the
    user, or what if the constructor of the `ConsoleUserInterface` requires additional
    parameters?
  prefs: []
  type: TYPE_NORMAL
- en: By applying the DIP principle, the following refactor was performed. First a
    new interface, `IUserInterface`, was introduced that contained the definitions
    of the methods implemented in the `ConsoleUserInterface`. Next, the interface,
    and not the concrete class, is used in the `InventoryCommand` classes. Finally,
    a reference to an object implementing the `IUserInterface` is passed into the
    constructor of the `InventoryCommand` classes. This approach protects the `InventoryCommand`
    classes from changes to the implementation details of `IUserInterface` classes,
    as well as providing a mechanism for more easily replacing different implementations
    of `IUserInterface` as the code base evolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DIP is illustrated as follows with the `QuitCommand` and is our final version
    of the class for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the class extends the `InventoryCommand` abstract class, providing
    both a common way of handling commands, as well as providing shared functionality.
    The constructor requires the `IUserInterface` dependency to be injected when the
    object is instantiated. Also note the `QuitCommand` implements a single method,
    `InternalCommand()`, keeping the `QuitCommand` lean and easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the picture, let''s view the final `InventoryCommand` base class.
    The following shows the constructor and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note the `IUserInterface` is passed into the constructor as well as a Boolean
    indicating whether the command is terminating or not. The `IUserInterface` is
    then made available to all implementation of `InventoryCommand` as the `Interface` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RunCommand` is the only public method on the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the `GetParameter` method is a method common to all implementations
    of `InventoryCommand`, so it is made internal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: DIP and IoC
  prefs: []
  type: TYPE_NORMAL
- en: The DIP and **Inversion of Control** (**IoC**) are closely related and all address
    the same issues but in slightly different ways. IoC and its specialized form,
    the **Service Locator Pattern** (**SLP**), use a mechanism to supply an implementation
    of an abstraction on demand. So, instead of injecting the implementation, IoC
    acts as a proxy to supply the details that are required. In the next chapter,
    .NET Core support for these patterns will be explored.
  prefs: []
  type: TYPE_NORMAL
- en: InventoryCommand unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `InventoryCommand` classes taking shape, let''s revisit the unit tests
    so we can start to validate what has been written so far and identify any missing
    requirements. The SOLID principles will show their value here. Because we kept
    our classes (SRP) and interfaces (ISP) small, and focused on just the minimum
    amount of functionality required (LSP), our tests should also be simpler to write
    and validate. For example, a test regarding one of the commands will not need
    to validate the display of the messages on the console (for example, color or
    text size) as that is not the responsibility of the `InventoryCommand` classes
    but of the implementation of the `IUserInterface`. Also, with dependency injection,
    we will be able to isolate the test to just the inventory command. The following
    diagram illustrates this, as the unit test will only validate what is contained
    in the green box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cfda6fb-5968-451a-af94-5bee807667a1.png)'
  prefs: []
  type: TYPE_IMG
- en: By keeping the unit test's scope limited, it will be easier to handle change
    as the application changes. In some situations where it is more difficult to separate
    the functionality due to interdependencies within classes (in other words, when
    SOLID is not followed), a test can span a larger section of the application including
    repositories. These tests are usually referred to as integration tests instead
    of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access modifiers are an important way of handling the visibility of types and
    type members by encapsulating code. By using a clear access strategy, the intent
    of how an assembly and its types should be used can be communicated and enforced.
    For example, in the FlixOne application, only types that should be accessed directly
    by the console are marked as public. This means that the console application should
    have visibility of a limited number of types and methods. These types and methods
    have been marked as public while types and methods that the console should not
    have access to, have been marked as internal, private, or protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please see the Microsoft docs programming guide for more information on access
    modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)'
  prefs: []
  type: TYPE_NORMAL
- en: The `InventoryCommand` abstract class is made public as the console application
    will use the `RunCommand` method to handle the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, note how the constructor and interface are made protected
    to give access to the sub-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following snippet, note that the `RunCommand` method is made public
    while the `InternalCommand` is made internal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the implementations of `InventoryCommand` are marked as internal
    to prevent them from being directly referenced outside of the assembly. This is
    illustrated as follows with the `QuitCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the access of the different implementations will not be visible directly
    to the unit test project, an additional step is required to make the internal
    types visible. The `assembly` directive could be placed in any compiled file and,
    for the FlixOne application, an `assembly.cs` was added containing the assembly
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations where the assembly is signed, the `InternalsVisibleTo()` requires
    a public key. Please see the Microsoft Docs C# Guide for more information: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies).'
  prefs: []
  type: TYPE_NORMAL
- en: Helper TestUserInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As part of a unit test of one of the `InventoryCommand` implementations, we
    do not want to test the referenced dependencies. Fortunately, because the commands
    adhere to the DIP, we can create a `helper`class to validate the implementation
    interactions with the dependencies. One of the dependencies is the `IUserInterface`,
    which is passed into the implementation in the constructor. The following is a
    reminder of the methods of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By implementing a `helper` class, we can supply the information required by
    the `ReadValue` method as well as verify that the appropriate messages are received
    in the `WriteMessage` and `WriteWarning` methods. In the test project, a new class
    called `TestUserInterface` was created that implements the `IUserInterface` interface.
    The class contains three lists containing the expected `WriteMessage`, `WriteWarning`,
    and `ReadValue` calls, and keeps track of the number of times it has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `WriteWarning` method is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `WriteWarning` method performs two asserts. The first verifies that the
    method is not called more times than expected and the second verifies that the
    message received matches the expected message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadValue` method is similar but it additionally returns a value back
    to the calling `InventoryCommand` implementation. This will simulate the user
    entering information into the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As an extra validation step, at the end of a test method, the `TestUserInterface`
    is called to verify that the expected number of `ReadValue`, `WriteMessage`, and
    `WriteWarning` requests were received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `TestUserInterface` class illustrates how a dependency can be mocked to
    provide stubbed functionality as well as provide assertions to help verify the
    expected behavior. In later chapters, we will use a third-party package to provide
    a more sophisticated framework for mocking the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Example unit test – QuitCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with the `QuitCommand`, the requirements are pretty straightforward:
    the command should print a farewell message and then cause the application to
    end. We have designed the `InventoryCommand` to return two Booleans to indicate
    whether the application should quit and whether the command ended successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The test uses the `TestUserInterface` to verify that the text `"Thank you for
    using FlixOne Inventory Management System"`is sent to the `WriteMessage` method
    and no `ReadValue` or `WriteWarning` requests are received. These last two criteria
    are verified by the `expectedInterface.Validate()` call. The result of the `QuitCommand`
    is verified by checking that the `shouldQuit` and `wasSuccessful` Booleans are
    true.
  prefs: []
  type: TYPE_NORMAL
- en: In the FlixOne scenario, the text to be shown is *hardcoded* in the solution
    for simplicity. A better approach would be to use resource files. Resource files
    provide a way of maintaining the text separate from the functionality as well
    as supporting localizing the data for different cultures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the scenario of an online bookseller, FlixOne, wanting
    to build an application for managing their inventory. The chapter covered a range
    of patterns and practices that the development team can use while developing the
    application. The team used MVP to help keep the scope of the initial delivery
    to a manageable level and to help focus the business onto determining the requirements
    that had the maximum benefit to the organization. The team decided to use TDD
    to validate that the delivery matches the requirements and to help the team measure
    progress. The basic project, as well as the unit testing framework, MSTest, was
    created. The team also used SOLID principles to help structure the code in a way
    that will both help readability as well as the maintenance of the code base, as
    new enhancements to the application are added. The first Gang of Four pattern,
    the Abstract Factory design pattern, was used to provide a base for all inventory
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the team will continue to build the initial inventory management
    project to fit the requirements defined in the MVP. The Gang of Four's Singleton
    pattern and the Factory Method pattern will be used by the team. These will be
    shown both with and without the mechanisms supported in .NET Core for these features.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In developing software for an organization, why is it sometimes difficult to
    determine requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two advantages and disadvantages of Waterfall software development
    versus Agile software development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does dependency injection help when writing unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the following statement false? With TDD, you no longer need people to
    test a new software deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

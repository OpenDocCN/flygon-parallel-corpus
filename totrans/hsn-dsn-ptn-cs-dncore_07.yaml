- en: Implementing Design Patterns - .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter continued the building of the FlixOne inventory management
    application by incorporating additional patterns. More of the Gang of Four patterns
    were used, including the Singleton and Factory patterns. The Singleton pattern
    was used to illustrate the Repository pattern that was used to maintain the FlixOne
    collection of books. The Factory pattern was used to further explore the **dependency
    injection** (**DI**). The .Net Core framework was used to complete the initial
    inventory management console application, in order to facilitate an **inversion
    of control** (**IoC**) container.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will continue building upon the inventory management console application,
    while also exploring features of .Net Core. The Singleton pattern, which was covered
    in the previous chapter, will be revisited and created, using the Singleton service
    lifetime built into the .Net Core framework. Using the framework's DI, the Configuration
    pattern will be shown, as well as **constructor injection (CI)** explained, using
    different examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: .Net Core service lifetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples that are used to explain the concepts.
    The code is kept simple, and is just for demonstration purposes. Most of the examples
    involve a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    Version 3 or later).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up .NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL server (express edition is used in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio 2010, or later.
    You can use your preferred IDE. To do this, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The installation instructions and the related library can be found at the following
    link: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code is available in the GitHub repository. The source code
    shown in the chapter might not be complete, so it is advisable to retrieve the
    source in order to run the examples. Please refer to [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5.](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter5)
  prefs: []
  type: TYPE_NORMAL
- en: .Net Core service lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fundamental concept to understand when working with .Net Core''s DI, is service
    lifetimes. A service lifetime defines how a dependency is managed in regards to
    how often it is created. As an illustration of this process, think of DI as managing
    a container of dependencies. Dependency is just a class that the DI knows about,
    because the class was *registered* with it. For .Net Core''s DI, this is done
    with the following three methods of `IServiceCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddTransient<TService, TImplementation>()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddScoped<TService, TImplementation>()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddSingleton<TService, TImplementation>()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IServiceCollection` interface is a collection of registered service descriptions,
    basically containing the dependency, and when the DI should supply the dependency.
    For example, when `TService` is requested, `TImplementation` is supplied (that
    is, injected).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the three service lifetimes, and provide an
    illustration of the different lifetimes via unit tests. We will also look at how
    implementation factories can be used to create instances of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Transient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `transient` dependency means each time the DI receives a request for a dependency,
    then a new instance of the dependency will be created. In most situations, this
    is the service lifetime that makes the most sense to use, as most classes should
    be designed to be lightweight, stateless services. In situations where the state
    needs to be persisted between references and/or if there is considerable effort
    in instantiating a new instance, then another service lifetime might make more
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .Net Core, there is the concept of a scope, which can be thought of as a
    context or boundary for the executing process. In some .Net Core implementations,
    the scope is implicitly defined, so you might not be aware that it is being put
    in place. For example, in ASP.Net Core, a scope is created for each web request
    that is received. This means that, if a dependency has a Scoped lifetime, then
    it will only be constructed once per web request, so, if the same dependency is
    used multiple times for the same web request, it will be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will explicitly create a scope in order to illustrate
    a Scoped lifetime, and the same concept applies in the unit test as it will in
    an ASP.Net Core application.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .Net Core, the Singleton pattern is implemented so that dependency is only
    ever instantiated once, just like the Singleton pattern that was implemented in
    the previous chapter. Similar to the Singleton pattern in the previous chapter,
    the `singleton` class needs to be thread safe, and only the factory method that
    is used to create the singleton class is guaranteed to be called only once by
    a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: Back to FlixOne
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate .Net Core''s DI, we need to make some modifications to the FlixOne
    inventory management application. The first thing to do will be to update the
    `InventoryContext` class, which was defined earlier, in order to no longer implement
    the Singleton pattern (as we will do this using .Net Core''s DI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The detail of the `AddBook` and `UpdateQuantity` methods are shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things to note. The constructor has been changed from
    protected to public. This will allow the class to be instantiated by objects outside
    of the class. Also, note that the static `Instance` property and the private static
    `_instance` field have been removed, while the private `_lock` field remains.
    Similar to the Singleton pattern defined in the previous chapter, this only guarantees
    how the class is instantiated; it does not prevent methods from being accessed
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `IInventoryContext` interface and the `InventoryContext` and `Book`
    classes were made public, as our DI is being defined in an external project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequently, the `InventoryCommandFactory` class, which is used to return
    commands, has been updated to have an instance of the `InventoryContext` injected
    into its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetCommand` method uses the input provided to determine the specific command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted, the `IInventoryContext` interface will now be supplied by the DI
    container that is defined in the client project. The console application now has
    an additional line to create a Singleton of the `IInventoryContext` interface
    using the `InventoryContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The console application can now be run with the same manual test as that performed
    in the previous chapter, but unit tests are a great way to understand what is
    being achieved using .Net Core's DI.
  prefs: []
  type: TYPE_NORMAL
- en: The example code provided for this chapter shows the completed project. The
    following section concentrates on the `InventoryContext` tests. The `InventoryCommandFactory`
    tests were also modified, but, as the changes are trivial, they will not be covered
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the changes to the `InventoryContext` class, we no longer have a convenient
    property for getting the only instance of the class. This means that `InventoryContext.Instance`
    will need to be replaced, and, as a first attempt, let''s create a method to return
    a new instance of `InventoryContext`, and use `GetInventoryContext()` instead
    of `InventoryContext.Instance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the unit tests fail with an error message: *The given key was
    not present in the dictionary*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/270f856b-e1dc-475a-8a82-22e9288276cb.png)'
  prefs: []
  type: TYPE_IMG
- en: As we saw in the previous chapter, this is because the `InventoryContext` list
    of books is empty each time the `InventoryContext` class is created. This is why
    we need to create a context using a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `GetInventoryContext()` method to now supply an instance
    of the `IInventoryContext` interface using .Net Core''s DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the updated method, an instance of the `ServiceCollection` class is created,
    which will be used to contain all the registered dependencies. The `InventoryContext`
    class is registered as a Singleton to be supplied when the `IInventoryContext`
    dependency is requested. A `ServiceProvider` instance is then generated, which
    will actually perform the DI based on the registrations in the `IServiceCollection` interface.
    The final step is to supply the `InventoryContext` class when the `IInventoryContext`
    interface is requested.
  prefs: []
  type: TYPE_NORMAL
- en: The `Microsoft.Extensions.DependencyInjection` library will need to be added
    to the `InventoryManagementTests` project in order to be able to reference the
    .Net Core DI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the unit test still does not pass, and results in the same error: *The
    given key was not present in the dictionary. *This is because we are creating
    a new instance of the DI framework each time `IInventoryContext` is requested.
    This means that even though our dependency is a Singleton, each instance of `ServiceProvider`
    will supply a new instance of the `InventoryContext` class. To get around this,
    we will create `IServiceCollection` when the test first starts up, and then we
    will use the same reference during the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the `TestInitialize` attribute is a great way to separate the functionality
    required by multiple `TestMethod` tests within a `TestClass` class. The method
    will be run before every test is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that there is a reference to the same `ServiceProvider` instance, we can
    update to retrieve the dependency. The following illustrates how the `AddBook()`
    method has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our unit test now passes successfully, as only one instance of the `InventoryContext`
    class is created during the execution of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c92dd81-8d8c-466a-982e-ab7862dcab15.png)'
  prefs: []
  type: TYPE_IMG
- en: The Singleton pattern is relatively easy to implement using the built-in DI,
    as illustrated in this section. Understanding when to use the pattern is an important
    concept. The next section will explore the concept of scope in more detail, in
    order to gain a further understanding of service lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In applications that have multiple processes executing simultaneously, understanding
    service lifetime is very important to both functional and non-functional requirements.
    As illustrated in the previous unit test without the correct service lifetime,
    `InventoryContext` did not function as desired, and led to an invalid situation.
    Likewise, the incorrect use of service lifetimes could lead to applications that
    do not scale well. In general, the use of a lock-and-shared state should be avoided
    in multi-process solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, imagine the FlixOne inventory management application
    was supplied to multiple staff members. The challenge now is how to perform a
    lock across multiple applications, and how to have a single collected state. In
    our terms, this would be a single `InventoryContext` class shared by multiple
    applications. Of course, this is where changing our solution to use a shared repository
    (for example, a database) would make sense, and/or changing our solution to a
    web application. We will cover databases and web application patterns in later
    chapters, but, as we are discussing service lifetimes, it does make sense to describe
    these in terms of a web application in more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts a web app receiving two requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a28f0bf1-4c7f-43ab-9cc4-3de7694fdf4c.png)'
  prefs: []
  type: TYPE_IMG
- en: In terms of service lifetimes, a Singleton service lifetime will be available
    to both requests, while each request receives its own Scope lifetime. The important
    thing to note is around garbage collection. Dependencies that are created with
    a Transient service lifetime are marked to be released once the object is no longer
    referenced, while dependencies created with a Scope service lifetime are not marked
    to be released until the web request completes. And, dependencies created with
    a Singleton service lifetime are not marked to be released until the application
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as shown in the following diagram, it is important to remember that dependencies
    in .Net Core are not shared between server instances in a web garden or web farm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13d3bc5b-0273-488b-9db0-f87daf198604.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following chapters, different approaches to the shared state will be
    shown, including using a shared cache, databases, and other forms of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .Net Core DI supports the ability to specify an *implementation factory*
    when registering a dependency. This allows for control over the creation of the
    dependency that is supplied by the service provided. This is done when registering
    by using the following extension of the `IServiceCollection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSingleton` extension receives both a class to be registered as well
    as the class to be supplied when the dependency is required. An interesting thing
    to note is the .Net Core DI framework will maintain the registered services and
    either deliver the implementation when requested, or as part of instantiating
    one of the dependencies. This automatic instantiation is called **constructor
    injection** (**CI**). We will see examples of both in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: IInventoryContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, let''s revisit the `InventoryContext` class that is used to
    manage the inventory of books, by segregating the read and the write operations
    performed on our collection of books. `IInventoryContext` is split into `IInventoryReadContext`
    and `IInventoryWriteContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: IInventoryReadContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IInventoryReadContext` interface contains the operation to read the books,
    while `IInventoryWriteContext` contains the operations that modify the collection
    of books. The original `IInventoryContext` interface was created for convenience
    for when a class requires both dependency types.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will cover patterns that take advantage of splitting the
    context, including the **Command and** **Query Responsibility Segregation** (**CQRS**)
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this refactor, some changes are required. First classes only requiring
    to read the collection of books have their constructor updated with the `IInventoryReadContext`
    interface, as illustrated in the `GetInventoryCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: IInventoryWriteContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Likewise, classes requiring to modify the collection of books are updated to
    the `IInventoryWriteContext` interface, as illustrated with `AddInventoryCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the detail of the `GetParameters` and `InternalCommand`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the `InternalCommand` method, where the book is added to the inventory
    with the given name of the book held in the `InventoryName` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the factory for the inventory commands.
  prefs: []
  type: TYPE_NORMAL
- en: InventoryCommandFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `InventoryCommandFactory` class is an implementation of the Factory pattern
    using .Net classes, which requires both readings of, and writing to, the collection
    of books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An interesting thing to note, is that the class actually did not require modifying
    from the previous chapter's version, as polymorphism handles the casting from
    `IInventoryContext` to the `IInventoryReadContext` and `IInventoryWriteContext`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes, we need to change the registration of the dependencies
    that are related to `InventoryContext`, in order to use an implementation factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For all three interfaces, the same instance of `InventoryContext` will be used,
    and this is instantiated once using the implementation factory extension. This
    is supplied when a `IInventoryReadContext`, `IInventoryWriteContext`, or `IInventoryContext`
    dependency is requested.
  prefs: []
  type: TYPE_NORMAL
- en: InventoryCommand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InventoryCommandFactory` was useful to illustrate how the Factory pattern
    could be achieved using .Net, but let''s revisit this now that we are using the
    .Net Core framework. Our requirement is given a string value; we want to return
    a particular implementation of `InventoryCommand`. This can be achieved in several
    ways, and, in this section, three examples will be given:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation factory using a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation factory using a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation factory of the `GetService()` method can be used to determine
    the type of `InventoryCommand` class to be returned. For this example, a new static
    method is created in the `InventoryCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a little tricky to read if you are not familiar with lambda expression
    bodies, so we will explain the code in a bit of detail. First of all, let''s revisit
    the syntax of the `AddSingleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the parameter of the `AddSingleton` extension is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the following code is equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetInventoryContext` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In our particular example, the specific `InventoryCommand` types have been
    marked as internal to the `FlixOne.InventoryManagement` project, so the `FlixOne.InventoryManagementClient`
    project is not able to access them directly. This is why a new static method was
    created in the `FlixOne.InventoryManagement.InventoryCommand` class that returned
    the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is, when the service is requested, a string will be supplied
    to determine the specific type. Because the dependency changed, this means the
    `CatalogService` constructor requires updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the service is requested, a string will be supplied to determine the specific.
    Because the dependency changed, the `CatalogueService` constructor requires updating:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when the string the user has entered is supplied to the `CommandFactory`
    dependency, the correct command is supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit tests associated with the command factory were also updated. As a
    comparison, a new `test` class was created from the existing `InventoryCommandFactoryTests` class,
    and named `InventoryCommandFunctionTests`. The initialization step is shown in
    the following code, with the changes highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual tests were also updated to supply the string as part of the
    get service call, as shown in the following code with `QuitCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The two tests verify that the services that are returned are of the `QuitCommand`
    type, when the service provider is given `"q"` or `"quit"`.
  prefs: []
  type: TYPE_NORMAL
- en: Using services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ServiceProvider` class provides a `Services` method that can be used to
    determine the appropriate service, when there are multiple dependencies registered
    for the same type. This example will take a different tack with `InventoryCommands`,
    and, because of the extent of the refactor, this will be done with new classes
    that will be created just to illustrate this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the unit test project, a new folder, `ImplementationFactoryTests`, was created,
    to contain the classes for this section. In the folder, a new base class for `InventoryCommand`
    was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept behind this new class is that child classes will define the strings
    that they respond to. For example, `QuitCommand` will respond to the `"q"` and
    `"quit"` strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the `GetInventoryCommand`, `AddInventoryCommand`, `UpdateQuantityCommand`,
    and `HelpCommand` classes, which follow a similar approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UnknownCommand` class, though, will be used as a default, so it will always
    evaluate to true, by overriding the `IsCommandFor` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `UnknownCommand` class is being treated as a default, the order
    of registration is important, and is shown below in the initialization of the
    unit `test` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, a new method has been created in order to return an instance
    of the `InventoryCommand` class when given a matching input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method will traverse the collection of dependencies that are registered
    for the `InventoryCommand` service, until a match is found by using the `IsCommandFor()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unit test then uses the `GetCommand()` method to determine the dependency,
    as shown below for `UpdateQuantityCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using third-party containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .Net Core framework provides great flexibility and functionality, but some
    features might not be supported, and a third-party container might be a more appropriate
    choice. Fortunately .Net Core is extensible and allows for the built-in service
    container to be replaced by a third-party container. To provide an example, we
    will use `Autofac` as our IoC container of the .Net Core DI.
  prefs: []
  type: TYPE_NORMAL
- en: '`Autofac` has a ton of great features, and is shown here as an example; but
    of course, there are other IoC containers that could have been used. For example,
    Castle Windsor and Unit are great alternatives that should also be considered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add the required `Autofac` package to the project. Using
    the package manager console, add the package using the following command (only
    required on the test project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This example will again support our `InventoryCommand` factory by using an `Autofac`
    feature of naming registered dependencies. These named dependencies will be used
    to retrieve the correct `InventoryCommand` instance, based on the supplied input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous example, the registration of dependencies will be done
    in the `TestInitialize` method. The registrations will be named based on the command
    that will be used to determine the command. The following shows the `Startup`
    method structure that creates the `ContainerBuilder` object which will build the
    `Container` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands are registered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous example, the container that is generated is an instance
    of `Autofac.IContainer`. This will be used to retrieve each registered dependency. `QuitCommand`,
    for example, will be named both `"q"` and `"quit"`, which indicates the two commands
    that can be used to execute the command. Also, note the last registered type is
    not named, and belongs to `UnknownCommand`. This will act as a default if no command
    is found by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine a dependency, a new method will be used to retrieve the dependency
    by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `Autofac.IContainer` interface has a `ResolveOptionalNamed<*T*>(*string*)`
    method name, which will return the dependency with the given name, or null, if
    no matching registrations are found. If the dependency is not registered with
    the given name, then an instance of the `UnknownCommand` class will be returned.
    This is done by using the null-coalescing operation, `??`, and the `IContainer.Resolve<*T*>`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '`Autofac.IContainer.ResolveNamed<*T*>(*string*)` will throw a `ComponentNotRegisteredException` exception
    if the dependency resolution fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A test method is written for each command in order to ensure that the commands
    are resolved correctly. Again, using `QuitCommand` as an example, we can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Please view the `InventoryCommandAutofacTests` class in the source for the other
    `InventoryCommand` examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of this chapter was to explore the .Net Core framework in more detail,
    and, in particular, the .Net Core DI. Three types of service lifetimes are supported:
    Transient, Scoped, and Singleton. A Transient service will create a new instance
    of a registered dependency for each request. A Scoped service will be generated
    once with a defined scope, while a Singleton service will be performed once for
    the lifetime of the DI service collection.'
  prefs: []
  type: TYPE_NORMAL
- en: As the .Net Core DI is central to confidently building .Net Core applications,
    it is important to understand its capabilities and its limitations. It is important
    to use the DI effectively, as well as to avoid duplicating functionality that
    is already supplied. Just as crucial, it is also wise to know the limits of the
    .Net Core DI framework, as well as the strengths of other DI frameworks, for situations
    where replacing the basic .Net Core DI framework with a third-party DI framework
    could be beneficial for an application.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will build upon the previous chapters and explore, common patterns
    in .Net Core ASP.Net web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure what type of service lifetime to use, which type is it best
    to register a class as? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In .Net Core ASP.Net solutions, is a Scope defined per web request, or per session?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does registering a class as a Singleton in the .Net Core DI framework make it
    thread-safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that the .Net Core DI framework can only be replaced with other Microsoft-supplied
    DI frameworks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

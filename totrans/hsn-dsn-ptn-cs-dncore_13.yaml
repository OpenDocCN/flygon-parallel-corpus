- en: Reactive Programming Patterns and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), we delved into functional programming and
    learned about **Func**, **Predicate**, **LINQ**, **Lambda**, **anonymous functions**,
    **expression trees**, and **recursion**. We also looked at the implementation
    of the strategy pattern using functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore the use of reactive programming and provides a hands-on
    demonstration of reactive programming using the C# language. We will delve into
    the principles and models of reactive programming and discuss the `IObservable`
    and `IObserver` providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inventory application will be expanded in two main ways: by reacting to
    changes and by discussing the **Model-View-ViewModel** (**MVVM**) pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The principles of reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive and IObservable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions—.NET Rx Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory application use case—getting inventory with a filter, paging, and
    sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and practices – MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts of reactive
    programming. The code is kept simple and is only for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running and executing the code will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the code examples, you will need to install Visual Studio (the preferred
    IDE). To do so, you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Visual Studio 2017 or the later version (2019) from the download link
    mentioned with the installation instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple options are available for Visual Studio installation. Here, we are
    using Visual Studio for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you will need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have SQL Server installed, you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For troubleshooting and for more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The principles of reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days, everyone is talking about **asynchronous programming**. Various
    applications are built on RESTful services that use asynchronous programming. The
    term *asynchronous* is relevant to reactive programming. Reactive is all about
    data streams, and reactive programming is a model structure that is built around
    asynchronous data streams. Reactive programming is also known as *the art of programming
    the propagation of changes*. Let's go back to our example from [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent
    Programming in .NET Core,* where we were discussing the ticket collection counters
    at a big conference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the three ticket-collection counters, we have one more counter
    named the calculation counter. This fourth counter concentrates on counting the
    collection, and it counts how many tickets are distributed from each of the three
    counters. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/747ea7b4-c8c3-4740-a44a-fb4986c84231.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the total of A+B+C is the sum of the remaining three
    columns; it is 1+1+1 = 3\. The **Total** column always shows the sum of rest of
    the three columns, and it will never show the actual person who is standing in
    the queue and waiting for their turn to collect the ticket. The value of the **Total**
    column depends upon the number of the remaining columns. If **Counter A** had
    two people in a queue, then the **Total** column would have the sum of 2+1+1 =
    4\. You can also refer to the **Total** column as a computed column. This column
    calculates the sum as soon as other rows/columns shift their counts (people waiting
    in the queue). If we were to write the **Total** column in C#, we would choose
    the computed property, and this would look as follows: `public int TotalColumn
    { get { return ColumnA + ColumnB + ColumnC; } }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, data flows from column to column. You can treat this
    as a data stream. You can create a stream for anything such as click events and
    hover events. Anything can be a stream variable: user inputs, properties, caches,
    data structures, and more. In the stream world, you can listen to the stream and
    react accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence of events is called a **stream**. A stream can emit three things:
    a value, an error, and a signal for completion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily work with a stream in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: One stream can be the input for another stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple streams can be the input for another stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams can be merged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data values can be mapped from one stream to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams can be filtered with the data/events that you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand streams more closely, see the following diagram that represents
    a stream (a sequence of events):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e147faca-305d-440c-87b6-0ba924c39f34.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a representation of a stream (sequence of events) where
    we have one to four events. Any of these events can be triggered or someone can
    click on any of them. These events can be represented by values and these values
    can be strings. The X sign shows that an error has occurred during the operation
    where streams are merged or their data is being mapped. Finally, the | sign shows
    that a stream (or an operation) is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Be reactive with reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, our computed property (discussed in the previous section) cannot
    be reactive or represent reactive programming. Reactive programming has specific
    designs and technologies. To experience the reactive programming or to be reactive, you
    can start with documents, available at [http://reactivex.io/](http://reactivex.io/)
    and experience it by going through the reactive manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))[.](https://www.reactivemanifesto.org/)
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, reactive properties are binding properties that react when
    an event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, when we deal with various large systems/applications, we find that
    they are too large to handle at once. These large systems are divided or composed
    into smaller systems. These smaller units/systems rely on reactive properties.
    To adhere to reactive programming, reactive systems apply design principles so
    that these properties can apply to all methods. With the help of this design/approach,
    we can make a composable system.
  prefs: []
  type: TYPE_NORMAL
- en: According to the manifesto, reactive programming and reactive systems are both different.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the basis of the reactive manifesto, we can conclude that reactive systems
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: Reactive systems are event-based design systems; these systems
    are quick to respond to any request in a short amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: Reactive systems are reactive in nature. These systems can react
    to changing the scalability rate by expanding or reducing the allocated resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: A resilient system is one that will not stop even if there is
    a failure/exception. Reactive systems are designed in such a way so that in any
    exception or failure, the system will never die; it remains working.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-based**: Any data item represents a message that can be sent to a
    specific destination. When a message or data item has arrived at a given state,
    an event emits a signal to notify the subscribers that a message has reached. Reactive
    systems rely on this message passing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a pictorial view of a reactive system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e361032-d61e-429f-a4f8-9745429379ec.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, a reactive system is composed of small systems that are resilient,
    scalable, responsive, and message-based.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive streams in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed the fact that reactive programming is a data stream.
    In the previous sections, we have also discussed how streams work and how these
    streams travel in a timely manner. We have seen an example of events and discussed
    the data streams in a reactive program. Now, let's go ahead with the same example
    and look at how two streams work with various operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we have two observable streams of an integer data type
    collection. Please note that we are using the pseudo code in this section to explain
    the behavior and the way in which these collections of data streams work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents two observable streams. The first stream,
    `Observer1`, contains numbers **1**, **2**, and **4**, whereas `Observer2`, which
    is a second stream, contains numbers **3** and **5**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35ab0fbd-3968-400c-9032-08126e65ac7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Merging two streams involves combining their sequence elements into a new stream.
    The following diagram shows a new stream that results when `Observer1` and `Observer2`
    are merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4aeb61d-ed6b-4fcf-9a24-8562bed48a92.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is only a representation of a stream and is not an actual
    representation of the sequence of elements in the stream. In this diagram, we
    have seen that elements (numbers) are in the sequence **1**, **2**, **3**, **4**,
    **5**, but this is not true in a realistic example. The sequence can vary; it
    could be **1**, **2**, **4**, **3**, **5**, or in any other order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering a stream is just like skipping elements/records. You can imagine
    a `Where` clause in LINQ, which looks something like this: `myCollection.Where(num
    => num <= 3);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a pictorial view of criteria, where we''re
    trying to pick only the elements that are meeting the specific criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a2965f1-b4a3-4034-82f1-7119a41fad65.png)'
  prefs: []
  type: TYPE_IMG
- en: We are filtering our stream and picking only those elements that are *<=3*.
    This means we are skipping elements **4** and **5**. In this case, we can say
    the filter is there to skip elements or to match the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand a map stream, you can imagine any mathematical operation where
    you would be counting sequences or incrementing numbers by adding some constant
    values. For example, if we have an integer value of *3* and our map stream is
    *+3*, that means we are counting a sequence as *3 + 3 = 6*. You can also correlate
    this with the LINQ and select and project the output like this: `return myCollection.Select(num
    => num+3);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents a map of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/031e8a71-9f81-475c-ac46-ae15cd06bc7c.png)'
  prefs: []
  type: TYPE_IMG
- en: After applying filters with the condition, *<= 3*, our stream has the elements **1**,
    **2**, and **3**. Additionally, we applied `Map (+3)` to the filtered stream with
    the elements **1**, **2**, and **3**, and, finally, our stream has the elements **4**,**5**,**6**
    (1+3, 2+3, 3+3).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world, these operations would occur sequentially or on demand.
    We have already done this operation of sequences so that we can apply the operations
    of merge, filter, and mapping in a sequential manner. The following diagram represents
    the flow of our imaginary example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3bfc2c2-2d3a-484f-a99f-8f8c3082316c.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have tried to represent our examples through diagrams, and we have gone
    through various operations where two streams talk to each other, and we got a
    new stream, and then we filtered and mapped the stream.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this better, refer to [https://rxmarbles.com/](https://rxmarbles.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a simple code to complete this example in the real world. First,
    we will study the code that implements the example, and then we will discuss the
    output of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet as an example of the `IObservable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static IObservable<T> From<T>(this T[] source) => source.ToObservable();`'
  prefs: []
  type: TYPE_NORMAL
- en: This code represents an extension method of a `T` type array. We created a generic
    method and named it `From`. This method returns an `Observable` sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visit the official documentation to know more about extension methods
    here: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we have the `TicketCounter` class. This class has two observers
    that are actually arrays of the integer data type. The following code shows two
    observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we apply the `From()` extension method to `Counter1` and `Counter2`.
    These counters actually represent our ticket counters and recall our example from
    [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent programming
    in .NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet represents `Counter1` and `Counter2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have two fields, `Counter1` and `Counter2`, and they are initialized
    from the constructor. When the `TicketCounter` class is being initialized, these
    fields get the values from the constructor of the class, as defined in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the complete code, go to and execute the code by hitting *F5* in
    Visual Studio. From here, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ca5c074-4bcc-4994-bb14-27c1f6df5946.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the console output and, in this console window, the user has been asked
    to enter a comma-separated number from `0` to `9`. Go ahead and enter a comma-separated
    number here. Please note that, here, we are trying to create a code that depicts
    our diagram of data stream representation, which was discussed earlier in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d898ad73-55f7-4510-8b2b-b860bce2c9cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As per the preceding diagram, we have entered two different comma-separated
    numbers. The first is `1,2,4` and the second is `3,5`. Now consider our `Merge`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Merge` method is merging two sequences of the data stream into `_observable`.
    The `Merge` operation is initiated with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the user is prompted to enter comma-separated numbers, and then
    the program stores these numbers into `counter1` and `counter2` by applying the `ToInts`
    method. The following is the code of our `ToInts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is an extension method for `string`. The target variable is of a `string`
    type that contains integers separated by `separator`. In this method, we are using
    the built-in `ConvertAll` method that is provided by .NET Core. This first splits
    the string and checks whether the split value is of an `integer` type. It then
    returns the `Array` of integers. This method produces the output, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/481c8752-3a12-4265-86d3-05dd0b57ceca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the output of our `merge` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b45912b4-2e62-4a21-8fad-4ea7d1524d85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output shows that we now have a final merged observer stream
    with the elements in sequence. Let''s apply a filter to this stream. The following
    code is our `Filter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the filter criteria for the number `<= 3`, which means we will pick
    only the elements whose values are either less than or equal to `3`. This method
    will initiate with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is executed, it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22aede10-aae2-4fee-9e9d-8d549af5ea7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we have a filtered stream with the elements in the sequence 1,3,2\.
    Now we need to map on this stream. We need a mapped element with `num + 3`, which
    means we need to output an integer number by adding `3` to this number. The following
    is our `Map` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method will be initialized with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution of the preceding method, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1f0aa3c-79ef-48d4-98e2-c178c079b892.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After applying the `Map` method, we have the stream of an element in the sequence
    of 4,6,5\. We have discussed how reactive works even with an imaginary example.
    We have created a small .NET Core console application to see the power of `Merge`,
    `Filter`, and `Map` operations on the observables. The following is the output
    of our console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ed54e75-5467-4282-ab32-9dbf41194cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous snapshot is telling the whole story of the execution of our sample
    application; `Counter1` and `Counter2` are data streams that contain the sequences
    of data 1,2,4 and 3,5\. We have the preceding output for `Merge` with the result
    `1,3,2,5,4 Filter (<=3)`, with the result 1,3,2 and `Map (+3)` with the data 4,6,5.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive and IObservable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed reactive programming and went through
    its model. In this section, we will discuss the Microsoft implementation of reactive
    programming. In response to reactive programming in .NET Core, we have various
    interfaces that provide a way to implement reactive programming in our application.
  prefs: []
  type: TYPE_NORMAL
- en: '`IObservable<T>` is a generic interface that is defined in the `System` namespace
    and declared as `public interface IObservable<out T>`. Here, `T` represents a
    generic type of parameter that provides notification information. In simple terms,
    this interface helps us to define a provider for notifications, and these notifications
    can be pushed for information. You can use the observer pattern while implementing
    the `IObservable<T>` interface in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern – implementation using IObservable<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple terms, a subscriber registers with a provider so that the subscriber
    may get notifications related to the message information. These notifications
    notify the provider that messages have been delivered to subscribers. This information
    may also be related to changes in operations or any other changes in the method
    or object itself. This is also known as **state changes**.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern specifies two terms: Observer and Observable. The observable
    is a provider also known as the **subject***.* The observer is registered with
    the `Observable`/`Subject`/`Provider` types, and the observer will be automatically
    notified by the provider whenever any changes occur due to the pre-defined criteria/condition,
    change or event, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a simple representation of the observer pattern, where
    the subject is notifying two different observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d2b83fd-d913-4456-bf7a-b587b7e12da5.png)'
  prefs: []
  type: TYPE_IMG
- en: Go back to the `FlixOne` inventory web application from [Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*, initiate your Visual Studio, and open the `FlixOne.sln` solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Solution Explorer. From here, you will see that our project will look
    similar to the following snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c18ba34-8fb5-4905-b012-8d55995ca8fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expand the Common folder under Solution Explorer and add two files: `ProductRecorder.cs`
    and `ProductReporter.cs`. These files are the implementation of the `IObservable<T>`
    and `IObserver<T>` interfaces. We also need to add a new ViewModel so that we
    can report actual messages to the users. To do so, expand the `Models` folder
    and add the `MessageViewModel.cs` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is showing our `MessageViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`MessageViewModel` contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MsgId`: A unique identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsSuccess`: Shows whether the operation has failed or succeeded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message`: A success message or an error message that depends upon the value
    of `IsSuccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToString()`: An override method that returns a string after concatenating
    all the information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now discuss our two classes; the following code is from the `ProductRecorder`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our `ProductRecorder` class implements the `IObservable<Product>` interface.
    If you recall our discussion regarding the observer pattern, you will come to
    know that this class is actually a provider, a subject, or an observable. The `IObservable<T>`
    interface has a `Subscribe` method that we need to use to subscribe our subscribers
    or observers (we will discuss the observer later in this section).
  prefs: []
  type: TYPE_NORMAL
- en: 'There should be a criteria or a condition so that the subscriber can get notifications.
    In our case, we have a `Record` method that serves this purpose. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is a `Record` method. We created this method to showcase the power
    of the pattern. This method is simply checking for the valid discount rates. If
    `discount rate` is not valid, as per the criteria/condition, this method would
    raise an exception and share the product name with an invalid `discount rate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous method validates the discount rate as per the criteria and sends
    a notification about the raised exception to the subscriber upon failure of the
    criteria. Take a look at the iteration block (the `foreach` loop) and imagine
    a situation where we do not have anything to iterate and all the subscribers have
    been notified. Can we imagine what will happen in this case? The same kind of
    situation may arise for `infinite` loop. To stop this, we need something that
    terminates the loop. For this, we have the following `EndRecording` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `EndRecoding` method is looping through the collection of `_observers` and
    triggering the `OnCompleted()` method explicitly. Finally, it cleared the `_observers` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the `ProductReporter` class. This class is an example of
    the implementation of the `IObserver<T>` interface. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `IObserver<T>` interface has the `OnComplete`, `OnError`, and `OnNext` methods
    that we have to implement in the `ProductReporter` class. The purpose of the `OnComplete`
    method is to notify the subscriber that the job has been done and then flush out
    the code. Furthermore, `OnError` is invoked when an error occurs during execution,
    while `OnNext` provides information of the next element in the sequence of a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, `PrepReportData` is a value addition that gives the
    user a formatted report about all the operations of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method is simply making additions to our `Reporter` collection,
    which is a collection of `MessageViewModel` classes. Note that, for simplicity
    purposes, you can also use the `ToString()` method that we have implemented in
    our `MessageViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the `Subcribe` and `Unsubscribe` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous two methods tell the system that there is a provider. Subscribers
    could subscribe to the provider or unsubscribe/dispose of it upon completion of
    the operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to showcase our implementation and see some good results. To do
    so, we need to make some changes to our existing `Product Listing` page and add
    a new View page to our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following link to our `Index.cshtml` page so that we can see the new
    link to view Audit Report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we added a new link to show the Audit Report
    based on our implementation of the `Report Action` method, which we have defined
    in our `ProductConstroller` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this code, our Product Listing page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ef8a83f-a7a4-4df1-85cc-96b6ed21a54c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s discuss the `Report action` method. For this, consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are only taking the first three products for demonstration
    purposes. Please note that you can modify the code as per your own implementation.
    In the code, we have created a `productProvider` class and three observers to
    subscribe to our `productProvider` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a pictorial view of all the activities to showcase
    the `IObservable<T>` and `IObserver<T>` interfaces that we have discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/846c2b3f-d4ee-49c8-b5d5-106160ff4a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code is used to subscribe to `productrovider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to log the report and then unsubscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s come back to our screen and add the `Report.cshtml` file to Views |
    Product. The following code is part of our Report page. You can find the complete
    code in the `Product` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a header for the columns of our table that shows the audit
    report.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will complete the table and add values to the `IsSuccess`
    and `Message` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are done with our implementation of the observer pattern
    using `IObservable<T>` and `IObserver<T>` interfaces. Run the project by pressing
    *F5* in Visual Studio, click on Product in the home page, and then click on the Audit
    Report link. From here, you will see that the audit report of our selected products,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/078bcd2a-09a4-484c-8d76-95933be89587.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a simple listing page that shows the data from
    a `MessageViewModel` class. You can make the changes and modify them as per your
    requirement. In general, audit reports are coming from a lot of operational activities
    that we are seeing in the preceding screen. You could also save the audited data
    in the database and then serve this data accordingly for different purposes such
    as for reporting to admin and more.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive extensions – .NET Rx extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The discussion in the previous session was aimed at reactive programming and
    the implementation of reactive programming using the `IObservable<T>` and `IObserver<T>`
    interfaces as an observer pattern. In this section, we will extend our learning
    with the help of **Rx Extensions**. If you would like to find out more about the
    development of Rx Extensions, you should follow the official repository at [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive).
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that Rx Extensions are now merged with the `System` namespace,
    and you can find everything in the `System.Reactive` namespace. If you have experience
    with Rx Extensions, you should know that the namespace of these extensions has
    been changed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Rx.Main` has been changed to `System.Reactive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rx.Core` has been changed to `System.Reactive.Core`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rx.Interfaces` has been changed to `System.Reactive.Interfaces`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rx.Linq` has been changed to `System.Reactive.Linq`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rx.PlatformServices` has been changed to `System.Reactive.PlatformServices`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rx.Testing` has been changed to `Microsoft.Reactive.Testing`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To initiate Visual Studio, open the `SimplyReactive` project (discussed in
    the previous section) and open the NuGet Package Manager. Click on Browse and
    enter the search term `System.Reactive`. From here, you will see the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1de57f4-7e26-4caa-9028-33a6d4e13cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: The aim of this section is to make you aware of reactive extensions but not
    delve into its internal development. These extensions are under the Apache2.0
    license and maintained by .NET Foundation. We have already implemented reactive
    extensions in our `SimplyReactive` application.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory application use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will continue with our FlixOne inventory application. Throughout
    this section, we will discuss the web application pattern and extend our web application
    developed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter continues looking at web applications that were discussed in the
    previous chapter. If you skipped the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), please revisit it to get up to speed with
    the current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through the process of requirement gathering and
    then discuss the various challenges of development and business with our web application
    that we developed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications - Part 2*, we added features to our FlixOne inventory
    web application. We extended the application after considering the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The business needs a rich UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New opportunities demand a responsive web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After several meetings and discussions with management, **Business Analyst**
    (**BA**), and presales folks, the management of the organization decided to work
    upon the following high-level requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our business team listed the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item filtering**: Currently, users are unable to filter items by category.
    To extend the list-view feature, the user should be able to filter the product
    item based on its respective category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism where a user can sort items
    based on the item''s name, price, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FlixOne inventory management web application is an imaginary product. We
    are creating this application to discuss the various design patterns required/used
    in the web project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting inventory with a filter, paging, and sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per our business requirements, we need to apply a filter, paging, and sorting
    to our FlixOne inventory application. First, let''s start implementing the sorting.
    To do so, I''ve created a project and put this project in the `FlixOneWebExtended`
    folder. Start Visual Studio and open the FlixOne solution. We will apply to sort
    to our product listing sheet for these columns: `Category`, `productName`, `Description`,
    and `Price`. Please note that we will not be using any external component for
    sorting, but we will create our own login.'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Solution Explorer, and open `ProductController`, which is available
    in the `Controllers` folder. Add the `[FromQuery]Sort sort` parameter to the `Index`
    method. Please note that the `[FromQuery]` attribute indicates that this parameter
    is a query parameter. We will use this parameter to maintain our sorting order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `Sort` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sort` class contains three public properties as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Order`: Indicates the sorting order. The `SortOrder` is an enum defined as
    `public enum SortOrder { D, A, N }`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColName`: Indicates the column name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColType`: Indicates the type of a column; `ColumnType` is an enum defined
    as `public enum ColumnType { Text, Date, Number }`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `IInventoryRepositry` interface, and add the `IEnumerable<Product>
    GetProducts(Sort sort)` method. This method is responsible for sorting the results.
    Please note that we are going to use LINQ queries to apply sorting. Implement
    this `InventoryRepository` class method and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is handling the case when `sort.ColName` is `productname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is handling the case when `sort.ColName` is `productprice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we set the value of the `sort` parameter as blank if it
    contains a null value, and then we process it by using `switch..case` in `sort.ColName.ToLower()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our `ListProducts()` method that gives us the result of the `IIncludeIQuerable<Product,Category>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply gives us `Products` by including `Categories` for
    each product. The sorting order will come from our user, so we need to modify
    our `Index.cshtml` page. We also need to add an anchor tag to the header columns
    of the table. For this, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code show the header columns of the table; `new Sort { ColName
    = "ProductName", ColType = ColumnType.Text, Order = SortOrder.A }` is the main
    way we are implementing `SorOrder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and you will see the following snapshot of the Product
    Listing page with the sorting feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72b4b9f-358a-41d8-9ff6-6f5c30f075af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open the `Index.cshtml` page, and add the following code to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are adding a textbox under `Form`. Here, the user
    inputs the data/value, and this data submits to the server as soon as the user
    clicks the submit button. At the server side, the filtered data will returned
    back and show the product listing. After the implementation of the preceding code,
    our Product Listing page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcf4ab01-e7d0-46b5-be17-6a942f083335.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the `Index` method in `ProductController` and change the parameters.
    Now the `Index` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we need to update the method parameters of `GetProducts()` in `InventoryRepository`
    and `InventoryRepository`. The following is the code for the `InventoryRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the project by pressing *F5* from Visual Studio and navigating to the
    filter/search option in Product Listing. For this, see this snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/802ed721-1eb2-4afc-8b51-3be146702b5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After entering your search term, click on the Search button, and this will
    give you the results, as shown in the following snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6f32b34-7662-4b1d-be5f-6d5a7c0c1bec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding Product Listing screenshot, we are filtering our Product records
    with `searchTerm` `mango`, and it produces single results, as shown in the previous
    snapshot. There is one issue in this approach for searching data: add `fruit`
    as a search term, and see what will happen. It will produce zero results. This
    is demonstrated in the following snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06ac51ab-3dfb-47e7-9e2a-8aeea1d0f932.png)'
  prefs: []
  type: TYPE_IMG
- en: We do not get any result, which means our search is not working when we are
    putting `searchTerm` in lowercase. This means our search is case-sensitive. We
    need to change our code to get it started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ignoring the case to make our search case-insensitive. We used `StringComparison.InvariantCultureIgnoreCase`
    and ignored the case. Now our search will work with either capital or lowercase
    letters. The following is the snapshot that produces results using lowercase `fruit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80ddb52c-00e6-4041-b490-377f78e502a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a previous discussion during the FlixOne app extension, we applied `Sort`
    and `Filter`; now we need to add `paging`. To do so, we have added a new class
    named, `PagedList` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the parameters of the `Index` method of `ProductController` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `Index.cshtml` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code makes it possible to move our screen to the next or the
    previous page. Our final screen will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2e1909c-873b-4285-b592-2c69ed0d6667.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have discussed and extended the features of our FlixOne
    application by implementing `Sorting`, `Paging`, and `Filter`. The aim of this
    section was to give you hands-on experience with a working application. We have
    coded our application in such a way that it will directly meet real-world applications.
    With the preceding enhancement, our application is now capable of giving a product
    listing that can be sorted, paginated, and filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and Practices – MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](8e089021-1efb-4b88-8bf2-e26f69f883b9.xhtml), *Implementing Design
    Patterns for Web Applications - Part 1*, we discussed the **MVC** pattern and
    created an application based on this.
  prefs: []
  type: TYPE_NORMAL
- en: Ken Cooper and Ted Peters are the names behind the invention of the MVVM pattern.
    At the time of this invention, both Ken and Ted were architects at the Microsoft
    Corporation. They made this pattern to simplify the UI of event-driven programming.
    Later on, it was implemented in **Windows Presentation Foundation** (**WPF**)
    and **Silverlight**.
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM pattern was announced in 2005 by John Gossman. John has blogged about
    this pattern in context with building WPF applications. The link for this is at [https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/).
  prefs: []
  type: TYPE_NORMAL
- en: MVVM is considered to be one of the variations of MVC to meet the modern **User
    Interface** (**UI**) development approach, where UI development is the core responsibility
    of designer/UI-developers rather than application developers. In this approach
    of development, a designer who is a graphical enthusiast and is focused on making
    a UI more attractive may or may not bother about the development part of the application.
    Generally, designers (UI persons) use various tools to make the UI more attractive.
    The UI can be made with a simple HTML, CSS, and so on, using rich controls of
    WPF or Silverlight.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Silverlight** is a framework that helps to develop applications
    with a rich UI. Many developers refer to it as an alternative of Flash by Adobe.
    In July 2015, Microsoft announced that it was no longer supporting Silverlight.
    Microsoft announced the support of WPF in .NET Core 3.0 during its build ([https://developer.microsoft.com/en-us/events/build](https://developer.microsoft.com/en-us/events/build)).
    There is also a blog with more insight into the plan to support WPF found here:
    [https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/](https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVVM pattern can be elaborated with its various components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: Holds data and does not care about any business logic in the application.
    I prefer to refer to this as a domain object because it holds the actual data
    of the application we are working with. In other words, we can say that a model
    is not responsible for making the data beautiful. For example, in a product model
    of our FlixOne application, a product model holds the value of various properties,
    and these describe a product by its name, description, category name, price, and
    more. These properties contain the actual data of the product, but the model is
    not responsible for making behavioral changes to any of the data. For example,
    it''s not the responsibility of our product mode to format the product description
    to look perfect on the UI. On the other hand, many of our models contain validations
    and other computed properties. The main challenge is to maintain the pure and
    cleaned model, which means that the model should resemble the real-world model.
    In our case, our `product` model is called a **clean model**. A clean model is
    one that resembles the actual properties of real products. For example, if the `Product`
    model is storing the data of fruits, then it should show properties such as the
    color of fruits and so on. The following code is from a model of our imaginary
    application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code is written in Angular. We will discuss Angular
    code in detail in the upcoming section, *Implementing MVVM*.
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: This is a data representation for the end user to access via the
    UI. This simply displays the value of the data, and this value may or may not
    be formatted. For example, we can show the discount rate as 18% on the UI, while
    it would be stored as 18.00 in the model. The view can also responsible for behavioral
    changes. The view accepts user inputs; for example, there would be a view that
    provides a form/screen to add a new product. Also, the view can manage the user
    input such as the key pressed, detecting a keyword, and more. It could also be
    an active view or a passive view. The view that accepts the user input and manipulates
    the data model (properties) according to the user input is an active view. A passive
    view is one that does nothing. In other words, a view that is not associated with
    the model is a passive view, and this kind of view is manipulated by a controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**: This works as a middleman between View and Model. Its responsibility
    is to make the presentation better. In our previous example, where View shows
    the discount rate as 18% but Model has a discount rate of 18.00, it is the responsibility
    of View Model to format 18.00 to 18% so that View can display the formatted discount
    rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we combine all the points discussed, we can visualize the entire MVVM pattern,
    which would look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61f3a6af-ade5-4d96-88d1-4d959db0bc1c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is a pictorial view of MVVM, and it shows us that **View
    Model** separates **View** and **Model**. **ViewModel** also maintains the `state`
    and `perform` operations. This helps **View** to present the final output to the
    end user. The view is UI, which gets data and presents it to the end user. In
    the next section, we will implement the MVVM pattern using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we understood what the MVVM pattern is and how it works.
    In this section, we will use our FlixOne application and build an application
    using Angular. To demonstrate the MVVM pattern, we will use the API built on ASP.NET
    Core 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Visual Studio and open FlixOne Solution from the `FlixOneMVVM` folder.
    Run the `FlixOne.API` project where you will see the following Swagger documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cc95489-4408-41f9-81a0-393b2ae85317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot is the snapshot of our Product APIs documentation,
    where we have incorporated Swagger for the API documentation. If you want to,
    you can test the API from this screen. If the APIs are returning results, then
    your project is successfully set up. If not, please check the prerequisites for
    this project, and also check the `README.md` file from the Git repository for
    this chapter. We have everything that is required to build a new UI; as discussed
    previously, we will create an Angular application that will consume our Product
    APIs. To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on FlixOne Solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add New Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Add New Project window, select ASP.NET Core Web Application. Call
    it FlixOne.Web and click OK. After doing so, refer to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e9f81475-6de0-46c7-bfe0-fb72a917416f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the next window, select Angular, make sure you have selected ASP.NET Core
    2.2, click OK, and refer to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/798ace74-dc36-45d9-aebd-c958464837c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open Solution Explorer and you will find the new `FlixOne.Web` project and
    folder hierarchy, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/afcc2e76-f48c-4abf-910f-9e7382731283.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Solution Explorer, right-click on the FlixOne.Web project, and click
    on the Set as Startup project, and then refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a4bac5f7-1e4f-447a-bd53-ee09dcf3a150.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the `FlixOne.Web` project and see the output, which will look like the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4643910-9a24-4f31-9102-f27f812cacf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have set up our Angular app successfully. Go back to your Visual Studio
    and open the Output window. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f215bcf-3786-4f4d-95aa-1737550c1192.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will find `ng serve "--port" "60672"` from the Output window; this is a
    command that tells the Angular app to listen and serve. Open the `package.json`
    file from `Solution Explorer`; this file belongs to the `ClientApp` folder. You
    will notice `"@angular/core": "6.1.10"`, which means our application is built
    on `angular6`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code of our `product.component.html` (this is a view):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application from Visual Studio, and click on Product, where you will
    get a Product Listing screen similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2388694-3340-4811-bf69-d26781422dfa.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have created a small demo application in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this chapter was to get you through the reactive programming by discussing
    its principles and the reactive programming model. Reactive is all about the data
    stream, which we have discussed with examples. We extended our example from [Chapter
    8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent Programming in .NET
    Core*, where we discussed the use case of the ticket collection counter at a conference.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the reactive system during our discussion of the reactive manifesto.
    We discussed the reactive system through the help of showcasing the `merge`, `filter`,
    and `map` operations, and how streams work with the help of examples. Also, we
    discussed the `IObservable` interface and the Rx extensions, using examples.
  prefs: []
  type: TYPE_NORMAL
- en: We carried forward our `FlixOne` inventory application and discussed the use
    cases to implement the paging and the sorting of inventory data for products.
    Finally, we discussed the MVVM pattern and created a small application on a MVVM
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter ([Chapter 11](1dd82c08-3988-4c19-aa44-4bc2fd3277a9.xhtml),
    *Advanced Database Design and Application Techniques*), advanced database and
    application techniques will be explored, including applying **Command Query Responsibility
    Segregation** (**CQRS**) and a ledger-style database.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are reactive properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a reactive system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by merging two reactive streams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the MVVM pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, refer to the following
    book. This book will provide you with various in-depth and hands-on exercises
    for reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive Programming for .NET Developer*s, *Antonio Esposito* and *Michael
    Ciceri*, Packt Publishing: [https://www.packtpub.com/web-development/reactive-programming-net-developers](https://www.packtpub.com/web-development/reactive-programming-net-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

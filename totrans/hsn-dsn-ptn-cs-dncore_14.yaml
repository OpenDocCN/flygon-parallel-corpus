- en: Advanced Database Design and Application Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据库设计和应用技术
- en: In the previous chapter, we learned about reactive programming by discussing
    its principles and models. We also discussed and looked at examples of how reactive
    programming is all about data streams.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过讨论其原则和模型来了解了响应式编程。我们还讨论并查看了响应式编程如何处理数据流的示例。
- en: Database designing is a complex task and needs a lot of patience. In this chapter,
    we will discuss advanced database and application techniques, including applying
    **Command Query Responsibility Segregation** (**CQRS**) and ledger-style databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计是一项复杂的任务，需要很多耐心。在本章中，我们将讨论高级数据库和应用技术，包括应用CQRS和分类账式数据库。
- en: Similar to previous chapters, a requirement gathering session will be illustrated
    in order to determine the **Minimum Viable Product** (**MVP**). In this chapter,
    several factors will be used to lead the design to CQRS. We will be using a ledger-style
    approach that consists of increased tracking of changes to inventory levels, as
    well as wanting to provide public APIs for retrieving inventory levels. This chapter
    will cover why developers use ledger-style databases and why we should focus on
    CQRS implementation. In this chapter, we will see why we adapt the CQRS pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的章节类似，将进行需求收集会话，以确定最小可行产品（MVP）。在本章中，将使用几个因素来引导设计到CQRS。我们将使用分类账式方法，其中包括增加对库存水平变化的跟踪，以及希望提供用于检索库存水平的公共API。本章将介绍开发人员为什么使用分类账式数据库以及为什么我们应该专注于CQRS实现。在本章中，我们将看到为什么我们要采用CQRS模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Use case discussion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例讨论
- en: Database discussion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库讨论
- en: Ledger-style databases for inventory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存的分类账式数据库
- en: Implementing the CQRS pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施CQRS模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demo purposes. Most of the examples involve a .NET
    Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: To run and execute the code, Visual Studio 2019 is a prerequisite (you can also
    use Visual Studio 2017 to run the application).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，Visual Studio 2019是必需的（您也可以使用Visual Studio 2017来运行应用程序）。
- en: Installing Visual Studio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio (preferred IDE).
    To do so, follow these instructions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio（首选IDE）。要做到这一点，请按照以下说明进行操作：
- en: Download Visual Studio 2017 (or version 2019) from the following download link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下下载链接下载Visual Studio 2017（或2019版本）：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions that are accessible through the previous
    link. Multiple options are available for Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上述链接可访问的安装说明。可用多种选项进行Visual Studio安装。在这里，我们使用Visual Studio for Windows。
- en: Setting up .NET Core
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，则需要按照以下说明进行操作：
- en: Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载.NET Core for Windows：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装SQL Server，则需要按照以下说明进行操作：
- en: Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: You can find the installation instructions at [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)找到安装说明。
- en: For troubleshooting and for more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Use case discussion
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例讨论
- en: In this chapter, we will continue with our FlixOne inventory application. Throughout
    this chapter, we will discuss CQRS patterns and extend the web application that
    we developed in the previous chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用我们的FlixOne库存应用程序。在本章中，我们将讨论CQRS模式，并扩展我们在以前章节中开发的Web应用程序。
- en: This chapter continues with the web application that was developed in the previous
    chapter. If you skipped the previous chapter, please revisit it in order to aid
    your understanding of the current chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续讨论上一章中开发的Web应用程序。如果您跳过了上一章，请重新阅读以帮助您理解当前章节。
- en: In this section, we will go through the process of requirement gathering, and
    then discuss the various challenges with our web application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过需求收集过程，然后讨论我们的Web应用程序的各种挑战。
- en: Project kickoff
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目启动
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications – Part 2*, we extended FlixOne Inventory and added
    authentication and authorization to the web application. We extended the application
    after considering the following points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)中，*为Web应用程序实现设计模式-第2部分*，我们扩展了FlixOne库存，并为Web应用程序添加了身份验证和授权。我们在考虑以下几点后扩展了应用程序：
- en: The current application is open for all; therefore, any user can visit any page,
    even restricted pages.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序对所有用户开放；因此，任何用户都可以访问任何页面，甚至是受限制的页面。
- en: Users should not access pages that require access or special access rights;
    these pages are also known as restricted pages or pages with limited access.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不应该访问需要访问或特殊访问权限的页面；这些页面也被称为受限制的页面或有限访问权限的页面。
- en: Users should be able to access pages/resources as per their roles.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够根据其角色访问页面/资源。
- en: 'In [Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml), *Reactive Programming
    Patterns and Techniques*, we further extended our FlixOne Inventory application
    and added paging, filtering, and sorting to all pages that show listings. The
    following points were considered while we extended the app:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml)中，*响应式编程模式和技术*，我们进一步扩展了我们的FlixOne库存应用程序，并为显示列表的所有页面添加了分页、过滤和排序。在扩展应用程序时考虑了以下几点：
- en: '**Item filtering**: Currently, users are unable to filter items by their categories.
    To extend this feature, users should be able to filter product items based on
    their categories.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目过滤**：目前，用户无法按照它们的类别对项目进行过滤。为了扩展此功能，用户应能够根据类别对产品项目进行过滤。'
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism that enables the user to
    sort items based on categories such as item name or price.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目排序**：目前，项目按照它们被添加到数据库的顺序出现。没有任何机制可以使用户根据类别（如项目名称或价格）对项目进行排序。'
- en: Requirements
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: 'After several meetings and discussions with management, **Business Analyst**
    (**BA**), and pre-sales staff, management decided to work on the following high-level
    requirements: business requirements and technical requirements.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多次会议和与管理层、**业务分析师**（**BA**）和售前人员的讨论后，管理层决定着手处理以下高层要求：业务需求和技术需求。
- en: Business requirements
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务需求
- en: 'On the basis of discussions with stakeholders and endusers, and as per the
    market survey, our business team has listed the following requirements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据与利益相关者和最终用户的讨论，以及市场调查的结果，我们的业务团队列出了以下要求：
- en: '**Product expansion**: The product is reaching different users. This is a good
    time to expand the application. The application will robust to expand after having
    expanded it.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品扩展**：产品正在接触到不同的用户。现在是扩展应用程序的好时机。扩展后的应用程序将更加强大。'
- en: '**Product model**: Being an inventory management application, users should
    feel freedom (this mean no restriction at model level, without complicated validations)
    and there should not be any restriction while users are interacting with the application.
    Every screen and page should be self-explanatory.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品模型**：作为库存管理应用程序，用户应该感到自由（这意味着在模型级别没有限制，没有复杂的验证），并且在用户与应用程序交互时不应有任何限制。每个屏幕和页面都应该是自解释的。'
- en: '**Database design**: The application''s database should be designed in such
    a way that the expansion should not take much time.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库设计**：应用程序的数据库应设计成扩展不需要花费太多时间的方式。'
- en: Technical requirements
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The actual requirements that meet business needs are now ready for development.
    After several discussions with business staff, we concluded that the following
    are the requirements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 满足业务需求的实际要求现已准备好进行开发。经过与业务人员的多次讨论后，我们得出以下要求：
- en: 'The following are the requirements for the** landing** or **home page**:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是**首页**或**主页**的要求：
- en: Should be a dashboard that contains various widgets
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有包含各种小部件的仪表板
- en: Should show an at-a-glance picture of the store
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该显示商店的一览图片
- en: 'The following are the requirements for the** product page**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是**产品页面**的要求：
- en: Should have the capability to add, update, and delete products
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应具有添加、更新和删除产品的功能
- en: Should have the capability to add, update, and delete product categories
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应具有添加、更新和删除产品类别的功能
- en: The FlixOne Inventory Management web application is an imaginary product. We
    are creating this application to discuss the various design patterns that are
    required/used in web projects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne库存管理Web应用程序是一个虚构的产品。我们正在创建此应用程序来讨论Web项目中所需/使用的各种设计模式。
- en: Challenges
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Although we have extended our existing web application, it has various challenges
    for both developers and businesses. In this section, we will discuss these challenges
    and then we will find out the solutions to overcome these challenges.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们扩展了现有的Web应用程序，但对开发者和企业都存在各种挑战。在本节中，我们将讨论这些挑战，然后找出克服这些挑战的解决方案。
- en: Challenges for developers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者面临的挑战
- en: 'The following are the challenges that arose due to a big change in the application.
    They were also a result of the major extensions associated with upgrading a console
    application to a web application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由应用程序的重大变化引起的挑战。这也是将控制台应用程序升级为Web应用程序的主要扩展的结果：
- en: '**No support for RESTful services**: Currently, there is no support for RESTful
    services because no APIs have been developed.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持RESTful服务**：目前，没有支持RESTful服务，因为没有开发API。'
- en: '**Limited security**: In the current application, there is only one mechanism
    that can restrict/permit the user from/to gaining access to a particular screen
    or module of the application: that is, by the login.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的安全性**：在当前应用程序中，只有一种机制可以限制/允许用户访问特定屏幕或应用程序模块：即登录。'
- en: Challenges for businesses
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业面临的挑战
- en: 'The following challenges occur as we adapt a new technology stack, and there
    are plenty of changes in the code. Therefore, it takes time to achieve the final
    output, which delays the product, resulting in a loss for the business:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们采用新技术栈时，会出现以下挑战，并且代码会发生许多变化。因此，要实现最终输出需要时间，这延迟了产品，导致业务损失：
- en: '**Loss of clientele**: Here, we are still in the development stage but the
    demand for our business is very high. However, the development team is taking
    longer than expected to deliver the product.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户流失：在这里，我们仍处于开发阶段，但对我们业务的需求非常高。然而，开发团队花费的时间比预期的要长，以交付产品。
- en: '**It takes more time to roll out the production updates**: Development efforts
    are time-consuming at the moment and this delays the subsequent activities, leading
    to a delay in production.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布生产更新需要更多时间：目前开发工作非常耗时，这延迟了后续活动，导致生产延迟。
- en: Providing a solution to the problems/challenges
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供解决问题/挑战的解决方案
- en: After several meetings and brainstorming sittings, the development team came
    to the conclusion that we have to stabilize our web-based solution. To overcome
    these challenges and provide the solution, the tech team and business team got
    together to identify the various solutions and points.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次会议和头脑风暴，开发团队得出结论，我们必须稳定我们的基于Web的解决方案。为了克服这些挑战并提供解决方案，技术团队和业务团队汇聚在一起，确定了各种解决方案和要点。
- en: 'The following are the points supported by the solution:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解决方案支持的要点：
- en: Evolve RESTful webservices—there should be one API dashboard
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展RESTful web服务——应该有一个API仪表板
- en: Strictly following **T****est-Driven Development** (**TDD**)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格遵循测试驱动开发（TDD）
- en: Re-designing the **user interface** (**UI**) to meet the user experience expectations
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设计用户界面（UI）以满足用户体验期望
- en: Database discussion
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库讨论
- en: 'Before we start with the database discussion we have to consider the following
    points—a big picture of our FlixOne web application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始数据库讨论之前，我们必须考虑以下几点——FlixOne网站应用程序的整体情况：
- en: One part of our application is inventory management, but another part of it
    is an e-commerce web application.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序的一部分是库存管理，但另一部分是电子商务网站应用程序。
- en: The challenging part is that our application would also serve as a **Point Of
    Sale** (**POS**). In this part/module, the user can pay for the items they have
    purchased from offline counters/outlets.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有挑战性的部分是我们的应用程序还将作为销售点（POS）提供服务。在这个部分/模块中，用户可以支付他们从离线柜台/门店购买的物品。
- en: For the inventory part, we need to address which approach we will be taking
    to calculate and maintain accounts and transactions, and to determine the cost
    of any item sold.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于库存部分，我们需要解决我们将采取哪种方法来计算和维护账户和交易，并确定出售任何物品的成本。
- en: To maintain stock for inventories, various options are available, with the two
    most commonly used options being **First In First Out** (**FIFO**) and **Last
    In First Out** (**LIFO**).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了维护库存，有各种选项可用，其中最常用的两个选项是先进先出（FIFO）和后进先出（LIFO）。
- en: 'Most of the transactions involve financial data, hence these transactions require
    historical data. Every record should have the following information: current value,
    the value before current changes, and the changes made.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分交易涉及财务数据，因此这些交易需要历史数据。每条记录应包含以下信息：当前值，当前更改之前的值，以及所做的更改。
- en: While we're maintaining inventory, we are also required to maintain the items
    purchased.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在维护库存的同时，我们还需要维护购买的物品。
- en: There are more points that are important when designing a database for any e-commerce
    web application. We are limiting our scope for the FlixOne application in order
    to showcase the inventory and stock management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何电子商务网站应用程序设计数据库时，还有更多重要的要点。我们将限制我们的范围，以展示FlixOne应用程序的库存和库存管理。
- en: Database processing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库处理
- en: Similar to the other topics we have covered in this book, there are a large
    number of databases ranging from basic patterns concerning the schema of a database
    to patterns that govern how database systems are put together. This section will
    cover two system patterns, **Online Transaction Processing** (**OLTP**) and **Online
    Analytical Processing** (**OLAP**). To further understand database design patterns,
    we will explore a specific pattern, ledger-style databases, in more detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中涵盖的其他主题类似，有许多数据库，涵盖了从数据库模式的基本模式到管理数据库系统如何组合的模式。本节将涵盖两种系统模式，即在线事务处理（OLTP）和在线分析处理（OLAP）。为了进一步了解数据库设计模式，我们将更详细地探讨一种特定模式，即分类账式数据库。
- en: A database schema is another word for the collection of tables, views, stored
    procedures, and other components that make up a database. Think of this as the *blueprint*
    of the database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式是数据库中表、视图、存储过程和其他组件的集合的另一个词。可以将其视为数据库的蓝图。
- en: OLTP
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OLTP
- en: An OLTP database has been designed to handle large numbers of statements that
    cause changes to the database. Basically, the `INSERT`, `UPDATE`, and `DELETE`
    statements all cause changes and behave very differently from the `SELECT` statement.
    OLTP databases have been designed with this in mind. Because these databases record
    changes, they are typically the *main *or *master*database, meaning that they
    are the repositories that hold the current data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 已设计OLTP数据库以处理导致数据库更改的大量语句。基本上，INSERT、UPDATE和DELETE语句都会导致更改，并且与SELECT语句的行为非常不同。OLTP数据库已经考虑到了这一点。因为这些数据库记录更改，它们通常是主数据库或主数据库，这意味着它们是保存当前数据的存储库。
- en: The `MERGE` statement also qualifies as a statement that causes change. This
    is because it provides a convenient syntax for the insertion of a record when
    a row does not exist, and the insertion of an update when a row does exist. It
    will update when a row does exist. The `MERGE` statement is not supported in all
    database providers or versions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: OLTP databases are typically designed to process change statements quickly.
    This is normally done by the careful planning of table structures. A simple way
    of viewing this is to consider a database table. This table can have fields for
    storing data, keys for looking up the data efficiently, indexes to other tables,
    triggers to respond to specific situations, and other table constructs. Each one
    of these constructs has a performance penalty. The design of OLTP databases is,
    therefore, a balance between using the minimum number of constructs on a table
    versus the desired behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a table that records the books in our inventory system. Each
    book might record the name, quantity, date published, and have references to author
    information, publishers, and other related tables. We could put an index on all
    columns and even add indexes for the data in related tables. The problem with
    this approach is that each index has to be stored and maintained for each statement
    that causes change. Database designers have to carefully plan and analyze databases
    in order to determine the optimal combination of adding and, just as importantly,
    not adding indexes and other constructs to tables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: A table index can be thought of like a virtual lookup table that provides the
    relational database with a faster way of looking up data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: OLAP
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases designed using the OLAP pattern are expected to have more `SELECT`
    statements than statements that cause change. These databases usually have a consolidated
    view of the data of one or more databases. Because of this, these databases are
    usually not the master database, but a database used to provide reporting and
    analysis separate from the master database. In some situations, this is provided
    on infrastructure isolated from other databases so as to not impact the performance
    of operational databases. This type of deployment is often referred to as a **data
    warehouse**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: A data warehousecan be used to provide a consolidated view of a system or collection
    of systems within an enterprise. The data is traditionally fed with slower periodical
    jobs to refresh the data from other systems, but with modern database systems,
    this is trending towards near real-time consolidation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between OLTP and OLAP is around how the data is stored
    and organized. In many situations, this would require tables or persistent views—depending
    on the technology used—to be created in the OLAP database that supports specific
    reporting scenarios and duplicates the data. In OLTP databases, duplication of
    data is undesirable as it then introduces multiple tables that need to be maintained
    for a single statement that causes change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Ledger-style databases
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ledger-style database design will be highlighted, as it is both a pattern
    that has been used in many financial databases for decades and it may not be known
    to some developers. The ledger-style database stems from an accountant''s ledger,
    where transactions were added to a document and the quantities and/or amounts
    are tallied in order to arrive at a final quantity or amount. The following table
    shows a ledger of the sale of apples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a0135c-e2a0-406c-8ce9-2c20c019ee12.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: There are a couple of things to point out about the example. The Purchaser information
    is written on separate rows instead of erasing their amounts and entering a new
    amount. Take the two purchases and one credit for West Country Produce. This is
    typically different from many databases in which a single row contains the Purchaser
    information with separate fields for the Amount and Price.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: A ledger-style database takes this concept by having a separate row per transaction,
    thus removing the `UPDATE` and `DELETE` statements and only relying on `INSERT`
    statements. This has several benefits. Similarly to a ledger, once each transaction
    has been written it cannot be removed or changed. If a mistake or a change occurs,
    such as the credit to West Country Produce, a new transaction needs to be written
    in order to arrive at the desired state. An interesting benefit of this is that
    the source table now has the immediate value of providing a detailed log of the
    activity. If we were to add a *modified by* column, we could then have a comprehensive
    log of who or what made the change and what the change was.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似账簿的数据库通过每个交易都有单独的一行来实现这一概念，因此删除`UPDATE`和`DELETE`语句，只依赖`INSERT`语句。这有几个好处。与账簿类似，一旦每笔交易被写入，就不能被移除或更改。如果出现错误或更改，比如对West
    Country Produce的信用，需要写入新的交易以达到期望的状态。这样做的一个有趣好处是源表现在立即提供了详细的活动日志。如果我们添加一个*modified
    by*列，我们就可以有一个全面的日志，记录是谁或什么做出了更改以及更改是什么。
- en: This example is for a single-entry ledger, but in the real world, a double-entry
    ledger would be used. The difference is that in a double-entry ledger, each transaction
    is recorded as a credit in one table and a debit in another.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是针对单条目账簿的，但在现实世界中，会使用双重账簿。不同之处在于，在双重账簿中，每笔交易都记录为一张表中的信用和另一张表中的借记。
- en: 'The next challenge is capturing the final or rolled-up version of the table.
    In this example, that is that amount of apples that have been purchased and for
    how much. The first approach could use a `SELECT` statement that simply performs `GROUP
    BY` on the purchaser, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个挑战是捕获表的最终或汇总版本。在这个例子中，这是已购买的苹果数量和价格。第一种方法可以使用一个`SELECT`语句，只需对购买者执行`GROUP
    BY`，如下所示：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this would be fine for smaller data sizes, the issue here is that the
    performance of the query would degrade over time as the number of rows increases.
    An alternative would be to aggregate the data into another form. There are two
    main ways of achieving this. The first is to perform this activity at the same
    time as you write the information from the ledger table into another table (or
    persistent view if supported) that holds the data in an aggregate form.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于较小的数据大小来说是可以的，但问题在于随着行数的增加，查询的性能会随着时间的推移而下降。另一种选择是将数据聚合成另一种形式。有两种主要的方法可以实现这一点。第一种方法是在将账簿表中的信息写入另一张表（或者如果支持的话，持久视图）时同时执行这个活动，这张表以聚合形式保存数据。
- en: A **persistent** or **materialized view** is similar to a database view, but
    the results of the view are cached. This gives us the benefit of not requiring
    the view to be recalculated on each request, and it is either refreshed periodically
    or when the underlying data changes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久**或**物化视图**类似于数据库视图，但视图的结果被缓存。这使我们不需要在每个请求上重新计算视图的好处，它要么定期刷新，要么在基础数据更改时刷新。'
- en: The second approach relies on another mechanism that is separate from the `INSERT`
    statement to retrieve the aggregated view when required. In some systems, the
    primary scenario of writing changes to a table and retrieving the result is performed
    less frequently. In this case, it would make more sense to optimize the database
    so that writes are faster than reads, therefore limiting the amount of processing
    required when new records are inserted.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法依赖于与`INSERT`语句分开的另一个机制，在需要时检索聚合视图。在一些系统中，向表中写入更改并检索结果的主要场景发生得不太频繁。在这种情况下，优化数据库使得写入速度比读取速度更快，从而限制插入新记录时所需的处理量会更有意义。
- en: The next section deals with an interesting pattern CQRS that can be applied
    at the database level. This could be used in the ledger-style database design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论一个有趣的模式CQRS，可以应用在数据库层面。这可以用在类似账簿的数据库设计中。
- en: Implementing the CQRS pattern
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施CQRS模式
- en: CQRS simply works on the separation between queries (to read) and commands (to
    modify). **Command-Query Separation** (**CQS**) is an approach to **Object-oriented
    Design** (**OOD**).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS简单地在查询（读取）和命令（修改）之间进行分离。**命令-查询分离**（**CQS**）是一种**面向对象设计**（**OOD**）的方法。
- en: 'CQRS was introduced for the first time by Bertrand Meyer ([https://en.wikipedia.org/wiki/Bertrand_Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer)).
    He mentioned this term in his book, *Object-Oriented Software Construction*, during
    the late 1980s: [https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554](https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是由Bertrand Meyer首次提出的（[https://en.wikipedia.org/wiki/Bertrand_Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer)）。他在20世纪80年代晚期的著作《面向对象的软件构造》中首次提到了这个术语：[https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554](https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554)。
- en: 'CQRS does fit well with some scenarios and has some useful factors to it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS在某些场景下非常适用，并具有一些有用的因素：
- en: '**Model separation**: In modeling terms, we are able to have multiple representations
    for our data model. The clear separation allows for choosing different frameworks
    or techniques over others that are more suitable for query or command. Arguably,
    this is achievable with **create, read, update, and delete** (**CRUD**)-style
    entities, although the single data layer assembly often emerges.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型分离**：在建模方面，我们能够为我们的数据模型有多个表示。清晰的分离允许选择不同的框架或技术，而不是更适合查询或命令的其他框架。可以说，这可以通过**创建、读取、更新和删除**（**CRUD**）风格的实体来实现，尽管单一的数据层组件经常会出现。'
- en: '**Collaboration**: In some enterprises, a separation between query and command
    would benefit the teams involved in building complex systems, particularly when
    some teams are more suited for different aspects of an entity. For example, a
    team that is more concerned about presentation could concentrate on the query
    model, while another team that is more focused on data integrity could maintain
    the command model.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：在一些企业中，查询和命令之间的分离将有利于参与构建复杂系统的团队，特别是当一些团队更适合处理实体的不同方面时。例如，一个更关注展示的团队可以专注于查询模型，而另一个更专注于数据完整性的团队可以维护命令模型。'
- en: '**Independent scalability**: Many solutions tend to either require more reads
    against the model, or more writes, depending on the business requirements.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立可伸缩性**：许多解决方案往往要求根据业务需求对模型进行更多读取或写入。'
- en: For CQRS, remember that commands update data and queries read data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CQRS，请记住命令更新数据，查询读取数据。
- en: 'Some important things to note while working on CQRS are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CQRS时需要注意的一些重要事项如下：
- en: Commands should be placed asynchronously rather than as synchronous operations.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令应该以异步方式放置，而不是同步操作。
- en: Databases should never be modified with queries.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库不应该通过查询进行修改。
- en: CQRS simplifies the design with the use of separate commands and queries. Also,
    we can physically separate read data from write data operations. In this arrangement,
    a read database could use a separate database schema, or in other words, we can
    say that it could use a read-only database that is optimized for queries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS通过使用单独的命令和查询简化了设计。此外，我们可以在物理上将读取数据与写入数据操作分开。在这种安排中，读取数据库可以使用单独的数据库架构，或者换句话说，我们可以说它可以使用一个专门用于查询的只读数据库。
- en: 'As the database uses a physical separation approach, we can visualize the CQRS
    flow of the application, as depicted in the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库采用了物理分离的方法，我们可以将应用程序的CQRS流程可视化，如下图所示：
- en: '![](img/a303ee36-9fb8-411d-a49c-26b3f526b63d.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a303ee36-9fb8-411d-a49c-26b3f526b63d.png)'
- en: The preceding diagram depicts an imaginary workflow of the CQRS application,
    in which an application has physically separate databases for write operations
    and read operations. This imaginary application is based on RESTful web services
    (.NET Core APIs). No APIs have been exposed directly to the client/end user who
    is consuming these APIs. There is an API gateway exposed to users, and any requests
    for applications will come through the API gateway.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表描述了CQRS应用程序的想象工作流程，其中应用程序具有用于写操作和读操作的物理分离数据库。这个想象中的应用程序是基于RESTful Web服务（.NET
    Core API）的。没有API直接暴露给使用这些API的客户端/最终用户。有一个API网关暴露给用户，任何应用程序的请求都将通过API网关进行。
- en: The API Gateway provides an entry point to groups with similar types of services.
    You can also simulate it with the facade pattern, which is part of the distributed
    system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: API网关为具有类似类型服务的组提供了一个入口点。你也可以使用外观模式来模拟它，这是分布式系统的一部分。
- en: 'In the previous diagram, we have the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个图表中，我们有以下内容：
- en: '**User interface**: This could be any client (who is consuming the APIs), web
    application, desktop application, mobile application, or any other application.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这可以是任何客户端（使用API的人），Web应用程序，桌面应用程序，移动应用程序，或者任何其他应用程序。'
- en: '**API Gateway**: Any request from UI and response to UI is delivered from the
    API Gateway. This is the main part of CQRS, as business logic can be incorporated
    by using the Commands and Persistence layers.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：来自用户界面的任何请求和向用户界面的任何响应都是通过API网关传递的。这是CQRS的主要部分，因为业务逻辑可以通过使用命令和持久层来合并。'
- en: '**Database(s)**: The diagram shows two physically separated databases. In real
    applications, this depends upon the requirements of the product, and you can use
    the database for both write and read operations.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：图表显示了两个物理分离的数据库。在实际应用中，这取决于产品的需求，你可以使用数据库进行写入和读取操作。'
- en: Queries are generated with `Read` operations that are **Data Transfer Objects**
    (**DTOs**).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询是通过`Read`操作生成的，这些操作是**数据传输对象**（**DTOs**）。
- en: 'You can now go back to the *Use case* section, in which we discussed the new
    features/extensions of our FlixOne inventory application. In this section, we
    will create a new FlixOne application with the features discussed previously using
    the CQRS pattern. Please note that we will be developing APIs first. If you did
    not install the pre-requisites, I suggest revisiting the *Technical requirements* section,
    gathering all of the required software, and installing them onto your machine.
    If you have completed the pre-requisites, then let''s start by following these
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以回到*用例*部分，在那里我们讨论了我们的FlixOne库存应用程序的新功能/扩展。在这一部分，我们将使用CQRS模式创建一个新的FlixOne应用程序，其中包括之前讨论的功能。请注意，我们将首先开发API。如果你没有安装先决条件，我建议重新访问*技术要求*部分，收集所有所需的软件，并将它们安装到你的机器上。如果你已经完成了先决条件，那么让我们开始按照以下步骤进行：
- en: Open Visual Studio.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Click File | New Project to create a new project.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击文件|新建项目来创建一个新项目。
- en: On the New Project window, select Web and then select ASP.NET Core Web Application.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目窗口中，选择Web，然后选择ASP.NET Core Web应用程序。
- en: Give a name to your project. I have named our project `FlixOne.API` and ensured
    that the Solution Name is `FlixOne`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的项目取一个名字。我已经为我们的项目命名为`FlixOne.API`，并确保解决方案名称为`FlixOne`。
- en: 'Select the Location of your `Solution` folder, then click on the OK button
    as shown in the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的`解决方案`文件夹的位置，然后点击*确定*按钮，如下图所示：
- en: '![](img/914c131b-65df-48fc-8f20-228eee0db8f6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/914c131b-65df-48fc-8f20-228eee0db8f6.png)'
- en: 'Now you should be on the New ASP.NET Web Core Application - FlixOne.API screen. Make
    sure that on this screen, you select ASP.NET Core 2.2\. Select Web Application
    (Model-View-Controller) from the available templates, and uncheck the Configure
    for HTTPS checkbox, as shown in the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该在新的ASP.NET Web Core应用程序 - FlixOne.API屏幕上。确保在此屏幕上，选择ASP.NET Core 2.2。从可用模板中选择Web应用程序（模型-视图-控制器），并取消选择HTTPS复选框，如下图所示：
- en: '![](img/90477786-80eb-41aa-b030-2bf74fa836dd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90477786-80eb-41aa-b030-2bf74fa836dd.png)'
- en: 'You will see a default page appear, as shown in the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个默认页面出现，如下截图所示：
- en: '![](img/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png)'
- en: 'Expand Solution Explorer and click on Show All files. You will see the default
    folders/files created by Visual Studio. Refer to the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开“解决方案资源管理器”，单击“显示所有文件”。您将看到Visual Studio创建的默认文件夹/文件。参考以下截图：
- en: '![](img/40563f44-0662-4c1b-aa6e-4901e13813ae.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40563f44-0662-4c1b-aa6e-4901e13813ae.png)'
- en: 'We have selected the ASP.NET Core Web (Model-View-Controller) template. Therefore,
    we have the default folders, Controllers, Models, and Views. This is a default
    template provided by Visual Studio. To check this default template, hit *F5* and
    run the project. Then, you will see the following default page:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了ASP.NET Core Web（Model-View-Controller）模板。因此，我们有默认的文件夹Controllers，Models和Views。这是Visual
    Studio提供的默认模板。要检查此默认模板，请按*F5*并运行项目。然后，您将看到以下默认页面：
- en: '![](img/61edea34-6458-48cb-b002-75bcbfa738a9.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61edea34-6458-48cb-b002-75bcbfa738a9.png)'
- en: 'The previous screenshot is the default Home screen of our web application.
    You may be thinking *is it a website?* and be expecting an API documentation page
    here instead of a web page. This is because, when we select the template, Visual
    Studio adds MVC Controller instead of API Controller by default. Please note that
    in ASP.NET Core, both MVC Controller and API Controller use the same Controller
    Pipeline (see the Controller class: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2)).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个截图是我们的Web应用程序的默认主屏幕。您可能会想*这是一个网站吗？*并期望在这里看到API文档页面而不是网页。这是因为当我们选择模板时，Visual
    Studio默认添加MVC Controller而不是API Controller。请注意，在ASP.NET Core中，MVC Controller和API
    Controller都使用相同的Controller Pipeline（参见Controller类：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2)）。
- en: 'Before discussing API projects in detail, let''s first add a new project to
    our FlixOne solution. To do so, expand Solution Explorer, right-click on the Solution
    Name, and then click on Add New Project. Refer to the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论API项目之前，让我们首先向我们的FlixOne解决方案添加一个新项目。要这样做，请展开“解决方案资源管理器”，右键单击解决方案名称，然后单击“添加新项目”。参考以下截图：
- en: '![](img/8b9834e5-e012-4982-932b-057a6510b41e.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b9834e5-e012-4982-932b-057a6510b41e.png)'
- en: 'In the New Project window, add the new `FlixOne.CQRS` project, and click on
    the `OK` button. Refer to the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在“新建项目”窗口中，添加新的`FlixOne.CQRS`项目，然后单击“OK”按钮。参考以下截图：
- en: '![](img/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png)'
- en: 'The previous screenshot is of the Add New Project window. On it, select .NET
    Core and then select the Class Library(.NET Core) project. Enter the name `FlixOne.CQRS`
    and click the OK button. A New Project has been added to the solution. You can
    then add folders to the new solution, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个截图是“添加新项目”窗口。在其中，选择.NET Core，然后选择Class Library(.NET Core)项目。输入名称`FlixOne.CQRS`，然后单击“OK”按钮。已将新项目添加到解决方案中。然后，您可以添加文件夹到新解决方案，如下截图所示：
- en: '![](img/cb3a872f-4b1b-486f-b858-b04df8b0855e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb3a872f-4b1b-486f-b858-b04df8b0855e.png)'
- en: 'The previous screenshot is showing that I have added four new folders: `Commands`,
    `Queries`, `Domain`, and `Helper`. In the `Commands` folder, I have the `Command`
    and `Handler` sub-folders. Similarly, for the `Queries` folder, I have added sub-folders
    called `Handler` and `Query`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个截图显示我已添加了四个新文件夹：`Commands`，`Queries`，`Domain`和`Helper`。在`Commands`文件夹中，我有`Command`和`Handler`子文件夹。同样，对于`Queries`文件夹，我添加了名为`Handler`和`Query`的子文件夹。
- en: 'To get started with the project, let''s first add two Domain Entities in the
    project. The following is the required code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始项目，让我们首先在项目中添加两个领域实体。以下是所需的代码：
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is a `Product` domain entity that has the following properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个`Product`领域实体，具有以下属性：
- en: '`Id`: A unique identifier'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`：一个唯一标识符'
- en: '`Name`: A product name'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：产品名称'
- en: '`Description`: A product description'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`：产品描述'
- en: '`Image`: An image of the product'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：产品的图像'
- en: '`Price`: The price of the product'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price`：产品的价格'
- en: 'We also need to add the `CommandResponse` database. This plays an important
    role when interacting with database/repository, in that it ensures that the system
    gets a response. The following is the code-snippet of the `CommandResponse` Entity
    Model:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加`CommandResponse`数据库。在与数据库/存储库交互时，这在确保系统获得响应方面起着重要作用。以下是`CommandResponse`实体模型的代码片段：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding `CommandResponse` class contains the following properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`CommandResponse`类包含以下属性：
- en: '`Id`: Unique identifier.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`：唯一标识符。'
- en: '`Success`: With values of `True` or `False`, it tells us whether the operation
    is successful or not.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Success`：具有`True`或`False`的值，告诉我们操作是否成功。'
- en: '`Message`: A message as a response to the operation. If `Success` if false,
    this message contains `Error`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`：作为操作响应的消息。如果`Success`为false，则此消息包含`Error`。'
- en: 'Now, it''s time to add interfaces for a query. To add interfaces, follow these
    steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为查询添加接口了。要添加接口，请按照以下步骤进行：
- en: 'From Solution Explorer, right-click on the `Queries` folder, click on Add,
    and then click on New Item, as per the following screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”中，右键单击“Queries”文件夹，单击“添加”，然后单击“新建项”，如下截图所示：
- en: '![](img/c7b79ebb-67b7-49ff-a003-26a089491ba5.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7b79ebb-67b7-49ff-a003-26a089491ba5.png)'
- en: 'From the Add New Item window, choose Interface, name it IQuery, and click on
    the Add button:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“添加新项”窗口中，选择接口，命名为`IQuery`，然后单击“添加”按钮：
- en: '![](img/e055b30e-23f0-49bd-b246-49d682935ed7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e055b30e-23f0-49bd-b246-49d682935ed7.png)'
- en: 'Follow the previous steps and add the `IQueryHandler` interface as well. The
    following is the code from the `IQuery` interface:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上述步骤，还要添加`IQueryHandler`接口。以下是`IQuery`接口的代码：
- en: '[PRE3]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous interface works as a skeleton for querying for any kind of operation.
    This is a generic interface using an `out` parameter of the `TResponse` type.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个接口作为查询任何类型操作的骨架。这是使用`TResponse`类型的`out`参数的通用接口。
- en: 'The following is code from our `ProductQuery` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`ProductQuery`类的代码：
- en: '[PRE4]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is code from our `ProductQueryHandler` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`ProductQueryHandler`类的代码：
- en: '[PRE5]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is code from our `ProductQueryHandlerFactory` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`ProductQueryHandlerFactory`类的代码：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly to `Query` interfaces and `Query` classes, we need to add interfaces
    for commands and their classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`Query`接口和`Query`类，我们需要为命令及其类添加接口。
- en: 'At the point by which we have created CQRS for a product domain entity, you
    can follow this workflow and add more entities as many times as you like. Now,
    let''s move on to our `FlixOne.API` project and add a new API controller by following
    these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为产品领域实体创建了CQRS的时候，您可以按照这个工作流程添加更多的实体。现在，让我们继续进行`FlixOne.API`项目，并按照以下步骤添加一个新的API控制器：
- en: From Solution Explorer, right-click on the `Controllers` folder.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击`Controllers`文件夹。
- en: Select Add | New Item.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加|新项目。
- en: 'Select API Controller Class and name it `ProductController`; refer to the following
    screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择API控制器类，并将其命名为`ProductController`；参考以下截图：
- en: '![](img/b9088f70-6e1b-4b33-a49f-2cff8620875d.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9088f70-6e1b-4b33-a49f-2cff8620875d.png)'
- en: 'Add the following code in the API controller:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API控制器中添加以下代码：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code is for saving the product:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于保存产品的：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is for deletion of products:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于删除产品的：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have created Product APIs, and we are not going to creates UI in this section. To
    view what we have done, we will be adding **Swagger** support to our API project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了产品API，并且在本节中不会创建UI。为了查看我们所做的工作，我们将为我们的API项目添加**Swagger**支持。
- en: Swagger is a tool that can be used for documentation purposes, and provides
    all of the information regarding the API endpoints on one screen, where you can
    visualize the API and test it by setting parameters as well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个用于文档目的的工具，并在一个屏幕上提供有关API端点的所有信息，您可以可视化API并通过设置参数进行测试。
- en: 'To get started with the implementation of Swagger in our API project, follow
    these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在我们的API项目中实现Swagger，按照以下步骤进行：
- en: Open Nuget Package Manager.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Nuget包管理器。
- en: 'Go to Nuget Package Manager | Browse and search for `Swashbuckle.ASPNETCore`; refer
    to the following screenshot:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Nuget包管理器|浏览并搜索`Swashbuckle.ASPNETCore`；参考以下截图：
- en: '![](img/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png)'
- en: 'Open the `Startup.cs` file and add the following code to the `ConfigureService`
    method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Startup.cs`文件，并将以下代码添加到`ConfigureService`方法中：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, add the following code to the `Configure` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`Configure`方法中：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have now completed all of the changes that serve to showcase the power of
    CQRS in the application. Hit *F5* in Visual Studio and open the Swagger documentation
    page by accessing the following URL: [http://localhost:52932/swagger/](http://localhost:52932/swagger/) (please
    note that port number `52932` may vary as per your setting of the project). You
    will see the following Swagger Documentation page:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了展示应用程序中CQRS的强大功能的所有更改。在Visual Studio中按下*F5*，并通过访问以下URL打开Swagger文档页面：[http://localhost:52932/swagger/](http://localhost:52932/swagger/)（请注意，端口号`52932`可能会根据项目设置而有所不同）。您将看到以下Swagger文档页面：
- en: '![](img/2a67a98c-096c-4475-8258-7a0ace3abfbd.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a67a98c-096c-4475-8258-7a0ace3abfbd.png)'
- en: Here, you can test Product APIs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以测试产品API。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the CQRS pattern, which we then implemented into our
    application. The aim of the chapter was to go through the database techniques
    and look at how ledger-style databases work for inventory systems. To showcase
    the power of CQRS, we have created Product APIs and added support for Swagger
    documentation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了CQRS模式，然后我们将其实现到我们的应用程序中。本章的目的是通过数据库技术，并查看分类账式数据库如何用于库存系统。为了展示CQRS的强大功能，我们创建了产品API，并添加了对Swagger文档的支持。
- en: In the next chapter, we will discuss cloud services and look at microservices
    and serverless techniques in detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论云服务，并详细了解微服务和无服务器技术。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: What is a ledger-style database?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是分类账式数据库？
- en: What is CQRS?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是CQRS？
- en: When should we use CQRS?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们何时应该使用CQRS？

- en: Coding for the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters explored patterns, from lower-level concepts such as the
    Singleton and Factory patterns, to patterns for specific technologies such as
    databases and web applications. These patterns are essential for ensuring the
    good design of a solution to ensure maintainability and efficient implementation.
    These patterns provide a solid foundation that allows applications to be enhanced
    and modified as requirements change and new functionality is added.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter takes a higher-level view of a solution to address concerns involving
    designing implementing solutions that are reliable, scalable, and secure. The
    patterns in this chapter often involve environments that contain multiple applications,
    a repository, and a range of possible infrastructure configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The software industry is continually evolving and with the change comes new
    opportunity as well as new challenges. In this chapter, we will look at different
    software patterns for the cloud. Many of these patterns are not new, and existed
    in on-premises environments. As cloud-first solutions are becoming the norm, these
    patterns are even more commonplace due to the ease of implementing solutions that
    do not rely on on-premises infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-first or cloud-native solutions have been designed to target cloud computing
    resources, while hybrid solutions have been designed to use both cloud computing
    resources as well as resources from a private data center.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter defines five key concerns when building solutions in the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss the key concerns and why they are significant to building cloud
    solutions. As the concerns are discussed, different patterns will be described
    that can be applied to address these concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not require any special technical requirements or source code
    as it is primarily theoretical.
  prefs: []
  type: TYPE_NORMAL
- en: Key considerations when building solutions in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making the decision to move to the cloud comes with its own set of problems
    and challenges. In this section, we will cover five key areas of consideration
    for building cloud-based solutions. While these are not unique to the cloud, they
    require special attention when switching to the cloud due to the wide range of
    technologies and solutions that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The five primary considerations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: This allows for accommodation of increased load or traffic
    for a growing business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience/availability**: This ensures the handling of failures in a system
    gracefully with as little impact on the user as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This ensures that private and proprietary data stays that way
    and is safe from hacks and attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application design**: This refers to the design of applications with special
    consideration for cloud-based solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps**: This is a collection of tools and practices that supports the development
    and running of cloud-based solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your business requirements, you may need to look for solutions
    for some or all of these considerations. It is also in your business's best interest
    to adopt providers with solutions to problems that you don't anticipate but would
    make for good contingency planning.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will discuss these considerations in further detail
    along with the available solution patterns for them.
  prefs: []
  type: TYPE_NORMAL
- en: These patterns range from a type of technology to architectural to business
    processes and a single pattern could address more than one concern.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability refers to the ability to allocate and manage resources used by an
    application in order for the application to maintain an acceptable level of quality
    under a given workload. Most cloud offerings provide mechanisms for increasing
    the quality and quantity of resources used by an application. For example, the
    Azure App Service allows scaling of both the size of the App Service and the number
    of instances of the App Service.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability can be viewed as demand on a limited number of resources. A resource
    could be disk space, RAM, bandwidth, or another aspect of software that can be
    quantified. The demand can range from the number of users, concurrent connections,
    or another demand that would produce a constraint on a resource. As the demand
    increases, a strain is placed on the application in order to provide the resource.
    When the strain affects the performance of the application, this is referred to
    as a resource bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a measure might be the number of users that can access an application
    before the performance of the application begins to deteriorate. The performance
    could be set as an average latency on requests being less than 2 seconds. As the
    number of users increases, the load on the system could then be viewed, and specific
    resource bottlenecks affecting the performance could be identified.
  prefs: []
  type: TYPE_NORMAL
- en: Workload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to determine how to effectively address scaling issues, it is important
    to understand the workload that the system will be under. There are four main
    types of workload: static, periodic, once-in-a-lifetime and unpredictable.'
  prefs: []
  type: TYPE_NORMAL
- en: A static workload represents a constant level of activity on a system. Because
    the workload does not fluctuate, this type of system does not require a very elastic
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Systems that have a predictable change in workload have a periodic workload.
    An example would be a system that experiences a surge of activity around the weekends
    or around the months when income tax is due. These systems can be scaled up to
    maintain a desired level of quality when the load increases and scaled down to
    save cost when the load decreases.
  prefs: []
  type: TYPE_NORMAL
- en: Once-in-a-lifetime workloads indicate systems designed around a specific event.
    These systems are provisioned to handle the workload around the event and deprovisioned
    once they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Unpredictable workloads often benefit from the auto-scale functionality mentioned
    earlier. These systems have large fluctuations in activity that are either not
    understood by the business yet or are influenced by other factors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and designing a cloud-based application for its type of workload
    is essential for both maintaining a high level of performance as well as lowering
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have available three design patterns and one architecture pattern to choose
    from to enable us to add scalability to our systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's review each in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it is possible to add physical RAM or an additional disk drive to an
    on-premises server, most cloud providers support the ability to easily increase
    or decrease the computing power of a system. This is often with little or no downtime
    as the system scales. This type of scaling is called vertical scaling and refers
    to when a resource such as the type of CPU, size and quality of RAM, or size and
    quality of the disk is altered.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scaling is often referred to as *scaling up* while horizontal scaling
    is often referred to as *scaling out*. In this context, the term *up* refers to
    the size of the resource while *out* refers to the number of instances.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Horizontal scaling differs from vertical scaling because, instead of altering
    the size of a system, horizontal scaling changes the number of systems involved.
    For example, a web application might run on a single server having 4 GB RAM and
    2 CPUs. If the server was increased in size to 8 GB RAM and 4 CPUs, then this
    would be vertical scaling. However, if two more servers were added with the same
    configuration of 4 GB RAM and 2 CPUs, then this would be horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Horizontal scaling can be achieved by using some form of load balancing that
    redirects the requests across a collection of systems as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
  prefs: []
  type: TYPE_IMG
- en: Horizontal scaling is usually preferred in cloud solutions over vertical scaling.
    This is because, in general, it is more cost effective to use several smaller
    virtual machines to a single large server to provide the same measure of performance.
  prefs: []
  type: TYPE_NORMAL
- en: For horizontal scaling to be most effective, it does require a system design
    that supports this type of scaling. For example, web applications designed without
    sticky sessions and/or state stored on the server work better for horizontal scaling.
    This is because sticky sessions cause a user's requests to be routed to the same
    virtual machine for processing and, over time, the balance of the routing across
    the virtual machines could become uneven and therefore not as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful applications
  prefs: []
  type: TYPE_NORMAL
- en: A *stateful *application maintains information about an active session on the
    server or repository.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless applications
  prefs: []
  type: TYPE_NORMAL
- en: '*Stateless* applications are designed to not require information about an active
    session to be stored on the server or repository. This allows for subsequent requests
    in a single session to be sent to any server to be handled and not just to the
    same server for the entire session.'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications designed that are stateful require sessions or information
    to be maintained in a shared repository. Stateless web applications support a
    more resilient pattern as any server in a web garden or web farm. This allows
    for a single node in the web application to fail without losing session information.
  prefs: []
  type: TYPE_NORMAL
- en: A web *garden* is a pattern where multiple copies of the same web application
    are hosted on the same server, whereas a web *farm* is a pattern where multiple
    copies of the same web application are hosted on different servers. In both patterns,
    routing is used to expose the multiple copies as if they were a single application.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An advantage of using a cloud provider over on-premises solutions is the built-in
    support for auto-scaling. As an added benefit to horizontal scaling, the ability
    to auto-scale an application is often a configurable feature of a cloud service.
    For example, an Azure App Service provides the ability to set up auto-scale profiles
    that allow an application to react to conditions. For example, the following screenshot
    shows an auto-scale profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
  prefs: []
  type: TYPE_IMG
- en: The profile designed for weekdays will increase or decrease the number of app
    service instances depending on the load on the servers. The load is being measured
    in CPU percentage. If the CPU percentage is averages above 60%, then the number
    of instances is increased up to a maximum of 10\. Similarly, if the CPU percentage
    falls below 30%, the number of instances is reduced to a minimum of 2.
  prefs: []
  type: TYPE_NORMAL
- en: An elastic infrastructure allows for resources to be scaled vertically or horizontally
    without requiring a re-deploy or downtime. The term is actually more of a degree
    of elasticity instead of referring to whether a system is *elastic* or *not elastic*. For
    example, an elastic service could allow for scaling both vertically and horizontally
    without requiring a restart of the service instances. A less elastic service would
    allow for scaling horizontally without a restart but would require a restart of
    the service when the size of the server is altered.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different interpretations of what microservices means and how it
    relates to **service-oriented architecture** (**SOA**). In this section, we are
    going to view microservices as a refinement of SOA and not a new architectural
    pattern. The microservice architecture extends SOA by adding some additional key
    principles which require that services must:'
  prefs: []
  type: TYPE_NORMAL
- en: be small - hence the term *micro*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: be built around a business capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: be loosely coupled with other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: be independently maintainable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: have an isolated state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices takes the services in SOA farther by reducing them to their smallest
    possible size. This fits well with some other patterns that we have seen, such
    as **Keep It Simple Stupid** (**KISS**) and **You Aren't Gonna Need It** (**YAGNI**)
    from [Chapter 2](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml), *Modern Software
    Design Patterns and Principles*. The microservice should only fulfill its requirements
    and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Business capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By building a service around a business capability, we align our implementation
    in such a way that, as the business requirements change, our services will be
    changed in a similar manner. Because of this, it is less likely that change in
    one area of the business will impact other areas.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice should interact with other services across a service boundary
    using a technology-agnostic protocol such as HTTP. This allows for the microservices
    to be integrated more easily and, more importantly, not require the rebuild of
    a microservice when another service changes. This does require a known *service
    contract* to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Service contract
  prefs: []
  type: TYPE_NORMAL
- en: A *service contract* is the definition of a service that is distributed to other
    development teams. **Web Services Description Language** (**WSDL**) is a widely
    known XML-based language for describing services, but other languages, such as
    Swagger, are also very popular.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a microservice, it is important to have a strategy for how
    the change will be managed. By having a versioned service contract, it is then
    possible to communicate the change clearly to a client of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the strategy of a microservice used to store an inventory of books
    could have the following strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Each service will be versioned and include a Swagger definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service will start with version 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a change is made that requires the service contract to change, the version
    will be increased by 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service will maintain up to three versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to a service must ensure that all current versions behave suitably.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding basic strategy does have interesting implications. First of all,
    the team maintaining a service must ensure that changes do not break existing
    services. This ensures a new deployment will not break other services while allowing
    for new functionality to be deployed. The contract does allow for up to three
    services to be active at a time, thus allowing for a dependable service to update
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Independently maintainable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the most distinguishing features of microservices. Having a microservice
    able to be maintained independent of other microservices empowers a business to
    be able to manage the service without impacting other services. By managing a
    service, we are including both the development as well as the deployment of a
    service. With this principle, microservices can be updated and deployed with a
    reduced chance of impacting other services, as well as at a different rate of
    change from other services.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Isolated state includes both data and other resources that could be shared including
    databases and files. This is also a distinguishing feature of microservice architecture.
    By having an independent state, we are reducing the chance that a change in the
    data model to support one service will impact other services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a more traditional SOA approach, where a
    single database is used by multiple services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By requiring a microservice to have an isolated state, we would then require
    a database per service as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
  prefs: []
  type: TYPE_IMG
- en: This has an advantage in that each service can choose the technology that best
    fits the requirements of the services.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice architecture does represent a shift from traditional service
    design and it does fit well in a cloud-based solution. The advantages of microservices
    and why they are gaining in popularity might not be immediately obvious. We have
    touched on how the design of microservices provides advantages for handling change
    gracefully. From a technical point of view, microservices can be scaled independently
    both at the service level and at the database.
  prefs: []
  type: TYPE_NORMAL
- en: What might not be clear is the benefit a microservice architecture has to a
    business. By having small independent services, the business can then look at
    different ways to maintain and develop microservices. The business now has options
    to host the services in different ways, including different cloud providers, as
    best fits the independent services. Likewise, the isolated nature of the services
    allows for a greater degree of agility in developing the services. As change happens,
    resources (that is, development team members) can be allocated to different services
    as required, and, as the scope of service is smaller, the amount of business knowledge
    required is also reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency/availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resiliency is the ability of an application to handle failure gracefully while
    availability is a measure of the amount of time the application is working. An
    application may have a collection of resources and still remain available if one
    of the resources becomes inoperable or unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: If an application is designed to handle one or more resources failing without
    the entire system becoming inoperable, this is referred to as **graceful degradation**.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns apply to both isolate the elements of an application as well as handle
    the interaction between the elements so that when a failure occurs, the impact
    is limited. Many of the resiliency-related patterns focus on the messaging between
    the components within the application or to other applications. The Bulkhead pattern,
    for example, isolates the traffic into pools so that when one pool becomes overwhelmed
    or fails, the other pools are not adversely affected. Other patterns apply specific
    techniques to handle messaging, such as retry policies or compensating transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Availability is an important factor to many cloud-based applications and, typically,
    availability is measured against a **service level agreement** (**SLA**). In most
    cases, the SLA stipulates the percentage of time the application must remain operable.
    Patterns involve both allowing for redundancy of components as well as using techniques
    to limit the effect of an increase in activity. For example, the Queue-Based Load
    Leveling pattern uses a queue to limit the effect a spike in activity might have
    on an application by acting as a buffer between the caller, or client, and the
    application or service.
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency and availability are identified here as related cloud solution factors
    as often a resilient application allows for a strict SLA on availability to be
    achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Solution pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure we have a system that has resilience and availability, our best bet
    is to look for a provider with a specific architecture. Enter **event-driven architecture**
    (**EDA**).
  prefs: []
  type: TYPE_NORMAL
- en: EDA is an architectural pattern that uses *events* to drive the behavior and
    activity of a system. The solution patterns available under it will help us achieve
    the intended resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: EDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EDA promotes the concept of having loosely connected producers and consumers
    where the producers do not have direct knowledge of the consumers. An event in
    this context is any change ranging from a user logging onto a system, to an order
    being placed, to a process failing to complete successfully. EDA fits well in
    distributed systems and allows for highly scalable solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many related patterns and approaches to EDA and the following patterns
    are presented in this section as being directly relevant to EDA:'
  prefs: []
  type: TYPE_NORMAL
- en: Queue-Based Load Leveling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher Subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensating Transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue-Based Load Leveling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queue-Based Load Leveling is an effective way of minimizing the impact of occurrences
    of high demand on availability. By introducing a queue between a client and service,
    we are able to throttle or restrict the number of requests that are being handled
    by the service at a time. This allows for smoother user experience. Take the following
    diagram as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a client submitting a request to a queue to be processed
    and the result saved to a table. The queue acts to prevent the function from being
    overwhelmed by a sudden spike in activity.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher Subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Publisher Subscriber pattern states that there are event publishers and
    event consumers. Essentially, this is the heart of EDA, as the publishers are
    decoupled from the consumers and are not concerned about the delivery of events
    to the consumers, but only with publishing events. The event will contain information
    that will be used to route the event to interested consumers. A consumer would
    then register or subscribe to being interested in specific events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram illustrates a Customer Service and an Order Service. The
    Customer Service acts as a publisher and submits an event when a customer is added.
    The Order Service has subscribed to new customer events. When a new customer event
    is received, the Order Service inserts the customer information into its local
    store.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing the Publisher Subscriber pattern into the architecture, the Order
    Service is then decoupled from the Customer Service. An advantage of this is it
    provides a more flexible architecture for change. For example, a new service could
    be introduced to add new customers to the solutions that do not require being
    added to the same repository used by the Customer Service. Also, more than one
    service could subscribe to the new customer event. Adding a welcome email could
    more easily be added as a new subscriber, rather than having to build this functionality
    into a single monolithic solution.
  prefs: []
  type: TYPE_NORMAL
- en: Priority Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another related pattern is Priority Queue, which provides a mechanism for treating
    similar events differently. Using the new customer example from the previous section,
    it would be possible to have two subscribers for a new customer event. One subscriber
    would be interested in the majority of the new customers, while one subscriber
    would identify a subset of the customers that should be handled differently. For
    example, new subscribers from rural areas might receive an email with additional
    information about specialized shipping providers.
  prefs: []
  type: TYPE_NORMAL
- en: Compensating transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With distributed systems, it is not always practical or desirable to issue
    a command as a transaction. A transaction in this context refers to a lower-level
    programming construct that manages one or more commands as a single action that
    either all succeeds or all fails. In some situations, a distributed transaction
    is not supported, or the overhead of using a distributed transaction outweighs
    the benefits. The Compensating Transaction pattern was developed to handle this
    situation. Let''s use the following as an example based on a BizTalk orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram shows two steps in a process: creating order in an Order Service
    and debiting funds from a Customer Service. The diagram shows how, first the order
    is created and then the funds are removed. If the debit of funds does not succeed
    then the order is removed from the Order Service.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security ensures an application does not disclose information incorrectly or
    provide functionality outside of intended use. Security includes both malicious
    and accidental actions. With cloud applications and increasing use of a wide range
    of identity providers, restricting access to only approved users is often challenging.
  prefs: []
  type: TYPE_NORMAL
- en: End-user authentication and authorization requires design and planning as fewer
    applications run in isolation, and it is common for multiple identity providers,
    such as Facebook, Google, and Microsoft, to be used. In some instances, patterns
    are used to provide access directly to resources for improved performance and
    scalability. Furthermore, other patterns are concerned with creating a virtual
    wall between clients and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the industry has become more interconnected, the pattern of using an external
    party to authenticate users has become more common. The Federated Security pattern
    has been chosen for discussion here as it is one of the best ways to ensure security
    in our systems, and most **software-as-a-service (SaaS)** platforms offer this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Federated security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Federated security delegates the authentication of user or service (consumer)
    to an external party known as an **identity provider** (**IdP**). An application
    using federated security will trust the IdP to properly authenticate the consumer
    and provide details about the consumer or claims accurately. This information
    about the consumer is presented as a token. A common scenario for this would be
    a web application using a social IdP such as Google, Facebook, or Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Federated security can handle a variety of scenarios, from interactive sessions
    to authentication backend services or non-interactive sessions. Another common
    scenario is the ability to provide a single authentication experience or **single
    sign-on** (**SSO**) across a suite of separately hosted applications. This scenario
    allows for a single token to be acquired from a **security token service** (**STS**)
    and the same token used to present to the multiple applications without requiring
    the login procedure to be repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Federated security has two main purposes. First, it simplifies the management
    of identities by having a single identity store. This allows for identities to
    be managed in a central and unified manner, making it easier to perform management
    tasks such as providing the login experience, forgotten password management, as
    well as revoking passwords in a consistent manner. Secondly, it provides a better
    user experience by offering users a similar experience across multiple applications
    as well as requiring only a single form of authentication, instead of needing
    to remember multiple passwords.
  prefs: []
  type: TYPE_NORMAL
- en: There are several standards for federated security and two widely used ones
    are **Security Assertion Markup Language** (**SAML**) and **OpenId Connect** (**OIDC**).
    SAML is older than OIDC and allows for the exchange of messages using an XML SAML
    format. OIDC is built upon OAuth 2.0 and commonly uses **JSON Web Token** (**JWT**)
    for describing the security token. Both formats support federated security, SSO,
    and many public IdPs such as Facebook, Google, and Microsoft support both standards.
  prefs: []
  type: TYPE_NORMAL
- en: Application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design of an application can vary significantly and be influenced by many
    factors. These factors are not only technical but are influenced by the teams
    involved in building, managing, and maintaining the applications. Some patterns,
    for example, work best with small dedicated teams as opposed to a larger number
    of geographically dispersed teams. Other design-related patterns handle different
    types of workload better and are used in specific scenarios. Other patterns have
    been designed around the frequency of change and how to limit the disruption of
    changes to an application once it has been released to users.
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As almost all on-premises patterns are applicable to cloud-based solutions,
    the scope of patterns that could be covered is staggering. The Cache and CQRS
    patterns have been chosen because the former is a very common pattern employed
    by most web applications and the latter shifts how designers think of building
    solutions and lends itself well to other architectural patterns such as SOA and
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing information retrieved from slower forms of storage into faster forms
    of storage, or caching, has been a technique that has been used in programming
    for decades and can be seen in software such as a browser cache and hardware such
    as RAM. In this chapter, we will look at three examples: Cache-aside, Write-through
    Cache, and Static Content Hosting.'
  prefs: []
  type: TYPE_NORMAL
- en: Cache-aside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Cache-aside pattern can be used to improve performance by loading frequently
    referenced data in a local or faster form of storage. With this pattern, it is
    the responsibility of the application to maintain the state of the cache. This
    is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
  prefs: []
  type: TYPE_IMG
- en: First, the application requests information from the cache. If the information
    is missing, then it is requested from the data store. The application then updates
    the cache with the information. Once the information is stored, it will then be
    retrieved from the cache and used without referencing the slower data store. With
    this pattern, it is the application's responsibility to maintain the cache, both
    when there is a cache miss, and when the data is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The term *cache miss* refers to when data is not found in the cache. In other
    words, it is missing from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Write-through cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Write-through Cache pattern can also be used to improve performance in
    a similar manner as the Cache-aside pattern. Its approach differs by moving the
    management of the cache''s content from the application to the cache itself, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
  prefs: []
  type: TYPE_IMG
- en: A request is made for a piece of information in the cache. If the data is not
    already loaded, then the information is retrieved from the data store, placed
    in the cache, and then returned. If the data was already held, then it is immediately
    returned. This pattern supports updating the cache by passing the write of the
    information through the cache service. The cache service then updates the information
    held, both in the cache and in the data store.
  prefs: []
  type: TYPE_NORMAL
- en: Static Content Hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Static Content Hosting pattern moves static content such as media images,
    movies, and other non-dynamic files to a system dedicated for fast retrieval.
    A specialized service for this is called a **content delivery network** (**CDN**),
    which manages to distribute content across multiple data centers and directs requests
    to the data center closest to the caller, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Static Content Hosting is a common pattern for web applications where a dynamic
    page is requested from the web application and the page contains a collection
    of static content, such as JavaScript and images, which the browser then retrieves
    directly from the CDN. This is an effective way to reduce the traffic on the web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Command and Query Responsibility Segregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is a great software
    pattern to discuss in more detail as it is conceptually simple and relatively
    easy to implement but has dramatic implications to both the application and the
    developers involved. The pattern clearly separates the commands that affect the
    state of the application from queries that only retrieve data. Simply put, commands
    such as updates, adds, and deletes are provided in different services from the
    queries that do not change any data.'
  prefs: []
  type: TYPE_NORMAL
- en: You might say *CQRS again!* and we recognize that we have used an example of
    CQRS in OOP and database design. The same principle does apply to many areas of
    software development. We are presenting CQRS in this section as a pattern for
    service design as it leads to some interesting benefits and fits well in modern
    patterns such as microservices and reactive application design.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS is based on the object-oriented design presented in the late 1980s by Bertrand
    Meyer's book, *Object-Oriented Software Construction*: [http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we revisit [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml): *Implementing
    Design Patterns - .NET Core*, we illustrated this pattern by splitting our inventory
    context into two interfaces: `IInventoryReadContext` and `IInventoryWriteContext`.
    As a reminder, here are the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `GetBooks` method is separated from the two methods, `AddBook`
    and `UpdateQuantity`, that modify the state of the inventory. This illustrated
    CQRS within the code solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same approach can be applied at a service level. If we use a service for
    maintaining inventory as an example, we would break the service between a service
    for updating the inventory and another service for retrieving the inventory. This
    is illustrates in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's explore CQRS first by looking at the challenges of when it is applied
    in cloud-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are significant challenges to using the CQRS pattern with services:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staleness is a measure of how closely data reflects the committed version of
    the data. Data, in most circumstances, has the potential to change, so, as soon
    as a piece of data is read, there is a chance that the data could be updated,
    making the read data become inconsistent with the source data. This is a challenge
    with all distributed systems where it is not practical to guarantee the value
    shown to a user reflects the source value. When the data directly reflects what
    is stored, we can call the data consistent; when the data does not, it is viewed
    as inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: A common term used in distributed systems is *eventual consistency*. Eventual
    consistency is used to say a system will over time become consistent. In other
    words, it will eventually become consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The other more subtle challenge is adoption. Implementing CQRS into an established
    development team can be met with resistance both from developers and designers
    who are unfamiliar with the pattern and may lack support from the business for
    deviating from current design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: So what are the benefits?
  prefs: []
  type: TYPE_NORMAL
- en: Why CQRS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are three compelling factors for using CQRS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaboration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model separation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent scalability**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With separate services, we can then maintain, deploy, and scale these services
    independently. This increases the level of collaboration we can achieve between
    the development teams.
  prefs: []
  type: TYPE_NORMAL
- en: By having separate services, we can use a model that best fits our service.
    The command service might use simple SQL statements directly against a database,
    as that is the most familiar technology to the team responsible, while the team
    building the query service might use a framework for handling complex statements
    against the database.
  prefs: []
  type: TYPE_NORMAL
- en: Most solutions tend to have a higher level of reads than writes (or vice versa)
    so splitting the services along this criterion makes sense in many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With cloud-based solutions, the data center is remotely hosted and you often
    do not have full control or access to all aspects of an application. In some cases,
    such as serverless services, the infrastructure is abstracted away. An application
    must still expose information about a running application that can be used to
    manage and monitor an application. Patterns used to manage and monitor are essential
    for the success of an application by providing both the ability to keep an application
    running healthily as well as providing strategic information to the business.
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the availability of commercial packages relating to monitoring and managing
    solutions, many businesses have gained better control and understanding of their
    distributed systems. Telemetry and continuous delivery/continuous integration
    have been chosen to cover in more detail as they have particular value in cloud-based
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Telemetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the software industry has evolved and distributed systems involve more services
    and applications, being able to have a collective and consistent view of a system
    has become a huge asset. Popularized by services such as New Relic and Microsoft
    Application Insights, **application performance management** (**APM**) systems
    use information recorded about applications and infrastructure, known as telemetry,
    to monitor, manage performance, and view the availability of a system. In cloud-based
    solutions, where it is often not possible or practical to gain direct access to
    the infrastructure of a system, an APM allows for telemetry to be sent to a central
    service, digested, and then presented to operations and the business, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is taken from Microsoft Application Insights and provides
    a high-level snapshot of a running web application. At a glance, operations can
    identify changes in the behavior of the system and react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration/continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration/continuous deployment** (**CI/CD**) is a modern development
    process designed to streamline the **software delivery product life cycle** (**SDLC**)
    by merging changes frequently and deploying those changes often. CI addresses
    the issues that arise in enterprise software development where multiple programmers
    are working on the same code base or when a single product is managed with multiple
    code branches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, there are three target environments: Development,
    **User Acceptance Testing** (**UAT**), and Production. The Development environment
    is the initial environment where all the changes made to an application are tested
    together. The UAT environment is used by the **Quality Assurance** (**QA**) team
    to verify the system is working as intended before the changes are moved to a
    customer-facing environment, referred to in the diagram as Production. The code
    base has been broken into three matching branches: the trunk which all changes
    by the development team are merged into, UAT, which is used to deploy to the UAT
    environment, and the Production code base, which is used to deploy into the Production
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: The CI pattern is applied by creating a new build when the code base changes.
    After a successful build, a suite of unit tests is run against the build to ensure
    existing functionality has not been broken. If a build is not successful, the
    development team investigates and either fixes the code base or the unit test
    so the build then passes.
  prefs: []
  type: TYPE_NORMAL
- en: Successful builds are then pushed to a target environment. The Trunk might be
    set to push a new build automatically once a day to the Integration environment,
    while the QA team has requested less disturbance in the environment, so a new
    build is only pushed once a week after office hours. Production might require
    a manual trigger to coordinate new releases as to announce the new features and
    bug fixes in a formal release.
  prefs: []
  type: TYPE_NORMAL
- en: There is confusion over the terms *continuous deployment* and *continuous delivery*.
    Many sources differentiate the two terms as to whether the process of deploying
    is automated or manual. In other words, continuous deployment requires automated
    continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The trigger to cause a merge between environments and therefore a build to be
    pushed to an environment, or released, might differ. In our illustration for the
    Development environment, we have a set of automated tests that are run against
    new builds automatically. If the tests are successful, then the merge is automatically
    performed from the Trunk to the UAT code base. The merge between UAT and Production
    code bases is only performed once the QA team has signed off or accepted the changes
    in the UAT environment.
  prefs: []
  type: TYPE_NORMAL
- en: Each enterprise will tailor the CI/CD process to fit their particular SDLC and
    business requirements. A public-facing website, for example, might require a rapid
    SDLC to stay competitive in the market, whereas an internal application might
    require a more conservative approach to limit the disruption caused by changing
    functionality without staff training.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, suites of tools have been developed to manage the CI/CD process
    within an organization. Azure DevOps, for example, helps to manage this process
    by allowing for a pipeline to be built to handle when builds are created and when
    they are released to environments, including both manual and automated triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud development requires careful planning, maintenance, and monitoring, and
    patterns can help achieve highly scalable, reliable, and secure solutions. Many
    of the patterns discussed in this chapter are applicable to on-premises applications
    and are essential in cloud solutions. The design of a cloud-first application
    should consider many factors, including scalability, availability, maintenance,
    monitoring, and security.
  prefs: []
  type: TYPE_NORMAL
- en: A scalable application allows for fluctuations in system load while maintaining
    an acceptable level of performance. The load can be measured in the number of
    users, concurrent processes, amount of data, and other factors in software. The
    ability to scale a solution horizontally requires a particular type of application
    development and is a paradigm that is especially significant to cloud computing.
    Patterns such as Queue-Based Load Leveling are a great technique to ensure solutions
    remain responsive under an increased load.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the patterns covered in this chapter are complementary. For example,
    an application following the Command and Query Responsibility Segregation might
    leverage federated security for providing a single sign-on experience and use
    an event-driven architecture to handle consistency across the different components
    of an application.
  prefs: []
  type: TYPE_NORMAL
- en: In cloud-based solutions, there is a near-endless collection of applicable patterns
    that address different challenges in distributed systems. The patterns presented
    in this chapter represent a selection chosen for their breadth, as well as how
    they complement one another. Please see the references to explore other patterns
    suitable in cloud-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: What a journey! We have covered patterns from software design patterns used
    in object-oriented programming and architectural patterns used in cloud-based
    solutions, to business patterns for more efficient teams and patterns for building
    successful applications. Though we tried to cover a wide range of patterns, there
    are bound to be ones that could have, and should have, been added.
  prefs: []
  type: TYPE_NORMAL
- en: With that, thank you from Gaurav and Jeffrey and we hope you enjoyed and gained
    something from reading *Hands-On Design Patterns with C# and .NET Core*. Please
    let us know what you think and share with us your favorite patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Most patterns have been developed recently and only apply to cloud-based applications.
    True or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An ESB stands for what, and can be used in what type of architecture: EDA,
    SOA or monolithic?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Queue-Based Load Leveling primarily used for DevOps, scalability, or availability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a website following Static Content Hosting, does a browser retrieve images
    and static content directly through a CDN, or does the web application retrieve
    the information on behalf of the browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, refer to the following
    books. These books will provide you with various in-depth and hands-on exercises
    on the topics that have been covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Azure Serverless Computing Cookbook,* by *Praveen Kumar Sreeram,* published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microservices with Azure,* by *Namit Tanasseri* *and Rahul Rai*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Azure for Developers,* by *Kamil Mrzygłód,* published by *Packt Publishing*: [https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Microservices with .NET Core 2.0 - Second Edition* by *Gaurav Aroraa*,
    published by *Packt Publishing*: [https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

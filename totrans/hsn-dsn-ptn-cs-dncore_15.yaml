- en: Coding for the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为云端编码
- en: The previous chapters explored patterns, from lower-level concepts such as the
    Singleton and Factory patterns, to patterns for specific technologies such as
    databases and web applications. These patterns are essential for ensuring the
    good design of a solution to ensure maintainability and efficient implementation.
    These patterns provide a solid foundation that allows applications to be enhanced
    and modified as requirements change and new functionality is added.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节探讨了模式，从较低级别的概念，如单例和工厂模式，到特定技术的模式，如数据库和Web应用程序的模式。这些模式对于确保解决方案的良好设计以确保可维护性和高效实施至关重要。这些模式提供了一个坚实的基础，使应用程序能够在需求变化和添加新功能时得到增强和修改。
- en: This chapter takes a higher-level view of a solution to address concerns involving
    designing implementing solutions that are reliable, scalable, and secure. The
    patterns in this chapter often involve environments that contain multiple applications,
    a repository, and a range of possible infrastructure configurations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从更高层次的视角来看待解决方案，以解决设计实施可靠、可扩展和安全的问题。本章中的模式通常涉及包含多个应用程序、存储库和各种可能的基础设施配置的环境。
- en: The software industry is continually evolving and with the change comes new
    opportunity as well as new challenges. In this chapter, we will look at different
    software patterns for the cloud. Many of these patterns are not new, and existed
    in on-premises environments. As cloud-first solutions are becoming the norm, these
    patterns are even more commonplace due to the ease of implementing solutions that
    do not rely on on-premises infrastructure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业不断发展，随之而来的是新的机遇和新的挑战。在本章中，我们将探讨云端的不同软件模式。这些模式中许多并非新鲜事物，在本地环境中已经存在。随着云优先解决方案变得普遍，这些模式由于实施不依赖本地基础设施的便利性而变得更加普遍。
- en: Cloud-first or cloud-native solutions have been designed to target cloud computing
    resources, while hybrid solutions have been designed to use both cloud computing
    resources as well as resources from a private data center.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 云优先或云原生解决方案旨在针对云计算资源，而混合解决方案则旨在同时使用云计算资源和私人数据中心的资源。
- en: 'This chapter defines five key concerns when building solutions in the cloud:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章定义了在构建云端解决方案时的五个关键考虑因素：
- en: Scalability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Availability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Application design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用设计
- en: DevOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: We will discuss the key concerns and why they are significant to building cloud
    solutions. As the concerns are discussed, different patterns will be described
    that can be applied to address these concerns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这些关键考虑因素以及它们对构建云解决方案的重要性。随着讨论这些问题，将描述不同的模式，以应对这些问题。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any special technical requirements or source code
    as it is primarily theoretical.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何特殊的技术要求或源代码，因为它主要是理论性的。
- en: Key considerations when building solutions in the cloud
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建云端解决方案时的关键考虑因素
- en: Making the decision to move to the cloud comes with its own set of problems
    and challenges. In this section, we will cover five key areas of consideration
    for building cloud-based solutions. While these are not unique to the cloud, they
    require special attention when switching to the cloud due to the wide range of
    technologies and solutions that are available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 决定转移到云端会带来一系列问题和挑战。在本节中，我们将涵盖构建基于云的解决方案的五个关键考虑领域。虽然这些问题并非云端独有，但在转向云端时需要特别关注，因为有各种技术和解决方案可供选择。
- en: 'The five primary considerations are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 五个主要考虑因素如下：
- en: '**Scalability**: This allows for accommodation of increased load or traffic
    for a growing business.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这允许适应不断增长的业务的负载或流量。'
- en: '**Resilience/availability**: This ensures the handling of failures in a system
    gracefully with as little impact on the user as possible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性/可用性**：这确保系统在发生故障时能够优雅地处理，对用户的影响尽可能小。'
- en: '**Security**: This ensures that private and proprietary data stays that way
    and is safe from hacks and attacks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这确保私人和专有数据保持原样，并且免受黑客和攻击的威胁。'
- en: '**Application design**: This refers to the design of applications with special
    consideration for cloud-based solutions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用设计**：这指的是专门考虑云端解决方案的应用设计。'
- en: '**DevOps**: This is a collection of tools and practices that supports the development
    and running of cloud-based solutions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps**：这是一套支持云端解决方案开发和运行的工具和实践集合。'
- en: Depending on your business requirements, you may need to look for solutions
    for some or all of these considerations. It is also in your business's best interest
    to adopt providers with solutions to problems that you don't anticipate but would
    make for good contingency planning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的业务需求，您可能需要寻找一些或所有这些考虑因素的解决方案。对于您的业务来说，采用能够解决您未预料到但会成为良好备用计划的问题的解决方案提供商也是最为有利的。
- en: In the following sections, we will discuss these considerations in further detail
    along with the available solution patterns for them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讨论这些考虑因素以及针对它们的可用解决方案模式。
- en: These patterns range from a type of technology to architectural to business
    processes and a single pattern could address more than one concern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式涵盖了从技术类型到架构和业务流程的各种问题，一个单一模式可能涉及多个问题。
- en: Scalability
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Scalability refers to the ability to allocate and manage resources used by an
    application in order for the application to maintain an acceptable level of quality
    under a given workload. Most cloud offerings provide mechanisms for increasing
    the quality and quantity of resources used by an application. For example, the
    Azure App Service allows scaling of both the size of the App Service and the number
    of instances of the App Service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性指的是为了应用程序在给定的工作负载下保持可接受的质量水平而分配和管理资源的能力。大多数云服务提供机制来增加应用程序使用的资源的质量和数量。例如，Azure应用服务允许扩展应用服务的大小和应用服务的实例数量。
- en: Scalability can be viewed as demand on a limited number of resources. A resource
    could be disk space, RAM, bandwidth, or another aspect of software that can be
    quantified. The demand can range from the number of users, concurrent connections,
    or another demand that would produce a constraint on a resource. As the demand
    increases, a strain is placed on the application in order to provide the resource.
    When the strain affects the performance of the application, this is referred to
    as a resource bottleneck.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性可以被视为对有限资源的需求。资源可以是磁盘空间、RAM、带宽或软件的另一个可以量化的方面。需求可以涵盖用户数量、并发连接数量或会对资源产生约束的其他需求。随着需求的增加，应用程序需要提供资源。当需求影响应用程序的性能时，这被称为资源瓶颈。
- en: For example, a measure might be the number of users that can access an application
    before the performance of the application begins to deteriorate. The performance
    could be set as an average latency on requests being less than 2 seconds. As the
    number of users increases, the load on the system could then be viewed, and specific
    resource bottlenecks affecting the performance could be identified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个度量标准可能是在应用程序性能开始恶化之前可以访问应用程序的用户数量。性能可以设置为请求的平均延迟小于2秒。随着用户数量的增加，可以查看系统的负载，并识别影响性能的特定资源瓶颈。
- en: Workload
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载
- en: 'In order to determine how to effectively address scaling issues, it is important
    to understand the workload that the system will be under. There are four main
    types of workload: static, periodic, once-in-a-lifetime and unpredictable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定如何有效地解决扩展性问题，了解系统将承受的工作负载是很重要的。有四种主要类型的工作负载：静态、周期性、一次性和不可预测的。
- en: A static workload represents a constant level of activity on a system. Because
    the workload does not fluctuate, this type of system does not require a very elastic
    infrastructure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工作负载表示系统上的持续活动水平。由于工作负载不波动，这种类型的系统不需要非常弹性的基础设施。
- en: Systems that have a predictable change in workload have a periodic workload.
    An example would be a system that experiences a surge of activity around the weekends
    or around the months when income tax is due. These systems can be scaled up to
    maintain a desired level of quality when the load increases and scaled down to
    save cost when the load decreases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可预测工作负载变化的系统具有周期性工作负载。例如，系统在周末或应交所得税的月份周围经历活动激增。这些系统可以进行扩展以在负载增加时保持所需的质量水平，并在负载减少时进行缩减以节省成本。
- en: Once-in-a-lifetime workloads indicate systems designed around a specific event.
    These systems are provisioned to handle the workload around the event and deprovisioned
    once they are no longer needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性工作负载表示围绕特定事件设计的系统。这些系统被配置为处理事件周围的工作负载，并在不再需要时取消配置。
- en: Unpredictable workloads often benefit from the auto-scale functionality mentioned
    earlier. These systems have large fluctuations in activity that are either not
    understood by the business yet or are influenced by other factors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不可预测的工作负载通常受益于前面提到的自动扩展功能。这些系统的活动波动很大，要么业务尚未理解，要么受其他因素影响。
- en: Understanding and designing a cloud-based application for its type of workload
    is essential for both maintaining a high level of performance as well as lowering
    costs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和设计基于云的应用程序以适应其工作负载类型对于保持高性能水平和降低成本都至关重要。
- en: Solution patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: 'We have available three design patterns and one architecture pattern to choose
    from to enable us to add scalability to our systems:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种设计模式和一种架构模式可供选择，以使我们的系统具有可扩展性：
- en: Vertical scaling
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Horizontal scaling
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Auto-scaling
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Microservices
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Let's review each in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地审查每一种。
- en: Vertical scaling
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Though it is possible to add physical RAM or an additional disk drive to an
    on-premises server, most cloud providers support the ability to easily increase
    or decrease the computing power of a system. This is often with little or no downtime
    as the system scales. This type of scaling is called vertical scaling and refers
    to when a resource such as the type of CPU, size and quality of RAM, or size and
    quality of the disk is altered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以向本地服务器添加物理RAM或额外的磁盘驱动器，但大多数云提供商支持轻松增加或减少系统的计算能力。这通常是在系统扩展时几乎没有或没有停机时间。这种类型的扩展称为垂直扩展，指的是改变资源，如CPU类型、RAM的大小和质量，或磁盘的大小和质量。
- en: Vertical scaling is often referred to as *scaling up* while horizontal scaling
    is often referred to as *scaling out*. In this context, the term *up* refers to
    the size of the resource while *out* refers to the number of instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展通常被称为“扩展”，而水平扩展通常被称为“扩展”。在这种情况下，“扩展”指的是资源的大小，“扩展”指的是实例的数量。
- en: Horizontal scaling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Horizontal scaling differs from vertical scaling because, instead of altering
    the size of a system, horizontal scaling changes the number of systems involved.
    For example, a web application might run on a single server having 4 GB RAM and
    2 CPUs. If the server was increased in size to 8 GB RAM and 4 CPUs, then this
    would be vertical scaling. However, if two more servers were added with the same
    configuration of 4 GB RAM and 2 CPUs, then this would be horizontal scaling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展与垂直扩展不同，因为水平扩展改变的是系统的数量，而不是系统的大小。例如，Web应用程序可能在一台具有4GB RAM和2个CPU的单个服务器上运行。如果将服务器的大小增加到8GB
    RAM和4个CPU，那么这将是垂直扩展。但是，如果增加了两台具有相同配置的4GB RAM和2个CPU的服务器，那么这将是水平扩展。
- en: 'Horizontal scaling can be achieved by using some form of load balancing that
    redirects the requests across a collection of systems as illustrated in the following
    diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展可以通过使用某种形式的负载平衡来实现，该负载平衡将请求重定向到一组系统，如下图所示：
- en: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
- en: Horizontal scaling is usually preferred in cloud solutions over vertical scaling.
    This is because, in general, it is more cost effective to use several smaller
    virtual machines to a single large server to provide the same measure of performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展通常比垂直扩展更受云解决方案的青睐。这是因为一般来说，使用多个较小的虚拟机来提供相同性能的服务比使用单个大型服务器更具成本效益。
- en: For horizontal scaling to be most effective, it does require a system design
    that supports this type of scaling. For example, web applications designed without
    sticky sessions and/or state stored on the server work better for horizontal scaling.
    This is because sticky sessions cause a user's requests to be routed to the same
    virtual machine for processing and, over time, the balance of the routing across
    the virtual machines could become uneven and therefore not as efficient as possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使水平扩展最有效，确实需要支持这种类型扩展的系统设计。例如，设计时没有粘性会话和/或状态存储在服务器上的Web应用程序更适合水平扩展。这是因为粘性会话会导致用户的请求被路由到同一台虚拟机进行处理，随着时间的推移，虚拟机之间的路由平衡可能变得不均匀，因此效率可能不尽如人意。
- en: Stateful applications
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态应用程序
- en: A *stateful *application maintains information about an active session on the
    server or repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*有状态*应用程序在服务器或存储库上维护有关活动会话的信息。'
- en: Stateless applications
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态应用程序
- en: '*Stateless* applications are designed to not require information about an active
    session to be stored on the server or repository. This allows for subsequent requests
    in a single session to be sent to any server to be handled and not just to the
    same server for the entire session.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*无状态*应用程序设计为不需要在服务器或存储库上存储有关活动会话的信息。这允许将单个会话中的后续请求发送到任何服务器进行处理，而不仅仅是发送到整个会话的同一服务器。'
- en: Web applications designed that are stateful require sessions or information
    to be maintained in a shared repository. Stateless web applications support a
    more resilient pattern as any server in a web garden or web farm. This allows
    for a single node in the web application to fail without losing session information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的Web应用程序需要在共享存储库中维护会话或信息。无状态的Web应用程序支持更具弹性的模式，因为Web garden或Web farm中的任何服务器都可以失败而不会丢失会话信息。
- en: A web *garden* is a pattern where multiple copies of the same web application
    are hosted on the same server, whereas a web *farm* is a pattern where multiple
    copies of the same web application are hosted on different servers. In both patterns,
    routing is used to expose the multiple copies as if they were a single application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Web *garden*是一种模式，其中同一Web应用程序的多个副本托管在同一台服务器上，而Web *farm*是一种模式，其中同一Web应用程序的多个副本托管在不同的服务器上。在这两种模式中，路由用于将多个副本公开为单个应用程序。
- en: Auto-scaling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展
- en: 'An advantage of using a cloud provider over on-premises solutions is the built-in
    support for auto-scaling. As an added benefit to horizontal scaling, the ability
    to auto-scale an application is often a configurable feature of a cloud service.
    For example, an Azure App Service provides the ability to set up auto-scale profiles
    that allow an application to react to conditions. For example, the following screenshot
    shows an auto-scale profile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云提供商而不是本地解决方案的优势是内置的自动扩展支持。作为水平扩展的附加好处，自动扩展应用程序的能力通常是云服务的可配置功能。例如，Azure应用服务提供了设置自动扩展配置文件的功能，允许应用程序对条件做出反应。例如，以下屏幕截图显示了一个自动扩展配置文件：
- en: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
- en: The profile designed for weekdays will increase or decrease the number of app
    service instances depending on the load on the servers. The load is being measured
    in CPU percentage. If the CPU percentage is averages above 60%, then the number
    of instances is increased up to a maximum of 10\. Similarly, if the CPU percentage
    falls below 30%, the number of instances is reduced to a minimum of 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为工作日设计的配置文件将根据服务器负载增加或减少应用服务实例的数量。负载以CPU百分比来衡量。如果CPU百分比平均超过60％，则实例数量增加到最多10个。同样，如果CPU百分比低于30％，实例数量将减少到最少2个。
- en: An elastic infrastructure allows for resources to be scaled vertically or horizontally
    without requiring a re-deploy or downtime. The term is actually more of a degree
    of elasticity instead of referring to whether a system is *elastic* or *not elastic*. For
    example, an elastic service could allow for scaling both vertically and horizontally
    without requiring a restart of the service instances. A less elastic service would
    allow for scaling horizontally without a restart but would require a restart of
    the service when the size of the server is altered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性基础设施允许资源在不需要重新部署或停机的情况下进行垂直或水平扩展。该术语实际上更多地是弹性程度，而不是指系统是否具有*弹性*或*非弹性*。例如，弹性服务可以允许在不需要重新启动服务实例的情况下进行垂直和水平扩展。较不具弹性的服务可以允许在不重新启动的情况下进行水平扩展，但在更改服务器大小时需要重新启动服务。
- en: Microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'There are different interpretations of what microservices means and how it
    relates to **service-oriented architecture** (**SOA**). In this section, we are
    going to view microservices as a refinement of SOA and not a new architectural
    pattern. The microservice architecture extends SOA by adding some additional key
    principles which require that services must:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务的含义以及它与面向服务的架构（SOA）的关系有不同的解释。在本节中，我们将微服务视为SOA的一种完善，而不是一种新的架构模式。微服务架构通过添加一些额外的关键原则来扩展SOA，要求服务必须：
- en: be small - hence the term *micro*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模小 - 因此称为*微*
- en: be built around a business capability
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕业务能力构建
- en: be loosely coupled with other services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他服务松散耦合
- en: be independently maintainable
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立维护
- en: have an isolated state
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有隔离状态
- en: Small
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模小
- en: Microservices takes the services in SOA farther by reducing them to their smallest
    possible size. This fits well with some other patterns that we have seen, such
    as **Keep It Simple Stupid** (**KISS**) and **You Aren't Gonna Need It** (**YAGNI**)
    from [Chapter 2](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml), *Modern Software
    Design Patterns and Principles*. The microservice should only fulfill its requirements
    and nothing more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务将SOA中的服务缩小到最小可能的规模。这与我们之前看到的一些其他模式非常契合，比如《保持简单愚蠢》（KISS）和《你不会需要它》（YAGNI）来自[第2章]，*现代软件设计模式和原则*。微服务应该只满足其要求，而不多做其他事情。
- en: Business capability
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务能力
- en: By building a service around a business capability, we align our implementation
    in such a way that, as the business requirements change, our services will be
    changed in a similar manner. Because of this, it is less likely that change in
    one area of the business will impact other areas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过围绕业务能力构建服务，我们以一种使得当业务需求发生变化时，我们的服务也会以类似的方式进行变更的方式来实现我们的实现。因此，较少可能会导致业务的一个领域的变化影响其他领域。
- en: Loosely coupled
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: A microservice should interact with other services across a service boundary
    using a technology-agnostic protocol such as HTTP. This allows for the microservices
    to be integrated more easily and, more importantly, not require the rebuild of
    a microservice when another service changes. This does require a known *service
    contract* to exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该使用技术无关的协议（如HTTP）跨服务边界与其他服务进行交互。这使得微服务更容易集成，更重要的是，当另一个服务发生变化时，不需要重建微服务。这确实需要存在一个已知的*服务合同*。
- en: Service contract
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务合同
- en: A *service contract* is the definition of a service that is distributed to other
    development teams. **Web Services Description Language** (**WSDL**) is a widely
    known XML-based language for describing services, but other languages, such as
    Swagger, are also very popular.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务合同*是分发给其他开发团队的服务定义。Web服务描述语言（WSDL）是一种广为人知的基于XML的描述服务的语言，但其他语言，如Swagger，也非常流行。'
- en: When implementing a microservice, it is important to have a strategy for how
    the change will be managed. By having a versioned service contract, it is then
    possible to communicate the change clearly to a client of the service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施微服务时，重要的是要有一个管理变更的策略。通过具有版本化的服务合同，可以清晰地向服务的客户传达变更。
- en: 'For example, the strategy of a microservice used to store an inventory of books
    could have the following strategy:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于存储图书库存的微服务的策略可能如下：
- en: Each service will be versioned and include a Swagger definition.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务将被版本化并包括Swagger定义。
- en: Each service will start with version 1.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务将从版本1开始。
- en: When a change is made that requires the service contract to change, the version
    will be increased by 1.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进行需要更改服务合同的更改时，版本将增加1。
- en: The service will maintain up to three versions.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务将维护最多三个版本。
- en: Changes to a service must ensure that all current versions behave suitably.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务的更改必须确保所有当前版本的行为都合适。
- en: The preceding basic strategy does have interesting implications. First of all,
    the team maintaining a service must ensure that changes do not break existing
    services. This ensures a new deployment will not break other services while allowing
    for new functionality to be deployed. The contract does allow for up to three
    services to be active at a time, thus allowing for a dependable service to update
    independently.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的基本策略确实有一些有趣的含义。首先，维护服务的团队必须确保更改不会破坏现有服务。这确保了新部署不会破坏其他服务，同时允许部署新功能。合同允许最多同时有三个服务处于活动状态，因此可以独立更新可靠的服务。
- en: Independently maintainable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以独立维护
- en: This is one of the most distinguishing features of microservices. Having a microservice
    able to be maintained independent of other microservices empowers a business to
    be able to manage the service without impacting other services. By managing a
    service, we are including both the development as well as the deployment of a
    service. With this principle, microservices can be updated and deployed with a
    reduced chance of impacting other services, as well as at a different rate of
    change from other services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务最显著的特点之一。使得一个微服务能够独立于其他微服务进行维护，使得企业能够在不影响其他服务的情况下管理该服务。通过管理服务，我们既包括服务的开发，也包括服务的部署。根据这一原则，微服务可以更新和部署，减少对其他服务的影响，并且以不同的变化速率进行部署。
- en: Isolated state
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离状态
- en: Isolated state includes both data and other resources that could be shared including
    databases and files. This is also a distinguishing feature of microservice architecture.
    By having an independent state, we are reducing the chance that a change in the
    data model to support one service will impact other services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离状态包括数据和其他可能共享的资源，包括数据库和文件。这也是微服务架构的一个显著特点。通过拥有独立的状态，我们减少了支持一个服务的数据模型的变化会影响其他服务的机会。
- en: 'The following diagram illustrates a more traditional SOA approach, where a
    single database is used by multiple services:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了更传统的SOA方法，多个服务使用单个数据库：
- en: '![](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'By requiring a microservice to have an isolated state, we would then require
    a database per service as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: This has an advantage in that each service can choose the technology that best
    fits the requirements of the services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservice architecture does represent a shift from traditional service
    design and it does fit well in a cloud-based solution. The advantages of microservices
    and why they are gaining in popularity might not be immediately obvious. We have
    touched on how the design of microservices provides advantages for handling change
    gracefully. From a technical point of view, microservices can be scaled independently
    both at the service level and at the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: What might not be clear is the benefit a microservice architecture has to a
    business. By having small independent services, the business can then look at
    different ways to maintain and develop microservices. The business now has options
    to host the services in different ways, including different cloud providers, as
    best fits the independent services. Likewise, the isolated nature of the services
    allows for a greater degree of agility in developing the services. As change happens,
    resources (that is, development team members) can be allocated to different services
    as required, and, as the scope of service is smaller, the amount of business knowledge
    required is also reduced.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency/availability
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resiliency is the ability of an application to handle failure gracefully while
    availability is a measure of the amount of time the application is working. An
    application may have a collection of resources and still remain available if one
    of the resources becomes inoperable or unavailable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If an application is designed to handle one or more resources failing without
    the entire system becoming inoperable, this is referred to as **graceful degradation**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Patterns apply to both isolate the elements of an application as well as handle
    the interaction between the elements so that when a failure occurs, the impact
    is limited. Many of the resiliency-related patterns focus on the messaging between
    the components within the application or to other applications. The Bulkhead pattern,
    for example, isolates the traffic into pools so that when one pool becomes overwhelmed
    or fails, the other pools are not adversely affected. Other patterns apply specific
    techniques to handle messaging, such as retry policies or compensating transactions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Availability is an important factor to many cloud-based applications and, typically,
    availability is measured against a **service level agreement** (**SLA**). In most
    cases, the SLA stipulates the percentage of time the application must remain operable.
    Patterns involve both allowing for redundancy of components as well as using techniques
    to limit the effect of an increase in activity. For example, the Queue-Based Load
    Leveling pattern uses a queue to limit the effect a spike in activity might have
    on an application by acting as a buffer between the caller, or client, and the
    application or service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency and availability are identified here as related cloud solution factors
    as often a resilient application allows for a strict SLA on availability to be
    achieved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Solution pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure we have a system that has resilience and availability, our best bet
    is to look for a provider with a specific architecture. Enter **event-driven architecture**
    (**EDA**).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: EDA is an architectural pattern that uses *events* to drive the behavior and
    activity of a system. The solution patterns available under it will help us achieve
    the intended resolutions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: EDA
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EDA promotes the concept of having loosely connected producers and consumers
    where the producers do not have direct knowledge of the consumers. An event in
    this context is any change ranging from a user logging onto a system, to an order
    being placed, to a process failing to complete successfully. EDA fits well in
    distributed systems and allows for highly scalable solutions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many related patterns and approaches to EDA and the following patterns
    are presented in this section as being directly relevant to EDA:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Queue-Based Load Leveling
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publisher Subscriber
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority Queue
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensating Transaction
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue-Based Load Leveling
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queue-Based Load Leveling is an effective way of minimizing the impact of occurrences
    of high demand on availability. By introducing a queue between a client and service,
    we are able to throttle or restrict the number of requests that are being handled
    by the service at a time. This allows for smoother user experience. Take the following
    diagram as an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows a client submitting a request to a queue to be processed
    and the result saved to a table. The queue acts to prevent the function from being
    overwhelmed by a sudden spike in activity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Publisher Subscriber
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Publisher Subscriber pattern states that there are event publishers and
    event consumers. Essentially, this is the heart of EDA, as the publishers are
    decoupled from the consumers and are not concerned about the delivery of events
    to the consumers, but only with publishing events. The event will contain information
    that will be used to route the event to interested consumers. A consumer would
    then register or subscribe to being interested in specific events:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram illustrates a Customer Service and an Order Service. The
    Customer Service acts as a publisher and submits an event when a customer is added.
    The Order Service has subscribed to new customer events. When a new customer event
    is received, the Order Service inserts the customer information into its local
    store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: By introducing the Publisher Subscriber pattern into the architecture, the Order
    Service is then decoupled from the Customer Service. An advantage of this is it
    provides a more flexible architecture for change. For example, a new service could
    be introduced to add new customers to the solutions that do not require being
    added to the same repository used by the Customer Service. Also, more than one
    service could subscribe to the new customer event. Adding a welcome email could
    more easily be added as a new subscriber, rather than having to build this functionality
    into a single monolithic solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Priority Queue
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another related pattern is Priority Queue, which provides a mechanism for treating
    similar events differently. Using the new customer example from the previous section,
    it would be possible to have two subscribers for a new customer event. One subscriber
    would be interested in the majority of the new customers, while one subscriber
    would identify a subset of the customers that should be handled differently. For
    example, new subscribers from rural areas might receive an email with additional
    information about specialized shipping providers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Compensating transaction
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With distributed systems, it is not always practical or desirable to issue
    a command as a transaction. A transaction in this context refers to a lower-level
    programming construct that manages one or more commands as a single action that
    either all succeeds or all fails. In some situations, a distributed transaction
    is not supported, or the overhead of using a distributed transaction outweighs
    the benefits. The Compensating Transaction pattern was developed to handle this
    situation. Let''s use the following as an example based on a BizTalk orchestration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'The diagram shows two steps in a process: creating order in an Order Service
    and debiting funds from a Customer Service. The diagram shows how, first the order
    is created and then the funds are removed. If the debit of funds does not succeed
    then the order is removed from the Order Service.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security ensures an application does not disclose information incorrectly or
    provide functionality outside of intended use. Security includes both malicious
    and accidental actions. With cloud applications and increasing use of a wide range
    of identity providers, restricting access to only approved users is often challenging.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: End-user authentication and authorization requires design and planning as fewer
    applications run in isolation, and it is common for multiple identity providers,
    such as Facebook, Google, and Microsoft, to be used. In some instances, patterns
    are used to provide access directly to resources for improved performance and
    scalability. Furthermore, other patterns are concerned with creating a virtual
    wall between clients and applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the industry has become more interconnected, the pattern of using an external
    party to authenticate users has become more common. The Federated Security pattern
    has been chosen for discussion here as it is one of the best ways to ensure security
    in our systems, and most **software-as-a-service (SaaS)** platforms offer this
    feature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Federated security
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Federated security delegates the authentication of user or service (consumer)
    to an external party known as an **identity provider** (**IdP**). An application
    using federated security will trust the IdP to properly authenticate the consumer
    and provide details about the consumer or claims accurately. This information
    about the consumer is presented as a token. A common scenario for this would be
    a web application using a social IdP such as Google, Facebook, or Microsoft.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Federated security can handle a variety of scenarios, from interactive sessions
    to authentication backend services or non-interactive sessions. Another common
    scenario is the ability to provide a single authentication experience or **single
    sign-on** (**SSO**) across a suite of separately hosted applications. This scenario
    allows for a single token to be acquired from a **security token service** (**STS**)
    and the same token used to present to the multiple applications without requiring
    the login procedure to be repeated:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Federated security has two main purposes. First, it simplifies the management
    of identities by having a single identity store. This allows for identities to
    be managed in a central and unified manner, making it easier to perform management
    tasks such as providing the login experience, forgotten password management, as
    well as revoking passwords in a consistent manner. Secondly, it provides a better
    user experience by offering users a similar experience across multiple applications
    as well as requiring only a single form of authentication, instead of needing
    to remember multiple passwords.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: There are several standards for federated security and two widely used ones
    are **Security Assertion Markup Language** (**SAML**) and **OpenId Connect** (**OIDC**).
    SAML is older than OIDC and allows for the exchange of messages using an XML SAML
    format. OIDC is built upon OAuth 2.0 and commonly uses **JSON Web Token** (**JWT**)
    for describing the security token. Both formats support federated security, SSO,
    and many public IdPs such as Facebook, Google, and Microsoft support both standards.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Application design
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design of an application can vary significantly and be influenced by many
    factors. These factors are not only technical but are influenced by the teams
    involved in building, managing, and maintaining the applications. Some patterns,
    for example, work best with small dedicated teams as opposed to a larger number
    of geographically dispersed teams. Other design-related patterns handle different
    types of workload better and are used in specific scenarios. Other patterns have
    been designed around the frequency of change and how to limit the disruption of
    changes to an application once it has been released to users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As almost all on-premises patterns are applicable to cloud-based solutions,
    the scope of patterns that could be covered is staggering. The Cache and CQRS
    patterns have been chosen because the former is a very common pattern employed
    by most web applications and the latter shifts how designers think of building
    solutions and lends itself well to other architectural patterns such as SOA and
    microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing information retrieved from slower forms of storage into faster forms
    of storage, or caching, has been a technique that has been used in programming
    for decades and can be seen in software such as a browser cache and hardware such
    as RAM. In this chapter, we will look at three examples: Cache-aside, Write-through
    Cache, and Static Content Hosting.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Cache-aside
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Cache-aside pattern can be used to improve performance by loading frequently
    referenced data in a local or faster form of storage. With this pattern, it is
    the responsibility of the application to maintain the state of the cache. This
    is illustrated in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: First, the application requests information from the cache. If the information
    is missing, then it is requested from the data store. The application then updates
    the cache with the information. Once the information is stored, it will then be
    retrieved from the cache and used without referencing the slower data store. With
    this pattern, it is the application's responsibility to maintain the cache, both
    when there is a cache miss, and when the data is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The term *cache miss* refers to when data is not found in the cache. In other
    words, it is missing from the cache.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Write-through cache
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Write-through Cache pattern can also be used to improve performance in
    a similar manner as the Cache-aside pattern. Its approach differs by moving the
    management of the cache''s content from the application to the cache itself, as
    shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: A request is made for a piece of information in the cache. If the data is not
    already loaded, then the information is retrieved from the data store, placed
    in the cache, and then returned. If the data was already held, then it is immediately
    returned. This pattern supports updating the cache by passing the write of the
    information through the cache service. The cache service then updates the information
    held, both in the cache and in the data store.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Static Content Hosting
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Static Content Hosting pattern moves static content such as media images,
    movies, and other non-dynamic files to a system dedicated for fast retrieval.
    A specialized service for this is called a **content delivery network** (**CDN**),
    which manages to distribute content across multiple data centers and directs requests
    to the data center closest to the caller, as shown in the following diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Static Content Hosting is a common pattern for web applications where a dynamic
    page is requested from the web application and the page contains a collection
    of static content, such as JavaScript and images, which the browser then retrieves
    directly from the CDN. This is an effective way to reduce the traffic on the web
    application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Command and Query Responsibility Segregation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is a great software
    pattern to discuss in more detail as it is conceptually simple and relatively
    easy to implement but has dramatic implications to both the application and the
    developers involved. The pattern clearly separates the commands that affect the
    state of the application from queries that only retrieve data. Simply put, commands
    such as updates, adds, and deletes are provided in different services from the
    queries that do not change any data.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: You might say *CQRS again!* and we recognize that we have used an example of
    CQRS in OOP and database design. The same principle does apply to many areas of
    software development. We are presenting CQRS in this section as a pattern for
    service design as it leads to some interesting benefits and fits well in modern
    patterns such as microservices and reactive application design.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: CQRS is based on the object-oriented design presented in the late 1980s by Bertrand
    Meyer's book, *Object-Oriented Software Construction*: [http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If we revisit [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml): *Implementing
    Design Patterns - .NET Core*, we illustrated this pattern by splitting our inventory
    context into two interfaces: `IInventoryReadContext` and `IInventoryWriteContext`.
    As a reminder, here are the interfaces:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the `GetBooks` method is separated from the two methods, `AddBook`
    and `UpdateQuantity`, that modify the state of the inventory. This illustrated
    CQRS within the code solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The same approach can be applied at a service level. If we use a service for
    maintaining inventory as an example, we would break the service between a service
    for updating the inventory and another service for retrieving the inventory. This
    is illustrates in the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Let's explore CQRS first by looking at the challenges of when it is applied
    in cloud-based solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of CQRS
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are significant challenges to using the CQRS pattern with services:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staleness is a measure of how closely data reflects the committed version of
    the data. Data, in most circumstances, has the potential to change, so, as soon
    as a piece of data is read, there is a chance that the data could be updated,
    making the read data become inconsistent with the source data. This is a challenge
    with all distributed systems where it is not practical to guarantee the value
    shown to a user reflects the source value. When the data directly reflects what
    is stored, we can call the data consistent; when the data does not, it is viewed
    as inconsistent.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A common term used in distributed systems is *eventual consistency*. Eventual
    consistency is used to say a system will over time become consistent. In other
    words, it will eventually become consistent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The other more subtle challenge is adoption. Implementing CQRS into an established
    development team can be met with resistance both from developers and designers
    who are unfamiliar with the pattern and may lack support from the business for
    deviating from current design patterns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: So what are the benefits?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Why CQRS?
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are three compelling factors for using CQRS:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaboration**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model separation**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent scalability**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With separate services, we can then maintain, deploy, and scale these services
    independently. This increases the level of collaboration we can achieve between
    the development teams.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: By having separate services, we can use a model that best fits our service.
    The command service might use simple SQL statements directly against a database,
    as that is the most familiar technology to the team responsible, while the team
    building the query service might use a framework for handling complex statements
    against the database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Most solutions tend to have a higher level of reads than writes (or vice versa)
    so splitting the services along this criterion makes sense in many scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With cloud-based solutions, the data center is remotely hosted and you often
    do not have full control or access to all aspects of an application. In some cases,
    such as serverless services, the infrastructure is abstracted away. An application
    must still expose information about a running application that can be used to
    manage and monitor an application. Patterns used to manage and monitor are essential
    for the success of an application by providing both the ability to keep an application
    running healthily as well as providing strategic information to the business.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Solution patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the availability of commercial packages relating to monitoring and managing
    solutions, many businesses have gained better control and understanding of their
    distributed systems. Telemetry and continuous delivery/continuous integration
    have been chosen to cover in more detail as they have particular value in cloud-based
    solutions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Telemetry
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the software industry has evolved and distributed systems involve more services
    and applications, being able to have a collective and consistent view of a system
    has become a huge asset. Popularized by services such as New Relic and Microsoft
    Application Insights, **application performance management** (**APM**) systems
    use information recorded about applications and infrastructure, known as telemetry,
    to monitor, manage performance, and view the availability of a system. In cloud-based
    solutions, where it is often not possible or practical to gain direct access to
    the infrastructure of a system, an APM allows for telemetry to be sent to a central
    service, digested, and then presented to operations and the business, as shown
    in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is taken from Microsoft Application Insights and provides
    a high-level snapshot of a running web application. At a glance, operations can
    identify changes in the behavior of the system and react accordingly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration/continuous deployment
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration/continuous deployment** (**CI/CD**) is a modern development
    process designed to streamline the **software delivery product life cycle** (**SDLC**)
    by merging changes frequently and deploying those changes often. CI addresses
    the issues that arise in enterprise software development where multiple programmers
    are working on the same code base or when a single product is managed with multiple
    code branches.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, there are three target environments: Development,
    **User Acceptance Testing** (**UAT**), and Production. The Development environment
    is the initial environment where all the changes made to an application are tested
    together. The UAT environment is used by the **Quality Assurance** (**QA**) team
    to verify the system is working as intended before the changes are moved to a
    customer-facing environment, referred to in the diagram as Production. The code
    base has been broken into three matching branches: the trunk which all changes
    by the development team are merged into, UAT, which is used to deploy to the UAT
    environment, and the Production code base, which is used to deploy into the Production
    environment.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The CI pattern is applied by creating a new build when the code base changes.
    After a successful build, a suite of unit tests is run against the build to ensure
    existing functionality has not been broken. If a build is not successful, the
    development team investigates and either fixes the code base or the unit test
    so the build then passes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Successful builds are then pushed to a target environment. The Trunk might be
    set to push a new build automatically once a day to the Integration environment,
    while the QA team has requested less disturbance in the environment, so a new
    build is only pushed once a week after office hours. Production might require
    a manual trigger to coordinate new releases as to announce the new features and
    bug fixes in a formal release.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: There is confusion over the terms *continuous deployment* and *continuous delivery*.
    Many sources differentiate the two terms as to whether the process of deploying
    is automated or manual. In other words, continuous deployment requires automated
    continuous delivery.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The trigger to cause a merge between environments and therefore a build to be
    pushed to an environment, or released, might differ. In our illustration for the
    Development environment, we have a set of automated tests that are run against
    new builds automatically. If the tests are successful, then the merge is automatically
    performed from the Trunk to the UAT code base. The merge between UAT and Production
    code bases is only performed once the QA team has signed off or accepted the changes
    in the UAT environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Each enterprise will tailor the CI/CD process to fit their particular SDLC and
    business requirements. A public-facing website, for example, might require a rapid
    SDLC to stay competitive in the market, whereas an internal application might
    require a more conservative approach to limit the disruption caused by changing
    functionality without staff training.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, suites of tools have been developed to manage the CI/CD process
    within an organization. Azure DevOps, for example, helps to manage this process
    by allowing for a pipeline to be built to handle when builds are created and when
    they are released to environments, including both manual and automated triggers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud development requires careful planning, maintenance, and monitoring, and
    patterns can help achieve highly scalable, reliable, and secure solutions. Many
    of the patterns discussed in this chapter are applicable to on-premises applications
    and are essential in cloud solutions. The design of a cloud-first application
    should consider many factors, including scalability, availability, maintenance,
    monitoring, and security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A scalable application allows for fluctuations in system load while maintaining
    an acceptable level of performance. The load can be measured in the number of
    users, concurrent processes, amount of data, and other factors in software. The
    ability to scale a solution horizontally requires a particular type of application
    development and is a paradigm that is especially significant to cloud computing.
    Patterns such as Queue-Based Load Leveling are a great technique to ensure solutions
    remain responsive under an increased load.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Many of the patterns covered in this chapter are complementary. For example,
    an application following the Command and Query Responsibility Segregation might
    leverage federated security for providing a single sign-on experience and use
    an event-driven architecture to handle consistency across the different components
    of an application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In cloud-based solutions, there is a near-endless collection of applicable patterns
    that address different challenges in distributed systems. The patterns presented
    in this chapter represent a selection chosen for their breadth, as well as how
    they complement one another. Please see the references to explore other patterns
    suitable in cloud-based solutions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: What a journey! We have covered patterns from software design patterns used
    in object-oriented programming and architectural patterns used in cloud-based
    solutions, to business patterns for more efficient teams and patterns for building
    successful applications. Though we tried to cover a wide range of patterns, there
    are bound to be ones that could have, and should have, been added.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: With that, thank you from Gaurav and Jeffrey and we hope you enjoyed and gained
    something from reading *Hands-On Design Patterns with C# and .NET Core*. Please
    let us know what you think and share with us your favorite patterns.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Most patterns have been developed recently and only apply to cloud-based applications.
    True or false?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An ESB stands for what, and can be used in what type of architecture: EDA,
    SOA or monolithic?'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is Queue-Based Load Leveling primarily used for DevOps, scalability, or availability?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a website following Static Content Hosting, does a browser retrieve images
    and static content directly through a CDN, or does the web application retrieve
    the information on behalf of the browser?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, refer to the following
    books. These books will provide you with various in-depth and hands-on exercises
    on the topics that have been covered in this chapter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*Azure Serverless Computing Cookbook,* by *Praveen Kumar Sreeram,* published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microservices with Azure,* by *Namit Tanasseri* *and Rahul Rai*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Azure for Developers,* by *Kamil Mrzygłód,* published by *Packt Publishing*: [https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Microservices with .NET Core 2.0 - Second Edition* by *Gaurav Aroraa*,
    published by *Packt Publishing*: [https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: Miscellaneous Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book so far, we have discussed various patterns, styles, and code. During
    this discussion, our aim was to understand the patterns and practices to write
    neat, clean, and robust code. This appendix will mainly focus on practices. The
    practice is very important when it comes to adhering to any rule or any kind of
    coding style. As a developer, you should rehearse coding on a daily basis. According
    to the old proverb, *practice makes man perfect*.
  prefs: []
  type: TYPE_NORMAL
- en: This is shown through the fact that skills such as playing a game, driving a
    car, reading, or writing do not come instantly. Instead, we should perfect these
    skills over time and with practice. For example, when you start driving, you start
    it slowly. There, you need to remember when to press the clutch, when to press
    the brake, how far they need to turn the steering wheel, and so on. However, once
    the driver is well acquainted with driving, then there is no need to remember
    these steps; they come naturally. This is because of practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this appendix, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Use case discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix contains various code examples to explain the concepts covered.
    The code is kept simple and is just for demo purposes. Most of the examples in
    this chapter involve a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, there are these prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (however, you can also run application using Visual Studio
    2017)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the code examples included in this chapter, you need to install Visual
    Studio or later. To do so, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Visual Studio from the following download link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple versions are available for Visual Studio. We are using Visual Studio
    for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The example code files for the chapter is available at the following link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Appendix](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Appendix).'
  prefs: []
  type: TYPE_NORMAL
- en: Use case discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Put simply, a use case is a pre-creation or a symbolic representation of a
    business scenario. For example, we can represent our login page use case in a
    pictorial/symbolic representation. In our example, users are trying to log into
    a system. If the login succeeds, they can enter the system. If it fails, the system
    informs the users that the login attempt failed. Refer to the following diagram
    of a **login** use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8594ebb-7aa1-4044-8605-a1fb0732da21.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, users called **User1**, **User2**, and **User3** are
    trying to enter the system using the login functionality of the application. If
    the login attempt is successful, the user can access the system. If not, the application
    notifies the user that login wasn't successful and the user can't access the system.
    The preceding diagram is much clearer than our actual verbose description, where
    we are describing this diagram. The diagram is also self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: UML diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed the login functionality with the help
    of symbolic representation. You might have noticed the symbols that are used in
    the diagram. The notations or symbols used in the previous diagram are part of
    a symbolic language called **Unified Modeling Language**. This is a way of visualizing
    our program, software, or even a class.
  prefs: []
  type: TYPE_NORMAL
- en: The symbol or notation used in the UML has evolved from the work of Grady Booch,
    James Rumbaugh, Ivar Jacobson, and the Rational Software Corporation.
  prefs: []
  type: TYPE_NORMAL
- en: Types of UML diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These diagrams are divided into two main groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural UML Diagrams**: These emphasize the things that must be present
    in the system being modeled. This group is further divided into the following
    different types of diagrams:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite structure diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral UML Diagrams**: These are used to show the functionality of the
    system and include use case, sequence, collaboration, state machine, and activity
    diagrams. This group is further divided into the following different types of
    diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction overview diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have established, practice is a habit that occurs in our daily activities.
    In software engineering—where software is engineered and not manufactured—we have
    to practice in order to write good quality code. There may be more points that
    explain the best practices involved in software engineering. Let''s discuss them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Short but simplified code**: This is a very basic thing that does require
    practice. Developers should use short but simplified code daily in order to write
    concise code and adhere to this practice in their daily life. The code should
    be clean and not repeat itself. Clean code and code simplification was covered
    in previous chapters; if you missed this topic, please revisit [Chapter](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml)
    [2](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml), *Modern Software Design Patterns
    and Principles*. Take a look at the following example of concise code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet contains a `Math` class with three `Add` methods.
    These methods are written to calculate the sum of two integer numbers and the
    sum of two float and decimal numbers. The `Add(float a, float b)` and `Add(decimal
    a, decimal b)` methods are the overloaded methods of `Add (int a, int b)`. The
    previous code example represents a scenario where the requirements are to make
    a single method with a output of the int, float, or decimal datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: This is an integral part of development when we want to test
    our code by writing code. **Test-driven development** (**TDD**) is one of the
    best practices that one should adhere to. We have discussed TDD in [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml),
    *Implementing Design Patterns for Web Applications - Part 2*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code consistency**: Nowadays, there are very rare opportunities for a developer
    to work alone. A developer mostly works in a team, meaning that it is very important
    for there to be code consistency throughout the team. Code consistency can refer
    to code style. There are a few recommended practices and coding conversions that
    developers should use regularly while writing programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many ways to declare a variable. Here is one of the best examples
    for variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we have declared a `math` variable of the `BestPractices.Math` type. Here, `BestPractices`
    is our namespace and `Math` is the class. If we are not taking `using` directives
    in the code then it's good practice to have fully namespace qualified variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Official docs for the C# language describe these conventions very elaborately.
    You can refer to them here: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reviews**: Making mistakes is human nature, and this also happens in
    development. Code review is the first step in practicing writing bug-free code
    and uncovering the unpredictable mistakes in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered various design patterns and principles including the
    best practices to write code. This section will summarize the following patterns
    and guide you to write quality and robust code. The details and implementation
    of these patterns are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already covered the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: GoF patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software development life cycle patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we have covered a lot of topics and developed a sample application
    (console and web). This is not the end of the world, there are more things to
    learn in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list more patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Space-based architectural pattern**: **Space-based Pattern** (**SBP**s) are
    patterns that help with application scalability by minimizing the factors that
    limit application scaling. These patterns are also known as **cloud architecture
    patterns**. We have covered many of them in [Chapter 12](002c9eec-cbca-4771-b5b0-45048acaa489.xhtml), *Coding
    for the Cloud*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messaging patterns**: These patterns are used to connect two applications
    based on messaging (sent in the form of packets). These packets or messages are
    transmitting using a logical path on which various applications connect (these
    logical paths are known as channels). There might be scenarios where one application
    has multiple messages; in that case, not all messages can be sent at once. In
    a scenario where there are multiple messages, a channel can be called a queue
    and several messages can be queued up in a channel and can be accessed from various
    applications at the same point in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional patterns for Domain-Driven Design—layered architecture:** This
    depicts separation of concerns, where the concept of layered architecture comes
    in. Behind the scenes, the basic idea for developing an application is that it
    should be structured into conceptual layers. In general, applications have four
    conceptual layers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface**: This layer has everything where the end user interacts,
    this layer accepts the commands and then provides the information accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: This layer is more towards transaction management, data
    translation, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain layer**: This layer sticks to behavior and the state of the domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure layer**: Everything happens here related to repositories,
    adapters, and frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerized application patterns**: Before we dig into this, we should
    know what containers are. A container is lightweight, portable software; it defines
    an environment under which software can run. Generally, software that is running
    inside the container is designed as a single-purpose application. For containerized
    applications the most important pattern is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker image building patterns**: This pattern is based on the Builder pattern
    from GoF design patterns, which we discussed in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns-Basics Part 1*. It only describes the setup so that
    it can be used to build a container. In addition to this, there is a multi-stage
    image building pattern that provides a way to build multiple images from a single
    Dockerfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of this appendix was to highlight the importance of practice. In this
    chapter, we discussed how we can practice enhancing our skills. Once we achieve
    the skills, there is no need to remember the steps to achieve a specific task.
    We covered and discussed a few use cases from the real world, discussed best practices
    from our day-to-day code, and other design patterns that can be used in our daily
    practice to enhance our skills. Finally, we wrapped up the last chapter of this
    book and learned that with practice and the adaptation of various patterns, developers
    can improve their code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: What is practice? Take a few examples from our routine and daily life.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can achieve a specific coding skill with practice. Explain this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is test-driven development and how does it helps developers to practice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have almost reached the end of this book! In this appendix, we have covered
    a lot of things related to practice. This is not the end of learning but it is
    just a beginning, there are more books you can refer to for your learning and
    knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hands-On Domain-Driven Design with .NET Core* by *Alexey Zimarev*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/application-development/hands-domain-driven-design-net-core](https://www.packtpub.com/in/application-development/hands-domain-driven-design-net-core).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# and .NET Core Test-Driven Development* by *Ayobami Adewole*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/application-development/c-and-net-core-test-driven-development](https://www.packtpub.com/in/application-development/c-and-net-core-test-driven-development).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Architectural Patterns*, by *Pethuru Raj, Harihara Subramanian, et al*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/application-development/architectural-patterns](https://www.packtpub.com/in/application-development/architectural-patterns).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrent Patterns and Best Practices*, by *Atul S. Khot*, published by *Packt
    Publishing*: [https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

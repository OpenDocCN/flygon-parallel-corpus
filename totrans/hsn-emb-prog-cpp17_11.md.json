["```cpp\n#include \"base_module.h\"\nclass THPModule {\n    public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n};\n#include \"thp_module.h\"\n#include \"dht_module.h\"\n#include \"bme280_module.h\"\nbool THPModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_TEMPERATURE_HUMIDITY, \n    THPModule::start, THPModule::shutdown);\n    return true;\n}\nbool THPModule::start() {\n    BME280Module::init();\n    return true;\n}\nbool THPModule::shutdown() {\n    BME280Module::shutdown();\n    return true;\n}\n```", "```cpp\n#include \"ota_core.h\"\n\n #include <Libraries/DHTesp/DHTesp.h>\n\n #define DHT_PIN 5 // DHT sensor: GPIO5 ('D1' on NodeMCU)\n\n class DHTModule {\n    static DHTesp* dht;\n    static int dhtPin;\n    static Timer dhtTimer;\n\n public:\n    static bool init();\n    static bool shutdown();\n    static void config(String cmd);\n    static void readDHT();\n };\n```", "```cpp\n#include \"dht_module.h\"\n\n DHTesp* DHTModule::dht = 0;\n int DHTModule::dhtPin = DHT_PIN;\n Timer DHTModule::dhtTimer;\n\n bool DHTModule::init() {\n    if (!OtaCore::claimPin(dhtPin)) { return false; }\n    if (!dht) { dht = new DHTesp(); dht->setup(dhtPin, DHTesp::DHT22); }\n    dhtTimer.initializeMs(2000, DHTModule::readDHT).start();    \n    return true;\n }\n```", "```cpp\nbool DHTModule::shutdown() {\n    dhtTimer.stop();\n    if (!OtaCore::releasePin((ESP8266_pins) dhtPin)) { delete dht; return false; }\n    delete dht;\n    dht = 0;    \n    return true;\n }\n```", "```cpp\n\n void DHTModule::config(String cmd) {\n    Vector<String> output;\n    int numToken = splitString(cmd, '=', output);\n    if (output[0] == \"set_pin\" && numToken > 1) {\n          dhtPin = output[1].toInt();\n    }\n }\n```", "```cpp\n void DHTModule::readDHT() {\n    TempAndHumidity th;\n    th = dht->getTempAndHumidity();\n\n    OtaCore::publish(\"nsa/temperature\", OtaCore::getLocation() + \";\" + th.temperature);\n    OtaCore::publish(\"nsa/humidity\", OtaCore::getLocation() + \";\" + th.humidity);\n }\n```", "```cpp\n#include \"ota_core.h\"\n\n #include <Libraries/BME280/BME280.h>\n\n class BME280Module {\n    static BME280* bme280;\n    static Timer timer;\n\n public:\n    static bool init();\n    static bool shutdown();\n    static void config(String cmd);\n    static void readSensor();\n };\n```", "```cpp\n#include \"bme280_module.h\"\n\n BME280* BME280Module::bme280 = 0;\n Timer BME280Module::timer;\n\n bool BME280Module::init() {\n    if (!OtaCore::starti2c()) { return false; }\n    if (!bme280) { bme280 = new BME280(); }\n\n    if (bme280->EnsureConnected()) {\n          OtaCore::log(LOG_INFO, \"Connected to BME280 sensor.\");\n          bme280->SoftReset();\n          bme280->Initialize();\n    }\n    else {\n          OtaCore::log(LOG_ERROR, \"Not connected to BME280 sensor.\");\n          return false;\n    }\n\n    timer.initializeMs(2000, BME280Module::readSensor).start();\n\n    return true;\n }\n\n bool BME280Module::shutdown() {\n    timer.stop();\n    delete bme280;\n    bme280 = 0;\n\n    return true;\n }\n\n void BME280Module::config(String cmd) {\n    Vector<String> output;\n    int numToken = splitString(cmd, '=', output);\n    if (output[0] == \"set_pin\" && numToken > 1) {\n          //\n    }\n }\n\n void BME280Module::readSensor() {\n    float t, h, p;\n    if (bme280->IsConnected) {\n          t = bme280->GetTemperature();\n          h = bme280->GetHumidity();\n          p = bme280->GetPressure\n          OtaCore::publish(\"nsa/temperature\", OtaCore::getLocation() + \";\" + t);\n          OtaCore::publish(\"nsa/humidity\", OtaCore::getLocation() + \";\" + h);\n          OtaCore::publish(\"nsa/pressure\", OtaCore::getLocation() + \";\" + p);\n    }\n    else {\n          OtaCore::log(LOG_ERROR, \"Disconnected from BME280 sensor.\");\n    }\n }\n\n```", "```cpp\n#include \"base_module.h\"\n\n class CO2Module {\n    static Timer timer;\n    static uint8_t readCmd[9];\n    static uint8 eventLevel;\n    static uint8 eventCountDown;\n    static uint8 eventCountUp;\n\n    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void readCO2();\n    static void config(String cmd);\n };\n```", "```cpp\n#include \"CO2_module.h\"\n\n Timer CO2Module::timer;\n uint8_t CO2Module::readCmd[9] = { 0xFF,0x01,0x86,0x00,0x00,0x00,0x00,0x00,0x79};\n uint8 CO2Module::eventLevel = 0;\n uint8 CO2Module::eventCountDown = 10;\n uint8 CO2Module::eventCountUp = 0;\n\n```", "```cpp\nbool CO2Module::initialize() {\n    BaseModule::registerModule(MOD_IDX_CO2, CO2Module::start, CO2Module::shutdown);\n    return true;\n }\n\n bool CO2Module::start() {\n    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; }\n    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; }\n\n    Serial.end();\n    delay(10);\n    Serial.begin(9600);\n    Serial.setCallback(&CO2Module::onSerialReceived);\n\n    timer.initializeMs(30000, CO2Module::readCO2).start();\n    return true;\n }\n```", "```cpp\nbool CO2Module::shutdown() {\n    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; }\n    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; }\n\n    timer.stop();\n    Serial.end();\n    return true;\n }\n\n void CO2Module::readCO2() {\n    Serial.write(readCmd, 9);\n }\n```", "```cpp\n void CO2Module::config(String cmd) {\n    Vector<String> output;\n    int numToken = splitString(cmd, '=', output);\n    if (output[0] == \"event\" && numToken > 1) {\n          // \n    }\n }\n\n```", "```cpp\nvoid CO2Module::onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount) {\n    if (availableCharsCount >= 9) {\n          char buff[9];\n          Serial.readBytes(buff, 9);\n\n          int responseHigh = (int) buff[2];\n          int responseLow = (int) buff[3];\n          int ppm = (responseHigh * 0xFF) + responseLow;\n          String response = OtaCore::getLocation() + \";\" + ppm;\n          OtaCore::publish(\"nsa/CO2\", response);\n\n          if (ppm > 1000) { // T3\n                if (eventLevel < 2 && eventCountUp < 10) {\n                      if (++eventCountUp == 10) {\n                            eventLevel = 2;\n                            eventCountDown = 0;\n                            eventCountUp = 0;\n                            response = OtaCore::getLocation() + \";\" + eventLevel + \";1;\" + ppm;\n                            OtaCore::publish(\"nsa/events/CO2\", response);\n                      }\n                }\n          }\n          else if (ppm > 850) { // T2\n                if (eventLevel == 0 && eventCountUp < 10) {\n                      if (++eventCountUp == 10) {\n                            eventLevel = 1;\n                            eventCountDown = 0;\n                            eventCountUp = 0;\n                            response = OtaCore::getLocation() + \";\" + eventLevel + \";1;\" + ppm;\n                            OtaCore::publish(\"nsa/events/CO2\", response);\n                      }\n                }\n                else if (eventLevel == 2 && eventCountDown < 10) {\n                      if (++eventCountDown == 10) {\n                            eventLevel = 1;\n                            eventCountUp = 0;\n                            eventCountDown = 0;\n                            response = OtaCore::getLocation() + \";\" + eventLevel + \";0;\" + ppm;\n                            OtaCore::publish(\"nsa/events/CO2\", response);\n                      }\n                }\n          }\n          else if (ppm < 750) { // T1\n                if (eventLevel == 1 && eventCountDown < 10) {\n                      if (++eventCountDown == 10) {\n                            eventLevel = 0;\n                            eventCountDown = 0;\n                            eventCountUp = 0;\n                            response = OtaCore::getLocation() + \";\" + eventLevel + \";0;\" + ppm;\n                            OtaCore::publish(\"nsa/events/CO2\", response);\n                      }\n                }\n          }\n    }\n }\n```", "```cpp\nchar getCheckSum(char* packet) { \n    char i, checksum; \n    for ( i = 1; i < 8; i++) { \n        checksum += packet[i]; \n    } \n\n    checksum = 0xff \u2013 checksum; \n    checksum += 1; \n    return checksum; \n}\n```", "```cpp\n#include \"base_module.h\"\n\n class JuraModule {\n    static String mqttTxBuffer;\n    static Timer timer;\n\n    static bool toCoffeemaker(String cmd);\n    static void readStatistics();\n    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n };\n```", "```cpp\n#include \"jura_module.h\"\n #include <stdlib.h>\n Timer JuraModule::timer;\n String JuraModule::mqttTxBuffer;\n bool JuraModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_JURA, JuraModule::start, JuraModule::shutdown);\n }\n bool JuraModule::start() {\n    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; }\n    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; }\n    Serial.end();\n    delay(10);\n    Serial.begin(9600);\n    Serial.setCallback(&JuraModule::onSerialReceived);\n    timer.initializeMs(60000, JuraModule::readStatistics).start();\n    return true;\n }\n```", "```cpp\nbool JuraModule::shutdown() {\n    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; } // RX 0\n    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; } // TX 0\n    timer.stop();\n    Serial.end();\n    return true;\n }\n void JuraModule::readStatistics() {\n    String message = \"RT:0000\";\n    JuraModule::toCoffeemaker(message);\n }\n```", "```cpp\nbool JuraModule::toCoffeemaker(String cmd) {\n    OtaCore::log(LOG_DEBUG, \"Sending command: \" + cmd);\n    cmd += \"\\r\\n\";\n    for (int i = 0; i < cmd.length(); ++i) {\n          uint8_t ch = static_cast<uint8_t>(cmd[i]);\n          uint8_t d0 = 0xFF;\n          uint8_t d1 = 0xFF;\n          uint8_t d2 = 0xFF;\n          uint8_t d3 = 0xFF;\n          bitWrite(d0, 2, bitRead(ch, 0));\n          bitWrite(d0, 5, bitRead(ch, 1));\n          bitWrite(d1, 2, bitRead(ch, 2));\n          bitWrite(d1, 5, bitRead(ch, 3));\n          bitWrite(d2, 2, bitRead(ch, 4));\n          bitWrite(d2, 5, bitRead(ch, 5));\n          bitWrite(d3, 2, bitRead(ch, 6)); \n          bitWrite(d3, 5, bitRead(ch, 7));\n          delay(1); \n          Serial.write(d0);\n          delay(1); \n          Serial.write(d1);\n          delay(1); \n          Serial.write(d2);\n          delay(1); \n          Serial.write(d3);\n          delay(7);\n    }     \n    return true;\n }\n```", "```cpp\nvoid JuraModule::onSerialReceived(Stream &stream, char arrivedChar, \nunsigned short availableCharsCount) {\n\n    OtaCore::log(LOG_DEBUG, \"Receiving UART 0.\");\n    while(stream.available()){\n\n        delay(1);\n        uint8_t d0 = stream.read();\n        delay(1);\n        uint8_t d1 = stream.read();\n        delay(1);\n        uint8_t d2 = stream.read();\n        delay(1);\n        uint8_t d3 = stream.read();\n        delay(7);\n\n        uint8_t d4;\n        bitWrite(d4, 0, bitRead(d0, 2));\n        bitWrite(d4, 1, bitRead(d0, 5));\n        bitWrite(d4, 2, bitRead(d1, 2));\n        bitWrite(d4, 3, bitRead(d1, 5));\n        bitWrite(d4, 4, bitRead(d2, 2));\n        bitWrite(d4, 5, bitRead(d2, 5));\n        bitWrite(d4, 6, bitRead(d3, 2));\n        bitWrite(d4, 7, bitRead(d3, 5));\n        OtaCore::log(LOG_TRACE, String(d4));\n        mqttTxBuffer += (char) d4;\n\n        if ('\\n' == (char) d4) {\n            long int espressoCount = strtol(mqttTxBuffer.substring(3, \n            7).c_str(), 0, 16);\n            long int espresso2Count = strtol(mqttTxBuffer.substring(7, \n            11).c_str(), 0, 16);\n            long int coffeeCount = strtol(mqttTxBuffer.substring(11, \n            15).c_str(), 0, 16);\n            long int coffee2Count = strtol(mqttTxBuffer.substring(15, \n            19).c_str(), 0, 16);\n            OtaCore::publish(\"nsa/espresso\", OtaCore::getLocation() + \n            \";\" + espressoCount);\n            OtaCore::publish(\"nsa/espresso2\", OtaCore::getLocation() + \n            \";\" + espresso2Count);\n            OtaCore::publish(\"nsa/coffee\", OtaCore::getLocation() + \";\" \n            + coffeeCount);\n            OtaCore::publish(\"nsa/coffee2\", OtaCore::getLocation() + \n            \";\" + coffee2Count);\n            mqttTxBuffer = \"\";\n          }\n    }\n }\n```", "```cpp\n#include \"base_module.h\" \n\nclass JuraTermModule {\n    static String mqttTxBuffer;\n\n    static bool toCoffeemaker(String cmd);\n    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void commandCallback(String message);\n };#include \"juraterm_module.h\"\n\n String JuraTermModule::mqttTxBuffer;\n\n bool JuraTermModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_JURATERM, JuraTermModule::start, JuraTermModule::shutdown);\n }\n\n bool JuraTermModule::start() {\n    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; } // RX 0\n    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; } // TX 0\n\n    OtaCore::registerTopic(\"coffee/command/\" + OtaCore::getLocation(), \n                            JuraTermModule::commandCallback); \n    Serial.end();\n    delay(10);\n    Serial.begin(9600);\n    Serial.setCallback(&JuraTermModule::onSerialReceived);\n\n    return true;\n }\n\n bool JuraTermModule::shutdown() {\n    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; } // RX 0\n    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; } // TX 0\n\n    Serial.end();\n    OtaCore::deregisterTopic(\"coffee/command/\" + OtaCore::getLocation());\n    return true;\n }\n\n void JuraTermModule::commandCallback(String message) {\n    if (message == \"AN:0A\") { return; }\n\n    JuraTermModule::toCoffeemaker(message);\n }\n```", "```cpp\n bool JuraTermModule::toCoffeemaker(String cmd) {\n    OtaCore::log(LOG_DEBUG, \"Sending command: \" + cmd);\n\n    cmd += \"\\r\\n\";\n\n    for (int i = 0; i < cmd.length(); ++i) {\n          uint8_t ch = static_cast<uint8_t>(cmd[i]);\n          uint8_t d0 = 0xFF;\n          uint8_t d1 = 0xFF;\n          uint8_t d2 = 0xFF;\n          uint8_t d3 = 0xFF;\n\n          bitWrite(d0, 2, bitRead(ch, 0));\n          bitWrite(d0, 5, bitRead(ch, 1));\n          bitWrite(d1, 2, bitRead(ch, 2));\n          bitWrite(d1, 5, bitRead(ch, 3));\n          bitWrite(d2, 2, bitRead(ch, 4));\n          bitWrite(d2, 5, bitRead(ch, 5));\n          bitWrite(d3, 2, bitRead(ch, 6)); \n          bitWrite(d3, 5, bitRead(ch, 7));\n\n          delay(1); \n          Serial.write(d0);\n          delay(1); \n          Serial.write(d1);\n          delay(1); \n          Serial.write(d2);\n          delay(1); \n          Serial.write(d3);\n          delay(7);\n    }     \n\n    return true;\n }\n\n void JuraTermModule::onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount) {\n    OtaCore::log(LOG_DEBUG, \"Receiving UART 0.\");\n\n    while(stream.available()){\n          delay(1);\n          uint8_t d0 = stream.read();\n          delay(1);\n          uint8_t d1 = stream.read();\n          delay(1);\n          uint8_t d2 = stream.read();\n          delay(1);\n          uint8_t d3 = stream.read();\n          delay(7);\n\n          uint8_t d4;\n          bitWrite(d4, 0, bitRead(d0, 2));\n          bitWrite(d4, 1, bitRead(d0, 5));\n          bitWrite(d4, 2, bitRead(d1, 2));\n          bitWrite(d4, 3, bitRead(d1, 5));\n          bitWrite(d4, 4, bitRead(d2, 2));\n          bitWrite(d4, 5, bitRead(d2, 5));\n          bitWrite(d4, 6, bitRead(d3, 2));\n          bitWrite(d4, 7, bitRead(d3, 5));\n\n          OtaCore::log(LOG_TRACE, String(d4));\n\n          mqttTxBuffer += (char) d4;\n          if ('\\n' == (char) d4) {\n                OtaCore::publish(\"coffee/response\", OtaCore::getLocation() + \";\" + mqttTxBuffer);\n                mqttTxBuffer = \"\";\n          }\n    }\n }\n```", "```cpp\n#include \"base_module.h\"\n\n #define GPIO_PIN 0\n\n class MotionModule {\n    static int pin;\n    static Timer timer;\n    static Timer warmup;\n    static bool motion;\n    static bool firstLow;\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void config(String cmd);\n    static void warmupSensor();\n    static void readSensor();\n    static void IRAM_ATTR interruptHandler();\n };\n```", "```cpp\n#include \"motion_module.h\"\nint MotionModule::pin = GPIO_PIN;\nTimer MotionModule::timer;\nTimer MotionModule::warmup;\nbool MotionModule::motion = false;\nbool MotionModule::firstLow = true;\nbool MotionModule::initialize() {\n      BaseModule::registerModule(MOD_IDX_MOTION, MotionModule::start, \n      MotionModule::shutdown);\n}\nbool MotionModule::start() {\n    if (!OtaCore::claimPin(ESP8266_gpio00)) { return false; }\n    pinMode(pin, INPUT);\n    warmup.initializeMs(60000, MotionModule::warmupSensor).start();\n   return true;\n}\n```", "```cpp\n\n bool MotionModule::shutdown() {\n    if (!OtaCore::releasePin(ESP8266_gpio00)) { return false; } // RX 0\n\n    timer.stop();\n    detachInterrupt(pin);\n\n    return true;\n }\n\n void MotionModule::config(String cmd) {\n    Vector<String> output;\n    int numToken = splitString(cmd, '=', output);\n    if (output[0] == \"set_pin\" && numToken > 1) {\n          //\n    }\n }\n\n void MotionModule::warmupSensor() {\n    warmup.stop();\n    attachInterrupt(pin, &MotionModule::interruptHandler, CHANGE);\n\n    timer.initializeMs(5000, MotionModule::readSensor).start();\n }\n```", "```cpp\n void MotionModule::readSensor() {\n    if (!motion) {\n          if (firstLow) { firstLow = false; }\n          else {\n                OtaCore::publish(\"nsa/motion\", OtaCore::getLocation() + \";0\");\n                firstLow = true;\n          }\n    }\n    else if (motion) {\n          OtaCore::publish(\"nsa/motion\", OtaCore::getLocation() + \";1\");\n          firstLow = true;\n    }\n }\n```", "```cpp\nvoid IRAM_ATTR MotionModule::interruptHandler() {\n    int val = digitalRead(pin);\n    if (val == HIGH) { motion = true; }\n    else { motion = false; }\n }\n```", "```cpp\n#include \"base_module.h\"\n\n #include <HardwarePWM.h>\n\n class PwmModule {\n    static HardwarePWM* hw_pwm;\n    static Vector<int> duty;\n    static uint8 pinNum;\n    static Timer timer;\n    static uint8* pins;\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void commandCallback(String message);\n };\n```", "```cpp\n#include \"pwm_module.h\"\n\n HardwarePWM* PwmModule::hw_pwm = 0;\n uint8 PwmModule::pinNum = 0;\n Timer PwmModule::timer;\n uint8* PwmModule::pins = 0;\n\n enum {\n    PWM_START = 0x01,\n    PWM_STOP = 0x02,\n    PWM_SET_DUTY = 0x04,\n    PWM_DUTY = 0x08,\n    PWM_ACTIVE = 0x10\n };\n```", "```cpp\n\n bool PwmModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_PWM, PwmModule::start, PwmModule::shutdown);\n }\n\n bool PwmModule::start() {\n    OtaCore::registerTopic(MQTT_PREFIX + String(\"pwm/\") + OtaCore::getLocation(), PwmModule::commandCallback);\n\n    return true;\n }\n\n bool PwmModule::shutdown() {\n    OtaCore::deregisterTopic(MQTT_PREFIX + String(\"pwm/\") + OtaCore::getLocation());\n\n    if (hw_pwm) {\n          delete hw_pwm;\n          hw_pwm = 0;\n    }\n\n    return true;\n }\n```", "```cpp\n\n void PwmModule::commandCallback(String message) {\n    OtaCore::log(LOG_DEBUG, \"PWM command: \" + message);\n    if (message.length() < 1) { return; }\n    int index = 0;\n    uint8 cmd = *((uint8*) &message[index++]);\n\n    if (cmd == PWM_START) {\n          if (message.length() < 2) { return; }\n          uint8 num = *((uint8*) &message[index++]);\n\n          OtaCore::log(LOG_DEBUG, \"Pins to add: \" + String(num));\n\n          if (message.length() != (2 + num)) { return; }\n\n          pins = new uint8[num];\n          for (int i = 0; i < num; ++i) {\n                pins[i] = *((uint8*) &message[index++]);\n                if (!OtaCore::claimPin(pins[i])) {\n                      OtaCore::log(LOG_ERROR, \"Pin is already in use: \" + String(pins[i]));\n\n                      OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";0\", 1);\n\n                      return; \n                }\n\n                OtaCore::log(LOG_INFO, \"Adding GPIO pin \" + String(pins[i]));\n          }\n\n          hw_pwm = new HardwarePWM(pins, num);\n          pinNum = num;\n\n          OtaCore::log(LOG_INFO, \"Added pins to PWM: \" + String(pinNum));\n\n          OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";1\", 1);\n    }\n    else if (cmd == PWM_STOP) {\n          delete hw_pwm;\n          hw_pwm = 0;\n\n          for (int i = 0; i < pinNum; ++i) {\n                if (!OtaCore::releasePin(pins[i])) {\n                      OtaCore::log(LOG_ERROR, \"Pin cannot be released: \" + String(pins[i]));\n\n                      OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";0\", 1);\n\n                      return; \n                }\n\n                OtaCore::log(LOG_INFO, \"Removing GPIO pin \" + String(pins[i]));\n          }\n\n          delete[] pins;\n          pins = 0;\n\n          OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";1\");\n    }\n    else if (cmd == PWM_SET_DUTY) {\n          if (message.length() < 3) { return; }\n\n          uint8 pin = *((uint8*) &message[index++]);\n          uint8 duty = *((uint8*) &message[index++]);\n          bool ret = hw_pwm->setDuty(pin, ((uint32) 222.22 * duty));\n          if (!ret) {\n                OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";0\");\n\n                return;\n          }\n\n          OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";1\");\n    }\n    else if (cmd == PWM_DUTY) {\n          if (message.length() < 2) { return; }\n\n          uint8 pin = *((uint8*) &message[index++]);\n          uint32 duty = hw_pwm->getDuty(pin);\n\n          uint8 dutyp = (duty / 222.22) + 1;\n          String res = \"\";\n          res += (char) pin;\n          res += (char) dutyp;\n          OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";\" + res);\n    }\n    else if (cmd == PWM_ACTIVE) {\n          String res;\n          if (pins && pinNum > 0) {\n                res = String((char*) pins, pinNum);\n          }\n\n          OtaCore::publish(\"pwm/response\", OtaCore::getLocation() + \";\" + res);\n    }\n }\n```", "```cpp\n#include \"base_module.h\"\n\n #include <Libraries/MCP23008/MCP23008.h>\n\n class IOModule {\n    static MCP23008* mcp;\n    static uint8 iodir;\n    static uint8 gppu;\n    static uint8 gpio;\n    static String publishTopic;\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void commandCallback(String message);\n };\n```", "```cpp\n#include \"io_module.h\"\n\n #include <Wire.h>\n\n MCP23008* IOModule::mcp = 0;\n uint8 IOModule::iodir;     \n uint8 IOModule::gppu;\n uint8 IOModule::gpio;      \n String IOModule::publishTopic;\n```", "```cpp\n\n enum {\n    IO_START = 0x01,\n    IO_STOP = 0x02,\n    IO_STATE = 0x04,\n    IO_SET_MODE = 0x08,\n    IO_SET_PULLUP = 0x10,\n    IO_WRITE = 0x20,\n    IO_READ = 0x40,\n    IO_ACTIVE = 0x80\n };\n\n enum {\n    MCP_OUTPUT = 0,\n    MCP_INPUT = 1\n };\n```", "```cpp\nbool IOModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_IO, IOModule::start, IOModule::shutdown);\n }\n\n bool IOModule::start() {   \n    publishTopic = \"io/response/\" + OtaCore::getLocation();\n    OtaCore::registerTopic(\"io/\" + OtaCore::getLocation(), IOModule::commandCallback);\n\n    OtaCore::starti2c();\n }\n\n bool IOModule::shutdown() {\n    OtaCore::deregisterTopic(\"io/\" + OtaCore::getLocation());\n    if (mcp) {\n          delete mcp;\n          mcp = 0;\n    }\n }\n```", "```cpp\nvoid IOModule::commandCallback(String message) {\n    OtaCore::log(LOG_DEBUG, \"I/O command: \" + message);\n    uint32 mlen = message.length();\n    if (mlen < 1) { return; }\n    int index = 0;\n    uint8 cmd = *((uint8*) &message[index++]);\n    if (cmd == IO_START) {\n        if (mlen > 2) {\n            OtaCore::log(LOG_INFO, \"Enabling I/O Module failed: too \n            many parameters.\");\n            OtaCore::publish(publishTopic, OtaCore::getLocation() + \n            \";\" + (char) 0x01 + (char) 0x00);\n            return; \n        }\n        // Read out the desired address, or use the default.\n        uint8 addr = 0;\n        if (mlen == 2) {\n            addr = *((uint8*) &message[index++]);\n            if (addr > 7) {                     \n            // Report failure. QoS 1.\n            OtaCore::log(LOG_INFO, \"Enabling I/O Module failed: invalid \n            i2c address.\");\n            OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" \n            + (char) 0x01 + (char) 0x00);\n            return;\n        }\n    }\n    if (!mcp) {\n        mcp = new MCP23008(0x40);\n    }           \n    // Set all pins to output (0) and low (0)\n    mcp->writeIODIR(0x00);\n    mcp->writeGPIO(0x00);\n    // Read in current chip values.\n    iodir = mcp->readIODIR();\n    gppu = mcp->readGPPU();\n    gpio = mcp->readGPIO();\n    // Validate IODIR and GPIO registers.\n    if (iodir != 0 || gpio != 0) {\n        delete mcp;\n        mcp = 0;\n        OtaCore::log(LOG_INFO, \"Enabling I/O Module failed: not \n        connected.\");\n         OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" +\n         (char) 0x01 + (char) 0x00);\n         return;\n    }\n    OtaCore::log(LOG_INFO, \"Enabled I/O Module.\");\n    OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" +                                                                        \n    (char) 0x01 + (char) 0x01);\n}\n    else if (cmd == IO_STOP) {\n        if (mlen > 1) {\n            OtaCore::log(LOG_INFO, \"Disabling I/O Module failed: too \n            many parameters.\");\n            OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" \n            + (char) 0x02 + (char) 0x00);\n            return; \n        }\n        if (mcp) {\n            delete mcp;\n            mcp = 0;\n        }\n        OtaCore::log(LOG_INFO, \"Disabled I/O Module.\");\n        OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n        (char) 0x02 + (char) 0x01);\n    }\n    else if (cmd == IO_STATE) {\n          if (mlen > 1) {\n                OtaCore::log(LOG_INFO, \"Reading state failed: too many parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x04 + (char) 0x00);\n                return; \n          }\n\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x04 + (char) 0x01 + \n                                                                      ((char) iodir) + ((char) gppu) +\n                                                                      ((char) gpio));\n    }\n    else if (cmd == IO_SET_MODE) {\n          if (mlen != 3) {\n                OtaCore::log(LOG_INFO, \"Reading state failed: incorrect number of parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x08 + (char) 0x00);\n                return; \n          }\n\n          uint8 pnum = *((uint8*) &message[index++]);\n          uint8 pstate = *((uint8*) &message[index]);\n          if (pnum > 7) {\n                OtaCore::log(LOG_INFO, \"Setting pin mode failed: unknown pin.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x08 + (char) 0x00);\n                return; \n          }\n\n          if (pstate > 1) {\n                // Report failure. QoS 1.\n                OtaCore::log(LOG_INFO, \"Setting pin mode failed: invalid pin mode.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x08 + (char) 0x00);\n                return; \n          }\n\n          // Set new state of IODIR register.\n          if (pstate == MCP_INPUT) { iodir |= 1 << pnum; } \n          else { iodir &= ~(1 << pnum); }\n\n          if (mcp) {\n                OtaCore::log(LOG_DEBUG, \"Setting pinmode in library...\");\n                mcp->writeIODIR(iodir);\n          }\n\n          OtaCore::log(LOG_INFO, \"Set pin mode for I/O Module.\");\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x08 + (char) 0x01);\n    }\n    else if (cmd == IO_SET_PULLUP) {          \n          if (mlen != 3) {\n                OtaCore::log(LOG_INFO, \"Reading state failed: incorrect number of parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x10 + (char) 0x00);\n                return; \n          }\n\n          uint8 pnum = *((uint8*) &message[index++]);\n          uint8 pstate = *((uint8*) &message[index]);\n          if (pnum > 7) {\n                OtaCore::log(LOG_INFO, \"Setting pull-up failed: unknown pin.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x10 + (char) 0x00);\n                return; \n          }\n\n          if (pstate > 1) {\n                OtaCore::log(LOG_INFO, \"Setting pull-up failed: invalid state.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x10 + (char) 0x00);\n                return; \n          }\n\n          if (pstate == HIGH) { gppu |= 1 << pnum; } \n          else { gppu &= ~(1 << pnum); }\n\n          if (mcp) {\n                OtaCore::log(LOG_DEBUG, \"Setting pull-up in library...\");\n                mcp->writeGPPU(gppu);\n          }\n\n          OtaCore::log(LOG_INFO, \"Changed pull-up for I/O Module.\");\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x10 + (char) 0x01);\n    }\n    else if (cmd == IO_WRITE) {\n          if (mlen != 3) {\n                OtaCore::log(LOG_INFO, \"Writing pin failed: incorrect number of parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x20 + (char) 0x00);\n                return; \n          }\n          // Set the new GPIO pin level.\n          uint8 pnum = *((uint8*) &message[index++]);\n          uint8 pstate = *((uint8*) &message[index]);\n          if (pnum > 7) {\n                OtaCore::log(LOG_INFO, \"Writing pin failed: unknown pin.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x20 + (char) 0x00);\n                return; \n          }\n          if (pstate > 1) {\n                OtaCore::log(LOG_INFO, \"Writing pin failed: invalid state.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x20 + (char) 0x00);\n                return; \n          }\n          String state = \"low\";\n          if (pstate == HIGH) { gpio |= 1 << pnum; state = \"high\"; } \n          else { gpio &= ~(1 << pnum); }\n\n          OtaCore::log(LOG_DEBUG, \"Changed GPIO to: \" + ((char) gpio));\n\n          if (mcp) {\n                OtaCore::log(LOG_DEBUG, \"Setting state to \" + state + \n                                        \" in library for pin \" + ((char) pnum));\n                mcp->writeGPIO(gpio);\n          }\n\n          OtaCore::log(LOG_INFO, \"Wrote pin state for I/O Module.\");\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x20 + (char) 0x01);\n    }\n\n    else if (cmd == IO_READ) {\n\n          if (mlen > 2) {\n                OtaCore::log(LOG_INFO, \"Reading pin failed: too many \n                parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation()\n                                                                     (char) 0x40 + (char) 0x00);\n                return; \n          }\n          // Read the GPIO pin status and return it.\n          uint8 pnum = *((uint8*) &message[index]);\n\n        if (pnum > 7) {\n            OtaCore::log(LOG_INFO, \"Reading pin failed: unknown pin.\");\n            OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" \n            + (char) 0x40 + (char) 0x00);\n        }\n          uint8 pstate;\n\n        if (mcp) {\n            OtaCore::log(LOG_DEBUG, \"Reading pin in library...\");\n            pstate = (mcp->readGPIO() >> pnum) & 0x1;\n        }\n        OtaCore::log(LOG_INFO, \"Read pin state for I/O Module.\");\n        OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n        (char) 0x40 + (char) 0x01 + (char) pnum + (char) pstate);\n    }\n\n    else if (cmd == IO_ACTIVE) {\n\n        if (mlen > 1) {\n            OtaCore::log(LOG_INFO, \"Reading active status failed: too \n            many parameters.\");\n            OtaCore::publish(publishTopic, OtaCore::getLocation() + \n            \";\" + (char) 0x80 + (char) 0x00);\n            return; \n        }\n        uint8 active = 0;\n        if (mcp) { active = 1; }\n        char output[] = { 0x80, 0x01, active };\n        OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n        String(output, 3));\n    }\n}\n```", "```cpp\n#include \"base_module.h\"\n\n class SwitchModule {\n    static String publishTopic;\n\n public:\n    static bool initialize();\n    static bool start();\n    static bool shutdown();\n    static void commandCallback(String message);\n };\n```", "```cpp\n#include \"switch_module.h\"\n#include <Wire.h>\n#define SW1_SET_PIN 5 \n#define SW2_SET_PIN 4 \n#define SW1_READ_PIN 14 \n#define SW2_READ_PIN 12 \nString SwitchModule::publishTopic;\nenum {\n    SWITCH_ONE = 0x01,//Switch the first connected load on, second off.\n    SWITCH_TWO = 0x02,//Switch the second connected load on, first off.\n    SWITCH_STATE = 0x04,//Returns position of the switch (0x01/0x02).\n};\nbool SwitchModule::initialize() {\n    BaseModule::registerModule(MOD_IDX_SWITCH, SwitchModule::start, \n    SwitchModule::shutdown);\n}\nbool SwitchModule::start() {\n    // Register pins.\n    if (!OtaCore::claimPin(ESP8266_gpio05)) { return false; }\n    if (!OtaCore::claimPin(ESP8266_gpio04)) { return false; }\n    if (!OtaCore::claimPin(ESP8266_gpio14)) { return false; }\n    if (!OtaCore::claimPin(ESP8266_gpio12)) { return false; }\n    publishTopic = \"switch/response/\" + OtaCore::getLocation();\n    OtaCore::registerTopic(\"switch/\" + OtaCore::getLocation(), \n    SwitchModule::commandCallback);\n// Set the pull-ups on the input pins and configure the output pins.\n    pinMode(SW1_SET_PIN, OUTPUT);\n    pinMode(SW2_SET_PIN, OUTPUT);\n    pinMode(SW1_READ_PIN, INPUT_PULLUP);\n    pinMode(SW2_READ_PIN, INPUT_PULLUP);\n    digitalWrite(SW1_SET_PIN, LOW);\n    digitalWrite(SW2_SET_PIN, LOW);\n }\n bool SwitchModule::shutdown() {\n    OtaCore::deregisterTopic(\"switch/\" + OtaCore::getLocation());\n    // Release the pins.\n    if (!OtaCore::releasePin(ESP8266_gpio05)) { return false; }\n    if (!OtaCore::releasePin(ESP8266_gpio04)) { return false; }\n    if (!OtaCore::releasePin(ESP8266_gpio14)) { return false; }\n    if (!OtaCore::releasePin(ESP8266_gpio12)) { return false; }\n }\n\n void SwitchModule::commandCallback(String message) {\n    // Message is the command.\n    OtaCore::log(LOG_DEBUG, \"Switch command: \" + message);\n\n    uint32 mlen = message.length();\n    if (mlen < 1) { return; }\n    int index = 0;\n    uint8 cmd = *((uint8*) &message[index++]);\n    if (cmd == SWITCH_ONE) {\n          if (mlen > 1) {\n                // Report failure. QoS 1.\n                OtaCore::log(LOG_INFO, \"Switching to position 1 failed: too many parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x01 + (char) 0x00);\n                return; \n          }\n\n          // Set the relay to its first position (reset condition).\n          // This causes pins 3 & 10 on the latching relay to become active.\n          digitalWrite(SW1_SET_PIN, HIGH);\n          delay(1000); // Wait 1 second for the relay to switch position.\n          digitalWrite(SW1_SET_PIN, LOW);\n\n          OtaCore::log(LOG_INFO, \"Switched to position 1.\");\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x01 + (char) 0x01);\n    }\n    else if (cmd == SWITCH_TWO) {\n          if (mlen > 1) {\n                OtaCore::log(LOG_INFO, \"Switching to position 2 failed: too many parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x02 + (char) 0x00);\n                return; \n          }\n\n          // Set the relay to its first position (reset condition).\n          // This causes pins 3 & 10 on the latching relay to become active.\n          digitalWrite(SW2_SET_PIN, HIGH);\n          delay(1000); // Wait 1 second for the relay to switch position.\n          digitalWrite(SW2_SET_PIN, LOW);\n\n          OtaCore::log(LOG_INFO, \"Switched to position 1.\");\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x02 + (char) 0x01);\n    }\n    else if (cmd == SWITCH_STATE) {\n          if (mlen > 1) {\n                OtaCore::log(LOG_INFO, \"Reading state failed: too many parameters.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x04 + (char) 0x00);\n                return; \n          }\n\n          // Check the value of the two input pins. If one is low, then that\n          // is the active position.\n          uint8 active = 2;\n          if (digitalRead(SW1_READ_PIN) == LOW) { active = 0; }\n          else if (digitalRead(SW2_READ_PIN) == LOW) { active = 1; }\n\n          if (active > 1) {\n                OtaCore::log(LOG_INFO, \"Reading state failed: no active state found.\");\n                OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x04 + (char) 0x00);\n                return; \n          }\n\n          OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" + \n                                                                      (char) 0x04 + (char) 0x01 + \n                                                                      (char) active);\n    }\n }\n```", "```cpp\n#include \"listener.h\"  \n#include <iostream> \n#include <string> \n\nusing namespace std; \n\n#include <Poco/Util/IniFileConfiguration.h> \n#include <Poco/AutoPtr.h> \n#include <Poco/Net/HTTPServer.h> \n\nusing namespace Poco::Util; \nusing namespace Poco; \nusing namespace Poco::Net; \n\n#include \"httprequestfactory.h\" \n\nint main(int argc, char* argv[]) { \n   cout << \"Starting MQTT BMaC Command & Control server...\\n\"; \n\n   int rc; \n   mosqpp::lib_init(); \n\n   cout << \"Initialised C++ Mosquitto library.\\n\"; \n\n   string configFile; \n   if (argc > 1) { configFile = argv[1]; } \n   else { configFile = \"config.ini\"; } \n\n   AutoPtr<IniFileConfiguration> config(new IniFileConfiguration(configFile)); \n   string mqtt_host = config->getString(\"MQTT.host\", \"localhost\"); \n   int mqtt_port = config->getInt(\"MQTT.port\", 1883); \n   string defaultFirmware = config->getString(\"Firmware.default\", \"ota_unified.bin\"); \n\n   Listener listener(\"Command_and_Control\", mqtt_host, mqtt_port, defaultFirmware); \n\n   UInt16 port = config->getInt(\"HTTP.port\", 8080); \n   HTTPServerParams* params = new HTTPServerParams; \n   params->setMaxQueued(100); \n   params->setMaxThreads(10); \n   HTTPServer httpd(new RequestHandlerFactory, port, params); \n   httpd.start(); \n\n   cout << \"Created listener, entering loop...\\n\"; \n\n   while(1) { \n         rc = listener.loop(); \n         if (rc){ \n               cout << \"Disconnected. Trying to reconnect...\\n\"; \n               listener.reconnect(); \n         } \n   } \n\n   cout << \"Cleanup...\\n\"; \n\n   mosqpp::lib_cleanup(); \n\n   return 0; \n} \n```", "```cpp\n#include <mosquittopp.h> \n#include <string> \n\nusing namespace std; \n\n#include <Poco/Data/Session.h> \n#include <Poco/Data/SQLite/Connector.h> \n\nusing namespace Poco; \n\nclass Listener : public mosqpp::mosquittopp { \n   Data::Session* session; \n   string defaultFirmware; \n\npublic: \n   Listener(string clientId, string host, int port, string defaultFirmware); \n   ~Listener(); \n\n   void on_connect(int rc); \n   void on_message(const struct mosquitto_message* message); \n   void on_subscribe(int mid, int qos_count, const int* granted_qos); \n}; \n```", "```cpp\n#include \"listener.h\" \n\n#include <iostream> \n#include <fstream> \n#include <sstream> \n\nusing namespace std; \n\n#include <Poco/StringTokenizer.h> \n#include <Poco/String.h> \n#include <Poco/Net/HTTPSClientSession.h> \n#include <Poco/Net/HTTPRequest.h> \n#include <Poco/Net/HTTPResponse.h> \n#include <Poco/File.h> \n\nusing namespace Poco::Data::Keywords; \n\nstruct Node { \n   string uid; \n   string location; \n   UInt32 modules; \n   float posx; \n   float posy; \n}; \n```", "```cpp\nListener::Listener(string clientId, string host, int port, string defaultFirmware) : mosquittopp(clientId.c_str()) { \n   int keepalive = 60; \n   connect(host.c_str(), port, keepalive); \n\n   Data::SQLite::Connector::registerConnector(); \n   session = new Poco::Data::Session(\"SQLite\", \"nodes.db\"); \n\n   (*session) << \"CREATE TABLE IF NOT EXISTS nodes (uid TEXT UNIQUE, \\ \n         location TEXT, \\ \n         modules INT, \\ \n         posx FLOAT, \\ \n         posy FLOAT)\", now; \n\n   (*session) << \"CREATE TABLE IF NOT EXISTS firmware (uid TEXT UNIQUE, \\ \n         file TEXT)\", now; \n\n   this->defaultFirmware = defaultFirmware; \n} \n```", "```cpp\nListener::~Listener() { \n   // \n} \n\nvoid Listener::on_connect(int rc) { \n   cout << \"Connected. Subscribing to topics...\\n\"; \n\n   if (rc == 0) { \n         string topic = \"cc/config\";   // announce by nodes coming online. \n         subscribe(0, topic.c_str()); \n         topic = \"cc/ui/config\";       // C&C client requesting configuration. \n         subscribe(0, topic.c_str()); \n         topic = \"cc/nodes/new\";       // C&C client adding new node. \n         subscribe(0, topic.c_str()); \n         topic = \"cc/nodes/update\";    // C&C client updating node. \n         subscribe(0, topic.c_str()); \n         topic = \"nsa/events/CO2\";     // CO2-related events. \n         subscribe(0, topic.c_str()); \n         topic = \"cc/firmware\";  // C&C client firmware command. \n         subscribe(0, topic.c_str()); \n   } \n   else { \n         cerr << \"Connection failed. Aborting subscribing.\\n\"; \n   } \n} \n```", "```cpp\nvoid Listener::on_message(const struct mosquitto_message* message) { \n   string topic = message->topic; \n   string payload = string((const char*) message->payload, message->payloadlen); \n\n   if (topic == \"cc/config\") { \n         if (payload.length() < 1) { \n               cerr << \"Invalid payload: \" << payload << \". Reject.\\n\"; \n               return; \n         } \n```", "```cpp\n         Data::Statement select(*session); \n         Node node; \n         node.uid = payload; \n         select << \"SELECT location, modules FROM nodes WHERE uid=?\", \n                     into (node.location), \n                     into (node.modules), \n                     use (payload); \n\n         size_t rows = select.execute(); \n\n         if (rows == 1) { \n               string topic = \"cc/\" + payload; \n               string response = \"mod;\" + string((const char*) &node.modules, 4); \n               publish(0, topic.c_str(), response.length(), response.c_str()); \n               response = \"loc;\" + node.location; \n               publish(0, topic.c_str(), response.length(), response.c_str()); \n         } \n         else if (rows < 1) { \n               // No node with this UID found. \n               cerr << \"Error: No data set found for uid \" << payload << endl; \n         } \n         else { \n               // Multiple data sets were found, which shouldn't be possible... \n               cerr << \"Error: Multiple data sets found for uid \" << payload << \"\\n\"; \n         } \n   } \n```", "```cpp\nelse if (topic == \"cc/ui/config\") { \n\n    if (payload == \"map\") {\n\n        ifstream mapFile(\"map.png\", ios::binary); \n\n        if (!mapFile.is_open()) { \n\n            cerr << \"Failed to open map file.\\n\"; \n\n            return; \n\n        } \n\n        stringstream ss; \n\n        ss << mapFile.rdbuf(); \n\n        string mapData = ss.str(); \n\n        publish(0, \"cc/ui/config/map\", mapData.length(), \n\n        mapData.c_str()); \n\n} \n```", "```cpp\n         else if (payload == \"nodes\") { \n               Data::Statement countQuery(*session); \n               int rowCount; \n               countQuery << \"SELECT COUNT(*) FROM nodes\", \n                     into(rowCount), \n                     now; \n\n               if (rowCount == 0) { \n                     cout << \"No nodes found in database, returning...\\n\"; \n                     return; \n               } \n\n               Data::Statement select(*session); \n               Node node; \n               select << \"SELECT uid, location, modules, posx, posy FROM nodes\", \n                           into (node.uid), \n                           into (node.location), \n                           into (node.modules), \n                           into (node.posx), \n                           into (node.posy), \n                           range(0, 1); \n\n               string header; \n               string nodes; \n               string nodeStr; \n               UInt32 nodeCount = 0; \n               while (!select.done()) { \n                     select.execute(); \n                     nodeStr = \"NODE\"; \n                     UInt8 length = (UInt8) node.uid.length(); \n                     nodeStr += string((char*) &length, 1); \n                     nodeStr += node.uid; \n                     length = (UInt8) node.location.length(); \n                     nodeStr += string((char*) &length, 1); \n                     nodeStr += node.location; \n                     nodeStr += string((char*) &node.posx, 4); \n                     nodeStr += string((char*) &node.posy, 4); \n                     nodeStr += string((char*) &node.modules, 4); \n                     UInt32 segSize = nodeStr.length(); \n\n                     nodes += string((char*) &segSize, 4); \n                     nodes += nodeStr; \n                     ++nodeCount; \n               } \n\n               UInt64 messageSize = nodes.length() + 9; \n               header = string((char*) &messageSize, 8); \n               header += \"NODES\"; \n               header += string((char*) &nodeCount, 4); \n               header += nodes; \n\n               publish(0, \"cc/nodes/all\", header.length(), header.c_str()); \n         } \n   } \n```", "```cpp\n   else if (topic == \"cc/nodes/new\") { \n         UInt32 index = 0; \n         UInt32 msgLength = *((UInt32*) payload.substr(index, 4).data()); \n         index += 4; \n         string signature = payload.substr(index, 4); \n         index += 4; \n\n         if (signature != \"NODE\") { \n               cerr << \"Invalid node signature.\\n\"; \n               return; \n         } \n\n         UInt8 uidLength = (UInt8) payload[index++]; \n         Node node; \n         node.uid = payload.substr(index, uidLength); \n         index += uidLength; \n         UInt8 locationLength = (UInt8) payload[index++]; \n         node.location = payload.substr(index, locationLength); \n         index += locationLength; \n         node.posx = *((float*) payload.substr(index, 4).data()); \n         index += 4; \n         node.posy = *((float*) payload.substr(index, 4).data()); \n         index += 4; \n         node.modules = *((UInt32*) payload.substr(index, 4).data()); \n\n         cout << \"Storing new node for UID: \" << node.uid << \"\\n\"; \n\n         Data::Statement insert(*session); \n         insert << \"INSERT INTO nodes VALUES(?, ?, ?, ?, ?)\", \n                     use(node.uid), \n                     use(node.location), \n                     use(node.modules), \n                     use(node.posx), \n                     use(node.posy), \n                     now; \n\n         (*session) << \"INSERT INTO firmware VALUES(?, ?)\", \n                     use(node.uid), \n                     use(defaultFirmware), \n                     now; \n   } \n```", "```cpp\n   else if (topic == \"cc/nodes/update\") { \n         UInt32 index = 0; \n         UInt32 msgLength = *((UInt32*) payload.substr(index, 4).data()); \n         index += 4; \n         string signature = payload.substr(index, 4); \n         index += 4; \n\n         if (signature != \"NODE\") { \n               cerr << \"Invalid node signature.\\n\"; \n               return; \n         } \n\n         UInt8 uidLength = (UInt8) payload[index++]; \n         Node node; \n         node.uid = payload.substr(index, uidLength); \n         index += uidLength; \n         UInt8 locationLength = (UInt8) payload[index++]; \n         node.location = payload.substr(index, locationLength); \n         index += locationLength; \n         node.posx = *((float*) payload.substr(index, 4).data()); \n         index += 4; \n         node.posy = *((float*) payload.substr(index, 4).data()); \n         index += 4; \n         node.modules = *((UInt32*) payload.substr(index, 4).data()); \n\n         cout << \"Updating node for UID: \" << node.uid << \"\\n\"; \n\n         Data::Statement update(*session); \n         update << \"UPDATE nodes SET location = ?, posx = ?, posy = ?, modules = ? WHERE uid = ?\", \n                     use(node.location), \n                     use(node.posx), \n                     use(node.posy), \n                     use(node.modules), \n                     use(node.uid), \n                     now; \n   } \n```", "```cpp\n   else if (topic == \"cc/nodes/delete\") { \n         cout << \"Deleting node with UID: \" << payload << \"\\n\"; \n\n         Data::Statement del(*session); \n         del << \"DELETE FROM nodes WHERE uid = ?\", \n                     use(payload), \n                     now; \n\n         (*session) << \"DELETE FROM firmware WHERE uid = ?\", \n                     use(payload), \n                     now; \n   } \n```", "```cpp\n   else if (topic == \"nsa/events/CO2\") { \n         StringTokenizer st(payload, \";\", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY); \n         if (st.count() < 4) { \n               cerr << \"CO2 event: Wrong number of arguments. Payload: \" << payload << \"\\n\"; \n               return; \n         } \n\n         string state = \"ok\"; \n         if (st[1] == \"1\") { state = \"warn\"; } \n         else if (st[1] == \"2\") { state = \"crit\"; } \n         string increase = (st[2] == \"1\") ? \"true\" : \"false\"; \n         string json = \"{ \\\"state\\\": \\\"\" + state + \"\\\", \\ \n                                 \\\"location\\\": \\\"\" + st[0] + \"\\\", \\ \n                                 \\\"increase\\\": \" + increase + \", \\ \n                                 \\\"ppm\\\": \" + st[3] + \" }\"; \n\n         Net::HTTPSClientSession httpsClient(\"localhost\"); \n         try { \n               Net::HTTPRequest request(Net::HTTPRequest::HTTP_POST, \n                                                   \"/\", \n                                                   Net::HTTPMessage::HTTP_1_1); \n               request.setContentLength(json.length()); \n               request.setContentType(\"application/json\"); \n               httpsClient.sendRequest(request) << json; \n\n               Net::HTTPResponse response; \n               httpsClient.receiveResponse(response); \n         } \n         catch (Exception& exc) { \n               cout << \"Exception caught while attempting to connect.\" << std::endl; \n               cerr << exc.displayText() << std::endl; \n               return; \n         } \n   } \n```", "```cpp\n   else if (topic == \"cc/firmware\") { \n         if (payload == \"list\") { \n               std::vector<File> files; \n               File file(\"firmware\"); \n               if (!file.isDirectory()) { return; } \n\n               file.list(files); \n               string out; \n               for (int i = 0; i < files.size(); ++i) { \n                     if (files[i].isFile()) { \n                           out += files[i].path(); \n                           out += \";\"; \n                     } \n               } \n\n               out.pop_back(); \n\n               publish(0, \"cc/firmware/list\", out.length(), out.c_str()); \n         } \n         else { \n               StringTokenizer st(payload, \";\", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY); \n\n               if (st[0] == \"change\") { \n                     if (st.count() != 3) { return; } \n                     (*session) << \"UPDATE firmware SET file = ? WHERE uid = ?\", \n                                             use (st[1]), \n                                             use (st[2]), \n                                             now; \n               } \n               else if (st[0] == \"upload\") { \n                     if (st.count() != 3) { return; } \n\n                     // Write file & truncate if exists. \n                     string filepath = \"firmware/\" + st[1];                       \n                     ofstream outfile(\"firmware/\" + st[1], ofstream::binary | ofstream::trunc); \n                     outfile.write(st[2].data(), st[2].size()); \n                     outfile.close(); \n               } \n         } \n   } \n} \nvoid Listener::on_subscribe(int mid, int qos_count, const int* granted_qos) { \n   // \n} \n```", "```cpp\n#include <Poco/Net/HTTPRequestHandlerFactory.h> \n#include <Poco/Net/HTTPServerRequest.h> \n\nusing namespace Poco::Net; \n\n#include \"datahandler.h\" \n\nclass RequestHandlerFactory: public HTTPRequestHandlerFactory { \npublic: \n   RequestHandlerFactory() {} \n   HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request) { \n         return new DataHandler(); \n   } \n}; \n```", "```cpp\n#include <iostream> \n#include <vector> \n\nusing namespace std; \n\n#include <Poco/Net/HTTPRequestHandler.h> \n#include <Poco/Net/HTTPServerResponse.h> \n#include <Poco/Net/HTTPServerRequest.h> \n#include <Poco/URI.h> \n#include <Poco/File.h> \n\n#include <Poco/Data/Session.h> \n#include <Poco/Data/SQLite/Connector.h> \n\nusing namespace Poco::Data::Keywords; \n\nusing namespace Poco::Net; \nusing namespace Poco; \n\nclass DataHandler: public HTTPRequestHandler { \npublic: \n   void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response) { \n         cout << \"DataHandler: Request from \" + request.clientAddress().toString() << endl; \n\n         URI uri(request.getURI()); \n         string path = uri.getPath(); \n         if (path != \"/\") { \n               response.setStatus(HTTPResponse::HTTP_NOT_FOUND); \n               ostream& ostr = response.send(); \n               ostr << \"File Not Found: \" << path; \n               return; \n         } \n\n         URI::QueryParameters parts; \n         parts = uri.getQueryParameters(); \n         if (parts.size() > 0 && parts[0].first == \"uid\") { \n               Data::SQLite::Connector::registerConnector(); \n               Data::Session* session = new Poco::Data::Session(\"SQLite\", \"nodes.db\"); \n\n               Data::Statement select(*session); \n               string filename; \n               select << \"SELECT file FROM firmware WHERE uid=?\", \n                                 into (filename), \n                                 use (parts[0].second); \n\n               size_t rows = select.execute(); \n\n               if (rows != 1) { \n                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); \n                     ostream& ostr = response.send(); \n                     ostr << \"File Not Found: \" << parts[0].second; \n                     return; \n               } \n\n               string fileroot = \"firmware/\"; \n               File file(fileroot + filename); \n\n               if (!file.exists() || file.isDirectory()) { \n                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); \n                     ostream& ostr = response.send(); \n                     ostr << \"File Not Found.\"; \n                     return; \n               } \n\n               string mime = \"application/octet-stream\"; \n               try { \n                     response.sendFile(file.path(), mime); \n               } \n               catch (FileNotFoundException &e) { \n                     cout << \"File not found exception triggered...\" << endl; \n                     cerr << e.displayText() << endl; \n\n                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); \n                     ostream& ostr = response.send(); \n                     ostr << \"File Not Found.\"; \n                     return; \n               } \n               catch (OpenFileException &e) { \n                     cout << \"Open file exception triggered...\" << endl; \n                     cerr << e.displayText() << endl; \n\n                     response.setStatus(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR); \n                     ostream& ostr = response.send(); \n                     ostr << \"Internal Server Error. Couldn't open file.\"; \n                     return; \n               } \n         } \n         else { \n               response.setStatus(HTTPResponse::HTTP_BAD_REQUEST); \n               response.send(); \n               return; \n         } \n   } \n}; \n```", "```cpp\n#include <string>\n #include <vector>\n\n using namespace std;\n\n #include <Poco/Data/Session.h>\n #include <Poco/Data/SQLite/Connector.h>\n\n #include <Poco/Net/HTTPClientSession.h>\n #include <Poco/Net/HTTPSClientSession.h>\n\n #include <Poco/Timer.h>\n\n using namespace Poco;\n using namespace Poco::Net;\n\n class Listener;\n\n struct NodeInfo {\n    string uid;\n    float posx;\n    float posy;\n    float current;    \n    float target;\n    bool ch0_state;\n    UInt8 ch0_duty;\n    bool ch0_valid;\n    bool ch1_state;\n    UInt8 ch1_duty;\n    bool ch1_valid;\n    bool ch2_state;\n    UInt8 ch2_duty;\n    bool ch2_valid;\n    bool ch3_state;\n    UInt8 ch3_duty;\n    bool ch3_valid;\n    UInt8 validate;\n };\n\n struct ValveInfo {\n    string uid;\n    UInt8 ch0_valve;\n    UInt8 ch1_valve;\n    UInt8 ch2_valve;\n    UInt8 ch3_valve;\n };\n\n struct SwitchInfo {\n    string uid;\n    bool state;\n };\n\n #include \"listener.h\"\n\n class Nodes {\n    static Data::Session* session;\n    static bool initialized;\n    static HTTPClientSession* influxClient;\n    static string influxDb;\n    static bool secure;\n    static Listener* listener;\n    static Timer* tempTimer;\n    static Timer* nodesTimer;\n    static Timer* switchTimer;\n    static Nodes* selfRef;\n\n public:\n    static void init(string influxHost, int influxPort, string influxDb, string influx_sec, Listener* listener);\n    static void stop();\n    static bool getNodeInfo(string uid, NodeInfo &info);\n    static bool getValveInfo(string uid, ValveInfo &info);\n    static bool getSwitchInfo(string uid, SwitchInfo &info);\n    static bool setTargetTemperature(string uid, float temp);\n    static bool setCurrentTemperature(string uid, float temp);\n    static bool setDuty(string uid, UInt8 ch0, UInt8 ch1, UInt8 ch2, UInt8 ch3);\n    static bool setValves(string uid, bool ch0, bool ch1, bool ch2, bool ch3);\n    static bool setSwitch(string uid, bool state);\n    void updateCurrentTemperatures(Timer& timer);\n    void checkNodes(Timer& timer);\n\n    void checkSwitch(Timer& timer);\n    static bool getUIDs(vector<string> &uids);\n    static bool getSwitchUIDs(vector<string> &uids);\n };\n```", "```cpp\n#include <mosquittopp.h>\n\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#include <Poco/Mutex.h>\n\nusing namespace Poco;\n\nstruct NodeInfo;\nstruct ValveInfo;\nstruct SwitchInfo;\n\n #include \"nodes.h\"\n\n class Listener : public mosqpp::mosquittopp {\n    map<string, NodeInfo> nodes;\n    map<string, ValveInfo> valves;\n    map<string, SwitchInfo> switches;\n    Mutex nodesLock;\n    Mutex valvesLock;\n    Mutex switchesLock;\n    bool heating;\n    Mutex heatingLock;\n\n public:\n    Listener(string clientId, string host, int port);\n    ~Listener();\n\n    void on_connect(int rc);\n    void on_message(const struct mosquitto_message* message);\n    void on_subscribe(int mid, int qos_count, const int* granted_qos);\n    bool checkNodes();\n    bool checkSwitch();\n };\n```", "```cpp\n#include \"mth.h\"\n\n#include <iostream>\n\nusing namespace std;\n\n#include <Poco/Net/HTTPRequest.h>\n#include <Poco/Net/HTTPResponse.h>\n#include <Poco/StringTokenizer.h>\n#include <Poco/String.h>\n\nusing namespace Poco;\n\nMtH::MtH(string clientId, string host, int port, string topics, string influxHost, \n                int influxPort, string influxDb, string influx_sec) : mosquittopp(clientId.c_str()) {\n    this->topics  = topics;\n    this->influxDb = influxDb;\n    if (influx_sec == \"true\") { \n          cout << \"Connecting with HTTPS...\" << std::endl;\n          influxClient = new Net::HTTPSClientSession(influxHost, influxPort);\n          secure = true; \n    } \n    else {\n          cout << \"Connecting with HTTP...\" << std::endl;\n          influxClient = new Net::HTTPClientSession(influxHost, influxPort);\n          secure = false; \n    }\n\n    int keepalive = 60;\n    connect(host.c_str(), port, keepalive);\n }\n```", "```cpp\n\n MtH::~MtH() {\n    delete influxClient;\n }\n\n void MtH::on_connect(int rc) {\n    cout << \"Connected. Subscribing to topics...\\n\";\n\n    if (rc == 0) {\n          StringTokenizer st(topics, \",\", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY);\n          for (StringTokenizer::Iterator it = st.begin(); it != st.end(); ++it) {\n                string topic = string(*it);\n                cout << \"Subscribing to: \" << topic << \"\\n\";\n                subscribe(0, topic.c_str());\n\n                // Add name of the series to the 'series' map.\n                StringTokenizer st1(topic, \"/\", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY);\n                string s = st1[st1.count() - 1]; // Get last item.\n                series.insert(std::pair<string, string>(topic, s));\n          }\n    }\n    else {\n          cerr << \"Connection failed. Aborting subscribing.\\n\";\n    }\n }\n```", "```cpp\nvoid MtH::on_message(const struct mosquitto_message* message) {\n    string topic = message->topic;      \n    map<string, string>::iterator it = series.find(topic);\n    if (it == series.end()) { \n          cerr << \"Topic not found: \" << topic << \"\\n\";\n          return; \n    }\n\n    if (message->payloadlen < 1) {\n          cerr << \"No payload found. Returning...\\n\";\n          return;\n    }\n\n    string payload = string((const char*) message->payload, message-\n    >payloadlen);\n    size_t pos = payload.find(\";\");\n    if (pos == string::npos || pos == 0) {\n        cerr << \"Invalid payload: \" << payload << \". Reject.\\n\";\n        return;\n    }\n\n    string uid = payload.substr(0, pos);\n    string value = payload.substr(pos + 1);\n    string influxMsg; \n    influxMsg = series[topic];\n    influxMsg += \",location=\" + uid;\n    influxMsg += \" value=\" + value;\n    try {\n        Net::HTTPRequest request(Net::HTTPRequest::HTTP_POST, \n        \"/write?db=\" + influxDb, Net::HTTPMessage::HTTP_1_1);\n        request.setContentLength(influxMsg.length());\n        request.setContentType(\"application/x-www-form-urlencoded\");\n        influxClient->sendRequest(request) << influxMsg;\n\n        Net::HTTPResponse response;\n        influxClient->receiveResponse(response);\n    }\n    catch (Exception& exc) {\n        cout << \"Exception caught while attempting to connect.\" << \n        std::endl;\n        cerr << exc.displayText() << std::endl;\n        return;\n    }\n```"]
- en: '*Chapter 1*: Introduction to Algorithmic Trading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take you through a brief history of trading and explain
    in which situations manual and algorithmic trading each make sense. Additionally,
    we will discuss financial asset classes, which are a categorization of the different
    types of financial assets. You will learn about the components of the modern electronic
    trading exchange, and, finally, we will outline the key components of an algorithmic
    trading system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the evolution of algorithmic trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding financial asset classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going through the modern electronic trading exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the components of an algorithmic trading system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through the evolution of algorithmic trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of trading one possession for another has been around since the
    beginning of time. In its earliest form, trading was useful for exchanging a less
    desirable possession for a more desirable possession. Eventually, with the passage
    of time, trading has evolved into participants trying to find a way to buy and
    hold trading instruments (that is, products) at prices perceived as lower than
    fair value in the hopes of being able to sell them in the future at a price higher
    than the purchase price. This **buy-low-and-sell-high principle** serves as the
    basis for all profitable trading to date; of course, how to achieve this is where
    the complexity and competition lies.
  prefs: []
  type: TYPE_NORMAL
- en: Markets are driven by the **fundamental economic forces of supply and demand**.
    As demand increases without a commensurate increase in supply, or supply decreases
    without a decrease in demand, a commodity becomes scarce and increases in value
    (that is, its market price). Conversely, if demand drops without a decrease in
    supply, or supply increases without an increase in demand, a commodity becomes
    more easily available and less valuable (a lower market price). Therefore, the
    market price of a commodity should reflect the equilibrium price based on available
    supply (sellers) and available demand (buyers).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many drawbacks to the **manual trading approach**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Human traders are inherently slow at processing new market information, making
    them likely to miss information or to make errors in interpreting updated market
    data. This leads to bad trading decisions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humans, in general, are also prone to distractions and biases that reduce profits
    and/or generate losses. For example, the fear of losing money and the joy of making
    money also causes us to deviate from the optimal systematic trading approach,
    which we understand in theory but fail to execute in practice. In addition, people
    are also naturally and non-uniformly biased against profitable trades versus losing
    trades; for instance, human traders are quick to increase the amount of risk after
    profitable trades and slow down to decrease the amount of risk after losing trades.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human traders learn by experiencing market conditions, for example, by being
    present and trading live markets. So, they cannot learn from and **backtest**
    over historical market data conditions – an important advantage of automated strategies,
    as we will see later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the advent of technology, trading has evolved from pit trading carried
    out by yelling and signaling buy and sell orders all the way to using sophisticated,
    efficient, and fast computer hardware and software to execute trades, often without
    much human intervention. Sophisticated algorithmic trading software systems have
    replaced human traders and engineers, and mathematicians who build, operate, and
    improve these systems, known as **quants**, have risen to power.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the key advantages of an **automated, computer-driven systematic/algorithmic
    trading approach** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Computers are extremely good at performing clearly defined and repetitive rule-based
    tasks. They can perform these tasks extremely quickly and can handle massive throughputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, computers do not get distracted, tired, or make mistakes (unless
    there is a software bug, which, technically, counts as a software developer error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithmic trading strategies also have no emotions as far as trading through
    losses or profits; therefore, they can stick to a systematic trading plan no matter
    what.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these advantages make systematic algorithmic trading the perfect candidate
    to set up low-latency, high-throughput, scalable, and robust trading businesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, algorithmic trading is not always better than manual trading:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual trading is better at dealing with significantly complex ideas and the
    complexities of real-world trading operations that are, sometimes, difficult to
    express as an automated software solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated trading systems require significant investments in time and R&D costs,
    while manual trading strategies are often significantly faster to get to market.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithmic trading strategies are also prone to software development/operation
    bugs, which can have a significant impact on a trading business. Entire automated
    trading operations being wiped out in a matter of a few minutes is not unheard
    of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, automated quantitative trading systems are not good at dealing with extremely
    unlikely events termed as **black swan** events, such as the LTCM crash, the 2010
    flash crash, the Knight Capital crash, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the history of trading and when automated/algorithmic
    is better than manual trading. Now, let's proceed toward the next section, where
    we will learn about the actual subject of trading categorized into financial asset
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding financial asset classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithmic trading deals with the trading of financial assets. A financial
    asset is a non-physical asset whose value arises from contractual agreements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major financial asset classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Equities** (**stocks**): These allow market participants to invest directly
    in the company and become owners of the company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed income** (**bonds**): These represent a loan made by the investor to
    a borrower (for instance, a government or a firm). Each bond has its end date
    when the principal of the loan is due to be paid back and, usually, either fixed
    or variable interest payments made by the borrower over the lifetime of the bond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real Estate Investment Trusts** (**REITs**): These are publicly traded companies
    that own or operate or finance income-producing real estate. These can be used
    as a proxy to directly invest in the housing market, say, by purchasing a property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commodities**: Examples include metals (silver, gold, copper, and more) and
    agricultural produce (wheat, corn, milk, and more). They are financial assets
    tracking the price of the underlying commodities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exchange-Traded Funds** (**ETFs**): An EFT is an exchange-listed security
    that tracks a collection of other securities. ETFs, such as SPY, DIA, and QQQ,
    hold equity stocks to track the larger well-known S&P 500, Dow Jones Industrial
    Average, and Nasdaq stock indices. ETFs such as **United States Oil Fund** (**USO**)
    track oil prices by investing in short-term WTI crude oil futures. ETFs are a
    convenient investment vehicle for investors to invest in a wide range of asset
    classes at relatively lower costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foreign Exchange** (**FX**) between different currency pairs, the major ones
    being the **US Dollar** (**USD**), **Euro** (**EUR**), **Pound Sterling** (**GBP**),
    **Japanese Yen** (**JPY**), **Australian Dollar** (**AUD**), **New Zealand Dollar**
    (**NZD**), **Canadian Dollar** (**CAD**), **Swiss Franc** (**CHF**), **Norwegian
    Krone** (**NOK**), and **Swedish Krona** (**SEK**). These are often referred to
    as the G10 currencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key **Financial derivatives** are options and futures – these are complex
    leveraged derivative products that can magnify the risk as well as the reward:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) **Futures** are financial contracts to buy or sell an asset at a predetermined
    future date and price.
  prefs: []
  type: TYPE_NORMAL
- en: b) **Options** are financial contracts giving their owner the right, but not
    the obligation, to buy or sell an underlying asset at a stated price (strike price)
    prior to or on a specified date.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the financial asset classes and their unique
    properties. Now, let's discuss the order types and exchange matching algorithms
    of modern electronic trading exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Going through the modern electronic trading exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first trading exchange was the Amsterdam Stock Exchange, which began in
    1602\. Here, the trading happened in person. The applications of technology to
    trading included using pigeons, telegraph systems, Morse code, telephones, computer
    terminals, and nowadays, high-speed computer networks and state-of-the-art computers.
    With the passage of time, the trading microstructure has evolved into the order
    types and matching algorithms that we are used to today.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of the modern electronic trading exchange microstructure is important
    for the design of algorithmic strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Order types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Financial trading strategies employ a variety of different order types, and
    some of the most common ones include Market orders, Market with Price Protection
    orders, **Immediate-Or-Cancel** (**IOC**) orders, **Fill and Kill** (**FAK**)
    orders, **Good-'Till-Day** (**GTD**) orders, **Good-'Till-Canceled** (**GTC**)
    orders, Stop orders, and Iceberg orders.
  prefs: []
  type: TYPE_NORMAL
- en: For the strategies that we will be exploring in this book, we will focus on
    Market orders, IOC, and GTC.
  prefs: []
  type: TYPE_NORMAL
- en: Market orders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Market orders are buy-or-sell orders that need to be executed instantly at the
    current market price and are used when the immediacy of execution is preferred
    to the execution price.
  prefs: []
  type: TYPE_NORMAL
- en: These orders will execute against all available orders on the opposite side
    at the order's price until all the quantity asked for is executed. If it runs
    out of available liquidity to match against, it can be configured to **sit in
    the order book** or **expire**. Sitting in the book means the order becomes a
    resting order that is added to the book for other participants to trade against.
    To expire means that the remaining order quantity is canceled instead of being
    added to the book so that new orders cannot match against the remaining quantity.
  prefs: []
  type: TYPE_NORMAL
- en: So, for instance, a buy market order will match against all sell orders sitting
    in the book from the best price to the worst price until the entire market order
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: These orders may suffer from extreme **slippage**, which is defined as the difference
    in the executed order's price and the market price at the time the order was sent.
  prefs: []
  type: TYPE_NORMAL
- en: IOC orders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IOC orders cannot execute at prices worse than what they were sent for, which
    means buy orders cannot execute higher than the order's price, and sell orders
    cannot execute lower than the order's price. This concept is known as **limit
    price** since that price is limited to the worst price the order can execute at.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IOC order will continue matching against orders on the order side until
    one of the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The entire quantity on the IOC order is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The price of the passive order on the other side is worse than the IOC order's
    price.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IOC order is partially executed, and the remaining quantity expires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IOC order that is sent at a price better than the best available order on
    the other side (that is, the buy order is lower than the best offer price, or
    the sell order is higher than the best bid price) does not execute at all and
    just expires.
  prefs: []
  type: TYPE_NORMAL
- en: GTC orders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GTC orders can persist indefinitely and require a specific cancellation order.
  prefs: []
  type: TYPE_NORMAL
- en: Limit order books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exchange accepts order requests from all market participants and maintains
    them in a **limit order book**. Limit order books are a view into all the market
    participant's visible orders available at the exchange at any point in time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Buy orders** (or **bids**) are arranged from the highest price (that is,
    the best price) to the lowest price (that is, the worst price), and **Ask orders**
    (that is, **asks** or **offers**) are arranged from the lowest price (that is,
    the best price) to the highest price (that is, the lowest price).'
  prefs: []
  type: TYPE_NORMAL
- en: The highest bid prices are considered the best bid prices because buy orders
    with the highest buy prices are the first to be matched, and the reverse is true
    for ask prices, that is, sell orders with the lowest sell prices match first.
  prefs: []
  type: TYPE_NORMAL
- en: Orders on the same side and at the same price level are arranged in the **First-In-First-Out**
    (**FIFO**) order, which is also known as priority order – orders with better priority
    are ahead of orders with lower priority because the better priority orders have
    reached the exchange before the others. All else being equal (that is, the same
    order side, price, and quantity), orders with better priority will execute before
    orders with worse priority.
  prefs: []
  type: TYPE_NORMAL
- en: The exchange matching engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The matching engine at the electronic trading exchange performs the **matching
    of orders** using **exchange matching algorithms**. The process of matching entails
    checking all active orders entered by market participants and matching the orders
    that cross each other in price until there are no unmatched orders that could
    be matched – so, buy orders with prices at or above other sell orders match against
    them, and the converse is true as well, that is, sell orders with prices at or
    below other buy orders match against them. The remaining orders remain in the
    exchange matching book until a new order flow comes in, leading to new matches
    if possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the FIFO matching algorithm, orders are matched first – from the best price
    to the worst price. So, an incoming buy order tries to match against resting sell
    orders (that is, asks/offers) from the lowest price to the highest price, and
    an incoming sell order tries to match against resting buy orders (that is, bids)
    from the highest price to the lowest price. New incoming orders are matched with
    a specific sequence of rules. For incoming aggressive orders (orders with prices
    better than the best price level on the other side), they are matched on a first-come-first-serve
    basis, that is, orders that show up first, take out liquidity and, therefore,
    match first. For passive resting orders that sit in the book, since they do not
    execute immediately, they are assigned based on priority on a first-come-first-serve
    basis. That means orders on the same side and at the same price are arranged based
    on the time it takes them to reach the matching engine; orders with earlier times
    are assigned better priority and, therefore, are eligible to be matched first.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the order types and exchange matching engine
    of the modern electronic trading exchange. Now, let's proceed toward the next
    section, where we will learn about the components of an algorithmic trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the components of an algorithmic trading system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A client-side algorithmic trading infrastructure can be broken down broadly
    into two categories: **core infrastructure** and **quantitative infrastructure**.'
  prefs: []
  type: TYPE_NORMAL
- en: The core infrastructure of an algorithmic trading system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A core infrastructure handles communication with the exchange using market data
    and order entry protocols. It is responsible for relaying information between
    the exchange and the algorithmic trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Its components are also responsible for capturing, timestamping, and recording
    historical market data, which is one of the top priorities for algorithmic trading
    strategy research and development.
  prefs: []
  type: TYPE_NORMAL
- en: The core infrastructure also includes a layer of risk management components
    to guard the trading system against erroneous or runaway trading strategies to
    prevent catastrophic outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some of the less glamorous tasks involved in the algorithmic trading
    business, such as back-office reconciliation tasks, compliance, and more, are
    also addressed by the core infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Trading servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trading server involves one or more computers receiving and processing market
    and other relevant data, and trading exchange information (for example, an order
    book), and issuing trading orders.
  prefs: []
  type: TYPE_NORMAL
- en: From the limit order book, updates to the exchange matching book are disseminated
    to all market participants over **market data protocols**.
  prefs: []
  type: TYPE_NORMAL
- en: Market participants have **trading servers** that receive these market data
    updates. While, technically, these trading servers can be anywhere in the world,
    modern algorithmic trading participants have their trading servers placed in a
    data center very close to the exchange matching engine. This is called a **colocated**
    or **Direct Market Access** (**DMA**) setup, which guarantees that participants
    receive market data updates as fast as possible by being as close to the matching
    engine as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Once the market data update, which is communicated via exchange-provided market
    data protocols, is received by each market participant, they use software applications
    known as **market data feed handlers** to decode the market data updates and feed
    it to the algorithmic trading strategy on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Once the algorithmic trading strategy has digested the market data update, based
    on the intelligence developed in the strategy, it generates outgoing order flow.
    This can be the addition, modification, or cancellation of orders at specific
    prices and quantities.
  prefs: []
  type: TYPE_NORMAL
- en: The order requests are picked up by an, often, separate client component known
    as the **order entry gateway**. The order entry gateway component communicates
    with the exchange using **order entry protocols** to translate this request from
    the strategy to the exchange. Notifications in response to these order requests
    are sent by the electronic exchange back to the order entry gateway. Again, in
    response to this order flow by a specific market participant, the matching engine
    generates market data updates, therefore going back to the beginning of this information
    flow loop.
  prefs: []
  type: TYPE_NORMAL
- en: The quantitative infrastructure of an algorithmic trading system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quantitative infrastructure builds on top of the platform provided by the
    core infrastructure and, essentially, tries to build components on top to research,
    develop, and effectively leverage the platform to generate revenue.
  prefs: []
  type: TYPE_NORMAL
- en: The research framework includes components such as backtesting, **Post-Trade
    Analytics** (**PTA**), and signal research components.
  prefs: []
  type: TYPE_NORMAL
- en: Other components that are used in research as well as deployed to live markets
    would be limit order books, predictive signals, and signal aggregators, which
    combine individual signals into a composite signal.
  prefs: []
  type: TYPE_NORMAL
- en: Execution logic components use trading signals and do the heavy lifting of managing
    live orders, positions, and **Profit And Loss** (**PnL**) across different strategies
    and trading instruments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, trading strategies themselves have a risk management component to manage
    and mitigate risk across different strategies and instruments.
  prefs: []
  type: TYPE_NORMAL
- en: Trading strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Profitable trading ideas have always been driven by human intuition developed
    from observing the patterns of market conditions and the outcomes of various strategies
    under different market conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, historically, it has been observed that large market rallies generate
    investor confidence, causing more market participants to jump in and buy more;
    therefore, recursively causing larger rallies. Conversely, large drops in market
    prices scare off participants invested in the trading instrument, causing them
    to sell their holdings and exacerbate the drop in prices. These intuitive ideas
    backed by observations in markets led to the idea of **trend-following strategies**.
  prefs: []
  type: TYPE_NORMAL
- en: It has also been observed that short-term volatile moves in either direction
    often tend to revert to their previous market price, leading to **mean reversion-based
    speculators and trading strategies**. Similarly, historical observations that
    similar product prices move together, which also makes intuitive sense have led
    to the generation of correlation and collinearity-based trading strategies such
    as **statistical arbitrage** and **pairs trading** strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Since every market participant uses different trading strategies, the final
    market prices reflect the majority of market participants. Trading strategies
    whose views align with the majority of market participants are profitable under
    those conditions. A single trading strategy generally cannot be profitable 100
    percent of the time, so sophisticated participants have a portfolio of trading
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Trading signals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Trading signals are also referred to as features, calculators, indicators, predictors,
    or alpha.
  prefs: []
  type: TYPE_NORMAL
- en: Trading signals are what drive algorithmic trading strategy decisions. Signals
    are well-defined pieces of intelligence derived from market data, alternative
    data (such as news, social media feeds, and more), and even our own order flow,
    which is designed to predict certain market conditions in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Signals almost always originate from some intuitive idea and observation of
    certain market conditions and/or strategy performance. Often, most quantitative
    developers spend most of their time researching and developing new trading signals
    to improve profitability under different market conditions and to improve the
    algorithmic trading strategy overall.
  prefs: []
  type: TYPE_NORMAL
- en: The trading signal research framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A lot of man-hours are invested in researching and discovering new signals to
    improve trading performance. To do that in a systematic, efficient, scalable,
    and scientific manner, often, the first step is to build a good **signal research
    framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This framework has subcomponents for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data generation is based on the signal we are trying to build and the market
    conditions/objectives we are trying to capture/predict. In most real-world algorithmic
    trading, we use tick data, which is data that represents every single event in
    the market. As you might imagine, there are a lot of events every day and this
    leads to massive amounts of data, so you also need to think about subsampling
    the data received. **Subsampling** has several advantages, such as reducing the
    scale of data, eliminating the noise/spurious patches of data, and highlighting
    interesting/important data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation of the predictive power or usefulness of features concerning
    the market objective that they are trying to capture/predict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintenance of historical results of signals under different market conditions
    along with tuning existing signals to changing market conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal aggregators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Signal aggregators** are optional components that take inputs from individual
    signals and aggregate them in different ways to generate a new composite signal.'
  prefs: []
  type: TYPE_NORMAL
- en: A very simple aggregation method would be to take the average of all the input
    signals and output the average as the composite signal value.
  prefs: []
  type: TYPE_NORMAL
- en: Readers familiar with statistical learning concepts of ensemble learning – bagging
    and boosting – might be able to spot a similarity between those learning models
    and signal aggregators. Oftentimes signal aggregators are just statistical models
    (regression/classification) where the input signals are just features used to
    predict the same final market objective.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The execution of strategies deals with efficiently managing and executing orders
    based on the outputs of the trading signals to minimize trading fees and slippage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slippage** is the difference between market prices and execution prices and
    is caused due to the latency experienced by an order to get to the market before
    prices change as well as the size of an order causing a change in price once it
    hits the market.'
  prefs: []
  type: TYPE_NORMAL
- en: The quality of execution strategies employed in an algorithmic trading strategy
    can significantly improve/degrade the performance of profitable trading signals.
  prefs: []
  type: TYPE_NORMAL
- en: Limit order books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Limit order books are built both in the exchange match engine and during the
    algorithmic trading strategies, although not necessarily all algorithmic trading
    signals/strategies require the entire limit order book.
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated algorithmic trading strategies can build a lot more intelligence
    into their limit order books. We can detect and track our own orders in the limit
    book and understand, given our priority, what our probability of getting our orders
    executed is. We can also use this information to execute our own orders even before
    the order entry gateway gets the execution notification from the exchange and
    leverage that ability to our advantage. Other more complex microstructure features
    such as detecting icebergs, detecting stop orders, detecting large in-flow or
    out-flow of buy/sell orders, and more are all possible with limit order books
    and market data updates at a lot of electronic trading exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Position and PnL management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's explore how positions and PnLs evolve as a trading strategy opens and
    closes long and short positions by executing trades.
  prefs: []
  type: TYPE_NORMAL
- en: When a strategy does not have a position in the market, that is, price changes
    do not affect the trading account's value, it is referred to as having a flat
    position.
  prefs: []
  type: TYPE_NORMAL
- en: From a flat position, if a buy order executes, then it is referred to as having
    a long position. If a strategy has a long position and prices increase, the position
    profits from the price increase. PnL also increases in this scenario, that is,
    profit increases (or loss decreases). Conversely, if a strategy has a long position
    and prices decrease, the position loses from the price decrease. PnL decreases
    in this scenario, for example, the profit decreases (or the loss increases).
  prefs: []
  type: TYPE_NORMAL
- en: From a flat position, if a sell order is executed then it is referred to as
    having a short position. If a strategy has a short position and prices decrease,
    the position profits from the price decrease. PnL increases in this scenario.
    Conversely, if a strategy has a short position and prices increase, then PnL decreases.
    PnL for a position that is still open is referred to as **unrealized PnL** since
    PnL changes with price changes as long as the position remains open.
  prefs: []
  type: TYPE_NORMAL
- en: A long position is closed by selling an amount of the instrument equivalent
    to the position size. This is referred to as closing or flattening a position,
    and, at this point, PnL is referred to as **realized PnL** since it no longer
    changes as price changes since the position is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, short positions are closed by buying the same amount as the position
    size.
  prefs: []
  type: TYPE_NORMAL
- en: At any point, the **total PnL** is the sum of realized PnLs on all closed positions
    and unrealized PnLs on all open positions.
  prefs: []
  type: TYPE_NORMAL
- en: When a long or short position is composed of buys or sells at multiple prices
    with different sizes, then the average price of the position is computed by computing
    the **Volume Weighted Average Price** (**VWAP**), which is the price of each execution
    weighted by the quantity executed at each price. Marking to market refers to taking
    the VWAP of a position and comparing that to the current market price to get a
    sense of how profitable or lossy a certain long/short position is.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A backtester uses historically recorded market data and simulation components
    to simulate the behavior and performance of an algorithmic trading strategy as
    if it were deployed to live markets in the past. Algorithmic trading strategies
    are developed and optimized using a backtester until the strategy performance
    is in line with expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Backtesters are complex components that need to model market data flow, client-side
    and exchange-side latencies in software and network components, accurate FIFO
    priorities, slippage, fees, and market impact from strategy order flow (that is,
    how would other market participants react to a strategy's order flow being added
    to the market data flow) to generate accurate strategy and portfolio performance
    statistics.
  prefs: []
  type: TYPE_NORMAL
- en: PTA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PTA is performed on trades generated by an algorithmic trading strategy run
    in simulation or live markets.
  prefs: []
  type: TYPE_NORMAL
- en: PTA systems are used to generate performance statistics from historically backtested
    strategies with the objective to understand historical strategy performance expectations.
  prefs: []
  type: TYPE_NORMAL
- en: When applied to trades generated from live trading strategies, PTA can be used
    to understand strategy performance in live markets as well as compare and assert
    that live trading performance is in line with simulated strategy performance expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Risk management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good risk management principles ensure that strategies are run for optimal PnL
    performance and safeguards are put in place against runaway/errant strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Bad risk management cannot only turn a profitable trading strategy into a non-profitable
    one but can also put the investor's entire capital at risk due to uncontrolled
    strategy losses, malfunctioning strategies, and possible regulatory repercussions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned when algorithmic trading has an advantage over
    manual trading, what the financial asset classes are, the most used order types,
    what the limit order book is, and how the orders are matched by the financial
    exchange.
  prefs: []
  type: TYPE_NORMAL
- en: We have also discussed the key components of an algorithmic trading system –
    the core infrastructure and the quantitative infrastructure which consists of
    trading strategies, their execution, limit order book, position, PnL management,
    backtesting, post-trade analytics, and risk management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the value of Python when it comes to algorithmic
    trading.
  prefs: []
  type: TYPE_NORMAL

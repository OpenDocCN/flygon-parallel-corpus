- en: '*Chapter 3*: High-Speed Scientific Computing Using NumPy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用NumPy进行高速科学计算'
- en: This chapter introduces us to NumPy, a high-speed Python library for matrix
    calculations. Most data science/algorithmic trading libraries are built upon NumPy's
    functionality and conventions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了NumPy，这是一个用于矩阵计算的高速Python库。大多数数据科学/算法交易库都是基于NumPy的功能和约定构建的。
- en: 'In this chapter, we are going to cover the following key topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Introduction to NumPy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy介绍
- en: Creating NumPy n-dimensional arrays (ndarrays)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 NumPy n维数组（ndarrays）
- en: Data types used with NumPy arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与NumPy数组一起使用的数据类型
- en: Indexing of ndarrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对ndarrays的索引
- en: Basic ndarray operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的ndarray操作
- en: File operations on ndarrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对ndarrays的文件操作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Python code used in this chapter is available in the `Chapter03/numpy.ipynb`
    notebook in the book's code repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的Python代码可在书的代码库中的`Chapter03/numpy.ipynb`笔记本中找到。
- en: Introduction to NumPy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy介绍
- en: Multidimensional heterogeneous arrays can be represented in Python using lists.
    A list is a 1D array, a list of lists is a 2D array, a list of lists of lists
    is a 3D array, and so on. However, this solution is complex, difficult to use,
    and extremely slow.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多维异构数组可以使用列表在Python中表示。一个列表是一个1D数组，一个列表的列表是一个2D数组，一个列表的列表的列表是一个3D数组，依此类推。然而，这种解决方案复杂，难以使用，并且非常慢。
- en: One of the primary design goals of the NumPy Python library was to introduce
    high-performant and scalable structured arrays and vectorized computations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy Python库的一个主要设计目标是引入高性能和可扩展的结构化数组和矢量化计算。
- en: Most data structures and operations in NumPy are implemented in C/C++, which
    guarantees their superior speed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中的大多数数据结构和操作都是用C/C++实现的，这保证了它们的优越速度。
- en: Creating NumPy ndarrays
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NumPy ndarrays
- en: An **ndarray** is an extremely high-performant and space-efficient data structure
    for multidimensional arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**ndarray**是一个极其高性能和空间高效的多维数组数据结构。'
- en: 'First, we need to import the NumPy library, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入NumPy库，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will start creating a 1D ndarray.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建一个1D ndarray。
- en: Creating 1D ndarrays
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建1D ndarrays
- en: 'The following line of code creates a 1D ndarray:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行创建一个1D ndarray：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will give the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s inspect the type of the array with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码检查数组的类型：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This shows that the array is a NumPy ndarray, as can be seen here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示数组是一个NumPy ndarray，如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can easily create ndarrays of two dimensions or more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建两个或更多维度的ndarrays。
- en: Creating 2D ndarrays
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建2D ndarrays
- en: 'To create a 2D ndarray, use the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个2D ndarray，使用以下代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result has two rows and each row has two values, so it is a 2 x 2 ndarray,
    as illustrated in the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有两行，每行有两个值，所以它是一个2 x 2的ndarray，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating any-dimension ndarrays
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任意维度的ndarrays
- en: 'An ndarray can construct arrays with arbitrary dimensions. The following code
    creates an ndarray of 2 x 2 x 2 x 2 dimensions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ndarray可以构建任意维度的数组。以下代码创建了一个2 x 2 x 2 x 2维度的ndarray：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The representation of the array is shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的表示如下：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'NumPy ndarrays have a `shape` attribute that describes the ndarray''s dimensions,
    as shown in the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarrays有一个`shape`属性，描述了ndarray的维度，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following snippet shows that `arr1D` is a one-dimensional array with five
    elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示`arr1D`是一个具有五个元素的一维数组：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can inspect the `shape` attribute on `arr2D` with the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码检查`arr2D`的`shape`属性：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, the output describes it as being a 2 x 2 ndarray, as we can see
    here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出描述它是一个2 x 2的ndarray，如我们在这里所见：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In practice, there are certain matrices that are more frequently used, such
    as a matrix of 0s, a matrix of 1s, an identity matrix, a matrix containing a range
    of numbers, or a random matrix. NumPy provides support for generating these frequently
    used ndarrays with one command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一些矩阵被更频繁地使用，比如一个0矩阵，一个1矩阵，一个单位矩阵，一个包含一系列数字的矩阵，或者一个随机矩阵。NumPy提供了支持用一个命令生成这些经常使用的ndarrays。
- en: Creating an ndarray with np.zeros(...)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `np.zeros(...)` 创建一个ndarray
- en: 'The `np.zeros(...)` method creates an ndarray populated with all 0s, as illustrated
    in the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.zeros(...)`方法创建一个填充有所有0的ndarray，如下面的代码片段所示：'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is all 0s, with dimensions being 2 x 5, as illustrated in the following
    code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出全为0，维度为2 x 5，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating an ndarray with np.ones(...)
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`np.ones(...)`创建一个ndarray
- en: '`np.ones(...)` is similar, but each value is assigned a value of 1 instead
    of 0\. The method is shown in the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.ones(...)` 类似，但每个值都被赋予值1而不是0。该方法如下代码片段所示：'
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is a 2 x 2 ndarray with every value set to 1, as illustrated in
    the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个2 x 2的ndarray，每个值都设置为1，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating an ndarray with np.identity(...)
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`np.identity(...)`创建一个ndarray
- en: 'Often in matrix operations we need to create an identity matrix, which is available
    in the `np.identity(...)` method, as illustrated in the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵运算中，我们经常需要创建一个单位矩阵，这在`np.identity(...)`方法中是可用的，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This creates a 3 x 3 identity matrix with 1s on the diagonals and 0s everywhere
    else, as illustrated in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个3 x 3的单位矩阵，对角线上为1，其他地方为0，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating an ndarray with np.arange(...)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`np.arange(...)`创建一个ndarray
- en: '`np.arange(...)` is the NumPy equivalent of the Python `range(...)` method.
    This generates values with a start value, end value, and increment, except this
    returns NumPy ndarrays instead, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.arange(...)` 是 Python `range(...)` 方法的 NumPy 等价物。这会生成具有起始值、结束值和增量的值，不同的是这里返回的是
    NumPy ndarrays，如下所示：'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The ndarray returned is shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的ndarray如下所示：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default, values start at 0 and increment by 1.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，值从0开始，递增1。
- en: Creating an ndarray with np.random.randn(…)
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`np.random.randn(…)`创建一个ndarray
- en: '`np.random.randn(…)` generates an ndarray of specified dimensions, with each
    element populated with random values drawn from a standard normal distribution
    (`mean=0`, `std=1`), as illustrated here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.random.randn(…)`生成一个指定维度的ndarray，每个元素都填充有从标准正态分布（`mean=0`，`std=1`）中抽取的随机值，如图所示：'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is a 2 x 2 ndarray with random values, as illustrated in the following
    code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个2 x 2的ndarray，其中包含随机值，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Data types used with NumPy ndarrays
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与NumPy ndarrays一起使用的数据类型
- en: NumPy ndarrays are homogenous—that is, each element in an ndarray has the same
    data type. This is different from Python lists, which can have elements with different
    data types (heterogenous).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarrays是同质的，也就是说，ndarray中的每个元素都具有相同的数据类型。这与Python列表不同，Python列表可以具有不同数据类型的元素（异质）。
- en: The `np.array(...)` method accepts an explicit `dtype=` parameter that lets
    us specify the data type that the ndarray should use. Common data types used are
    `np.int32`, `np.float64`, `np.float128`, and `np.bool`. Note that `np.float128`
    is not supported on Windows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.array(...)`方法接受一个显式的`dtype=`参数，让我们指定ndarray应该使用的数据类型。常用的数据类型包括`np.int32`，`np.float64`，`np.float128`和`np.bool`。请注意，`np.float128`在Windows上不受支持。'
- en: The primary reason why you should be conscious about the various numeric types
    for ndarrays is the memory usage—the more precision the data type provides, the
    larger memory requirements it has. For certain operations, a smaller data type
    may be just enough.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到对ndarrays的各种数值类型的主要原因是内存使用——数据类型提供的精度越高，内存需求就越大。对于某些操作，较小的数据类型可能就足够了。
- en: Creating a numpy.float64 array
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个numpy.float64数组
- en: 'To create a 128-bit floating-values array, use the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个128位浮点值数组，请使用以下代码：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a numpy.bool array
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个numpy.bool数组
- en: 'We can create an ndarray by converting specified values to the target type.
    In the following code example, we see that even though integer data values were
    provided, the resulting ndarray has `dtype` as `bool`, since the data type was
    specified to be `np.bool`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将指定的值转换为目标类型来创建一个ndarray。在下面的代码示例中，我们看到即使提供了整数数据值，由于指定了数据类型为`np.bool`，所以生成的ndarray的`dtype`为`bool`：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The values are shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值如下所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We observe that the integer values (`-1, 0, 1`) were converted to `bool` values
    (`True, False, True`). `0` gets converted to `False`, and all other values get
    converted to `True`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到整数值（`-1, 0, 1`）被转换为`bool`值（`True, False, True`）。`0`被转换为`False`，所有其他值被转换为`True`。
- en: ndarrays' dtype attribute
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarrays的dtype属性
- en: 'ndarrays have a `dtype` attribute to inspect the data type, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ndarrays具有一个`dtype`属性来检查数据类型，如下所示：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is a NumPy `dtype` object with a `float64` value, as illustrated
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个NumPy`dtype`对象，其值为`float64`，如图所示：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Converting underlying data types of ndarray with numpy.ndarrays.astype(...)
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用numpy.ndarrays.astype(...)转换ndarray的基础数据类型
- en: 'We can easily convert the underlying data type of an ndarray to any other compatible
    data type with the `numpy.ndarrays.astype(...)` method. For example, to convert
    `arr1D` from `np.float64` to `np.int64`, we use the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用`numpy.ndarrays.astype(...)`方法将ndarray的基础数据类型转换为任何其他兼容的数据类型。例如，要将`arr1D`从`np.float64`转换为`np.int64`，我们使用以下代码：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This reflects the new data type, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了新的数据类型，如下所示：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When `numpy.ndarray.astype(...)` converts to a narrower data type, it will
    truncate the values, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当`numpy.ndarray.astype(...)`转换为较窄的数据类型时，它将截断值，如下所示：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This converts `arr1D` to the following integer-valued ndarray:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将`arr1D`转换为以下整数值的ndarray：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The original floating values (1.1, 2.2, …) are converted to their truncated
    integer values (1, 2, …).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的浮点值（1.1, 2.2, …）被转换为它们的截断整数值（1, 2, …）。
- en: Indexing of ndarrays
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ndarrays的索引
- en: Array indexing refers to the way of accessing a particular array element or
    elements. In NumPy, all ndarray indices are zero-based—that is, the first item
    of an array has index `0`. Negative indices are understood as counting from the
    end of the array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引是指访问特定数组元素的方式。在NumPy中，所有ndarray索引都是从零开始的，也就是说，数组的第一个项的索引是`0`。负索引被理解为从数组末尾开始计数。
- en: Direct access to an ndarray's element
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接访问ndarray的元素
- en: Direct access to a single ndarray's element is one of the most used forms of
    access.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问单个ndarray的元素是最常用的访问形式之一。
- en: 'The following code builds a 3 x 3 random-valued ndarray for our use:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码构建了一个3 x 3的随机值ndarray供我们使用：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `arr` ndarray has the following elements:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr` ndarray具有以下元素：'
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can index the first element with integer index `0`, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用整数索引`0`来索引第一个元素，如下所示：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This gives us the first row of the `arr` ndarray, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们`arr` ndarray的第一行，如下所示：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can access the element at the second column of the first row by using the
    following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码访问第一行的第二列的元素：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'ndarrays also support an alternative notation to perform the same operation,
    as illustrated here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ndarrays还支持执行相同操作的另一种符号，如下所示：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It accesses the same element as before, as can be seen here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它访问与之前相同的元素，如下所示：
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `numpy.ndarray[index_0, index_1, … index_n]` notation is especially more
    concise and useful when accessing ndarrays with very large dimensions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.ndarray[index_0, index_1, … index_n]`符号在访问具有非常大维度的ndarrays时特别简洁和有用。'
- en: 'Negative indices start from the end of the ndarray, as illustrated here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 负索引从ndarray的末尾开始，如图所示：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This returns the last row of the ndarray, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回ndarray的最后一行，如下所示：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ndarray slicing
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray切片
- en: While single ndarray access is useful, for bulk processing we require access
    to multiple elements of the array at once (for example, if the ndarray contains
    all daily prices of an asset, we might want to process only all Mondays' prices).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个ndarray访问很有用，但是对于批量处理，我们需要一次访问数组的多个元素（例如，如果ndarray包含某个资产的所有每日价格，我们可能只想处理所有星期一的价格）。
- en: Slicing allows access to multiple ndarray records in one command. Slicing ndarrays
    also works similarly to slicing of Python lists.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 切片允许一次访问多个ndarray记录。切片ndarrays的工作方式也类似于切片Python列表。
- en: The basic slice syntax is *i:j:k*, where *i* is the index of the first record
    we want to include, *j* is the stopping index, and *k* is the step.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基本切片语法是*i:j:k*，其中*i*是我们要包括的第一个记录的索引，*j*是停止索引，*k*是步长。
- en: Accessing all ndarray elements after the first one
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问第一个元素之后的所有ndarray元素
- en: 'To access all elements after the first one, we can use the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问第一个元素之后的所有元素，我们可以使用以下代码：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This returns all the rows after the first one, as illustrated in the following
    code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了第一行之后的所有行，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Fetching all rows, starting from row 2 and columns 1 and 2
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取所有行，从第二行开始，列为1和2
- en: 'Similarly, to fetch all rows starting from the second one, and columns up to
    but not including the third one, run the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要获取从第二行开始的所有行，以及列直到但不包括第三列，运行以下代码：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is a 2 x 2 ndarray as expected, as can be seen here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个2 x 2的ndarray，如下所示：
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Slicing with negative indices
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用负索引进行切片
- en: 'More complex slicing notation that mixes positive and negative index ranges
    is also possible, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用混合正负索引范围的更复杂的切片表示法，如下所示：
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a less intuitive way of finding the slice of an element at the second
    row and at the second column, as illustrated here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个寻找第二行第二列元素切片的不太直观的方法，如下所示：
- en: '[PRE48]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Slicing with no indices
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有索引的切片
- en: 'Slicing with no indices yields the entire row/column. The following code generates
    a slice containing all elements on the third row:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有索引的切片产生整行/列。以下代码生成一个包含第三行所有元素的切片：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following code generates a slice of the original `arr` ndarray:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了原始`arr` ndarray的一个切片：
- en: '[PRE51]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE52]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Setting values of a slice to 0
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将切片的值设置为0
- en: Frequently, we will need to set certain values of an ndarray to a given value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，我们需要将ndarray的某些值设置为给定值。
- en: 'Let''s generate a slice containing the second row of `arr` and assign it to
    a new variable, `arr1`, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个包含`arr`的第二行的切片，并将其赋值给一个新变量`arr1`，如下所示：
- en: '[PRE53]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`arr1` now contains the last row, as shown in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr1`现在包含最后一行，如下面的代码片段所示：'
- en: '[PRE54]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s set every element of `arr1` to the value `0`, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`arr1`的每个元素设置为值`0`，如下所示：
- en: '[PRE55]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As expected, `arr1` now contains all 0s, as illustrated here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`arr1`现在包含了所有的0，如下所示：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s re-inspect our original `arr` ndarray, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新检查我们的原始`arr` ndarray，如下所示：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We see that our operation on the `arr1` slice also changed the original `arr`
    ndarray. This brings us to the most important point: ndarray slices are views
    into the original ndarrays, not copies.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们对`arr1`切片的操作也改变了原始的`arr` ndarray。这带我们来到最重要的一点：ndarray切片是对原始ndarrays的视图，而不是副本。
- en: It is important to remember this when working with ndarrays so that we do not
    inadvertently change something we did not mean to. This design is purely for efficiency
    reasons, since copying large ndarrays incurs large overheads.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理ndarrays时，重要的是记住这一点，这样我们就不会无意中改变我们本来不想改变的东西。这个设计纯粹是为了效率原因，因为复制大的ndarrays会产生很大的开销。
- en: 'To create a copy of an ndarray, we explicitly call the `numpy.ndarray.copy(...)`
    method, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个ndarray的副本，我们明确调用`numpy.ndarray.copy(...)`方法，如下所示：
- en: '[PRE59]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s change some values in the `arr_copy` ndarray, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变`arr_copy` ndarray中的一些值，如下所示：
- en: '[PRE60]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can see the change in `arr_copy` in the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的代码片段中看到`arr_copy`的变化：
- en: '[PRE61]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s inspect the original `arr` ndarray as well, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查原始的`arr` ndarray，如下所示：
- en: '[PRE62]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE63]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We see that the original ndarray is unchanged since `arr_copy` is a copy of
    `arr` and not a reference/view to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到原始的ndarray没有改变，因为`arr_copy`是`arr`的副本，而不是引用/视图。
- en: Boolean indexing
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔索引
- en: 'NumPy provides multiple ways of indexing ndarrays. NumPy arrays can be indexed
    by using conditions that evaluate to `True` or `False`. Let''s start by regenerating
    an `arr` ndarray, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了多种索引ndarrays的方法。可以使用评估为`True`或`False`的条件来索引NumPy数组。让我们从头开始重新生成一个`arr`
    ndarray，如下所示：
- en: '[PRE64]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is a 3 x 3 ndarray with random values, as can be seen in the following
    code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个3 x 3的ndarray，其中包含随机值，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s revisit the output of running the following code, which is really just
    calling the `np.less(...)` `np.less(arr, 0)`) method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视运行以下代码的输出，这实际上只是调用`np.less(...)` `np.less(arr, 0)`)方法：
- en: '[PRE66]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This generates another ndarray of `True` and `False` values, where `True` means
    the corresponding element in `arr` was negative and `False` means the corresponding
    element in `arr` was not negative, as illustrated in the following code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了另一个由`True`和`False`值组成的ndarray，其中`True`表示`arr`中对应的元素为负数，`False`表示`arr`中对应的元素不是负数，如下面的代码片段所示：
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use that array as an index to `arr` to find the actual negative elements,
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用该数组作为`arr`的索引来找到实际的负元素，如下所示：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As expected, this fetches the following negative values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这获取了以下负值：
- en: '[PRE69]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can combine multiple conditions with `&` (and) and `|` (or) operators. Python''s
    `&` and `|` Boolean operators do not work on ndarrays since they are for scalars.
    An example of a `&` operator is shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`&`（和）和`|`（或）运算符组合多个条件。Python的`&`和`|`布尔运算符不适用于ndarrays，因为它们是用于标量的。以下是`&`运算符的一个示例：
- en: '[PRE70]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This generates an ndarray with the value `True`, where the elements are between
    `-1` and `1` and `False` otherwise, as illustrated in the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了一个值为`True`的ndarray，其中元素在`-1`和`1`之间，否则为`False`，如下面的代码片段所示：
- en: '[PRE71]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As we saw before, we can use that Boolean array to index `arr` and find the
    actual elements, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以使用布尔数组来索引`arr`并找到实际的元素，如下所示：
- en: '[PRE72]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following output is an array of elements that satisfied the condition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是满足条件的元素数组：
- en: '[PRE73]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Indexing with arrays
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组进行索引
- en: 'ndarray indexing also allows us to directly pass lists of indices of interest.
    Let''s first generate an ndarray of random values to use, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray索引还允许我们直接传递感兴趣的索引列表。让我们首先生成一个随机值ndarray来使用，如下所示：
- en: '[PRE74]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is shown here:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can select the first and third rows, using the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码选择第一行和第三行：
- en: '[PRE76]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is a 2 x 3 ndarray containing the two rows, as illustrated here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个包含两行的2 x 3的ndarray，如下所示：
- en: '[PRE77]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can combine row and column indexing using arrays, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组组合行和列索引，如下所示：
- en: '[PRE78]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding code gives us the second column of the first and third rows,
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了第一行和第三行的第二列，如下所示：
- en: '[PRE79]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can also change the order of the indices passed, and this is reflected in
    the output. The following code picks out the third row followed by the first row,
    in that order:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改变传递的索引的顺序，这在输出中有所体现。以下代码按顺序选择第三行和第一行：
- en: '[PRE80]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output reflects the two rows in the order we expected (third row first;
    first row second), as illustrated in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出反映了我们期望的两行顺序（先第三行；再第一行），如下代码片段所示：
- en: '[PRE81]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now that we have learned how to create ndarrays and about the various ways to
    retrieve the values of their elements, let's discuss the most common ndarray operations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建ndarray以及检索其元素值的各种方法，让我们讨论最常见的ndarray操作。
- en: Basic ndarray operations
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的ndarray操作
- en: 'In the following examples, we will use an `arr2D` ndarray, as illustrated here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用一个`arr2D` ndarray，如下所示：
- en: '[PRE82]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is a 2 x 2 ndarray with values from `1` to `4`, as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值从`1`到`4`的2 x 2的ndarray，如下所示：
- en: '[PRE83]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Scalar multiplication with an ndarray
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray的标量乘法
- en: 'Scalar multiplication with an ndarray has the effect of multiplying each element
    of the ndarray, as illustrated here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray的标量乘法会使ndarray的每个元素相乘，如下所示：
- en: '[PRE84]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE85]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Linear combinations of ndarrays
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray的线性组合
- en: 'The following operation is a combination of scalar and ndarray operations,
    as well as operations between ndarrays:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作是标量和ndarray操作以及ndarray之间操作的组合：
- en: '[PRE86]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is what we would expect, as can be seen here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如我们所期望的那样，如下所示：
- en: '[PRE87]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Exponentiation of ndarrays
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray的指数运算
- en: 'We can raise each element of the ndarray to a certain power, as illustrated
    here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将ndarray的每个元素提升到一定的幂，如下所示：
- en: '[PRE88]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE89]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Addition of an ndarray with a scalar
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray与标量的加法
- en: 'Addition of an ndarray with a scalar works similarly, as illustrated here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray与标量的加法也类似，如下所示：
- en: '[PRE90]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE91]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Transposing a matrix
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵的转置
- en: 'Finding the transpose of a matrix, which is a common operation, is possible
    in NumPy with the `numpy.ndarray.transpose(...)` method, as illustrated in the
    following code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 找到矩阵的转置，这是一个常见的操作，在NumPy中可以使用`numpy.ndarray.transpose(...)`方法，如下代码片段所示：
- en: '[PRE92]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This transposes the ndarray and outputs it, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转置ndarray并输出它，如下所示：
- en: '[PRE93]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Changing the layout of an ndarray
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变ndarray的布局
- en: The `np.ndarray.reshape(...)` method allows us to change the layout (shape)
    of the ndarray without changing its data to a compatible shape.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.ndarray.reshape(...)`方法允许我们改变ndarray的布局（形状）而不改变其数据为兼容的形状。'
- en: 'For instance, to reshape `arr2D` from 2 x 2 to 4 x 1, we use the following
    code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将`arr2D`从2 x 2重塑为4 x 1，我们使用以下代码：
- en: '[PRE94]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The new reshaped 4 x 1 ndarray is displayed here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 新的重塑为4 x 1的ndarray在这里显示：
- en: '[PRE95]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following code example combines `np.random.randn(...)` and `np.ndarray.reshape(...)`
    to create a 3 x 3 ndarray of random values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例结合了`np.random.randn(...)`和`np.ndarray.reshape(...)`来创建一个3 x 3的随机值ndarray：
- en: '[PRE96]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The generated 3 x 3 ndarray is shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的3 x 3的ndarray如下所示：
- en: '[PRE97]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Finding the minimum value in an ndarray
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ndarray中找到最小值
- en: 'To find the minimum value in an ndarray, we use the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ndarray中找到最小值，我们使用以下命令：
- en: '[PRE98]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The result is shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE99]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Calculating the absolute value
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算绝对值
- en: 'The `np.abs(...)` method, shown here, calculates the absolute value of an ndarray:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.abs(...)`方法，如下所示，计算ndarray的绝对值：'
- en: '[PRE100]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output ndarray is shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的ndarray如下所示：
- en: '[PRE101]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Calculating the mean of an ndarray
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算ndarray的平均值
- en: 'The `np.mean(...)` method, shown here, calculates the mean of all elements
    in the ndarray:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.mean(...)`方法如下所示，计算ndarray中所有元素的平均值：'
- en: '[PRE102]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The mean of the elements of `arr` is shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr`元素的平均值如下所示：'
- en: '[PRE103]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can find the mean along the columns by specifying the `axis=` parameter,
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定`axis=`参数来找到沿列的平均值，如下所示：
- en: '[PRE104]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This returns the following array, containing the mean for each column:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回包含每列平均值的数组：
- en: '[PRE105]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Similarly, we can find the mean along the rows by running the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过运行以下代码找到行的平均值：
- en: '[PRE106]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'That returns the following array, containing the mean for each row:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含每行平均值的数组：
- en: '[PRE107]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Finding the index of the maximum value in an ndarray
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到ndarray中最大值的索引
- en: 'Often, we''re interested in finding where in an array its largest value is.
    The `np.argmax(...)` method finds the location of the maximum value in the ndarray,
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们对于在数组中找到最大值的位置感兴趣。`np.argmax(...)`方法找到ndarray中最大值的位置，如下所示：
- en: '[PRE108]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This returns the following value, to represent the location of the maximum
    value (`2.60439882`):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下值，表示最大值的位置（`2.60439882`）：
- en: '[PRE109]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `np.argmax(...)` method also accepts the `axis=` parameter to perform the
    operation row-wise or column-wise, as illustrated here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.argmax(...)`方法还接受`axis=`参数来执行逐行或逐列的操作，如下所示：'
- en: '[PRE110]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This finds the location of the maximum value on each row, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到每行最大值的位置，如下所示：
- en: '[PRE111]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Calculating the cumulative sum of elements of an ndarray
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算ndarray元素的累积和
- en: 'To calculate the running total, NumPy provides the `np.cumsum(...)` method.
    The `np.cumsum(...)` method, illustrated here, finds the cumulative sum of elements
    in the ndarray:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算运行总数，NumPy提供了`np.cumsum(...)`方法。`np.cumsum(...)`方法如下所示，找到ndarray中元素的累积和：
- en: '[PRE112]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output provides the cumulative sum after each additional element, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了每个额外元素后的累积和，如下所示：
- en: '[PRE113]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Notice the difference between a cumulative sum and a sum. A cumulative sum is
    an array of a running total, whereas a sum is a single number.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意累积总和和总和之间的差异。累积总和是一个运行总数的数组，而总和是一个单个数字。
- en: 'Applying the `axis=` parameter to the `cumsum` method works similarly, as illustrated
    in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将`axis=`参数应用于`cumsum`方法的结果类似，如下代码片段所示：
- en: '[PRE114]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This goes row-wise and generates the following array output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按行进行，并生成以下数组输出：
- en: '[PRE115]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Finding NaNs in an ndarray
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ndarray中找到NaN
- en: Missing or unknown values are often represented in NumPy using a **Not a Number**
    (**NaN**) value. For many numerical methods, these must be removed or replaced
    with an interpolation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy中，缺失或未知的值通常使用**Not a Number** (**NaN**)值表示。对于许多数值方法，必须删除或用插值替换这些值。
- en: 'First, let''s set the second row to `np.nan`, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将第二行设置为`np.nan`，如下所示：
- en: '[PRE116]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The new ndarray has the NaN values, as illustrated in the following code snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ndarray具有NaN值，如下代码片段所示：
- en: '[PRE117]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `np.isnan(...)` ufunc finds if values in an ndarray are NaNs, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.isnan(...)` ufunc查找ndarray中的值是否为NaN，如下所示：'
- en: '[PRE118]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is an ndarray with a `True` value where NaNs exist and a `False`
    value where NaNs do not exist, as illustrated in the following code snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个ndarray，其中NaN存在的地方为`True`，NaN不存在的地方为`False`，如下代码片段所示：
- en: '[PRE119]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Finding the truth values of x1>x2 of two ndarrays
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找两个ndarrays的x1>x2的真值
- en: Boolean ndarrays are an efficient way of obtaining indices for values of interest.
    Using Boolean ndarrays is far more performant than looping over the matrix elements
    one by one.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔ndarray是获取感兴趣的值的索引的有效方式。使用布尔ndarray比逐个循环遍历矩阵元素要高效得多。
- en: 'Let''s build another `arr1` ndarray with random values, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用随机值构建另一个`arr1` ndarray，如下所示：
- en: '[PRE120]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The result is a 3 x 3 ndarray, as illustrated in the following code snippet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个3 x 3的ndarray，如下代码片段所示：
- en: '[PRE121]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Similarly, let''s build another `arr2` ndarray, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，让我们构建另一个`arr2` ndarray，如下所示：
- en: '[PRE122]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is shown here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE123]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `np.greater(...)` function is a binary ufunc that generates a `True` value
    when the left-hand-side value in the ndarray is greater than the right-hand-side
    value in the ndarray. This function can be seen here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.greater(...)`函数是一个二进制ufunc，当ndarray中的左侧值大于ndarray中的右侧值时生成一个`True`值。该函数如下所示：'
- en: '[PRE124]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is an ndarray of `True` and `False` values as described previously,
    as we can see here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个包含`True`和`False`值的ndarray，如前面描述的，如下所示：
- en: '[PRE125]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `>` infix operator, shown in the following snippet, is a shorthand of `numpy.greater(...)`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`中缀运算符，如下代码片段所示，是`numpy.greater(...)`的简写：'
- en: '[PRE126]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is the same, as we can see here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相同，如下所示：
- en: '[PRE127]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: any and all Boolean operations on ndarrays
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ndarray上的任何和所有布尔操作
- en: In addition to relational operators, NumPy supports additional methods for testing
    conditions on matrices' values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关系运算符外，NumPy还支持其他用于测试矩阵值条件的方法。
- en: 'The following code generates an ndarray containing `True` for elements that
    satisfy the condition, and `False` otherwise:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成一个包含满足条件的元素为`True`，否则为`False`的ndarray：
- en: '[PRE128]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output is shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE129]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The following `numpy.ndarray.any(...)` method returns `True` if any element
    is `True` and otherwise returns `False`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`numpy.ndarray.any(...)`方法在任何元素为`True`时返回`True`，否则返回`False`：
- en: '[PRE130]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, we have at least one element that is `True`, so the output is `True`,
    as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里至少有一个元素为`True`，所以输出为`True`，如下所示：
- en: '[PRE131]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Again, it accepts the common `axis=` parameter and behaves as expected, as
    we can see here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次接受常见的`axis=`参数，并且表现如预期，如下所示：
- en: '[PRE132]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'And the operation performed row-wise yields, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 并且按行执行的操作产生以下结果：
- en: '[PRE133]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The following `numpy.ndarray.all(...)` method returns `True` when all elements
    are `True`, and `False` otherwise:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`numpy.ndarray.all(...)`方法在所有元素为`True`时返回`True`，否则返回`False`：
- en: '[PRE134]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This returns the following, since not all elements are `True`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下结果，因为并非所有元素都为`True`：
- en: '[PRE135]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'It also accepts the `axis=` parameter, as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它还接受`axis=`参数，如下所示：
- en: '[PRE136]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Again, each row has at least one `False` value, so the output is `False`, as
    shown here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每行至少有一个`False`值，所以输出为`False`，如下所示：
- en: '[PRE137]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Sorting ndarrays
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序ndarrays
- en: Finding an element in a sorted ndarray is faster than processing all elements
    of the ndarray.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序的ndarray中查找元素比处理ndarray的所有元素要快。
- en: 'Let''s generate a 1D random array, as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个1D随机数组，如下所示：
- en: '[PRE138]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The ndarray contains the following data:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray包含以下数据：
- en: '[PRE139]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `np.sort(...)` method is pretty straightforward, as can be seen here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.sort(...)`方法非常简单，如下所示：'
- en: '[PRE140]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output is shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE141]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s inspect the original ndarray to see if it was modified by the `numpy.sort(...)`
    operation, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查原始的ndarray，看看它是否被`numpy.sort(...)`操作修改了，如下所示：
- en: '[PRE142]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The following output shows that the original array is unchanged:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示原始数组未更改：
- en: '[PRE143]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The following `np.argsort(...)` method creates an array of indices that represent
    the location of each element in a sorted array:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`np.argsort(...)`方法创建一个表示每个元素在排序数组中位置的索引数组：
- en: '[PRE144]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The output of this operation generates the following array:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出生成以下数组：
- en: '[PRE145]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'NumPy ndarrays have the `numpy.ndarray.sort(...)` method as well, which sorts
    arrays in place. This method is illustrated in the following code snippet:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy ndarrays也有`numpy.ndarray.sort(...)`方法，可以就地对数组进行排序。该方法如下代码片段所示：
- en: '[PRE146]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'After the call to `sort()`, we call `numpy.argsort(...)` to make sure the array
    was sorted, and this yields the following array that confirms that behavior:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`sort()`之后，我们调用`numpy.argsort(...)`来确保数组已排序，这将产生以下数组，确认了这种行为：
- en: '[PRE147]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Searching within ndarrays
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ndarrays中搜索
- en: Finding indices of elements where a certain condition is met is a fundamental
    operation on an ndarray.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在ndarray上满足某个条件的元素的索引是对ndarray的基本操作。
- en: 'First, we start with an ndarray with consecutive values, as illustrated here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从具有连续值的ndarray开始，如下所示：
- en: '[PRE148]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'This creates the following ndarray:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了以下ndarray：
- en: '[PRE149]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'We create a second ndarray based on the first one, except this time the values
    in the second one are multiplied by `1000`, as illustrated in the following code
    snippet:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据第一个ndarray创建了第二个ndarray，不同之处在于第二个ndarray中的值乘以了`1000`，如下面的代码片段所示：
- en: '[PRE150]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, we know `arr2` contains the following data:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们知道`arr2`包含以下数据：
- en: '[PRE151]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We define another ndarray that contains 10 `True` and `False` values randomly,
    as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义另一个包含10个随机`True`和`False`值的ndarray，如下所示：
- en: '[PRE152]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The values in the `cond` ndarray are shown here:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` ndarray中的值如下所示：'
- en: '[PRE153]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `np.where(...)` method allows us to select values from one ndarray or another,
    depending on the condition being `True` or `False`. The following code will generate
    an ndarray with a value picked from `arr1` when the corresponding element in the
    `cond` array is `True`; otherwise, the value is picked from `arr2`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.where(...)`方法允许我们根据条件是`True`还是`False`从一个ndarray或另一个ndarray中选择值。以下代码将生成一个ndarray，其中当`cond`数组中的相应元素为`True`时，从`arr1`中选择值；否则，从`arr2`中选择值：'
- en: '[PRE154]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The returned array is shown here:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组如下所示：
- en: '[PRE155]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: File operations on ndarrays
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ndarrays上进行文件操作
- en: Most NumPy arrays are read in from files and, after processing, written out
    back to files.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数NumPy数组都是从文件中读取的，并在处理后写回到文件中。
- en: File operations with text files
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文本文件进行文件操作
- en: The key advantages of text files are that they are human-readable and compatible
    with any custom software.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件的主要优势是它们可读性强，并且与任何自定义软件兼容。
- en: 'Let''s start with the following random array:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下随机数组开始：
- en: '[PRE156]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This array contains the following data:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含以下数据：
- en: '[PRE157]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The `numpy.savetxt(...)` method saves the ndarray to disk in text format.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.savetxt(...)`方法以文本格式将ndarray保存到磁盘中。'
- en: 'The following example uses a `fmt=''%0.2lf''` format string and specifies a
    comma delimiter:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了`fmt='%0.2lf'`格式字符串，并指定了逗号分隔符：
- en: '[PRE158]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Let''s inspect the `arr.csv` file written out to disk in the current directory,
    as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查在当前目录中写出到磁盘的`arr.csv`文件，如下所示：
- en: '[PRE159]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The **comma-separated values** (**CSV**) file contains the following data:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值**（**CSV**）文件包含以下数据：'
- en: '[PRE160]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `numpy.loadtxt(...)` method loads an ndarray from text file to memory.
    Here, we explicitly specify the `delimiter='',''` parameter, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.loadtxt(...)`方法从文本文件加载ndarray到内存中。在这里，我们明确指定了`delimiter='',''`参数，如下所示：'
- en: '[PRE161]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And the ndarray read in from the text file contains the following data:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件中读入的ndarray包含以下数据：
- en: '[PRE162]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: File operations with binary files
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用二进制文件进行文件操作
- en: Binary files are far more efficient for computer processing—they save and load
    more quickly and are smaller than text files. However, their format may not be
    supported by other software.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件对计算机处理来说更有效率——它们保存和加载更快，比文本文件更小。然而，它们的格式可能不被其他软件支持。
- en: 'The `numpy.save(...)` method stores ndarrays in a binary format, as illustrated
    in the following code snippet:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.save(...)`方法以二进制格式存储ndarrays，如下面的代码片段所示：'
- en: '[PRE163]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The output of the `arr.npy` file is shown here:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.npy`文件的输出如下所示：'
- en: '![](img/B15029_03_01.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15029_03_01.jpg)'
- en: The `numpy.save(...)` method automatically assigns the `.npy` extension to binary
    files it creates.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.save(...)`方法会自动为创建的二进制文件分配`.npy`扩展名。'
- en: 'The `numpy.load(...)` method, shown in the following code snippet, is used
    for reading binary files:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.load(...)`方法如下面的代码片段所示，用于读取二进制文件：'
- en: '[PRE164]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The newly read-in ndarray is shown here:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 新读入的ndarray如下所示：
- en: '[PRE165]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Another advantage of having binary file formats is that data can be stored with
    extreme precision, especially when dealing with floating values, which is not
    always possible with text files since there is some loss of precision in certain
    cases.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有二进制文件格式的另一个优势是，数据可以以极高的精度存储，特别是在处理浮点值时，这在文本文件中并不总是可能，因为在某些情况下会有一些精度损失。
- en: 'Let''s check if the old `arr` ndarray and the newly read-in `arr_new` array
    match exactly, by running the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来检查旧的`arr` ndarray和新读入的`arr_new`数组是否完全匹配：
- en: '[PRE166]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This will generate the following array, containing `True` if the elements are
    equal and `False` otherwise:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下数组，如果元素相等则包含`True`，否则包含`False`：
- en: '[PRE167]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: So, we see that each element matches exactly.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到每个元素都完全匹配。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create matrices of any dimension in
    Python, how to access the matrices' elements, how to calculate basic linear algebra
    operations on matrices, and how to save and load matrices.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Python中创建任意维度的矩阵，如何访问矩阵的元素，如何在矩阵上计算基本的线性代数操作，以及如何保存和加载矩阵。
- en: Working with NumPy matrices is a principal operation for any data analysis since
    vector operations are machine-optimized and thus are much faster than operations
    on Python lists—usually between 5 and 100 times faster. Backtesting any algorithmic
    strategy typically consists of processing enormous matrices, and then the speed
    difference can translate to hours or days of saved time.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy矩阵是任何数据分析的主要操作，因为向量操作经过机器优化，因此比Python列表上的操作快得多——通常快5到100倍。回测任何算法策略通常包括处理巨大的矩阵，速度差异可以节省数小时甚至数天的时间。
- en: 'In the next chapter, we introduce the second most important library for data
    analysis: Pandas, built upon NumPy. NumPy provides support for data manipulations
    based upon DataFrames (a DataFrame is the Python version of an Excel worksheet—that
    is, a two-dimensional data structure where each column has its own type).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍数据分析中第二重要的库：Pandas，它是建立在NumPy之上的。NumPy提供了对基于数据框的数据操作的支持（数据框是Python版本的Excel工作表，即二维数据结构，其中每一列都有自己的类型）。

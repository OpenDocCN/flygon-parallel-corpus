- en: '*Chapter 4*: Data Manipulation and Analysis with pandas'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the Python `pandas` library built upon
    NumPy, which provides data manipulation and analysis methods for structured data
    frames. The name **pandas** is derived from **panel** **data**, an econometrics
    term for multidimensional structured datasets, according to the Wikipedia page
    on pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pandas` library contains two fundamental data structures to represent
    and manipulate structured rectangular datasets with a variety of indexing options:
    Series and DataFrames. Both use the index data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Most operations in the processing of financial data in Python are based upon
    DataFrames. A DataFrame is like an Excel worksheet – a two-dimensional table that
    may contain multiple time series stored in columns. Therefore, we recommend you
    execute all the examples in this chapter yourself in your environment to get practice
    with the syntax and to better know what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pandas Series, pandas DataFrames, and pandas Indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning essential operations on pandas DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring file operations with pandas DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python code used in this chapter is available in the `Chapter04/pandas.ipynb`
    notebook in the book's code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pandas Series, pandas DataFrames, and pandas Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas Series, pandas DataFrames, and pandas Indexes are the fundamental pandas
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: pandas.Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pandas.Series` data structure represents a one-dimensional series of homogenous
    values (integer values, string values, double values, and so on). Series are a
    type of list and can contain only a single list with an index. A Data Frame, on
    the other hand, is a collection of one or more series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `pandas.Series` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That series contains the index in the first column, and in the second column,
    the index''s corresponding values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify custom index names by specifying the `index` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a series by specifying the `index -> value` mapping via
    a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.Series.index` attribute lets us access the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The index is of type `pandas.Index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of the series can be accessed using the `pandas.Series.values` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign the series a name by modifying the `pandas.Series.name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples demonstrated numerous ways how to construct a pandas
    Series. Let's learn about DataFrames, a data structure that may contain multiple
    Series.
  prefs: []
  type: TYPE_NORMAL
- en: pandas.DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pandas.DataFrame` data structure is a collection of multiple `pandas.Series`
    objects of possibly different types indexed by the same common Index object.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of all statistical time series operations are performed on DataFrames
    and `pandas.DataFrame` is optimized for parallel super-fast processing of DataFrames,
    much faster than if the processing was done on separate series.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a DataFrame from a dictionary, where the key is the column name
    and the value of that key contains the data for the corresponding series/column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass the `index=` parameter here to label the indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructs the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.columns` attribute returns the names of the different
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is an `Index` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The indices can be accessed from the `pandas.DataFrame.index` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame also contains the `pandas.DataFrame.values` attribute, which
    returns the values contained in the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a new column to the DataFrame with specified values and the same
    index with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can assign names to the DataFrame's index and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can name the index by modifying the `pandas.DataFrame.index.name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And that yields the following updated DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns can be renamed using the `pandas.DataFrame.columns.name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The new DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples demonstrated how a DataFrame can be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: pandas.Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the `pandas.Series` and `pandas.DataFrame` data structures utilize the
    `pandas.Index` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many special types of `Index` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int64Index`: `Int64Index` contains integer index values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiIndex`: `MultiIndex` contains indices that are tuples used in hierarchical
    indexing, which we will explore in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatetimeIndex`: `DatetimeIndex`, which we have seen before, contains datetime
    index values for time series datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a `pandas.Index` object by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Index` objects are immutable and thus cannot be modified in place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we try to modify an element in an `Index` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Python warns us that we cannot manually modify the index object.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to construct series and DataFrames. Let's explore the
    essential operations done on DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Learning essential pandas.DataFrame operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the essential operations done on DataFrames. Knowing
    they exist and how to use them will save you an enormous amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing, selection, and filtering of DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas data structures are indexed by special `Index` objects (while `numpy.ndarrays`
    and Python list objects are only indexable by integers). The steps for this lesson
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s inspect the contents of the `df2` DataFrame created earlier in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select the Series of values in column `B` by performing the following
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can select multiple columns by passing a list of column names (somewhat
    similar to what we saw with `numpy.ndarrays`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Boolean selection with DataFrames by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This selects the following rows, which satisfy the provided condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.loc[...]` attribute lets us index rows instead of columns.
    The following selects the two rows `c` and `d`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following subset DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas DataFrames still support standard integer indexing through the `pandas.DataFrame.iloc[...]`
    attribute. We can select the first row by doing this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This selects the following single-row DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can modify the DataFrame with an operation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This updates the DataFrame to this new DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned how to index, select, and filter DataFrames.
    In the next section, we will learn how to drop rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping rows and columns from a DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dropping rows and columns from a DataFrame is a critical operation – it not
    only helps save the computer''s memory but also ensures that the DataFrame contains
    only logically needed information. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s display the current DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This DataFrame contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To drop the row at index `b`, we use the `pandas.DataFrame.drop(...)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields a new DataFrame without the row at index `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether the original DataFrame was changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that it was not, that is, `pandas.DataFrame.drop(...)` is
    not in place by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify the original DataFrame, we use the `inplace=` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The new in-place modified DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can drop multiple rows as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following new DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To drop columns instead of rows, we specify the additional `axis=` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us this new DataFrame with two dropped columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We have learned how to drop rows and columns in this section. In the next section,
    we will learn how to sort values and rand them.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting values and ranking the values' order within a DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a DataFrame with integer row indices, integer column names,
    and random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`pandas.DataFrame.sort_index(...)` sorts the DataFrame by index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also sort by column name values by specifying the `axis` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with the columns arranged in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the values in the DataFrame, we use the `pandas.DataFrame.sort_values(...)`
    method, which takes a `by=` parameter specifying which column(s) to sort by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame sorted by the values in the first column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.rank(...)` method yields a DataFrame containing the rank/order
    of values in each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output contains the rank (in ascending order) of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With this lesson completed, in the next section we will perform arithmetic operations
    on DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations on DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create two DataFrames for our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `df1` DataFrame contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the `df2` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the two DataFrames together. Note that they have different index
    values as well as different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a summation of elements if the index and column exists in both
    DataFrames, otherwise it is NaN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `pandas.DataFrame.add(...)` method with `fill_value=` to a value
    to be used instead of `NaN` (in this case `0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform arithmetic operations between DataFrames and Series as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this operation is the following (since the right-hand-side only
    had `colB`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Let's now learn how to merge and combine multiple DataFrames into a single Dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Merging and combining multiple DataFrames into a single DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating two DataFrames, `df1` and `df2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `df1` DataFrame has the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create `df2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `df2` DataFrame has the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.merge(...)` method joins/merges two DataFrames. The `left_index=`
    and `right_index=` parameters indicate that the merge should be performed on Index
    values in both DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'That yields the following merged DataFrame. The `_x` and `_y` suffixes are
    added to differentiate between left and right DataFrame columns with the same
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify custom suffixes with the `suffixes=` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following DataFrame with the suffixes we provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify the behavior of the join (outer, inner, left, or right join)
    using the `how=` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with `NaNs` for missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas DataFrames themselves have a `pandas.DataFrame.merge(...)` method that
    behaves the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative is the `pandas.DataFrame.join(...)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output of the join (left join by default) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.concat(...)` method combines DataFrames by concatenating rows together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following concatenated DataFrame with `NaNs` for missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can concatenate across columns by specifying the `axis=` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with additional columns from `df2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at hierarchical indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been dealing with Index objects that were a simple single value.
    Hierarchical indexing uses `MultiIndex` objects, which are tuples of multiple
    values per Index. This lets us create sub-DataFrames inside a single DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `MultiIndex` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the layout of the `MultiIndex` DataFrame that uses hierarchical indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign names to the `MultiIndex` object with the `pandas.MultiIndex.names`
    attribute – it requires a list of names with the same dimension as the dimensions
    of the `MultiIndex` DataFrame (in this case, two elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.reset_index(...)` method removes all indexing levels
    from a `MultiIndex` DataFrame by default, but can be used to remove one or more
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to the following integer indexed DataFrame and the `MultiIndex`
    values are added as columns in this DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.unstack(...)` method has similar behavior and pivots
    the inner level of indexing and converts them to columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the new DataFrame where the innermost indexing level `[1, 2,
    3]` becomes columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.stack(...)` method does the opposite of `unstack(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The output DataFrame is the original DataFrame with hierarchical indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the structure of the `MultiIndex` DataFrame. Note that we first
    call `pandas.DataFrame.stack(...)` to convert the columns `[A, B]` into a third
    level of indexing in the `MultiIndex` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a `MultiIndex` object with three levels of indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Now we will learn how to group operations in DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping operations in DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grouping operations in pandas generally follow the split-apply-combine process
    of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the data is split into groups based on one or more keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we apply necessary functions to these groups to compute the desired results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we combine them to build the transformed dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, grouping a single indexed DataFrame builds a hierarchical DataFrame.
    The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `pandas.DataFrame.reset_index(…)` method to remove all hierarchical
    indexing from our previous `df` DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following DataFrame with integer indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `pandas.DataFrame.groupby(...)` method to group the `A` and
    `B` columns by the `alpha` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following `DataFrameGroupBy` object, which we can subsequently
    operate on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `DataFrameGroupBy.describe(...)` method to collect summary descriptive
    statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following output where statistics for `A` and `B` are generated
    but grouped by the `alpha` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the `pandas.DataFrame.unstack(...)` method using the `DataFrameGroupBy.apply(...)`
    method, which accepts different functions and applies them to each group of the
    `grouped` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following hierarchical DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'There also exists the `DataFrameGroupBy.agg(...)` method, which accepts functions
    and aggregates each column for each group using that method. The next example
    aggregates using the `mean` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The output contains the mean for columns `A` and `B` grouped by values in `alpha`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar method is the `DataFrameGroupBy.transform(...)` method, with the
    only difference being that transform works on one column at a time and returns
    a sequence of values of the same length as the series, while apply can return
    any type of result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the Z score for columns `A` and `B`, which we explained in [*Chapter
    2*](B15029_02_Final_NM_ePub.xhtml#_idTextAnchor026), *Exploratory Data Analysis*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We will now learn how to transform values in DataFrames' axis indices.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming values in DataFrames' axis indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first reinspect the `df2` DataFrame that we will be using in these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'This contains the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rename the Index labels using the `pandas.DataFrame.index` attribute
    as we saw before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following transformed DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The `pandas.Index.map(...)` method applies functions to transform the Index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `map` function takes the first three characters
    of the name and sets that as the new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.rename(...)` method lets us transform both Index names
    and column names and accepts a dictionary mapping from the old name to the new
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting DataFrame has new labels on both axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: With this lesson learned, we will learn how to handle missing data in DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Handling missing data in DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Missing data is a common phenomenon in data science and can happen for multiple
    reasons – for example, technical error, human error, market holiday.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out missing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with missing data, the first option is to remove all observations
    with any missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code block modifies the `df2` DataFrame using the `pandas.DataFrame.at[...]`
    attribute and sets some values to `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.isnull(...)` method finds missing values in a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a DataFrame with `True` where values are missing and `False`
    otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.notnull(...)` method does the opposite (detects non-missing
    values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.DataFrame.dropna(...)` method allows us to drop rows with missing
    values. The additional `how=` parameter controls which rows get dropped. To drop
    rows that have `NaN` for all fields, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following modified DataFrame with the `Bet` row removed since
    that was the only one with all `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `how=` to `any` removes rows with any NaN values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following DataFrame with all non-NaN values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at how to fill in missing data.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in missing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second option when dealing with missing data is to fill in the missing values
    either with a value of our choice or using other valid values in the same column
    to duplicate/extrapolate the missing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by re-inspecting the `df2` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with some missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the `pandas.DataFrame.fillna(...)` method with the `method=''backfill''`
    and `inplace=True` arguments to use the `backfill` method to backward fill the
    missing values from the other values and change the DataFrame in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The new DataFrame contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The `NaN` value at `(Del,colB)` is because there were no observations after
    that row, so backfill could not be performed. That can be fixed instead with forward
    fill.
  prefs: []
  type: TYPE_NORMAL
- en: The transformation of DataFrames with functions and mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pandas DataFrame values can also be modified by passing functions and dictionary
    mappings that operate on one or more data values and generate new transformed
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `df2` DataFrame by adding a new column, `Category`, containing
    discrete text data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The new DataFrame contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.Series.map(...)` method accepts a dictionary containing a mapping
    from the old value to the new value and transforms the values. The following snippet
    changes the text values in `Category` to single characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The `pandas.DataFrame.applymap(...)` method allows us to apply functions to
    data values in a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `numpy.exp(...)` method, which calculates the
    exponential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a DataFrame containing exponential values of the original DataFrame''s
    values (except the `NaN` value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've learned how to transform DataFrames, we will see how to discretize
    and bucket values in DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Discretization/bucketing of DataFrame values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to achieve discretization is to create ranges of values and
    assign a single discrete label to all values that fall within a certain bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s generate a random valued ndarray for our use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'This contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.cut(...)` method can be used to discretize these values. The following
    code uses the `bins=` and `labels=[...]` arguments to bin the values into five
    discrete values with the labels provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the discrete values after the transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The `pandas.qcut(...)` method is similar but uses quartiles to bin the continuous
    values to discrete values so that each category has the same amount of observations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following builds five discrete bins using the `q=` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'And the quartile discretization yields the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block builds a pandas DataFrame consisting of the original
    continuous values as well as the categories generated from `cut` and `qcut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'This DataFrame allows side-by-side comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas.Categorical.categories` attribute provides us with the bucket ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the buckets/range of values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inspect the buckets for `qcut` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'They are slightly different from the previous buckets and they are shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at permuting and sampling DataFrame values to generate new
    DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Permuting and sampling DataFrame values to generate new DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permuting available datasets to generate new datasets and sampling datasets
    to either sub-sample (reduce the number of observations) or super-sample (increase
    the number of observations) are common operations in statistical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s generate a DataFrame of random values to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numpy.random.permutation(...)` method, when applied to a DataFrame, randomly
    shuffles along the Index axis and can be used to permute the rows in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following DataFrame with the rows randomly shuffled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `numpy.random.randint(...)` method to generate random integers
    within a certain range and then use the `pandas.DataFrame.iloc[...]` attribute
    to randomly sample with replacement (the same observation can be picked more than
    once) from our DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block picks out five rows randomly sampled with replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following randomly sub-sampled DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will look at exploring file operations with `pandas.DataFrames`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring file operations with pandas.DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas supports the persistence of DataFrames in both plain-text and binary
    formats. The common text formats are CSV and JSON files, the most used binary
    formats are Excel XLSX, HDF5, and pickle.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we focus on plain-text persistence.
  prefs: []
  type: TYPE_NORMAL
- en: CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSV** files (**comma-separated values** files) are data-exchange standard
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing CSV files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a pandas DataFrame to a CSV file is easily achievable using the `pandas.DataFrame.to_csv(...)`
    method. The `header=` parameter controls whether a header is written to the top
    of the file or not and the `index=` parameter controls whether the Index axis
    values are written to the file or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inspect the file written to disk using the following Linux command typed
    into the notebook. The `!` character instructs the notebook to run a shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The file contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Reading CSV files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reading a CSV file and building a pandas DataFrame from the data in it can
    be achieved using the `pandas.read_csv(...)` method. Here we will specify the
    character (although that is the default for `read_csv`), the `index_col=` parameter
    to specify which column to treat as the Index of the DataFrame, and the `nrows=`
    parameter to specify how many rows to read in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'This builds the following DataFrame, which is the same DataFrame that was written
    to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the `chunksize=` parameter, which reads in the specified
    number of lines at a time, which can help when exploring very large datasets contained
    in very large files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'That returns a pandas `TextFileReader` generator, which we can iterate through
    as needed instead of loading the entire file at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'We can force the generator to finish evaluation by wrapping it in a list and
    observe the entire DataFrame loaded in chunks of two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives us the following list of two-line blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: We will now look at how to explore file operations in JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON files are based upon data structures identical to Python dictionaries.
    This makes JSON files very convenient for many purposes including representing
    DataFrames as well as representing configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pandas.DataFrame.to_json(...)` method conveniently writes a DataFrame
    to a JSON file on disk. Here we write only the first four rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out the JSON file written to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following dictionary-style JSON file written to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading JSON files back into Pandas DataFrames is just as easy with the `pandas.read_json(...)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us back the original four-row DataFrame that was written to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Congrats on successfully completing this lesson!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to the pandas library, upon which the majority, if
    not all, time-series operations in Python are done. We have learned how to create
    a DataFrame, how to alter it, and how to persist it.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas DataFrames are principally for high-performance bulk data manipulation,
    selecting and reshaping data. They are the Python version of Excel worksheets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate visualization in Python using Matplotlib.
  prefs: []
  type: TYPE_NORMAL

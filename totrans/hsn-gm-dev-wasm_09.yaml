- en: Improved Particle Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *particle system* we developed in the previous chapter was a good start,
    but the effects you can create with it are rather bland. Our particles do not
    rotate or scale, they are not animated, and they are relatively consistent in
    the way they look over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to include several images in your build to
    make this project work. Make sure that you include the `/Chapter09/sprites/` folder
    from this project''s GitHub repository. If you would like to build the particle
    system tool from GitHub, the source for the tool is located in the `/Chapter09/advanced-particle-tool/`
    folder. If you haven''t downloaded the GitHub project yet, you can get it online
    here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want the most out of our particle system, we are going to need to add
    more features to it. In this chapter, we will be adding the following additional
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Particle scale over its lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animated particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color change over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for particle bursts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for looping and non-looping emitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying our HTML shell file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add some new inputs into the HTML shell file.
    We are going to copy the `basic_particle_shell.html` file to a new shell file
    that we will call `advanced_particle_shell.html`. We will be adding a second container
    class `div` element and a lot of new inputs to the HTML portion of the shell file
    between the original container and the `canvas` element. Here is what that new
    container element looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Scaling values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling a sprite means modifying that sprite's size by some multiple of its
    original size. For example, if we scale a 16 x 16 sprite by a scaling value of
    `2.0`, the sprite will render to the canvas as a 32 x 32 image. This new container
    starts with four input elements, as well as their labels, which tell the particle
    system how to scale the particles over their lifetimes. The `min_starting_scale`
    and `max_starting_scale` elements are the starting range scale of the particles.
    If you want the particle to always start with a scale of `1.0` (1 to 1 scale with
    the `.png` image size), you should put `1.0` in both of these fields. The actual
    starting scale value will be a randomly chosen value that falls between the two
    values you put in those fields. We haven't added any checks in this interface
    to verify that `max` is larger than `min`, so make sure that `max` is the same
    value or larger than the `min` value or this will break the emitter. The next
    two `input` elements are `min_end_scale` and `max_end_scale`. Like the starting
    scale values, the actual ending scale will be a randomly chosen value that falls
    between the two values we put in these fields. At any given point in a particle's
    lifetime, it will have a scale that is a value interpolated between the scale
    value assigned to the start of that particle's lifetime and the scale value at
    the end. So, if I start with a scale value of `1.0` and end with a scale value
    of `3.0`, when the lifetime of the particle is half over, the scale value of the
    particle will be `2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what those elements look like in the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Color-blending values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SDL has a function called `SDL_SetTextureColorMod` that is capable of modifying
    the red, green, and blue color channels of a texture. This function can only reduce
    color channel values, so using these values works best on grayscale images. The
    next two inputs in the HTML are `start_color` and `end_color`. These values will
    be used to modify the color channels of the particle over its lifetime. Each color
    channel (red, green, and blue) interpolated over the lifetime of the particle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what those elements look like in the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Particle burst
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, the particle systems we have worked with have emitted a
    consistent stream of particles. We may want a point in time within the lifetime
    of our particle system when a burst of particles is emitted all at once. The next
    two input elements are `burst_time` and `burst_particles`. The `burst_time` element
    allows values from `0.0` to `1.0`. This number represents the portion of the way
    through the particle emitter's lifetime at which the burst will occur. A value
    of `0.0` would mean that the burst would happen at the very beginning of the emitter's
    life cycle, `1.0` would occur at the very end, and `0.5` would occur halfway between.
    After the `burst_time` element is the `burst_particles` element. This element
    contains the number of particles that are emitted in the burst. Before adjusting
    this so that it's a large number, make sure that you set the `max_particles` input
    element to a value that can accommodate the burst. For instance, if you have a
    particle emitter that emits `20` particles per second and you have a maximum number
    of particles that is also `20` particles, adding a burst of any size will not
    be noticeable because there will not be enough inactive particles left in the
    particle pool for the burst to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what those elements look like in the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Looping the emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some emitters execute for a fixed time and then stop when that time has expired.
    An example of this kind of emitter is an explosion. Once an explosion effect has
    finished, we want it to end. A different type of emitter might loop, it would
    continue to execute until some other code stops the emitter. An example of this
    kind of emitter is our spaceship's engine exhaust. As long as our spaceship is
    accelerating, we would like to see a trail of particles being emitted out of the
    back of it. The next element in the HTML is a loop checkbox element. If clicked,
    the emitter will continue emitting, even after its lifetime is over. If there
    is a burst associated with this emitter, that burst will occur each time the emitter
    passes through that part of its loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the input element will look like in the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Aligning particle rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Rotation* can improve many particle effects. We are forced to pick and choose
    the values we want to use for the particle system in our project because, frankly,
    I could write an entire book on particle systems. Instead of having rotation value
    ranges, like we did earlier for the particle''s scale, we are going to have a
    single flag that allows the user to choose whether the particle system is going
    to align its rotation with the emission velocity vector. I find this to be a pleasant
    effect. The user will make this decision with an `id="align_rotation"` checkbox.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the HTML code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Emission time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *emission time* is the amount of time in milliseconds that our particle
    emitter will run for before it stops running, or loops if the user has ticked
    the loop checkbox. If the particle system loops, this value will only be noticeable
    for particle systems with a burst. This will cause the burst to happen each time
    the particle system goes through the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Animation frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to create a particle with a multi-frame animation, we can add the
    number of frames here. This feature assumes a *horizontal strip sprite sheet*
    and will divide the loaded image file evenly on the *x* axis. When this value
    is `1`, there is no animation because there is only a single frame. The frame
    time for the animation will be evenly divided across the individual particle's
    time to live. In other words, if you have a ten-frame animation and the particle
    lifetime is 1,000 milliseconds, each frame of the animation will display for 100
    milliseconds (1,000/10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our HTML, let's take a look at the JavaScript portion
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tool we are creating operates outside of the game we have been working on
    for several chapters now. Because of this, we are working on a new HTML shell
    file, and we will be writing a lot of JavaScript to integrate our user interface
    with the WebAssembly classes we will drop into our game later. Let's take the
    time to walk through all of the JavaScript functions we will need to add to our
    new HTML shell file.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript UpdateClick function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have modified the HTML, the next thing we need to do is modify the
    `UpdateClick()` JavaScript function to allow it to grab the new values out of
    the HTML elements and pass those values into the `Module.ccall` function call
    to `update_emitter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the new version of the `UpdateClick` function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have added new local variables into this JavaScript function
    that will store the values that we take from our new HTML elements. Retrieving
    the scaling values and coercing them into numbers to pass into `update_emitter`
    should look pretty familiar by now. Here is that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Coercing color values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, variable coercion is the process of turning one variable type
    into a different variable type. Because JavaScript is a weakly typed language,
    coercion is a little different from typecasting, which is analogous to variable
    coercion in strongly typed languages such as C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: The process of coercing our color values into `Integer` values is a two-step
    process. The values in these elements are strings that start with the `*#*` character,
    followed by a six-digit hexadecimal number. The first thing we need to do is remove
    that starting `#` character, as it will prevent us from parsing that string into
    an integer. We do this with a simple `substr` to get a substring (part of a string)
    of the value inside of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what that looks like for `start_color`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the string will always be seven characters long, but we only want
    the last six characters. We now have a hexadecimal representation of the starting
    color, but it is still a string variable. Now, we need to coerce this into an
    `Integer` value, and we have to tell the `parseInt` function to use base 16 (hexadecimal),
    so we will pass the value `16` into `parseInt` as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have coerced `start_color` into an integer, we will do the same
    for `end_color`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Additional variable coercions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the `start_color` and `end_color` coercions, the remaining coercions we
    must perform should feel familiar. We coerce the values in `burst_time`, `burst_particles`,
    `emit_time`, and `animation_frames` into `Number` variables. We coerce the checked
    values from `loop` and `align_rotation` into Boolean variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the remainder of the coercion code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the variable types and the new variables into our `Module.ccall`
    call to `update_emitter` in our WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the handleFiles function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last changes we need to make to our HTML shell file are modifications to
    the `handleFiles` function. These modifications effectively mirror the changes
    to the `UpdateClick` function. As you step through the code, you will see the
    same coercion replicated inside of `handleFiles`, and the `Module.ccall` to `add_emitter`
    will be updated with the same new parameter types and parameters. Here is the
    code for the latest version of the `handleFiles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our JavaScript code, we can begin making our changes to the
    WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Particle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have added the changes to our HTML shell file, we need to make some
    changes to our WebAssembly module to support these new parameters. We are going
    to work our way from the bottom up, starting with the `Particle` class. This class
    is not only useful for the tool we are building to design particle systems, but
    it is one of a few classes that, once we have completed it, we will be able to
    pull into our game, allowing us to add some beautiful looking effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the particle class definition looks like inside the `game.hpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: New attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to walk through the new attributes that were added to the `Particle`
    class definition and briefly discuss what each new attribute does. The first attribute
    that we added was `bool m_color_mod`. In our HTML, we don't have a checkbox for
    this value, so you may be wondering why there is one here. The reason is performance.
    If the user doesn't want a color modification, a call to `SDL_SetTextureColorMod`
    is a waste. If we have two white values passed into the `Particle` object, no
    interpolation or call to modify the value is necessary. We could check the start
    and end color each time to see if their values are `0xffffff`, but I felt that
    adding this flag would make the check clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning rotation attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `m_align_rotation` flag that follows is simply the flag we passed in from
    the checkbox. If this value is `true`, the particle will rotate itself to point
    in the direction it is moving. The `m_rotation` floating-point variable follows
    that. The attribute variable that holds the angle of the particle will be rotated
    based on the direction in which the particle is moving. Here is what these values
    look like in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Color attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The color mod flag I mentioned earlier makes the check on the next set of values
    a lot easier. Our hexadecimal color value that represented the red, green, and
    blue values in our HTML needed to be passed in as an integer so that it could
    be broken down into three 8-bit channels. Here is what those 8-bit color variables
    look like in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that these are all 8-bit unsigned integer variables that are
    declared with `Uint8`. When SDL performs color modification, it doesn't take in
    RGB values as a single variable; instead, it takes the values broken down into
    three 8-bit variables representing each of the individual channels. The `m_start_(color)`
    variable and the `m_end_(color)` variable will be interpolated based on the particle
    lifetime to get the `m_current_(color)` variable, which will be passed in as the
    channels to SDL when we do the color modification. Because we will be passing
    these values in as a single color variable from the JavaScript, the `Particle`
    constructor and the `Update` functions will need to perform bitwise operations
    to set these individual channel variables.
  prefs: []
  type: TYPE_NORMAL
- en: Animation attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next set of new attributes are all related to the new frame animation functionality
    in our `Particle`. Here are those attributes in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first attribute, `m_animation_frames`, is the value that's passed indirectly
    from the JavaScript. It tells the `Particle` class how many frames are in the
    sprite texture when it renders that texture to the canvas. The second attribute,
    `m_current_frame`, is used by the `Particle` class to keep track of which frame
    it should currently be rendering. The final attribute variable, `m_next_frame_ms`,
    tells the particle how many milliseconds are left before it must increment its
    current frame to display the next frame in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Size and scale attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next batch of attributes have to do with the size and scale of our particle.
    In the previous version of this code, we handled width and height in the `m_dest`
    rectangle. That is no longer practical, because the width and height (`w` and
    `h`) attributes of this rectangle will need to be modified to account for our
    current scale. Here are the new variables as they appear in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `m_width` and `m_height` attributes are now required to keep track of the
    original width and height of the particle, which haven been adjusted by the scale.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_start_scale` and `m_end_scale` attributes are values that are randomly
    picked between the `max` and `min` values we defined in the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_current_scale` attribute is the current scale that's used when calculating
    the `m_dest.w` and `m_dest.h` values when we render the particle. The current
    scale will be a value interpolated between the `m_start_scale` and `m_end_scale`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The source rectangle attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous version of the code, we didn''t have frame-animated particles.
    Because of this, we didn''t need to declare a source rectangle. If you want to
    render the entire texture to the canvas, you can pass in `NULL` in place of a
    source rectangle in the call to `SDL_RenderCopy`, which was what we were doing.
    Now that we have frame animations, we will pass in the location and the dimension
    of the part of the texture we render to the canvas. Because of this, we need to
    define a source rectangle attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Additional constructor parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have walked through all the new attributes, we will briefly discuss
    the changes that are required by the signatures of our functions. The `Particle`
    class constructor must add some new parameters that will support our align rotation,
    color modification, and frame animation functionality. Here is what the new signature
    for the constructor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `boolean` value called `align_rotation` tells the constructor to align the
    particle's rotation with the direction it is moving in. The `start_color` and
    `end_color` parameters are the color modification values if we are using the new
    color modification feature of our particle system. The last parameter, `animation_frames`,
    tells the particle system whether or not it is using a frame animation system,
    and if so, how many frames it will use.
  prefs: []
  type: TYPE_NORMAL
- en: The Update function's parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modifications to the signature for the `Update` function mirrors the changes
    we need to make to the constructor. There are a total of four new parameters that
    are used to influence the align rotation, the color modification system, and the
    frame animation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the new `Update` function signature looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Spawn function's parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last function signature that will need to be modified is the `Spawn` function.
    New values will be required to allow the `Emitter` to set the scale and rotation
    values when we spawn an individual particle. The `float start_scale` and `float
    end_scale` parameters are used to set the starting and ending scale multipliers
    when we generate the particle. The last parameter that''s added is `float rotation`,
    which represents the angle the particle is moving based on the *x* and *y* velocities
    of this particular particle. The following is the new version of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Changes to particle.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next set of changes we need to make to our `Particle` class are all changes
    to the functions we defined in the `particle.cpp` file. It is challenging to keep
    track of the changes made to these functions, so rather than discuss these changes,
    I will walk you through everything that is happening in each of the functions
    we discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Particle constructor logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logic in the new `Particle` constructor adds a lot of code to set the stage
    for our new features. Here is what the latest version of the function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first large batch of this code is used to set up the 8-bit color channels
    at the beginning and the end of our particle''s lifetime. If either the starting
    color or the ending color is not `0xffffff` (white), we will set up the starting
    and ending color channels using the `>>` operator (bit shift). Here is the code
    that sets the starting channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you aren''t familiar with the right bit shift operator `>>`, it takes an
    integer on the left-hand side of the operator and shifts the number of bits on
    the right-hand side of the operator. For example, a binary value of 15 (0000 1111)
    that''s shifted to the right by two bits will return a new value of 3 (0000 0011).
    When we shift to the right, any bits shifted to the right-hand side are lost,
    and bits with a value of 0 are moved in from the left-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67ed6961-92c2-4974-9df7-1b89a8846928.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Example of a right bit shift'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an RGB integer that comes in, each channel takes up 1 byte or 8
    bits. So, if R = **9**, G = **8**, and B = **7**, our integer value in hexadecimal
    would look like this: ff090807\. If we want to get to the R-value, we need to
    shift off the two bytes on the right-hand side of this 4 byte integer. Each byte
    is 8 bits, so we would take our RGB and use the `>>` operator to shift it by 16
    bits. We would then have the value `09`, which we could use to set our 8 bit red
    channel. When we do the green channel, we want the second byte from the right
    so that we can shift off 8 bits. Now, in our 4 byte integer, we would have 00000908\.
    Because we are moving this into an 8 bit integer, all the data not in the rightmost
    byte is lost in the assignment, so we end up with `08` in our green channel. Finally,
    the blue channel value is already in the rightmost byte. All we need to do with
    that is cast it to an 8 bit integer, so we lose all of the data that is not in
    the blue channel. The following is a diagram of the 32 bit color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df4baba9-146f-4ce0-af07-995d2c162b92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Color bits in a 32-bit integer'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to perform this same bit of magic on the end color channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we will do is set the current color channels to the starting
    color channels. We do this to create our particles with the colors' starting values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If both the starting and ending colors are white, we want to set the color
    mod flag to `false`, so we will not attempt to modify the color on this particle.
    We will initialize all the color channels to `255`. Here is the code that does
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After the code for managing the color modification is some initialization code,
    which sets the attribute variables in this object from the parameters passed into
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the source and destination rectangles based on the height and
    width passed in, as well as the number of animation frames for the particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines of code initialize the current frame to `0` and our active
    flag to `false`. All animations start on frame `0`, and a new particle is not
    active until it's spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the last few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Particle Update logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Particle` class'' `Update` function is run on each of the particles that
    were created by a previous PNG file upload. This function updates most of the
    values set in the constructor. The only exception is that the width and height
    dimensions of the particle must stay the same. This is because the constructor
    set these values based on the dimensions of the image file that was uploaded.
    I don''t feel the need to step through each part of this function, because of
    how similar it is to the constructor that we just walked through. Take a moment
    to look over the code to see how similar it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Particle Spawn function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Particle` class'' `Spawn` function is run by the `Emitter` whenever it
    needs to emit a new particle. When the emitter hits its next particle emission
    time, it searches through the particle pool, looking for a particle that is marked
    as not active. If it finds a particle, it calls the `Spawn` function on that particle,
    which activates the particle and sets several values specific to its run. All
    of the values that are passed into `Spawn` are changed by the `Emitter` every
    time the particle is emitted. Here is what the code for this function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Almost everything that's done in this function is initialization and is pretty
    straightforward. The first four lines initialize the position attribute (`m_position`),
    as well as the position with the destination rectangle (`m_dest`). Then, the velocity
    is set. The alpha always begins at `255`. The particle is activated, the time
    to live variable is activated, and the rotation is set. Color channels are reinitialized,
    the scale is initialized, and the current frame and the time to the next frame
    are set.
  prefs: []
  type: TYPE_NORMAL
- en: Particle Move function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Particle` class'' `Move` function is the function that not only changes
    the render position of the particle, but also adjusts all of the interpolated
    values between the beginning and the end of the particle''s life. Let''s step
    through the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the `Move` function calculates `time_pct`. That is a floating-point
    value that ranges from `0.0` - `1.0`. This variable starts with a value of `0.0`
    when the particle has just been spawned and hits `1.0` when the particle is ready
    to be deactivated. It gives us a floating-point value indicating where we are
    in the lifespan of this particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `m_ttl` attribute is the time to live for this particle in milliseconds,
    and `m_life_time` is the total lifespan of the particle. This value is useful
    for doing all of our interpolated value calculations inside of this `Move` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line returns the current frame, based on the value that is in
    `time_pct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, several lines adjust the x and y velocity of the particle based
    on the acceleration value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to set the `acc_adjusted` variable to a modified version of the `m_acceleration`
    variable based on the fraction of a second (`delta_time`) that has elapsed. After
    changing the `m_velocity` values, we need to use those velocity values to modify
    the position of the particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `m_alpha_fade` variable is `true`, the code will modify the alpha value,
    interpolating it to `0` by the time the `time_pct` value becomes `1.0`. If the
    `m_alpha_fade` flag is not set, the alpha value is set to `255` (full opacity).
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `m_color_mod` flag is `true`, we need to use `time_pct` to interpolate
    between the starting channel color value and the ending channel color value in
    order to find the current channel color value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After finding the interpolated value for each of the color channels, we need
    to use `time_pct` to interpolate the current scale. Then, we set our destination
    width and destination height based on that current scale value, and the dimensions
    of the source rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we will do is decrease the `m_ttl` variable (time to live) by
    `diff_time` (time since the previous frame render). If the time to live drops
    to or below `0`, we deactivate the particle, make it available in the particle
    pool, and stop it from rendering. If there is still some time to live, we set
    the `m_src.x` (source rectangle *x* value) to the proper location for the frame
    we want to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Particle Render function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final function in our `Particle` class is the `Render` function. The `Emitter`
    class calls this function for every active particle in the particle pool. The
    function sets the alpha and color channel values on the sprite texture used by
    the particle. It then checks the `m_align_rotation` flag to see if the texture
    needs to be copied to the back buffer using `SDL_RenderCopy` or `SDL_RederCopyEx`.
    The difference between these two render calls is that `SDL_RenderCopyEx` allows
    the copy to be rotated or flipped. Both of these functions use the `m_src` rectangle
    to determine a rectangle inside of the texture to copy. Both use the `m_dest`
    rectangle to determine the destination in the back buffer, where we copy our texture
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss how to modify our `Emitter` class to accommodate
    our improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Emitter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, when we discussed the `Emitter` class, it manages and
    emits particles. In a typical particle system, you may have many emitters. In
    our game, we will eventually allow for multiple emitters, but in this tool, we
    will keep to a single emitter for simplicity. We have four functions defined in
    the `Emitter` class, and we will be changing three of them. The only function
    that will not require a change is the `GetFreeParticle` function. If you don't
    remember, `GetFreeParticle` loops through `m_particle_pool` (the particle pool
    attribute) looking for particles that are not marked as active (`particle->m_active
    == false`). If it finds one, it returns that particle. If not, it returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The Emitter constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for the `Emitter` constructor will need to change to allow us to set
    the attributes that are required to support the new particle system functionality.
    The following is the code for the new `Emitter` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Enough of this code has changed that I feel it makes sense to walk through the
    entire function. The first two lines set the `color` attribute, and then activate
    the emitter by setting `m_active` to `true`. We set this active flag to `true`
    when an emitter is created or updated. If it is a looping emitter, the active
    flag will remain on indefinitely. If `Emitter` does not loop, the emitter will
    stop emitting when it reaches the end of its emit time, as set by the `emit_time_ms`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we do is set the minimum and maximum starting velocities. We
    have a little code in `Emitter` that makes sure that `max_starting_velocity` is
    greater than `min_starting_velocity`, but when we move this code into the game,
    we may choose to just set the values to whatever works well. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After we set the velocities, an SDL surface is created using a `sprite_file`
    string, which is the location of the file we have loaded into the WebAssembly
    virtual filesystem. If that file is not in the virtual filesystem, we print out
    an error message and exit the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the surface from the image file, we use that surface to create
    an SDL texture called `m_sprite_texture`, and then we use `SDL_FreeSurface` to
    destroy the memory that was used by the surface because it is no longer needed
    now that we have a texture. Then, we call `SDL_QueryTexture` to retrieve the width
    and the height of the sprite texture and use them to set the `Emitter` attributes
    `m_sprite_width` and `m_sprite_height`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is set the `m_max_particles` attribute and use
    that variable to initialize the particle pool. A `for` loop is used to push new
    particles to the back of the `std::vector` variable, `m_particle_pool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the particle pool, we use the parameters to set the emitter''s
    attributes for the old and the new particle system values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Emitter update logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Update` function of `Emitter` is similar to the constructor, but runs
    when `Emitter` already exists and needs to be updated. This function begins by
    setting all of the attribute variables on our `Emitter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After we set the attribute variables, we may need to either increase or decrease
    the size of the `m_particle_pool` vector (the particle pool). If the number of
    particles in our pool is greater than the new maximum number of particles, we
    can shrink the particle pool with a simple resize. If the particle pool is too
    small, we will need to loop over the code that creates new particles and adds
    those particles to the pool. We do this until the size of the pool matches the
    new maximum number of particles. Here is the code that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have resized the particle pool, we need to loop over every particle
    inside of that pool and run the `Update` function on each particle to make sure
    that every particle updates with the new attribute values. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Emitter Move function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final emitter function we need to update is the `Emitter::Move` function.
    This function determines whether it emits any new particles this frame, and if
    so, how many. It also uses randomization to pick many of the starting values of
    these particles, within the ranges passed in from our HTML. After spawning any
    new particles, the function will loop over the particle pool, moving and rendering
    any particles that are currently active. Here is the full code for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We will break this code into two parts to make it easier to understand. The
    first part of the `Move` function is responsible for spawning new particles when
    necessary. The second portion is responsible for moving and rendering any existing
    active particles. The particle spawning portion of this code is only run if `m_active`
    (the active flag) is `true`. The second part will run either way. When an emitter
    is deactivated, we don't want all of the particles that have been spawned by the
    emitter to disappear suddenly. Instead, we would like all the particles to continue
    to be moved and rendered until they have all been deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to walk through the code in smaller chunks to explain everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This first chunk of code checks the `m_active` attribute variable to make sure
    that the emitter is currently active. If it isn't, we can skip over the part of
    this function that spawns new particles. The next thing we do is subtract `diff_time`
    from the `m_next_emission` attribute. When the `m_next_emission` attribute hits
    or goes below `0`, another particle will spawn. We also subtract `diff_time` from
    `m_ttl`, which is the time to live attribute. Immediately after subtracting from
    `m_ttl`, we check the value in `m_ttl` to see if it is less than or equal to `0`.
    If time to live drops below `0`, we need to check to see whether this is a looping
    emitter by looking at the `m_loop` attribute. If it is a looping emitter, we reset
    the time to live variable, and we set the `m_has_burst` flag to `false`. If this
    is not a looping emitter, we deactivate the emitter by setting `m_active` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chunk of code has to do with emitting bursts of particles using
    the new burst feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The burst particle feature is new to our *advanced particle system*. We are
    using a nested `if` statement here. We could have put `&&` on the end of the first
    `if` and done this with one `if` statement, but I wanted to separate conditions
    to make it easier to understand. The outer `if` statement first checks to see
    if the `m_burst_particles` attribute (the number of burst particles) is greater
    than `0`. If it is, then this emitter uses the burst system and will need to create
    a burst of particles at the proper burst time. The next check in this outer `if`
    statement is to check if the burst has already run in this emitter. Because of
    the way we have designed this burst system, there can only be one burst per emission
    loop. So, if the `m_has_burst` attribute is `true`, then a burst will not run.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to the inner loop, we need to check to see whether we have passed
    the burst time for our emission. The `m_burst_time_pct` attribute holds a value
    between `0.0` and `1.0` that represents the decimal percentage of time through
    the emission at which the particle burst happens. The `m_ttl` variable holds the
    time to live in milliseconds for the emitter. If we divide `m_ttl` by `m_emit_loop_ms`
    (the emit time in milliseconds), we get an emit time countdown from `1.0` to `0.0`,
    where `0.0` means the emission is complete. The `m_burst_time_pct` variable goes
    in the other direction. A value of `0.6` means that the burst happens 60% of the
    way through our emission. Because the other side of this `if` statement is a countdown
    and the burst time counts up, we need to subtract `m_burst_time_pct` from `1.0`
    to make a proper comparison. If `(float)m_ttl / (float)m_emit_loop_ms` is less
    than `1.0 - m_burst_time_pct`, then we are ready for the burst. To make the burst
    happen, we first set `m_has_burst = true`. This will prevent the burst from happening
    multiple times in the same emission. We then subtract the number of burst particles,
    multiplied by the emission time in milliseconds, from `m_next_emission`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following few lines of code enter a `while` loop that emits particles as
    long as the next emission time is less than `0`. In the previous version of this
    code, we had an `if` statement here instead of a loop. This limited our particle
    system to emit no more than one particle per frame. That may work for some simple
    particle systems without a burst mode, but once you add a burst, you need to be
    able to emit many particles in a single frame. Let''s take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop checks to see whether `m_next_emission` is less than or equal
    to `0`. The line immediately after that adds `m_emission_time_ms` to the next
    emission. The effect of this is that if we had subtracted a large number from
    `m_next_emission` (like we did in our burst), this loop would allow us to emit
    multiple particles in a single run of our `Move` function. This means we can emit
    numerous particles in a single frame. What we do immediately after the addition
    to `m_next_emission` is get a free particle from our particle pool by making a
    call to `GetFreeParticle`. If we make the maximum number of particles too small,
    `GetFreeParticle` might run out of particles we can use and return `NULL`. If
    this is the case, we need to skip all of the steps that emit a new particle, which
    is why there is the `if` statement, which checks for a `NULL` particle.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know that we can spawn a particle, we need to grab a bunch of random
    values inside of the ranges we set in the HTML file. The C/C++ `rand()` function
    returns a random integer number. Most of the values we need are floating points.
    We will need to write a simple function called `get_random_float`. This function
    gets a random floating-point number with three decimal precision that falls between
    a min and a max value passed into it. We chose three-decimal precision based on
    our needs for this game. The function can be modified for higher precision if
    that is necessary later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that gets random values for use with the newly spawned particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The random values we get here are the distance from our emitter at which we
    will generate the particle, the velocity of the particle, the particle directional
    angle, and the starting and ending scale values. Because we would like the particle
    that is spawned at a given angle from the center of our emitter to also have the
    same directional velocity, we have assigned a random number to only the *x* values
    of `spawn_point` and `velocity_point`. We are going to use the same angle we generated
    randomly earlier to rotate both of those points. Here is the rotation code for
    those points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We generate the spawn points with a position relative to an origin of `0,0`.
    Because our emitter is probably not at `0,0`, we need to adjust the position of
    the spawn point by the values in the `m_position` point. Here is the code we use
    to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we do is spawn the particle with the values we randomly generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the function has completed spawning the particles for the current
    frame, the function will need to loop over the particle pool looking for active
    particles to move and render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will update the C++/WebAssembly functions we are calling
    from our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: External functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *advanced particle system* we are writing has two external functions that
    can be called from the JavaScript in our app. These functions, `add_emitter`,
    and `update_emitter`, are called to either insert or modify the particle system
    in the WebAssembly module. The `advanced_particle.cpp` file contains these functions,
    as well as the `main` function, which is called when the `Module` is loaded, and
    the `show_emission` function, which is called once per frame render. We will not
    need to modify the `main` and the `show_emission` functions from what we created
    for the basic particle system earlier in this chapter. We will, however, need
    to add the additional parameters we put into our JavaScript code to `add_emitter`
    and `update_emitter`. Also, we have created a utility function called `get_random_float`,
    which we use when spawning particles. Because this file contains all of our other
    C-style functions, I feel that `advanced_particle.cpp` is the best place to put
    this function as well.
  prefs: []
  type: TYPE_NORMAL
- en: Random floating-point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by discussing the new `get_random_float` function. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `%` (modulo operator) is used to make the random integer value between 0
    and whatever value you use after `%`. The modulo operator is a remainder operator.
    It returns the remainder of a division operation. For example, `13 % 10` would
    return 3, as would `23 % 10`. Taking `% 10` of any number will always result in
    a number between 0 and 9\. Modulo is useful in conjunction with `rand()` because
    it will result in a random number between 0 and the value after `%`. So, `rand()
    % 10` will result in a random number between 0 and 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_random_float` function takes in a minimum and maximum float value
    and generates a random number within that range. The first two lines take those
    float values, multiply them by 1,000, and cast them to an integer. Because `rand()`
    only works with integers, we need to simulate a precision value. Multiplying by
    1,000 gives us three-decimal precision. If, for instance, we want to generate
    a random number between 1.125 and 1.725, both of those values would be multiplied
    by 1,000, and we would use `rand()` to generate a random value between 1,125 and
    1,175:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, `rand()` only generates random integers, and using the `%` (modulo
    operator) alongside `rand()` will give you a number between `0` and the number
    that follows `%`. Because of this, we want to know the difference between our
    `int_min` and `int_max` values. If we subtract `int_min` from `int_max`, we will
    get a number that is this difference. We could potentially be thrown off if the
    calling code accidentally passes in a value for max that is smaller than the value
    for `int_min`, so we need a little bit of code to check whether `max` is smaller
    than `min`, and if it is, we need to switch those two values. Here is that `if`
    statement code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go ahead and get the difference between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following line of code, we get a random value between 0 and the value
    in `int_diff`. We are using the `?:` (ternary operator) to make sure that `int_diff`
    is not 0 before we execute `rand() % int_diff`. The reason for this is that `%`
    is a division remainder operator, so, like dividing by 0, executing `% 0` results
    in an exception. If there is no difference between our minimum and maximum values,
    we will return the minimum value. So, by using the ternary operator, we can set
    `int_rand` to 0 if `int_diff` is 0\. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add `int_min` to `int_rand`, and we have a random value between the
    `int_min` and `int_max` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is cast `int_rand` to a `float` and divide it
    by `1000.0`. This will return a floating-point value that falls between the `min`
    and `max` floating-point values that are passed into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Adding an emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `add_emitter` function is a pass-through that checks to see if there is
    an existing emitter and deletes it if there is. It then creates a new `Emitter`
    object, passing in all of the values we set in our HTML and passed through in
    JavaScript. The changes we need to make include adding the new parameters into
    the signature of the `add_emitter` function, and adding those same new parameters
    into the call to the `Emitter` constructor. In both the function signature and
    the constructor call, we will add a `/* new parameters */` comment that shows
    where old parameters end and the new ones begin. Here is the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Updating an emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The changes we made to the `update_emitter` function mirror those made in the
    `add_emitter` function. The primary differences between `add_emitter` and `update_emitter`
    are that `update_emitter` will not run if there is not an existing emitter, and
    instead of calling the `Emitter` constructor to create a new `Emitter`, it calls
    an existing emitter''s `Update` function. The `Update` function passes in all
    of the new values and most of the old ones (except for `char* file_name`). Just
    like with the changes we made to the `add_emitter` function, we have placed a
    `/* new parameters */` comment in the function signature and the call to the emitter
    `Update` function to show where the new parameters have been added. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will configure our *advance particle system tool* to
    create a new *particle emitter*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the particle emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you may be wondering when we are going to get back to writing
    the game. We built this *particle emitter configuration tool* for a few reasons.
    First of all, it is difficult to configure a particle system in compiled code.
    If we wanted to test a configuration for an emitter, we would need to recompile
    our values with every test, or we would need to write a data loader, and rerun
    the game after making configuration changes. Creating a tool that allows us to
    test different emitter configurations allows for faster (and more interesting)
    particle system creation.
  prefs: []
  type: TYPE_NORMAL
- en: HTML shell and WebAssembly module interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I also had an ulterior motive for creating a particle system configuration tool.
    It is possible that some of you may not be reading this book to learn game programming,
    per se. You may have purchased this book as a fun way to learn more about WebAssembly.
    Writing this tool was a fun way to learn more about the interaction between a
    WebAssembly module and the HTML and JavaScript that drives that module.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running the new tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all the parameters we would like, it is time to recompile the
    updated version of the configuration tool and start designing some particle systems.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building this from the GitHub project, you will need to run this
    compile command from the `/Chapter09/advanced-particle-tool/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following on the command line to compile the new configuration
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the web page in `emrun` or a web browser (if you are running a web server).
    It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a987a969-a6ae-4290-98c9-c7285611d17f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Screenshot of our particle system configuration tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start with a simple exhaust emitter. Make the following changes
    to the HTML values and click the Upload .png button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'min angle: -10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'max angle: 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'max particles: 500'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'emission rate: 50'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'radius: 0.5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'min start vel: 100.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'max start vel: 150.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'burst time: 0.7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'burst particles: 40'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'animation frames: 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have clicked the Upload .png button, navigate to the `ProjectileExpOrange.png`
    file in the image directory and open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of what the config tool looks like with our exhaust particle
    emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cbb0c41-5fb0-470b-a355-bd404fc6df29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Engine exhaust configuration'
  prefs: []
  type: TYPE_NORMAL
- en: I would encourage you to play around with the values until you get something
    you like. Whenever you change the values on the left-hand side of the page, you
    will need to click the Update Emitter button to see that new value reflected in
    the particle system on the right-hand side of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a particle emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an exhaust particle system, we are going to start adding the
    particle system code into the game to add some nice particle effects. I would
    like to have a particle system for the player and enemy ship exhaust. I would
    also like to add a particle system effect on top of the animated explosion we
    have to make it stand out.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we are going to do is copy the `particle.cpp` and `emitter.cpp`
    files into the main `Chapter09` directory. After that, we will need to add those
    class definitions to the `game.hpp` file, as well as to the `get_random_float`
    function prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to game.hpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first set of changes we need to make are to the `game.hpp` file. We need
    to add an `Emitter` class definition, a `Particle` class definition, and an external
    function prototype for `get_random_float`. We also need to add some new attributes
    to the `Ship` class. Here is the line we must add for the `get_random_float` prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Particle class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition for the `Particle` class that we must add to `game.hpp` is the
    same definition that we have for our advanced configuration tool. Because it is
    the same, we will not walk through what everything in the class does. If you don''t
    remember, please feel free to go back to the previous chapter as a reference.
    Here is the class definition code for `Particle` that we''ll be adding to `game.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Emitter class definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Emitter` class has a few additional attributes we have added that help
    the `Emitter` position itself relative to the game objects. There is a `Run` function
    that we do not need in the particle emitter configuration tool, but we will need
    it in the game code so that we can trigger the `Emitter` at any time. The `Update`
    function inside of `Emitter` and `Particle` are not necessary inside of the game,
    but we are going to leave them in there in order to not complicate the changes.
    The Emscripten dead code elimination logic should remove that code when it compiles
    the game anyway. Here is the new code for the `Emitter` class definition that
    we need to add to `games.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The code we added to the particle system configuration tool is surrounded by
    comments labeled `added`. Let me walk through what each of these new attributes
    and the new function does. Here are the first two added attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'These two values are adjustments, and are used to modify the position at which
    the emitter spawns particles. These variables are useful for small adjustments
    to particle positions relative to the position of an object the emitter is following.
    Here are the following three attributes that we have added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: These are pointers to the x, y, and rotational attributes of a parent object.
    If we set `Emitter->m_parent_rotation_ptr = &m_Rotation`, for instance, that pointer
    will point to the rotation of our parent object, and we will be able to access
    that value inside of our `Emitter` to adjust the rotation. The same holds true
    for `m_parent_x_ptr` and `m_parent_y_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have added a `Run` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This function allows a particle emitter, that is not looping, to be restarted.
    We will be using this for the `Explosion` emitter that we added to the `Ship`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to emitter.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have walked through the changes that we need to make to `game.hpp`,
    we are going to walk through all of the changes that we will make to the `emitter.cpp`
    file, function by function.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two changes to be made to the constructor function. First, we''ll
    add some initialization at the top that initializes all of the new pointers to
    `NULL`. We do not need these pointers in every emitter, so we can check against
    `NULL` to see when they are or are not used. Further down, we will modify the
    values that are passed into the constructors from degrees to radians. Here is
    what the function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The first changes are at the very top of this function, and set our new pointer
    attributes to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, we will check to see if these pointers are `NULL`, and if not, we will
    use `m_parent_rotation_ptr` to adjust the rotation angle of this emitter. We will
    use `m_parent_x_ptr` to change the x coordinate of the emitter, and we will use
    `m_parent_y_ptr` to adjust the y coordinate of this emitter. After that, we have
    the code that modifies the passed in minimum and maximum angles from degrees to
    radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The real reason we need to do this is that we are hardcoding the values we pass
    into the emitter. If we created a data loader, we could have done this conversion
    when the data loaded up. But, because we are taking these values straight out
    of our *particle emitter configuration tool* and hardcoding the values right into
    the call to the new emitter, we will either have to remember to do the conversion
    ourselves every time we change these values, or we will have to do it from within
    the constructor and the `Update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the Update function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Update` function is not likely to ever be called inside our game. Emscripten''s
    dead code removal process should eliminate it. However, we haven''t removed it
    from the `Emitter` class. If you think you may ever call this, you might want
    to change the `m_min_angle` and `m_max_angle` initialization to convert from degrees
    into radians, like we did in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Run function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the particle system configuration tool, we didn''t need a `Run` function
    because calling the `Update` function would run `Emitter`. The `Update` function
    is far too cumbersome to use inside our game. It uses a large number of configuration
    variables that we may not have access to when we call the function. All we want
    to do is set the emitter to active, reset the time to live, and the burst flag.
    Instead of calling `Update`, we create a small `Run` function to do what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Setting `m_active` to true makes the emitter active so that it can spawn new
    particles when calling the `Move` function. Resetting `m_ttl` to `m_emit_loop_ms`
    makes sure that the time to live does not automatically shut the emitter down
    the next time it calls the `Move` function. Setting `m_has_burst = false` makes
    sure that, if there is a particle burst that must occur somewhere in the emission,
    it will run.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the Move function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new version of the `Move` function will need to be able to modify its position
    based on a parent position and rotate its defined position based on the parent''s
    rotation. It will also need to be able to make minor adjustments using `m_x_adjustment`
    and `m_y_adjustment`. Here is the new version of `Move` in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code is the same as it was in earlier versions. Let''s walk through
    the differences. First, we need to rotate this entire particle system if there
    is a rotated parent object. We will use this for the exhaust particle system that
    we will be adding to the spaceship objects. This exhaust has to be positioned
    relative to the spaceship. To do that, we need to take the position and rotate
    it. We also need to add the parent''s rotation to the existing emission angle.
    Here is the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top, we create a new `Point` object called `rotated_position`. If the
    `m_parent_rotation_ptr` is not `NULL`, we add that value to the emission angle
    we calculated earlier. We will copy the values of `m_position` into `rotated_position`
    and `Rotate` that position by the parent''s rotation. Later, we will check whether
    `m_parent_rotation_ptr` is not `NULL`, and if not, we will use `rotated_position`
    relative to the parent object''s position to calculate the location of the emitter.
    The following is an `if` statement that checks whether `m_parent_rotation_ptr
    == NULL`. If it is null, the first part of this `if` block does what would have
    been done earlier. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `if` statement was checking whether `m_parent_rotation_ptr == NULL`,
    we don''t want to use the rotated version of the particle system''s position.
    That block defaulted to using the `m_position` attribute unmodified. If `m_parent_rotation_ptr`
    is not `NULL`, we will run the following `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses a rotated version of `m_position`. Next, we want to see whether
    `m_parent_x_ptr` and `m_parent_y_ptr` are not `NULL`. If they aren''t, then we
    need to add the parent''s position to the `spawn_point` using these values. Here
    is that piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of code we will add to the `Move` function is the micro adjustment
    to the spawn point. Sometimes, particle systems need a little bit of tweaking
    before rotation to have them look just right. Therefore, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The values of `m_x_adjustment` and `m_y_adjustment` default to `0`, so if you
    want to use these values, they will need to be set sometime after creating the
    emitter.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to ship.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we are going to do is modify the `ship.cpp` file to make use
    of two new particle emitters. We want a particle emitter for the ship's exhaust,
    and one to improve the ship's explosion. We are going to need to make changes
    to the `Ship` class' constructor, the `Ship` class' `Acceleration` function, and
    the `Ship` class' `Render` function.
  prefs: []
  type: TYPE_NORMAL
- en: The Ship class' constructor function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Ship` class'' constructor function has changed most of the functions inside
    of the `Ship` class. We are not only initializing new attributes  we also need
    to set the parent and adjustment values on the emitters. Here is the new code
    for the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The first several lines haven''t changed from the old version. The new changes
    start when we initialize `m_Accelerating` to `false`. After that, we set up the
    exhaust emitter, first creating a new emitter, then setting the parent values
    and the adjustment values, and finally, we set it to inactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'All of those values that are passed into the `Emitter` function come straight
    from the *particle system configuration tool*. We have to add them manually into
    our function call. If we were working on a large project, this would not be very
    scalable. We would probably have the configuration tool create some sort of data
    file (for example, JSON or XML). But for expediency, we have simply hardcoded
    these values based on what we had inside of the configuration tool. Unfortunately,
    the values are not in the same order that they appear inside of the tool. You
    will need to look at the signature of the `Emitter` constructor to make sure that
    you put the values in the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, `sprite_file`, is the location of your file in the virtual
    filesystem. That file is not automatically included in your project. You will
    need to make sure that it is in the right location. We put the file in the `sprites`
    directory and use the following flag when we run Emscripten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our `Exhaust` emitter, we create an `Explosion` emitter with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of the `m_Explode` emitter is similar to the `m_Exhaust` emitter,
    but we have different values that we pass into the emitter based on what we created
    in the *particle emitter configuration tool*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/803f6bd8-9791-4cb1-aa82-2aaff1deb10f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Explosion configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As with the `m_Exhaust` emitter, we will need to set all of the parent pointer
    variables and deactivate the emitter. Unlike `m_Exhaust`, we won't need to make
    fine adjustments using the `m_x_adjustment` and `m_y_adjustment` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The Ship class' Acceleration function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to run the exhaust emitter only when the ship is accelerating. To do
    this, we will need to set a flag inside of our ship''s `Accelerate` function.
    Here is the new version of the acceleration function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The only change is the addition of the line at the beginning, which sets `m_Accelerating`
    to `true`. When we are rendering the ship, we can check this flag and start or
    stop the emitter based on the value inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The Ship class' Render function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final changes to the `Ship` class are in the ship''s `Render` function.
    Inside this function, we will need to add code that moves and renders the two
    new particle systems, as well as code that will turn the exhaust on if the ship
    is accelerating, and off if it isn''t. Here is the new version of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the first block of added code, near the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `Move` function on an emitter both moves and renders all of
    the particles inside of the particle system. It also spawns new particles if it
    is time for the emitter to do that. At the very end of the function, there is
    code to handle the exhaust emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This code checks to see if the `m_Accelerating` flag is `false`. If it is, we
    deactivate the exhaust emitter. If the ship is accelerating, we set the `m_active`
    flag to `true`. We don't make a call to the `Run` function, because we are doing
    this every frame, and we don't want to start the *time to live* over on that emitter
    every time we loop. The last line sets `m_Accelerating` to `false`. We do this
    because we don't have anywhere in our code that detects when a ship stops accelerating.
    If the ship is accelerating, that flag will be set back to `true` before we get
    to this point in the code. If not, it will stay set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to projectile_pool.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t need to change a lot inside of the `ProjectilePool` class. In fact,
    we only need to make two changes to one function. The `MoveProjectiles` function
    inside of the `ProjectilePool` class performs all of the collision detection between
    projectiles and our two ships. If a ship is destroyed, we run the `m_Explode`
    particle emitter on that ship. That will require two new lines of code inside
    of the hit test condition for each of the ships. Here is the new version of the
    `MoveProjectiles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The two lines of code I have added are for the calls to `player->m_Explode->Run();`
    and `enemy->m_Explode->Run();`. These lines execute when the player's ship or
    the enemy ship collides with one of the projectiles and is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last change we need to make in order to add exhaust and explosion particle
    systems is to the `main.cpp` file. This change requires the addition of a single
    function, `get_random_float`. We discussed this function earlier. It is a way
    for our particle emitter to get random floating-point values that fall between
    a minimum and a maximum value. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the new particle_system.html file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have made all the necessary changes to our files, we can go ahead
    and use Emscripten to compile and test the new version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building this from the GitHub project, you will need to run this
    compile command from the `/Chapter09/` directory. The previous compile was done
    from inside the `/Chapter09/advanced-particle-tool/` directory, so make sure that
    you are in the right place when you run this command; otherwise, it won't have
    the files it needs to build the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Taking it further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not be writing a data export tool for configuration. This chapter is
    too long as it is. When you are creating particle systems, you can spend a near
    infinite amount of time tweaking them to your liking. Particle systems can have
    a tremendous number of configuration parameters. You can even have Bzier curves
    for movement, rotation, and scaling. Some advanced particle systems have particles
    that emit other particles. There is no limit to the complexity that we can add
    to a particle system, but there is a limit to the number of pages I can have in
    this book, so I encourage you to take this system and add to it until you get
    the results you want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have made it through a very long, information-packed chapter.
    In the last two chapters, we discussed what particle systems are and why they
    are used. We learned how to add files to, and how to access, the WebAssembly virtual
    filesystem. We learned how to create more advanced interactions between the HTML
    shell file and the WebAssembly module. We then constructed a more advanced particle
    emitter configuration tool with a lot more functionality. After constructing some
    nice looking particle systems in the tool, we took the data and code and used
    it to construct two new particle emitters inside the game we have been building.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing and building AI for our enemy spaceship.
  prefs: []
  type: TYPE_NORMAL

- en: AI and Steering Behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game we have been writing is loosely based on the computer game *Spacewar!*
    If you are not familiar with *Spacewar!*, it was the first computer game ever
    written. It originally ran on a PDP-1 owned by MIT and was written by an MIT student
    named Steve Russel, in 1962\. Back then, just getting a computer to display graphical
    output was difficult enough. *Spacewar!*, as well as many other early game systems
    such as *Pong*, were designed to be played by more than one person. That was because
    programming a computer to behave like a human was a very difficult thing. That
    is still somewhat true today, although more processing power and data allows modern
    **Artificial Intelligence** (**AI**) algorithms to behave much more intelligently
    than they have in the past.
  prefs: []
  type: TYPE_NORMAL
- en: Because our game is a single-player web game, we do not have the benefit of
    using a second human intelligence to power our enemy spaceship. Before this chapter,
    we used an AI stub to allow our enemy spaceship to move and shoot randomly around
    our gameplay area. That might have worked for us up to this point, but now we
    want our player to feel threatened by the enemy ship. It should be intelligent
    enough to fight and kill our player in one-on-one combat.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter10/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    at: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the concept of AI and Game AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding obstacles to the game for avoidance AI (and increasing the canvas size)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new collision detection for a line of sight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the concept of a **Finite State Machine** (**FSM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the concept of **autonomous agents**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the concept of **steering behaviors**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding force fields to our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FSMs and steering behaviors to create an AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning our AI to allow the enemy spaceship to navigate obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Game AI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many early video games avoided AI because it was a very challenging problem
    with the hardware available at the time. For example, *Space Invaders*, *Galaga*,
    and *Galaxian* all had aliens that moved in specific non-intelligent patterns.
    Early Atari games were either two-player games (*Pong*) or had the player interact
    with a non-intelligent environment (*Breakout*). One early and successful attempt
    at a game with AI was *PAC-MAN*. Each ghost in *PAC-MAN* had a different personality
    and would behave a little differently in the same circumstances. *PAC-MAN* also
    used a simple **Finite State Machine** (**FSM**). That is a type of AI where the
    AI behaves differently under different environmental circumstances. If the player
    ate a *power pellet* in *PAC-MAN*, the ghosts would all turn blue and suddenly
    become edible in a *hunter-becomes-the-hunted* reversal of fortune. While the
    ghosts could be eaten, it would have been easier for the programmers to have those
    ghosts continue to hunt down *PAC-MAN*, as they did before. That would make the
    ghosts look either stupid or suicidal, which is the kind of behavior we would
    like to avoid when writing an AI.
  prefs: []
  type: TYPE_NORMAL
- en: In 1950, the mathematical and computer genius Alan Turing proposed a benchmark
    for AI that he called "the imitation game," but it would later become known as
    *the Turing test*. He proposed a game having human players interacting with humans
    and computers through a text-based interface. If a computer could convince a human
    that they were interacting with another human and not a computer, that computer
    should be considered to be intelligent. Personally, I feel as if we passed this
    threshold a long time ago. But when machines threaten human intelligence, humans
    like to move the goal posts.
  prefs: []
  type: TYPE_NORMAL
- en: In 1964, Joseph Weizenbaum of MIT wrote a chatbot named ELIZA. ELIZA pretended
    to be a psychotherapist at the other end of a chat system. ELIZA managed to fool
    quite a few people into believing it was a real psychotherapist, which is probably
    as much a commentary on psychotherapy as it is on human intelligence. Anyone looking
    for a chatbot would easily be able to tell ELIZA was not human, but Joesph Weizenbaum
    was quite disturbed by the number of people willing to pour their heart out to
    ELIZA as if she were a real person.
  prefs: []
  type: TYPE_NORMAL
- en: The Loebner prize is an annual Turing test competition, where a series of judges
    who are AI experts have yet to be fooled by a chatbot. Today, many programs routinely
    fool people into thinking they are humans. I would argue that needing a human
    expert to determine whether an AI has passed the Turing test is moving the goalposts
    significantly from where Alan Turing initially set them. I believe if we had a
    large sample of non-experts that were fooled by a chatbot, we should consider
    that chatbot to be intelligent, but I digress.
  prefs: []
  type: TYPE_NORMAL
- en: My point in bringing up the Turing test is that a Game AI needs to pass a modified
    form of the Turing test. When you write a Game AI, your goal is to convince the
    player that they are not playing a game against a total loser. All Game AIs are,
    more or less, lame. For the time being, we will not be able to create a Game AI
    version of IBM's Watson (the AI that defeated Ken Jennings in Jeopardy). Like
    everything in a computer game, we need to learn to work within the constraints
    of the system. And for a web-based game, those constraints may be significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, it is OK to cheat, but don''t get caught. Many Game AIs cheat. An
    RTS may be able to see through the fog of war. An AI poker player may be able
    to peak at the player''s cards. One way we are going to cheat is to allow our
    enemy spaceship to accelerate in directions that are not allowed for the player.
    The key to cheating with a Game AI is to make sure that the behavior or movement
    does not look unnatural. Many years ago, I wrote an online version of the card
    game Spades, playable at [https://www.icardgames.com/spades.html](https://www.icardgames.com/spades.html).
    The player''s partner AI is allowed to peak at everyone''s cards. One common complaint
    I get is that the player''s partner will frequently trump the player''s high card.
    That is because the AI is looking not at who is currently winning the trick, but
    whether the player that will follow him can win the trick if he does not play
    a higher card than the one the player lead with. Not realizing this behavior is
    helping them, I get many frustrated complaints from players about the partner
    trumping their card. This is an example of a case where the player is actually
    doing better because of the AI but leaves with the impression that the AI is making
    stupid choices. My point is, Game AI is all about impression. Remember what the
    AI host said in the HBO television show *Westworld*, when one of the characters
    asked her if she was real: "If you can''t tell, does it really matter?"'
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous agents versus top-down AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1986, Craig Reynolds created a well-regarded AI program called *Boids* (a
    combination of bird and droids). This program created a fascinating bird-like
    flocking behavior, where little triangles moved around the screen in ways that
    remind the observer of flocking birds or fish. When the environment had obstacles,
    the boids broke up to steer around the obstacles and rejoin later. A collision
    between two flocks will usually end up in the flocks joining up and moving on.
    The Boids algorithm is an implementation of autonomous agents for AI. Each individual
    boid makes decisions based on a few simple rules and its immediate environment.
    That results in what is called **emergent behavior**, which is behavior that looks
    as if it was designed from the top down, but is not. The irony is that a top-down-implemented
    AI frequently looks less intelligent than allowing the individual agents to make
    their own decisions. It's a little like the old Soviet top-down command-and-control
    economy, versus a capitalist economy where individuals make decisions based on
    their immediate environment. In games, as in economics, you can also have a mixed
    system, where a top-down AI can send messages to autonomous agents giving them
    new goals or instructions. In the game we are writing, we have a single enemy
    spaceship, so the decision to manage AI from the top down or through autonomous
    agents does not really matter much, but because you may choose to expand the game
    in the future to support multiple enemies and their AIs, our agent will manage
    itself autonomously.
  prefs: []
  type: TYPE_NORMAL
- en: What is an FSM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FSMs are very common in games. As I mentioned before, PAC-MAN was an early game
    that had an AI with more than one state. The ghosts could be in a *hunt* or a
    *flee* state based on a global condition flipped when PAC-MAN would eat a large
    dot on the screen, commonly known as a **power pellet**. A specific state in an
    FSM can be either a global condition or, in the case of a **finite** **state automaton**,
    could be a state that is specific to any *autonomous agent* within the game. Managing
    behaviors or state transitions could be as simple as using a switch statement,
    or they could be more complicated systems that load and unload AI modules when
    different states are triggered. A state may choose when a transition to a different
    state occurs, or state transitions could be managed by the game from the top down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FSM we will be writing for this game will be very basic. It will be a simple
    switch that will perform different behaviors based on the current state. The enemy
    ship''s position relative to the player and whether there is an unobstructed line
    of sight between them will be used to determine the transitions between states.
    Our FSM will have four basic states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WANDER`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`APPROACH`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ATTACK`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FLEE`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The conditions for entering these states are as follows: If the enemy ship
    does not have an unobstructed path to the player ship, it enters a `WANDER` state
    where it wanders around the gameplay area checking periodically for a line of
    sight path to the player. Once there is a line-of-sight path to the player, the
    enemy ship will enter an `APPROACH` state, where it will attempt to get close
    enough to the player ship to attack it. Once the player is close enough, it enters
    the `ATTACK` state, where it fires on the player ship. If the player ship gets
    too close to the enemy ship, the enemy will `FLEE`, attempting to increase the
    distance between itself and the player ship.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing steering behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steering behaviors are a force-based approach to navigation toward, or away
    from, specific points while avoiding obstacles. It was originally discussed in
    a presentation by Craig Reynolds (the *Boids* guy) at the **Game Developer's Conference**
    (**GDC**) in 1999, and the original paper discussing steering behaviors can be
    found online at [https://www.red3d.com/cwr/steer/gdc99/](https://www.red3d.com/cwr/steer/gdc99/).
    Unlike pathfinding algorithms such as the A* or Dijkstra's algorithms, steering
    behaviors are tactical in nature. They involve a goal position and forces drawing
    the autonomous agent toward its goal, while simultaneously pushing the agent away
    from obstacles you would like it to avoid. In the case of our game, the enemy
    spaceship is our autonomous agent that will be using the steering behaviors. It
    will be in pursuit of the player spaceship while avoiding obstacles including
    asteroids, projectiles, and the star in the center of the gameplay area. We will
    be discussing several steering behaviors in detail in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: The seek behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **seek steering behavior** is a force that points the agent (the enemy
    ship) at the desired target and moves the agent in the direction of that target.
    This behavior attempts to hit a maximum velocity and reach its target in the minimum
    amount of time. The seek behavior assumes that the position it is seeking is static
    and is not subject to change over time. This diagram shows what the seek behavior
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be373985-1267-43f6-841e-9c1153c9ed8e.png)'
  prefs: []
  type: TYPE_IMG
- en: The seek behavior
  prefs: []
  type: TYPE_NORMAL
- en: The flee behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flee** is a steering behavior that is the opposite of seek behavior. This
    behavior takes a position or game object and attempts to get as far away from
    it as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fleeing is the behavior you demonstrate when chased by a bear. Your only goal
    is to put as much distance between you and the current location of that bear as
    you can. So, the next time a bear chases you, stop for a moment and think, "*Wow,
    my brain is currently implementing a version of the autonomous agent steering
    behavior known as* flee." Or you could keep running. The choice is yours. Take
    a look at the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d89bc0a-4783-4973-bc39-b34168a6135a.png)'
  prefs: []
  type: TYPE_IMG
- en: An artist's rendering of a bear eating the reader
  prefs: []
  type: TYPE_NORMAL
- en: 'You can program the flee behavior by negating the direction of the seek behavior.
    In other words, if the seek behavior produces a direction vector force of 1,1,
    the flee steering behavior would produce a direction vector force of -1,-1\. This
    diagram depicts flee behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95bd7792-7a2a-4e73-933c-633246625c9a.png)'
  prefs: []
  type: TYPE_IMG
- en: The flee behavior
  prefs: []
  type: TYPE_NORMAL
- en: The arrival behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with the seek steering behavior is that it won''t be satisfied
    until the agent reaches its target position. The other problem is that because
    it tries to reach that position at maximum speed, it will almost always overshoot
    it, resulting in oscillation around the desired destination. The **arrival steering
    behavior** allows the seek behavior to end gracefully by beginning to decelerate
    when it is in an **arrival range** of the target. As long as the target destination
    is within the desired range, the arrival behavior will reduce movement toward
    the seek position. The following diagram depicts the arrival behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d63484e-dbbf-4987-bf91-7a9593292d5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrival behavior
  prefs: []
  type: TYPE_NORMAL
- en: The pursuit behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We build the **pursuit behavior** on top of the seek behavior. Where the seek
    behavior is looking to reach a static point, the pursuit behavior assumes that
    the target is moving. Because our agent (the enemy ship) wishes to track down
    and destroy the player, which is usually moving, we will be using the pursuit
    steering behavior. The pursuit behavior looks at the velocity of the target. Instead
    of heading directly for the target's current position, it attempts to locate an
    intercept point where it predicts the target will be. Seek reminds me a little
    of a children's soccer team. All the kids run to where the ball is, not where
    the ball will be. Because of this, everyone on the soccer field runs as one large
    unit up and down the field. Someday, they will grow up and incorporate the pursuit
    steering behavior into their soccer strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram depicts the pursuit behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f81489f-b09c-4751-8fec-6a85da83f056.png)'
  prefs: []
  type: TYPE_IMG
- en: The pursuit behavior
  prefs: []
  type: TYPE_NORMAL
- en: The evade behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Evade** is to *pursuit* as *flee* is to *seek*. Like pursuit, the **evade
    steering behavior** is attempting to determine where the obstacle you are avoiding
    will be, and moves as far away from that point as possible. In other words, it
    takes the same point we found in the pursuit behavior and then runs away from
    that point. The next diagram depicts the evade behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5951f12c-2eef-48be-a168-5863dad8d48c.png)'
  prefs: []
  type: TYPE_IMG
- en: The evade behavior
  prefs: []
  type: TYPE_NORMAL
- en: Obstacle avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Obstacle avoidance** differs from the flee and evade behaviors in that an
    obstacle may potentially be in the path of our agent as it attempts to seek out
    a new location. Flee and evade cause us to try to move as far away as possible
    from the location of the object or the position we are fleeing, whereas obstacle
    avoidance is more about avoiding a collision with an obstacle on the way to a
    target. In the case of our game, obstacles to be avoided include asteroids, projectiles,
    and the star in the center of the game screen. Obstacle avoidance usually involves
    only seeking to avoid the most threatening (nearest) obstacle. Our agent has a
    given lookahead distance that looks in the direction it is moving. If a line between
    its current position and the maximum lookahead in the direction it is moving collides
    with an object, obstacle avoidance requires we adjust our direction. The area
    we avoid should be larger than the collision detection area for the obstacle to
    give us a buffer to avoid, especially because the asteroids and projectiles are
    moving in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram depicts obstacle avoidance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/558939ad-5d41-4b33-8c37-29b4547e82c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Obstacle avoidance
  prefs: []
  type: TYPE_NORMAL
- en: The wander behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wander** is a state in which the agent is moving somewhat randomly around
    the game screen. Causing the direction of the enemy spaceship to rotate every
    frame randomly would result in very erratic behavior. Instead, there should be
    a random number of milliseconds (200-2,000) where the spaceship maintains its
    current direction. When the ship has gone the random number of milliseconds, it
    should randomly choose to turn left or turn right, but should have a biased chance
    of turning in the same direction it did the previous time, with that bias decreasing
    each time it chooses the same direction after the initial choice. That will give
    the wandering behavior a little more consistency and appear a little less jittery.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See how the wander behavior chooses a point at random and moves toward it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93567b37-73f1-48e3-ade1-8b5e61fdb426.png)'
  prefs: []
  type: TYPE_IMG
- en: Demonstrating the wander behavior
  prefs: []
  type: TYPE_NORMAL
- en: Combining forces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our earlier discussion of the reader using the flee behavior to escape a bear
    was oversimplified. It assumes you are fleeing that bear in a large open field.
    If you are running from a bear in the woods, you will both need to avoid running
    into the trees and get yourself as far away from that bear as you can. You have
    to blend these two activities seamlessly, or get eaten by that bear. If we want
    the enemy ship to pursue or flee from the player ship, and avoid obstacles at
    the same time, we are going to need to combine steering forces. The highest priority
    always has to be avoiding obstacles. If you run into a tree while fleeing that
    bear, he's still going to end up eating you. The general strategy our steering
    behavior will implement is finding a line-of-sight vector with the player ship.
    There are several opportunities we have to find a line of sight, because of the
    way our game level wraps around on itself. If that line of sight is longer than
    a chosen distance, we will wander until our distance is short enough that we can
    pursue the player while shooting at him. While we are wandering, we will want
    to combine any wandering force with forces that help the enemy ship avoid hitting
    asteroids or the star. Once we are in pursuit, we will want to continue to avoid
    obstacles. There will be a large arrival area where our ship will slow to a stop
    and fire in the direction of the player. Once the player closes in a specific
    range, our ship will flee.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying game.hpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get too far into our new code, I want to make some quick changes
    to the `game.hpp` file to add some functionality we will be using later in this
    chapter. The first thing I want to add near the top of the `game.hpp` file is
    a few macros that will let us quickly convert from an angle in degrees to radians,
    and also from radians to degrees. I find myself doing this a lot when using SDL
    because SDL, for some reason, wants rotations in degrees, and every other library
    out there uses radians. So, let''s go ahead and add the following two lines of
    code somewhere near the top of the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be changing the size of our canvas from 320 x 200 to 800 x 600\. To
    make this easy to switch later, let''s go ahead and define a few macros we will
    use for the canvas width and height and put those somewhere near the top of the
    `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rand()` function, used in C and C++ to get a random number, can only be
    used to return an integer. I will be adding a function to get a random number
    that falls between minimum and maximum floating-point values, so I will need to
    add an external reference to that function to our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also starting to need circular references in our classes. The `FiniteStateMachine`
    class will need a reference to the `EnemyShip` class, and the `EnemyShip` class
    will need a reference to the `FiniteStateMachine` class. Unfortunately, we need
    to define one of these classes before the other. In the past, we have been able
    to define our classes in a specific order to avoid this problem, but now we will
    need a group of class declarations before any of our class definitions. That will
    allow the compiler to know that a class will be defined before the definition.
    Add this block of class declarations somewhere near the top of the `game.hpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add an enumeration to keep track of our FSM states. As I mentioned
    earlier, there are four states in our FSM: `APPROACH`, `ATTACK`, `FLEE`, and `WANDER`.
    We will define these states in an enumeration called `FSM_STATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One of the first classes we defined in `game.hpp` was the `Point` class. This
    class has *x* and *y* attributes and a few useful functions such as `Rotate`.
    We are going to need to greatly expand the use of this class and what it can do.
    So much so, that calling it *point* is no longer accurate. I would prefer to call
    this class *vector*, because we will be using it for vector mathematics from now
    on. The only problem I have with this name is that it might be confusing because
    we are using the `std::vector` to handle array-like data in our code. Because
    of this, I have decided we will call this class `Vector2D`. We will be greatly
    expanding the functionality of this class to include a function that will normalize
    the vector (that is, change its magnitude to 1). We need two functions that will
    determine the magnitude and the square magnitude of the vector. We will need a
    function that will project the vector on to another vector (to help us in the
    line-of-sight collision detection). We will need to be able to find the dot product
    of two vectors. We will also need to be able to find the rotation of a given vector.
    In addition to these new functions, we will overload operators on our vectors
    to allow us to add vectors, subtract vectors, and multiply and divide vectors
    by a scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and delete the `Point` class definition, and replace that code with
    the new `Vector2D` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new collision detection will also need a `Range` class. A range represents
    a range of values between a minimum and a maximum. We can add two ranges together.
    We can find the overlap between the two ranges. We can extend a range by a given
    scalar value, or we can clamp a value to fall inside a given range. Here is what
    the new `Range` class definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you scroll down to the `Collider` class, we will be adding a few new functions
    and a few new attributes. I want to use our `Collider` class to support new steering
    behaviors. So, we will need some steering-specific attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`m_SteeringRadius` is a new attribute that is a multiple of `m_Radius`. For
    steering purposes, we want to make sure that the sizes of the objects we want
    to avoid is smaller than the object''s collision area. That creates an additional
    margin for our steering behavior that will help us to avoid these objects. The
    `m_SteeringRadiusSQ` attribute is the square of the steering radius. That will
    keep us from having to square the steering radius for collision checks over and
    over again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to add the declarations of the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `SteeringLineTest` and `SteeringRecTest` functions will differ from a real
    line and rectangle collision test. The steering rectangle test (`SterringRectTest`)
    will be used to limit the number of objects we must test for object avoidance
    purposes. We only want our AI to worry about objects that are within a box around
    the enemy ship that is 200 x 200 pixels. That will be useful if we have a large
    number of objects to test. To keep this test fast, we will be checking against
    the objects in that box as if they are points and will not take the object's radius
    into account. The `SteeringLineTest` function will be testing to see whether the
    steering radius of this collider hits a line defined by two points in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our game, we have not added a hit point system. A single collision with
    an asteroid or projectile results in instant death. That makes the game really
    short. To increase the game time, we will be adding shields to our ship. These
    shields will cause the player or enemy to be invulnerable for as long as the shields
    are active. While you use the shields, they will slowly turn from green to red,
    and at some point, they will stop working. That will all depend on the amount
    of time that you have used the shields during the given game to encourage the
    player to use the shields only when needed. Here is what the `Shield` class definition
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Shield` class definition, we will need to add a class definition
    for our `Asteroid` class. Unlike the Atari game *Asteroids*, we cannot destroy
    these asteroids by shooting them. They are meant to be obstacles, but we will
    (for the moment) allow the asteroids to be destroyed if the player crashes into
    them with their shields active. They will move slowly around the game screen and
    provide obstacles for the player and the enemy AI to navigate during gameplay.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also be adding a big star to the center of the gameplay area. That
    is similar to the black hole that was in the center of the game *Spacewar!*, which
    we are loosely basing our game on. This star will eventually provide gravitational
    attraction to make the game a bit more challenging. We will be animating a star
    image and adding some solar flares using particle emitters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make a few modifications to our `Ship` class. Here is what it will
    look like once we finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we will do is add the `m_Shield` attribute, which is a pointer
    to a `Shield` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we use separate variables for the *x* direction and *y* direction,
    as well as different variables for the *x* velocity and *y* velocity, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove all of that code and swap it for some `Vector2D` objects, representing
    the direction vector and the velocity vector, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to prevent code duplication between our enemy ship and our player
    ship, we will add a `Shoot()` function that will fire a projectile from the ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next class we need to modify is our `EnemyShip` class. We need to add a
    string with the filename of our `Shield` sprite. We also need to remove our old
    `AIStub()` function and replace it with a pointer to our FSM. Here is what the
    new version of the `EnemyShip` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A significant new class we will be adding is the `FiniteStateMachine` class.
    This class will be doing all of the AI''s heavy lifting. Here is the class definition
    that you must add to `game.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of this class definition are nine constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first two constants, `c_AttackDistSq` and `c_FleeDistSq`, are the values
    used by the FSM to determine whether it will change states into either the `ATTACK`
    or `FLEE` states; `c_MinRandomTurnMS` and `c_RandTurnMS` are both constants used
    by the `WANDER` state to determine when the AI will next decide to change directions
    randomly. The `c_ShieldDist` constant is the distance at which an obstacle will
    cause the AI to turn on its shields. The `c_AvoidDist` constant gives us the range
    at which an AI makes corrective adjustments to avoid an object. The `c_StarAvoidDistSQ`
    function is the distance at which the AI will make course adjustments to avoid
    the star in the center of the play area. The `c_ObstacleAvoidForce` constant is
    a steering force added to the velocity of an object to help it avoid obstacles,
    and `c_StarAvoidForce` is a similar force used to avoid the star.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the constants, we have a block of attributes that are used by the FSM
    to make state-based decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `m_CurrentState` attribute holds the current state of our FSM. The `m_Ship`
    attribute contains a pointer to the ship. Right now, this is always the single
    enemy ship that is in our game, but in the future, you may want to add multiple
    enemy ships. The `m_HasLOS` attribute is a `boolean` that keeps track of whether
    our ship currently has an unobstructed line of sight with the player. The `m_LastTurnLeft`
    attribute is a `boolean` that keeps track of the direction, in which the ship
    last turned while in the `WANDER` state. The `m_SameTurnPct` attribute is the
    percentage chance that the ship will continue turning in the same direction while
    in the `WANDER` state. The `m_NextTurnMS` attribute is the number of milliseconds
    a ship in the `WANDER` state will continue before making a directional heading
    change. The `m_CheckCycle` variable is used to break up the AI into performing
    different checks during different frame rendering cycles. If you have your AI
    do all the work between each frame render each time, you could potentially bog
    the system down. It is usually better practice to break the AI into multiple parts
    and only do part of the logic with each frame render. The `m_DesiredRotation`
    attribute is the desired heading of the AI, and, finally, `m_PlayerDistSQ` is
    the squared distance between the enemy ship and the player ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify the `Projectile` class to use a `Vector2D` to keep track
    of the velocity instead of two floating-point variables, `m_VX` and `m_VY`. Here
    is the new version of the `Projectile` class after the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `game.hpp` file, we should add a few external references
    to our new list of asteroids, and the star that will be going in the center of
    the gameplay area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have taken care of the modifications we need to make to our `game.hpp`
    file, let's get into the obstacles we are adding.
  prefs: []
  type: TYPE_NORMAL
- en: Adding obstacles to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, we do not have anything in our game for an AI to steer around. We
    need to add some obstacles that can get in the way of our enemy ship. We want
    our enemy ship to do what it can to avoid these obstacles while attempting to
    approach and attack our player''s spaceship. The first thing we will add is a
    big star right in the middle of our gameplay area. We can animate this star and
    add some nice particle effects for the star''s corona. In the last section, we
    created the class definition of this star in the `game.hpp` file and it looked
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to create a new file called `star.cpp` to accompany this class
    definition. In it, we should define our constructor and the `Move` and `Render`
    functions. As with all of our CPP files, the first thing we do is include the
    `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have a few `#define` directives that we use to define the sprite
    files we will be using to render our star and the flare particle systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is fairly long, but a lot of it should look pretty familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor starts by inheriting the `Collider` constructor passing it
    a radius of `32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It then creates a sprite texture to use when rendering the star. This part
    of the code should look pretty familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting up the sprite texture, the constructor sets some of the attributes,
    including radius and position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it adds emitters to the `m_FlareList` vector. These will be some solar
    flare particle systems. I used the particle system configuration tool to come
    up with the values we are creating in these emitters. You can play with the values
    if you like, but I felt that these values created a nice-looking flare effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The star''s `Move` function is pretty simple. It cycles through the eight frames
    of the star''s animation sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The star''s `Render` function is a little bit more complicated because it needs
    to loop over the flare emitters, and move them before it renders the star''s sprite
    texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the `asteroid.cpp` file. That will hold the function
    definitions for our `Asteroid` class. Here is our class definition for `Asteroid`
    in the `games.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `asteroid.cpp` file, we will need to define the `Asteroid` constructor,
    the `Move` function, the `Render` function, and the `Explode` function. At the
    top of the `asteroid.cpp` file, we will need to `#include` the `game.hpp` file
    and define the location of our asteroid sprite file in the virtual filesystem.
    Here are what those first few lines of code look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function we will define is our constructor. Here is the constructor
    function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the constructor calls the parent constructor in the `Collider`
    class, passing in a radius for the `Collider` of `8.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the constructor loads and initializes the sprite texture using
    SDL, a process we should all be pretty familiar with by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define our explosion emitter. This emitter will be activated if our
    asteroid is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we create a second emitter that will shoot out little chunks of
    rock when our asteroid is destroyed. That is meant to compliment the `m_Explosion`
    emitter, and it will run at the same time as the asteroid explodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last several lines set the starting values for our asteroid''s attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function we will be defining is the `Move` function. Here is what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first batch of code dealing with `m_NextFrameTime` and `m_CurrentFrame`
    simply alternates between the sprite frames based on the amount of time that has
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we update the position based on the time delta and current velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `WrapPosition` function is called. This function moves our asteroid
    back to the right side of the screen if it went off the screen to the left, and
    moves it to the top if it goes off the bottom. Whenever an asteroid moves off
    the screen in a given direction, its position will be wrapped around to the other
    side of the gameplay area.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `Move` function, we define the `Asteroid Render` function. The complete
    function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two lines move the explosion emitter and the chunks emitter. If the
    asteroid has not been destroyed, these functions will not do anything. If the
    asteroid has been destroyed, the functions will run the particle emitter. These
    emitters do not loop, so when their emission time is up, they will stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we check to see whether the asteroid is alive, and if it is not,
    we exit this function. The reason we do this after moving our emitters is that
    we must continue to run the emitter after an asteroid is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we do in this function is to render our asteroid sprite texture,
    a process that should look pretty familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function in our `asteroid.cpp` file is the `Explode` function. This
    function will run when an asteroid is destroyed. The function will run our two
    emitters, which were designed to create an explosion effect. It will also set
    the asteroid''s alive flag to `false`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our game obstacles, let's look into what it will take
    to create some shields for our spaceships.
  prefs: []
  type: TYPE_NORMAL
- en: Adding force fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, in our game, our spaceships are destroyed with a single collision.
    This ends up creating a game that is over very quickly. It would be nice to have
    a force field to prevent the ship''s destruction when a collision is about to
    occur. This will also give our AI something else it can do in its bag of tricks.
    When the shields are up, there will be a little force-field animation surrounding
    the spaceship that is using it. There is a time limit to shield use. That will
    prevent the player or the AI from keeping the shield up for the entire game. While
    the shield is active, the color of the shields will transition from green to red.
    The closer the color gets to red, the closer the shields are to running out of
    power. Every time the shields get hit, the player or AI''s shields will have additional
    time taken off them. We have already created the class definition inside of the
    `game.hpp` file. Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To accompany this class definition, we will need a `shield.cpp` file, where
    we can define all of the functions used by this class. The first function we will
    define inside our `shield.cpp` file is the `Shield` constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shield` constructor function will call the `Collider` constructor function,
    with a radius of `12.0`. That is a larger radius than the ship''s radius. We will
    want this `Collider` to be hit instead of the ship, if the shields are active.
    The first block of code in this constructor function sets the starting values
    for the attributes of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we set `m_ttl` to `25500`. That is the time you can use the shield
    in milliseconds. That amounts to 25.5 seconds. I wanted it to be a multiple of
    255, so that the green color will transition from 255 to 0, based on the time
    left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the red color will transition from 0 to 255, also based on the
    time left. After that, we create the shield''s sprite texture in the standard
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After the constructor, we need to define our `Move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the shield is not active, this function does not do anything. If it is active,
    the `m_ttl` parameter is decremented based on the number of milliseconds passed
    since the last frame. Then, we increment the current frame if the proper number
    of milliseconds has elapsed. If the shield's time left drops below 0, the shields
    are deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined our `Move` function, we will define our `Render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `Move` function, the `Render` function does not do anything if the
    active flag is false. We calculate the colors based on the time left using the
    following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'That will smoothly transition the color of our shields from green to red. We
    use a call to `SDL_SetTextureColorMod` to set the sprite texture''s color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Everything else in the `Shield::Render` function is pretty standard and should
    look very familiar by now.
  prefs: []
  type: TYPE_NORMAL
- en: More collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the modifications we need to make to our `Collider` class.
    As we discussed earlier, our AI will be implementing steering behaviors. These
    steering behaviors will require some new attributes and functions in our `Collider`
    class. Here is what the new `Collider` class is going to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three new functions, two of them are for steering. One of the functions,
    `WrapPosition()`, will be used to wrap objects moving off the screen in one direction
    so that they reappear on the other side of the game screen. Let''s open up `collider.cpp`
    and take a look. The first thing we need to change is the constructor function.
    Here is what the new version of the constructor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines are the only modifications. You will notice that we set the
    `m_SteeringRadius` attribute to `1.5` times the `m_Radius` value. This additional
    buffer space is to prevent our enemy ship from getting too close to the asteroids,
    especially if they are moving. This factor effectively makes the steering behavior
    more wary of collisions with asteroids. The multiple of `1.5` was chosen somewhat
    arbitrarily because it worked well when I tested it. If you would like your AI
    to be less concerned with asteroid collisions and more likely to pursue the player
    by putting itself in danger, you could reduce this value, maybe to something like
    `1.1`. You could also increase this value to make the AI even more wary of asteroids.
    Setting the value too high will result in an AI that is too timid. Setting it
    too low will have it pursue the player under almost any circumstance, mimicking
    the infamous words of Admiral David Farragut during the Battle of Mobile Bay,
    "*Damn the torpedoesâ€”full speed ahead!*"
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to add the new function, `SteeringLineText`, to `collider.cpp`.
    This new function will do circle-line collision detection between a line connecting
    our enemy ship and our player, and detect all of the asteroids and projectiles
    our ship could hit along that path. It is a line-of-sight test to determine whether
    there is a clear path to the player from our position. Circle-line collision detection
    is somewhat complicated, compared to circle-circle or rectangle-rectangle collision
    detection. I borrowed heavily from a solution I created on [embed.com](https://www.embed.com)
    at the following address: [https://www.embed.com/typescript-games/multiple-type-collision-detection.html](https://www.embed.com/typescript-games/multiple-type-collision-detection.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Circle-line collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in determining whether a circle and line collide is the simplest:
    Check whether either of the endpoints of your line falls within the circle''s
    radius. That is done by a simple distance check using the Pythagorean theorem.
    If the distance between one of the points and the center of our circle is less
    than the radius, the line is inside the circle. Here is a diagram of a point falling
    inside the radius of the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c99d9002-ff23-456d-b5ab-d208f912ad0e.png)'
  prefs: []
  type: TYPE_IMG
- en: The line's p2 point falls inside the circle radius
  prefs: []
  type: TYPE_NORMAL
- en: If either point falls within the radius of the circle, we know that the line
    and the circle collide. If neither point falls within the radius of the circle,
    we are not done. Then what we will need to do is find the closest point on the
    line to the center of the circle. Let me digress for a moment to get a little
    more technical. Technically, all lines are infinite. When we have two points and
    draw a â€œlineâ€ in between those points, it is a line segment. To find the closest
    point between a line and our circle, we are going to need to talk about something
    called **vector projection**.
  prefs: []
  type: TYPE_NORMAL
- en: Vector projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector projection is a little bit complicated. If you project a given vector
    b on to vector *a*, you get a scalar multiple of vector *a* (we will call this
    scalar multiple *c*), where you can add a vector perpendicular to vector *ca*
    to get vector *b*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an example of projecting vector *b* onto vector *a*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adfb214e-e771-4370-9e06-b044e38c8569.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of projecting vector b onto vector a
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at this is that a projection of vector b on to vector a
    gives us the closest point to the end point of vector b that is on a line segment,
    as defined by any scalar multiple of vector a. You may be wondering what this
    has to do with detecting a collision between a circle and a line. Well, if we
    assume that vector b represents the position of the center point of our circle,
    we can figure out what the closest point on our line is to the center point of
    that circle. We then test for a collision between the point we found with our
    projection and the center of the circle. See how vector projection can be used
    to determine the closest point on a line to a circle in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f4d3c2b-0da5-4bb8-8dcc-486984f5aca3.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that projecting the vector onto our line gives us the closest point on
    the line to the circle
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another potential problem you have to look at. The projection onto
    vector a might give you a value for c (the scalar multiple) that is greater than
    1\. If this is the case, it might be that our line collides with the circle beyond
    our ending point. Because of this, we will also need to do some range checks to
    see whether we are past the end of our line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee892c81-12aa-41a8-b496-7c1cc2cf8132.png)'
  prefs: []
  type: TYPE_IMG
- en: Projecting the circle's vector on to our line gives us the closest point that
    is passed the range of our line segment
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I have explained what vector projection is, let''s take a look at
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier, the first thing we do is test the start and end point
    distance to the location of this `Collider` object. If the distance squared is
    less than the steering radius squared for either of the points, we know that the
    line collides with our steering radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If neither point falls inside the circle, we will need to test against the
    projection. We will need to turn the line segment into a vector that goes through
    the origin. To do this, we will need to subtract the starting point from the ending
    point, and we will also need to adjust the position of the circle by the same
    amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make sure that the point closest to the collider is still on the
    line segment. That can be done with a simple range test against the starting and
    ending *x* and *y* values. If both the *x* and *y* coordinates fall into our range,
    we know that the point must lie somewhere on the line segment. If it does not,
    we know that the line does not collide with the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have not returned with a `false` value at this point, we know what the
    nearest point to the collider is on our line segment. Now we can test the distance
    from that point to our collider to see whether it is close enough to collide with
    our steering radius; if it is, we return `true`, and if it is not, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The Vector2D class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I mentioned earlier that we needed to scrap our old `Point` class in favor
    of something that has a lot more functionality. The new `Vector2D` class will
    add several new functions to the `Point` class we were using earlier. Let''s take
    another look at the function definition we have inside our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Unlike points, vectors have a magnitude. Because it is faster to calculate,
    we will also add a squared magnitude, `MagSQ`, function. Vectors can be normalized,
    which means they can be modified to have a magnitude of 1\. We discussed vector
    projection earlier, and we have created a `Project` function to allow us to do
    that. Finding the dot product of two vectors is a very useful operation in games.
    The dot product of two normalized vectors is a scalar value that ranges between
    1 and -1, depending on the angle between those two vectors. The value is 1 if
    the vectors point in the same direction, -1 if they point in the opposite direction,
    and 0 if the two vectors are perpendicular to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The dot product of two normalized vectors is the same as the cosine of the angle
    between those two normalized vectors. Getting the dot product of any two vectors,
    *a* and *b*, gives you the (magnitude of *a*) * (magnitude of *b*) * cosine (angle
    between *a* and *b*). The reason we normalize these vectors first is to set the
    magnitude of *a* and the magnitude of *b* to 1, which causes our normalized dot
    product to return the cosine of the angle between vectors *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a `FindAngle` function that will tell us the directional angle
    of this function. We will overload many operators to allow for easier vector manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at `vector.cpp` in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two functions are constructors, and they are essentially the same
    as the constructors that were in the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have our overloaded operators. That allows us to add, subtract,
    multiply, and divide vectors easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Rotate` function is one of the few functions that existed on the `Point`
    class. It has not changed from the `Point` class version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Normalize` function changes the magnitude of the vector to a value of
    1\. It does this by determining the magnitude of the vector and dividing the *x*
    and *y* value by that magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Project` function uses the dot product of the normalized angles and multiplies
    that scalar value by the vector to determine the new projected vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Dot` product function is actually a dot product of the normalized vectors.
    That gives us information on the angle between the two vectors. We are normalizing
    first because we are using this dot product only in our vector projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindAngle` function uses the inverse tangent to find the angle in radians
    between two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The final two functions get the vector''s magnitude and squared magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Writing an FSM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the tools we need in our `Collider` and `Vector2D` classes,
    we can build our FSM. The `FiniteStateMachine` class will manage our AI. Our FSM
    will have four states: `SEEK`, `FLEE`, `ATTACK`, and `WANDER`. It will implement
    steering behaviors and add an avoid force whenever it is trying to navigate through
    obstacles such as asteroids. The AI will also need to check whether the enemy
    ship should raise or lower its shields. Let''s take a second look at the definition
    of the `FiniteStateMachine` class as we have defined it in our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s spend a little time going through all of the functions that we will
    define in our `finite_state_machine.cpp` file. The constructor function at the
    beginning of this file does not do anything complicated. It does some basic initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'After the constructor, we have four state functions defined: `SeekState`, `FleeState`,
    `WanderState`, and `AttackState`. The first of these four states causes our enemy
    ship to seek out a specific point in our gameplay area. That point will either
    be calculated in our `Move` function or inside our `AttackState` function. Here
    is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing the function does is determine what angle the ship should point
    at to seek out the destination point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the `rotate_direction` value we calculated, the AI makes a decision
    to rotate the ship left or right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why there are two calls to `RotateRight()` and `RotateLeft()`.
    Well, that is a bit of AI cheating. I want the enemy spaceship to rotate and accelerate
    faster than the player, so we call the `Rotate` functions twice and the `Accelerate`
    function four times. The amount of cheating you do depends on personal preference,
    and how obvious your cheating is. Generally speaking, you want your AI to be challenging,
    but not too challenging. An AI that is obviously cheating will upset the player.
    Above all, if you cheat, make sure you don't get caught!
  prefs: []
  type: TYPE_NORMAL
- en: 'After the rotations, we end the function with the four calls to `Accelerate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'After our `SEEK` state, we need to define the function we run when we are in
    the `FLEE` state. The `FLEE` state is the opposite of the `SEEK` state in that
    the AI is trying to get as far away from the flee position as possible. We do
    a little less cheating in our version of the `FLEE` state, but this can be changed
    based on personal taste:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WANDER` state is a state in which the AI wanders around the gameplay area.
    This state runs if the enemy ship does not have an unobstructed line of sight
    to the player ship. The AI will wander around the gameplay area looking for an
    unobstructed path to the player. In the `WANDER` state, the ship is more likely
    to continue turning in the direction it turned the last time than choose a new
    direction. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Attack` state calls the `Seek` state while shooting at the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To know where to go when we seek and attack, we could point our enemy ship
    directly at the player''s current location. It would be better if we could predict
    where the player''s ship will be by the time we get there. We have a `PredictPosition`
    function that will predict where the player will be, using its current velocity.
    Here is our `PredictPosition` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: That is only a guess, and it is imperfect. We use this function to predict both
    where we will seek and where we will attack. If we were seeking the player, we
    would probably want to predict the distance the player will move, which will be
    about the same as the current distance between the enemy ship and the player ship.
    However, it is more important that we predict where our projectiles will be when
    we fire them. The projectiles move quite a bit faster than our ship, so we divide
    the distance between the enemy ship and the player ship by a factor of 10 to make
    our prediction. The projectiles do not actually move 10 times as fast, but, as
    with many of the constant values we choose for our AI, trial and error and what
    looks right trump actual data. Dropping the multiple to a factor of 5 will double
    the distance we will lead the player ship with each shot. Making the value 20
    would cut that lead in half. A value of 10 is what looked right to me when I was
    testing the AI, but you can tweak this number to your taste. You could even add
    a random factor if you like.
  prefs: []
  type: TYPE_NORMAL
- en: The AvoidForce function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AvoidForce` function is also a bit of a cheat. Steering behaviors use
    an avoid force to prevent autonomous agents from colliding with obstacles. If
    the avoid force value is set too high, it will look as if the enemy ship is magically
    repelled from the obstacles. If it is too low, it will crash right into them.
    Our `AvoidForce` function will look for the closest obstacle to our enemy ship
    and will increase the velocity of the enemy ship to steer it around any obstacles.
    Here is what that function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first check in this function is how close we are to the star in the center
    of the gameplay area. This star is the biggest thing we need to avoid. It is the
    only object that will destroy us even if our shields are on, so the AI needs to
    be extra certain it does not hit the star. This check involves finding the squared
    distance between the center of the play area and the enemy spaceship, and checking
    that value against a constant we set in our class definition call, `c_StarAvoidDistSQ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tweak the value of `c_StarAvoidDistSQ` to allow the enemy spaceship
    to get closer to, or stay further away from, the center of the game screen. If
    our enemy ship is not too close to the viewable game area, we look to see whether
    any obstacles are close to the spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We do a rectangle test against all of the asteroids and projectiles in our
    game. At the beginning of the `if` block, we set up the corners of our rectangle
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `c_AvoidDist` constant is set in the `FiniteStateMachine` class definition
    and can be changed based on your taste. Increasing the avoid distance makes the
    AI keep a greater distance from all the projectiles. If you set this value too
    high, your AI will be rather timid. Reduce the distance and the AI will tolerate
    flying much closer to the obstacles. If it''s too low, it will frequently crash
    into them. After determining the values to use for our rectangle test, we loop
    over all of our asteroids, looking for an asteroid that is both active and within
    the bounds of our rectangle test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding avoid forces, we are only avoiding the closest obstacle. You could
    write a more complicated version of this, capable of adding an avoiding force
    for several objects within our bounding box, but avoiding the closest obstacle
    works reasonably well. After checking all of our asteroids, we check to see whether
    there is a projectile that is active and closer than the closest asteroid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find at least one object in our bounding box, we want to both rotate
    our spaceship so that it moves to avoid it naturally as the player would, and
    we also add an avoid force, which is a bit of a cheat. The avoid force pushes
    our enemy spaceship away from the object based on a constant, `c_ObstacleAvoidForce`,
    that we set in our class definition. That value can be tweaked up and down. In
    general, I like to keep this value high, risking the player may realize that this
    is a cheat. You may modify the value of `c_ObstacleAvoidForce` based on your preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The obstacle branch runs if the enemy ship is not too close to the star. If
    the object is too close to the star, the code jumps into the `else` block. This
    code creates an avoid force that pushes and steers the ship away from the center
    of the play area. It has its own constant avoid force that we set inside the class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ShieldCheck` function is similar to the avoid force function, in that
    it checks a bounding rectangle to see whether there is an obstacle close to our
    ship. It then determines whether the ship is unlikely to avoid a collision. No
    matter how good our steering forces, sometimes we are not able to avoid an asteroid
    or projectile. If this is the case, we want to raise our shields. We do not need
    to check whether we are close to the star because the star will kill us whether
    our shields are up or not, so there is no need to bother worrying about that in
    the `ShieldCheck` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Like the avoid force check, we set up a bounding rectangle around our ship with
    the `c_ShieldDist` constant. This value should be lower than the avoid force.
    If it is not, we will raise our shields needlessly when we could avoid the object.
    Just like everything else in our AI, if the value of `c_ShieldDist` is set too
    high, we will be raising our shields when we do not need to. Our shields have
    limited use, so this would waste shield time that we could otherwise use later.
    If we set the value too low, we risk hitting an obstacle that the ship is accelerating
    toward before we have a chance to raise the shields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function, `LOSCheck`, is a line-of-sight check. That means that it
    looks to see whether a straight line could be drawn between the enemy ship and
    the player''s ship without intersecting any obstacles. If there is a clear line
    of sight, this function returns `true`. If there is an obstacle blocking the line
    of sight, the function returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing we will frequently want to make checks against is the player''s distance
    to the enemy ship. Because the square root is a time-consuming operation, we eliminate
    it by checking against a squared distance. We use the `GetPlayerDistSq` function
    to get the squared distance between the enemy ship and the player ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The FSM''s `Move` function is the function that runs our AI every frame. It
    performs a series of checks to determine what state the AI should be in and executes
    that state''s function. It also checks to see whether the AI should raise or lower
    the spaceship''s shields. Here is the function in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `m_CheckCycle` attribute to cycle through the different state checks
    we perform to reduce the burden on the CPU. That is not really necessary for an
    AI as simple as this one. There is only one agent in our game executing this AI,
    but if we ever expanded this to use multiple agents, we might set up each of those
    agents starting on a different cycle check number to spread out our computations.
    Right now, this cycle check is included for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if we are on cycle 0, we run the line-of-sight check, and if
    we do not have a line of sight, we set the current state to `WANDER`. In cycle
    1, we look to see whether we had a line of sight on the last frame, and if we
    did, we figure out whether we want to approach, flee, or attack, based on the
    distance between the enemy ship and the player ship. On cycle 2, we add any avoid
    forces and reset our check cycle attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we perform a shield check every cycle. I initially had the shield check
    performed on every fourth cycle, but the enemy ship was getting hit too often
    when it was struck by a projectile head on. Because of this, I changed the code
    to perform the shield check on every cycle. That is the kind of manual tweaking
    you end up doing in Game AI to make it work. There is a lot of trial and error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The last few blocks of code are just a series of `if` and `else if` statements
    that look to see what the current state is, and calls the appropriate function
    based on that state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the ai.html file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to compile and test our `ai.html` file. The screenshot for
    this version of the game will look quite a bit different than our previous version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the game will have a much larger canvas, with asteroids
    and a star in the middle. The enemy spaceship will seek out the player and attack.
    Here is a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d777e80d-46b6-4267-9d9c-18343538ce48.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of ai.html
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you must run WebAssembly apps using a web server, or with `emrun`.
    If you would like to run your WebAssembly app using `emrun`, you must compile
    it with the `--emrun` flag. The web browser requires a web server to stream the
    WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed Game AI, what it is, and how it is different than
    academic AI. We talked about using autonomous agents versus a top-down AI, and
    the benefits of each AI style, as well as how we can mix the two styles.
  prefs: []
  type: TYPE_NORMAL
- en: I introduced the concept of an FSM and mentioned early uses of FSMs in games
    such as *PAC-MAN*, and we explored steering behaviors, and the kinds of steering
    behaviors we will use to direct the agent in our game. We added asteroids and
    a star as obstacles to our game and increased the size of our gameplay area. We
    added new forms of collision detection to allow our AI to determine when it has
    a line of sight with our player. We also added rectangle collision detection to
    determine whether there is an obstacle close enough for our AI to use an avoid
    force. We expanded our `Point` class to a `Vector2D` class and added new functionality
    including projection, magnitude, and dot product calculations. We wrote an FSM
    and used it to determine what steering forces we will be using, and under what
    circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be greatly expanding the size of our level and
    adding a camera so that we can move our spaceship around this larger version of
    the gameplay area.
  prefs: []
  type: TYPE_NORMAL

- en: Debugging and Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we are going to discuss two topics that will be helpful
    as you go on to create games using Emscripten and build in WebAssembly. We are
    going to discuss the topics of debugging and optimization. We will debug before
    optimizing, because building your code to output more debuging information prevents
    optimization. We will start by using some basic debugging techniques, such as
    printing a stack trace and defining debug macros that we can remove by changing
    a compile flag. We will then move on to some more advanced debugging techniques,
    such as compiling with Emscripten flags, which allow us to trace through our code
    in Firefox and Chrome. We will also discuss some of the differences between debugging
    using the Firefox and Chrome developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure that you include the `/Chapter16/sprites/` folder from this project''s
    GitHub repository. If you haven''t downloaded the GitHub project yet, you can
    get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: After we have finished discussing debugging, we will move on to optimization.
    We will discuss the optimization flags you can use with Emscripten, as well as
    the use of profilers to determine where your game or app may be having performance
    issues. We will discuss general techniques for optimizing your code for WebAssembly
    deployment. Finally, we will discuss optimizations related to web games and WebGL
    calls made by the WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: Debug macro and stack trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way you can start debugging your code is by using `#define` to create a
    debugging macro, which we can activate by passing a flag into the Emscripten compiler.
    However, this will resolve to nothing if we don''t pass that flag. Macros are
    easy to add, and we can create a call that prints a line if we are running with
    our debug flag, but will not slow down performance if we aren''t. If you are not
    familiar with preprocessor commands, they are commands that are issued to the
    compiler that evaluate while the code is compiled instead of at runtime. For instance,
    if I used a `#ifdef PRINT_ME` command, the line of code would only be compiled
    into our source code if the `PRINT_ME` macro is defined either with a `#define
    PRINT_ME` macro on a line earlier in the code, or if we compiled the source with
    the `-DPRINT_ME` flag passed into the compiler when we ran the compiler. Let''s
    say we had the following block of code in our `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we did, we would have compiled and ran that code. The web browser''s console
    prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compiled it with the `-DPRINT_ME` flag and then ran the code at the command
    line, we would see the following printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you disassembled the code into WebAssembly text, then you wouldn't see any
    hint of the original `printf` statement that printed "nothing was defined". At
    compile time, the code is removed. This makes preprocessor macros very useful
    when creating code that we want to include during the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the `-D` flag to include debug macros in your code, make sure
    that you don't include that flag when you are compiling for release, as that will
    continue to include all of your debug macros when you don't want them. You may
    want to consider having a `-DRELEASE` flag that overrides your `-DDEBUG` flag
    when you compile your code for general release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping all of your `printf` calls confined to a macro is a good way to make
    sure you removed all the calls to `printf` that will slow down your app when you
    publish it. Let''s try this out by starting with the `webgl-redux.c` file as a
    baseline. From the code we created in the previous chapter, copy and paste `webgl-redux.c`
    into a file called `debug.cpp`. We will add our debug macro at the beginning of
    this file. Immediately after the line that includes `emscripten.h`, but before
    the line of code that defines the canvas width, add the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will only compile the `run_debug` function if we pass the `-DDEBUG`
    flag to the compiler. The user shouldn''t run the `run_debug` function directly,
    because it will not exist if we don''t use the `-DDEBUG` flag. Instead, we should
    use the `DBG` macro function. This macro exists regardless of whether we use the
    `-DDEBUG` flag. If we use this flag, the function calls the `run_debug` function.
    If we don''t use this flag, the calls to `DBG` magically disappear. The `run_debug`
    function not only uses `printf` to print out a string, but also uses `EM_ASM`
    to dump a stack trace to the JavaScript console. A stack trace logs out every
    function that is currently on the JavaScript stack. Let''s add a few function
    calls that will eventually call our `DBG` macro. These should be added immediately
    before the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `main` function, we should add a call to `inner_call_3()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile our `debug.cpp` file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles the `debug.cpp` file into an `index.html` file. If we serve that
    file from a web server and open it in a browser, we will see the following in
    our JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that we have a stack trace, followed by our message, `check
    console log for stack trace`, which was the string we passed into the `DBG` macro.
    One thing you may notice if you look carefully is that this stack trace is not
    very helpful. Most of the functions in the stack trace are labeled `wasm-function`,
    which, from a debugging perspective, is kind of useless. This is because we lose
    the function names in the compilation process. To keep these names, we will need
    to pass the `-g4` flag to Emscripten when we compile. The `-g` flag, followed
    by a number, tells the compiler how much debugging information to preserve in
    the compilation process, with `-g0` being the least amount of information and
    `-g4` being the most. If we want to create source maps that map our WebAssembly
    to the C/C++ source code it was created from, we will need to pass in the `-g4`
    command, and if we want to know the functions called by our stack trace, we are
    going to need `-g4` for that as well. Let''s try recompiling with our `-g4` flag.
    Here is the new version of the `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, reload the page and check the console. In the following snippet, we have
    the new stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much more readable. You can see all of the inner call functions we
    defined, as well as the `main` function. But what happened to `run_debug`? It
    came out looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here is called C++ name mangling, and we discussed it briefly
    in earlier chapters. Because C++ allows for function overloading, the compiler
    *mangles* the names of functions so that each version of the function has a different
    name. We were able to prevent this in our calls to `inner_call_1`, `inner_call_2`,
    and `inner_call_3` by placing them in a block labeled `extern "C"`. This tells
    the compiler not to mangle the names of these functions. It isn''t strictly necessary
    for debugging, but I wanted to demonstrate how adding functions to this block
    can allow for easier recognition of our functions inside a stack trace. Here is
    what that same stack trace looks like if I remove the `extern "C"` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all of our inner call functions are mangled. In the next section,
    we will be discussing source maps.
  prefs: []
  type: TYPE_NORMAL
- en: Source maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's briefly discuss source maps. Back in the early days of the web, it
    was decided that users should be able to view all of the source code on every
    web page. Early on, this was always HTML, but later, JavaScript was added and
    became something a user could view in an attempt to understand the workings of
    a given web page. Today, this is not possible in most cases. Some code today,
    such as TypeScript, is transpiled into JavaScript from another language. If you
    are writing JavaScript, you may use Babel to convert the latest JavaScript to
    run on older web browsers. Uglify or Minify may be used to remove white space
    and shorten variable names. If you need to debug the original source code, a source
    map is a tool you can use to map the JavaScript running in your browser back to
    the original source.
  prefs: []
  type: TYPE_NORMAL
- en: 'A source map is a JSON file that contains data mapping for the machine-generated
    JavaScript output code and points it back to either the handwritten JavaScript
    or in an alternative language, such as TypeScript or CoffeeScript. There are two
    ways that an application can tell the web browser that there is a source map file
    associated with a given piece of code. We can include a comment with the `sourceMappingURL`
    directive in the code, or we could include a `SourceMap` inside the HTTP header
    for that file. If we are using the `sourceMappingURL` comment method, add the
    following line to the end of the output JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is usually done programmatically during the build process. The alternative
    method would add the following line to the HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss browser-based WebAssembly debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Browser debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging WebAssembly in a web browser is still pretty crude. For example, at
    the time of writing, it is still not possible to directly *watch* a variable using
    the debugger. In both Firefox and Chrome, you must occasionally refresh your browser
    to see the CPP source file. Unlike debugging JavaScript, the WebAssembly debuggers
    feel (ironically) buggy. In Chrome, you frequently have to click the step over
    button several times to advance the line of code. In both browsers, breakpoints
    sometimes fail to work.
  prefs: []
  type: TYPE_NORMAL
- en: I frequently have to remove and then re-add a break point to get them to work
    again. It is still early days for WebAssembly source maps and in-browser debugging,
    so the hope is that the situation will improve soon. Until it does, try combining
    debugging in the browser with the addition debug statements, as I advised earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your code for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, we will need to compile our app to support source maps
    that we can use for in-browser debugging in Firefox and Chrome. Currently, the
    only browsers that support in-browser debugging are Firefox, Chrome, and Safari.
    I will only be covering Firefox and Chrome in this book. You can compile the `debug.cpp`
    file for use with the WebAssembly debugger using the following `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first new flag is `-g4`, which instructs the compiler to have the highest
    amount of debugging data and create source map files for our WebAssembly. After
    that comes the `--source-map-base http://localhost:8080/` flag, which tells the
    compiler to add the `sourceMappingURL$http://localhost:8080/debug.wasm.map` string
    to the end of the `debug.wasm` file. This allows the browser to find the source
    map file that is associated with the `debug.wasm` file. The last two new flags
    are `-s MAIN_MODULE=1` and `-s WASM=1`. I'm not sure why either of these flags
    are required to make the source mapping work. Both of these flags are explicitly
    telling the compiler to run the default behavior. However, at the time of writing,
    if you don't include these flags, browser debugging will not work. This feels
    like a bug to me, so it is possible that by the time you are reading this, `emcc`
    will not require those final two flags. Compiling with the preceding command will
    allow you to test using the WebAssembly debugger on Chrome and Firefox. If you
    really want to debug on Opera, Edge, or some other debugger that doesn't support
    WebAssembly debugging yet, you do have an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Using asm.js as an alternative for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For whatever reason, you may feel that debugging using Edge or Opera may be
    necessary. If you feel that you must debug in a browser that doesn't have a WebAssembly
    debugger, you could compile for asm.js as an alternative. If so, change the `-s
    WASM=1` flag to `-s WASM=0`, and you will be set. This will create a JavaScript
    file instead of a WASM file, but the two files (in theory) should behave the same.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome has some great tools for debugging JavaScript, but is still pretty raw
    when it comes to debugging WebAssembly. After you have built the app, open it
    up in Chrome, and then open up Chrome Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a11a945-2feb-426c-8ab0-79ce61d0d3ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Screenshot of opening Chrome Developer Tools using the menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open it up using the menu in the top left of the browser, as seen in
    the preceding screenshot, or you can open the developer tools by pressing *Ctrl*
    + *Shift* + *I* on your keyboard. When you load up your `debug.html` file in Chrome,
    you need to click on the Sources tab in the developer window. This is what this
    should look like if you are on the Sources tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5b7fd9-415c-4edb-a9f4-c2e387054c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Screenshot using the sources tab in Chrome Developer Tools'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see `debug.cpp` in the Sources tab, you may need to click the browser's
    reload button next to the URL at the top to reload the page. As I stated earlier,
    the interface feels a little buggy, and sometimes the CPP file doesn't load on
    the first try. Hopefully, this will have changed by the time you read this. Once
    you select the CPP file, you should be able to see the C++ code from our `debug.cpp`
    file in the code window in the center of the Developer Tools window. You can set
    breakpoints in the C++ code by clicking on the line number next to the line of
    code where you would like a breakpoint. You can then step through the code using
    the buttons above the `Watch` variables. Although the watch variables don't work
    at the time of writing, you may want to try it anyway. WebAssembly is improving
    on an almost daily basis, and bug fixes are constantly happening, so by the time
    you read this, things may have changed. If not, you may use the `Local` variables
    to get some idea of what values are changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can watch these variables get populated as you step through the source
    code, and you can frequently determine which variables are updated by watching
    these values change. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2194af80-6559-4c96-85cf-a4aa50496525.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Screenshot of the debug tools in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, you need to click the step over button more than once
    to get the line to advance in the C++ code window. In Chrome, the step over button
    is advancing one WebAssembly instruction per click instead of one C++ instruction.
    This may have changed by the time you read this, but don't be surprised if you
    need to click step over more than once to advance through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Firefox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firefox has a number of advantages and disadvantages compared to Chrome. On
    the plus side, you can click the step over button once in Firefox per line in
    your C++ code. On the minus side, this makes knowing which local variables are
    changing in response to the line you are executing more difficult to track. These
    `Local` variables are a little like registers in a register-based assembly language
    so that the same variable may get moved in and out of a few of them. It can be
    a little easier to follow along with the values if you have to click the button
    once per assembly instruction. However, if you are more interested in tracing
    through the flow of your code than knowing what values change for each WebAssembly
    instruction, Firefox is much better for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open up your Firefox Developer Tools, click the menu button in the top right
    corner of the browser window and select Web Developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/571431e1-1c13-455c-9300-6d5f00ab92f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Web Developer tools in the Firefox browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once on the Web Developer menu, click the Debugger menu item to open up the
    Debugger window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee20cca5-4719-4b79-8de6-4dc4ef3b5887.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Screenshot of opening Debugger in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of selecting the debugger through the menu system, you can use the
    shortcut keys *Ctrl* + *Shift* + *C* to open up the Inspector, and then select
    the Debugger tab from the Web Developer window. Here is what this looks like when
    you are in the Firefox Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40bc212-12a6-460a-b385-3262e7b75831.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Screenshot of using Debugger in the Firefox browser'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, debugging will need to combine the use of debugging macros, as discussed
    in the previous section, with the ability of the browser to fully understand what
    is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox Developer Edition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am briefly going to mention the Firefox Developer Edition. If you prefer
    to use Firefox as your primary WebAssembly development browser, you may want to
    consider using Firefox Developer Edition. The Developer Edition pushes forward
    updates to the web developer tools faster than the standard version of Firefox.
    Because WebAssembly is so new, updates that improve the development experience
    are likely to show up in the Developer Edition weeks or months earlier than they
    will become available in the standard version. At the time of writing, there is
    no significant difference between the two versions, but if you are interested
    in trying it out, it is available at the following web address: [https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/).'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing your WebAssembly code is partially about decision making and experimenting.
    It is about discovering what works for your particular game or app. When WebAssembly
    was designed, for instance, a decision was made to have the WebAssembly bytecode
    run on a virtual stack machine. The designers of WebAssembly made this choice
    because they felt that they could justify the small loss of performance with a
    significantly smaller bytecode download size. Every piece of code has a bottleneck
    somewhere. In OpenGL applications that bottleneck will be interfacing with the
    GPU. The bottleneck for your application may be the memory, or it may be CPU-bound.
    Optimizing code, in general, is about determining what the holdup is and deciding
    what trade-off you would like to make to improve things. If you optimize for download
    size, you may lose some runtime performance. If you optimize for runtime performance,
    you may have to increase your memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten provides us with a large selection of flags to optimize for different
    potential bottlenecks. All of the optimization flags will result in varying degrees
    of longer compile times, so using any of these flags should come late in the development
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `-O` flags for general optimization. `-O0`, `-O1`, `-O2`, and
    `-O3` provide different levels of trade-off between compile time and code performance.
    The `-O0` and `-O1` flags provide minimal optimization. The `-O2` flag offers
    most of the optimization you get from the `-O3` flag, but with significantly shorter
    compile times. Finally, `-O3` provides the highest level of optimization, but
    takes substantially longer than any other flag to compile, so it is a good idea
    to wait until you are nearing the end of development to begin using it. In addition
    to the `-O` flags, `-s AGGRESSIVE_VARIABLE_ELIMINATION=1` can be used to increase
    performance, but may result in larger bytecode download sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two other `-O` flags that I didn't mention in the preceding section.
    Those flags are used to optimize for bytecode download size instead of purely
    optimizing for performance. The `-Os` flag takes about as long as `-O3`, and provides
    as much performance optimization as it can, but sacrifices some of the `-O3` optimizations
    in favor of smaller download sizes. `-Oz` is like `-Os`, but prioritizes smaller
    download sizes even further by sacrificing even more performance optimization,
    which results in smaller bytecode. Another way to optimize for size is to include
    the `-s ENVIRONMENT='web'` flag. You should only use this flag if you are compiling
    for the web. It removes any source code that is used to support other environments,
    such as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the safe optimization flags we have been using up until this
    point, Emscripten also allows for two *unsafe* flags that can improve performance,
    but come at the risk of potentially breaking your code. These flags are high risk/high
    reward optimizations that you should only use before the bulk of testing is complete.
    Using the `--closure 1` flag runs the Closure JavaScript compiler, which performs
    very aggressive optimization on the JavaScript in our app. However, you shouldn't
    use the `--closure 1` flag unless you are already familiar with using the closure
    compiler and the effects that compiler could have on JavaScript. The second *unsafe*
    flag is the `--llvm-lto 1` flag, which enables *Link Time Optimization* during
    the LLVM compile step. This process can break your code, so take extreme care
    when using this flag.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is the best way to determine what bottlenecks exist in your source
    code. When you are profiling WebAssembly modules, I recommend that you use the
    `--profiling` flag when compiling. You can profile without it, but all of the
    module functions you call will be labeled `wasm-function`, which can make your
    life more difficult than it needs to be. After compiling your code with the `--profile`
    flag, open up a new *Incognito* window in Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by either pressing the *CTRL + SHIFT + N* keys, or through
    the menu in the top right corner of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b6fc82e-f25b-4487-87b5-2632a5b32714.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Opening an Incognito window in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening an Incognito window will prevent any Chrome extensions from running
    when profiling your app. This will prevent you from having to wade through the
    code in those extensions to get to the code in your app. Once you have opened
    an Incognito window, press *Ctrl* + *Shift* + *I* to inspect the page. This will
    open up Chrome Developer Tools at the bottom of the browser window. Inside Chrome
    Developer Tools, select the Performance tab, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed201a26-d861-4f07-91b7-29d544bc9195.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: The Performance tab in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the Record button and let it run for a few seconds. After you have
    recorded for five or six seconds, click the Stop button to stop profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f360963f-d7da-48ee-b60c-4e69981c71d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Screenshot of recording performance metrics in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: After you stop profiling, you will see data within the performance window. This
    is called the Summary tab, and displays data in the form of a pie chart that breaks
    down the number of milliseconds your app is spending on various tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the vast majority of the time, our app is idle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8fea306-0daa-4c78-a71c-a1b49c4397cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Performance overview in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: The summary is interesting. It can tell you where your bottleneck is on a very
    high level, but to evaluate our WebAssembly, we will need to look in the Call
    Tree tab. Click on the Call Tree tab, and you will see the following window:ï¿¼
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3aa8cd8-4542-4c9e-bc91-70ecf0f28220.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Screenshot of the Call Tree in the Chrome browser'
  prefs: []
  type: TYPE_NORMAL
- en: Because our `game_loop` function is being called every frame, we can find the
    call inside the `Animation Frame Fired` tree. Drill down, looking for `game_loop`.
    When we find the function, it is mangled because it is a C++ function. So, instead
    of seeing `_game_loop`, we see `_Z9game_loopv`, although you may see something
    mangled differently. If you would like to prevent this mangling, you can wrap
    this function in an `extern "C"` block.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the execution of this function took a total of 3.2% of the
    browser's CPU time. You can also look at each of the OpenGL calls from within
    this function. If you take a look at our game loop, more than half of the CPU
    time is spent in `_glClear`. This is not a problem for this application, because
    the vast majority of the browser CPU time is spent idle. If, however, our game
    loop function was taking up a large percentage of the CPU time, we would need
    to see where in that function we were spending it.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with try/catch blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, try/catch blocks are known to cause significant performance
    issues in WebAssembly modules, so only use them if they're absolutely necessary.
    You may want to use them during the development phase, and remove them when building
    for release. Some of the `-O` optimization flags will remove try/catch blocks,
    which you need to be aware of if you plan on using them in production. If you
    want to use try/catch blocks in your production build, you will need to compile
    using the `-s DISABLE_EXCEPTION_CATCHING=0` flag. This will tell the compiler
    not to remove the try/catch blocks from the optimized version of your bytecode.
    If you would like to remove your try/catch blocks from unoptimized development
    code, you can do so by using the `-s DISABLE_EXCEPTION_CATCHING=1` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing OpenGL for WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to remember that any calls to OpenGL from WebAssembly are calling
    WebGL using a function table. Part of the reason this is important is because
    any time you use OpenGL ES and OpenGL functionality that is not available in WebGL,
    Emscripten must perform some very slow software emulation on those functions.
    It is also important to remember that WebGL calls are more expensive than OpenGL
    calls on a native platform because WebGL is sandboxed, and various security checks
    are performed by the browser when it calls WebGL. Emscripten provides you with
    several flags that allow you to emulate OpenGL and OpenGL ES calls that are not
    available in WebGL. For performance reasons, however do not use these functions
    unless you absolutely have to.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebGL 2.0 if possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL 2.0 is faster than WebGL 1.0, but, at the time of writing, it is supported
    on far fewer browsers. Just compiling your WebGL 1.0 code to WebGL 2.0 will give
    you about a 7% performance improvement. However, before you choose to do this,
    you may want to consult [https://caniuse.com/#search=webgl2](https://caniuse.com/#search=webgl2)
    to see whether the browsers you are targeting support WebGL 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the number of OpenGL calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calls to OpenGL from WebAssembly are not as fast as those same calls from a
    natively compiled application. A call to OpenGL from WebAssembly is making a call
    to a WebGL analog. WebGL was built to execute inside a web browser and performs
    some security checks to verify that we are not asking WebGL to do anything malicious.
    This means that we must account for that additional overhead when writing OpenGL
    that's targeting WebAssembly. There are cases where two or three calls to OpenGL
    for a native application would be faster than combining those calls into a single
    OpenGL call. However, that same code in WebAssembly might run faster if you condensed
    it into a single call to OpenGL. When optimizing for WebAssembly, try doing what
    you can to minimize the number of OpenGL calls, and use your profiler to verify
    that the new code is faster.
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten OpenGL flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several Emscripten linker flags can have a significant effect on performance.
    Some of the flags were created to ease porting of code to WebAssembly, but have
    the potential to create performance problems. Others can improve performance under
    the right conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The `-s FULL_ES2=1` and `-s FULL_ES3=1` linker flags emulate the entire OpenGL
    ES 2.0/3.0 API. As I mentioned earlier, by default, the OpenGL ES 2/3 implementations
    in WebAssembly only support subsets of OpenGL ES 2/3 that are compatible with
    WebGL. This is because WebGL is doing the rendering in WebAssembly. There may
    be a reason why you absolutely need a feature of OpenGL ES 2/3 that is not available
    by default. If so, you can use the `-s FULL_ES2=1` or `-s FULL_ES3=1` flags to
    emulate that feature in the software. This will come at a price when it comes
    to performance, so take that into consideration if you decide to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `-s LEGACY_GL_EMULATION=1` flag is used to emulate old versions of OpenGL
    that use the fixed function pipeline. It is also not recommended that you use
    this flag because of the poor performance that will result. This flag exists for
    people who are looking to port old code to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use WebGL 2 to gain the performance increase associated with
    it, use the `-s USE_WEBGL2=1` linker flag. If you have code that was written for
    WebGL 1.0, but would like the performance gains of WebGL 2.0, you can try compiling
    to WebGL 2.0 to see whether you used any code that was not backward compatible
    in WebGL 2.0\. If it doesn't compile with this flag, you can try the `-s WEBGL2_BACKWARDS_COMPATIBILITY_EMULATION=1`
    linker flag, which will allow you to compile your WebGL 1.0 code so that you can
    use it in WebGL 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about different strategies we can use to debug and
    optimize our WebAssembly code. We discussed writing C macros, which allow us to
    easily remove calls to print to the console when we move from development into
    production. We talked about source maps, what they are, and how they can help
    us to debug our WebAssembly code from within a browser. We discussed using the
    debugger in both Chrome and Firefox to step through WebAssembly's source code.
    Finally, we discussed optimization in WebAssembly, what compiler options are available
    in Emscripten, and how we can go about improving our WebGL performance.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You should be well on your way to developing your own games
    or apps in WebAssembly. I hope that you enjoyed learning how we can use WebGL
    to build games for the web. If you have any questions, comments, or would just
    like to say hi, you can find me on the following platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter**: [https://twitter.com/battagline](https://twitter.com/battagline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinkedIn**: [https://www.linkedin.com/in/battagline/](https://www.linkedin.com/in/battagline/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YouTube**: [https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ](https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

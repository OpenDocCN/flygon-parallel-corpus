- en: Spring MVC Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC优化
- en: In the previous chapter, we learned about the Spring **Aspect-Oriented Programming**
    (**AOP**) module, AOP concepts, its various terminologies, and how to implement
    advice. We also saw the proxy concept and its implementation using the proxy pattern.
    We went through the best practices to follow to achieve quality and performance
    with the Spring AOP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Spring **面向切面编程**（**AOP**）模块，AOP概念，其各种术语，以及如何实现建议。我们还了解了代理概念及其使用代理模式的实现。我们通过最佳实践来实现Spring
    AOP的质量和性能。
- en: Spring MVC is the most popular Java web application framework nowadays. It is
    provided by Spring itself. Spring Web MVC helps to develop a flexible and loosely
    coupled web-based application. Spring MVC follows the **Model-View-Controller**
    (**MVC**) pattern, which separates the input logic, business logic, and presentation
    logic while providing loose coupling between components. The Spring MVC module
    allows us to write a test case without using the request and response object in
    the web application. So, it removes the overhead of testing the web components
    in the enterprise application. Spring MVC also supports multiple new view technologies
    and allows for extending. Spring MVC provides a clear definition of roles for
    controllers, view resolvers, handler mappings, and POJO beans, which makes it
    simple to create Java web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC现在是最流行的Java Web应用程序框架。它由Spring自身提供。Spring Web MVC有助于开发灵活和松散耦合的基于Web的应用程序。Spring
    MVC遵循**模型-视图-控制器**（**MVC**）模式，它将输入逻辑、业务逻辑和表示逻辑分开，同时提供组件之间的松散耦合。Spring MVC模块允许我们在Web应用程序中编写测试用例而不使用请求和响应对象。因此，它消除了在企业应用程序中测试Web组件的开销。Spring
    MVC还支持多种新的视图技术，并允许扩展。Spring MVC为控制器、视图解析器、处理程序映射和POJO bean提供了清晰的角色定义，使得创建Java
    Web应用程序变得简单。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Spring MVC configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC配置
- en: Spring asynchronous processing, `@Async` annotation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring异步处理，`@Async`注解
- en: '`CompletableFuture` with Spring Async'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Async的`CompletableFuture`
- en: Spring Security configuration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring安全配置
- en: Authentication cache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证缓存
- en: Fast and stateless API authentication with Spring Security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security进行快速和无状态的API身份验证
- en: Monitoring and managing Tomcat with JMX
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMX监视和管理Tomcat
- en: Spring MVC performance improvements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC性能改进
- en: Spring MVC configuration
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC配置
- en: The Spring MVC architecture is designed along with a front controller servlet,
    the `DispatcherServlet`, which is a front controller pattern implementation and
    acts as an entry point for all of the HTTP requests and responses. The `DispatcherServlet` can
    be configured and mapped using Java configuration or in the deployment descriptor
    file, `web.xml`. Before moving on to the configuration part, let's understand
    the flow of Spring MVC architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC架构设计了一个前端控制器Servlet，即`DispatcherServlet`，它是前端控制器模式的实现，并充当所有HTTP请求和响应的入口点。`DispatcherServlet`可以使用Java配置或部署描述符文件`web.xml`进行配置和映射。在进入配置部分之前，让我们了解Spring
    MVC架构的流程。
- en: Spring MVC architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC架构
- en: 'In the Spring MVC framework, there are multiple core components that maintain
    the flow of request and response execution. These components are clearly separated
    and have different interfaces and implementation classes, so they can be used
    according to requirements. These core components are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC框架中，有多个核心组件来维护请求和响应执行的流程。这些组件被清晰地分开，并且具有不同的接口和实现类，因此可以根据需求使用。这些核心组件如下：
- en: '| **Component** | **Summary** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **摘要** |'
- en: '| `DispatcherServlet` | It acts as a front controller of the Spring MVC framework
    through the life cycle of HTTP requests and responses. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `DispatcherServlet` | 它作为Spring MVC框架的前端控制器，负责HTTP请求和响应的生命周期。 |'
- en: '| `HandlerMapping` | When a request comes, this component is responsible for
    deciding which controller will handle the URL. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `HandlerMapping` | 当请求到来时，这个组件负责决定哪个控制器将处理URL。 |'
- en: '| `Controller` | It executes the business logic and maps the resultant data
    in `ModelAndView`. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Controller` | 它执行业务逻辑并映射`ModelAndView`中的结果数据。 |'
- en: '| `ModelAndView` | It holds the model data object in terms of the execution
    result and the view object to render. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `ModelAndView` | 它以执行结果和视图对象的形式保存模型数据对象。 |'
- en: '| `ViewResolver` | It decides the view to be rendered. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `ViewResolver` | 它决定要呈现的视图。 |'
- en: '| `View` | It shows the result data from a model object. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `View` | 它显示来自模型对象的结果数据。 |'
- en: 'The following diagram illustrates the flow of the preceding components in the
    Spring MVC architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了Spring MVC架构中前面组件的流程：
- en: '![](img/742e69c4-d5cc-407c-aa61-c4a201de15e2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/742e69c4-d5cc-407c-aa61-c4a201de15e2.png)'
- en: Spring MVC architecture
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC架构
- en: 'Let''s understand the basic flow of the architecture:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解架构的基本流程：
- en: When the incoming **request** comes, it is intercepted by the front controller,
    `DispatcherServlet`. After intercepting the **request**, the front controller
    finds the appropriate `HandlerMapping`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当传入的**请求**到来时，它被前端控制器`DispatcherServlet`拦截。在拦截**请求**后，前端控制器找到适当的`HandlerMapping`。
- en: The `HandlerMapping` maps the client **request** call to the appropriate `Controller`,
    based on the configuration file or from the annotation `Controller` list, and
    returns the `Controller` information to the front controller.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HandlerMapping`将客户端**请求**调用映射到适当的`Controller`，根据配置文件或注解`Controller`列表，并将`Controller`信息返回给前端控制器。'
- en: The `DispatcherServlet` dispatches the **request** to the appropriate `Controller`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`将**请求**分派到适当的`Controller`。'
- en: The `Controller` executes the business logic defined under the `Controller`
    method and returns the resultant data, in the form of `ModelAndView`, back to
    the front controller.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Controller`执行在`Controller`方法下定义的业务逻辑，并将结果数据以`ModelAndView`的形式返回给前端控制器。'
- en: The front controller gets the **view name** based on the values in the `ModelAndView` and
    passes it to the `ViewResolver` to resolve the actual view, based on the configured
    view resolver.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端控制器根据`ModelAndView`中的值获取**视图名称**并将其传递给`ViewResolver`以根据配置的视图解析器解析实际视图。
- en: The **view** uses the **Model** object to render the screen. The output is generated
    in the form of `HttpServletResponse` and passed to the front controller.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图**使用**模型**对象来呈现屏幕。输出以`HttpServletResponse`的形式生成并传递给前端控制器。'
- en: The front controller sends the **response** back to the servlet container to
    send the output back to the user.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端控制器将**响应**发送回Servlet容器，以将输出发送回用户。
- en: 'Now, let''s understand the Spring MVC configuration methods. Spring MVC configuration
    can be set up in the following ways:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解Spring MVC配置方法。Spring MVC配置可以通过以下方式进行设置：
- en: XML-based configuration
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: Java-based configuration
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: 'Before we start with the configuration using the preceding methods, let''s
    define the steps that are involved in setting up the Spring MVC application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上述方法进行配置之前，让我们定义设置Spring MVC应用程序所涉及的步骤：
- en: Configuring front controller
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置前端控制器
- en: Creating Spring application context
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Spring应用程序上下文
- en: Configuring `ViewResolver`
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`ViewResolver`
- en: XML-based configuration
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: In an XML-based configuration, we will do the Spring MVC configuration externally,
    using the XML files. Let's move forward with the configuration, following the
    preceding steps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于XML的配置中，我们将使用XML文件来进行Spring MVC配置。让我们按照上述步骤继续进行配置。
- en: Configuring front controller
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置前端控制器
- en: 'To configure the front controller servlet, `DispatcherServlet`, in an XML-based
    configuration, we need to add the following XML code in the `web.xml` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于XML的配置中配置前端控制器Servlet`DispatcherServlet`，我们需要在`web.xml`文件中添加以下XML代码：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding XML code, at first, we configured the `DispatcherServlet`.
    Then, we mentioned the context configuration location, `/WEB-INF/spring-mvc-context.xml`.
    We set the `load-on-startup` value as `1`, so the servlet container will load
    this servlet upon startup. In the second part, we defined the `servlet-mapping` tag
    to map a URL `/` to `DispatcherServlet`. Now, we will define the Spring application
    context in the next step.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述XML代码中，我们首先配置了`DispatcherServlet`。然后，我们提到了上下文配置位置`/WEB-INF/spring-mvc-context.xml`。我们将`load-on-startup`值设置为`1`，因此Servlet容器将在启动时加载此Servlet。在第二部分中，我们定义了`servlet-mapping`标签，将URL`/`映射到`DispatcherServlet`。现在，我们将在下一步中定义Spring应用程序上下文。
- en: It is good to configure the `load-on-startup` element under the `DispatcherServlet`
    configuration to load it at the highest priority. This is because, in a cluster
    environment, you might face timeout issues if Spring is not up and you get a large
    number of calls hitting your web app once it's deployed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DispatcherServlet`配置下配置`load-on-startup`元素是一个好习惯，以便在集群环境中，如果Spring没有启动并且一旦部署就会有大量的调用命中您的Web应用程序，您可能会面临超时问题。
- en: Creating a Spring application context
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring应用程序上下文
- en: 'After configuring the `DispatcherServlet` in `web.xml`, let''s move ahead to
    create a Spring application context. For that, we need to add the following XML
    code in the `spring-mvc-context.xml` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`中配置`DispatcherServlet`之后，让我们继续创建一个Spring应用程序上下文。为此，我们需要在`spring-mvc-context.xml`文件中添加以下XML代码：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding XML code, we first defined a component scan tag, `<context:component-scan
    />`, for the `com.packt.springhighperformance.ch4.controller` package, so that
    all of the beans and controllers get created and autowired.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述XML代码中，我们首先为`com.packt.springhighperformance.ch4.controller`包定义了一个组件扫描标签`<context:component-scan
    />`，以便所有的bean和控制器都能被创建和自动装配。
- en: Then, we have used `<mvc:annotation-driven />` to register automatically different
    beans and components that includes request mapping, data binding, validation,
    and auto conversion feature with `@ResponseBody`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了`<mvc:annotation-driven />`来自动注册不同的bean和组件，包括请求映射、数据绑定、验证和使用`@ResponseBody`进行自动转换功能。
- en: Configuring ViewResolver
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ViewResolver
- en: 'To configure `ViewResolver`, we need to specify a bean for the class `InternalResourceViewResolver` in
    the `spring-mvc-context.xml` file, after `<mvc:annotation-driven />`. Let''s do
    that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置`ViewResolver`，我们需要在`spring-mvc-context.xml`文件中为`InternalResourceViewResolver`类指定一个bean，在`<mvc:annotation-driven
    />`之后。让我们这样做：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After configuring `ViewResolver`, we will create a `Controller` to test the
    configuration. But, before moving on to that, let's see the Java-based configuration.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`ViewResolver`之后，我们将创建一个`Controller`来测试配置。但是，在继续之前，让我们看看基于Java的配置。
- en: Java-based configuration
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: For the Java-based Spring MVC configuration, we will follow the same steps that
    we did with the XML-based configuration. In a Java-based configuration, all of
    the configurations will be done under the Java class. Let's follow the sequence.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Java的Spring MVC配置，我们将按照与基于XML的配置相同的步骤进行。在基于Java的配置中，所有配置都将在Java类下完成。让我们按照顺序进行。
- en: Configuring front controller
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置前端控制器
- en: 'With Spring 5.0, there are three ways to configure `DispatcherServlet` programmatically,
    by implementing or extending any of the following three classes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring 5.0中，有三种方法可以通过实现或扩展以下三个类来以编程方式配置`DispatcherServlet`：
- en: '`WebAppInitializer` interface'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAppInitializer` 接口'
- en: '`AbstractDispatcherServletInitializer` abstract class'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractDispatcherServletInitializer` 抽象类'
- en: '`AbstractAnnotationConfigDispatcherServletInitializer` abstract class'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractAnnotationConfigDispatcherServletInitializer` 抽象类'
- en: We will use the `AbstractDispatcherServletInitializer` class, as it is the preferred
    approach for applications that use Java-based Spring configuration. It is preferred
    because it allows us to start a servlet application context, as well as a root
    application context.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`AbstractDispatcherServletInitializer`类，因为它是使用基于Java的Spring配置的应用程序的首选方法。它是首选的，因为它允许我们启动一个Servlet应用程序上下文，以及一个根应用程序上下文。
- en: 'We need to create the following class to configure `DispatcherServlet`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建以下类来配置`DispatcherServlet`：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous class code is equivalent to the `web.xml` file configuration that
    we created in the *XML-based configuration* section. In the preceding class, the
    `getRootConfigClasses()` method is used to specify the root application context
    configuration classes (or `null`, if not required). `getServletConfigClasses()` is
    used to specify the web application configuration classes (or `null`, if not required).
    The `getServletMappings()` method is used to specify the servlet mappings for
    the `DispatcherServlet`. Root config classes will be loaded first, then servlet
    config classes will be loaded. Root config classes will create an `ApplicationContext`,
    which will act as a parent context, whereas servlet config classes will create
    a `WebApplicationContext`, and it will act as a child context of the parent context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类代码等同于我们在*基于XML的配置*部分创建的`web.xml`文件配置。在前面的类中，`getRootConfigClasses()`方法用于指定根应用程序上下文配置类（如果不需要，则为`null`）。`getServletConfigClasses()`用于指定Web应用程序配置类（如果不需要，则为`null`）。`getServletMappings()`方法用于指定`DispatcherServlet`的Servlet映射。首先加载根配置类，然后加载Servlet配置类。根配置类将创建一个`ApplicationContext`，它将作为父上下文，而Servlet配置类将创建一个`WebApplicationContext`，它将作为父上下文的子上下文。
- en: Creating a Spring application context and configuring a ViewResolver
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Spring应用程序上下文并配置ViewResolver
- en: 'In Spring 5.0, to create a Spring application context and to configure a `ViewResolver`
    using Java configuration, we need to add the following code in the class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring 5.0中，要使用Java配置创建Spring应用程序上下文并配置`ViewResolver`，需要在类中添加以下代码：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we created a class, `SpringMvcWebConfig`, implementing
    a `WebMvcConfigurer` interface, which provides options for customizing Spring
    MVC configuration. The `@EnableWebMvc` object enables the default configuration
    for Spring MVC. The `@ComponentScan` object specifies the base packages to scan
    for controllers. The two annotations `@EnableWebMvc` and `@ComponentScan` are
    equivalent to the `<context:component-scan />` and `<mvc:annotation-driven />`
    that we created in `spring-mvc-context.xml` in the *XML-based configuration* section.
    The `resolve()` method returns `InternalResourceViewResolver`, which helps in
    mapping logical view names from a preconfigured directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个类`SpringMvcWebConfig`，实现了`WebMvcConfigurer`接口，该接口提供了自定义Spring
    MVC配置的选项。`@EnableWebMvc`对象启用了Spring MVC的默认配置。`@ComponentScan`对象指定了要扫描控制器的基本包。这两个注解`@EnableWebMvc`和`@ComponentScan`等同于我们在*基于XML的配置*部分中创建的`spring-mvc-context.xml`中的`<context:component-scan
    />`和`<mvc:annotation-driven />`。`resolve()`方法返回`InternalResourceViewResolver`，它有助于从预配置的目录中映射逻辑视图名称。
- en: Creating a controller
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个控制器
- en: 'Now, let''s create a controller class to map the `/home` request, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个控制器类来映射`/home`请求，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, `@Controller` defines a Spring MVC controller that contains
    request mappings. The `@RequestMapping(value = "home")` object defines a mapping
    URL, `/home`, to a method, `home()`. So, when the browser hits a `/home` request,
    it executes the `home()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Controller`定义了一个包含请求映射的Spring MVC控制器。`@RequestMapping(value = "home")`对象定义了一个映射URL`/home`到一个方法`home()`。因此，当浏览器发送一个`/home`请求时，它会执行`home()`方法。
- en: Creating a view
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个视图
- en: 'Now, let''s create a view, `home.jsp`, in the `src/main/webapp/WEB-INF/views/home.jsp`
    folder, with the following HTML content:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`src/main/webapp/WEB-INF/views/home.jsp`文件夹中创建一个视图`home.jsp`，其中包含以下HTML内容：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when we run this application, it will show the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个应用程序时，它将显示以下输出：
- en: '![](img/777d9599-35dd-4ca1-bb09-689f78e850d1.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/777d9599-35dd-4ca1-bb09-689f78e850d1.png)'
- en: In the next section, we will learn about Spring asynchronous processing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于Spring异步处理的内容。
- en: Spring asynchronous processing, @Async annotation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring异步处理，@Async注解
- en: Spring provides support for asynchronous method execution. This can also be
    achieved using threads, but it makes the code more complex and sometimes results
    in more bugs and errors. When we need to execute a simple action in an asynchronous
    manner, it is a cumbersome process to handle it using threads. There are cases
    in which it is necessary to perform the operation asynchronously, like sending
    a message from one machine to another machine. The main advantage of asynchronous
    processing is that the caller will not have to wait for the completion of the
    called method. In order to execute a method in a separate thread, you need to
    annotate the method with the `@Async` annotation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了对异步方法执行的支持。这也可以使用线程来实现，但会使代码更复杂，有时会导致更多的错误和bug。当我们需要以异步方式执行简单操作时，使用线程来处理会是一个繁琐的过程。有些情况下需要异步执行操作，比如从一台机器发送消息到另一台机器。异步处理的主要优势在于调用者不必等待被调用方法的完成。为了在单独的线程中执行方法，需要使用`@Async`注解对方法进行注解。
- en: 'Asynchronous processing support can be enabled by using the `@EnableAsync`
    annotation to run the `@Async` methods in the background thread pool. The following
    is an example of Java configuration to enable asynchronous processing:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`@EnableAsync`注解来启用异步处理，以在后台线程池中运行`@Async`方法。以下是启用异步处理的Java配置示例：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Asynchronous processing can also be enabled by using XML configuration, as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理也可以通过使用XML配置来启用，如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@Async annotation modes'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Async注解模式'
- en: 'There are two modes of `@Async` annotation processing methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Async`注解处理方法有两种模式：'
- en: Fire and forget mode
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送并忘记模式
- en: Result retrieval mode
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果检索模式
- en: Fire and forget mode
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送并忘记模式
- en: 'In this mode, a method will be configured as a `void` type, to be run asynchronously:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，方法将配置为`void`类型，以异步运行：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Result retrieval mode
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果检索模式
- en: 'In this mode, a method will be configured with a return type by wrapping the
    result with the `Future` type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，方法将配置一个返回类型，通过`Future`类型来包装结果：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Spring also provides support for the `AsyncResult` class, which implements the
    `Future` interface. It can be used to track the result of asynchronous method
    invocation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还提供了对`AsyncResult`类的支持，该类实现了`Future`接口。它可以用于跟踪异步方法调用的结果。
- en: Limitations of @Async annotation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Async注解的限制'
- en: 'The `@Async` annotation has the following limitations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Async`注解有以下限制：'
- en: The method needs to be `public` so that it can be proxied
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法需要是`public`，这样它才能被代理
- en: Self-invocation of the asynchronous method would not work, because it bypasses
    the proxy and calls the underlying method directly
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法的自我调用不起作用，因为它会绕过代理直接调用底层方法
- en: Thread pool executor
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池执行程序
- en: You might wonder how we declare the thread pools that asynchronous methods will
    use. By default, for the thread pool, Spring will try to find either a unique `TaskExecutor` bean
    defined in the context or an `Executor` bean, named `TaskExecutor`. If neither
    of the preceding two options is resolvable, Spring will use `SimpleAsyncTaskExecutor` to
    process asynchronous method processing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们如何声明异步方法将使用的线程池。默认情况下，对于线程池，Spring将尝试在上下文中找到一个名为`TaskExecutor`的唯一bean，或者一个名为`TaskExecutor`的`Executor`
    bean。如果前两个选项都无法解析，Spring将使用`SimpleAsyncTaskExecutor`来处理异步方法处理。
- en: However, sometimes we do not want to use the same thread pool for all of the
    application's tasks. We can have different thread pools, with different configurations
    for each method. For that, we just need to pass the executor name to the `@Async` annotation
    for each method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们不想为应用程序的所有任务使用相同的线程池。我们可以为每个方法使用不同的线程池，并为每个方法配置不同的线程池。为此，我们只需要将执行器名称传递给每个方法的`@Async`注解。
- en: To enable asynchronous support, the `@Async` annotation is not enough; we need
    to use the `@EnableAsync` annotation in our configuration classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用异步支持，`@Async`注解是不够的；我们需要在配置类中使用`@EnableAsync`注解。
- en: In Spring MVC, when we configure `DispatcherServlet` using the `AbstractAnnotationConfigDispatcherServletInitializer`
    initializer class, which extends `AbstractDispatcherServletInitializer`, it has
    the `isAsyncSupported` flag enabled by default.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC中，当我们使用`AbstractAnnotationConfigDispatcherServletInitializer`初始化类配置`DispatcherServlet`时，它默认启用了`isAsyncSupported`标志。
- en: 'Now, we need to declare a thread pool definition for asynchronous method invocation.
    In Spring MVC Java-based configuration, this can be done by overriding the `configureAsyncSupport()` method
    of the `WebMvcConfigurer` interface in the Spring Web MVC configuration class.
    Let''s override this method, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为异步方法调用声明一个线程池定义。在Spring MVC基于Java的配置中，可以通过在Spring Web MVC配置类中覆盖`WebMvcConfigurer`接口的`configureAsyncSupport()`方法来实现。让我们按照以下方式覆盖这个方法：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding method, we have configured the thread pool executor by overriding
    the `configureAsyncSupport()` method. Now, let''s call the asynchronous method
    created in the service class `BankAsyncService` by using a controller class, as
    follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们通过覆盖`configureAsyncSupport()`方法配置了线程池执行程序。现在，让我们通过控制器类调用服务类`BankAsyncService`中创建的异步方法，如下所示：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, when we request `/syncacct`, it will invoke `syncAccount()`
    and return the result of the asynchronous method in a separate thread.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当我们请求`/syncacct`时，它将调用`syncAccount()`并在单独的线程中返回异步方法的结果。
- en: CompletableFuture with Spring Async
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring异步的CompletableFuture
- en: The `CompletableFuture` class was introduced in Java 8, and it provides a simple
    way to write asynchronous, multithreaded, non-blocking code. With Spring MVC,
    it is also possible to use `CompletableFuture` with controllers, services, and
    repositories from public methods annotated with `@Async`. `CompletableFuture`
    implements the `Future` interface, which provides the result of an asynchronous
    computation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类是在Java 8中引入的，它提供了一种简单的方式来编写异步、多线程、非阻塞的代码。在Spring MVC中，也可以在使用`@Async`注解的公共方法的控制器、服务和存储库中使用`CompletableFuture`。`CompletableFuture`实现了`Future`接口，该接口提供了异步计算的结果。'
- en: 'We can create `CompletableFuture` in the following simple way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下简单方式创建`CompletableFuture`：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To get the result of this `CompletableFuture`, we can call the `CompletableFuture.get()`
    method. This method will be blocked until `Future` is completed. For that, we
    can manually call the `CompletableFuture.complete()` method to `complete` `Future`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这个`CompletableFuture`的结果，我们可以调用`CompletableFuture.get()`方法。该方法将被阻塞，直到`Future`完成。为此，我们可以手动调用`CompletableFuture.complete()`方法来`complete`
    `Future`：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: runAsync() – running a task asynchronously
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: runAsync() - 异步运行任务
- en: When we want to execute a background activity task asynchronously and do not
    want to return anything from that task, we can use the `CompletableFuture.runAsync()`
    method. It takes a parameter as a `Runnable` object and returns the `CompletableFuture<Void>`
    type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要异步执行后台活动任务，并且不想从该任务中返回任何东西时，我们可以使用`CompletableFuture.runAsync()`方法。它以`Runnable`对象作为参数，并返回`CompletableFuture<Void>`类型。
- en: 'Let''s try to use the `runAsync()` method by creating another controller method
    in our `BankController` class, with the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过在我们的`BankController`类中创建另一个控制器方法来使用`runAsync()`方法，如下所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, when a request comes with the `/synccust` path, it
    will run `syncCustomerAccount()` in a separate thread and will complete the task
    without returning any value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当请求使用`/synccust`路径时，它将在单独的线程中运行`syncCustomerAccount()`，并在不返回任何值的情况下完成任务。
- en: supplyAsync() – running a task asynchronously, with a return value
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: supplyAsync() - 异步运行任务，带有返回值
- en: When we want to return a result after finishing a task asynchronously, we can
    use `CompletableFuture.supplyAsync()`. It takes `Supplier<T>` as a parameter and
    returns `CompletableFuture<T>`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在异步完成任务后返回结果时，我们可以使用`CompletableFuture.supplyAsync()`。它以`Supplier<T>`作为参数，并返回`CompletableFuture<T>`。
- en: 'Let''s check the `supplyAsync()` method by creating another controller method
    in our `BankController` class, with the following example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们的`BankController`类中创建另一个控制器方法来检查`supplyAsync()`方法，示例如下：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `CompletableFuture` object uses the global thread pool, `ForkJoinPool.commonPool()`,
    to execute tasks in a separate thread. We can create a thread pool and pass it
    to `runAsync()` and `supplyAsync()` methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`对象使用全局线程池`ForkJoinPool.commonPool()`在单独的线程中执行任务。我们可以创建一个线程池并将其传递给`runAsync()`和`supplyAsync()`方法。'
- en: 'The following are two variants of the `runAsync()` and `supplyAsync()` methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`runAsync()`和`supplyAsync()`方法的两种变体：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Attaching a callback to the CompletableFuture
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将回调附加到CompletableFuture
- en: '`CompletableFuture.get()` blocks the object and waits until the `Future` task
    is completed and the result is returned. To build an asynchronous system, there
    should be a callback, automatically called when the `Future` task has completed.
    We can attach a callback to `CompletableFuture` by using the `thenApply()`, `thenAccept()`,
    and `thenRun()` methods.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture.get()`会阻塞对象，并等待`Future`任务完成并返回结果。要构建一个异步系统，应该有一个回调，在`Future`任务完成时自动调用。我们可以使用`thenApply()`、`thenAccept()`和`thenRun()`方法将回调附加到`CompletableFuture`。'
- en: Spring Security configuration
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: 'Spring Security is a widely used security service framework for Java EE-based
    enterprise applications. At the authentication level, Spring Security provides
    different kinds of authentication models. Some of these models are provided by
    third parties, and some sets of authentication features are provided by Spring
    Security itself. Some of the following authentication mechanisms are provided
    by Spring Security:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是Java EE企业应用程序广泛使用的安全服务框架。在认证级别上，Spring Security提供了不同类型的认证模型。其中一些模型由第三方提供，一些认证功能集由Spring
    Security自身提供。Spring Security提供了以下一些认证机制：
- en: Form-based authentication
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表单的认证
- en: OpenID authentication
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID认证
- en: LDAP specifically used in large environments
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP专门用于大型环境
- en: Container-managed authentication
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的认证
- en: Custom authentication systems
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义认证系统
- en: JAAS
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAAS
- en: Let's look at an example to activate Spring Security in a web application. We
    will use an in-memory configuration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例来在Web应用程序中激活Spring Security。我们将使用内存配置。
- en: Configuring Spring Security dependencies
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Security依赖项
- en: 'To configure Spring Security in a web application, we need to add the following
    Maven dependencies to our **Project Object Model** (**POM**) file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Web应用程序中配置Spring Security，我们需要将以下Maven依赖项添加到我们的**项目对象模型**（**POM**）文件中：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Configuring a security filter for incoming requests
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为传入请求配置安全过滤器
- en: 'When implementing security in a web application, it is better to validate all
    of the incoming requests. In Spring Security, the framework itself looks at the
    incoming request and authenticates the user to perform an action, based on the
    provided access. To intercept all of the incoming requests to a web application,
    we need to configure `filter`, `DelegatingFilterProxy`, which will delegate the
    requests to a Spring-managed bean, `FilterChainProxy`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中实现安全性时，最好验证所有传入的请求。在Spring Security中，框架本身查看传入的请求并验证用户以执行操作，基于提供的访问权限。为了拦截Web应用程序的所有传入请求，我们需要配置`filter`，`DelegatingFilterProxy`，它将把请求委托给Spring管理的`FilterChainProxy`：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Based on the `filter` configuration, all of the requests will go through this
    `filter`. Now, let's configure security-related stuff, like authentication, URL
    security, and role access.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`filter`配置，所有请求将通过此`filter`。现在，让我们配置与安全相关的内容，如身份验证、URL安全和角色访问。
- en: Configuring Spring Security
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Security
- en: 'Now, we will configure Spring Security authentication and authorization by
    creating a Spring Security configuration class as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过创建Spring Security配置类来配置Spring Security身份验证和授权，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s understand the preceding configuration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解上述配置：
- en: '`@EnableWebSecurity`: It enables Spring Security''s web security support, and
    also provides the Spring MVC integration.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@EnableWebSecurity：它启用了Spring Security的Web安全支持，并提供了Spring MVC集成。'
- en: '`WebSecurityConfigurerAdapter`: It provides a set of methods that are used
    to enable specific web security configuration.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSecurityConfigurerAdapter`：它提供了一组方法，用于启用特定的Web安全配置。'
- en: '`protected void configure(AuthenticationManagerBuilder auth)`: We have used
    in-memory authentication in this example. It can be used to connect to the database
    using `auth.jdbcAuthentication()`, or to a **Lightweight Directory Access Protocol** (**LDAP**)
    using `auth.ldapAuthentication()`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected void configure(AuthenticationManagerBuilder auth)`: 在本示例中，我们使用了内存认证。它可以用于使用`auth.jdbcAuthentication()`连接到数据库，或者使用`auth.ldapAuthentication()`连接到**轻量级目录访问协议**（**LDAP**）。'
- en: '`.passwordEncoder(passwordEncoder)`: We have used the password encoder `BCryptPasswordEncoder`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.passwordEncoder(passwordEncoder)`: 我们使用了密码编码器`BCryptPasswordEncoder`。'
- en: '`.withUser("user").password(passwordEncoder.encode("user@123"))`: It sets the
    user ID and encoded password for authentication.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.withUser("user").password(passwordEncoder.encode("user@123"))`: 为认证设置用户ID和编码密码。'
- en: '`.roles("USER")`: It assigns roles to the user.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.roles("USER")`: 为用户分配角色。'
- en: '`protected void configure(HttpSecurity http)`: It is used to secure different
    URLs that need security.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected void configure(HttpSecurity http)`: 用于保护需要安全性的不同URL。'
- en: '`.antMatchers("/login").permitAll()`: It permits all of the users to access
    the login page.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.antMatchers("/login").permitAll()`: 允许所有用户访问登录页面。'
- en: '`.antMatchers("/admin/**").hasRole("ADMIN")`: It permits access to the admin
    panel to the users who have the `ADMIN` role.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.antMatchers("/admin/**").hasRole("ADMIN")`: 允许具有`ADMIN`角色的用户访问管理员面板。'
- en: '`.antMatchers("/**").anyRequest().hasAnyRole("ADMIN", "USER")`: It means that
    to make any request with `"/"`, you must be logged in with the `ADMIN` or `USER`
    role.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.antMatchers("/**").anyRequest().hasAnyRole("ADMIN", "USER")`: 这意味着对于带有`"/"`的任何请求，您必须使用`ADMIN`或`USER`角色登录。'
- en: '`.and().formLogin()`: It will provide a default login page, with username and
    password fields.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.and().formLogin()`: 它将提供一个默认的登录页面，带有用户名和密码字段。'
- en: '`.and().logout().logoutSuccessUrl("/login").permitAll()`: It sets the logout
    success page when a user logs out.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.and().logout().logoutSuccessUrl("/login").permitAll()`: 当用户注销时，设置注销成功页面。'
- en: '`.csrf().disable()`: By default, the **Cross Site Request Forgery** (**CSRF**)
    flag is enabled. Here, we have disabled it from configuration.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.csrf().disable()`: 默认情况下，**跨站请求伪造**（**CSRF**）标志是启用的。在这里，我们已经从配置中禁用了它。'
- en: Adding a controller
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个控制器
- en: 'We will use the following `BankController` class for URL mapping:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下`BankController`类进行URL映射：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, when we run this example, it will first show the login authentication form
    provided by the Spring Framework, before we try to access any URL of the web application.
    If a user logs in with the `USER` role and tries to access the admin panel, they
    will be restricted from accessing it. If a user logs in with the `ADMIN` role,
    they will be able to access both the user panel and the admin panel.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个例子时，它将首先显示由Spring框架提供的登录身份验证表单，然后再尝试访问Web应用程序的任何URL。如果用户使用`USER`角色登录并尝试访问管理员面板，他们将被限制访问。如果用户使用`ADMIN`角色登录，他们将能够访问用户面板和管理员面板。
- en: Authentication cache
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证缓存
- en: Spring Security performance becomes one of the major concerns when there is
    a maximum number of calls hit on the application. By default, Spring Security
    creates a new session for each new request and prepares a new security context
    every single time. This becomes an overhead when maintaining user authentication,
    and due to that, performance is lowered.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序受到最大数量的调用时，Spring Security的性能成为一个主要关注点。默认情况下，Spring Security为每个新请求创建一个新会话，并每次准备一个新的安全上下文。在维护用户身份验证时，这会成为一个负担，从而降低性能。
- en: 'For example, we have an API that requires authentication on each request. If
    there are multiple calls made to this API, it will impact the performance of the
    application which uses this API. So, let''s understand this problem without a
    caching implementation. Take a look at the following logs, where we call an API
    using the `curl` command, without a caching implementation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个API，每个请求都需要身份验证。如果对该API进行多次调用，将会影响使用该API的应用程序的性能。因此，让我们在没有缓存实现的情况下了解这个问题。看一下以下日志，我们使用`curl`命令调用API，没有缓存实现：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Take a look at the following log:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下日志：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each time we call this API, it will authenticate the username and password with
    the database value. This affects the application performance and can lead to an
    unnecessary load if users are making frequent calls.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此API时，它将使用数据库值对用户名和密码进行身份验证。这会影响应用程序的性能，并且如果用户频繁调用，可能会导致不必要的负载。
- en: 'One of the dignified solutions to overcome this issue is caching the user authentication
    for a specific time limit. We will use the implementation of `UserCache` with
    a properly configured `AuthenticationProvider`, and pass it to `AuthenticationManagerBuilder`.
    We will use `EhCache` to play with the cached object. We can employ this solution
    through the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这个问题的一个体面的解决方案之一是缓存用户身份验证一段特定的时间。我们将使用带有正确配置的`AuthenticationProvider`的`UserCache`的实现，并将其传递给`AuthenticationManagerBuilder`。我们将使用`EhCache`来操作缓存对象。我们可以通过以下步骤来使用这个解决方案：
- en: Implementing the caching configuration class
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现缓存配置类
- en: Providing `UserCache` to `AuthenticationProvider`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AuthenticationProvider`提供`UserCache`
- en: Providing `AuthenticationProvider` to `AuthenticationManagerBuilder`
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AuthenticationManagerBuilder`提供`AuthenticationProvider`
- en: Implementing the caching configuration class
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现缓存配置类
- en: 'We have created the following class, which will provide the `UserCache` bean
    that will provide it to `AuthenticationProvider`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了以下类，它将提供`UserCache` bean，并将其提供给`AuthenticationProvider`：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding class, `@EnableCaching` enables cache management.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述类中，`@EnableCaching`启用了缓存管理。
- en: Providing UserCache to AuthenticationProvider
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向AuthenticationProvider提供UserCache
- en: 'Now, we will provide the created `UserCache` bean to `AuthenticationProvider`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建的`UserCache` bean提供给`AuthenticationProvider`：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Providing AuthenticationProvider to AuthenticationManagerBuilder
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向AuthenticationManagerBuilder提供AuthenticationProvider
- en: 'Now, let''s provide `AuthenticationProvider` to `AuthenticationManagerBuilder`
    in the Spring Security configuration class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Spring Security配置类中向`AuthenticationManagerBuilder`提供`AuthenticationProvider`：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s call that API and check the performance of authentication. If we
    call the API four times, the following log will be generated:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用该API并检查身份验证的性能。如果我们调用API四次，将生成以下日志：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the preceding log, initially, `AuthenticationProvider` searches
    the `UserDetails` object from the cache; if it fails to get it from the cache, `AuthenticationProvider`
    will query the database for `UserDetails` and will put the updated object into
    the cache and for all the later calls, it will retrieve the `UserDetails` object
    from the cache.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的日志中所看到的，最初，`AuthenticationProvider`从缓存中搜索`UserDetails`对象；如果它无法从缓存中获取，`AuthenticationProvider`将查询数据库以获取`UserDetails`，并将更新后的对象放入缓存中，以便以后的所有调用都将从缓存中检索`UserDetails`对象。
- en: If you update the password for a user and try to authenticate the user with
    the new password, and it fails to match the value in the cache, then it will query
    the `UserDetails` from the database.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更新用户的密码并尝试使用新密码对用户进行身份验证，但与缓存中的值不匹配，则它将从数据库中查询`UserDetails`。
- en: Fast and stateless API authentication with Spring Security
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security实现快速和无状态的API身份验证
- en: Spring Security also provides stateless APIs for securing non-browser clients,
    such as mobile applications or other apps. We will learn how to configure Spring
    Security for securing stateless APIs. Also, we will figure out the important points
    that need to be considered when designing security solutions and improving the
    performance of user authentication.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security还提供了用于保护非浏览器客户端（如移动应用程序或其他应用程序）的无状态API。我们将学习如何配置Spring Security来保护无状态API。此外，我们将找出在设计安全解决方案和提高用户身份验证性能时需要考虑的重要点。
- en: API authentication with the JSESSIONID cookie
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API身份验证需要JSESSIONID cookie
- en: 'It''s not a good practice for API clients to use form-based authentication,
    due to the essential need for providing a `JSESSIONID` cookie with the chain of
    requests. Spring Security also provides an option to use HTTP basic authentication,
    which is an older approach but works fine. In the HTTP basic authentication approach,
    user/password details need to be sent with a request header. Let''s take a look
    at the following example of an HTTP basic authentication configuration:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API客户端使用基于表单的身份验证并不是一个好的做法，因为需要在请求链中提供`JSESSIONID` cookie。Spring Security还提供了使用HTTP基本身份验证的选项，这是一种较旧的方法，但效果很好。在HTTP基本身份验证方法中，用户/密码详细信息需要与请求头一起发送。让我们看一下以下HTTP基本身份验证配置的示例：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, the `configure()` method is from the `WebSecurityConfigurerAdapter`
    abstract class, which provides a default implementation of this method. The subclasses
    should invoke this method by calling `super`, as it may override their configuration.
    This configuration approach has one disadvantage; whenever we call the secured
    endpoint, it creates a new session. Let''s check this by using the `curl` command
    to call the endpoint:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`configure()`方法来自`WebSecurityConfigurerAdapter`抽象类，该类提供了此方法的默认实现。子类应该通过调用`super`来调用此方法，因为它可能会覆盖它们的配置。这种配置方法有一个缺点；每当我们调用受保护的端点时，它都会创建一个新的会话。让我们使用`curl`命令来调用端点来检查一下：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have one session ID cookie; let''s call it again:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个会话ID cookie；让我们再次调用它：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we have two different session IDs in each response. In the preceding
    example, for testing purposes, we sent the `Authorization` header with an encoded
    username and password. You can get the `Basic Y3VzdDAwMTpDdXN0QDEyMw==` header
    value from the browser when you hit the URL, by providing a username and password
    for authentication.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个响应中都有两个不同的会话ID。在上面的示例中，为了测试目的，我们发送了带有编码的用户名和密码的`Authorization`头。当您提供用户名和密码进行身份验证时，您可以从浏览器中获取`Basic
    Y3VzdDAwMTpDdXN0QDEyMw==`头值。
- en: API authentication without the JSESSIONID cookie
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API身份验证不需要JSESSIONID cookie
- en: 'As there is no need for sessions for API client authentication, we can easily
    get rid of the session ID with the following configuration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API客户端身份验证不需要会话，我们可以通过以下配置轻松摆脱会话ID：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, in the preceding configuration, we have used `SessionCreationPolicy.STATELESS`.
    With this option, there will not be a session cookie added in the response header.
    Let''s see what happens after this change:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在前面的配置中，我们使用了`SessionCreationPolicy.STATELESS`。通过这个选项，在响应头中不会添加会话cookie。让我们看看在这个改变之后会发生什么：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, there is no session cookie found in the response header.
    So, in this way, we can manage stateless authentication for APIs using Spring
    Security.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，在响应头中找不到会话cookie。因此，通过这种方式，我们可以使用Spring Security管理API的无状态身份验证。
- en: Monitoring and managing Tomcat with JMX
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JMX监控和管理Tomcat
- en: '**Java Management Extension** (**JMX**) provides a powerful mechanism to monitor
    and manage Java applications. It can be enabled in Tomcat to monitor threads,
    CPU usage, and heap memory, and to configure **MBeans**. Spring provides JMX support
    out of the box, and we can use it to easily integrate our Spring application into
    JMX architecture.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java管理扩展**（**JMX**）提供了一种强大的机制来监视和管理Java应用程序。它可以在Tomcat中启用，以监视线程、CPU使用率和堆内存，并配置**MBeans**。Spring提供了开箱即用的JMX支持，我们可以使用它轻松地将我们的Spring应用程序集成到JMX架构中。'
- en: 'JMX support provides the following core features:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JMX支持提供以下核心功能：
- en: Easy and flexible support for controlling the management interface of beans
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松灵活地支持控制bean的管理接口
- en: Declarative support for exposing MBeans over remote connectors
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明支持通过远程连接器公开MBean
- en: Automatic registration of Spring beans as JMX MBean
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Spring bean自动注册为JMX MBean
- en: Simplified support to proxy both local and remote MBean resources
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化支持代理本地和远程MBean资源
- en: 'JMX functionality has three levels:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JMX功能有三个级别：
- en: '**Instrumentation level**: This level contains the components and resources
    that are represented by one or more Java beans, which are known as **managed beans,**
    or MBean.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器级别：**这个级别包含由一个或多个Java bean表示的组件和资源，这些组件和资源被称为**托管bean**或MBean。'
- en: '**Agent level**: This is known as an intermediate agent, called the **MBean
    server**. It gets the request from the remote management level and passes it to
    the appropriate MBean. It can also receive notifications related to state changes from
    MBeans and forward them back to the remote management level.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理级别：**这被称为中间代理，称为**MBean服务器**。它从远程管理级别获取请求，并将其传递给适当的MBean。它还可以接收来自MBean的与状态更改相关的通知，并将其转发回远程管理级别。'
- en: '**Remote management level:** This layer is made of connectors, adapters, or
    client programs. It sends requests to the agent level and receives the responses
    to the requests. Users can connect to the MBean server using either a connector
    or a client program, such as JConsole, with a protocol such as **Remote Method
    Invocation** (**RMI**) or **Internet Inter-ORB Protocol** (**IIOP**), and use
    an adapter.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程管理级别：**这一层由连接器、适配器或客户端程序组成。它向代理级别发送请求，并接收请求的响应。用户可以使用连接器或客户端程序（如JConsole）连接到MBean服务器，使用**远程方法调用**（**RMI**）或**Internet互操作对象协议**（**IIOP**）等协议，并使用适配器。'
- en: In short, a user at the remote management level sends a request to the agent
    level, which finds the appropriate MBean at the instrumentation level, and sends
    the response back to the user.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Connecting JMX to monitor Tomcat
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure JMX on Tomcat, we need to set the relevant system properties upon
    JVM startup. We can use the following methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the `catalina.sh` or `catalina.bat` file in `{tomcat-folder}\bin\`,
    adding the following values:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For example, we can add the following values at `{tomcat-folder}\bin\catalina.bat`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you want to configure JMX for your Tomcat in Eclipse, you need to do the
    following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Go to Window | Show View | Server.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Tomcat Overview configuration window by double-clicking on Tomcat v8.0
    Server at localhost.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under General Information, click on Open launch configuration.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Arguments tab of Edit launch configuration properties.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In VM arguments, add the following properties, and then click OK:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After making this change, we need to restart the Tomcat server. After that,
    we need to test the connection with JConsole. After opening JConsole, we need
    to provide Remote Process with a hostname and port number, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/971e79e2-6a7a-4f18-9236-1ec792804c7e.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we have provided the hostname as `localhost` and
    the port number as `8990`. When you click on Connect, you will get a dialog box
    where you need to click on Insecure connection, and then you will be connected
    to JConsole.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Creating an MBean
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an MBean, we can use `@Managed` annotations to convert any class
    into an MBean. The class `BankTransferService` transfers an amount from one account
    to another. We will use this example for further understanding:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding class, the `@ManagedResource` annotation will mark the class
    as MBean, and the `@ManagedAttribute` and `@ManagedOperation` annotations can
    be used to expose any attributes or methods. The `@Component` annotation will
    make sure that all classes annotated with `@Component`, `@Service`, or `@Repository`
    will be added to the Spring context.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Exporting an MBean in a Spring context
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need to create an `MBeanExporter` in a Spring application context.
    We just need to add the following tag in the Spring context XML configuration:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We need to add the `component-scan` element before the `‹context:mbean-export/›`
    element; otherwise, the JMX server will not be able to find any beans.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our Spring context configuration will look like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we just need to start our Tomcat server and open the JConsole to see our
    MBean. After connecting to JConsole, go to the MBeans tab, where you can see our
    package folder, which contains our `BankMoneyTransferService` MBean, listed in
    the sidebar:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb0dd8cb-79e4-4ea8-b8e7-d43d3b5e9989.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: As you can see in the earlier example, our MBean is generated and listed in
    the JConsole. Now, we can transfer an amount from one account to another by clicking
    on the Transfer button, invoking the method `transfer()`, which we created in
    our MBean. When we click on the checkBalance button, it will show the current
    balance in a pop up based on the entered account number. In the background, it
    will invoke the `checkBalance()` method of the `BankMoneyTransferService` class.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC performance improvements
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC application performance can be improved through multiple strategies
    and tips. Here, we have listed some of the strategies that can improve the performance
    enormously:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: High performance using connection pooling
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hibernate improvements
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing improvements
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper server maintenance
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the authentication cache with Spring Security
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Executor service framework
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High performance using connection pooling
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standout amongst the most important features to enhance performance in Spring
    MVC is **connection pooling**. In this mechanism, *N* number of database connections
    are created and managed in a pool to increase the application's performance. When
    an application needs to utilize a connection, it just requests a connection, uses
    it, and then returns it to the pool. The main advantage of this procedure is that
    there are connections promptly available in the connection pool, so they can be
    utilized right away. The pool itself deals with the life cycle of the connection,
    so the developer doesn't have to wait for the connection to get established.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate improvements
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another major point to enhance performance is regarding Hibernate. Dirty checking
    is one of the features provided by Hibernate. In dirty checking, Hibernate automatically
    distinguishes whether an object is modified and needs to be updated. Hibernate
    does the dirty work to keep a mind on the performance cost, whenever required.
    At the point when a specific entity has a corresponding table with a large number
    of columns, the cost increases. To minimize the dirty checking cost, we can set
    the transaction to `readOnly`, which will increase the performance and eliminate
    the need for any dirty checks:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another improvement related to Hibernate can be taken care is by flushing and
    clearing the Hibernate session intermittently. At the point when data is inserted/modified
    in the database, Hibernate stores a version of the entities already persisted
    in its session, just in case they are updated again before the session is closed.
    We can restrict Hibernate from storing the entities in its session longer than
    really required. Once data is inserted, we do not need to store the entities in
    the persistent state anymore. We can therefore safely flush and clear the `entityManager`
    to synchronize the state of entities with the database and delete the entities
    from the cache. This will keep the application away from memory constraints, and
    is sure to positively impact performance:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: One more improvement can be made by using **lazy initialization**. If we are
    using Hibernate, we should make sure that the lazy initialization feature is used
    properly. We should only use lazy load for the entities if it is required. For
    example, if we have a custom entity collection like `Set<Employee>` which is configured
    for lazy initialization, then each entity of that collection will be loaded separately
    using individual queries. So, if there are multiple entities lazy initialized
    in a set, then there will a large number of queries executed in sequence, which
    can majorly impact the performance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Testing improvements
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For testing improvements, we can build a test environment where an application
    can be executed, and get the result inside of it. We can write repeatable performance
    testing scripts and focus on both the absolute performance (like the page rendering
    time) and the performance on a scale (like the performance degrade on load). We
    can use a profiler in our test environment.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Proper server maintenance
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One major performance aspect is related to proper server maintenance (if performance
    is the main concern). The following are some important points that should be considered
    to improve performance:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning the temporary files periodically by creating a scheduled automated
    script.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a load balancer when multiple server instances are running.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the configuration based on the application needs. For example, in
    the case of Tomcat, we can refer to Tomcat configuration recommendations.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the authentication cache with Spring Security
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be a significant point of view to enhance performance, which can be
    identified when using Spring Security. Spring Security should be properly configured
    to improve performance when the request handling time is measured to be on the
    undesirable side. There might be a case where the actual request handling time
    is measured around 100 ms and Spring Security authentication adds 400-500 extra
    milliseconds. We can eliminate this performance cost using an authentication cache
    with Spring Security.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Spring Security时，可以找到提高性能的重要观点。当请求处理时间被认为是不理想的时候，应该正确配置Spring Security以提高性能。可能存在这样一种情况，实际请求处理时间大约为100毫秒，而Spring
    Security认证额外增加了400-500毫秒。我们可以使用Spring Security的认证缓存来消除这种性能成本。
- en: Implementing Executor service framework
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Executor服务框架
- en: With all possible improvements, if concurrency is maintained in terms of request
    handling, performance can be improved. There might be a case when load testing
    is performed with multiple concurrent hits to our application, and it may affect
    our application’s performance. In such cases, we should tune up the thread defaults
    on the Tomcat server. In the event that there is high concurrency, the HTTP requests
    will be put on hold until a thread becomes available to process them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有可能的改进，如果在请求处理方面保持并发性，性能可以得到改善。可能存在这样一种情况，即对我们的应用程序进行多个并发访问的负载测试，这可能会影响我们应用程序的性能。在这种情况下，我们应该调整Tomcat服务器上的线程默认值。如果存在高并发性，HTTP请求将被暂停，直到有一个线程可用来处理它们。
- en: The default server thread implementation can be extended by using the Executor
    framework within our business logic, to make concurrent asynchronous calls from
    within a method in a single thread execution flow.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在业务逻辑中使用Executor框架来扩展默认的服务器线程实现，可以实现并发异步调用。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got a clear idea of the Spring MVC module and learned about
    different configuration methods. We also learned about the Spring asynchronous
    processing concept, with `CompletableFeature` implementation. After that, we went
    through the Spring Security module and learned about configuration. We also understood
    the authentication part of Spring Security with the stateless API. Then, we went
    through the monitoring part of Tomcat with JMX. At the end, we looked at Spring
    MVC performance improvements.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对Spring MVC模块有了清晰的了解，并学习了不同的配置方法。我们还学习了Spring异步处理概念，以及`CompletableFeature`的实现。之后，我们学习了Spring
    Security模块的配置。我们还了解了Spring Security的认证部分和无状态API。然后，我们学习了Tomcat的监控部分和JMX。最后，我们看了Spring
    MVC的性能改进。
- en: In the next chapter, we will learn about Spring database interaction. We will
    start with Spring JDBC configuration with optimal database design and configuration.
    Then, we will go through the optimal connection pooling configuration. We will
    also cover the concept of `@Transactional` for performance improvement. Finally,
    we will go through database design best practices.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Spring数据库交互的知识。我们将从Spring JDBC配置和最佳数据库设计和配置开始。然后，我们将介绍最佳连接池配置。我们还将涵盖“@Transactional”概念以提高性能。最后，我们将介绍数据库设计的最佳实践。

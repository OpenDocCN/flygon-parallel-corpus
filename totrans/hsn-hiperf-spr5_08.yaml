- en: Multithreading and Concurrent Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程和并发编程
- en: In the previous chapter, we learned how we can optimize Spring messaging. We
    also learned various configuration tips and tricks that help us to improve the
    performance of our application. We also looked at the monitoring and configuration
    of JMS and RabbitMQ for optimal performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何优化Spring消息传递。我们还学习了各种配置技巧，帮助我们提高应用程序的性能。我们还研究了监视和配置JMS和RabbitMQ以实现最佳性能。
- en: In this chapter, we will cover the core concept of Java threads and then will
    move to advanced thread support provided by the `java.util.concurrent` package.
    For this package, we will see various classes and interfaces that help us write
    multithreaded and concurrent programming. We will also learn how we can use Java
    `ThreadPool` to improve performance. We will walk through useful functionalities
    provided by the Spring Framework, such as task executing, scheduling, and running
    as asynchronous. Finally, we will look into Spring transaction management with
    threads and various best programming practices for threads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Java线程的核心概念，然后将转向`java.util.concurrent`包提供的高级线程支持。对于这个包，我们将看到各种类和接口，帮助我们编写多线程和并发编程。我们还将学习如何使用Java线程池来提高性能。我们将介绍Spring框架提供的有用功能，如任务执行、调度和异步运行。最后，我们将探讨Spring事务管理与线程以及线程的各种最佳编程实践。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Java classical threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java经典线程
- en: The `java.util.concurrent` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包'
- en: Using the thread pools for asynchronous processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池进行异步处理
- en: Spring task execution and scheduling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring任务执行和调度
- en: Spring Async
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring异步
- en: Spring and threads—transactions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring和线程-事务
- en: Java threads best programming practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java线程最佳编程实践
- en: Java classical threads
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java经典线程
- en: Java applications execute via threads, which are an independent path of execution
    within a program. Any Java program has at least one thread, known as the main
    thread, which is created by **Java Virtual Machine** (**JVM**). Java is a multithreaded
    application that allows multiple thread execution at any particular time and these
    threads can run concurrently, either asynchronously or synchronously. When multiple
    threads are executing, each thread's path can differ from the other thread's paths.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序通过线程执行，线程是程序内部的独立执行路径。任何Java程序至少有一个线程，称为主线程，由Java虚拟机（JVM）创建。Java是一个多线程应用程序，允许在任何特定时间执行多个线程，并且这些线程可以并发地运行，无论是异步还是同步。当多个线程执行时，每个线程的路径可以与其他线程的路径不同。
- en: The JVM provides each thread with its own stack to prevent threads from interfering
    with each other. Separate stacks help threads keep track of their next instructions
    to execute, which can differ from thread to thread. The stack also gives a thread
    its own copy of method parameters, local variables, and the return value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JVM为每个线程提供自己的堆栈，以防止线程相互干扰。单独的堆栈帮助线程跟踪它们要执行的下一个指令，这可以与其他线程不同。堆栈还为线程提供了方法参数、局部变量和返回值的副本。
- en: Threads live within a process and share their resources, such as memory and
    open files, with the other threads of the process. The ability to share resources
    between different threads makes them more susceptible to errors where performance
    is a significant requirement. Every thread in Java is created and controlled by
    the `java.lang.Thread` class and the `java.lang.Runnable` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 线程存在于一个进程中，并与进程的其他线程共享资源，如内存和打开的文件。在不同线程之间共享资源的能力使它们更容易受到性能要求的影响。在Java中，每个线程都是由`java.lang.Thread`类和`java.lang.Runnable`接口创建和控制的。
- en: Creating threads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程
- en: 'Threads are objects in the Java language. They can be created using the following
    mechanisms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是Java语言中的对象。可以使用以下机制创建线程：
- en: Create a class that implements the `Runnable` interface
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现`Runnable`接口的类
- en: Create a class that extends the `Thread` class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个扩展`Thread`类的类
- en: 'There are two ways to create a `Runnable` object. The first way is to create
    a class that implements the `Runnable` interface as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建`Runnable`对象的方法。第一种方法是创建一个实现`Runnable`接口的类，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before Java 8, we only had this way to create a `Runnable` object. But since
    Java 8, we can create a `Runnable` object using a Lambda expression.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，我们只能使用这种方式创建`Runnable`对象。但自Java 8以来，我们可以使用Lambda表达式创建`Runnable`对象。
- en: 'After creating the `Runnable` object, we need to pass it to a `Thread` constructor
    that receives a `Runnable` object as an argument:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Runnable`对象后，我们需要将其传递给接受`Runnable`对象作为参数的`Thread`构造函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some constructors don''t take the `Runnable` object as an argument, such as `Thread()`.
    In that case, we need to take another approach in order to create a thread:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有些构造函数不接受`Runnable`对象作为参数，比如`Thread()`。在这种情况下，我们需要采取另一种方法来创建线程：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thread life cycle and states
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程生命周期和状态
- en: Understanding the thread life cycle and states is very important when working
    with threads and multithreaded environments. In the previous examples, we saw
    how we can create the Java thread object using the `Thread` class and the `Runnable`
    interface. But to start the thread, we have to first create the thread object
    and call its `start()` method to execute the `run()` method as a thread.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理线程和多线程环境时，了解线程生命周期和状态非常重要。在前面的例子中，我们看到了如何使用`Thread`类和`Runnable`接口创建Java线程对象。但是要启动线程，我们必须首先创建线程对象，并调用其`start()`方法来执行`run()`方法作为线程。
- en: 'The following are different states of the thread life cycle in Java:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java线程生命周期的不同状态：
- en: '**New**: The thread is in the new state when it is created with a `new` operator.
    At this stage, the thread is not alive.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**New**：使用`new`运算符创建线程时，线程处于新状态。在这个阶段，线程还没有启动。'
- en: '**Runnable**: The thread is in the runnable state when we call the `start()`
    method of the thread object. At this stage, the thread scheduler still does not
    pick it for running.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running**: The thread state is changed from runnable to running when the
    thread scheduler has selected it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocked/waiting**: The thread state is blocked/waiting when it is currently
    not eligible to run.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminated/dead**: The thread state is terminated/dead when it executes its
    run method. At this stage, it''s considered to be not alive.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced thread tasks
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the thread life cycle and its states, but threads also support
    some advanced tasks, such as sleeping, joining, and interrupting. Let''s discuss
    them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**Sleeping**: The `sleep()` thread method can be used to pause the execution
    of the current thread for the specified amount of time.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joining**: The `join()` thread method can be used to pause the execution
    of the current thread until the thread it joins completes its task.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupting**: The `interrupt()` thread method can be used to break out
    the sleeping or waiting state of the thread. It throws `InterruptedException`
    if the thread is in the sleeping or waiting state, otherwise, it doesn''t interrupt
    the thread but sets the interrupted flag to true.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing threads
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In multithreaded applications, there might be situations where multiple threads
    try to access a shared resource and produce erroneous and unexpected results.
    We need to ensure that the resource will be used by only one thread at a time,
    and that can be achieved by synchronization. The `synchronized` keyword is used
    to achieve synchronization; when we define any synchronized block in Java, only
    one thread can access that block and other threads are blocked until the thread
    inside the block exits that block.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The `synchronized` keyword can be used with the following different types of
    blocks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code blocks inside instance methods
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code blocks inside static methods
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, a synchronized block degrades performance. We must use the `synchronized`
    keyword when required, otherwise, we should use the synchronized block of the
    critical section only where it is required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Issues with multithreading
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading is a very powerful mechanism that helps us to better utilize
    the system's resources, but we need to take special care while reading and writing
    data shared by multiple threads. There are two basic problems with multithreading
    programming—visibility and access problems. A visibility problem occurs when the
    effects of one thread can be seen by another. An access problem can occur when
    the same shared resources are accessed by multiple threads at the same time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Due to visibility and access problems, a program does not react any more and
    it leads to deadlocks or generates incorrect data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.concurrent package
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we focused on Java's low-level support for threads.
    In this section, we will move on to look at Java's high-level thread support provided
    by the `java.util.concurrent` package. This package has various classes and interfaces
    that provide very useful functionalities to help us implement multithreaded and
    concurrent programming. In this section, we will mainly focus on some of the most
    useful utilities of this package.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the high-level overview of the `java.util.concurrent`
    API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc28c2a8-acac-4718-a085-9dab2fe53a72.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Let's discuss the interfaces in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Executors
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Executor` provides an abstraction layer over all the internal thread management
    tasks and manages the entire concurrent execution flow of the threads. An `Executor`
    is an object that executes tasks provided.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java concurrency API provides the following three basic interfaces for
    executors:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`Executor`: This is a simple interface that is used to launch a new task. It
    does not strictly require the execution to be asynchronous.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecutorService`: This is a subinterface of the `Executor` interface. It allows
    us to pass a task to be executed by a thread asynchronously. It provides methods
    to manage the termination of previously sublimed tasks through `shutdown()`, `shutdownNow()`,
    and `awaitTermination(long timeout, TimeUnit unit)`. It also provides methods
    that return the `Future` object for tracking the progress of one or more asynchronous
    tasks.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`：这是`Executor`接口的子接口。它允许我们异步地将任务传递给线程执行。它提供了管理先前提交的任务终止的方法，如`shutdown()`、`shutdownNow()`和`awaitTermination(long
    timeout, TimeUnit unit)`。它还提供了返回`Future`对象以跟踪一个或多个异步任务进度的方法。'
- en: '`ScheduledExecutorService`: This is a subinterface of `ExecutorService`. It
    provides various key methods, such as `schedule()`, `scheduleAtFixedRate()` and
    `scheduleWithFixedDelay()`. All schedule methods can accept relative delays and
    periods as arguments, and this helps us to schedule tasks to execute after a given
    delay or period.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledExecutorService`：这是`ExecutorService`的子接口。它提供了各种关键方法，如`schedule()`、`scheduleAtFixedRate()`和`scheduleWithFixedDelay()`。所有调度方法都可以接受相对延迟和周期作为参数，这有助于我们安排任务在给定延迟或周期后执行。'
- en: 'The following is a simple example showing how to create `Executor` in order
    to execute a `Runnable` task:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单示例，演示了如何创建`Executor`以执行`Runnable`任务：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous example, a `Runnable` object is created by an anonymous class
    and executes a task by means of a single-threaded `Executor` interface. When we
    compile and run the preceding class, we will get the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，通过匿名类创建了一个`Runnable`对象，并通过单线程`Executor`接口执行任务。当我们编译和运行上述类时，将得到以下输出：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ThreadFactory
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ThreadFactory
- en: The `ThreadFactory` interface is used to create a new thread on demand and also
    helps us to eliminate lots of boilerplate code for creating threads.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFactory`接口用于按需创建新线程，还帮助我们消除创建线程的大量样板代码。'
- en: 'The following example shows how we can use the `ThreadFactory` interface to
    create new threads:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用`ThreadFactory`接口创建新线程：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we compile and run the preceding class, we will get the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译和运行上述类时，将得到以下输出：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Synchronizers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步器
- en: 'Java provides a `synchronized` keyword to write synchronized code, but it is
    difficult to correctly write synchronized code through the `synchronized` keyword
    alone. The `java.util.concurrent` package provides various utility classes, such
    as `CountDownLatch`, `CyclicBarrier`, `Exchanger`, `Semaphore`, and `Phaser`,
    which are known as synchronizers. Synchronizers are concurrency utilities that
    provide thread synchronization without using the `wait()` and `notify()` methods.
    Let''s have a look at the following classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`synchronized`关键字来编写同步代码，但仅通过`synchronized`关键字正确编写同步代码是困难的。`java.util.concurrent`包提供了各种实用程序类，如`CountDownLatch`、`CyclicBarrier`、`Exchanger`、`Semaphore`和`Phaser`，它们被称为同步器。同步器是提供线程同步的并发实用程序，而无需使用`wait()`和`notify()`方法。让我们看看以下类：
- en: '`CountDownLatch`: This allows one thread to wait for one or more threads to
    complete before it can start processing.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`：这允许一个线程在一个或多个线程完成之前等待。'
- en: '`CyclicBarrier`: This is very similar to `CountdownLatch`, but it allows multiple
    threads to wait for each other before they can start processing.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：这与`CountdownLatch`非常相似，但它允许多个线程在开始处理之前等待彼此。'
- en: '`Semaphore`: This maintains a set of permits for restricting the number of
    threads that can access a shared resource. Threads require a permit from `Semaphore`
    before accessing a shared resource. It provides two main methods, `acquire()`
    and `release()`, for getting and releasing permits, respectively.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信号量`：这维护了一组许可证，用于限制可以访问共享资源的线程数量。线程在访问共享资源之前需要从`信号量`获取许可证。它提供了两个主要方法`acquire()`和`release()`，分别用于获取和释放许可证。'
- en: '`Exchanger`: This provides a synchronization point where threads can exchange
    objects.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger`：这提供了一个同步点，线程可以在其中交换对象。'
- en: '`Phaser`: This provides a thread synchronization mechanism similar to `CyclicBarrier`
    and `CountDownLatch`, but it supports more flexible usage. It allows a group of
    threads to wait on a barrier and then proceed after the last thread arrives, and
    it also supports multiple phases of execution.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`：这提供了类似于`CyclicBarrier`和`CountDownLatch`的线程同步机制，但支持更灵活的使用。它允许一组线程在障碍上等待，然后在最后一个线程到达后继续，并且还支持多个执行阶段。'
- en: Concurrent collection classes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合类
- en: 'The concurrent collection classes provide more scalability and performance
    than other collection classes, such as `HashMap` or `Hashtable`. The following
    are useful concurrent classes provided in the `java.util.concurrent` package:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合类提供了比其他集合类（如`HashMap`或`Hashtable`）更好的可伸缩性和性能。以下是`java.util.concurrent`包中提供的有用并发类：
- en: '`ConcurrentHashMap`: This is similar to `HashMap` and `Hashtable`, but it has
    been designed to work in concurrent programming without the need for explicit
    synchronization. `Hashtable` and `ConcurrentHashMap` are both thread-safe collections,
    but `ConcurrentHashMap` is more advanced than `Hashtable`. It does not lock the
    entire collection for synchronization, so it is very useful when there are a lot
    of updates and fewer concurrent reads.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`：这类似于`HashMap`和`Hashtable`，但它被设计为在并发编程中工作，而无需显式同步。`Hashtable`和`ConcurrentHashMap`都是线程安全的集合，但`ConcurrentHashMap`比`Hashtable`更先进。它不会锁定整个集合进行同步，因此在有大量更新和较少并发读取时非常有用。'
- en: '`BlockingQueue`: The producer-consumer pattern is the most common design pattern
    in asynchronous programming, and the `BlockingQueue` data structure can be very
    useful in these asynchronous scenarios.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockingQueue`：生产者-消费者模式是异步编程中最常见的设计模式，`BlockingQueue`数据结构在这些异步场景中非常有用。'
- en: '`DelayQueue`: This is an infinite size blocking queue of elements where an
    element can only be taken when its delay has expired. If multiple elements delay
    expiry, then the element with the longest delay expiration will be taken first.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelayQueue`：这是一个无限大小的阻塞队列，其中的元素只有在其延迟到期时才能被取出。如果多个元素延迟到期，那么延迟到期时间最长的元素将首先被取出。'
- en: Lock
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁
- en: The `Lock` interface provides more advanced locking mechanisms than the synchronized block.
    The main difference between the synchronized block and `Lock` is that the synchronized
    block is fully contained in a method while the `Lock` interface has separate methods, `lock()` and `unlock()`, that
    can be called in a different method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口提供了比`synchronized`块更高级的锁定机制。`synchronized`块和`Lock`之间的主要区别是`synchronized`块完全包含在一个方法中，而`Lock`接口有单独的`lock()`和`unlock()`方法，可以在不同的方法中调用。'
- en: Callable and Future
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用和未来
- en: The `Callable` interface is similar to the `Runnable` object, but it can return
    any type of object, which helps us to get a result or status from a `Callable`
    task.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`接口类似于`Runnable`对象，但它可以返回任何类型的对象，这有助于我们从`Callable`任务中获取结果或状态。'
- en: The `Callable` task returns the `Future` object, which is used for getting the
    result of an asynchronous operation. Its uses include providing a couple of methods
    to check whether the asynchronous execution is completed or not and retrieving
    the result of the computation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`任务返回`Future`对象，用于获取异步操作的结果。它的用途包括提供一对方法来检查异步执行是否已完成，并检索计算的结果。'
- en: Atomic variables
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子变量
- en: Atomic variables are non-blocking algorithms introduced in the `java.util.concurrent.atomic`
    package. The main benefits of using atomic variables is that we don't need to
    worry about synchronization. Atomic variables are a necessity in multithreaded
    environments to avoid data inconsistency. It supports lock-free, thread-safe operations
    on single variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量是在`java.util.concurrent.atomic`包中引入的非阻塞算法。使用原子变量的主要好处是我们不需要担心同步。在多线程环境中，原子变量是避免数据不一致的必要性。它支持对单个变量进行无锁、线程安全的操作。
- en: Using thread pools for asynchronous processing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池进行异步处理
- en: Thread pool is a core concept in multithreaded programming that serves a collection
    of idle threads that can be used to execute a task. A thread pool can reuse previously
    created threads to execute the current task so that the thread is already available
    when the request arrives, which can reduce the time of thread creation and improve
    the performance of the application. Normally, thread pool can be used in a web
    server to handle client requests and also to maintain open connections to the
    database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池是多线程编程中的核心概念，用于提供一组空闲线程，可用于执行任务。线程池可以重用先前创建的线程来执行当前任务，以便在请求到达时线程已经可用，这可以减少线程创建的时间并提高应用程序的性能。通常，线程池可以用于Web服务器来处理客户端请求，还可以维护到数据库的开放连接。
- en: We can configure the maximum number of concurrent threads in the pool, which
    is useful for preventing overload. If all threads are busy executing a task, then
    a new task is placed in a queue and waits for a thread to become available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置池中并发线程的最大数量，这对于防止过载很有用。如果所有线程都在执行任务，那么新任务将被放置在队列中，等待线程可用。
- en: 'The Java concurrency API supports the following types of thread pools:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API支持以下类型的线程池：
- en: '**Fixed-thread pool**: A thread pool with a fixed number of threads. A task
    will only execute if a thread is available, otherwise, it is waiting in a queue.
    The `Executors.newFixedThreadPool()` method is used to create a fixed-thread pool.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定线程池：具有固定数量线程的线程池。只有在有线程可用时任务才会执行，否则会在队列中等待。使用`Executors.newFixedThreadPool()`方法来创建固定线程池。
- en: '**Cached-thread pool**: A thread pool where we can create new threads as required,
    but also reuse previously created threads. A thread will be terminated and removed
    from the pool if it is ideal for 60 seconds. The `Executors.newCachedThreadPool()`
    method is used to create a cached-thread pool.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存线程池：我们可以根据需要创建新线程，但也可以重用先前创建的线程。如果线程空闲了60秒，它将被终止并从池中移除。使用`Executors.newCachedThreadPool()`方法来创建缓存线程池。
- en: '**Single-thread pool**: A thread pool with one thread. It executes tasks one
    by one. The `Executors.newSingleThreadExecutor()` method is used to create a single-thread
    pool.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程池：一个线程的线程池。它逐个执行任务。使用`Executors.newSingleThreadExecutor()`方法来创建单线程池。
- en: '**Fork/join pool**: A thread pool that is used to perform heavy tasks faster,
    by splitting the task into smaller pieces recursively. To create a fork/join pool,
    we need to create an instance of the `ForkJoinPool` class.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支/合并池：用于更快地执行重型任务的线程池，通过递归地将任务分割成较小的片段。要创建分支/合并池，我们需要创建`ForkJoinPool`类的实例。
- en: 'The following is a simple example of the fixed-thread pool:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是固定线程池的一个简单示例：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following demonstrates how the task is implemented:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了任务的实现方式：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, we created a pool with a maximum of three concurrent
    threads and submitted `6` tasks to the `executor` object. When we compile and
    run the preceding class, we know that only three threads execute the tasks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个最多有三个并发线程的池，并向`executor`对象提交了`6`个任务。当我们编译和运行前面的类时，我们知道只有三个线程执行任务。
- en: 'Here is the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spring task execution and scheduling
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring任务执行和调度
- en: Using threads in any web application is not easy when we are dealing with a
    long-running task. Sometimes, we need to run a task asynchronously or after a
    specific delay, and that can be accomplished by Spring's task execution and scheduling.
    The Spring Framework introduced abstractions for asynchronous execution and scheduling
    of tasks with the `TaskExecutor` and `TaskScheduler` interfaces.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中使用线程处理长时间运行的任务并不容易。有时，我们需要异步运行任务或在特定延迟后运行任务，这可以通过Spring的任务执行和调度来实现。Spring框架引入了用于异步执行和任务调度的抽象，使用`TaskExecutor`和`TaskScheduler`接口。
- en: TaskExecutor
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TaskExecutor
- en: 'Spring provides the `TaskExecutor` interface as an abstraction for dealing
    with `Executor`. The implementation classes of `TaskExecutor` are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了`TaskExecutor`接口作为处理`Executor`的抽象。`TaskExecutor`的实现类如下：
- en: '`SimpleAsyncTaskExecutor`: This starts a new thread and executes it asynchronously.
    It does not reuse the thread.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleAsyncTaskExecutor`：这启动一个新线程并异步执行。它不重用线程。'
- en: '`SyncTaskExecutor`: This executes each task synchronously in the calling thread.
    It does not reuse the thread.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyncTaskExecutor`：这在调用线程中同步执行每个任务。它不重用线程。'
- en: '`ConcurrentTaskExecutor`: This exposes bean properties for configuring `java.util.concurrent.Executor`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentTaskExecutor`：这公开了用于配置`java.util.concurrent.Executor`的bean属性。'
- en: '`SimpleThreadPoolTaskExecutor`: This is a subclass of `SimpleThreadPool` of
    `Quartz`, which listens to Spring''s life cycle callbacks.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleThreadPoolTaskExecutor`：这是`Quartz`的`SimpleThreadPool`的子类，它监听Spring的生命周期回调。'
- en: '`ThreadPoolTaskExecutor`: This exposes bean properties for configuring `java.util.concurrent.ThreadPoolExecutor`
    and wraps it in `TaskExecutor`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolTaskExecutor`：这公开了用于配置`java.util.concurrent.ThreadPoolExecutor`的bean属性，并将其包装在`TaskExecutor`中。'
- en: '`TimerTaskExecutor`: This implements a single `TimerTask` class as its backing
    implementation. It executes methods as synchronous in a separate thread.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimerTaskExecutor`：这实现了一个`TimerTask`类作为其后备实现。它在单独的线程中同步执行方法。'
- en: '`WorkManagerTaskExecutor`: This uses the `CommonJ` `WorkManager` interface
    as its backing implementation.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkManagerTaskExecutor`：这使用`CommonJ`的`WorkManager`接口作为其后备实现。'
- en: Let's see a simple example of executing a task with `SimpleAsyncTaskExecutor`
    in the Spring application. It creates a new thread for each task submission and
    runs as asynchronous.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Spring应用程序中使用`SimpleAsyncTaskExecutor`执行任务的简单示例。它为每个任务提交创建一个新线程并异步运行。
- en: 'Here is the configuration file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置文件：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the bean class where we have assigned `5` tasks to `TaskExecutor`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个bean类，我们已经将`5`个任务分配给了`TaskExecutor`：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the code for executing the task from the `main` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`main`方法执行任务的代码：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we compile and run the preceding class, we will get the following output.
    Here, we can see five threads are created and they execute the task asynchronously:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行上述类时，将得到以下输出。在这里，我们可以看到创建了五个线程，并且它们异步执行任务：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TaskScheduler
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TaskScheduler
- en: Sometimes, we need to perform a task at fixed intervals, and this can be achieved
    with the Spring scheduler framework. In this section, we will see how we can schedule
    a task in Spring with the use of a few annotations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要按固定间隔执行任务，这可以通过Spring调度程序框架实现。在本节中，我们将看到如何使用一些注解在Spring中安排任务。
- en: 'Let''s see a simple example of scheduling a task in the Spring application:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在Spring应用程序中安排任务的简单示例：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Spring, we can enable task scheduling with the help of the `@EnableScheduling`
    annotation. Once task scheduling is enabled, Spring will automatically register
    an internal bean post processor, which will find the `@Scheduled` annotated methods
    on a Spring-managed bean.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，我们可以通过`@EnableScheduling`注解启用任务调度。一旦启用任务调度，Spring将自动注册一个内部bean后处理器，该处理器将在Spring管理的bean上找到`@Scheduled`注解的方法。
- en: 'In the previous example, we annotated the `scheduledTask()` method with the
    `@Scheduled` annotation with the `fixedDelay` attribute to be invoked every `2`
    seconds. We can also use other attributes, such as `fixedRate` and `cron`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用`@Scheduled`注解将`scheduledTask()`方法与`fixedDelay`属性一起注释，以便每`2`秒调用一次。我们还可以使用其他属性，如`fixedRate`和`cron`：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we compile and run the previous class, we will get the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行上一个类时，将得到以下输出：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Spring Async
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Async
- en: In this section, we will see the asynchronous execution support in Spring. In
    certain cases, we need to execute some tasks asynchronously, because the result
    of that task does not require the user, so we can process that task in a separate
    thread. The main benefit of asynchronous programming is that we can increase the
    performance and responsiveness of our application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到Spring中的异步执行支持。在某些情况下，我们需要异步执行一些任务，因为该任务的结果不需要用户，所以我们可以在单独的线程中处理该任务。异步编程的主要好处是我们可以提高应用程序的性能和响应能力。
- en: Spring provides annotation support for asynchronous method execution via `@EnableAsync`
    and `@Async`. Let's discuss them in detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Spring通过`@EnableAsync`和`@Async`提供了异步方法执行的注解支持。让我们详细讨论它们。
- en: The @EnableAsync annotation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@EnableAsync注解'
- en: 'We can enable asynchronous processing by simply adding `@EnableAsync` to a
    configuration class, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地将`@EnableAsync`添加到配置类来启用异步处理，如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we have not provided `TaskExecutor` as a bean, so Spring
    will use a default `SimpleAsyncTaskExecutor` implicitly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们没有将`TaskExecutor`作为bean提供，因此Spring将隐式地使用默认的`SimpleAsyncTaskExecutor`。
- en: The @Async annotation
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Async注解'
- en: Once asynchronous processing is enabled, then the methods that are annotated
    with the `@Async` annotation will execute asynchronously.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了异步处理，那么用`@Async`注解标记的方法将异步执行。
- en: 'The following is a simple example of the `@Async` annotation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`@Async`注解的简单示例：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also annotate the `@Async` annotation to a method with the return type,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`@Async`注解添加到具有返回类型的方法中，如下所示：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous code, we used the `AsyncResult` class, which implements `Future`.
    This can be used to get the results of the execution of the asynchronous method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了实现`Future`的`AsyncResult`类。这可以用于获取异步方法执行的结果。
- en: 'The following is the code to call the asynchronous method from the `main` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`main`方法调用异步方法的代码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we compile and run the preceding class, we will get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行上述类时，将得到以下输出：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '@Async with CompletableFuture'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Async与CompletableFuture'
- en: 'In the previous section, we saw how we can use `java.util.Future` to get the
    result of asynchronous method execution. It provides an `isDone()` method to check
    whether the computation is done or not, and a `get()` method to retrieve the result
    of the computation when it is done. But there are certain limitations to using
    the `Future` API:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用`java.util.Future`来获取异步方法执行的结果。它提供了一个`isDone()`方法来检查计算是否完成，以及一个`get()`方法在计算完成时检索计算结果。但是使用`Future`
    API存在一定的限制：
- en: Suppose we have written code to fetch the latest product price from an e-commerce
    system through a remote API. This task is time-consuming, so we need to run it
    asynchronously and use `Future` to get the result of that task. Now, the problem
    will occur when the remote API service is down. At that time, we need to complete
    `Future` manually by the last cached price of the product and that is not possible
    with `Future`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们编写了代码，通过远程API从电子商务系统中获取最新的产品价格。这个任务很耗时，所以我们需要异步运行它，并使用`Future`来获取该任务的结果。现在，当远程API服务宕机时，问题就会出现。这时，我们需要手动完成`Future`，使用产品的最后缓存价格，这是`Future`无法实现的。
- en: '`Future` only provides a `get()` method that notifies us when a result is available.
    We cannot attach a callback function to `Future` and have it get called automatically
    when the `Future` result is available.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`只提供一个`get()`方法，当结果可用时通知我们。我们无法将回调函数附加到`Future`，并在`Future`结果可用时自动调用它。'
- en: Sometimes we have requirements, such as the result of the long-running task
    is needed to send another long-running task. We can't create such asynchronous
    workflow with `Future`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时我们有需求，比如需要将长时间运行任务的结果发送给另一个长时间运行的任务。我们无法使用`Future`创建这样的异步工作流。
- en: We cannot run multiple `Future` in parallel.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法并行运行多个`Future`。
- en: The `Future` API does not have any exception handling.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future` API没有任何异常处理。'
- en: 'Because of these limitations, Java 8 introduced a better abstraction than `java.util.Future`,
    called `CompletableFuture`. We can create `CompletableFuture` simply using the
    following no-arg constructor:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，Java 8引入了比`java.util.Future`更好的抽象，称为`CompletableFuture`。我们可以使用以下无参构造函数简单地创建`CompletableFuture`：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the list of methods provided by `CompletableFuture`, which help us
    to resolve the limitations of `Future`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`CompletableFuture`提供的方法列表，帮助我们解决`Future`的限制：
- en: The `complete()` method is used to complete the task manually.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete()`方法用于手动完成任务。'
- en: The `runAsync()` method is used to run background tasks asynchronously that
    do not return anything. It takes a `Runnable` object and returns `CompletableFuture<Void>`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsync()`方法用于异步运行不返回任何内容的后台任务。它接受一个`Runnable`对象并返回`CompletableFuture<Void>`。'
- en: The `supplyAsync()` method is used to run background tasks asynchronously and
    return a value. It takes `Supplier<T>` and returns `CompletableFuture<T>`, where
    `T` is the type of the value given by the supplier.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supplyAsync()`方法用于异步运行后台任务并返回一个值。它接受`Supplier<T>`并返回`CompletableFuture<T>`，其中`T`是供应商提供的值的类型。'
- en: The `thenApply()`, `thenAccept()`, and `thenRun()` methods are used to attach
    a callback to `CompletableFuture`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenApply()`、`thenAccept()`和`thenRun()`方法用于将回调附加到`CompletableFuture`。'
- en: The `thenCompose()` method is used to combine two dependent `CompletableFuture` together.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenCompose()`方法用于将两个依赖的`CompletableFuture`组合在一起。'
- en: The `thenCombine()` method is used to combine two independent `CompletableFuture` together.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenCombine()`方法用于将两个独立的`CompletableFuture`组合在一起。'
- en: The `allOf()` and `anyOf()` methods are used to combine multiple `CompletableFuture` together.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allOf()`和`anyOf()`方法用于将多个`CompletableFuture`组合在一起。'
- en: The `exceptionally()` method is used to get the generated error from `Future`.
    We can log the error and set a default value.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exceptionally()`方法用于从`Future`获取生成的错误。我们可以记录错误并设置默认值。'
- en: The `handle()` method is used to handle the exception.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle()`方法用于处理异常。'
- en: Spring and threads – transactions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring和线程-事务
- en: 'The Spring Framework offers an extensive API for database transaction management.
    Spring takes care of all basic transaction management control and provides a consistent
    programming model for different transaction APIs, such as JDBC, Hibernate, **Java
    Transaction API** (**JTA**), **Java Persistence API** (**JPA**), and **Java Data
    Objects** (**JDO**). There are two types of transactions provided by Spring: one
    is declarative and the other is programmatic transaction management. Declarative
    is very high-level, while programmatic is more advanced but flexible.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架为数据库事务管理提供了广泛的API。Spring负责所有基本的事务管理控制，并为不同的事务API提供了一致的编程模型，如JDBC、Hibernate、Java
    Transaction API（JTA）、Java Persistence API（JPA）和Java Data Objects（JDO）。Spring提供了两种类型的事务：一种是声明式的，另一种是编程式的事务管理。声明式的层次很高，而编程式的更高级但更灵活。
- en: Spring transaction management works very well with a single thread. But it cannot
    manage a transaction across multiple threads. If we try to use the transaction
    with multiple threads, our program gives a runtime error or an unexpected result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Spring事务管理在单个线程中运行得很好。但它无法管理跨多个线程的事务。如果我们尝试在多个线程中使用事务，我们的程序会给出运行时错误或意外结果。
- en: 'To understand why a Spring transaction fails with multiple threads, first,
    we need to understand how transactions work with Spring. Spring stores all transaction
    information in the `ThreadLocal` variables inside the `org.springframework.transaction.support.TransactionSynchronizationManager`
    class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么Spring事务在多个线程中失败，首先，我们需要了解Spring如何处理事务。Spring将所有事务信息存储在`org.springframework.transaction.support.TransactionSynchronizationManager`类内的`ThreadLocal`变量中：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The thread's local variable holds the information of a specific transaction
    for a single thread only and that cannot be accessed by another thread. So, an
    ongoing transaction's information is not passed to the newly created thread. The
    result will be an error indicating that the transaction is missing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的局部变量仅保存特定事务的信息，仅限于单个线程，不能被另一个线程访问。因此，正在进行的事务信息不会传递给新创建的线程。结果将是一个错误，指示事务丢失。
- en: Now we are able to understand the problem of a Spring transaction with multiple
    threads. Spring cannot maintain the transaction state to old threads from newly
    created threads. To solve the transaction problem with multiple threads, we need
    to manually pass the thread's local variable values to the newly created thread.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够理解Spring事务在多个线程中的问题。Spring无法将事务状态保持到旧线程，以便从新创建的线程中访问。为了解决多线程的事务问题，我们需要手动将线程的局部变量值传递给新创建的线程。
- en: Java threads best programming practices
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java线程最佳编程实践
- en: 'The purpose of using multithreading and concurrent programming is to improve
    performance, but we need to always remember that speed comes after correctness.
    The Java programming language provides lots of synchronization and concurrency
    support from the language to API level, but it depends on an individual''s expertise
    in writing bug-free Java concurrency code. The following are Java concurrency
    and multithreading best practices, which help us write better concurrency code
    in Java:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多线程和并发编程的目的是提高性能，但我们需要始终记住速度是在正确性之后。Java编程语言从语言到API级别提供了大量的同步和并发支持，但这取决于个人在编写无错误的Java并发代码方面的专业知识。以下是Java并发和多线程的最佳实践，这有助于我们在Java中编写更好的并发代码：
- en: '**Use immutable classes**: We should always prefer the immutable class in multithreading
    programming because immutable classes make sure that values are not changed in
    the middle of an operation without using synchronized blocks. For example, in
    an immutable class, such as `java.lang.String`, any modification on `String`,
    such as adding something or converting into uppercase, always creates another
    string object, keeping the original object unbroken.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不可变类**：在多线程编程中，我们应该始终优先使用不可变类，因为不可变类确保在操作中值不会在没有使用同步块的情况下更改。例如，在不可变类中，如`java.lang.String`，对`String`的任何修改，如添加内容或转换为大写，总是创建另一个字符串对象，保持原始对象不变。'
- en: '**Use local variables**: Always try to use local variables instead of an instance
    or class-level variables because local variables are never shared between threads.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用局部变量**：始终尝试使用局部变量而不是实例或类级变量，因为局部变量永远不会在线程之间共享。'
- en: '**Use thread pool**: Thread pool can reuse previously created threads and eliminate
    the time of thread creation, which improves the performance of the application.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用线程池**：线程池可以重用先前创建的线程，并消除线程创建的时间，从而提高应用程序的性能。'
- en: '**Use the synchronization utility**: Here, we can use the synchronization utility
    instead of the `wait` and `notify` methods. The `java.util.concurrent` package
    provides better synchronization utilities, such as `CycicBariier`, `CountDownLatch`,
    `Sempahore`, and `BlockingQueue`. It is very easy to wait for five threads using
    `CountDownLatch` to complete its task instead of implementing the same utility
    using the `wait` and `notify` methods. It is also easier to implement the producer-consumer
    design with the help of `BlockingQueue` rather than the `wait` and `notify` methods.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用同步工具**：在这里，我们可以使用同步工具而不是`wait`和`notify`方法。`java.util.concurrent`包提供了更好的同步工具，如`CycicBariier`、`CountDownLatch`、`Sempahore`和`BlockingQueue`。使用`CountDownLatch`等待五个线程完成任务比使用`wait`和`notify`方法实现相同的工具更容易。使用`BlockingQueue`更容易实现生产者-消费者设计，而不是使用`wait`和`notify`方法。'
- en: '**Use concurrent collections instead of synchronized collection**: Concurrent
    collections are implemented with the new locking mechanism provided by the `Lock`
    interface and designed in such a way that we can take advantage of the native
    concurrency construct provided by the underlying hardware and JVM. Concurrent
    collections give more scalability and performance than their synchronized counterparts. `ConcurrentHashMap`
    provides better performance than synchronized `HashMap` or `Hashtable` classes
    if there are many updates and fewer reads concurrently.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并发集合而不是同步集合**：并发集合是使用`Lock`接口提供的新锁定机制实现的，并且设计成这样，我们可以利用底层硬件和JVM提供的本机并发构造。并发集合比它们的同步对应物具有更好的可伸缩性和性能。如果有许多并发更新和较少读取，`ConcurrentHashMap`比同步的`HashMap`或`Hashtable`类提供更好的性能。'
- en: '**Minimize locking scope**: We should always try to reduce the locking scope
    as much as possible because locking block will not be executed concurrently and
    it impacts the application''s performance. We should always first try to use atomic
    and volatile variables to achieve our synchronization requirement if our requirement
    is not satisfied with them, and then we need to use the functionality provided
    by the `Lock` interface. We can also reduce the locking scope to use a synchronized
    block instead of the synchronized method.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化锁定范围**：我们应该尽量减少锁定范围，因为锁定块不会同时执行，并且会影响应用程序的性能。如果我们的需求无法满足，首先尝试使用原子和易失性变量来实现我们的同步需求，然后需要使用`Lock`接口提供的功能。我们还可以减少锁定范围，使用同步块而不是同步方法。'
- en: '**Use Java Executor framework**: It provides an abstraction layer on the Java
    threading framework and provides better control in terms of creating and executing
    threads in a multithreaded environment.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Java Executor框架**：它在Java线程框架上提供了一个抽象层，并在多线程环境中创建和执行线程方面提供了更好的控制。'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Java thread and learned how we can implement multithreading
    and concurrent programming with the help of the `java.util.concurrent` package.
    We also learned how we can improve performance using a thread pools in our application.
    We saw the task executing and scheduling functionalities provided by Spring and
    also learned about `@Async` support by Spring, which can increase the performance
    and responsiveness of our application. We reviewed how Spring transaction management
    creates an issue while working with multiple threads, and also looked at the best programming
    practices for multithreading and concurrent programming.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了Java线程，并学习了如何利用`java.util.concurrent`包实现多线程和并发编程。我们还学习了如何在应用程序中使用线程池来提高性能。我们看到了Spring提供的任务执行和调度功能，还学习了Spring的`@Async`支持，可以提高应用程序的性能和响应能力。我们回顾了Spring事务管理在处理多线程时可能出现的问题，并了解了多线程和并发编程的最佳编程实践。
- en: In the next chapter, we will learn about profiling an application to figure
    out the performance of an application. It is very useful for identifying performance
    issues. We will also learn about logging, which is an important tool for identifying
    issues in the application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何对应用程序进行性能分析，以找出性能问题。这对于识别性能问题非常有用。我们还将学习日志记录，这是识别应用程序问题的重要工具。

- en: 10\. Securing your AKS cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 保护您的AKS集群
- en: '*Loose lips sink ships* is a phrase that describes how easy it can be to jeopardize
    the security of a Kubernetes-managed cluster (*Kubernetes*, by the way, is Greek
    for *helmsman*, as in the helmsman of a *ship*). If your cluster is left open
    with the wrong ports or services exposed, or plain text is used for secrets in
    application definitions, bad actors can take advantage of this negligent security
    and do pretty much whatever they want in your cluster.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “泄露机密会导致失败”是一个描述在Kubernetes管理的集群中很容易危及安全性的短语（顺便说一句，*Kubernetes*在希腊语中是*舵手*的意思，就像*船*的舵手）。如果您的集群开放了错误的端口或服务，或者在应用程序定义中使用了明文作为秘密，不良行为者可以利用这种疏忽的安全性做几乎任何他们想做的事情。
- en: In this chapter, we will explore Kubernetes security in more depth. You will
    be introduced to the concept of **role-based access control (RBAC)** in Kubernetes.
    After that, you will learn about secrets and how to use them. You will first create
    secrets in Kubernetes itself, and afterward create a Key Vault to store secrets
    more securely. You'll finish this chapter with a brief introduction to service
    mesh concepts, and you'll be given a practical example to follow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨Kubernetes安全性。您将了解Kubernetes中的**基于角色的访问控制（RBAC）**的概念。之后，您将学习有关秘密以及如何使用它们的内容。您将首先在Kubernetes中创建秘密，然后创建一个Key
    Vault来更安全地存储秘密。最后，您将简要介绍服务网格概念，并且将给出一个实际示例供您参考。
- en: 'The following topics will be covered briefly in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍以下主题：
- en: Role-based access control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: Setting up secrets management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置秘密管理
- en: Using secrets stored in Key Vault
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Key Vault中使用存储的秘密
- en: The Istio service mesh at your service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio服务网格为您服务
- en: Note
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To complete the example about RBAC, you need access to an Azure AD instance,
    with global administrator permissions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成有关RBAC的示例，您需要访问具有全局管理员权限的Azure AD实例。
- en: Let's start this chapter with RBAC.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从RBAC开始这一章。
- en: Role-based access control
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: In production systems, you need to allow different users different levels of
    access to certain resources; this is known as **role-based access control** (**RBAC**).
    This section will take you through how to configure RBAC in AKS, and how to assign
    different roles with different rights. The benefits of establishing RBAC are that
    it not only acts as a guardrail against the accidental deletion of critical resources
    but also that it is an important security feature that limits full access to the
    cluster to roles that really need it. On an RBAC-enabled cluster, users will be
    able to observe that they can modify only those resources to which they have access.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，您需要允许不同用户对某些资源有不同级别的访问权限；这被称为**基于角色的访问控制**（**RBAC**）。本节将带您了解如何在AKS中配置RBAC，以及如何分配不同权限的不同角色。建立RBAC的好处在于，它不仅可以防止意外删除关键资源，还是一项重要的安全功能，限制了对集群的完全访问权限。在启用RBAC的集群上，用户将能够观察到他们只能修改他们有权限访问的资源。
- en: Up till now, using Cloud Shell, we have been acting as *root*, which allowed
    us to do anything and everything in the cluster. For production use cases, root
    access is dangerous and should be restricted as much as possible. It is a generally
    accepted best practice to use the **principle of least privilege** (**PoLP**)
    to log into any computer system. This prevents both access to secure data and
    unintentional downtime through the deletion of key resources. Anywhere between
    22% and 29% ([https://blog.storagecraft.com/data-loss-statistics-infographic/](https://blog.storagecraft.com/data-loss-statistics-infographic/))
    of data loss is attributed to human error. You don't want to be part of that statistic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用Cloud Shell，我们一直在扮演*root*，这使我们可以在集群中做任何事情。对于生产用例来说，root访问是危险的，应尽可能受到限制。通常公认的最佳实践是使用**最小权限原则**（PoLP）登录任何计算机系统。这可以防止对安全数据的访问和通过删除关键资源而造成意外停机。据统计，22%至29%（[https://blog.storagecraft.com/data-loss-statistics-infographic/](https://blog.storagecraft.com/data-loss-statistics-infographic/)）的数据丢失归因于人为错误。您不希望成为这一统计数字的一部分。
- en: 'Kubernetes developers realized this was a problem and added RBAC along with
    the concept of service roles to control access to clusters. Kubernetes RBAC has
    three important concepts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes开发人员意识到这是一个问题，并添加了RBAC以及服务角色的概念来控制对集群的访问。Kubernetes RBAC有三个重要的概念：
- en: '**Role**: A role contains a set of permissions. A role has a default of *no
    permissions*, and every permission needs to be specifically called out. Examples
    of permissions include *get*, *watch*, and *list*. The role also contains which
    resources these permissions are given to. Resources can be either all Pods, Deployments,
    and so on, or can be a specific object (such as *pod/mypod*).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：角色包含一组权限。角色默认没有权限，每个权限都需要明确声明。权限的示例包括*get*、*watch*和*list*。角色还包含这些权限所赋予的资源。资源可以是所有Pod、部署等，也可以是特定对象（如*pod/mypod*）。'
- en: '**Subject**: The subject is either a person or a service account that is assigned
    a role. In AKS, these subjects can be Azure AD users or groups.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：主体可以是分配了角色的Azure AD用户或组。'
- en: '**RoleBinding**: A RoleBinding links a subject to a role in a certain namespace
    or, in the case of a ClusterRoleBinding, the whole cluster.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RoleBinding**：RoleBinding将一个主体与特定命名空间中的角色或者ClusterRoleBinding中的整个集群中的角色进行了关联。'
- en: 'An important notion to understand is that when interfacing with AKS, there
    are two layers of RBAC: Azure RBAC and Kubernetes RBAC. Azure RBAC deals with
    the roles given to people to make changes in Azure, such as creating, modifying,
    and deleting clusters. Kubernetes RBAC deals with the access rights to resources
    in a cluster. Both are independent control planes but can use the same users and
    groups originating in Azure AD.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的概念要理解的是，在与AKS进行交互时，有两个RBAC层次：Azure RBAC和Kubernetes RBAC。Azure RBAC处理分配给人们在Azure中进行更改的角色，比如创建、修改和删除集群。Kubernetes
    RBAC处理集群中资源的访问权限。两者都是独立的控制平面，但可以使用源自Azure AD的相同用户和组。
- en: '![An architectural diagram showing the two layers of RBAC: Azure RBAC and Kubernetes
    RBAC. Within Azure, Azure AD users or groups are assigned Azure roles to allowaccess
    to nodes within subscriptions and resource groups. Similarly, Azure AD users or
    groups get assigned Kubernetes roles to access Pods, deployments, and namespaces
    within Kubernetes.](image/Figure_10.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一个架构图，显示了RBAC的两个层次：Azure RBAC和Kubernetes RBAC。在Azure中，Azure AD用户或组被分配Azure角色，以允许访问订阅和资源组中的节点。同样，Azure
    AD用户或组被分配Kubernetes角色，以访问Kubernetes中的Pod、部署和命名空间。](image/Figure_10.1.jpg)'
- en: 'Figure 10.1: Two different RBAC planes, Azure and Kubernetes'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.1：两个不同的RBAC平面，Azure和Kubernetes
- en: RBAC in Kubernetes is an optional feature. The default in AKS is to create clusters
    that have RBAC enabled. However, by default, the cluster is not integrated with
    Azure AD. This means that by default you cannot grant Kubernetes permissions to
    Azure AD users. In this example, we will create a new cluster integrated with
    Azure AD. Let's start our exploration of RBAC by creating a new user and a new
    group in Azure AD.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的RBAC是一个可选功能。在AKS中，默认情况下是创建启用了RBAC的集群。但是，默认情况下，集群未集成到Azure AD中。这意味着默认情况下，您无法授予Kubernetes权限给Azure
    AD用户。在这个例子中，我们将创建一个与Azure AD集成的新集群。让我们通过在Azure AD中创建一个新用户和一个新组来开始我们对RBAC的探索。
- en: Creating a new cluster with Azure AD integration
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个集成了Azure AD的新集群
- en: 'In this section, we will create a new cluster that is integrated with Azure
    AD. This is required so we can reference users in Azure AD in the next steps.
    All these steps will be executed in Cloud Shell. We have provided the steps as
    well in a file called `cluster-aad.sh`. If you prefer to execute the script, please
    change the variables in the first four lines to reflect your preferences. Let''s
    go ahead and perform the steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个与Azure AD集成的新集群。这是必需的，这样我们就可以在接下来的步骤中引用Azure AD中的用户。所有这些步骤将在Cloud
    Shell中执行。我们还提供了一个名为`cluster-aad.sh`的文件中的步骤。如果您希望执行该脚本，请更改前四行中的变量以反映您的偏好。让我们继续执行这些步骤：
- en: 'We will start by scaling down our current cluster to one node:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从缩减当前集群到一个节点开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will set some variables that we''ll use in the script:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置一些在脚本中将使用的变量：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now get the existing service principal from our AKS cluster. We will
    reuse this service principal to grant permissions to the new cluster to access
    our Azure subscription:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从我们的AKS集群中获取现有的服务主体。我们将重用此服务主体，以授予新集群访问我们的Azure订阅的权限：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will create a new Azure AD application. This Azure AD application
    will be used to get the Azure AD group memberships of a user:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的Azure AD应用程序。这个Azure AD应用程序将用于获取用户的Azure AD组成员资格：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the next step, we will update the application, create a service principal,
    and get the secret from the service principal:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将更新应用程序，创建服务主体，并从服务主体获取密钥：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we will give this service principal permission to access directory data
    in Azure AD:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将授予此服务主体访问Azure AD中的目录数据的权限：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is one manual step here that takes us to the Azure portal. We need to
    grant admin consent to the application. To achieve this, look for *Azure Active
    Directory* in the Azure search bar:![Searching for Azure Active Directory in the
    Azure search bar.](image/Figure_10.2.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个手动步骤，需要我们转到Azure门户。我们需要授予应用程序管理员同意。为了实现这一点，在Azure搜索栏中查找*Azure Active Directory*：![在Azure搜索栏中搜索Azure
    Active Directory。](image/Figure_10.2.jpg)
- en: 'Figure 10.2: Looking for Azure Active Directory in the search bar'
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.2：在搜索栏中查找Azure Active Directory
- en: Then, select **App registrations** in the left-hand menu:![Selecting the App
    registrations tab in the left-hand menu.](image/Figure_10.3.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在左侧菜单中选择**应用程序注册**：![在左侧菜单中选择应用程序注册选项卡。](image/Figure_10.3.jpg)
- en: 'Figure 10.3: Selecting App registrations'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.3：选择应用程序注册
- en: In the **App registrations** blade, go to **All applications**, look for *<clustername>Server*,
    and select that application:![Looking for the app registration called handsonaksaadserver
    we created using the script earlier.](image/Figure_10.4.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序注册**中，转到**所有应用程序**，查找*<clustername>Server*，并选择该应用程序：![查找我们之前使用脚本创建的名为handsonaksaadserver的应用程序注册。](image/Figure_10.4.jpg)
- en: 'Figure 10.4: Looking for the app registration we created using the script earlier'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.4：查找我们之前使用脚本创建的应用程序注册
- en: In the view of that app, click on **API permissions**, and click on **Grant
    admin consent for Default Directory** (this name might depend on your Azure AD
    name):![Moving to API permissions in the left menuand clicking the button to grant
    admin privileges.](image/Figure_10.5.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该应用的视图中，点击**API权限**，然后点击**为默认目录授予管理员同意**（此名称可能取决于您的Azure AD名称）：![转到左侧菜单中的API权限，并点击按钮授予管理员特权。](image/Figure_10.5.jpg)
- en: 'Figure 10.5: Granting the admin consent'
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.5：授予管理员同意
- en: In the following prompt, select **Yes** to grant those permissions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的提示中，选择**是**以授予这些权限。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It can take about a minute for the **Grant admin consent** button to become
    active. If it is not active yet, please wait a minute and try again. You will
    need admin rights in Azure AD to be able to grant this consent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**授予管理员同意**按钮可能需要大约一分钟才能激活。如果还没有激活，请等待一分钟然后重试。您需要在Azure AD中拥有管理员权限才能授予此同意。'
- en: 'Next, we''ll create another service principal and grant it permissions as well.
    This service principal will take the authentication request from the user and
    will verify their credentials and permissions:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个服务主体并授予其权限。这个服务主体将接受用户的认证请求，并验证他们的凭据和权限：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, as a final step, we can create the new cluster:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，作为最后一步，我们可以创建新的集群：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we have created a new AKS cluster that is integrated with Azure
    AD for RBAC. It takes about 5 to 10 minutes to create a new cluster. While the
    new cluster is being created, you can continue to the next section and create
    a new user and group in Azure AD.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经创建了一个集成了Azure AD的新AKS集群，用于RBAC。创建一个新集群大约需要5到10分钟。在新集群正在创建时，您可以继续下一节并在Azure
    AD中创建新用户和组。
- en: Creating users and groups in Azure AD
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Azure AD中创建用户和组
- en: In this section, we will create a new user and a new group in Azure AD. We will
    use them later on in the chapter to assign them permissions to our AKS cluster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在Azure AD中创建一个新用户和一个新组。我们将在本章后面使用它们来分配权限给我们的AKS集群。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You need the User Administrator role in Azure AD to be able to create users
    and groups.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Azure AD中拥有用户管理员角色才能创建用户和组。
- en: To start with, look for *azure active directory* in the Azure search bar:![Searching
    for Azure Active Directory in the Azure search bar.](image/Figure_6.17.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Azure搜索栏中查找*Azure活动目录*：![在Azure搜索栏中搜索Azure活动目录。](image/Figure_6.17.jpg)
- en: 'Figure 10.6: Looking for Azure Active Directory in the search bar'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.6：在搜索栏中查找Azure活动目录
- en: Click on **Users** on the left-hand side. Then select **New user** to create
    a new user:![Navigating to the All Users option in the left menu and then clicking
    on the New user button.](image/Figure_10.7.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**用户**。然后选择**新用户**来创建一个新用户：![导航到左侧菜单中的所有用户选项，然后点击新用户按钮。](image/Figure_10.7.jpg)
- en: 'Figure 10.7: Clicking on New user to create a new user'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.7：点击新用户以创建新用户
- en: Provide the information about the user, including the username. Make sure to
    note down the password, as this will be required to log in:![In the new user window,
    adding all the user details and making sure to note down the password.](image/Figure_10.8.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供有关用户的信息，包括用户名。确保记下密码，因为这将需要用于登录：![在新用户窗口中，添加所有用户详细信息并确保记下密码。](image/Figure_10.8.jpg)
- en: 'Figure 10.8: Providing the user details (make sure to note down the password)'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.8：提供用户详细信息（确保记下密码）
- en: Once the user is created, go back to the Azure AD blade and select **Groups**.
    Then click the **New group** button to create a new group:![Selecting the All
    groups tab in the left menu and clicking on the new group button to create a new
    group.](image/Figure_10.9.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户后，返回Azure AD刀片并选择**组**。然后点击**新建组**按钮创建一个新组：![在左侧菜单中选择所有组选项卡，然后点击新建组按钮创建一个新组。](image/Figure_10.9.jpg)
- en: 'Figure 10.9: Clicking on New group to create a new group'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.9：点击新建组创建新组
- en: Create a new security group. Call the group `kubernetes-admins`, and add `Tim`
    as a member of the group. Then hit the **Create** button at the bottom:![In the
    new group window,settingthe group type to security, adding a group name and a
    group description, and adding the user we created in the previous step to this
    group.](image/Figure_10.10.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的安全组。将组命名为`kubernetes-admins`，并将`Tim`添加为组的成员。然后点击底部的**创建**按钮：![在新组窗口中，将组类型设置为安全，添加组名称和组描述，并将我们在上一步中创建的用户添加到该组中。](image/Figure_10.10.jpg)
- en: 'Figure 10.10: Adding the group type, group name and group description'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.10：添加组类型、组名称和组描述
- en: We have now created a new user and a new group. As a final step, we'll make
    that user a cluster owner in AKS so they can use the Azure CLI to get access to
    the cluster. To do that, look for your cluster in the Azure search bar:![Entering
    the cluster name in the Azure search bar and selecting the cluster.](image/Figure_10.11.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个新用户和一个新组。作为最后一步，我们将使该用户成为AKS中的集群所有者，以便他们可以使用Azure CLI访问集群。为此，在Azure搜索栏中搜索您的集群：![在Azure搜索栏中输入集群名称并选择该集群。](image/Figure_10.11.jpg)
- en: 'Figure 10.11: Looking for your cluster in the Azure search bar'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.11：在Azure搜索栏中查找您的集群
- en: In the cluster blade, click on **Access control (IAM)** and then click on the
    **Add** button to add a new role assignment. Select the **Azure Kubernetes Service
    Cluster User Role** and assign that to the new user you just created:![In the
    cluster blade, select Access Control (IAM), click on the add button atthe top
    of the screen, select the Azure Kubernetes Service ClusterUser Role, and look
    for the user we created earlier.](image/Figure_10.12.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集群刀片中，点击**访问控制（IAM）**，然后点击**添加**按钮添加新的角色分配。选择**Azure Kubernetes Service Cluster
    User Role**并分配给您刚创建的新用户：![在集群刀片中，选择访问控制（IAM），点击屏幕顶部的添加按钮，选择Azure Kubernetes Service
    Cluster User Role，并查找我们之前创建的用户。](image/Figure_10.12.jpg)
- en: 'Figure 10.12: Assigning the cluster user role to the new user you created'
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.12：为新创建的用户分配集群用户角色
- en: As we will also be using Cloud Shell for our new user, we will give them contributor
    access to the Cloud Shell storage account. First, look for *storage* in the Azure
    search bar:![Searching for storage accounts in the Azure search bar.](image/Figure_10.13.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们还将为新用户使用Cloud Shell，因此我们将为他们提供对Cloud Shell存储账户的贡献者访问权限。首先，在Azure搜索栏中搜索*存储*：![在Azure搜索栏中搜索存储账户。](image/Figure_10.13.jpg)
- en: 'Figure 10.13: Looking for storage accounts in the Azure search bar'
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.13：在Azure搜索栏中搜索存储账户
- en: Select the resource group in which this storage account was created by Cloud
    Shell:![In the storage account window, selecting the resource group in which the
    storage account was created by the Cloud Shell.](image/Figure_10.14.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此存储账户所在的资源组：![在存储账户窗口中，选择由Cloud Shell创建的存储账户所在的资源组。](image/Figure_10.14.jpg)
- en: 'Figure 10.14: Selecting the resource group'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.14：选择资源组
- en: Go to **Access control (IAM)** and click on the **Add** button. Give the **Storage
    Account Contributor** role to your newly created user:![Navigating to the Access
    control (IAM) window and clicking on the Add button. Then, giving the Contributor
    role to our newly created user.](image/Figure_10.15.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**访问控制（IAM）**，然后单击**添加**按钮。将**Storage Account Contributor**角色授予您新创建的用户：![导航到访问控制（IAM）窗口，然后单击添加按钮。然后，将Contributor角色授予我们新创建的用户。](image/Figure_10.15.jpg)
- en: 'Figure 10.15: Giving the newly created user Storage Account Contributor access'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.15：给予新创建的用户Storage Account Contributor访问权限
- en: This has concluded the creation of a new user and group and giving that user
    access to AKS. In the next section, we will configure RBAC for that user and group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经完成了创建新用户和组，并给予该用户对AKS的访问权限。在下一节中，我们将为该用户和组配置RBAC。
- en: Configuring RBAC in AKS
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在AKS中配置RBAC
- en: 'To demonstrate RBAC in AKS, we will create two namespaces and deploy the Azure
    Vote application in each namespace. We will give our group cluster-wide read-only
    access to Pods, and we will give the user the ability to delete Pods in only one
    namespace. Practically, we will need to create the following objects in Kubernetes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示AKS中的RBAC，我们将创建两个命名空间，并在每个命名空间中部署Azure Vote应用程序。我们将给予我们的组对Pod的全局只读访问权限，并且我们将给予用户仅在一个命名空间中删除Pod的能力。实际上，我们需要在Kubernetes中创建以下对象：
- en: '`ClusterRole` to give read-only access'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRole`来给予只读访问权限'
- en: '`ClusterRoleBinding` to grant our group the access to this role'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRoleBinding`来授予我们的组对该角色的访问权限'
- en: '`Role` to give delete permissions in the `delete-access` namespace'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Role`来在`delete-access`命名空间中给予删除权限'
- en: '`RoleBinding` to grant our user access to this role![Graphical representation
    of the demo we are going to build. The group we created will get a ReadOnlyClusterRole,
    and the user we created gets a role inthe delete-access namespace to grant permission
    to delete pods.](image/Figure_10.16.jpg)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoleBinding`来授予我们的用户对该角色的访问权限![我们将要构建的演示的图形表示。我们创建的组将获得ReadOnlyClusterRole，我们创建的用户在delete-access命名空间中获得一个角色，以授予删除pod的权限。](image/Figure_10.16.jpg)'
- en: 'Figure 10.16: The Group getting read-only access to the whole cluster, and
    the User getting delete permissions to the delete-access namespace'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.16：组获得对整个集群的只读访问权限，用户获得对delete-access命名空间的删除权限
- en: 'Let''s set up the different roles on our cluster:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的集群上设置不同的角色：
- en: 'To start our example, we will need to retrieve the ID of the group. The following
    commands will retrieve the group ID:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始我们的示例，我们需要检索组的ID。以下命令将检索组ID：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will show your group ID. Note this down because we''ll need it in the
    next steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示您的组ID。记下来，因为我们在下一步中会需要它：
- en: '![The output of the az ad group show command showing the group ID.](image/Figure_10.17.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![az ad group show命令的输出，显示组ID。](image/Figure_10.17.jpg)'
- en: 'Figure 10.17: Getting the group ID'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.17：获取组ID
- en: 'As we created a new cluster for this example, we will get the credentials to
    log in to this cluster. We will use the admin credentials to do the initial setup:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们为这个示例创建了一个新的集群，我们将获取凭据以登录到这个集群。我们将使用管理员凭据进行初始设置：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Kubernetes, we will create two namespaces for this example:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，我们将为这个示例创建两个命名空间：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will deploy the `azure-vote` application in both namespaces:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在两个命名空间中部署`azure-vote`应用程序：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will create the `ClusterRole` file. This is provided in the `clusterRole.yaml`
    file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`ClusterRole`文件。这在`clusterRole.yaml`文件中提供：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s have a closer look at this file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个文件：
- en: '**Line 2**: Defines the creation of a `ClusterRole`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2行**：定义了`ClusterRole`的创建'
- en: '**Line 4**: Gives a name to our `ClusterRole`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4行**：为我们的`ClusterRole`命名'
- en: '**Line 6**: Gives access to all API groups'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6行**：给予所有API组的访问权限'
- en: '**Line 7**: Gives access to all Pods'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7行**：给予所有Pod的访问权限'
- en: '**Line 8**: Gives access to the actions — `get`, `watch`, and `list`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行：允许执行`get`、`watch`和`list`操作
- en: 'We will create this `ClusterRole` using the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令创建这个`ClusterRole`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step is to create a ClusterRoleBinding. The binding links the role
    to a user. This is provided in the `clusterRoleBinding.yaml` file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个ClusterRoleBinding。该绑定将角色链接到用户。这在`clusterRoleBinding.yaml`文件中提供：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s have a closer look at this file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个文件：
- en: '**Line2**: Defines that we are creating a `ClusterRoleBinding`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行：定义我们正在创建一个`ClusterRoleBinding`
- en: '**Line 4**: Gives a name to our `ClusterRoleBinding`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行：为我们的`ClusterRoleBinding`命名
- en: '**Lines 5-8**: Refer to the `ClusterRole` we created in the previous step'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第5-8行：指的是我们在上一步中创建的`ClusterRole`
- en: '**Lines 9-12**: Refer to our group in Azure AD'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第9-12行：在Azure AD中引用我们的组
- en: 'We can create this `ClusterRoleBinding` using the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建这个`ClusterRoleBinding`：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we''ll create the `Role` that is limited to the `delete-access` namespace.
    This is provided in the `role.yaml` file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个限制在`delete-access`命名空间的`Role`。这在`role.yaml`文件中提供：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This file is similar to the `ClusterRole` file from earlier. There are two
    meaningful differences:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件类似于之前的`ClusterRole`文件。有两个有意义的区别：
- en: '**Line 2**: Defines we are creating a `Role`, and not a `ClusterRole`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行：定义我们正在创建一个`Role`，而不是`ClusterRole`
- en: '**Line 5**: Defines in which namespace this `Role` is created'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行：定义了在哪个命名空间中创建这个`Role`
- en: 'We can create this `Role` using the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建这个`Role`：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will create the `RoleBinding` that links our user to the namespaced
    role. This is provided in the `roleBinding.yaml` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建将我们的用户链接到命名空间角色的`RoleBinding`。这在`roleBinding.yaml`文件中提供：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This file is similar to the ClusterRoleBinding file from earlier. There are
    a couple of meaningful differences:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件类似于之前的ClusterRoleBinding文件。有一些有意义的区别：
- en: '**Line2**: Defines the creation of a `RoleBinding` and not a `ClusterRoleBinding`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行：定义了创建一个`RoleBinding`而不是`ClusterRoleBinding`
- en: '**Line 5**: Defines in which namespace this `RoleBinding` is created'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行：定义了在哪个命名空间中创建这个`RoleBinding`
- en: '**Line 7**: Refers to a regular `Role` and note a `ClusterRole`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行：指的是一个普通的`Role`而不是`ClusterRole`
- en: '**Lines 11-13**: Define our user instead of a group'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第11-13行：定义了我们的用户而不是一个组
- en: 'We can create this `RoleBinding` using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建这个`RoleBinding`：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This has concluded the requirements for RBAC. We have created two roles and
    set up two RoleBindings. In the next section, we will explore the impact of RBAC
    by logging in to the cluster as our user.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经满足了RBAC的要求。我们已经创建了两个角色并设置了两个RoleBindings。在下一节中，我们将通过以我们的用户身份登录到集群来探索RBAC的影响。
- en: Verifying RBAC
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证RBAC
- en: 'To verify that RBAC works as expected, we will log in to the Azure portal using
    the newly created user. Go to [https://portal.azure.com](https://portal.azure.com)
    in a new browser, or an InPrivate window, and log in with the newly created user.
    You will be prompted immediately to change your password. This is a security feature
    in Azure AD to ensure that only that user knows their password:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证RBAC是否按预期工作，我们将使用新创建的用户登录到Azure门户。在新的浏览器或InPrivate窗口中转到[https://portal.azure.com](https://portal.azure.com)，并使用新创建的用户登录。您将立即收到更改密码的提示。这是Azure
    AD中的安全功能，以确保只有该用户知道他们的密码：
- en: '![A browser window prompting to change the password.](image/Figure_10.18.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![提示更改密码的浏览器窗口。](image/Figure_10.18.jpg)'
- en: 'Figure 10.18: You will be asked to change your password'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.18：您将被要求更改密码
- en: 'Once we have changed your password, we can start testing the different RBAC
    roles:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更改了您的密码，我们就可以开始测试不同的RBAC角色：
- en: We will start our experiment by setting up Cloud Shell for the new user. Launch
    Cloud Shell and select Bash:![Selecting the Bash option as the Cloud Shell.](image/Figure_10.19.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过为新用户设置Cloud Shell来开始我们的实验。启动Cloud Shell并选择Bash：![选择Bash选项作为Cloud Shell。](image/Figure_10.19.jpg)
- en: 'Figure 10.19: Selecting Bash as Cloud Shell'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.19：选择Bash作为Cloud Shell
- en: In the next view, select **Show advanced settings**:![After navigating to the
    bash option, selecting the Show advanced settings button.](image/Figure_10.20.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个视图中，选择**显示高级设置**：![在导航到bash选项后，选择显示高级设置按钮。](image/Figure_10.20.jpg)
- en: 'Figure 10.20: Selecting Show advanced settings'
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.20：选择显示高级设置
- en: Then, point Cloud Shell to the existing storage account and create a new file
    share:![Pointing the Cloud Shell to the existing storage account to create a new
    file share by clicking on the create storage button.](image/Figure_10.21.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将Cloud Shell指向现有的存储账户并创建一个新的文件共享：![通过单击创建存储按钮，将Cloud Shell指向现有的存储账户以创建新的文件共享。](image/Figure_10.21.jpg)
- en: 'Figure 10.21: Point to the existing storage account and create a new file share'
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.21：指向现有的存储账户并创建一个新的文件共享
- en: 'Once Cloud Shell is available, let''s get the credentials to connect to our
    AKS cluster:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Cloud Shell可用，让我们获取连接到我们的AKS集群的凭据：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we''ll try a command in kubectl. Let''s try to get the nodes in the cluster:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将尝试在kubectl中执行一个命令。让我们尝试获取集群中的节点：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since this is the first command executed against an RBAC-enabled cluster, you
    are asked to log in again. Browse to [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin)
    and provide the code Cloud Shell showed you. Make sure you log in here with your
    new user''s credentials:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是针对启用RBAC的集群执行的第一个命令，您将被要求重新登录。浏览至[https://microsoft.com/devicelogin](https://microsoft.com/devicelogin)并提供Cloud
    Shell显示给您的代码。确保您在此处使用新用户的凭据登录：
- en: '![Entering the code provided by Cloud Shell in the prompt window and clicking
    on the next button.](image/Figure_10.22.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![在提示窗口中输入Cloud Shell提供的代码，然后单击下一步按钮。](image/Figure_10.22.jpg)'
- en: 'Figure 10.22: Copy-paste the code Cloud Shell showed you in the prompt'
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.22：在提示中复制粘贴Cloud Shell显示给您的代码
- en: 'After you have logged in, you should get a `Forbidden` error message from kubectl,
    informing you that you don''t have permission to view the nodes in the cluster.
    This was expected since the user is configured only to have access to Pods:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您应该从kubectl收到一个“Forbidden”错误消息，通知您您没有权限查看集群中的节点。这是预期的，因为用户只被配置为可以访问Pods：
- en: '![kubectl giving an error message and stating that we don''t have permission
    to view the nodes in the cluster.](image/Figure_10.23.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl给出错误消息，并声明我们没有权限查看集群中的节点。](image/Figure_10.23.jpg)'
- en: 'Figure 10.23: The prompt asking you to log in and the Forbidden message'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.23：提示您登录和被禁止的消息
- en: 'Now we can verify that our user has access to view Pods in all namespaces and
    that the user has the permissions to delete Pods in the `delete-access` namespace:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以验证我们的用户可以查看所有命名空间中的Pods，并且用户有权限在“delete-access”命名空间中删除Pods：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should succeed for both namespaces. This is due to the `ClusterRole` configured
    for the user''s group:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对两个命名空间都成功。这是由于为用户组配置的“ClusterRole”：
- en: '![Output showing that our user has access to view Pods in both namespaces.](image/Figure_10.24.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示我们的用户可以查看两个命名空间中的Pods。](image/Figure_10.24.jpg)'
- en: 'Figure 10.24: Our user has access to view Pods in both namespaces'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.24：我们的用户可以查看两个命名空间中的Pods
- en: 'Let''s also verify the `delete` permissions:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也验证一下“删除”权限：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As expected, this is denied in the `no-access` namespace and allowed in the
    `delete-access` namespace, as can be seen in *Figure 10.25*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，在“no-access”命名空间中被拒绝，在“delete-access”命名空间中被允许，如*图10.25*所示：
- en: '![Verifying the delete permissions shows that it is denied in the no-access
    namespace and allowed in the delete-access namespace.](image/Figure_10.25.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![验证删除权限显示在无访问命名空间中被拒绝，在删除访问命名空间中被允许。](image/Figure_10.25.jpg)'
- en: 'Figure 10.25: Deletes are denied in the no-access namespace and allowed in
    the delete-access namespace'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图10.25: 在无访问命名空间中被拒绝，在删除访问命名空间中被允许'
- en: 'In this section, we have set up a new cluster integrated with Azure AD and
    verified the correct configuration of RBAC with Azure AD identities. Let''s clean
    up the resources we have created in this section, get the credentials for our
    existing cluster, and scale our regular cluster back to two nodes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经设置了一个集成了Azure AD的新集群，并验证了与Azure AD身份的RBAC的正确配置。让我们清理本节中创建的资源，获取现有集群的凭据，并将我们的常规集群缩减到两个节点：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next section, we will continue down the path of Kubernetes security,
    this time investigating Kubernetes secrets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续探讨Kubernetes安全性的路径，这次是调查Kubernetes密码。
- en: Setting up secrets management
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置密码管理
- en: All production applications require some secret information to function. Kubernetes
    has a pluggable Secrets back end to manage these secrets. Kubernetes also provides
    multiple ways of using the secrets in your Deployment. The ability to manage secrets
    and properly use the Secrets back end will make your services resistant to attacks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生产应用程序都需要一些秘密信息才能运行。Kubernetes具有可插拔的密码后端来管理这些密码。Kubernetes还提供了多种在部署中使用密码的方式。管理密码并正确使用密码后端的能力将使您的服务能够抵抗攻击。
- en: We have used secrets in some of our Deployments in previous chapters. Mostly,
    we passed the secrets as a string in some kind of variable, or Helm took care
    of creating the secrets for us. In Kubernetes, secrets are a resource, just like
    Pods and ReplicaSets. Secrets are always tied to a specific namespace. Secrets
    have to be created in all the namespaces where you want to use them. In this section,
    we'll learn how to create, decode, and use our own secrets. We will start by using
    the built-in secrets from Kubernetes, and finish by leveraging Azure Key Vault
    to store secrets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们在一些部署中使用了密码。大多数情况下，我们将密码作为某种变量的字符串传递，或者Helm负责为我们创建密码。在Kubernetes中，密码是一种资源，就像Pods和ReplicaSets一样。密码始终与特定的命名空间相关联。必须在要使用它们的所有命名空间中创建密码。在本节中，我们将学习如何创建、解码和使用我们自己的密码。我们将首先使用Kubernetes中的内置密码，最后利用Azure
    Key Vault来存储密码。
- en: Creating your own secrets
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建您自己的密码
- en: 'Kubernetes provides three ways of creating secrets, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了三种创建密码的方式，如下所示：
- en: Creating secrets from files
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建密码
- en: Creating secrets from YAML or JSON definitions
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从YAML或JSON定义创建密码
- en: Creating secrets from the command line
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行创建密码
- en: 'Using any of the preceding methods, you can create three types of secrets:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述任何方法，您可以创建三种类型的密码：
- en: '**Generic secrets**: These can be created using literal values.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用密码**: 这些可以使用文字值创建。'
- en: '**Docker-registry credentials**: These are used to pull images from a private
    registry.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker-registry凭据**: 用于从私有注册表中拉取镜像。'
- en: '**TLS certificates**: These are used to store SSL certificates.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS证书**: 用于存储SSL证书。'
- en: We'll begin by using the file method of creating secrets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用文件方法创建密码开始。
- en: '**Creating secrets from files**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**从文件创建密码**'
- en: 'Let''s say that you need to store a URL and a secret token for accessing an
    API. To achieve this, you''ll need to follow these steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要存储用于访问API的URL和秘密令牌。为了实现这一点，您需要按照以下步骤进行操作：
- en: 'Store the URL in `apiurl.txt`, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL存储在`apiurl.txt`中，如下所示：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Store the token in another file, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌存储在另一个文件中，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let Kubernetes create the secrets from the files, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让Kubernetes从文件中创建密码，如下所示：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this command, we specify the secret type as `generic`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们将秘密类型指定为`generic`。
- en: 'The command should return the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回以下输出：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can check whether the secrets were created in the same way as any other
    Kubernetes resource by using the `get` command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`get`命令检查秘密是否与任何其他Kubernetes资源以相同的方式创建：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command will return an output similar to *Figure 10.26*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回类似于*图10.26*的输出：
- en: '![Output of kubectl get secrets command displaying the name, type, data, and
    age of the secret. The output has one highlight, highlighting the secret called
    myapi-url-token which is of type Opaque.](image/Figure_10.26.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get secrets命令的输出显示了秘密的名称、类型、数据和年龄。输出中有一个高亮显示，突出显示了名为myapi-url-token的秘密，类型为Opaque。](image/Figure_10.26.jpg)'
- en: 'Figure 10.26: The output of kubectl get secrets'
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.26：kubectl get secrets的输出
- en: Here, you will see the secret we just created, and any other secrets that are
    still present in the `default` namespace. Our secret is of the `Opaque` type,
    which means that, from Kubernetes' perspective, the schema of the contents is
    unknown. It is an arbitrary key-value pair with no constraints, as opposed to
    Docker registry or TLS secrets, which have a schema that will be verified as having
    the required details.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到我们刚刚创建的秘密，以及仍然存在于`default`命名空间中的任何其他秘密。我们的秘密是`Opaque`类型，这意味着从Kubernetes的角度来看，内容的模式是未知的。它是一个任意的键值对，没有约束，与Docker注册表或TLS秘密相反，后者具有将被验证为具有所需详细信息的模式。
- en: 'For more details about the secrets, you can also run the `describe` command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解有关秘密的更多详细信息，您还可以运行`describe`命令：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will get an output similar to *Figure 10.27*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得类似于*图10.27*的输出：
- en: '![Output of the describe command displaying additional details about the secrets.](image/Figure_10.27.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![描述命令的输出显示了有关秘密的其他详细信息。](image/Figure_10.27.jpg)'
- en: 'Figure 10.27: Output of describing the secret'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.27：描述秘密的输出
- en: As you can see, neither of the preceding commands displayed the actual secret
    values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的命令都没有显示实际的秘密值。
- en: 'To get the secrets, run the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取秘密，请运行以下命令：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will get an output similar to *Figure 10.28*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得类似于*图10.28*的输出：
- en: '![Output showing the encoded value of the secret through the -o yaml switch
    in kubectl get secret command.](image/Figure_10.28.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![通过kubectl get secret命令中的-o yaml开关显示秘密的编码值的输出。](image/Figure_10.28.jpg)'
- en: 'Figure 10.28: Using the -o yaml switch in kubectl get secret gets us the encoded
    value of the secret'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.28：在kubectl get secret中使用-o yaml开关可以获取秘密的编码值
- en: The data is stored as key-value pairs, with the file name as the key and the
    base64-encoded contents of the file as the value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以键值对的形式存储，文件名作为键，文件的base64编码内容作为值。
- en: 'The preceding values are base64-encoded. Base64 encoding isn''t secure. It
    scrambles the secret so it isn''t easily readable by an operator, but any bad
    actor can easily decode a base64-encoded secret. To get the actual values, run
    the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的值是base64编码的。Base64编码并不安全。它会使秘密变得难以被操作员轻松阅读，但任何坏人都可以轻松解码base64编码的秘密。要获取实际值，请运行以下命令：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will get the value that was originally entered:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得最初输入的值：
- en: '![Getting the actual values of the secret that were originally entered by using
    the echo <encoded secret> | base64 -d command.](image/Figure_10.29.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![获取最初使用echo <encoded secret> | base64 -d命令输入的秘密的实际值。](image/Figure_10.29.jpg)'
- en: 'Figure 10.29: Base64-encoded secrets can easily be decoded'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.29：Base64编码的秘密可以轻松解码
- en: 'Similarly, for the `url` value, you can run the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对于`url`值，您可以运行以下命令：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will get the originally entered `url` value, as shown in *Figure 10.30*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得最初输入的`url`值，如*图10.30*所示：
- en: '![Output showing the encoded URL, which is the originally entered URL.](image/Figure_10.30.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![显示编码的URL的输出，这是最初输入的URL。](image/Figure_10.30.jpg)'
- en: 'Figure 10.30: The encoded URL can also easily be decoded'
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.30：编码的URL也可以很容易地解码
- en: In this section, we were able to encode the URL with a secret token and get
    the actual secret values back using files. Let's move on and explore the second
    method — creating secrets from YAML or JSON definitions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们能够使用文件对URL进行编码，并获取实际的秘密值。让我们继续探索第二种方法——从YAML或JSON定义创建秘密。
- en: '**Creating secrets manually using YAML files**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用YAML文件手动创建秘密**'
- en: 'We will create the same secrets using YAML files by following these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤使用YAML文件创建相同的秘密：
- en: 'First, we need to encode the secrets to `base64`, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将秘密编码为`base64`，如下所示：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will get the following value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下价值：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You might notice that this is the same value that was present when we got the
    `yaml` definition of the secret in the previous section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这与我们在上一节中获取秘密的`yaml`定义时存在的值相同。
- en: 'Similarly, for the `url` value, we can get the base64-encoded value, as shown
    in the following code block:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对于`url`值，我们可以获取base64编码的值，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will give you the `base64` encoded URL:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给您`base64`编码的URL：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now create the secret definition manually; then, save the file. This
    file has been provided in the code bundle as `myfirstsecret.yaml`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以手动创建秘密定义；然后保存文件。该文件已在代码包中提供，名称为`myfirstsecret.yaml`：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s investigate this file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下这个文件：
- en: '**Line 2**: This specifies that we are creating a secret.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2行**：这指定了我们正在创建一个秘密。'
- en: '**Line 5**: This specifies that we are creating an `Opaque` secret, meaning
    that from Kubernetes'' perspective, values are unconstrained key-value pairs.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5行**：这指定了我们正在创建一个`Opaque`秘密，这意味着从Kubernetes的角度来看，值是无约束的键值对。'
- en: '**Lines 7-8**: These are the base64-encoded values of our secret.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7-8行**：这些是我们秘密的base64编码值。'
- en: 'Now we can create the secrets in the same way as any other Kubernetes resource
    by using the `create` command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像任何其他Kubernetes资源一样使用`create`命令创建秘密：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can verify whether our secret was successfully created using this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式验证我们的秘密是否已成功创建：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will show us an output similar to *Figure 10.31*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个类似于*图10.31*的输出：
- en: '![Output verifying that our secret was successfully created using the kubectl
    get secrets command.](image/Figure_10.31.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![验证我们的秘密是否已成功使用kubectl get secrets命令创建的输出。](image/Figure_10.31.jpg)'
- en: 'Figure 10.31: Our secret was successfully created from a YAML file'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.31：我们的秘密已成功从YAML文件创建
- en: You can double-check that the secrets are the same by using `kubectl get -o
    yaml secrets/myapiurltoken-yaml` in the same way that we described in the previous
    section.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在上一节中描述的方式使用`kubectl get -o yaml secrets/myapiurltoken-yaml`来双重检查秘密是否相同。
- en: '**Creating generic secrets using literals**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用文字创建通用秘密**'
- en: 'The third method of creating secrets is by using the `literal` method, which
    means you pass the value on the command line. To do this, run the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建秘密的第三种方法是使用`literal`方法，这意味着您可以在命令行上传递值。要做到这一点，请运行以下命令：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can verify that the secret was created by running the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来验证秘密是否已创建：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will give us a similar output to *Figure 10.32*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个类似于*图10.32*的输出：
- en: '![Output of the kubectl get secrets commands verifying that our secret was
    successfully created from the CLI.](image/Figure_10.32.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![运行kubectl get secrets命令的输出，验证我们的秘密是否已成功从CLI创建。](image/Figure_10.32.jpg)'
- en: 'Figure 10.32: Our secret was successfully created from the CLI'
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.32：我们的秘密已成功从CLI创建
- en: Thus, we have created secrets using literal values in addition to the preceding
    two methods.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经使用文字值创建了秘密，除了前面两种方法。
- en: Creating the Docker registry key
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Docker注册表密钥
- en: 'Connecting to a private Docker registry is a necessity in production environments.
    Since this use case is so common, Kubernetes has provided mechanisms to create
    a connection:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中连接到私有Docker注册表是必要的。由于这种用例非常常见，Kubernetes提供了创建连接的机制：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first parameter is the secret type, which is `docker-registry`. Then, you
    give the secret a name; for example, `regcred`. The other parameters are the Docker
    server ([https://index.docker.io/v1/](https://index.docker.io/v1/) for Docker
    Hub), your username, your password, and your email.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是秘密类型，即`docker-registry`。然后，您给秘密一个名称；例如，`regcred`。其他参数是Docker服务器（[https://index.docker.io/v1/](https://index.docker.io/v1/)用于Docker
    Hub），您的用户名，您的密码和您的电子邮件。
- en: You can retrieve the secret in the same way as other secrets by using `kubectl`
    to access secrets.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl`访问秘密以相同的方式检索秘密。
- en: In Azure, **Azure Container Registry** (**ACR**) is most frequently used to
    store container images. There are two ways in which the cluster can connect to
    ACR. The first way is using a secret in the cluster like we just described. The
    second way – which is the recommended way – is to use a service principal. We
    will cover integrating AKS and ACR in *Chapter 11, Serverless Functions*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中，**Azure容器注册表**（**ACR**）最常用于存储容器映像。集群可以连接到ACR的方式有两种。第一种方式是在集群中使用像我们刚刚描述的秘密。第二种方式
    - 这是推荐的方式 - 是使用服务主体。我们将在*第11章，无服务器函数*中介绍集成AKS和ACR。
- en: The final secret type in Kubernetes is the TLS secret.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的最终秘密类型是TLS秘密。
- en: Creating the TLS secret
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建TLS秘密
- en: 'A TLS secret is used to store TLS certificates. To create a TLS secret that
    can be used in Ingress definitions, we use the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: TLS秘密用于存储TLS证书。要创建可用于Ingress定义的TLS秘密，我们使用以下命令：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first parameter is `tls` to set the secret type, and then the `key` value
    and the actualcertificate value. These files are usually obtained from your certificate
    registrar.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`tls`，用于设置秘密类型，然后是`key`值和实际的证书值。这些文件通常来自您的证书注册商。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We created TLS secrets in *Chapter 6*, *Managing your AKS,* cluster, where we
    used `cert-manager` to create the secrets on our behalf.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第6章*，*管理您的AKS*，集群中创建了TLS秘密，在那里我们使用`cert-manager`代表我们创建了这些秘密。
- en: 'If you want to generate your own secret, you can run the following command
    to generate a self-signed SSL certificate:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想生成自己的秘密，可以运行以下命令生成自签名SSL证书：
- en: '`openssl req -x509 -nodes -days 365 -newkey rsa:2048 - keyout /tmp/ssl.key
    -out /tmp/ssl.crt -subj "/CN=foo.bar.com"`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl req -x509 -nodes -days 365 -newkey rsa:2048 - keyout /tmp/ssl.key
    -out /tmp/ssl.crt -subj "/CN=foo.bar.com"`'
- en: In this section, we covered the different secret types in Kubernetes and saw
    how you can create secrets. In the next section, we will use the secrets in our
    application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Kubernetes中不同的秘密类型，并看到了如何创建秘密。在下一节中，我们将在我们的应用程序中使用这些秘密。
- en: Using your secrets
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用您的秘密
- en: 'Once secrets have been created, they need to be linked to the application.
    This means that Kubernetes needs to pass the value of the secret to the running
    container in some way. Kubernetes offers two ways to link your secrets to your
    application:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密一旦创建，就需要与应用程序进行关联。这意味着Kubernetes需要以某种方式将秘密的值传递给正在运行的容器。Kubernetes提供了两种将秘密链接到应用程序的方式：
- en: Using secrets as environment variables
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密用作环境变量
- en: Mounting secrets as files
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将秘密挂载为文件
- en: Mounting secrets as files is the best way to consume secrets in your application.
    In this section, we will explain both methods, and also show why it's best to
    use the second method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密挂载为文件是在应用程序中使用秘密的最佳方法。在本节中，我们将解释两种方法，并展示为什么最好使用第二种方法。
- en: Secrets as environment variables
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为环境变量的秘密
- en: 'Secrets are referenced in the Pod definition under the `containers` and `env`
    sections. We will use the secrets that we previously defined in a Pod and learn
    how to use them in an application:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod定义中引用秘密在`containers`和`env`部分下。我们将使用之前在Pod中定义的秘密，并学习如何在应用程序中使用它们：
- en: 'We can configure a Pod with environment variable secrets like the definition
    provided in `pod-with-env-secrets.yaml`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以配置一个具有环境变量秘密的Pod，就像在`pod-with-env-secrets.yaml`中提供的定义：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s inspect this file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个文件：
- en: '**Line 9**: Here, we are setting the environment variables.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9行**：在这里，我们设置环境变量。'
- en: '**Lines 11-14**: Here, we refer to the `secreturl.txt` file in the `myapi-url-token`
    secret.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**第11-14行**：在这里，我们引用`myapi-url-token`秘密中的`secreturl.txt`文件。'
- en: '**Lines 16-19**: Here, we refer to the `secrettoken.txt` file in the `myapi-url-token`
    secret.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**第16-19行**：在这里，我们引用`myapi-url-token`秘密中的`secrettoken.txt`文件。'
- en: 'Let''s now create the Pod and see whether it really worked:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建Pod并看看它是否真的起作用：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check whether the environment variables are set correctly:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查环境变量是否设置正确：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This should show you a result similar to *Figure 10.33*:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示与*图10.33*类似的结果：
- en: '![Verifying whether the environment variables are set correctly by using kubectl
    exec to open a shell in the container and running echo to get the secret values.](image/Figure_10.33.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![通过使用kubectl exec在容器中打开shell并运行echo来验证环境变量是否设置正确，以获取秘密值。](image/Figure_10.33.jpg)'
- en: 'Figure 10.33: We can get the secrets inside the Pod'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.33：我们可以在Pod内部获取秘密
- en: Any application can use the secret values by referencing the appropriate `env`
    variables. Please note that both the application and the Pod definition have no
    hard-coded secrets.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都可以通过引用适当的`env`变量来使用秘密值。请注意，应用程序和Pod定义都没有硬编码的秘密。
- en: Secrets as files
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将秘密作为文件
- en: Let's take a look at how to mount the same secrets as files. We will use the
    following Pod
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将相同的秘密挂载为文件。我们将使用以下Pod
- en: 'definition to demonstrate how this can be done. It is provided in the `pod-with-env-secrets.yaml`
    file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 定义以演示如何完成此操作。它在`pod-with-env-secrets.yaml`文件中提供：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s have a closer look at this file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这个文件：
- en: '**Lines 9-12**: Here, we provide the mount details. We mount in the `/etc/secrets`
    directory as read-only.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第9-12行**：在这里，我们提供挂载详细信息。我们将`/etc/secrets`目录挂载为只读。'
- en: '**Lines 13-16**: Here, we refer to the secret. Please note that both values
    in the secret will be mounted in the container.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13-16行**：在这里，我们引用秘密。请注意，秘密中的两个值都将挂载到容器中。'
- en: Note that this is more succinct than the `env` definition, as you don't have
    to define a name for each and every secret. However, applications need to have
    a special code to read the contents of the file in order to load it properly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这比`env`定义更简洁，因为您不必为每个秘密定义名称。但是，应用程序需要有特殊的代码来读取文件的内容，以便正确加载它。
- en: 'Let''s see whether the secrets made it through:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看秘密是否传递了：
- en: 'Create the Pod using the following command:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建Pod：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Echo the contents of the files in the mounted volume:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回显挂载卷中文件的内容：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see in *Figure 10.34*, our secrets are present in our Pod:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图10.34*中所见，我们的Pod中存在秘密：
- en: '![Output showing that the secrets are available as files in our Pod.](image/Figure_10.34.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示我们的Pod中的秘密可用作文件。](image/Figure_10.34.jpg)'
- en: 'Figure 10.34: The secrets are available as files in our Pod'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.34：我们的Pod中的秘密可用作文件
- en: We have now discussed two ways in which secrets can be passed to a running container.
    In the next section, we will explain why it's best practice to use the file method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了将秘密传递给运行中容器的两种方法。在下一节中，我们将解释为什么最好使用文件方法。
- en: Why secrets as files is the best method
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么将秘密作为文件是最佳方法
- en: 'Although it is a common practice to use secrets as environment variables, it
    is more secure to mount secrets as files. Kubernetes treats secrets as environment
    variables securely, but the Docker runtime doesn''t treat them securely. To verify
    this, you can run the following commands to see the secret in plain text in the
    Docker runtime:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将秘密作为环境变量是一种常见做法，但将秘密作为文件挂载更安全。Kubernetes安全地处理秘密作为环境变量，但Docker运行时不安全地处理它们。要验证这一点，您可以运行以下命令以在Docker运行时看到明文的秘密：
- en: 'Start by getting the instance that the secret Pod is running on with the following
    command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用以下命令获取秘密Pod正在运行的实例：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This should show you the instance ID, as seen in *Figure 10.35*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向您显示实例ID，如*图10.35*所示：
- en: '![Executing the kubectl describe pod secret-using-env command to get the instance
    ID.](image/Figure_10.35.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: 使用kubectl describe pod secret-using-env命令执行以获取实例ID。
- en: 'Figure 10.35: Get the instance ID'
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.35：获取实例ID
- en: 'Next, get the Docker ID of the running Pod:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取正在运行的Pod的Docker ID：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should give you the Docker ID:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向您显示Docker ID：
- en: '![Getting the Docker ID with the kubectl describe pod secret-using-env command.](image/Figure_10.36.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: 使用kubectl describe pod secret-using-env命令获取Docker ID。
- en: 'Figure 10.36: Get the Docker ID'
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.36：获取Docker ID
- en: 'Finally, we will execute a command in the node running our container to show
    the secret we have passed as an environment variable:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在运行我们的容器的节点中执行一个命令，以显示我们作为环境变量传递的秘密：
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will show you both secrets in plain text:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您显示明文的两个秘密：
- en: '![Output showing that the secrets are decoded in the Docker runtime](image/Figure_10.37.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: 输出显示秘密在Docker运行时被解码
- en: 'Figure 10.37: The secrets are decoded in the Docker runtime'
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.37：秘密在Docker运行时被解码
- en: As you can see, the secrets are decoded in the Docker runtime. This means any
    operator with access to the machine will have access to the secrets. This also
    means that most logging systems will log sensitive secrets.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，秘密在Docker运行时被解码。这意味着任何有权访问机器的操作者都将能够访问这些秘密。这也意味着大多数日志系统将记录敏感秘密。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: RBAC is also very important for controlling secrets. A person who has access
    to the cluster and has the right role has access to the secrets that are stored.
    As secrets are only base64-encoded, anybody with RBAC permissions to the secrets
    can decode them. It is recommended to treat access to secrets carefully and be
    very careful about giving people access to use the `kubectl exec` command to get
    a shell to containers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC对于控制秘密也非常重要。拥有对集群的访问权限并具有正确角色的人可以访问存储的秘密。由于秘密只是base64编码的，任何具有对秘密的RBAC权限的人都可以解码它们。建议谨慎对待对秘密的访问，并非常小心地授予人们使用`kubectl
    exec`命令获取容器shell的访问权限。
- en: 'Let''s make sure to clean up the resources we created in this example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保清理掉我们在这个示例中创建的资源：
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that we have explored secrets in Kubernetes using the default secrets mechanism,
    let's go ahead and use a more secure option, namely Key Vault.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用默认的秘密机制在Kubernetes中探索了秘密，让我们继续使用一个更安全的选项，即Key Vault。
- en: Using secrets stored in Key Vault
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存储在Key Vault中的秘密
- en: In the previous section, we explored secrets that were stored natively in Kubernetes.
    This means they were stored base64-encoded on the Kubernetes API server (in the
    background, they will be stored in an etcd database, but that is part of the managed
    service provided by Microsoft). We saw in the previous section that base64-encoded
    secrets are not secure at all. For highly secure environments, you will want to
    use a better secret store.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了存储在Kubernetes中的本地秘密。这意味着它们以base64编码存储在Kubernetes API服务器上（在后台，它们将存储在etcd数据库中，但这是微软提供的托管服务的一部分）。我们在上一节中看到，base64编码的秘密根本不安全。对于高度安全的环境，您将希望使用更好的秘密存储。
- en: 'Azure offers an industry-compliant secrets storage solution called Azure Key
    Vault. It is a managed service that makes creating, storing, and retrieving secrets
    easy, and offers good monitoring of access to your secrets. Microsoft maintains
    an open-source project that allows you to mount secrets in Key Vault to your application.
    This solution is called Key Vault FlexVolume and is available here: [https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Azure提供了符合行业标准的秘密存储解决方案，称为Azure密钥保管库。这是一个托管服务，可以轻松创建、存储和检索秘密，并提供对秘密访问的良好监控。微软维护了一个开源项目，允许您将密钥保管库中的秘密挂载到您的应用程序中。这个解决方案称为密钥保管库FlexVolume，可以在这里找到：[https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol)。
- en: In this section, we will create a Key Vault and install Key Vault FlexVolume
    to mount a secret stored in Key Vault in a Pod.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个密钥保管库，并安装密钥保管库FlexVolume以挂载存储在密钥保管库中的秘密到Pod中。
- en: Creating a Key Vault
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建密钥保管库
- en: 'We will use the Azure portal to create a Key Vault:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Azure门户创建密钥保管库：
- en: To start the creation process, look for *key vault* in the Azure search bar:![Searching
    for Key Vault in the Azure search bar.](image/Figure_10.38.jpg)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始创建过程，请在Azure搜索栏中查找*密钥保管库*：![在Azure搜索栏中搜索密钥保管库。](image/Figure_10.38.jpg)
- en: 'Figure 10.38: Looking for key vault in the Azure search bar'
  id: totrans-337
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.38：在Azure搜索栏中查找密钥保管库
- en: Click the **Add** button to start the creation process:![Navigating to the topleft
    and clicking the Add button to start creating a Key Vault.](image/Figure_10.39.jpg)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加”按钮开始创建过程：![导航到左上角并点击“添加”按钮开始创建密钥保管库。](image/Figure_10.39.jpg)
- en: 'Figure 10.39: Click the Add button to start creating a Key Vault'
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.39：单击“添加”按钮开始创建密钥保管库
- en: Provide the details to create the Key Vault. The Key Vault's name has to be
    globally unique, so consider adding your initials to the name. It is recommended
    to create the Key Vault in the same region as your cluster:![Entering details
    such assubscription, key vault name, and region to create the Key Vault.](image/Figure_10.40.jpg)
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供创建密钥保管库的详细信息。密钥保管库的名称必须是全局唯一的，因此考虑在名称中添加您的缩写。建议在与您的集群相同的区域创建密钥保管库：![输入订阅、密钥保管库名称和区域等详细信息以创建密钥保管库。](image/Figure_10.40.jpg)
- en: 'Figure 10.40: Providing the details to create the Key Vault'
  id: totrans-341
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.40：提供创建密钥保管库的详细信息
- en: Once you have provided the details, hit the **Review + create** button to review
    and create your Key Vault. Hit the **Create** button to finish the creation process.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供详细信息后，点击“审核+创建”按钮以审核并创建您的密钥保管库。点击“创建”按钮完成创建过程。
- en: It will take a couple of seconds to create your Key Vault. Once the vault is
    created, open it, go to secrets, and hit the **Generate/Import** button to create
    a new secret:![Navigating to the secrets tab in the left navigation and hitting
    the Generate/Import button to create a new secret.](image/Figure_10.41.jpg)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的密钥保管库需要几秒钟的时间。一旦保管库创建完成，打开它，转到秘密，然后点击**生成/导入**按钮创建一个新的秘密：![导航到左侧导航中的秘密选项卡，并点击生成/导入按钮创建新秘密。](image/Figure_10.41.jpg)
- en: 'Figure 10.41: Creating a new secret'
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.41：创建新秘密
- en: In the secret creation wizard, provide the details about your secret. To make
    this demonstration easier to follow, it is recommended to use the name `k8s-secret-demo`.
    Hit the **Create** button at the bottom of the screen to create the secret:![Entering
    the details to create our new secret.](image/Figure_10.42.jpg)
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在秘密创建向导中，提供有关您的秘密的详细信息。为了使演示更容易跟进，建议使用名称`k8s-secret-demo`。点击屏幕底部的**创建**按钮来创建秘密：![输入创建新秘密的详细信息。](image/Figure_10.42.jpg)
- en: 'Figure 10.42: Providing the details for your new secret'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.42：提供新秘密的详细信息
- en: Now that we have a secret in Key Vault, we can move ahead and configure Key
    Vault FlexVolume to access this secret in Kubernetes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在密钥保管库中有一个秘密，我们可以继续配置Key Vault FlexVolume以在Kubernetes中访问此秘密。
- en: Setting up Key Vault FlexVolume
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Key Vault FlexVolume
- en: 'In this section, we will set up Key Vault FlexVolume in our cluster. This will
    allow us to retrieve secrets from Key Vault:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在我们的集群中设置Key Vault FlexVolume。这将允许我们从Key Vault中检索秘密：
- en: 'Create Key Vault FlexVolume using the following command. The `kv-flexvol-installer.yaml`
    file has been provided in the source code for this chapter:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建Key Vault FlexVolume。`kv-flexvol-installer.yaml`文件已在本章的源代码中提供：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We have provided the `kv-flexvol-installer.yaml` file to ensure consistency
    with the examples in this book. For production use cases, we recommend installing
    the latest version, available at [https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了`kv-flexvol-installer.yaml`文件，以确保与本书中的示例一致。对于生产用例，我们建议安装最新版本，可在[https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol)上找到。
- en: 'FlexVolume requires credentials to connect to Key Vault. In this step, we will
    create a new service principal:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FlexVolume需要凭据才能连接到Key Vault。在这一步中，我们将创建一个新的服务主体：
- en: '[PRE56]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We will now create two secrets in Kubernetes to store the service principal
    connection:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在Kubernetes中创建两个秘密来存储服务主体连接：
- en: '[PRE57]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will now give this service principal access to the secrets in our Key Vault:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为此服务主体授予对密钥保管库中秘密的访问权限：
- en: '[PRE58]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can verify that these permissions were successfully set in the portal.
    In your Key Vault, in the **Access policies** section, you should see that the
    flex application has `Get` permissions to keys, secrets, and certificates:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在门户中验证这些权限是否已成功设置。在您的密钥保管库中，在**访问策略**部分，您应该看到flex应用程序对密钥、秘密和证书具有`获取`权限：
- en: '![In the Access policies section, we can see that the flex application has
    get permissions for keys, secrets, and certificates.](image/Figure_10.43.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![在访问策略部分，我们可以看到flex应用程序对密钥、秘密和证书具有获取权限。](image/Figure_10.43.jpg)'
- en: 'Figure 10.43: The flex application has Get permissions on keys, secrets, and
    certificates'
  id: totrans-362
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.43：flex应用程序对密钥、秘密和证书具有获取权限
- en: Note
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Key Vault FlexVolume supports a number of authentication options. We are now
    using a pre-created service principal. FlexVolume also supports the use of managed
    identities, either using a Pod identity or using the identity of the **Virtual
    Machine Scale Set** (**VMSS**) hosting the cluster. These other authentication
    options will not be explored in this book, but you are encouraged to read more
    at https://github.com/Azure/kubernetes-keyvault-flexvol.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Key Vault FlexVolume支持多种身份验证选项。我们现在正在使用预创建的服务主体。FlexVolume还支持使用托管标识，可以使用Pod标识或使用托管集群的**虚拟机规模集**（**VMSS**）的标识。本书不会探讨这些其他身份验证选项，但鼓励您在https://github.com/Azure/kubernetes-keyvault-flexvol上阅读更多。
- en: That concludes the setup of Key Vault FlexVolume. In the next section, we will
    use FlexVolume to get access to a secret and mount it in a Pod.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了Key Vault FlexVolume的设置。在下一节中，我们将使用FlexVolume来访问秘密并将其挂载在Pod中。
- en: Using Key Vault FlexVolume to mount a secret in a Pod
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Key Vault FlexVolume在Pod中挂载秘密
- en: In this section, we will mount a secret from Key Vault into a new Pod.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将把一个来自Key Vault的秘密挂载到一个新的Pod中。
- en: 'We have provided a file called `pod_secret_flex.yaml` that will help create
    a Pod that mounts a Key Vault secret. You will need to make two changes to this
    file:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`pod_secret_flex.yaml`的文件，它将帮助创建一个挂载Key Vault秘密的Pod。您需要对这个文件进行两处更改：
- en: '[PRE59]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s investigate this file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下这个文件：
- en: '**Lines 9-12**: Similar to the example of mounting a secret as a file, we are
    also providing a `volumeMount` to mount our secret as a file.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9-12行**：类似于将秘密作为文件挂载的示例，我们还提供了一个`volumeMount`来将我们的秘密作为文件挂载。'
- en: '**Lines 13-23**: This is the volume configuration that points to FlexVolume.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**第13-23行**：这是指向FlexVolume的卷配置。'
- en: '**Lines 17-18**: Here, we refer to the service principal credentials we created
    in the previous example.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**第17-18行**：在这里，我们提到了在上一个示例中创建的服务主体凭据。'
- en: '**Lines 20-23**: You need to make changes to these values to represent your
    environment.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**第20-23行**：您需要更改这些值以代表您的环境。'
- en: 'We can create this Pod using the following command:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建此Pod：
- en: '[PRE60]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the Pod is created and running, we can execute in the Pod and verify that
    the secret is present:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Pod被创建并运行，我们可以在Pod中执行并验证秘密是否存在：
- en: '[PRE61]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This should output the secret we created in Key Vault, as seen in Figure 10.43:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出我们在Key Vault中创建的秘密，如图10.43所示：
- en: '![Output displaying that the secret we configured in Key Vault is mounted in
    the Pod as a file.](image/Figure_10.44.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![显示我们在Key Vault中配置的秘密被挂载在Pod中作为文件的输出。](image/Figure_10.44.jpg)'
- en: 'Figure 10.44: The secret we configured in Key Vault is mounted in the Pod as
    a file'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10.44：我们在Key Vault中配置的秘密被挂载在Pod中作为一个文件
- en: We have successfully used Key Vault to store secrets. The secret is no longer
    stored poorly encoded using base64 on our cluster, but it is now stored securely
    outside of the cluster in Key Vault. We can still access the secret in the cluster
    using Key Vault FlexVolume.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功使用Key Vault存储秘密。秘密不再以base64编码的方式存储在我们的集群中，而是安全地存储在集群外的Key Vault中。我们仍然可以使用Key
    Vault FlexVolume在集群中访问秘密。
- en: 'Let''s make sure to clean up our Deployment:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保清理我们的部署：
- en: '[PRE62]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this section, we have seen multiple ways to create and mount secrets. We
    have explored creating secrets using files, YAML files, and directly from the
    command line. We have also explored how secrets can be consumed, either as an
    environment variable or as a mounted file. We then looked into a more secure way
    to consume secrets, namely via Azure Key Vault.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经看到了创建和挂载秘密的多种方式。我们已经探讨了使用文件、YAML文件和直接从命令行创建秘密的方法。我们还探讨了秘密可以如何被使用，可以作为环境变量或作为挂载文件。然后，我们研究了一种更安全的使用秘密的方式，即通过Azure
    Key Vault。
- en: In the next section, we'll explore using the Istio service mesh to configure
    additional network security in our cluster.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用Istio服务网格在我们的集群中配置额外的网络安全。
- en: The Istio service mesh at your service
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Istio服务网格为您服务
- en: We have found a number of ways to secure our Pods, but our network connections
    are still open. Any Pod in the cluster can talk to any other Pod in the same cluster.
    As a site reliability engineer, you will want to enforce both ingress and egress
    rules. Additionally, you also want to introduce traffic monitoring and would like
    to have better traffic control. As a developer, you don't want to be bothered
    by all of those requirements as you won't know where your application will be
    deployed, or what is and isn't allowed. The best solution would be a tool for
    us to run the applications as is, while still specifying network policies, advanced
    monitoring, and traffic control.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了一些保护我们的Pod的方法，但我们的网络连接仍然是开放的。集群中的任何Pod都可以与同一集群中的任何其他Pod通信。作为一个站点可靠性工程师，你会希望强制执行入口和出口规则。此外，你还希望引入流量监控，并希望有更好的流量控制。作为开发人员，你不想被所有这些要求所困扰，因为你不知道你的应用将被部署在哪里，或者什么是允许的。最好的解决方案是一个工具，让我们可以按原样运行应用程序，同时指定网络策略、高级监控和流量控制。
- en: Enter service mesh. This is defined as the layer that controls service-to-service
    communication. A service mesh is a network between microservices. A service mesh
    is implemented as a piece of software that controls and monitors traffic between
    those different microservices. Typically, a service mesh makes use of a sidecar
    to implement functionality transparently. If you remember, a Pod in Kubernetes
    can consist of one or more containers. A sidecar is a container that is added
    to an existing Pod to implement additional functionality; in a service mesh's
    case, this functionality is the service mesh's functionality.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 进入服务网格。这被定义为控制服务之间通信的层。服务网格是微服务之间的网络。服务网格被实现为控制和监视不同微服务之间流量的软件。通常，服务网格利用边车来透明地实现功能。如果你记得，Kubernetes中的Pod可以由一个或多个容器组成。边车是添加到现有Pod中以实现附加功能的容器；在服务网格的情况下，这个功能就是服务网格的功能。
- en: Note
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A service mesh controls much more than simply network security. If all you require
    is network security in your cluster, please consider adopting network policies.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格控制的远不止网络安全。如果你的集群只需要网络安全，请考虑采用网络策略。
- en: 'Just as with microservices, a service mesh implementation is not a free lunch.
    If you don''t have hundreds of microservices running, you probably don''t need
    a service mesh. If you decide that you really do need one, you will need to choose
    one first. There are four popular options, each with its own advantages:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务一样，服务网格的实现并不是免费的午餐。如果你没有数百个微服务在运行，你可能不需要服务网格。如果你决定你真的需要一个，你首先需要选择一个。有四个流行的选项，每个都有自己的优势：
- en: Linkerd (https://linkerd.io/), including Conduit (https://conduit.io/)
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linkerd (https://linkerd.io/)，包括Conduit (https://conduit.io/)
- en: Istio (https://istio.io/)
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio (https://istio.io/)
- en: Consul (https://www.consul.io/mesh.html)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Consul (https://www.consul.io/mesh.html)
- en: You should choose one service mesh based on your needs and feel comfortable
    in the knowledge that any one of these solutions will work for you. In this section,
    you will be introduced to the Istio service mesh. We chose the Istio service mesh
    because of its popularity. We used stars and commits on GitHub as a measure of
    popularity.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据自己的需求选择一个服务网格，并且放心任何一个解决方案都会适合你。在本节中，你将介绍Istio服务网格。我们选择了Istio服务网格，因为它很受欢迎。我们使用GitHub上的星星和提交作为受欢迎程度的衡量标准。
- en: Describing the Istio service mesh
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述Istio服务网格
- en: Istio is a service mesh created by IBM, Google, and Lyft. The project was announced
    in May 2017 and reached a stable v1 in July 2018\. Istio is the control plane
    portion of the service mesh. Istio by default makes use of the `Envoy` sidecar.
    In this section, we will try to explain what a service mesh is and what the core
    functionalities of the Istio service mesh are.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are only touching on service meshes, and Istio specifically, very briefly
    in this book. Istio is a very powerful tool to not only secure but also manage
    the traffic for your cloud-native application. There are a lot of details and
    functionalities we do not cover in this book.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In terms of functionality, a service mesh (and Istio specifically) has a number
    of core capabilities. The first of these capabilities is traffic management. The
    term traffic management in this context means the control of traffic routing.
    By implementing a service mesh, you can control traffic in order to implement
    A/B testing or canary rollouts. Without a service mesh, you would need to implement
    that logic in your application's core code, whereas with a service mesh, that
    logic is implemented outside of the application.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: With traffic management also comes the added security that Istio offers. Istio
    can manage authentication, authorization, and the encryption of service-to-service
    communication. This ensures that only authorized services communicate with each
    other. In terms of encryption, Istio can implement **mutual TLS** (**mTLS**) to
    encrypt service-to-service communication.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Istio also has the capability to implement policies. Policies can be used to
    either rate limit certain traffic (for example, only allow x transactions a minute),
    handle the whitelisting and blacklisting of access to services, or implement header
    rewrites and redirects.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Istio adds tremendous visibility of the traffic between the different
    services in your application. Out of the box, Istio can perform traffic tracing,
    monitoring, and logging of the traffic between your services. You can use this
    information to create dashboards to demonstrate application performance and use
    this information to more effectively debug application failures.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will install Istio and configure mTLS encryption
    of traffic between Pods. This is only one of the many capabilities of the platform.
    We encourage you to venture outside of the book and learn more about Istio.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Installing Istio
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing Istio is easy; to do so, follow these steps:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Move to your home directory and download the `istio` package, as follows:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add the `istio` binaries to your path. First, get the Istio release number
    you are running:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This should show you an output similar to *Figure 10.45*:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the ls | grepistio command displaying the Istio release number
    being run.](image/Figure_10.45.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.45: Getting your Istio release number'
  id: totrans-414
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note down the Istio version and use it as follows to add the binaries to your
    path:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Check whether your cluster can be used to run Istio using the following command:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Install `istio` with the demo profile:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The demo profile is great to use for a demo of Istio, but it is not recommended
    for production installations.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure everything is up and running, as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should see a number of services in the `istio-system` namespace:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying all the services in the istio-system namespace.](image/Figure_10.46.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.46: All Istio services are up and running'
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You now have Istio up and running.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Envoy as a sidecar automatically
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction of this section, a service mesh uses a sidecar
    to implement functionality. Istio has the ability to install the `Envoy` sidecar
    it uses automatically by using labels in the namespace. We can make it function
    in this way by using the following steps:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s label the default namespace with the appropriate label, namely `istio-
    injection=enabled`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s launch an application to see whether the sidecar is indeed deployed
    automatically (the `bookinfo.yaml` file is provided in the source code for this
    chapter):'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Get the Pods running on the default namespace. It might take a couple of seconds
    for the Pods to show up, and it will take a couple of minutes for all the Pods
    to become `Running`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the `describe` command on any one of the Pods:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can see that the sidecar has indeed been applied:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![Output showing that Istio automatically injected the sidecar proxy listing
    the details about the product page and the istio-proxy.](image/Figure_10.47.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.47: Istio automatically injected the sidecar proxy'
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that without making any modifications to the underlying application, we
    were able to get the Istio service mesh deployed and attached to the containers.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing mutual TLS
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To encrypt all the service-to-service traffic, we will enable mTLS. By default,
    mutual TLS is not enforced. In this section, we will enforce mTLS authentication
    step by step.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want more information on the end-to-end security framework within Istio,
    please read https://istio.io/docs/concepts/security/ #authentication-policies.
    For more details on mutual TLS, please read https://istio.io/docs/concepts/ security/#mutual-tls-authentication.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying sample services**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you will be deploying two services, `httpbin` and `sleep`,
    under different namespaces. Two of these namespaces, `foo` and `bar`, will be
    part of the service mesh. This means they will have the `istio` sidecar proxy.
    You will learn a different way in which a sidecar can be injected here. The third
    namespace, `legacy`, will run the same services without the sidecar proxy:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical representation of the demo application we are going to build. The
    image shows two namespaces in the mesh and one namespace outside of the mesh.
    Each namespace has two pods, sleep and httpbin.](image/Figure_10.48.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.48: Two of the three namespaces are in the service mesh'
  id: totrans-450
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will look at the services of namespaces by using the following commands:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create namespaces (`foo`, `bar`, and `legacy`) and create the `httpbin`
    and `sleep` services in those namespaces:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, we are now using the `istioctl` tool to inject the sidecar.
    It reads our YAML files and injects the sidecar in the Deployment. We now have
    a service in the `foo` and `bar` namespaces with the sidecar injected. However,
    they are not injected in the `legacy` namespace.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Let's check whether everything deployed successfully. To check this, we have
    provided a script that makes a connection from each namespace to all the other
    namespaces. The script will output the HTTP status code for each connection.![Graph
    showing how the script uses the sleep pod to test all connections and makes a
    connection to httpbin in each namespace.](image/Figure_10.49.jpg)
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.49: The script will test all connections'
  id: totrans-456
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Run the script using the following command:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding command iterates through all reachable combinations. You should
    see something similar to the following output. An HTTP status code of `200` means
    success:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the bash test_mtls.sh command displaying an HTTP status code of
    200, indicating success for all the pods and demonstrating that each Pod can communicate
    with all other Pods.](image/Figure_10.50.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.50: Without any policy, we can successfully connect from each namespace
    to the other namespaces'
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This shows us that in the current configuration, all Pods can communicate with
    all other Pods.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that there are no existing policies except for the default, as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This should show you:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying that there are only two policies present.](image/Figure_10.51.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.51: There should only be two policies present'
  id: totrans-467
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Additionally, ensure that there are no destination rules that apply:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the results, there should be no hosts with `foo`, `bar`, `legacy`, or a wildcard
    (indicated as `*`).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![Ensuring that there are no destination rules that apply and there are no
    hosts with foo, bar, legacy, or a * wildcard.](image/Figure_10.52.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.52: There should be no hosts with foo, bar, legacy, or a * wildcard'
  id: totrans-472
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have successfully deployed the sample services and were able to confirm that
    – in the default scenario – all services were able to communicate with each other.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Globally enabling mTLS
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With an mTLS policy, you can state that all services must use mTLS when communicating
    with other services. If not using mTLS, a bad actor who has access to a cluster,
    even if they don''t have access to the namespace, can communicate with any Pod.
    If given enough rights, they can also operate as the man in the middle between
    services. Implementing mTLS between services reduces the chances of man-in-the-middle
    attacks between services:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable mutual TLS globally, we will create the following `MeshPolicy` (provided
    in `mtls_policy.yaml`):'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Since this `MeshPolicy` has no selectors, it will apply to all workloads. All
    workloads in the mesh will only accept encrypted requests using TLS. This means
    the `MeshPolicy` handles the incoming part of the connection:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical representation showing how the MeshPolicy applies to the incoming
    connection. The picture shows how httpbin in the foo and bar namespaces are part
    of the MeshPolicy.](image/Figure_10.53.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.53: The MeshPolicy applies to the incoming connection'
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can create the `MeshPolicy` using this command:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are applying the mTLS very coarsely and aggressively. Typically, in a production
    system, you will introduce mTLS more slowly. Istio has a special mTLS enforcement
    mode called `permissive` to help achieve this. With mTLS in the `permissive` mode,
    Istio will try to implement mTLS where possible and log a warning where it is
    not possible. However, the traffic will continue to flow.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the script again to test network connectivity:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Those systems with sidecars will fail when running this command and will receive
    a `503` status code, as the client is still using plain text. It might take a
    few seconds for `MeshPolicy` to take effect. *Figure 10.54* shows the output:![Output
    of the bash test_mtls.sh command showing that the traffic to the httpbin.foo and
    httpbin.barPods that have a sidecar fail with a 503 status code.](image/Figure_10.54.jpg)
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.54: Traffic to Pods with a sidecar fails with a 503 status code'
  id: totrans-488
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you see a `200` status code more frequently in the preceding output, consider
    waiting a couple of seconds and then rerunning the test.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now allow certain traffic by setting the destination rule to use a
    `*` wildcard that is similar to the mesh-wide authentication policy. This is required
    to configure the client side:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s have a look at this file:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 2**: Here, we are creating a `DestinationRule` which defines policies
    that apply to traffic intended for a service after routing has occurred.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 7**: Traffic intended for any host in `.local` (which in our case is
    all the traffic in the cluster) should use this policy.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 8-10**: Here, we define that mTLS is required for all traffic.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DestinationRule` applies to the outgoing part of the connection, as shown
    in *Figure 10.55*:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '![A graphical representation showing that the destinationRule applies to the
    outgoing part of the connection. The image shows that sleep in namespace foo and
    bar are part of the DestinationRule.](image/Figure_10.55.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.55: The DestinationRule applies to outgoing traffic'
  id: totrans-498
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can create this using the following:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can check the impact of this by running the same command again:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This time, the returned codes will be as shown in *Figure 10.56*:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '![Re-running the bash test_mtls.sh command, which shows that foo and bar can
    now connect to each other, but they can''t connect to legacy anymore.](image/Figure_10.56.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.56: Foo and bar can now connect to each other but they can''t connect
    to legacy anymore'
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s consider for a minute what we implemented in this case. We implemented:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: A cluster-wide policy that requires TLS traffic coming into Pods.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: A cluster-wide DestinationRule that required mTLS on outgoing traffic.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: The impact of this is that services within the mesh (also known as having the
    sidecar) can now communicate with each other using mTLS, and services that are
    completely out of the mesh (also known as not having the sidecar) can also communicate
    with each other, only without mTLS. Due to our current configuration, service-to-service
    communication is broken when only part of the flow is in the mesh.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure to clean up any resources we deployed:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This concludes this demonstration of Istio.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we focused on security in Kubernetes. We started with a look
    into cluster RBAC using identities in Azure AD. After that, we continued with
    storing secrets in Kubernetes. We went into detail about creating, decoding, and
    using secrets. Finally, we installed and injected Istio, achieving the goal of
    being able to set system-wide policies without needing developer intervention
    or oversight. Since hackers like to pick on easy systems, the skills that you
    have learned in this chapter will help to make your setup less likely to be targeted.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, you will learn how to deploy serverless functions
    on **Azure Kubernetes Service** (**AKS**).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL

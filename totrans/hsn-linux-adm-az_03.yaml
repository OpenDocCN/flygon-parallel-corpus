- en: 'Chapter 3: Basic Linux Administration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the deployment of your first Linux **virtual machine** (**VM**), let's
    log in, discuss some basic Linux commands, and learn how to find our way in the
    Linux environment. This chapter is about basic Linux administration, starting
    with the Linux shell, which is used to interact with the Linux system. We'll discuss
    how to use the shell to accomplish our day-to-day administration tasks, such as
    accessing the filesystem, managing processes such as starting and killing programs,
    and many other things.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of this chapter, we'll discuss the **Discretionary Access Control**
    (**DAC**) model and how to create, manage, and verify users and groups in Linux
    and get permissions for files and directories based on the username and group
    membership. We'll also cover changing file ownership for a user/group and changing
    and verifying basic permissions and access control lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key topics of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the shell and configuring the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help using man pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with and editing text files via the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the file hierarchy, managing the filesystem, and mounting new
    filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User and group management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last chapter, we created the VM and logged in using SSH, but how do we
    interact with the Linux machine and instruct it to perform tasks? As we mentioned
    at the beginning of this chapter, we'll use the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be exploring the widely used Bash shell, the configuration of the Bash
    shell, and how to use it. A shell is a user interface in which you can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interact with the kernel, filesystem, and processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute programs, aliases, and shell built-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A shell provides features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History and aliasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many different shells available, such as the KornShell, Bash, and
    the **Z shell** (**Zsh**). Bash is the default shell on almost every Linux system.
    Its development started in 1988 as a replacement for one of the oldest shells:
    the Bourne shell. Bash was based on the Bourne shell and lessons learned from
    other shells such as the KornShell and the C shell. Bash has become the most popular
    shell and is available on many different operating systems, including Windows
    10, FreeBSD, macOS, and Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the most important features that were added to Bash version
    2.05a (released in 2001) that have made Bash the most prominent shell:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocompletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here documents (a way of getting text input into a separate file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New variables, such as `$RANDOM` and `$PPID`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lately, the Z shell is becoming more popular; the development of this shell
    started in 1990, and it can be seen as an extension to Bash. There is also a compatibility
    mode with Bash. It comes with even better auto-complete support, including auto-correction
    and more advanced pathname expansion. Its functionality can be extended with modules,
    for example, to get more help with commands. The Oh-My-ZSH ([https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh))
    and Prezto ([https://github.com/sorin-ionescu/prezto](https://github.com/sorin-ionescu/prezto))
    projects are worth mentioning: they provide theming, advanced configuration, and
    plugin management to make the Z shell very user-friendly. All these nice features
    come with a price: the Z shell is definitely more resource-hungry than Bash.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most important features of a shell is that you can execute commands.
    A command can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shell built-in (a command that is provided by the shell in question)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executable on a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find out what type of command you''re executing, there is the `type` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `-a` parameter will show all locations containing an executable
    named `echo`. In the following screenshot, we can see that when we add the `-a`
    parameter, the shell gives a reference to the `/usr/bin/echo` directory as well,
    due to the presence of the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the type command along with the parameter -a to find the type and locations
    of an executable named echo.](img/B15455_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Locations containing the executable echo'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s do the same for `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you will get a similar output for `type ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the command type -a ls to display the location containing the executable
    ls. By running this command we can also see that ls is an alias for ls --color=auto](img/B15455_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Locations containing the executable ls'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here, we can see that `ls` is an alias for the `ls --color=auto` command with
    some parameters added. An alias can replace an existing command or create a new
    one. The `alias` command without parameters will give you aliases that are already
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the alias command on different keywords to display the aliases these
    commands are already configured with.](img/B15455_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Using the alias command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `ll` alias is an example of a newly created command. The `mv` command is
    an example of a replacement. Create a new alias with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, to replace the `grep` command with `search`, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The alias you are creating will be added to the `.bashrc` file. If you want
    to remove an alias you have created, you can use the `unalias` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you want to remove all defined aliases, you can use `unalias -a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `which` command identifies the location of a program in the `$PATH` variable.
    This variable contains a list of directories that are? used to find an executable.
    This way, you don''t have to provide the full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output tells you that it''s available in the `/usr/bin` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying the location of a program using the which command.](img/B15455_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Directory location of the program in $PATH variable'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Command-line Editing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many ways, entering commands in the Bash shell is the same as working in
    a text editor. That is probably the reason why there are shortcuts for actions
    such as going to the start of a line, and why the shortcuts are the same as in
    the two most famous, and most commonly used, text editors: Emacs and vi.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Bash is configured to be in Emacs editing mode. If you want to
    check the current editing mode, run `set -o`. The output will say whether Emacs
    or vi is set to `on`. The following are a few very important shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A table listing a few important shortucts to navigate through the Bash shell.](img/B15455_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: List of Bash shell shortcuts'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to use vi mode, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch back to Emacs mode, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The vi editor is covered in a later section of this chapter, *Working with Text
    Files*. For now, you can use almost every command in command mode, including `navigation`,
    `yank`, and `put`.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` command is a Bash built-in command that toggles attributes specific
    to Bash. Without parameters, it dumps environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Working with history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Bash shell provides command-line tools that you can use to work with the
    user''s command history. Every command that you execute is registered in a history
    file in the home directory: `~/.bash_history`. To view the content of this history,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows a numbered list of previously used commands; you can simply
    redo a command using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`!<number>`: Execute the command based on the history list number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!<-number>`: For instance, `!-2` executes the command that was executed two
    commands prior to the last command in the history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!<first characters of the command>:` This will execute the last item that
    starts with this character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!!:` Redo the last command. You can combine this with other commands. For
    instance, `sudo !!`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can backward-search the history using *Ctrl* + *R* (Emacs mode) or using
    the forward slash (vi command mode). Browsing is possible using the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The history file is not written directly after the execution of a command,
    but at the end of a login session. If you are working in multiple sessions, it
    can be a good idea to write the history directly. To do so, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the just-saved history in another session, execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear the history of the current session, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to save the history to a file, you can execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, by saving the cleared history, you emptied the history file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice feature of working with the history is that you can edit it. Let''s
    say you executed the `ls -alh` command, but you need `ls -ltr`. Just type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can do this for every entry in the history; for instance, for
    number `6` in the history list, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you need more flexibility, and you want to edit a big line that contains
    a lot of typos. Enter the `fc` command. Fix the command using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This opens a text editor (vi by default) and, after saving the modification,
    it will execute the modified command.
  prefs: []
  type: TYPE_NORMAL
- en: Autocompletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everyone makes typos; no one can remember every parameter. Autocompletion can
    prevent many errors and helps you in many ways when you enter commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Autocompletion works for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Executables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell built-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs on the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filenames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters, if the utility supports it and the `bash-completion` package is
    installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shell is configured in Emacs mode, use *Ctrl* + *I* to activate autocomplete;
    if the shell is configured in vi mode, you can use *Ctrl* + *P* as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If there is more than one possibility, you have to hit *Ctrl* + *I* or *Ctrl*
    + *P* twice.
  prefs: []
  type: TYPE_NORMAL
- en: Globbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Globbing is expanding a non-specific filename that contains a wildcard into
    one or more specific filenames in the Linux shell. Another common name for globbing
    is pathname expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following wildcards are recognized in the Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?`: One single character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Multiple characters. Please notice that if you use this wildcard as the
    first character, filenames starting with a dot won''t match. Of course, you can
    use `.*`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[a-z], [abc]`: One character from the range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{a,b,c}`: a or b or c.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some nice examples of using wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo *`: This will list the files or directories in the current working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd /usr/share/doc/wget*`: This will change the directory to the directory
    name starting with `wget` residing in `/usr/share/doc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls /etc/*/*conf`: This will list all `.conf` files in all directories under
    `/etc`. Here''s an example of this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Running the command ls /etc/*/*conf to display all .conf files in all directories
    under /etc.](img/B15455_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Listing all the .conf files from all directories'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`mkdir -p /srv/www/{html,cgi-bin,logs}`: This will create `html`, `cgi-bin`,
    and `log` directories inside `/srv/www` with a single command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the early days of Unix, one of the developers, Ken Thompson, defined a *Unix
    philosophy*, an approach based on experience to make everything as modular as
    possible and to reuse code and programs as much as possible. Particularly in those
    days, reusability was important for performance reasons and to provide a method
    that allowed for easy maintenance of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a version of this *Unix philosophy* modified by Peter H Salus, the objectives
    of redirection are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write programs that do one thing and do it well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write programs to work together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write programs to handle text streams, because that is a universal interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make this philosophy possible, programs were developed with support for
    file descriptors, or, in modern parlance, communication channels. Every program
    has at least three communication channels:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard input (0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard output (1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard error (2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the nice features of this implementation is that you can redirect the
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To redirect the standard output to a file, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To redirect the standard output and append to an existing file, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Redirect the standard error and output to a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To redirect standard output first to a file and then redirect the standard
    error there as well, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To redirect the standard input, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do an activity to help us understand the concept of redirection. Please
    run the command first, verify the output, then redirect to file using the following
    methods. For example, run `ls` and verify the output, then use `>` to redirect
    the output to `/tmp/test.list`. You can always check the file using `cat /tmp/test.list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A special version of input redirection is `heredoc.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command concatenates the standard output and appends it to the `/tmp/heredoc.txt`
    file. There is no way to interrupt or break the command because the keyboard is
    not the standard input until it encounters a label, in this example, `EOF`. This
    method is often used to create configuration files from scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is taking the standard output of one command and redirecting
    it to the standard input of another command using the `|` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `tee` command, you can combine the power of redirection and piping.
    There are times when you want to make sure the output of `command 1` is written
    to a file for troubleshooting or logging and, at the same time, you pipe it to
    the standard input of another command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Appending to a file is also possible using the `-a` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case of `tee` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This way, it is possible to write into a file without using difficult `su` constructions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every command-line interface, even those without advanced scripting possibilities,
    has the concept of variables. In Bash, there are two types of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in or internal variables that affect the behavior of Bash or give information
    about Bash. Some examples include `BASH_VERSION`, `EDITOR`, and `PATH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables that are known to one or more applications, including
    built-in variables and user-defined variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To list the environment variables for your current shell, you can use the `env`
    or `printenv` command. `printenv` is also able to show the content of a specific
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the command printenv PATH to list the environment variables for your
    current shell.](img/B15455_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Displaying the content of a specific variable using printenv command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way to view the content of a variable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare an environment variable, execute `var=value`. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To add more characters to the value, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `animal` variable is only known to your current shell. If you want to export
    it to child processes, you need to export the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash is also capable of doing simple calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Another feature is putting the output of a command into a variable—a technique
    called nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is just a glimpse of what Bash is capable of, but this should
    be enough for you to learn how to handle Bash configuration files and modify them
    for the environment you need so that they behave in the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: Bash Configuration Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three important system-wide configuration files for the Bash shell:
    `/etc/profile`, `/etc/bashrc`, and `/etc/environment`. The purpose of these files
    is to store information regarding your shell, such as the colors, aliases, and
    variables. For example, in the previous section, we added a couple of aliases,
    and they are stored in a file called `bashrc`, which is a configuration file.
    Each file has its own purpose; we will take a look at each of them now.'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/profile` is a script that is executed once a user logs in to a system.
    It is not a good idea to modify this file; instead, use the snap-in `/etc/profile.d`
    directory. Files in this directory are executed in alphabetical order and must
    have `.sh` as the file extension. As a side note, `/etc/profile` is not only used
    by the Bash shell, but by all shells for Linux, except for PowerShell. You can
    also create a user-specific profile script in the home directory, `~/.bash_profile`,
    which is also Bash-specific.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some typical content of a profile script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are using Ubuntu or a similar distribution, `pinfo` is not installed
    by default. Run `apt install pinfo` to install it.
  prefs: []
  type: TYPE_NORMAL
- en: The `shopt` command changes some default Bash behavior, such as checking for
    mail or the behavior of globbing. The `unset` command is the opposite of the `set`
    command. In our example, by default, Bash checks for mail every minute; after
    executing the `unset MAILCHECK` command, the `MAILCHECK` variable is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/etc/bashrc` script is started every time any user invokes a shell or
    shell script. For performance reasons, keep it as minimal as possible. Instead
    of the `/etc/bashrc` file, you can use the user-specific `~/.bashrc` file, and
    the `~/.bash_logout` script is executed if you exit a shell. The `bashrc` configuration
    files are often used to modify the prompt (the `PS1` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the parameters for the `PS1` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Colors (like GREEN, DARKGRAY passed into PS1 variable) are defined in ANSI color
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\e`: Escape character in ANSI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\n`: Newline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w`: Current working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\t`: Current time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u`: Username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/etc/environment` file (empty by default in Red Hat–based distributions)
    is the first file that is executed at login. It contains variables for every process,
    not just the shell. It's not a script, just one variable on each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `/etc/environment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `EDITOR` variable is an important one. Many programs can invoke an editor;
    sometimes it's vi by default, sometimes it's not. Setting a default ensures that
    you can always use your favorite editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don't want to log out and log in again, you can use the `source` command,
    for instance, `source /etc/environment`. This way, the variables will be read
    into your current shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you are new to Linux or a long-time user, from time to time, you'll
    need help. It's impossible to remember all the commands and their parameters.
    Almost every command has a `--help` parameter, and there is sometimes documentation
    installed in the `/usr/share/doc` directory, but the most important sources of
    information are the information documents and man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Using the man pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a saying, **Read The Fine Manual** (**RTFM**), and sometimes people
    replace the word *fine* with another, less friendly word. Almost every command
    has a manual: a man page provides you with all the information you need. And yes,
    not all man pages are easy to read, especially older ones, but if you use man
    pages frequently, you''ll get used to them, and you''ll be able to find the information
    you need quickly enough. Normally, man pages are installed on your system, and
    they are available online: [http://man7.org/linux/man-pages](http://man7.org/linux/man-pages).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the man pages are removed in the Azure images for openSUSE Leap and
    SUSE Linux Enterprise Server. You have to reinstall every package to make them
    available again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Man pages are installed in the `/usr/share/man` directory in GZIP compressed
    archives. Man pages are specially formatted text files that you can read with
    the `man` command or `pinfo`. The `pinfo` utility acts as a text browser, very
    similar to a text-based web browser. It adds hyperlink support and the ability
    to navigate between different man pages using the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to replace the `man` command with `pinfo`, it is a good idea to
    create an alias using the `alias man="pinfo -m"` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'All man pages follow a similar structure, and they are always formatted and
    divided into sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name of the command and a brief explanation of the command. Usually
    a one-liner; detailed information can be found in the Description section of the
    man page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synopsis**: An overview with all the available parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifconfig` command explicitly states that this command is obsolete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: All the available parameters of a command, sometimes including
    examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: If the examples are not in the Options section, there may be
    a separate section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Files**: Files and directories that are important to this command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**: Refers to other man pages, info pages, and other sources of documentation.
    Some man pages contain other sections, such as notes, bugs, history, authors,
    and licenses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Man pages are help pages that are divided into several sections; these sections
    are described in the Description section of the man page. You can use `man man`
    to understand more about the sections. The following screenshot shows the different
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot listing various sections of the man pages.](img/B15455_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Different sections of a man page'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This sectioning is important to know about, especially if you want to search
    for documentation. To be able to search for documentation, you''ll need to index
    the man pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normally, after installing a package, the index is automatically updated. Sometimes,
    the packager will have failed to add a post-install script to execute the `mandb`
    command. It's a good idea to execute the command manually if you can't find the
    information and you are pretty sure that there should be a man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can use the `apropos` or `man -k` commands to find the information
    you need. It doesn''t matter which one you choose; the syntax is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we search for the word `time`, limiting the search
    to the man page section 5.
  prefs: []
  type: TYPE_NORMAL
- en: Using info Documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Info documents are another important source of information. The difference between
    man pages and info pages is that info pages are more freely formatted, whereas
    man pages are a sort of instruction manual for a certain command. Info documents
    are, most of the time, complete handbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Info documents are, like man pages, compressed and installed in the `/usr/share/info`
    directory. To read them, you can use `info` or the more modern `pinfo`. Both commands
    act as a text-based browser. If you are a big fan of the Emacs editor, you can
    use InfoMode ([https://www.emacswiki.org/emacs/InfoMode](https://www.emacswiki.org/emacs/InfoMode))
    to read the info documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the nice features is that you can directly jump to one of the hyperlinks
    in the document using `pinfo` or `info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are using Ubuntu or a similar distribution, `pinfo` is not installed
    by default. Run `apt install pinfo` to install it.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example opens the man page of `pinfo` and jumps directly to the
    `Keybindings` section.
  prefs: []
  type: TYPE_NORMAL
- en: The `pinfo` command has a search option, `-a`. If there is a match, it will
    automatically open the corresponding `info` document or man page. For example,
    if you would like to know about the `echo` command, use `pinfo -a echo`; it'll
    take you to the help section of the `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `info` command has a search option as well: `-k`. Using `-k`, the `info`
    command will look up the keyword in all available manuals. For example, here we''ve
    checked for the `paste` keyword, and it returned all possible matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the info -k command to look up the keyword paste in all available manuals.](img/B15455_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Checking for the paste keyword using the info command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another source of documentation is the documentation provided by the Linux distribution
    vendor. The websites of Red Hat, SUSE, Canonical, and Debian host useful handbooks,
    wikis, and so on. They can be very useful, especially for topics that are distribution-specific,
    such as software management.
  prefs: []
  type: TYPE_NORMAL
- en: There are two distributions that are not Microsoft-endorsed distributions, Gentoo
    and Arch Linux, and they have excellent wikis on their websites. And, of course,
    some of the information in these wikis is specific to these distributions, but
    many articles are useful and will work on every distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Foundation hosts a wiki at [https://wiki.linuxfoundation.org](https://wiki.linuxfoundation.org)
    with documentation regarding topics such as networking, and standards such as
    the `init` system, systemd, and the Linux firewall (firewalld); these topics are
    discussed in *Chapter 5, Advanced Linux Administration*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Linux Documentation Project can be found at [https://www.tldp.org](https://www.tldp.org).
    While many of the documents you can find there are very old, it's still a good
    starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Text Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unix philosophy started by Ken Thompson aimed to create a capable operating
    system with a small footprint and a clean user interface. Because part of the
    Unix philosophy is to *write programs to handle text streams, because that is
    a universal interface*, communication between programs, configuration files, and
    many other things is implemented in plain text. This section is all about handling
    plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the most fundamental level, reading the content of a file in plain text
    format means taking the content of this file and redirecting it to the standard
    output. The `cat` command is one utility that can do that—concatenate the content
    of one or more files (or another input channel) to the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading the contents of the file /etc/shells using the cat utility.](img/B15455_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Using the cat command to generate standard output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some nice parameters of this utility are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-A`: Show all non-printable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: Number lines, including empty lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: Number lines, except empty lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: Suppress repeated (`!`) empty blank lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another utility like `cat`, which is the `tac` utility. This will
    print the file in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Printing the contents of a file in reverse order by running the tac utility.](img/B15455_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Using the tac utility to print files in reverse order'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The problem with the `cat` command is that it just dumps the content to the
    standard output without paginating the content, and the scrollback functionality
    for the terminals is not very good.
  prefs: []
  type: TYPE_NORMAL
- en: The `more` utility is a filter for paging. It displays the text one screenful
    at a time and provides a basic search engine that can be activated by using the
    forward slash. At the end of the file, `more` will exit, with or without the message
    `Press space to continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `less` utility is more advanced than the `more` utility. It has the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to scroll forward, backward, and horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced search engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple file handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to display information about the file, such as the filename and length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to invoke shell commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `more` and `less`, the `v` command allows us to switch to an editor, by default
    the vi editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both `more` and `less` are available on every distribution; however, on some
    distributions, `more` is an alias for `less`. Use the `type` command to verify!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see only a specific number of lines at the top of a file, there
    is a utility called `head`. By default, it shows the first 10 lines of a file.
    You can modify this behavior using the `-n` parameter for the number of lines
    and the `-c` parameter for the number of bytes/kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` utility is the opposite of `tail`; it shows the first 10 lines by
    default. For example, we have a file named `states.txt` that contains the names
    of US states in alphabetical order. If we use the `head` command, it will print
    the first 10 lines of the file, and if we use the `tail` command it''ll print
    the last 10 lines. Let''s have a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Printing the first 10 and the last 10 entries of a file using the head and
    tail utility.](img/B15455_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Using head and tail utilities to list the first and last 10 entries
    of the file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It recognizes the same parameters as `head` to modify that behavior. But there
    is an extra parameter that makes this utility extremely useful for logging purposes.
    `-f` appends the output as the file grows; it''s a way of following and monitoring
    the content of a file. A very well-known example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Searching in Text Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have heard that everything in Linux is a file. Also, many things in
    Linux are managed by text streams and text files. Sooner or later, you will want
    to search the text in order to make modifications. This can be done by using regular
    expressions. A regular expression (regex for short) is a pattern of special characters
    and text used to match strings when performing a search. Regular expressions are
    used by many applications with a built-in processor, such as the Emacs and vi
    text editors, and utilities such as `grep`, `awk`, and `sed`. Many scripting and
    programming languages have support for regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we'll only cover the basics of this topic—just enough that you
    can use them in your daily system administration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every regular expression is built around an atom. The atom identifies what
    text is to be matched and where it is to be found when doing a search. It could
    be a known single-character item (or a dot if you don''t know the character),
    a class, or a range, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A table showing how to express multiple single character items and ranges
    using regular expressions.](img/B15455_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Examples of atom'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A regex can also be expressed in the form of a shorthand class. Here are a
    few examples of shorthand classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A list of different regular expressions expressed in the form of a shorthand
    class.](img/B15455_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure3.14: Examples of shorthand classes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use position anchors to determine where to find the next character.
    Some popular ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List of important position anchors to determine where to find the next character.](img/B15455_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: List of position anchors'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using a repetition operator, you can specify how many times a character should
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List of repetition operators](img/B15455_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: List of repetition operators'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A few examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you search for the character `b` and the word `boom` is found, it will match
    the letter `b`. If you search for `bo`, it will match these characters in this
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you search for `bo{,2}m`, the words `bom` and `boom` will match. But if the
    word `booom` exists, it will not match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you search for `^bo{,2}m`, there will be only a match if the word `boom`
    is at the beginning of a line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A reference for regular expressions can be found using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: One utility we've already mentioned is the `grep` utility, which is used to
    search in text files. There are multiple versions of this utility; nowadays, `egrep`
    is the most commonly used version because it has the most complete regular expression
    support, including shorthand ranges and the OR alternation operator, `|`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common options for `egrep` and `grep` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A table listing common options for egrep and grep.](img/B15455_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: egrep and grep options'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also take look at the other options by checking the man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example of `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![grep example](img/B15455_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: grep example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another utility that is very useful is `awk`. Now, `awk` is a utility that was
    created by the developers Alfred Aho, Peter Weinberger, and Brian Kernighan. It
    is a scripting language used for text files which is used to generate and manipulate
    log files or reports. `awk` doesn't require any compiling, and you can mention
    the fields required in the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It scans the `/etc/passwd` file and splits the content using the field separator,
    the colon. It searches for the line starting with the `root` string and prints
    some text (`Homedir of root:`) and the sixth column.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Text Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because text files are so important in Linux, a text editor is very important.
    Every distribution has one or more editors in their repositories for both graphical
    and non-graphical environments. You can be sure that at least vim, a modern vi
    implementation, and Emacs are available. There is an ongoing war between vi lovers
    and Emacs lovers—they have been insulting each other for decades and will do so
    for many decades to come.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to make the decision for you; instead, if you are already familiar
    with one of them, stick with it. If you don't know vi or Emacs, try them both
    for a while and decide for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some other editors available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nano`, a free clone of proprietary Pico, the text-editor component of the
    Pine email client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mcedit`, a part of the **Midnight Commander** (**MC**) file manager that can
    run standalone as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joe`, which can emulate the keybindings of nano, Emacs, and a very old word
    processor called WordStar (note that, for CentOS, this editor is not available
    in the standard repository, but is in a third-party repository).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to learn about vi, execute the `vimtutor` command, a tutorial that
    comes with vim. It's a good starting point for learning all the basics of navigation,
    the commands, and text editing in vi.
  prefs: []
  type: TYPE_NORMAL
- en: Emacs comes with a very good help function that you can access in Emacs via
    *Ctrl* + *H* + *R*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to edit text streams and files is by using the non-interactive
    text editor sed. Instead of text files editing opening a file in a text editor
    window, it processes a file or stream from the shell. It''s a handy utility if
    you want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform edits on file(s) automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On multiple files, make the same edits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a conversion program—for example, to change between lowercase and uppercase,
    or even more complex conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax of the sed editor is very similar to the commands of the vi editor,
    and can be scripted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default behavior for sed is not to edit the file itself, but to dump the
    changes to the standard output. You can redirect this output to another file or
    use the `-i` parameter, which stands for `sed` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It will search for a string, replace it, and continue searching and replacing
    until the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together with a little bit of scripting, you can edit multiple files in the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can limit the search to a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `info` page of `sed` is a great resource for all the commands and, more
    importantly, it has an example section if you want to know more.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Your Way in the Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know how to manipulate and edit text files, it''s time to see
    how these files are stored in the system. As a system administrator, you will
    have to check, mount, or even unmount the drives. So, now let''s take a close
    look at the filesystem in Linux. The layout of the Linux filesystem is like all
    other members of the Unix family: very different from Windows. There is no concept
    of drive letters. Instead, there is a root filesystem (`/`), and everything else
    is available on the root filesystem, including other mounted filesystems.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll learn where you can find files, and why they are there.
  prefs: []
  type: TYPE_NORMAL
- en: The Filesystem Hierarchy Standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2001, the Linux Foundation started the **Linux Standard Base Project** (**LSB**).
    Based on the POSIX specification, the idea behind this process was to have a standardized
    system so that applications can run on any compatible Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The **Filesystem Hierarchy Standard** (**FHS**) is a part of this project and
    defines the directory structure and directory contents. Of course, there are still
    some minor differences between distributions regarding the directory structure,
    but even on distributions that are not willing to fully support the LSB, such
    as Debian, the directory structure follows the FHS.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshots are taken from a CentOS system, using the `tree` utility
    to show the directory structure. If `tree` is not installed on your system, the
    shell will prompt you with the command to install. Please do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root filesystem, the following directories are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the directory structure of the root filesystem using the tree utility.](img/B15455_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: Displaying the directory structure using the tree utility'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `tree` command will layout the filesystem in a tree-like structure. Alternatively,
    you can use `ls -lah /` to see the structure in a list format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directories are present in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: Contains programs that you need on a minimal system to be executed
    by an unprivileged user such as a shell. On Red Hat–based systems, this directory
    is a symbolic link to `/usr/bin`. Commands such as `ps`, `ls`, and `ping` are
    stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: Contains programs that you need on a minimal system to be executed
    by a privileged user (`root`), such as filesystem repair utilities. On Red Hat
    Enterprise Linux–based systems, this directory is a symbolic link to `/usr/sbin`.
    Examples include `iptables`, `reboot`, `fdisk`, `ifconfig`, and `swapon`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: Devices are mounted on a special filesystem called `devfs`. All peripheral
    devices are here, such as the serial port, disks, and CPUs—except the network
    interface. Examples: `/dev/null`, `/dev/tty1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: Processes are mounted on a special filesystem called `procfs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys`: Hardware information on the `sysfs` filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: Consists of editable text configuration files required by all programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: Library for drivers and non-editable text configuration files. Library
    filenames are either `ld*` or `lib*.so.*`, for example, `libutil-2.27.so`, or
    `libthread_db-1.0.so`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib64`: Libraries for drivers, but no configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: Kernel and boot-loader. Examples: `initrd.img-2.6.32-24-generic`,
    `vmlinuz-2.6.32-24-generic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root`: User data for the `root` user. Only the `root` user has the right
    to write to this directory. `/root` is the `root` user''s home directory, which
    is not the same as `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: User data for unprivileged users. Similar to the `C:\Users\username`
    folder in Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media`: Removable media, such as CD-ROM and USB drives, are mounted here.
    At least read-only for every user. Examples include `/media/cdrom` for CD-ROM,
    `/media/floppy` for floppy drives, and `/media/cdrecorder` for CD writers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt`: Non-removable media, including remote storage. At least read-only for
    every user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/run`: Files specific for a user or process, for instance, USB drivers that
    should be available for a specific user, or runtime information for a daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt`: Optional software that is not a part of the distribution, such as third-party
    software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv`: Static server data. It can be used for static websites, file servers,
    and orchestration software such as Salt or Puppet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: Dynamic data. Ranges from print spoolers and logging to dynamic websites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: Temporary files, not persistent during reboots. Nowadays, it''s often
    a RAM filesystem (`tmpfs`) that is mounted on this directory. The directory itself
    is more or less deprecated and from an application perspective, replaced with
    a directory in `/var` or `/run`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: It contains all extra software-related binaries, documentation, and
    source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `tree` command again to show the directory structure in `/usr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Directory structure in the /usr directory](img/B15455_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Directory structure in the /usr directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The directory structure of `/usr` is very similar to the structure of `/`.
    A few extra directories were added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/usr/etc`: If you recompile software that is already a part of the distribution,
    the configuration files should be in `/usr/etc`, so they can''t conflict with
    files in `/etc`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/games`: Data for old games such as `fortune`, `figlet`, and `cowsay`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/include`: Development headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/libexec`: Wrapper scripts. Let''s say you need multiple versions of Java.
    They all need different libraries, environment variables, and so on. A wrapper
    script is there to call a specific version with the correct settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share`: Program data such as wallpaper, menu items, icons, and documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/src`: Linux kernel sources and sources from software that is included
    in the distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/local`: Software that you install and compile yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The directory structure of `/usr/local` is the same as `/usr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Directory structure in the /usr/local directory](img/B15455_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Directory structure of the /usr/local directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This directory is there for software development. There is no need to have this
    directory in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional software is placed in `/opt`. The main directory structure is `/opt/<vendor>/<software>/`,
    for example, `/opt/google/chrome`. A list of the possible vendor/provider names
    is maintained by the `/usr` and `/usr/local`, with one exception: you can choose
    between `/conf` and `/etc` in the software directory or in the `/etc/opt` directory.
    Non-native Linux software such as PowerShell can use its own structure within
    the software directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may be a good idea to define the root filesystem more precisely. The root
    filesystem is the filesystem where the root directory, `/`, is located. All other
    filesystems are mounted on directories created on this root filesystem. To find
    out what directories are local to the root filesystem and which ones are mount
    points, execute the `findmnt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using findmnt command to determine which directories are local to the root
    filesystem and which ones are mount points.](img/B15455_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Using the findmnt command to find mount points'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Adding the `-D` parameter will show you the size of the filesystem and the
    amount of space that is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the file size and available space by running the findmnt -D command.](img/B15455_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: Listing the file size and available space with the findmnt -D
    command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `findmnt` command is a great way to find out where a device is mounted,
    for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If a directory is not a mount point, use the `-T` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In *Chapter 5, Advanced Linux Administration*, the different filesystems, and
    how to mount and automatically mount local and remote filesystems, are covered
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Files on the Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Searching for files on the filesystem can be done with the `find` command. Unfortunately,
    if you are not already familiar with this command, the man page may be overwhelming
    and not very easy to read. However, if you understand the basics of this command,
    the man page will help you add parameters to search every property of a file or
    directory, or both.
  prefs: []
  type: TYPE_NORMAL
- en: The first possible parameters of the `find` command are options. These affect
    the behavior of the `find` command, that is, whether it should follow symbolic
    links and debug and speed optimization options. Options are optional—most of the
    time you don't need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the options, the next parameter tells the `find` command where to start
    the search process. It is not a very good idea to start at the root (`/`) directory;
    it takes too much time and can consume too much CPU activity on large filesystems.
    Remember the FHS—for instance, if you want to search configuration files, start
    searching in the `/etc` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will show you all the files in `/etc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the location, the next parameter is an expression containing one or more
    tests. To list the most common tests, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-type`, `f` for file, `d` for directory, `b` for block device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-name <pattern>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-user` and `-group`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-perm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-exec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can perform a combination of these tests. For instance, to search for files
    with filenames that end in `conf`, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For some tests, such as `size` and `atime`, it''s possible to add a so-called
    comparison with a provided parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+n`: Greater than `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: Less than `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: Exactly `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `find` command searches for files and directories and compares them to
    the value of `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example will search for directories with content that exceeds 100 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last parameter is the action that should be executed on the files that
    were found. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ls`, output is similar to the `ls` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-print` to print the filenames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-printf` to format the output of the `-print` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fprintf` to write the formatted output to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-printf` parameter can be extremely useful. For instance, this command
    will search for files and list their size in bytes and the filename. After that,
    you can use the `sort` command to sort files by size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some more dangerous actions as well, such as `-delete` to remove
    the files found and `-exec` to execute an external command. Be very sure of the
    result of your search action before using these parameters. Most of the time,
    performance-wise, you are better off using the `xargs` utility anyway. This utility
    takes the results and converts them into arguments to a command. An example of
    such a command is as follows; the `grep` utility is being used to search the content
    of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Process Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed the filesystem in Linux. From a system
    administrator's perspective, managing processes is crucial. There will be scenarios
    where you'll need to start, stop, or even kill processes. Also, to avoid throttling
    your machine, you need to be cautious about the processes running on the system.
    Let's take a closer look at process management in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Processes are run by the Linux kernel, started by a user, or created by other
    processes. All processes are child processes of process number one, which will
    be covered in the next chapter. In this section, we'll learn to identify processes
    and how to send a signal to a process.
  prefs: []
  type: TYPE_NORMAL
- en: View Processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you start a program, a `/proc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bash, you can find the PID of the current shell with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also find the PID of the parent shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the PID of a program on your filesystem, use the `pidof` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You might see multiple PIDs returned by the shell. If you want to return only
    one PID, use the `-s` parameter, which stands for single shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look in the `proc` directory of the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigating to the /proc directory and listing all of its contents using ls](img/B15455_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: proc directory of the current shell'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can see all the properties of this process. Let''s look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmdline`: The command that is executed to create this process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environ`: The environment variables that are available to this process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: The status of the file, the **UID** (**User Identifier**), and the
    **GID** (**Group Identifier**) of the user/group that owns the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you execute `cat environ`, the output is difficult to read because the end-of-line
    character is `\0` instead of `\n`. You can fix this using the `tr` command to
    translate the `\0` into `\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `proc` directory is very interesting for troubleshooting, but there are
    also many tools that use this information to produce more human-friendly output.
    One of these utilities is the `ps` command. There is something strange about this
    command; it supports three different types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ps -ef` is the same as `ps -e -f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps ax` is the same as `ps a x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU style**: Preceded by a double dash and a long-named option. Commands
    cannot be grouped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output formatting for the three styles is not the same, but you can modify
    the behavior with options. A comparison follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the ps command using its three different types of parameters.](img/B15455_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Using the ps utility with its parameters'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The processes between square brackets are kernel processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query for specific values, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Another utility that can help you search for a process is `pgrep`. It searches
    on values such as the name and user and shows the PID by default. The output can
    be formatted using parameters such as `-l` to list the process name, or `-o` to
    add the full command to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interactive way to monitor processes uses the `top` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring processes using the top command](img/B15455_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: Monitoring processes using the top command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The values in the columns for a process visible in `top` are the same as in
    `ps`. In the man page of `top`, you can find a good explanation of what they mean.
    Some of them will be covered in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `top` command, or the fancier `htop` command, can help you to quickly identify
    processes taking too much memory or CPU and send a signal to the process. If you
    want detailed and advanced process monitoring and troubleshooting, it's better
    to use the tooling available in Azure. This is covered in *Chapter 11, Troubleshooting
    and Monitoring Your Workloads*.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Signals to a Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the real world, you might encounter an issue where a particular process
    is consuming a lot of memory. At this point, you might want to send a kill signal
    to the process. Likewise, you may encounter different scenarios while dealing
    with processes. In this section, we will be exploring different signals that can
    be sent to the process. On the man page for signals, section 7, you can find more
    info about signals. A signal is a message to a process, for instance, to change
    the priority or to kill it. There are many different signals described in this
    manual, but only a few are really important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signal 1**: This hangs the process; it will reload everything that is attached
    to a process. Commonly used to reread a changed configuration file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal 2**: This is the same as *Ctrl* + *C* and *Ctrl* + *Break*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal 3**: Normal quitting of a process; the same as *Ctrl* + *D*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal 15**: Default signal, used to terminate a command, giving the terminal
    time to clean up everything nicely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal 9**: Kill a command without cleanup. This is dangerous and can make
    your system unstable and sometimes even vulnerable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to see the list of signals that can be sent to a process,
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a signal to a process, you can use the `top` (shortcut `k`) or `kill`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a nice utility you can use to grep a process or group of processes;
    it sends a signal at once: `pkill`. It''s similar to `pgrep`. Selection is possible
    on values such as `name` and `uid`.'
  prefs: []
  type: TYPE_NORMAL
- en: Discretionary Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have covered the filesystem and process management, there should
    be a way to restrict permissions to the files that you are creating. In other
    words, you shouldn't grant everyone access to everything and most organizations
    follow the principle of giving the most granular permissions. **Discretionary
    Access Control** (**DAC**) is a security implementation that restricts access
    to objects such as files and directories. A user or a group of users gets access
    based on ownership and the permissions on the objects.
  prefs: []
  type: TYPE_NORMAL
- en: In cloud environments, user and group management may not be a part of your daily
    job. It's often delegated to identity management systems such as **Active Directory**
    (**AD**), and you don't need many user accounts; authentication and authorization
    at an application level are more important nowadays. But it's still a good idea
    to be able to verify users and know how the underlying system works.
  prefs: []
  type: TYPE_NORMAL
- en: User Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you deploy a VM in Azure, in the wizard you''ll specify a user, which will
    be created by the Azure Agent user management in the VM—for instance, if you deploy
    a VM with PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a VM with PowerShell](img/B15455_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Deploying a VM with PowerShell'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use this account to log in. It's a normal user, also called an unprivileged
    user, which doesn't have administrative privileges. To gain administrative privileges,
    you need the `sudo` command; `sudo` means superuser do (or do as superuser). Without
    parameters, the `su` command switches your current user to another user, root—the
    administrator account in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want root privileges, in some Linux images in Azure you can't use the
    `su` command. It's disabled by default. To get a root shell, you can use `sudo
    -s`. By default, the `sudo` command will ask you for your password.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more information about this user account, use the `getent` command to
    get an entity from the `passwd` database, where the user information is stored.
    This `passwd` database can be local, stored in a `/etc/passwd` file, or can be
    remote, where a remote server will grant authorization by checking the user database,
    **Lightweight Directory Access Protocol** (**LDAP**) for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the details for the `linvirt` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using getent to get details of linvirt](img/B15455_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: Using getent to get details of linvirt'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The output of this command is a colon-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: User account name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**General Electric Comprehensive Operating System** (**GECOS**) field for extra
    account information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home directory for this user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the early days of the Unix operating system family, the password was stored
    in the `/etc/passwd` file, but for security reasons the hashed password was moved
    to `/etc/shadow`. The password can be changed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to change the password of the current user, you don''t need to
    use `sudo`, and don''t need to specify the username. You can view the entry in
    the `/etc/shadow` file with `getent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking password entry using getent command](img/B15455_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: Checking password entry using the getent command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The columns after the hashed password contain aging information that can be
    viewed (and changed) with the `chage` command. The notation in the shadow database
    is notated by the number of days since epoch (the virtual birthday of Unix: January
    1, 1970). The `chage` command translates it into a more human-readable form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using chage command to convert epoch to a human-readable date.](img/B15455_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Using the chage command to get aging information'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s go back to the `passwd` database. The numbering of the user ID is defined
    in the `/etc/login.defs` file. ID `0` is reserved for the root account. IDs `1`
    to `200` are reserved for `admin` accounts that are not in use any longer in modern
    Linux systems. In Red Hat–based distributions, the range 201–999 is reserved for
    system accounts, and daemons run under these accounts. The range for unprivileged
    accounts is between 1,000 and 60,000 for local users and >60,000 for remote users
    (for example, AD or LDAP users). There are small differences between Linux distributions.
    Let''s summarize the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A table showing the relation between user ID numbers and user types in Linux.](img/B15455_03_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: User IDs with their reserved user types'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Many distributions are configured with the so-called `/etc/login.defs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that if you create a user, a primary group is automatically created
    with the same name as the login. If you disable this functionality, a newly created
    user becomes a member of another group automatically, defined in `/etc/default/useradd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The GECOS field can be changed with the `chfn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing GECOS field with the chfn command](img/B15455_03_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: Changing GECOS field with the chfn command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `chfn` (change finger) command refers to an old utility, `finger`, which
    is not installed by default but is still available in repositories. A `finger`
    daemon that makes the GECOS information available via the network is available
    as well, but it's considered a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default shell while creating a user is defined in `/etc/default/useradd`.
    You can change the default shell to another using the `chsh` command. The shell
    must be listed in the `/etc/shells` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of this book, keep Bash as the default shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you learned how to verify and change the properties of an
    existing local user. Of course, you can add additional users as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useradd` command has a lot of customization options. You can learn more
    about this using `man useradd`. Alternatively, you can use the `adduser` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user with the adduser command](img/B15455_03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.33: Adding a user with the adduser command'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Group Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, a user will be part of a primary group.
    When you create a user, if you don't specify a group, a group will be created
    with the same name as the username. If you check the previous screenshot, you
    can see a group named `john` for the user `john`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being a member of a primary group, additional group memberships can
    be added. This is necessary to get access to a group directory/share or to delegate
    privileges in the `sudo` configuration. You can add existing additional groups
    with the `--groups` parameter of the `useradd` command during the creation of
    a user, or afterward with `usermod` or `groupmems`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new user and a new group and verify the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the `student` user a member of the `staff` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change your primary group temporarily with **switch group** (**sg**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It's not very common, but you can add a password to a group account using the
    `gpasswd` command. This way, a user that is not a member of this group can still
    use `sg` and enter the password for the group.
  prefs: []
  type: TYPE_NORMAL
- en: A very special group is the `wheel` group. In the `sudo` configuration, a user
    that is a member of this group is able to execute commands that need administrative
    privileges. In Ubuntu, this group is not available; instead, there is a group
    called `sudo` that can be used for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Login Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an enterprise environment, administrators are required to collect information
    such as the number of users logged in, the number of invalid logins, and whether
    any authorized users tried to log in for security auditing purposes. In this chapter,
    we'll cover login management in Linux, which is crucial from a security standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any login into a Linux system is registered, tracked, and managed by a service
    called `systemd-logind` and a corresponding command: `loginctl`. This command
    is available for all Linux distributions; however, if you are using **Windows
    Subsystem for Linux** (**WSL**), due to the lack of systemd, this will not be
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of this command are divided into sections for users, sessions,
    and seats. To do some exercises with these parameters, open a second `ssh` session
    to your VM using the credentials of the student account. Execute the commands
    in the first `ssh` session.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, list the sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note down the session ID(s) and the details of a particular session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, the session ID is `27`, so we will be checking the session details
    using `loginctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using loginctl to check session details for session ID 27](img/B15455_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.34: Checking the session details for session ID 27'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'View the user properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Switch to the second SSH session and execute `man man`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now switch login management back to the first SSH session and view the status
    of the student using the `user-status` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the user-status parameter to view the status of the student ](img/B15455_03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.35: Using the user-status parameter'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, terminate the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `terminate-user` parameter that can be handy if there are multiple
    users in one session.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter was a sort of crash course on how to survive in Linux if you are
    unfamiliar with the operating system. This chapter was not about how to become
    a senior Linux administrator.
  prefs: []
  type: TYPE_NORMAL
- en: In your daily life as an administrator in Azure, you may not use everything
    in this chapter. For instance, you might not create users in a VM. But you should
    be able to verify users configured in an identity management system such as AD
    and verify that they are able to log in.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was all about using shells, the structure of the filesystem, and
    finding files. We looked at the role of text files in Linux and how to process
    and edit them. We worked with processes and saw how to view and kill them. And,
    last but not least, we looked at user and group management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss managing resources in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, instead of answering some questions, I want you to do an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the users `Lisa`, `John`, `Karel`, and `Carola`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the passwords for these users to `welc0meITG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the existence of these users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `finance` and `staff` groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the users `Lisa` and `Carola` members of `finance`, and `Karel` and `John`
    members of `staff`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the /home/staff and /home/finance directories and set the group ownership
    of these directories to staff and home, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the staff group read access to the finance directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that newly created files receive the correct group ownership and permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many books that are published for users that are new to the Linux
    operating system. Here are a few of my personal favorites.
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Linux - Quick Hacks for the Command Line* (ISBN 978-1787129184)
    by Petru Işfan and Bogdan Vaida is a strange collection of nice tips and tricks,
    and sometimes that is all you need.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are able to read German, all the books by Michael Kofler ([https://kofler.info](https://kofler.info))
    should be on your bookshelf, even if you are an experienced Linux user!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Microsoft website hosts very good documentation on regular expressions:
    [https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions](https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions).
    And I do like [http://regexone.com](http://regexone.com) if you want to practice
    using regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `awk` utility comes with a big manual ([https://www.gnu.org/software/gawk/manual/gawk.html](https://www.gnu.org/software/gawk/manual/gawk.html)),
    but it's maybe not the best place to start. Shiwang Kalkhanda did a very good
    job in *Learning AWK Programming* (ISBN 978-1788391030), producing a very readable
    book. Don't be afraid of the word *Programming* in this title, especially if you
    are not a developer; you should read this book.
  prefs: []
  type: TYPE_NORMAL

- en: Creating a Highly Available Self-Healing Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through how the IT industry has evolved from using
    monolithic applications to cloud-native, containerized, and highly available microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: With open source, we can provide solutions that will enable us to create highly
    available and on-demand scales of our applications based on our user consumption.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Describing microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why containers are the home of microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can orchestrate our containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the most commonly-used orchestrator in Open Source, Kubernetes.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are used to design applications in a modular way, where each module
    is deployed independently, and they communicate with each other through APIs.
    All these modules work together to deliver a single application where each function
    has its own purpose.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's take a look at an online store. All we can see is the main
    website; however, on the backend there are several microservices that come into
    play, one service to take orders, another to suggest items for you based on your
    previous browsing, payment processing, review and comment handlers, and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an example of a microservice application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4ce4515-7320-4dd9-910d-043557a5767b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: By nature, microservice applications do not require a huge team to support the
    application as a whole. One single team supports only one or two modules in the
    big picture, creating a more granular approach in terms of support and expertise
    of each moving part of the final product. Support and development are not only
    granular, but there are also failures. In the case of a single microservice failure,
    only that portion of the application will fail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our online store example, let's say that the microservice that
    handles the reviews and comments fails. This is due to the fact that our website
    is constructed using microservices, so only that component of our site will be
    unavailable to our customers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: They will, however, still be able to continue purchasing and using the website
    with no issues, and while users will not be able to see the reviews for the products
    they are interested in, this does not mean that our entire website usability is
    compromised. Depending on what caused the issue, you can either patch the microservice
    or restart it. Bringing down the entire website for a patch or restart is no longer
    necessary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: As an infrastructure engineer you might think, why do I have to know what a
    microservice is or what its benefits are? Well, the reason is simple. As an architect
    or infrastructure engineer, you are building the underlying infrastructure for
    this type of application. Whether they are monolithic applications running on
    a single host or microservices spread out across multiple containers, it will
    certainly impact the way you design your customer's architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Linux will be your best friend here, as you will find multiple open source tools
    that will help you to maintain high availability, load balancing, and **continuous
    integration** (**CI**)/**continuous delivery** (**CD**) with tools such as Docker,
    Kubernetes, Jenkins, Salt, and Puppet.  So whenever a customer asks you for which
    OS environment he should start designing his microserviced applications, Linux
    will be your  answer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Docker Swarm and Kubernetes are leaders when it comes to container
    orchestration. When it comes to microservices, containers will be also your go-to
    when designing an infrastructure for a customer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We will be diving into Kubernetes in [Chapter 7](d89f650b-f4ea-4cda-9111-a6e6fa6c2256.xhtml), *Understanding
    the Core Components of a Kubernetes Cluster*, and showing how it will help you
    orchestrate and deliver an elegant but complex solution for hosting microservices
    and other types of applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: However, before talking about Kubernetes or container orchestration, we need
    to explain the concept of a container in order to understand why they are perfect
    for housing microservice apps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在谈论Kubernetes或容器编排之前，我们需要解释容器的概念，以便理解为什么它们非常适合托管微服务应用程序。
- en: Containers in Linux have been available for some time now, but it was not until
    a few years ago (with the release of the Docker Engine) that they gained momentum
    and admiration across all the tech communities. Containers came into play at the
    right time, and with the rise of microservices architecture they came to stay,
    and are shaping the way that we design and perform it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的容器已经有一段时间了，但直到几年前（随着Docker Engine的发布），它们才在所有技术社区中获得了动力和赞誉。容器在合适的时间出现了，并随着微服务架构的兴起而留了下来，并且正在塑造我们设计和执行它的方式。
- en: Let's take a step back so that you can understand the benefits of such technology.
    Imagine that you have a simple monolith application that is running an API from
    which you can consult a list of users and what they have bought from a website
    that you are hosting on the same application bundle.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，以便您了解这种技术的好处。想象一下，您有一个简单的单体应用程序，它正在运行一个API，您可以从中查询用户列表以及他们从您托管的网站购买的商品。
- en: After a while, your customer sees that their API is becoming really popular
    among other applications, who are now making thousands of HTTP `GET` requests
    during peak hours. The current infrastructure is not able to handle so many requests,
    so your customer asks you to scale their infrastructure in a way that can handle
    more requests. The problem here is that because this is a monolithic application,
    you will not only need to calculate the resources required for the API, but you
    will have to also take into account the web-store frontend that is hosted alongside
    the API—even though the API is the only thing that you actually need to scale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，您的客户发现他们的API在其他应用程序中变得非常受欢迎，这些应用程序现在在高峰时段进行数千次HTTP `GET`请求。当前的基础设施无法处理如此多的请求，因此您的客户要求您以一种可以处理更多请求的方式扩展他们的基础设施。问题在于，因为这是一个单体应用程序，您不仅需要计算API所需的资源，还需要考虑与API一起托管的网店前端，即使API是您实际上需要扩展的唯一内容。
- en: This will be a waste of resources as you are taking the web-store frontend as
    well, which does not require any additional replicas or resources. You are wasting
    precious, and sometimes expensive (if you are in the public cloud) storage, memory,
    and CPU resources on something that doesn't really require it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一种资源浪费，因为您还将包括不需要任何额外副本或资源的网店前端。您正在浪费宝贵的，有时是昂贵的（如果您在公共云中）存储、内存和CPU资源，用于一些实际上并不需要的东西。
- en: So, this is where microservices, and also containers for hosting such types
    of applications, come into play. With microservices in container images, you don't
    have to provision a new server every time you need to scale up your services due
    to demand, nor do you have to restart the server, or struggle with package dependencies
    every time you perform an update of the app or the OS. With a simple single command
    (`docker container run companyreg.io/storeapi:latest`), your application is up
    and ready to serve requests. Similarly, if your application fails, just restart
    your container or provision a new one, and you are ready to go. What if an update
    that was made to the microservice had a bug? Just go ahead and revert to the previous
    image version and you can be up and running again; there is no need to start uninstalling
    updated libraries or dealing with dependency issues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是微服务和为托管这种类型的应用程序而设计的容器发挥作用的地方。使用容器镜像中的微服务，您无需每次需要扩展服务以满足需求时都要提供新的服务器，也无需重新启动服务器，或者在执行应用程序或操作系统更新时每次都要处理软件包依赖关系。只需使用一个简单的命令（`docker
    container run companyreg.io/storeapi:latest`），您的应用程序就可以启动并准备好提供请求。同样，如果您的应用程序失败，只需重新启动容器或提供一个新的容器，您就可以继续进行。如果对微服务进行的更新存在错误，只需回滚到以前的镜像版本，您就可以重新启动；无需开始卸载更新的库或处理依赖关系问题。
- en: Containers also allow consistency across application deployments because, as
    you may know, there are multiple ways of installing a package. You can do so through
    a package manager such as `apt`, `yum`, and `apk`, or through `git`, `/curl/wget`,
    `pip`, and `juju`, and depending on how you install it, it will also define the
    way you maintain it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还允许应用程序部署的一致性，因为您可能知道，有多种安装软件包的方式。您可以通过`apt`、`yum`和`apk`等软件包管理器进行安装，也可以通过`git`、`/curl/wget`、`pip`和`juju`进行安装，取决于您的安装方式，也将定义您的维护方式。
- en: Imagine a production environment where the developers send their package to
    the **open profiling standard** (**OPS**) team for deployment, and every OPS engineer
    deploys the app in a different way! This will become unsupportable and very hard
    to track. A container image with your app on it will create consistency because,
    no matter where you deploy it as a container, it will have the same location for
    all the configuration files, binaries, libraries, and dependencies everywhere
    you deploy it. Everything will be isolated into a container running with its own
    **process namespace** (**PID namespace**), network namespace, and **mount namespace**
    (**MNT namespace**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，开发人员将其软件包发送给**开放性分析标准**（**OPS**）团队进行部署，每个OPS工程师以不同的方式部署应用程序！这将变得难以支持和跟踪。具有您的应用程序的容器镜像将创建一致性，因为无论您将其部署为容器的位置在哪里，它都将在所有部署的地方具有相同的位置，用于所有配置文件、二进制文件、库和依赖项。所有内容都将被隔离到一个具有自己的**进程命名空间**（**PID命名空间**）、网络命名空间和**挂载命名空间**（**MNT命名空间**）的容器中。
- en: The point of having an app architected in microservices is to provide isolation
    to each of the microservices in the app so that they can be easily managed and
    maintained—and a container achieves exactly that. You can even define how you
    want to start your application every time the container comes up—again, consistency
    plays a leading role here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序架构为微服务的目的是为了为应用程序中的每个微服务提供隔离，以便它们可以轻松管理和维护——容器正好实现了这一点。你甚至可以定义每次容器启动时如何启动应用程序——一致性在这里起着主导作用。
- en: Creating container images
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建容器镜像
- en: 'The way you build a container is through something called a **Dockerfile**.
    A Dockerfile is basically a set of instructions on how to build your container
    image; a typical Dockerfile is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器的方式是通过一个叫做**Dockerfile**的东西。Dockerfile基本上是一组关于如何构建容器镜像的指令；一个典型的Dockerfile如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it is a very readable set of instructions. Without even knowing
    what each instruction does, we can assume its function because it's very similar
    to English. This Dockerfile is just an example and by far the most efficient way
    to do it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一组非常易读的指令。即使不知道每个指令的作用，我们也可以假设它的功能，因为它非常类似于英语。这个Dockerfile只是一个例子，迄今为止是最有效的方法。
- en: An image is essentially like a template in the **virtual machine** (**VM**)
    world; it is a set of read-only layers that contain all the information that you
    need to deploy your containers—from a single image you can deploy multiple containers
    as they all work on their own writable layer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像本质上就像**虚拟机**（**VM**）世界中的模板；它是一组只读层，包含了部署容器所需的所有信息——从单个镜像中，你可以部署多个容器，因为它们都在自己的可写层上运行。
- en: 'For example, whenever you pull an image you will see the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每当你拉取一个镜像，你会看到以下输出：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each `Pull complete` instance that you see corresponds to a layer of the image.
    So, what are these layers and where do they come from?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的每个`Pull complete`实例对应着镜像的一个层。那么，这些层是什么，它们来自哪里呢？
- en: When we perform the build of the image, some of the instructions that we define
    in the Dockerfile will create a new layer. Each instruction in the file is executed
    in a read-write layer in a container that, at the end of the build, will be committed
    to the final layer stack that shapes the final image. One thing to note is that
    even if each instruction during the build is executed in a container, not all
    commands will create data that will make the image larger in terms of size and
    layers—some of them will only write to something called the **image manifest**,
    which is essentially a file that contains all the images' metadata.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建镜像时，我们在Dockerfile中定义的一些指令将创建一个新的层。文件中的每个指令都在容器中的读写层中执行，在构建结束时，将提交到最终层堆栈，形成最终镜像。需要注意的是，即使构建过程中的每个指令都在容器中执行，并非所有命令都会创建数据，使得镜像在大小和层面上变得更大——其中一些只会写入到所谓的**镜像清单**中，这本质上是一个包含所有镜像元数据的文件。
- en: Let's explore each command a little bit more.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨每个命令。
- en: FROM
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM
- en: The `FROM` instruction indicates what your initial image will be and, essentially,
    the grounds on which you will start building your own image.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令指示了你的初始镜像是什么，基本上是你将开始构建自己镜像的基础。'
- en: What you put here will depend on your needs, for instance, which image has the
    libraries preinstalled that my application needs, which image already has the
    compiler that I need to compile my application, or which image has the least impact
    on our final size. For example, your application is built on Python 2\. Instead
    of using CentOS or Ubuntu as the initial image and then installing Python manually,
    you can just use the `python:2.7` image, and it will already come with Python
    preinstalled for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里放置的内容将取决于你的需求，例如，哪个镜像预先安装了我应用程序需要的库，哪个镜像已经安装了我需要编译应用程序的编译器，或者哪个镜像对我们最终大小的影响最小。例如，你的应用程序是基于Python
    2构建的。你可以直接使用`python:2.7`镜像，而不是使用CentOS或Ubuntu作为初始镜像，然后手动安装Python，因为它已经预先安装了Python。
- en: Clearly, there are more things to consider here, but we will be going through
    them later in this chapter when we look at the best practices of image building.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这里还有更多需要考虑的事情，但我们将在本章后面讨论镜像构建的最佳实践时再详细介绍。
- en: 'Since this instruction takes another image and uses it as its basis, your final
    image will inherit the layers of your base; so, the total number of final layers
    will be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个指令会使用另一个镜像作为基础，你的最终镜像将继承基础镜像的层；因此，最终层的总数将如下所示：
- en: '*Final image layers = base image layers + the layers you create*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*最终镜像层 = 基础镜像层 + 你创建的层*'
- en: LABEL
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LABEL
- en: 'The `LABEL` instruction is very self-explanatory—it labels your images with
    key-value pairs as metadata that you will later be able to retrieve through the
    `docker inspect` command. You can use this to add data that you would like the
    user of your image to know. Usually, it is used to add the information about the
    author of the image, such as their email or company:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`指令非常直观——它使用键值对为你的镜像添加元数据标签，稍后可以通过`docker inspect`命令检索。你可以使用它来添加用户需要知道的数据。通常用于添加镜像作者的信息，比如他们的电子邮件或公司：'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because this instruction is just metadata, no extra layers will be added to
    your image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个指令只是元数据，不会为你的镜像添加额外的层。
- en: RUN
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUN
- en: With `RUN`, you will run the commands that you need to prepare your container
    to run your application; for example, to install packages, compile your code,
    and create users or directories. `RUN` has two ways of running commands.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RUN`，你将运行需要准备容器来运行你的应用程序的命令；例如，安装软件包、编译代码，创建用户或目录。`RUN`有两种运行命令的方式。
- en: 'The shell form is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: shell形式如下：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this form, all your commands will be run with the `/bin/sh -c` shell by
    default, although you can change the shell by using the `SHELL` instruction, as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，默认情况下所有命令都将使用`/bin/sh -c` shell运行，尽管你可以使用`SHELL`指令来更改shell，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `SHELL` keyword can only be run in the JSON array format, which leads us
    to the second form that you can use to run the `RUN` instruction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHELL`关键字只能以JSON数组格式运行，这导致我们可以使用第二种形式来运行`RUN`指令。'
- en: 'The exec form is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行形式如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main difference here, besides the formatting, is that in the exec form
    the shell is not invoked, so normal variable substitution will not happen—instead,
    you will have to invoke the shell as a command for the shell to be able to provide
    variable expansion:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别，除了格式之外，在执行形式中不会调用shell，因此不会发生正常的变量替换——相反，您必须调用shell作为shell的命令，以便shell能够提供变量扩展：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Due to the nature of the `RUN` keyword, each instance of it will be executed
    on a new layer and committed to the final image, therefore, every time you use
    `RUN` it will add a new layer to your image.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RUN`关键字的性质，每个实例都将在新层上执行并提交到最终图像，因此，每次使用`RUN`都会向图像添加一个新层。
- en: ENV
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV
- en: 'For `ENV`, there is not much to say—this instruction sets variables for the
    environment. They will be used during build time and will be available during
    container runtime. `ENV` does not generate extra layers to the container as it
    stores the environment variables on the image manifest as metadata:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ENV`，没有太多可说的——这个指令为环境设置变量。它们将在构建时使用，并在容器运行时可用。`ENV`不会为容器生成额外的层，因为它将环境变量存储在图像清单中作为元数据：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters for `ENV` are treated in `<key>` /`<value>` pairs, where the
    `<key>` parameter is the variable name and the `<value>` parameter is its contents
    or value. You can either declare them by using the `=` sign or without it. Quote
    marks and backslashes can be used to escape spaces in the value field.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`的参数以`<key>` /`<value>`对的形式处理，其中`<key>`参数是变量名，`<value>`参数是其内容或值。您可以使用`=`符号声明它们，也可以不使用。引号和反斜杠可用于转义值字段中的空格。'
- en: 'All the following variations are valid:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有变体都是有效的：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: COPY
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY
- en: With `COPY`, we can copy files or directories from our local host (where you
    are executing the Docker build) to our image. This is very useful as you are actually
    moving content to the image, so that you can copy your applications, files, or
    anything that you might need for your container to work. As we previously mentioned,
    any instructions that add actual data to the container will create a new layer,
    therefore, increasing the storage footprint of your final image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`COPY`，我们可以将文件或目录从本地主机（执行Docker构建的位置）复制到我们的图像中。这非常有用，因为您实际上正在将内容移动到图像中，以便您可以复制应用程序、文件或任何可能需要的内容以使容器工作。正如我们之前提到的，任何向容器添加实际数据的指令都将创建一个新层，因此会增加最终图像的存储占用。
- en: 'This instruction shares the same forms as `RUN`; you can either use JSON formatting
    or just space the `<src>` source separately from the `<dst>` destination:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令与`RUN`具有相同的形式；您可以使用JSON格式化，也可以将`<src>`源分开放置到`<dst>`目的地：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are several catches that we need to go through. First, if any of the filenames
    or directories has a space on its name, you have to use the JSON array format.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个陷阱我们需要经历。首先，如果任何文件名或目录名中有空格，您必须使用JSON数组格式。
- en: 'Second, by default, all files and directories will be copied with **user identifier**
    (**UID**) and **group identifier** (**GID**) `0` (root). To override this, you
    can use the `--chown=<UID>:<GID>` flag as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，默认情况下，所有文件和目录都将以**用户标识符**（**UID**）和**组标识符**（**GID**）`0`（root）复制。要覆盖此设置，可以使用`--chown=<UID>:<GID>`标志，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`chown` accepts either the numerical ID or the name of the user or group. If
    there is only one of them, then it is defined as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`chown`接受数字ID或用户或组的名称。如果只有其中一个，则定义如下：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`COPY` will assume that both the user and the group are the same.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`将假定用户和组都是相同的。'
- en: If you are copying similarly-named files, then you can always use wildcards—`COPY`
    will use the Go `filepath.Match` rule, which can be found at [http://golang.org/pkg/path/filepath#Match](http://golang.org/pkg/path/filepath#Match).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要复制名称相似的文件，则可以始终使用通配符——`COPY`将使用Go的`filepath.Match`规则，该规则可以在[http://golang.org/pkg/path/filepath#Match](http://golang.org/pkg/path/filepath#Match)找到。
- en: 'How you define the `<src>` and `<dst>` entries is very important because they
    follow these three rules:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`<src>`和`<dst>`条目的方式非常重要，因为它们遵循以下三条规则：
- en: The path that you define in `<src>` must be inside the context of the build,
    essentially, all files and directories that are located in the directory that
    you specified when running the Docker build `PATH` command.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<src>`中定义的路径必须在构建的上下文中，基本上，所有位于您运行Docker构建`PATH`命令时指定的目录中的文件和目录。
- en: If you are copying directories, then always end them with `/`. In this way,
    Docker knows that this is a directory and not a single file that you are copying.
    Additionally, if it's a directory, all of the files inside of it will be copied
    as well.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要复制目录，则始终以`/`结尾。这样，Docker就知道这是一个目录，而不是要复制的单个文件。此外，如果是目录，则其中的所有文件也将被复制。
- en: The path defined in `<dst>` will always have to be an absolute path, unless
    you specify a working directory to be relative to with the `WORKDIR` instruction.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<dst>`中定义的路径将始终是绝对路径，除非您使用`WORKDIR`指令指定相对于的工作目录。'
- en: Finishing with the `COPY` instruction, I must add that `COPY` only supports
    copying locally-located files. If you want to copy files from a remote server
    using URLs, you must use the `ADD` instruction, which follows the same rules that
    `COPY` does but with some other caveats for URLs. This is beyond the scope of
    this chapter, but you can learn more about it at [https://docs.docker.com](https://docs.docker.com).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要说的是`COPY`指令，我必须补充的是`COPY`只支持复制本地文件。如果要使用URL从远程服务器复制文件，必须使用`ADD`指令，它遵循与`COPY`相同的规则，但对于URL还有一些其他注意事项。这超出了本章的范围，但您可以在[https://docs.docker.com](https://docs.docker.com)了解更多信息。
- en: EXPOSE
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE
- en: With the `EXPOSE` keyword, we are not actually publishing the container port
    that we specify here; instead, we are creating a guideline for the container's
    user to know which ports to publish when they start the container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EXPOSE`关键字，我们实际上并没有发布我们在这里指定的容器端口；相反，我们正在为容器的用户创建一个指南，让他们知道在启动容器时应该发布哪些端口。
- en: Therefore, this is only metadata that is again created in the image's manifest,
    which can later be retrieved with `docker inspect`. No additional layers are created
    with this keyword.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这只是在图像的清单中再次创建的元数据，稍后可以使用`docker inspect`检索。不会使用此关键字创建其他图层。
- en: Ports defined in the `EXPOSE` instruction can be either **user datagram protocol**
    (**UDP**) or **transmission control protocol** (**TCP**), but, by default, TCP
    is assumed if no protocol is specified.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EXPOSE`指令中定义的端口可以是**用户数据报协议**（**UDP**）或**传输控制协议**（**TCP**），但是，默认情况下，如果未指定协议，则假定为TCP。
- en: 'Here are some examples of the `EXPOSE` instruction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`EXPOSE`指令的示例：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: CMD and ENTRYPOINT
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD和ENTRYPOINT
- en: These are probably the most important instructions in a Dockerfile, since they
    tell the container what to run when it's started. We will go through both of them
    and explore how they interact with one another and how they differ from one another.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是Dockerfile中最重要的指令，因为它们告诉容器在启动时要运行什么。我们将逐个讨论它们，并探讨它们如何相互作用以及它们之间的区别。
- en: Let's start with `ENTRYPOINT` first. This instruction, as we mentioned before,
    allows you to define the executable that you want to run when starting the container.
    You can add multiple `ENTRYPOINT` definitions in a Dockerfile, but only the last
    one will be executed on `docker container run`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从`ENTRYPOINT`开始。正如我们之前提到的，这个指令允许您定义启动容器时要运行的可执行文件。您可以在Dockerfile中添加多个`ENTRYPOINT`定义，但只有最后一个会在`docker
    container run`上执行。
- en: When you run a container with the `run` argument, you can usually add command-line
    arguments. These arguments will be appended to the `ENTRYPOINT` parameter unless
    you use the `--entrypoint` flag while using `docker container run` to overwrite
    the `ENTRYPOINT` executable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`run`参数运行容器时，通常可以添加命令行参数。除非您在使用`docker container run`时使用`--entrypoint`标志覆盖`ENTRYPOINT`可执行文件，否则这些参数将被追加到`ENTRYPOINT`参数。
- en: 'Let''s look at some examples. Let''s say that we are using a container with
    the following Dockerfile:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。假设我们正在使用一个具有以下Dockerfile的容器：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s assume that we built the image and tagged it `entrypointexample`.
    When we run this container without extra command-line arguments, it will appear
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们构建了图像并将其标记为`entrypointexample`。当我们在不带额外命令行参数的情况下运行此容器时，它将显示如下：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we add command-line arguments to the `run` command, we will see something
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`run`命令添加命令行参数，我们将看到类似这样的东西：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, it is not actually executing a BASH shell, but it''s taking
    `/bin/bash` as though it was a string for the `echo` command that we defined in
    our Dockerfile. Let''s consider a more explicit example as, with the previous
    one, I only wanted to demonstrate that even if you pass an actual command or try
    to execute a shell, it will still take it and pass it as arguments for `ENTRYPOINT`.
    Here is a more clear example with a simple string:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它实际上并没有执行BASH shell，而是将`/bin/bash`作为我们在Dockerfile中定义的`echo`命令的字符串。让我们考虑一个更明确的例子，因为前一个例子中，我只是想演示即使您传递了实际命令或尝试执行shell，它仍然会将其作为`ENTRYPOINT`的参数传递。这是一个更清晰的例子，带有一个简单的字符串：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, if we pass the `--entrypoint` flag, we will overwrite the `ENTRYPOINT`
    executable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们传递`--entrypoint`标志，我们将覆盖`ENTRYPOINT`可执行文件：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Okay, so why is the formatting of this command this way? As we saw earlier,
    the `--entrypoint` flag only replaces the executable—all additional parameters
    have to be passed as arguments. This is the reason why our `ls` has its `-lath
    /var` arguments at the very end. There are some additional things that we need
    to see here, and they correspond to the forms that the `ENTRYPOINT` instruction
    has.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么为什么这个命令的格式是这样的呢？正如我们之前看到的，`--entrypoint`标志只替换可执行文件——所有额外的参数都必须作为参数传递。这就是为什么我们的`ls`在最后有`-lath
    /var`参数的原因。这里还有一些其他需要注意的地方，它们对应于`ENTRYPOINT`指令的形式。
- en: 'As with the other Dockerfile instruction, `ENTRYPOINT` has two forms, shell
    and exec:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Dockerfile指令一样，`ENTRYPOINT`有两种形式，shell和exec：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the exec form, the same rules that apply to the previous Dockerfile instructions
    apply here as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于exec形式，适用于之前Dockerfile指令的相同规则也适用于这里。
- en: No shell is invoked in exec form, therefore, the `$PATH` variable is not present,
    and you will not be able to use the executables without providing their full path—this
    is why we used `/bin/ls` instead of just `ls`. Also, you can see that you first
    define the executable in the JSON array and then its parameters, this first field
    is what the `--entrypoint` flag will replace. Any additional parameters when using
    the flag will have to be passed to the `docker container run` command arguments
    as we did in our example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在exec形式中不会调用shell，因此`$PATH`变量不存在，您将无法在不提供完整路径的情况下使用可执行文件——这就是为什么我们使用`/bin/ls`而不是`ls`。此外，您可以看到您首先在JSON数组中定义可执行文件，然后是其参数，这个第一个字段是`--entrypoint`标志将替换的内容。在使用该标志时，任何额外的参数都必须作为`docker
    container run`命令参数传递，就像我们在示例中所做的那样。
- en: 'Shell form, on the other hand, will load `/bin/sh` so that environment variables
    are available. Let''s take a look at an example; here is a container with the
    following Dockerfile using the exec form:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，shell形式将加载`/bin/sh`，以便环境变量可用。让我们看一个例子；这是一个使用exec形式的Dockerfile的容器：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s assume that we built the image and tagged it `pathexampleexec`. When
    we run the container, we will see the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建了图像并将其标记为`pathexampleexec`。当我们运行容器时，我们将看到以下内容：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a container with the following Dockerfile using the shell form:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用shell形式的Dockerfile的容器：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we run the container, we will see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行容器时，我们将看到以下内容：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's say that you want to have some default arguments for your application,
    but you want your user to be able to overwrite and use different arguments if
    they require. This is where `CMD` comes in; with `CMD`, you can specify default
    parameters for your executable, but they will be overwritten if a user runs the
    container with command arguments on `docker container run`. You have to be careful
    of how you declare `ENTRYPOINT`, because if `ENTRYPOINT` is declared using the
    shell form, all `CMD` definitions will be ignored.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想为应用程序设置一些默认参数，但是您希望用户能够覆盖并使用不同的参数。这就是`CMD`的作用；使用`CMD`，您可以为可执行文件指定默认参数，但如果用户在`docker
    container run`上运行容器时使用命令参数，这些参数将被覆盖。您必须小心声明`ENTRYPOINT`，因为如果使用shell形式声明`ENTRYPOINT`，所有`CMD`定义将被忽略。
- en: 'Let''s take a look at a couple of examples; the following is a Dockerfile of
    the container to run:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子；以下是要运行的容器的Dockerfile：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the running of the previously mentioned container, assuming that it
    was built and tagged as `cmdexample`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设先前提到的容器已构建并标记为`cmdexample`，下面是其运行情况：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we use the exec form for `ENTRYPOINT`, the CMD parameters will be appended
    to the `ENTRYPOINT`. Dockerfile for reference:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们对`ENTRYPOINT`使用执行形式，CMD参数将被附加到`ENTRYPOINT`。参考Dockerfile：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the output, assuming that the image was built and tagged as `execcmdexample`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设镜像已构建并标记为`execcmdexample`，以下是输出：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that this time the `CMD` entries were appended to `ENTRYPOINT` as arguments.
    However, remember that the contents of `CMD` are just defaults; if we specify
    the arguments on `docker container run`, these will overwrite those in `CMD`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次`CMD`条目被附加到`ENTRYPOINT`作为参数。但是，请记住，`CMD`的内容只是默认值；如果我们在`docker container
    run`上指定参数，这些参数将覆盖`CMD`中的参数。
- en: 'Using the same Dockerfile as the preceding example, we will something similar
    to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与前面示例相同的Dockerfile，我们将得到类似以下的内容：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are several combinations between `CMD` and `ENTRYPOINT`, and you can
    see all of them in the following chart taken from [https://docs.docker.com](https://docs.docker.com):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`和`ENTRYPOINT`之间有几种组合，您可以在以下来自[https://docs.docker.com](https://docs.docker.com)的图表中看到所有这些组合：'
- en: '![](img/78bc3880-5c3b-4744-90a5-727d6a982c94.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78bc3880-5c3b-4744-90a5-727d6a982c94.png)'
- en: Building container images using best practices
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最佳实践构建容器镜像
- en: Dockerfiles are like recipes for your applications, but you can't just throw
    in the ingredients and hope for the best. Creating an efficient image requires
    you to be careful about how you utilize the tools at your disposal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfiles are like recipes for your applications, but you can't just throw
    in the ingredients and hope for the best. Creating an efficient image requires
    you to be careful about how you utilize the tools at your disposal.
- en: The whole point of containers is to have a small footprint—having a 1 GB+ image
    for a 100 MB application is not indicative of a small footprint, nor is it efficient
    at all. Microservices are all about this as well; having small container images
    for your microservices not only improves performance, but storage utilization
    decreases security vulnerabilities and points of failure, and it also saves you
    money.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的整个目的是占用空间小 - 对于100 MB应用程序来说，拥有1 GB以上的镜像并不代表占用空间小，也不高效。微服务也是如此；为微服务拥有小的容器镜像不仅提高了性能，而且存储利用率降低了安全漏洞和故障点，并且还能节省金钱。
- en: Container images are stored locally in your host and remotely in a container
    registry. Public cloud providers charge you for the storage utilization of your
    registry and not by the image quantity that you have stored there. Think of a
    registry as the GitHub of containers. Let's say that you have to pull an image
    from your cloud provider's registry; which image do you think it will be faster
    to pull? A 1 GB image or a 100 MB image? The image size is essential.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像在主机本地和容器注册表中存储。公共云提供商根据注册表的存储利用率收取费用，而不是根据您在其中存储的镜像数量收费。想象一下注册表就像容器的GitHub。假设您必须从云提供商的注册表中拉取镜像；您认为拉取1
    GB镜像还是100 MB镜像会更快？镜像大小很重要。
- en: 'The first thing to consider when building an image is the base image that you
    are going to use. Instead of using large images (such as full Linux distributions,
    Ubuntu, Debian, or CentOS) that have a lot of tools and executables that you will
    not need for your application to run, use smaller ones such as Alpine:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像时要考虑的第一件事是要使用的基础镜像。不要使用大型镜像（如完整的Linux发行版，Ubuntu，Debian或CentOS），因为这些镜像有很多工具和可执行文件，您的应用程序不需要运行，而是使用较小的镜像，例如Alpine：
- en: '| **REPOSITORY ** | **SIZE** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **REPOSITORY ** | **SIZE** |'
- en: '| `centos` | 200 MB |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `centos` | 200 MB |'
- en: '| `ubuntu` | 83.5 MB |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ubuntu` | 83.5 MB |'
- en: '| `debian` | 101 MB |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `debian` | 101 MB |'
- en: '| `alpine ` | 4.41 MB |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `alpine ` | 4.41 MB |'
- en: 'You will find that most of the images have a slimmer version of themselves,
    for example, `httpd` and `nginx`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现大多数镜像都有自己的精简版本，例如`httpd`和`nginx`：
- en: '| **REPOSITORY** | **TAG** | **SIZE** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **REPOSITORY** | **TAG** | **SIZE** |'
- en: '| `httpd` | `alpine` | 91.4 MB |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `httpd` | `alpine` | 91.4 MB |'
- en: '| `httpd` | `latest` | 178 MB |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `httpd` | `latest` | 178 MB |'
- en: '| `nginx` | `alpine` | 18.6 MB |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `nginx` | `alpine` | 18.6 MB |'
- en: '| `nginx` | `latest` | 109 MB |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `nginx` | `latest` | 109 MB |'
- en: As you can see, `httpd`:`alpine` is almost 50% smaller than `httpd`:`latest`,
    while `nginx`:`alpine` is 80% smaller!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`httpd`:`alpine`几乎比`httpd`:`latest`小了50%，而`nginx`:`alpine`小了80%！
- en: Smaller images will not only reduce your storage consumption, but they will
    also reduce your attack surface. This is because a smaller container has a lower
    attack surface; let's take a look at the latest Ubuntu image versus the latest
    Alpine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更小的镜像不仅会减少存储消耗，还会减少攻击面。这是因为较小的容器具有较小的攻击面；让我们看看最新的Ubuntu镜像与最新的Alpine镜像。
- en: 'For Ubuntu, we can see an increased count for vulnerabilities as per the Docker
    Hub page for the latest tag; this is captured in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu，我们可以看到最新标签的漏洞数量增加了；以下是Docker Hub页面的截图：
- en: '![](img/b425f5cd-5234-44ea-9d34-9838f950efa0.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b425f5cd-5234-44ea-9d34-9838f950efa0.png)'
- en: 'For Alpine Linux, the count goes down to zero, as demonstrated in the following
    screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Alpine Linux，计数降至零，如下截图所示：
- en: '![](img/b3203d39-5afb-4e50-907f-5fda932e443a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3203d39-5afb-4e50-907f-5fda932e443a.png)'
- en: In the preceding screenshot, we can see the vulnerability count when compared
    to Ubuntu. Even today, the latest Alpine image has no vulnerabilities whatsoever.
    In comparison, Ubuntu has seven vulnerable components that are not even needed
    for our application to run.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到与Ubuntu相比的漏洞计数。即使在今天，最新的Alpine图像也没有任何漏洞。相比之下，Ubuntu有七个不需要的组件存在漏洞，这些组件甚至不需要我们的应用程序运行。
- en: Another thing to take into account is the layering of your image; each time
    you run a `RUN` statement in the build it will add one more layer and size to
    your final image. Reducing the number of `RUN` statements and what you run on
    them will dramatically decrease your image size.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要考虑的事情是图像的分层；每次在构建中运行`RUN`语句时，它都会添加一个更多的层和大小到最终图像中。减少`RUN`语句的数量以及在其中运行的内容将大大减少图像的大小。
- en: 'Let''s take our first Dockerfile, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个Dockerfile，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can modify the `RUN` instruction into the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`RUN`指令修改为以下方式：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now instead of creating three layers, we will be producing only one, by running
    all our commands in a single statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将不再创建三个层，而是通过在单个语句中运行所有命令来产生一个层。
- en: Remember that everything you do in `RUN` is executed with `/bin/sh -c` or any
    other shell that you specified with `SHELL`, so `&`, `;`, and `\` are accepted
    as they would be in a regular shell.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在`RUN`中执行的所有操作都是使用`/bin/sh -c`或您在`SHELL`中指定的任何其他shell来执行的，因此`&`、`;`和`\`都会被接受，就像在常规shell中一样。
- en: 'However, we didn''t only remove the extra `RUN` instructions; we also added
    `apt clean` to clean the cache of our container before it commits, and used the
    `--no-install-recommend` flag to avoid installing any unnecessary packages, thus
    reducing both storage space and the attack surface:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不仅删除了额外的`RUN`指令；我们还添加了`apt clean`来清理容器的缓存，然后使用了`--no-install-recommend`标志来避免安装任何不必要的软件包，从而减少了存储空间和攻击面：
- en: 'Here are the details of the original image:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是原始图像的详细信息：
- en: '| **REPOSITORY ** | **SIZE** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | **大小** |'
- en: '| `bigimage` | 221 MB |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `bigimage` | 221 MB |'
- en: 'Here are the details of the smaller image:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是较小图像的详细信息：
- en: '| **REPOSITORY ** | **SIZE** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | **大小** |'
- en: '| `smallerimage` | 214 MB |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `smallerimage` | 214 MB |'
- en: Of course, this is not a huge difference, but this is only an example and no
    real application was being installed. In a production image, you will have to
    do more than just install `apache2`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个巨大的差异，但这只是一个例子，没有安装任何真正的应用程序。在生产图像中，您将不得不做的不仅仅是安装`apache2`。
- en: 'Now let''s use both of the techniques that we have learned and slim our image
    down:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们学到的两种技术，来精简我们的图像：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the final size of the image:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是图像的最终大小：
- en: '| **REPOSITORY ** | **SIZE** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **仓库** | **大小** |'
- en: '| `finalimage` | 5.79 MB |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `finalimage` | 5.79 MB |'
- en: Now, you can see there is a great difference in sizes—we passed from 221 MB
    to 217 MB, and finally ended up with a 5.79-MB image! Both images did the exact
    same thing, which was to serve a web page, but with an entirely different footprint.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到大小上有很大的差异——我们从221 MB减少到217 MB，最终得到了一个5.79 MB的图像！这两个图像都完成了完全相同的任务，即提供网页服务，但占用的空间完全不同。
- en: Container orchestration
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排
- en: 'Now that we know how to create our images, we need a way to maintain the desired
    state of our applications. Here''s where container orchestrators come in. Container
    orchestrators answer questions such as the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建我们的图像，我们需要一种方法来维护我们应用程序的期望状态。这就是容器编排器的作用。容器编排器回答了以下问题：
- en: How do I maintain my applications so that they are highly available?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何维护我的应用程序，使其具有高可用性？
- en: How do I scale each microservice on demand?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据需求扩展每个微服务？
- en: How do I load balance my application across multiple hosts?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在多个主机之间负载均衡我的应用程序？
- en: How do I limit my application's resource consumption on my hosts?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何限制我的应用程序在主机上的资源消耗？
- en: How do I easily deploy multiple services?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何轻松部署多个服务？
- en: With container orchestrators, administrating your containers has never been
    as easy or efficient as it is now. There are several orchestrators available,
    but the most widely used are Docker Swarm and Kubernetes. We will discuss Kubernetes
    later on in this chapter and take a more in-depth look at it in the [Chapter 7](d89f650b-f4ea-4cda-9111-a6e6fa6c2256.xhtml),
    *Understanding the Core Components of a Kubernetes Cluster*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器编排器，管理您的容器从未像现在这样简单或高效。有几种编排器可用，但最常用的是Docker Swarm和Kubernetes。我们将在本章后面讨论Kubernetes，并深入了解[第7章](d89f650b-f4ea-4cda-9111-a6e6fa6c2256.xhtml)中的核心组件。
- en: What all orchestrators have in common is that their basic architecture is a
    cluster that is composed of some master nodes watching for your desired state,
    which will be saved in a database. Masters will then start or stop your containers
    depending on the state of the worker nodes that are in charge of the container
    workloads. Each master node will also be in charge of dictating which container
    has to run on which node, based on your predefined requirements, and to scale
    or restart any failed instances.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编排器共同之处在于它们的基本架构是一个由一些主节点组成的集群，这些主节点监视您的期望状态，并将其保存在数据库中。主节点将根据工作节点的状态启动或停止容器，工作节点负责容器工作负载。每个主节点还负责根据您预定义的要求来指示哪个容器必须在哪个节点上运行，并根据需要扩展或重新启动任何失败的实例。
- en: However, orchestrators not only provide high availability by restarting and
    bringing up containers on demand, both Kubernetes and Docker Swarm also have mechanisms
    to control traffic to the backend containers, in order to provide load balancing
    for incoming requests to your application services.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编排器不仅通过重新启动和按需启动容器来提供高可用性，Kubernetes和Docker Swarm还具有控制流量到后端容器的机制，以便为应用程序服务的传入请求提供负载均衡。
- en: 'The following diagram demonstrates the traffic going to an orchestrated cluster:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5135807-8184-484f-b09d-84618971f17e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Let's explore Kubernetes a little bit more.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is by far the most popular container orchestrator out there. Many
    public cloud providers are now adopting it as the de facto container orchestrator;
    for instance, Azure with its **Azure Kubernetes Services** (**AKS**), Amazon Web
    Services with **elastic container service for Kubernetes** (**EKS**), and Google
    Cloud with **Google Kubernetes Engine** (**GKE**). Most of these solutions are
    managed, abstracting the management plane for the user for ease of use, and adopting
    cloud-native solutions such as integration with public cloud load balancers and
    DNS services.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes sits in the middle of a **platform as a service** (**PaaS**) solution
    and an **infrastructure as a service** (**IaaS**) solution because it provides
    you with a platform to run your containers and manage your data, but it still
    lets you provision software-defined infrastructures such as load balancers, network
    management, ingress controls, and resource allocation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: With Kubernetes, we can automate the process of deploying our containers and
    maintaining our desired state while controlling the resource consumption of our
    applications and providing high availability and isolation across our different
    applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has the basic orchestrator components that we mentioned before; it
    has worker nodes, master nodes, and a database that saves the status of our cluster.
    We will start exploring Kubernetes concepts in depth in [Chapter 7](d89f650b-f4ea-4cda-9111-a6e6fa6c2256.xhtml), *Understanding
    the Core Components of a Kubernetes Cluster*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the basic architecture of Kubernetes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbdec0c7-d304-4b05-8631-31fa286aa2f1.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how IT is evolving from a monolithic design to
    microservices, and how containers are helping us achieve this type of architecture
    by allowing a modularized infrastructure. We used the example of an online store
    to demonstrate how microservices allow for the scalability of specific components
    without the need to bring down the entire application. Additionally, we explored
    how the same example has a highly available design by discussing how the microservices
    approach allows for just a portion of the application to fail without impacting
    the entire solution (that is, how only the reviews part failed without bringing
    down the entire online store).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Later, we learned how containers are created from images through the use of
    a Dockerfile, which uses a readable set of instructions to create the base image.
    An image can be seen as the counterpart of a template in the context of VMs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: From this Dockerfile, we learned that a `FROM` statement indicates what will
    be the initial image, how the `LABEL` instruction adds metadata to the container,
    how `RUN` executes the commands that you need to prepare your container to run
    your application, and how `ENV` sets variables for the environment used for container
    building.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we discussed some of the best practices when building container
    images, such as the use of smaller images (such as Alpine), and how choosing a
    smaller image helps to reduce the number of vulnerabilities present in the built
    containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we quickly glanced over some of the more popular orchestration tools
    that are available, these being Docker Swarm and Kubernetes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will jump into exploring the core components of a Kubernetes
    cluster.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the components of Kubernetes?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between GKE, EKS, and AKS?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How secure are containers from exploits?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How easy is to deploy an application in a container?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are Docker containers and Kubernetes exclusive to Linux?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes* by Gigi Sayfan: [https://www.packtpub.com/virtualization-and-cloud/mastering-kubernetes](https://www.packtpub.com/virtualization-and-cloud/mastering-kubernetes)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gigi Sayfan的《精通Kubernetes》：[https://www.packtpub.com/virtualization-and-cloud/mastering-kubernetes](https://www.packtpub.com/virtualization-and-cloud/mastering-kubernetes)
- en: '*Kubernetes for Developers* by Joseph Heck: [https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joseph Heck的《面向开发人员的Kubernetes》：[https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)
- en: '*Hands-On Microservices with Kubernetes* by Gigi Sayfan: [https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes](https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gigi Sayfan的《使用Kubernetes进行微服务实践》：[https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes](https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes)
- en: '*Getting Started with Kubernetes – Third Edition* by Jonathan Baier, Jesse
    White: [https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jonathan Baier，Jesse White的《Kubernetes入门-第三版》：[https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)
- en: '*Mastering Docker - Second Edition* by Russ McKendrick, Scott Gallagher: [https://www.packtpub.com/virtualization-and-cloud/mastering-docker-second-edition](https://www.packtpub.com/virtualization-and-cloud/mastering-docker-second-edition)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Russ McKendrick，Scott Gallagher的《精通Docker-第二版》：[https://www.packtpub.com/virtualization-and-cloud/mastering-docker-second-edition](https://www.packtpub.com/virtualization-and-cloud/mastering-docker-second-edition)
- en: '*Docker Bootcamp* by Russ McKendrick et al: [https://www.packtpub.com/virtualization-and-cloud/docker-bootcamp](https://www.packtpub.com/virtualization-and-cloud/docker-bootcamp)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Russ McKendrick等人的《Docker Bootcamp》：[https://www.packtpub.com/virtualization-and-cloud/docker-bootcamp](https://www.packtpub.com/virtualization-and-cloud/docker-bootcamp)
- en: Bibliography/sources
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献/来源
- en: 'What are microservices?: [http://microservices.io/](http://microservices.io/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？：[http://microservices.io/](http://microservices.io/)
- en: 'Docker Hub: [https://hub.docker.com/](https://hub.docker.com/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub：[https://hub.docker.com/](https://hub.docker.com/)
- en: 'Production-Grade Container Orchestration: [http://kubernetes.io/](http://kubernetes.io/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产级容器编排：[http://kubernetes.io/](http://kubernetes.io/)

- en: Deploying and Configuring Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和配置Kubernetes
- en: 'After learning about Kubernetes internal components and how they interact with
    each other, it''s time to learn how to set them up. Installing a Kubernetes cluster
    manually can be a very painful and delicate process, but by going through the
    required steps, we can learn and understand better its internal components. After
    performing a manual install, we can also explore what other alternatives and tools
    we have available to automate this process. The following is a summary of what
    we will learn in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Kubernetes内部组件及其相互作用方式之后，现在是时候学习如何设置它们了。手动安装Kubernetes集群可能是一个非常痛苦和微妙的过程，但通过完成所需的步骤，我们可以更好地学习和理解其内部组件。在执行手动安装后，我们还可以探索其他可用于自动化此过程的替代方案和工具。以下是本章将学习的内容的摘要：
- en: Creating our compute environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的计算环境
- en: Bootstrapping the control plane
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导控制平面
- en: Bootstrapping worker nodes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导工作节点
- en: Configuring cluster networking and DNS settings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置集群网络和DNS设置
- en: Examples of managed Kubernetes services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管Kubernetes服务的示例
- en: With each step, we will be closer to completing a full install of Kubernetes,
    and ready to test it in a development environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过每一步，我们将更接近完成Kubernetes的完整安装，并准备在开发环境中进行测试。
- en: Infrastructure deployment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施部署
- en: To deploy the infrastructure that will be running our Kubernetes cluster, we
    will be using Microsoft Azure. You can follow along by creating a free trial or
    using any other public cloud provider, or your own on-premise IT infrastructure.
    The steps will differ depending on what you choose, though.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署将运行我们的Kubernetes集群的基础设施，我们将使用Microsoft Azure。您可以通过创建免费试用或使用任何其他公共云提供商，或者您自己的本地IT基础设施来跟随。具体步骤将取决于您的选择。
- en: Installing Azure CLI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Azure CLI
- en: 'There are two ways of deploying resources in Azure when you are using Linux:
    you can do it either from the portal or via the Azure CLI. We will be using both,
    but for different scenarios.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Linux时，在Azure中部署资源有两种方式：您可以从门户或通过Azure CLI进行。我们将两者都使用，但用于不同的场景。
- en: Let’s begin installing Azure CLI on our Linux workstation or on the Windows
    subsystem for Linux.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的Linux工作站或Windows子系统上安装Azure CLI。
- en: Note that all commands are assumed to be issued by an account with root privileges
    or the root account itself (but this is not recommended).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有命令都假定由具有root权限的帐户或root帐户本身发出（但这并不推荐）。
- en: 'For RHEL/Centos-based distributions, you need to perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于RHEL/Centos的发行版，您需要执行以下步骤：
- en: 'Download and `import` the repository key, as shown in the following command:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并`import`存储库密钥，如下命令所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '2\. Create the repository config file, as shown in the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建存储库配置文件，如下命令所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '3\. Install `azure-cli` using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 使用以下命令安装`azure-cli`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '4\. Log in to your Azure subscription using the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 使用以下命令登录到您的Azure订阅：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are not in a Desktop environment, you can use: az login --use-device-code, 
    because  the regular "az login" requires  a web browser to perform the login.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不在桌面环境中，您可以使用：az login --use-device-code，因为常规的“az login”需要通过Web浏览器执行登录。
- en: After installing Azure CLI, we still need to set up some defaults so we won't
    have to type the same flag options over and over again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Azure CLI后，我们仍然需要设置一些默认值，这样我们就不必一遍又一遍地输入相同的标志选项。
- en: Configuring Azure CLI
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Azure CLI
- en: 'Every resource on Azure lives in a resource group and a geographical location.
    Because all our resources will be living in the same resource group and location,
    let''s configure them as defaults. To do this, run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Azure上的每个资源都位于资源组和地理位置中。因为我们所有的资源都将位于同一个资源组和位置中，让我们将它们配置为默认值。要做到这一点，请运行以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For our example, we are using `east us` for the location, as this is the location
    closest to where we are based. The group name will depend on how you are going
    to name your resource group—in our case, `Kube_Deploy`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用“东部”作为位置，因为这是离我们最近的位置。组名将取决于您将如何命名您的资源组-在我们的情况下，是`Kube_Deploy`。
- en: 'With the defaults configured, let''s move on to actually create the resource
    group that will contain our resources, using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了默认值后，让我们继续实际创建包含我们资源的资源组，使用以下命令：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: High-level design overview
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设计概述
- en: 'With our resource group created and our location selected, let''s take a high-level
    look at the design that we are going to create using the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的资源组并选择了我们的位置后，让我们通过以下代码高层次地查看我们将要创建的设计：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The important things that we need to note right now are the number of VMs, the
    network architecture, and firewall rules, because these are the elements that
    we will be configuring directly in our first steps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要注意的重要事项是VM的数量、网络架构和防火墙规则，因为这些是我们将直接在我们的第一步中配置的元素。
- en: Let's take a look at our network requirements before we start provisioning our
    resources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置资源之前，让我们先看一下我们的网络需求。
- en: 'We have the following requirements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下要求：
- en: 'The following three sets of different, non-overlapping subnets:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下三组不同的、不重叠的子网：
- en: VM subnet
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VM子网
- en: Pod subnet
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod子网
- en: Service subnet
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务子网
- en: 'Statically allocated IP addresses for the following resources:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下资源的静态分配的IP地址：
- en: Master nodes
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点
- en: Worker nodes
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作节点
- en: Management VM
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理VM
- en: Public IP for the load-balancer
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器的公共IP
- en: DNS server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS服务器
- en: 'For our VM subnet, we are going to use the following address space:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的VM子网，我们将使用以下地址空间：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The service CIDR will be the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务CIDR将如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And finally, our POD CIDR will be a little bit bigger so that it can allocate
    more pods, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的POD CIDR将会更大一些，以便它可以分配更多的POD，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's start provisioning the network resources that we need to make this
    architecture possible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始配置我们需要使这种架构成为可能的网络资源。
- en: Provisioning network resources
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置网络资源
- en: 'First, we will create the virtual network that will contain our VM subnet.
    To do this, run the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建包含VM子网的虚拟网络。要做到这一点，运行以下命令：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The two key points in this command are the `address-prefix`flag and the `subnet-prefix` flag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令中的两个关键点是`address-prefix`标志和`subnet-prefix`标志。
- en: With the `address-prefix`flag, we will be specifying the address space that
    will define which subnets we can put on the VNET. For example, our VNET prefix
    is `192.16.0.0/16`. This means that we cannot put any address outside this CIDR;
    for example, `10.0.0.0/24` won’t work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`address-prefix`标志，我们将指定定义VNET上可以放置哪些子网的地址空间。例如，我们的VNET前缀是`192.16.0.0/16`。这意味着我们不能在这个CIDR之外放置任何地址；例如，`10.0.0.0/24`是行不通的。
- en: The subnet prefix will be the address space that will be provided to the VMs
    connected to our subnet. Now that we have created our VNET and the subnet, we
    require a static public IP address. In Azure and in any public cloud provider,
    public IPs are resources that are separate from the VM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 子网前缀将是分配给连接到我们子网的VM的地址空间。现在我们已经创建了我们的VNET和子网，我们需要一个静态的公共IP地址。在Azure和任何公共云提供商中，公共IP是与VM分开的资源。
- en: 'Let''s create our public IPs by running the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来创建我们的公共IP：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once created, we can take note of the IP by running the following query:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，可以通过运行以下查询来记录IP：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With our VNET, subnet, and public IP all allocated, we just need one final
    resource, a firewall, to provide security for our VMS. In Azure, firewalls are
    called **network security groups** (**NSGs**). The process of creating an NSG
    is fairly simple, as shown in the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的VNET、子网和公共IP分配完毕，我们只需要最后一个资源，一个防火墙，为我们的VMS提供安全保障。在Azure中，防火墙称为**网络安全组**（**NSG**）。创建NSG的过程非常简单，如下命令所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After creating the NSG, we assign the NSG to our subnet using the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建NSG后，我们使用以下命令将NSG分配给我们的子网：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Provisioning compute resources
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置计算资源
- en: With our network all set up, we are ready to start creating some VMs. But before
    we create any VM, we need to create the SSH keys that we will use to access our
    VMs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设置完成后，我们准备开始创建一些VM。但在创建任何VM之前，我们需要创建用于访问我们的VM的SSH密钥。
- en: The first pair of keys that we will create is for our management VM. This VM
    will be the only one that will have SSH access from the outside world. We do not
    want to expose port `22` of any of our cluster nodes for security reasons. Any
    time when we want to access any of our nodes, we will be doing it from this VM.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一对密钥是用于我们的管理VM。这个VM将是唯一一个可以从外部世界访问SSH的VM。出于安全原因，我们不希望暴露任何集群节点的`22`端口。每当我们想要访问我们的任何节点时，我们都将从这个VM中进行访问。
- en: 'To create the SSH keys, run `ssh-keygen` on your Linux workstation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建SSH密钥，请在您的Linux工作站上运行`ssh-keygen`：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s create the management VM using the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令创建管理VM：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember to replace the `<USERNAME>` field with the desired username.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用所需的用户名替换`<USERNAME>`字段。
- en: 'The next step is where we need to configure our first NSG rule. This rule will
    allow traffic from our own network to our management VM on port `22` so that we
    can SSH into it. Let''s set this up using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是我们需要配置第一个NSG规则的地方。这个规则将允许来自我们自己网络的流量进入我们的管理VM的`22`端口，这样我们就可以通过SSH连接到它。让我们使用以下命令设置这个规则：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `source-address-prefixes` is your ISP provided public IP address, as this
    IPs can be dynamic, in the even that it changes, you can edit the IP on the Network
    Security Group rules in your Azure Portal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`source-address-prefixes`是您的ISP提供的公共IP地址，因为这些IP可能是动态的，如果发生变化，您可以在Azure门户中的网络安全组规则中编辑IP。'
- en: 'Now let''s connect to our VM to create SSH keys that will allow us to connect
    to our cluster VMs. To retrieve the public IP address of our management `vm`,
    run the following query:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们连接到我们的VM，创建SSH密钥，以便我们可以连接到我们的集群VM。要检索我们管理VM的公共IP地址，运行以下查询：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s SSH into our VM using our previously created private key, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用之前创建的私钥SSH进入我们的VM，如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will only need to specify the private key if you are logged in with a different
    user than the one with which you created the key pair.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您使用与创建密钥对的用户不同的用户登录时，才需要指定私钥。
- en: Now that we are in the management VM, run `ssh-keygen` again and finally exit
    the VM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在管理VM中，再次运行`ssh-keygen`，最后退出VM。
- en: To provide high availability in the case of a disaster in the Azure data centers,
    our master nodes will be on an availability set. Let’s create the availability
    set.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Azure数据中心发生灾难时提供高可用性，我们的主节点将位于可用性集上。让我们创建可用性集。
- en: If you don't recall what an availability set is, you can go back to our Gluster
    chapters and revisit its functionalities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不记得可用性集是什么，您可以回到我们的Gluster章节，重新了解它的功能。
- en: 'To create the availability set, run the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可用性集，请运行以下命令：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can go ahead and create our first control plane nodes. Let’s save our
    management’s VM public SSH key into a variable first to pass the key to the master
    nodes, as shown in the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续创建我们的第一个控制平面节点。让我们首先将我们管理VM的公共SSH密钥保存到一个变量中，以便将密钥传递给主节点，如下命令所示：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To create the three controller nodes, run the following `for`loop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建三个控制器节点，请运行以下`for`循环：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The sizes that we are using on these VMs are small because this is only a test
    environment, and we will not really require a lot of compute resources. In a real
    environment, we would size the VMs based on the considerations that we explored
    in the [Chapter 8](ed5a52b9-ab7d-4db3-8c84-e295d7de9600.xhtml), *Architecting
    a Kubernetes Cluster*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这些VM上使用的大小很小，因为这只是一个测试环境，我们实际上不需要很多计算资源。在真实环境中，我们会根据我们在[第8章](ed5a52b9-ab7d-4db3-8c84-e295d7de9600.xhtml)中探讨的考虑因素来确定VM的大小，*设计一个Kubernetes集群*。
- en: 'Last but not least, we create our worker nodes using the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，我们使用以下命令创建我们的工作节点：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Preparing the management VM
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备管理VM
- en: With our controller and worker nodes created, we can now log in to our management
    VM and start installing and configuring the tools that we will need to bootstrap
    our Kubernetes cluster.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: From here on out, we will mostly be working on the management VM. Let's SSH
    to the VM and start installing our toolset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: First, we will need to download the tools to create the certificates that our
    cluster’s services will be using to talk with one another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install dependencies first using the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With **Go lang** installed, you need to update your `PATH` variable and create
    a new one named `GOPATH`. Your TLS certificate-generating tool, CFFSL, will be
    installed in this path. To do this, you can do the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then run the following to load the variables in your current shell:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the variables set, now we are ready to go and get our `cffsl` toolkit
    using the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both binaries will be saved under our `GOPATH` variable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Generating certificates
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the CFSSL binaries installed and loaded to our `PATH`, we can start generating
    our certificate files. We will be generating a lot of files in this part of the
    install, so it will be a good idea to create a directory structure to store them
    appropriately.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first files that we need to generate are the files for our certificate authority,
    which will be signing the rest of our component’s certificates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be storing all of our certificates under the `~/certs/` directory,
    but first we need to create the directory. Let''s set this up using the following
    command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have the directory, let''s start by  using the following command
    to generate the CA configuration file, which will have information such as the
    expiration date of the certificates issued by our CA and what the CA is going
    to be used for:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With our CA config, we can now start issuing certificate signing requests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The first CSR that we are going to generate is the one for our CA. Let''s set
    this up using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have both our `JSON` files, we can actually use `cffsl` and generate
    our certificates using the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As shown in the following command, three files will be generated, `ca.csr`,
    `ca.pem`, and `ca-key.pem`. The first one, `ca.csr`, is the certificate signing
    request. The other two are our public certificate and the private key respectively:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will be the case for any certificates that we generate from here on in.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Client certificates
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our CA is configured and its certificate files generated, we can start
    issuing certificates for our admin user and for the kubelet on each worker node.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The process and the files that we are going to create are very similar to the
    CA ones, but with slight differences in the commands that we use to generate them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a directory for our `admin certs `using the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, create the admin user certificate. This certificate is for our administrators
    to manage our cluster via `kubectl`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will generate the `json` for the `csr` using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With our JSON ready, let''s now sign and create the admin certificates using
    the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The process for creating the `kubelet` certificates is a little bit different
    compared to the admin and CA certs. The `kubelet` certificate requires us to have
    the hostname field filled up in the certificate, as this is how it will be identified.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then use the following command to create the `json` `csr`, in which not much
    has changed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, the process is a little bit different when it comes to generating
    the `certs`, as you can see from the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, the hostname field will contain any IP or FQDN that the node
    will have. Now generate a cert for each worker node, filling in the information
    corresponding to the node that you are generating the cert for.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Control plane certificates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start creating the certificate for our kube master components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为我们的kube主要组件创建证书。
- en: 'As with the previous steps, create a directory that will contain the master
    node components’ certificates and generate the certificate files for each of them
    in the following way:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的步骤一样，创建一个包含主节点组件证书的目录，并按以下方式为每个组件生成证书文件：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For `kube-controller-manager`, use the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`kube-controller-manager`，使用以下命令：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the `kube-proxy`, use the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`kube-proxy`，使用以下命令：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For the `kube-scheduler`, use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`kube-scheduler`，使用以下命令：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we need to create the API server. You will notice that it is similar to
    the process we used with the `kubelets`, as this certificate requires the hostname
    parameter. But with the `kube-api` cert, we will not only provide the hostname
    and IP address of the individual nodes, we will also provide instead all of the
    possible hostnames and IPs that our API server will be using: the load-balancer
    public IP, the IP of each master node, and a special FQDN, `kubernetes.default`.
    All of them will be in a single cert.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建API服务器。您会注意到它与我们在`kubelets`中使用的过程类似，因为这个证书需要主机名参数。但是对于`kube-api`证书，我们不仅会提供单个节点的主机名和IP地址，还会提供API服务器将使用的所有可能的主机名和IP地址：负载均衡器的公共IP，每个主节点的IP，以及一个特殊的FQDN，`kubernetes.default`。所有这些将包含在一个单独的证书中。
- en: 'Let’s create a separate directory first using the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用以下命令创建一个单独的目录：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s create a variable for the hostname using the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令为主机名创建一个变量：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that you should replace `<PUBLIC_IP>` with your public IP address.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您应该用您的公共IP地址替换`<PUBLIC_IP>`。
- en: 'Now, let''s create the certificate using the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令创建证书：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: At this point, only one certificate is missing—the service account certificate.
    This certificate is not for any normal user or Kubernetes component specifically.
    Service account certificates are used by the API server to sign tokens that are
    used for service accounts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，只缺少一个证书——服务账户证书。这个证书不是为任何普通用户或Kubernetes组件特定的。服务账户证书由API服务器用于签署用于服务账户的令牌。
- en: 'We will be storing these key pairs in the same directory as the API certs,
    so we will just create the `json` and run the `cfssl` `gencert` command, as shown
    in the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些密钥对存储在与API证书相同的目录中，所以我们只需创建`json`并运行`cfssl` `gencert`命令，如下命令所示：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Sending our certificates home
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送我们的证书回家
- en: With all our certificates generated, it's time to move them to their corresponding
    nodes. Microsoft Azure can resolve internally via the VM name, so we can move
    the certificates easily.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有证书生成完毕后，是时候将它们移动到相应的节点上了。Microsoft Azure可以通过VM名称内部解析，所以我们可以轻松地移动证书。
- en: 'To move the certificates to the `kubelets`, use the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将证书移动到`kubelets`：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Repeat for the rest of the nodes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的节点重复以上步骤。
- en: 'To move the certificates to the control plane, use the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将证书移动到控制平面：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Repeat for the last controllers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对最后的控制器重复以上步骤。
- en: Kubeconfigs
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeconfigs
- en: For you to be able to talk to Kubernetes, you need to know where your API is.
    You also need to tell the API who you are and what your credentials are. All of
    this information is provided with `kubeconfigs`. These configuration files contain
    all the information necessary for you to reach and authenticate against the cluster.
    Not only will users be using `kubeconfig` files to reach the cluster, they will
    also be using it to reach other services. That is why we will be generating multiple
    `kubeconfig` files for every component and user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够与Kubernetes通信，您需要知道API的位置。您还需要告诉API您是谁以及您的凭据是什么。所有这些信息都包含在`kubeconfigs`中。这些配置文件包含了您到达和对集群进行身份验证所需的所有信息。用户不仅将使用`kubeconfig`文件来访问集群，还将使用它来访问其他服务。这就是为什么我们将为每个组件和用户生成多个`kubeconfig`文件。
- en: Installing kubectl
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kubectl
- en: To be able to create the `kubeconfig` files, we require `kubectl`. You will
    be installing `kubectl` in the management VM first to generate the config files,
    but later we will also use it to manage our cluster.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够创建`kubeconfig`文件，我们需要`kubectl`。您将首先在管理VM中安装`kubectl`以生成配置文件，但稍后我们还将使用它来管理我们的集群。
- en: 'First, add the repository from where we will be getting `kubectl`, as shown
    in the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加我们将获取`kubectl`的存储库，如下命令所示：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we install it using `yum`, as shown in the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`yum`进行安装，如下命令所示：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Control plane kubeconfigs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制平面kubeconfigs
- en: The first kubeconfigs that we will be generating are for our control plane components.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要生成的第一个kubeconfigs是我们的控制平面组件。
- en: 'To maintain order, we will keep organizing our files into directories. All
    our `kubeconfigs` will go in the same directory, though, as shown in the following
    command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持秩序，我们将继续将文件组织到目录中。所有我们的`kubeconfigs`将放在同一个目录中，如下命令所示：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With our directory created, let's begin generating `kubeconfigs`!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们创建的目录，让我们开始生成`kubeconfigs`！
- en: Kube-controller-manager
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-controller-manager
- en: '`kube-controller-manager` `kubeconfig`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-controller-manager` `kubeconfig`：'
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Kube-scheduler
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-scheduler
- en: '`Kube-scheduler` `kubeconfig`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kube-scheduler` `kubeconfig`：'
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Kubelet configs
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubelet配置
- en: 'For our `kubelets`, we will require one `kubeconfig` for each node. To make
    things easier, we will just make a for loop to create a config for each node,
    as shown in the following command. Note that you need to replace  `<KUBE_API_PUBLIC_IP>`
    with your own public IP address:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`kubelets`，我们将需要每个节点一个`kubeconfig`。为了简化操作，我们将使用for循环为每个节点创建一个配置，如下命令所示。请注意，您需要用您自己的公共IP地址替换`<KUBE_API_PUBLIC_IP>`：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Finally, the last `kubeconfig` that our worker nodes will need is the `kube-proxy
    kubeconfig`. We will only be generating one as it does not contain any specific
    node configurations, and we can just copy the same config to all our nodes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的工作节点将需要的最后一个`kubeconfig`是`kube-proxy kubeconfig`。我们只会生成一个，因为它不包含任何特定的节点配置，我们可以将相同的配置复制到所有节点。
- en: Kube-proxy
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-proxy
- en: '`kube-proxy` `kubeconfig`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-proxy` `kubeconfig`：'
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have the control plane kubeconfigs and worker nodes, we will now
    create the `kubeconfig` for the administrator user, using the following command.
    This `kubeconfig` file is the one that we will be using to connect to the cluster
    and manage its API objects:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了控制平面kubeconfigs和工作节点，我们现在将使用以下命令为管理员用户创建`kubeconfig`。这个`kubeconfig`文件是我们将用来连接到集群并管理其API对象的文件：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Moving configs around
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动配置文件
- en: Our kubeconfigs now need to be transferred to each of their corresponding VMs.
    To do this, we will follow the same procedure that we used to move the certificates.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的kubeconfigs需要传输到它们各自的VM。为此，我们将遵循与移动证书相同的过程。
- en: 'First, let''s move kubeconfigs that go in the worker nodes using the following
    command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令移动进入工作节点的kubeconfigs：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Repeat for every node.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个节点重复。
- en: 'With the kubeconfigs in place on the nodes, we can now move the `kube-api`
    server configs using the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点上放置了kubeconfigs后，我们现在可以使用以下命令移动`kube-api`服务器配置：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Repeat for every controller.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个控制器重复。
- en: Installing the control plane
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装控制平面
- en: Now we will install the binaries required for our control plane.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装控制平面所需的二进制文件。
- en: ETCD
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ETCD
- en: In this design, we have decided to run `etcd` alongside our `kube-apiserver`.
    We will start downloading the binaries and configuring the `systemd` units for
    our database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们决定将`etcd`与我们的`kube-apiserver`一起运行。我们将开始下载二进制文件并为我们的数据库配置`systemd`单元。
- en: Installing etcd
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装etcd
- en: It's time to start installing the `etcd` cluster in our controller nodes. To
    install `etcd`, we will SSH into each of the controllers from our management VM
    and run the following procedures.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的控制器节点中开始安装`etcd`集群了。要安装`etcd`，我们将从管理VM中SSH到每个控制器并运行以下程序。
- en: 'We will begin by downloading and extracting the binaries using the following
    command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下命令下载和提取二进制文件：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After we have extracted the binaries, we need to copy the kubernetes API and
    CA certificates to our `etcd` directory using the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取了二进制文件之后，我们需要使用以下命令将kubernetes API和CA证书复制到我们的`etcd`目录中：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Before creating the `systemd` unit file, let’s set up some variables to make
    things a little easier.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`systemd`单元文件之前，让我们设置一些变量，以使事情变得更容易一些。
- en: 'These two first variables will be host-unique, as shown in the following commands:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量将是唯一的，如以下命令所示：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next and last variable will be the same across all the nodes; it will contain
    the hostname and IP of each of our `ectd` cluster members, as shown in the following
    command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个和最后一个变量将在所有节点上相同；它将包含每个`ectd`集群成员的主机名和IP，如以下命令所示：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have the variables, let''s create the `systemd` unit file, as shown
    in the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了变量，让我们创建`systemd`单元文件，如以下命令所示：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we reload, enable, and start the daemon using the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新加载、启用并启动守护进程，使用以下命令：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once you have repeated this process for each of the nodes, you can check the
    status of the cluster by running the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为每个节点重复了这个过程，您可以通过运行以下命令来检查集群的状态：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Encrypting etcd data
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密etcd数据
- en: The API server can encrypt data stored in `etcd`. To do this, we will be using
    a flag called `--experimental-encryption-provider-config` when we create our `kube-apiserver
    systemd` unit file. But before we pass the flag, we need to create a YAML that
    will contain our encryption key.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器可以加密存储在`etcd`中的数据。为此，我们将在创建`kube-apiserver systemd`单元文件时使用一个名为`--experimental-encryption-provider-config`的标志。但在传递该标志之前，我们需要创建一个包含我们加密密钥的YAML。
- en: 'We will only create one YAML definition and copy it to every controller node.
    You should do this from the management VM so that you can easily transfer the
    file to all the controllers. Let''s set this up using the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会创建一个YAML定义并将其复制到每个控制器节点。您应该从管理VM执行此操作，以便可以轻松地将文件传输到所有控制器。让我们使用以下命令设置这一点：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Input the YAML definition as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入YAML定义如下：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, move the key to every node as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将密钥移动到每个节点：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Installing the Kubernetes controller binaries
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Kubernetes控制器二进制文件
- en: Now that `etcd` is in place, we can start installing `kube-apiserver`, `kube-controller-manager`,
    and `kube-scheduler`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`etcd`已经就位，我们可以开始安装`kube-apiserver`、`kube-controller-manager`和`kube-scheduler`。
- en: Kube-apiserver
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-apiserver
- en: 'Let''s begin by SSHing into our first controller node and downloading the required
    binary using the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个控制器节点SSH并使用以下命令下载所需的二进制文件：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now move the binaries to `/usr/local/bin/` using the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令将二进制文件移动到`/usr/local/bin/`：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we will be creating and moving all the directories and certificates that
    are needed for our API server to work using the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下命令创建和移动所有API服务器所需的目录和证书：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Before creating the `systemd` unit file, let''s declare some variables using
    the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`systemd`单元文件之前，让我们使用以下命令声明一些变量：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Only the `I_IP` variable will be unique on each node, and it will depend on
    the IP of the node on which you are doing the procedure. The other three will
    be the same on all nodes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`I_IP`变量在每个节点上是唯一的，它将取决于您正在执行该过程的节点的IP。其他三个变量在所有节点上都是相同的。
- en: 'Now that the variables are set up, we can start creating the unit file, as
    shown in the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量设置好了，我们可以开始创建单元文件，如以下命令所示：
- en: '[PRE73]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Kube-controller-manager
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-controller-manager
- en: To install the `kube-controller-manager`, the steps will be very similar, except
    that at this point we will start using the kubeconfigs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`kube-controller-manager`，步骤将非常相似，只是在这一点上，我们将开始使用kubeconfigs。
- en: 'First, download `kube-controller-manager` using the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令下载`kube-controller-manager`：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Move the `kubeconfig` and create the unit file for the `kube-controller-manager` using
    the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令移动`kubeconfig`并创建`kube-controller-manager`的单元文件：
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Kube-scheduler
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-scheduler
- en: The final component to install in the control plane is `kube-scheduler`. With
    the scheduler, besides creating the `systemd` unit file we will also be creating
    a YAML file that contains the basic configuration of the scheduler.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制平面中安装的最后一个组件是`kube-scheduler`。除了创建`systemd`单元文件外，我们还将创建一个包含调度程序基本配置的YAML文件。
- en: 'First, let''s download the binaries. Use the following commands to download
    `kube-scheduler` and move it to `/usr/local/bin/`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们下载二进制文件。使用以下命令下载`kube-scheduler`并将其移动到`/usr/local/bin/`：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We move the `kubeconfig` file to the `kubernetes` folder using the following
    command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将`kubeconfig`文件移动到`kubernetes`文件夹中：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`kube-scheduler.yml` is given as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-scheduler.yml`如下所示：'
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`kube-scheduler.service` is given as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-scheduler.service`如下所示：'
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Repeat all the steps in the *Installing the control plane* section on each controller
    node before moving on to the next steps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，重复在每个控制器节点上的*安装控制平面*部分中的所有步骤。
- en: Starting the control plane
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动控制平面
- en: After finishing the installation of each component on every controller node,
    we are ready to start and test the services.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个控制器节点上完成每个组件的安装后，我们准备启动和测试服务。
- en: 'To do this, we will first enable and start all `systemd` units using the following
    command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先使用以下命令启用和启动所有`systemd`单元：
- en: '[PRE80]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Finally, to be able to use `kubectl` ourselves, we need to set the context of
    the cluster that we want to connect to and set up the `kubeconfig` admin as our
    default one. The `kubeconfig` admin that we have is currently set to point to
    `localhost` as the `kube-apiserver` endpoint. This will be OK for now, because
    we only want to test our components.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了能够自己使用`kubectl`，我们需要设置要连接的集群的上下文，并将`kubeconfig`管理员设置为默认值。我们目前设置的`kubeconfig`管理员指向`localhost`作为`kube-apiserver`端点。这暂时没问题，因为我们只想测试我们的组件。
- en: 'Enter the following command in your `kube-controller-1`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kube-controller-1`中输入以下命令：
- en: '[PRE81]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should look as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Setting RBAC permissions for kubelets.
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为kubelets设置RBAC权限。
- en: Our API server will require permissions to talk to the `kubelets` API. To accomplish
    this, we create cluster roles that we will bind to the Kubernetes user. We will
    do this on just one of the controller nodes because we will use `kubectl`, and
    the changes will be applied to the entire cluster.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API服务器将需要权限与`kubelets` API进行通信。为此，我们创建将绑定到Kubernetes用户的集群角色。我们将在一个控制器节点上执行此操作，因为我们将使用`kubectl`，并且更改将应用于整个集群。
- en: Cluster role
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群角色
- en: 'Create a cluster role that contains the permissions using the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建包含权限的集群角色：
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Cluster role binding
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群角色绑定
- en: 'Now bind the role to the Kubernetes user using the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令将角色绑定到Kubernetes用户：
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Load-balancer setup
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡器设置
- en: We need to load-balance the request to all our kube-controller-nodes. Because
    we are running on the cloud, we can create a load-balancer object that will load-balance
    requests across all our nodes. Not only that, but we can configure health probes
    that will monitor the status of our controller nodes to see if they are available
    to receive requests.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将请求负载均衡到所有kube-controller节点。因为我们在云上运行，我们可以创建一个负载均衡器对象，该对象将在所有节点上负载均衡请求。不仅如此，我们还可以配置健康探测，以监视控制器节点的状态，看它们是否可用来接收请求。
- en: Creating the load-balancer
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建负载均衡器
- en: The load-balancer is what we have been saving the public IP for. The LB is going
    to be our point of access to our cluster from the outside. We will need to create
    rules to health-check port `80` and to redirect `kubectl` requests to `6443`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器是我们一直在保存公共IP的地方。LB将成为我们从外部访问集群的入口。我们需要创建规则来健康检查端口`80`，并将`kubectl`请求重定向到`6443`。
- en: Let's go through the following steps to achieve this.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来实现这一点。
- en: Azure load-balancer
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure负载均衡器
- en: We will have to go back to our workstation with the Azure CLI installed to go
    through the next set of steps.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不回到我们安装了Azure CLI的工作站，以完成接下来的一系列步骤。
- en: 'To create the load-balancer in your workstation and assign it the public IP,
    run the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的工作站上创建负载均衡器并为其分配公共IP，请运行以下命令：
- en: '[PRE85]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now that we have created our load-balancer, we still need to configure three
    more things:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了负载均衡器，我们仍然需要配置三件事：
- en: The backend pool
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端池
- en: Health probes
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康探测
- en: Load balancing rules
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡规则
- en: The backend pool
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端池
- en: 'So far ,we have been doing everything related to Azure via the Azure CLI. Let''s
    go through the following steps via the Azure portal so you can familiarize yourself
    with the portal as well:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在通过Azure CLI进行与Azure相关的一切。让我们通过Azure门户按照以下步骤，以便您也可以熟悉门户：
- en: '![](img/c8a39b26-0784-4a9b-aa82-9ce3e429b507.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8a39b26-0784-4a9b-aa82-9ce3e429b507.png)'
- en: 'To create the backend pool, navigate to your kube-lb object as shown in the
    following screenshots:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建后端池，请转到kube-lb对象，如下面的屏幕截图所示：
- en: '![](img/39e23280-0c2f-4e1a-a367-fe23bab0fb65.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e23280-0c2f-4e1a-a367-fe23bab0fb65.png)'
- en: 'When you are inside the load-balancer object, navigate to Backend Pools and
    click on Add, as shown in the following screenshot:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在负载均衡器对象内时，请转到后端池并单击添加，如下面的屏幕截图所示：
- en: '![](img/315ef824-ef98-4093-a4d4-ad9e97422f10.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/315ef824-ef98-4093-a4d4-ad9e97422f10.png)'
- en: 'When you click on Add, a menu will appear. Name your backend pool `kube-lb-backend`
    and make sure you select all the kube-controller-nodes and their respective IPs,
    as shown in the following screenshot:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击“添加”时，将出现一个菜单。将您的后端池命名为`kube-lb-backend`，并确保选择所有kube-controller节点及其各自的IP，如下截图所示：
- en: '![](img/0fd2e97f-982e-4dbe-85ba-b52bb5428e03.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd2e97f-982e-4dbe-85ba-b52bb5428e03.png)'
- en: Example
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: Click on Add to finish. We have successfully set up backend VMs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“添加”以完成。我们已成功设置了后端VM。
- en: Health probes
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康探测
- en: Before we can create load balancing rules, we need to create the health probes
    that will tell our LB which nodes are available to receive traffic. Because, at
    the time of writing this chapter, load-balancers in Azure do not support HTTPS
    health probes, we will need to expose the `/healthz` endpoint through HTTP. To
    do this, we will install Nginx in our controller nodes, and pass proxy requests
    coming to port `80` to port `6443`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建负载均衡规则之前，我们需要创建健康探测，告诉我们的LB哪些节点可以接收流量。因为在撰写本章时，Azure中的负载均衡器不支持HTTPS健康探测，我们需要通过HTTP公开`/healthz`端点。为此，我们将在我们的控制节点上安装Nginx，并将传入到端口`80`的代理请求传递到端口`6443`。
- en: 'SSH back to your controller nodes and perform the following procedures in each
    one of them:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH返回到您的控制节点，并在每个节点上执行以下过程：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Once Nginx is installed, replace the `server` entry in `/etc/nginx/nginx.conf`
    with the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nginx后，在`/etc/nginx/nginx.conf`中替换`server`条目为以下内容：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Because we are running a RHEL-based distribution, SELINUX is enabled by default;
    therefore, it will be preventing Nginx from accessing the TCP socket on port `6443`.
    To permit this behavior, we need to run the following commands.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在运行基于RHEL的发行版，默认情况下启用了SELINUX；因此，它将阻止Nginx访问端口`6443`上的TCP套接字。为了允许这种行为，我们需要运行以下命令。
- en: 'First, we install the required packages to manage SELINUX, as shown in the
    following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们安装所需的软件包来管理SELINUX，如下命令所示：
- en: '[PRE88]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Once the packages are installed, we run the following to allow connections
    to port `6443`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包后，我们运行以下命令允许连接到端口`6443`：
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Lastly, we use the following command to start `nginx`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令启动`nginx`：
- en: '[PRE90]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If you want to test this, you can always run a `curl` on `localhost`, like
    this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试这个，您可以随时在`localhost`上运行`curl`，就像这样：
- en: '[PRE91]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The following output will be generated if everything was correctly configured:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切配置正确，将生成以下输出：
- en: '[PRE92]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Remember to repeat all these procedures for each of the controller nodes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住为每个控制节点重复所有这些过程。
- en: Now that the health endpoints are exposed, we are ready to create health probe
    rules in the load-balancer.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在健康端点已暴露，我们已准备好在负载均衡器中创建健康探测规则。
- en: Back in the `kube-lb` menu, under Settings—the same place where we configure
    backend pools—select health probes and click on Add.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`kube-lb`菜单，在设置下，与我们配置后端池的地方相同，选择健康探测，然后单击“添加”。
- en: 'Once the menu appears, fill in the fields as shown in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单出现后，填写字段，如下截图所示：
- en: '![](img/de036edf-e4cc-4d3a-b71a-0f471cff5621.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de036edf-e4cc-4d3a-b71a-0f471cff5621.png)'
- en: Load-balancing rules
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡规则
- en: We have everything ready to create load-balancing rules and get our load-balancer
    ready for use.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好创建负载均衡规则，并使我们的负载均衡器准备就绪。
- en: 'The process is the same one that we used with backend pools and health probes.
    Go to the Settings menu under kube-lb and select Load Balancing Rules. Click on
    Add and fill in the dialog that appears, as shown in the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与我们在后端池和健康探测中使用的过程相同。转到kube-lb下的设置菜单，选择负载均衡规则。单击“添加”并填写出现的对话框，如下截图所示：
- en: '![](img/ab7bfe68-f15c-4c60-a5d0-46072476d4bf.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab7bfe68-f15c-4c60-a5d0-46072476d4bf.png)'
- en: Once what is ready, we just need to open our network security group to allow
    connections on port `6443`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们只需要打开我们的网络安全组，允许在端口`6443`上进行连接。
- en: 'On your Azure CLI workstation, run the following command to create the rule:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure CLI工作站上运行以下命令以创建规则：
- en: '[PRE93]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Give it a few minutes to take effect, and then navigate in your browser to `https://<LB_IP>:6443/version`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟生效，然后在浏览器中导航至`https://<LB_IP>:6443/version`。
- en: 'You should see something like the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This will indicate that you can access the API server through the LB.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表明您可以通过LB访问API服务器。
- en: Worker node setup
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作节点设置
- en: It's time to configure and install our worker nodes. In these, we will be installing
    `kubelet`, the kube proxy, the container runtime, and the container network interface
    plugins.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是配置和安装我们的工作节点的时候了。在这些节点上，我们将安装`kubelet`、kube代理、容器运行时和容器网络接口插件。
- en: 'SSH into the first worker node from your management VM, as shown in the following
    command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理VM中的第一个工作节点SSH登录，如下命令所示：
- en: '[PRE95]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Downloading and preparing binaries
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和准备二进制文件
- en: Before configuring any service, we need to download any dependencies and set
    up the required repositories. After this, we can start downloading the binaries
    and moving them to their respective locations.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置任何服务之前，我们需要下载任何依赖项并设置所需的存储库。之后，我们可以开始下载二进制文件并将它们移动到它们各自的位置。
- en: Adding the Kubernetes repository
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Kubernetes存储库
- en: 'The repository that we need to configure is the Kubernetes repository. With
    this, we will be able to download `kubectl`. Let''s set this up using the following
    command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置的存储库是Kubernetes存储库。通过这样，我们将能够下载`kubectl`。让我们使用以下命令设置：
- en: '[PRE96]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Installing dependencies and kubectl
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装依赖项和kubectl
- en: 'With the `repo` configured, we can start downloading `kubectl` and any required
    dependencies for the binaries that we will download. Let''s set this up using
    the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置`repo`，我们可以开始下载`kubectl`和我们将下载的二进制文件所需的任何依赖项。让我们使用以下命令设置：
- en: '[PRE97]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Downloading and storing worker binaries
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和存储工作节点二进制文件
- en: 'Now that we have the dependencies ready, we can download our required worker
    binaries using the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的依赖项准备好了，我们可以使用以下命令下载所需的工作节点二进制文件：
- en: '[PRE98]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now let''s create the folder structure for the recently downloaded binaries
    using the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下命令创建最近下载的二进制文件的文件夹结构：
- en: '[PRE99]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We change the name to `runc` for ease of use and to conform to the convention,
    as shown in the following command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将名称更改为`runc`以方便使用并符合约定，如以下命令所示：
- en: '[PRE100]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We give executable permissions to the rest of our binaries using the following
    command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令为其余的二进制文件授予可执行权限：
- en: '[PRE101]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After giving them executable rights, we can move them to `/usr/local/bin/` using
    the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 给予它们可执行权限后，我们可以使用以下命令将它们移动到`/usr/local/bin/`：
- en: '[PRE102]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Some of the downloaded files are TAR archives, which we need to `untar` and
    store in their respective locations using the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一些下载的文件是TAR存档文件，我们需要使用以下命令`untar`并将其存储在各自的位置：
- en: '[PRE103]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Containerd setup
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Containerd设置
- en: We are ready now to start configuring each service. The first one is `containerd`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好开始配置每个服务了。第一个是`containerd`。
- en: 'Let’s create the configuration directory using the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建配置目录：
- en: '[PRE104]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now we create the `toml` config file, which will tell `containerd` what container
    runtime to use. Let''s set this up using the following command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建`toml`配置文件，告诉`containerd`要使用哪个容器运行时。让我们使用以下命令进行设置：
- en: '[PRE105]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Finally, let''s set up the `systemd` unit file using the following command:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令设置`systemd`单元文件：
- en: '[PRE106]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The kubelet
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubelet
- en: Our main service in the worker nodes is the `kubelet`. Let's create its configuration
    files.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工作节点中的主要服务是`kubelet`。让我们创建它的配置文件。
- en: 'First, we need to move the `kubelet` certificates to their locations using
    the following command:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用以下命令将`kubelet`证书移动到它们的位置：
- en: '[PRE107]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now we create the YAML config file that will contain things such as the DNS
    server IP address, the cluster domain, and the location of the certificate files.
    Let''s set this up using the following command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建YAML配置文件，其中包含DNS服务器IP地址、集群域和证书文件的位置等内容。让我们使用以下命令进行设置：
- en: '[PRE108]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Finally, we create the service unit file using the following command:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令创建服务单元文件：
- en: '[PRE109]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: kube-proxy
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-proxy
- en: The next service to create is `kube-proxy`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要创建的服务是`kube-proxy`。
- en: 'We move the previously created `kubeconfigs` using the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令移动先前创建的`kubeconfigs`：
- en: '[PRE110]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As with `kubelet`, `kube-proxy` also requires a config `YAML` that has the
    cluster CIDR and the mode in which `kube-proxy` will operate. Let''s set this
    up using the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与`kubelet`一样，`kube-proxy`还需要一个配置`YAML`，其中包含集群CIDR和`kube-proxy`将运行的模式。让我们使用以下命令进行设置：
- en: '[PRE111]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, we create a unit file for `kube-proxy` using the following command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令为`kube-proxy`创建一个单元文件：
- en: '[PRE112]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Starting services
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'Once you have completed these procedures on ALL kube-nodes, you can start the
    services on each node with the following command:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有kube节点上的这些步骤后，您可以使用以下命令在每个节点上启动服务：
- en: '[PRE113]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Kubernetes networking
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes网络
- en: 'We still have a couple more things to do in our cluster: we need to install
    a network provider and configure the DNS.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的集群中还有一些事情要做：我们需要安装网络提供程序并配置DNS。
- en: Getting the nodes ready
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备节点
- en: Our nodes will have to be able to forward packets in order for our pods to be
    able to talk to the outside world. Azure VMs do not have IP forwarding enabled
    out-of-the-box, so we will have to enable it manually.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的节点必须能够转发数据包，以便我们的pod能够与外部世界通信。Azure VM默认情况下未启用IP转发，因此我们必须手动启用它。
- en: 'To do this, go to your Azure CLI workstation and run the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请转到Azure CLI工作站并运行以下命令：
- en: '[PRE114]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This will enable IP forwarding capabilities on the VM’s NIC.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在VM的NIC上启用IP转发功能。
- en: Now we have to enable the IP-forwarding kernel parameter on the worker nodes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在工作节点上启用IP转发内核参数。
- en: 'SSH into each worker node from the management VM and enable IPv4 forwarding
    using the following command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理VM登录到每个工作节点，并使用以下命令启用IPv4转发：
- en: '[PRE115]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Configuring remote access
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置远程访问
- en: 'Now, in order to run `kubectl` commands from your management VM, we need to
    create a `kubeconfig` that uses the admin certificate and the public IP address
    of our cluster. Let''s set this up using the following command:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了从管理VM运行`kubectl`命令，我们需要创建一个使用集群的管理员证书和公共IP地址的`kubeconfig`。让我们使用以下命令进行设置：
- en: '[PRE116]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Installing Weave Net
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Weave Net
- en: With remote access on our management VM configured, we can now run `kubectl`
    commands without having to log in to our controller nodes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了管理VM上的远程访问后，我们现在可以在不必登录到控制节点的情况下运行`kubectl`命令。
- en: 'To install Weave Net, run the following `kubectl` command from the management
    VM:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Weave Net，请从管理VM运行以下`kubectl`命令：
- en: '[PRE117]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: With Weave Net installed, now our pods will have IP allocations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Weave Net后，现在我们的pod将有IP分配。
- en: DNS server
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS服务器
- en: 'Now we will provision our DNS server, which will be provided by Core DNS, an
    open source DNS server based on plugins. Let''s set this up using the following
    command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将配置我们的DNS服务器，它将由Core DNS提供，这是一个基于插件的开源DNS服务器。让我们使用以下命令进行设置：
- en: '[PRE118]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Check the DNS pods with the following command:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查DNS pod：
- en: '[PRE119]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'With the DNS server pods created, we have successfully finished the installation
    of our Kubernetes cluster. If you want, you can create the following deployment
    to test the cluster one more time:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了DNS服务器pod后，我们已成功完成了Kubernetes集群的安装。如果您愿意，您可以创建以下部署来再次测试集群：
- en: '[PRE120]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Now that we have seen the steps needed to create a cluster from scratch, I want
    to talk a little bit about managed Kubernetes solutions.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了从头开始创建集群所需的步骤，我想谈谈托管的Kubernetes解决方案。
- en: Managing Kubernetes on the cloud
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云上管理Kubernetes
- en: 'Installing and making a Kubernetes cluster usable and ready for production,
    as you saw in this chapter, is a very long and complex process. If any step goes
    wrong, your entire deployment might be useless. Because of this, many cloud providers
    are offering managed Kubernetes solutions—Kubernetes as a service, in a way. In
    this type of managed solution, the cloud provider or service provider will manage
    the master nodes of the cluster, which include all the Kubernetes controllers,
    the API server, and even the `etcd` database. This is a major advantage because
    using a managed service will mean that you don''t have to worry about the maintenance
    of the master nodes, and so you won''t have to worry about the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Renewing SSL certificates
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating/upgrading the `etcd` database
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating/upgrading each of the master node binaries
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering extra nodes to the cluster
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of support if something goes wrong
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent integration with the cloud infrastructure
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system patching and maintenance
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By forgetting these, we can focus on what's important, such as provisioning
    pods and creating workloads on our cluster. With managed services, the learning
    curve decreases dramatically because our staff can focus mainly on the functionality
    of Kubernetes instead of how it works in order for them to maintain it.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, some managed Kubernetes services worth mentioning are
    from the following three biggest cloud providers:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Services** (**AKS**)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Web Services Elastic Container Service for Kubernetes** (**EKS**)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides managed Kubernetes services, there are also several open-source projects
    and non-open-source projects that are Kubernetes-based. These projects are not
    entirely managed, but instead use Kubernetes in the backend to achieve their goals.
    The following are some more well-known projects:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Okd (Red Hat's upstream community project for Red Hat OpenShift)
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat OpenShift
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SUSE **Container as a Service** (**Caas**)platform
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesosphere Kubernetes Engine
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic steps of provisioning a Kubernetes cluster.
    We also learned about the Azure command-line interface and how to provision resources
    in Azure. We also tried different tools across the whole deployment, such as CFSSL
    and Nginx.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: We learned about and provisioned `kubectl` configuration files that enabled
    us to access our cluster and deployed a dummy deployment to test our cluster.
    Finally, we looked at the benefits of running a managed cluster and the different
    types of managed service that we can find in the major public cloud providers.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explain what each component does. The reader will learn
    about the different components and their purposes.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you install Kubernetes?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `kubeconfig`?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create SSL certificates?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is AKS?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we use the Azure CLI?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we provision a resource group in Azure?
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we install `etcd`?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes* by Packt Publishing: [https://prod.packtpub.com/in/application-development/mastering-kubernetes-second-edition](https://prod.packtpub.com/in/application-development/mastering-kubernetes-second-edition)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes for Developers* by Packt Publishing: [https://prod.packtpub.com/in/virtualization-and-cloud/kubernetes-developers](https://prod.packtpub.com/in/virtualization-and-cloud/kubernetes-developers)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Microservices with Kubernetes* by Packt Publishing: [https://prod.packtpub.com/in/virtualization-and-cloud/hands-microservices-kubernetes](https://prod.packtpub.com/in/virtualization-and-cloud/hands-microservices-kubernetes)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bibliography/sources:'
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generating self-signed certificates:** [https://coreos.com/os/docs/latest/generate-self-signed-certificates.html](https://coreos.com/os/docs/latest/generate-self-signed-certificates.html)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFlare''s PKI/TLS toolkit**: [https://github.com/cloudflare/cfssl](https://github.com/cloudflare/cfssl)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Go Programming Language**:[ ](https://golang.org/doc/install)[https://golang.org/doc/install](https://golang.org/doc/install)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go编程语言**：[https://golang.org/doc/install](https://golang.org/doc/install)'

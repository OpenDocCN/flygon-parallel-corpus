- en: Solving Management Problems with Salty Solutions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Salty解决管理问题
- en: 'In this chapter, we will discover and discuss why a business needs to have
    a centralized management utility for its infrastructure, including the high level
    of complexity that a heterogeneous environment brings to the table. We will be
    talking about solutions to this and things such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现并讨论为什么企业需要为其基础设施拥有集中管理工具，包括异构环境带来的高复杂性。我们将讨论解决这个问题的解决方案，以及以下内容：
- en: How new technologies bring complexity to our business
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新技术给我们的业务带来复杂性
- en: How we can centralize system management.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何集中化系统管理。
- en: How **infrastructure as code** (**IaC**) help us to maintain our system's state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（IaC）如何帮助我们维护系统状态'
- en: Tools that leverage IaC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用IaC的工具
- en: The SaltStack platform and its components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SaltStack平台及其组件
- en: Let's begin our journey through system management.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的系统管理之旅。
- en: Centralizing system management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中化系统管理
- en: Understanding the reason behind system management can be easily taken for granted.
    We often assume that just because a business has a big IT infrastructure, it needs
    a solution to manage its inventory. While this is obviously true, there is more
    to it than that. Our job as architects consists of listening to our customers'
    problems and understanding what exactly they are looking for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解系统管理背后的原因很容易被忽视。我们经常假设，只因为一个企业拥有庞大的IT基础设施，就需要解决其清单管理的问题。虽然这显然是真的，但其中还有更多。我们作为架构师的工作包括倾听客户的问题，并理解他们究竟在寻找什么。
- en: New technologies and system management
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新技术和系统管理
- en: In this ever-evolving IT world, changes come fast. New technologies come out
    almost every day. Technologies such as virtualization, IoT, and the cloud are
    shaping and changing the way we use IT by growing our infrastructures exponentially,
    which the bare-metal era never saw.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个不断发展的IT世界中，变化迅速。几乎每天都会出现新技术。虚拟化、物联网和云等技术正在塑造和改变我们使用IT的方式，通过不断扩大我们的基础设施，这是裸金属时代从未见过的。
- en: All these changes and exponential growth means that IT managers have a lot more
    to manage and far less time to train their staff to support these technologies,
    so many businesses can barely keep up with the pace. This can result in them becoming
    reluctant to adopt new technologies. But many have no choice but to adopt them
    for fear of becoming irrelevant and not being able to satisfy the demands of their
    customers. If their competitors have the advantage and deliver a better and faster
    service, they will likely go out of business.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变化和指数级增长意味着IT经理有更多的东西要管理，但时间更少来培训他们的员工支持这些技术，因此许多企业几乎无法跟上步伐。这可能导致他们不愿意采用新技术。但许多企业别无选择，只能采用这些技术，因为他们担心变得无关紧要，无法满足客户的需求。如果他们的竞争对手占据优势并提供更好更快的服务，他们很可能会破产。
- en: Companies want to adopt these technologies as soon as possible, to gain an edge
    over their competitors, but new technologies often come with big learning curves.
    During this time, IT staff need to learn how to manage and maintain new systems,
    resulting in keeping critical systems and workloads available becoming a challenge.
    Not complying with our SLAs becomes a real threat; imagine a situation where a
    developer needs the operations team to apply a library patch to our dev environment
    systems in order to test a new release, and because our operations staff (or at
    least half of them) are in training, developers are tempted to bypass the standardized
    change-request process and apply the update themselves. Shadow IT in this type
    of situation is really common, and we need to avoid it at all costs. Shadow IT
    can make our company non-compliant with regulatory standards.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 公司希望尽快采用这些技术，以在竞争对手之上取得优势，但新技术往往伴随着陡峭的学习曲线。在此期间，IT人员需要学习如何管理和维护新系统，这导致保持关键系统和工作负载可用性成为一项挑战。不遵守我们的SLA成为真正的威胁；想象一下，开发人员需要运维团队在我们的开发环境系统中应用库补丁以测试新版本，因为我们的运维人员（或至少一半）正在接受培训，开发人员很容易绕过标准化的变更请求流程并自行应用更新。在这种情况下，影子IT非常普遍，我们需要尽一切努力避免。影子IT可能使我们的公司不符合监管标准。
- en: While IT leaders push to adopt new technologies, they are often left with very
    small and declining budgets to do this type of transformation. This also directly
    affects our critical systems and workloads because investment in system management
    declines and moves toward innovation. Moving toward innovation is not a bad thing,
    because it will eventually enable us to provide a better service, but it is important
    to understand that it also has consequences regarding the maintenance of our existing
    environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IT领导者推动采用新技术，但他们往往面临非常有限且日益减少的预算来进行这种转型。这也直接影响我们的关键系统和工作负载，因为对系统管理的投资减少并转向创新。迈向创新并不是坏事，因为最终它将使我们能够提供更好的服务，但重要的是要理解，这也会对我们现有环境的维护产生后果。
- en: With new technology comes new infrastructure; mixed environments become more
    common every day, and it is crucial to understand how to manage these mixed environments
    in the best and most efficient way possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新技术的出现，新基础设施也随之而来；混合环境变得越来越普遍，了解如何以最佳和最有效的方式管理这些混合环境至关重要。
- en: Recovering control of our own infrastructure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新掌控我们自己的基础设施
- en: Having control of our infrastructure is the main goal of system management.
    But what does it mean to have control? Inventory listing, version control, automated
    patching, and software distribution are all part of system management. All of
    them are part of a bigger picture where IT regains control of its infrastructure
    and can ensure compliance and standardization across their systems no matter what
    Linux distribution they are running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 掌控我们的基础设施是系统管理的主要目标。但是拥有控制权意味着什么？清单清单、版本控制、自动打补丁和软件分发都是系统管理的一部分。所有这些都是更大格局的一部分，IT可以重新掌控其基础设施，并确保无论他们正在运行什么Linux发行版，都可以确保其系统的合规性和标准化。
- en: Often our systems are separated; this separation is because they might differ
    in their characteristics. We can have systems with Red Hat Enterprise Linux-based
    distributions or Debian-based distributions, systems that have different architectures
    such as x86, power servers, or even ARM. All these systems might not even talk
    to one another or serve the same purpose; all of them become silos that IT has
    to maintain and manage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们的系统是分开的；这种分离是因为它们可能在特征上有所不同。我们可能有基于Red Hat Enterprise Linux的发行版或基于Debian的发行版的系统，具有不同架构的系统，如x86、功率服务器，甚至ARM。所有这些系统甚至可能不会相互通信或为相同的目的服务；它们都成为IT必须维护和管理的存储。
- en: Imagine performing all the different tasks that systems' management is about
    on each separate silo by hand without a tool to centralize and automate the tasks.
    Human error is the most direct threat to this type of scenario, followed by the
    large complexity, time, and cost that an IT business has to incur to train its
    staff, hire staff, and buy specific administration tools for each different system
    type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在没有工具来集中和自动化任务的情况下，手动在每个独立的存储中执行系统管理的各种任务。人为错误是这种情况最直接的威胁，其次是IT业务必须承担的大量复杂性、时间和成本，包括培训员工、雇佣员工以及为每种不同的系统类型购买特定的管理工具。
- en: Centralized tools to disperse problems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中工具分散问题
- en: Centralized configuration management can help us to control changes to systems
    in a controlled, consistent, and stable way. It is perfect for systems that are
    running a cluster or configured for high availability, as all the nodes across
    the cluster have to have the exact same configuration. With configuration management,
    we can also understand the reason behind permissions on certain files, a package
    installed on all the systems, or even a line of code in a configuration file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集中配置管理可以帮助我们以受控、一致和稳定的方式控制系统的变更。对于运行集群或配置为高可用性的系统来说，这是完美的，因为集群中的所有节点都必须具有完全相同的配置。通过配置管理，我们还可以理解某些文件的权限背后的原因，所有系统上安装的软件包，甚至配置文件中的一行代码。
- en: These changes or configurations that we implement through a configuration management
    tool can also be rolled back, as most tools available in the market come with
    version control, and any typo, human error, or incompatible update can easily
    be rolled back.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置管理工具实施的这些变更或配置也可以回滚，因为市场上大多数工具都带有版本控制，任何拼写错误、人为错误或不兼容的更新都可以轻松回滚。
- en: As we slowly transition into cloud environments, virtual machines and resources
    become more and more a commodity and a service. Configuration management tools
    that can help us manage, provision, and maintain our cloud infrastructure become
    very valuable assets. With these types of tool, we can treat our infrastructure
    in a more elastic way, and define it in a descriptive way, in the sense that we
    can have templates that deploy the same infrastructure or implement changes based
    on a definition; this is what we call **infrastructure as code** (**IaC**).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们慢慢过渡到云环境，虚拟机和资源变得越来越成为商品和服务。可以帮助我们管理、配置和维护云基础设施的配置管理工具变得非常有价值。通过这些类型的工具，我们可以以更具弹性的方式处理基础设施，并以描述性的方式定义它，这意味着我们可以拥有部署相同基础设施的模板或根据定义实施更改；这就是我们所说的**基础设施即代码**（**IaC**）。
- en: Coding for a desired state
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码实现期望状态
- en: The whole idea behind IaC is to have consistency and versioning within our environment.
    IaC seeks a more descriptive and standard way of provisioning resources, by avoiding
    unique and special deployments to prevent the situation in which recreating an
    environment is highly complex because of the uniqueness of each of its components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: IaC背后的整个理念是在我们的环境中实现一致性和版本控制。IaC寻求一种更具描述性和标准的资源配置方式，避免独特和特殊的部署，以防止由于每个组件的独特性而重新创建环境变得非常复杂的情况。
- en: 'IaC tools define configurations via a specific language or via existing languages
    such as YAML or JSON; in the following, we can see an example extract from a Terraform
    template that defines virtual machines in Microsoft Azure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IaC工具通过特定语言或现有语言（如YAML或JSON）定义配置；以下是一个从Terraform模板中提取的示例，该模板定义了Microsoft Azure中的虚拟机：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the world of cloud infrastructures, elasticity is key. Now we don't have
    existing resources provisioned on our datacenters waiting to be used. In the cloud,
    we pay for what we use and having VMs or storage sitting there increasing our
    monthly bill is not ideal. With IaC, we can scale up or scale down those environments
    on demand. For example, we know that we have an application that is at its peak
    consumption only during business hours and requires extra instances to support
    the load. But out of business hours, a single instance is enough to support the
    load. With IaC, we can have a script to create extra instances in the morning
    and lower the instances at the end of the day. Each instance is not unique and
    we can take advantage of configuration management tools that use descriptive files
    via IaC to achieve this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在云基础设施世界中，弹性是关键。现在我们没有在数据中心等待使用的现有资源。在云中，我们按需付费，拥有虚拟机或存储空间会增加我们的月度账单，这并不理想。通过IaC，我们可以根据需求扩展或缩减这些环境。例如，我们知道我们有一个应用程序，只在工作时间内消耗最大，并需要额外的实例来支持负载。但在工作时间之外，一个实例就足以支持负载。通过IaC，我们可以编写脚本在早上创建额外的实例，并在一天结束时减少实例。每个实例都不是唯一的，我们可以利用通过IaC使用描述性文件的配置管理工具来实现这一点。
- en: There are several tools that can accomplish the afore mentioned example, but
    many tools don't just provision infrastructure in the cloud or in virtualized
    environments. Other configuration management tools do even more than that; they
    can push configuration files, install packages, create users, or even filesystems.
    There are several ways and methods in which these tools perform their configurations.
    Many tools require an agent, but a few others are agentless.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以完成上述示例，但许多工具不仅可以在云中或虚拟化环境中提供基础设施。其他配置管理工具甚至可以做得更多；它们可以推送配置文件，安装软件包，创建用户，甚至文件系统。这些工具执行配置的方式和方法有几种。许多工具需要代理，但还有一些是无代理的。
- en: The way in which configuration management tools perform their changes is essentially
    via a **push** or a **pull**. This will depend (but not always) on whether the
    tool uses an agent or is agentless. Most agentless tools push the configuration
    changes you declare in IaC files and send the changes to either an API in the
    cloud or via SSH when you execute the tool via a command line or a script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具执行其更改的方式基本上是通过推送或拉取。这将取决于（但并非总是）工具是否使用代理或无代理。大多数无代理工具将您在IaC文件中声明的配置更改推送到云中的API，或者通过SSH发送更改，当您通过命令行或脚本执行工具时。
- en: On the other hand, a pull is almost always through an agent. The agent is constantly
    consulting the configuration management server for definitions, verifying the
    desired state in case something was changed to pull those changes from the server
    and apply them to its host.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，拉取几乎总是通过代理进行。代理不断地向配置管理服务器查询定义，验证所需状态，以防有所更改，然后从服务器拉取这些更改并应用到其主机上。
- en: 'Pushes and pulls can be applied in two different ways: in a declarative way
    and in an imperative way. The declarative way specifies what the desired state
    is, and the changes are applied as they are defined in the IaC specification file.
    The imperative way consists of running a set of instructions or commands in a
    specific order to tell the system how to reach the desired state.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 推送和拉取可以以两种不同的方式应用：声明式和命令式。声明式方式指定所需状态是什么，并且更改将按照IaC规范文件中定义的方式应用。命令式方式包括按特定顺序运行一组指令或命令，告诉系统如何达到所需状态。
- en: 'Some open source tools available for configuration management via IaC are as
    follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IaC进行配置管理的一些开源工具如下：
- en: Puppet
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet
- en: Chef
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef
- en: Ansible
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Terraform
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform
- en: Salt
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盐
- en: Vagrant
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vagrant
- en: We will be taking an in-depth look at Salt and its components in the [Chapter
    14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml), *Getting Your Hands Salty*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第14章《Getting Your Hands Salty》中深入了解盐及其组件。
- en: Understanding NaCl
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解NaCl
- en: We learned about what IaC is, and the difficulties behind systems management.
    But as architects of future solutions, we need to know and understand which tools
    can help our customers face the challenges that configuration management brings
    to the table.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了IaC是什么，以及系统管理背后的困难。但作为未来解决方案的架构师，我们需要知道并了解哪些工具可以帮助我们的客户面对配置管理带来的挑战。
- en: In this section, we will be talking about how we can use **Salt**, or **The**
    **SaltStack Platform** as it is also known, to help us achieve a centralized,
    agile, and elastic management infrastructure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用盐，或者称为盐堆平台，来帮助我们实现集中、灵活和弹性的管理基础设施。
- en: Introducing Salt
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍盐
- en: Salt is an open source project developed in Python and was created by Tomas
    S Hatch, back in 2011. Originally, it wasn't intended to be a configuration management
    tool, but rather a data collection tool and a remote command execution software
    that leveraged the `ZeroMQ` library. Later the same year, configuration management
    functionalities were added via states, which we will review later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 盐是一个由Tomas S Hatch于2011年开发的Python开源项目。最初，它并不是一个配置管理工具，而是一个数据收集工具和远程命令执行软件，利用了ZeroMQ库。同年晚些时候，通过状态添加了配置管理功能，我们稍后将进行审查。
- en: Due to the fact that Salt is written in Python, it is highly extensible and
    modular, and can easily write customized modules to extend its functionality even
    further.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于盐是用Python编写的，因此它具有高度的可扩展性和模块化，可以轻松编写自定义模块以进一步扩展其功能。
- en: It is crucial to understand that Salt is not just a configuration management
    tool, but in these chapters, we will be focusing on its configuration management
    capabilities due to the nature of the subject at hand. In the *Further reading*
    section, I will be adding several other book recommendations if you want to learn
    more about other Salt functionalities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理解盐不仅是一个配置管理工具至关重要，但在这些章节中，我们将专注于其配置管理能力，因为这是当前主题的性质。在“进一步阅读”部分，我将添加几本其他书籍推荐，如果您想了解更多关于盐的其他功能。
- en: The ways you define desired states in Salt, or in other words the languages
    that Salt supports, are varied. The main and default language is YAML with support
    for `Jinja` templating.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在盐中定义所需状态的方式，或者换句话说，盐支持的语言是多种多样的。主要和默认语言是YAML，支持Jinja模板。 '
- en: 'An example of a YAML definition to create a new user can be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新用户的YAML定义示例如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: YAML is a data-render language for Salt; data renders take definitions in the
    file and then transform them into Python data structures for Salt to consume.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是盐的数据渲染语言；数据渲染将文件中的定义转换为盐消耗的Python数据结构。
- en: 'The following are some other data-render languages that Salt supports:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是盐支持的其他数据渲染语言：
- en: '`dson`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dson
- en: '`hjson`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hjson
- en: '`json5`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json5
- en: '`json`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json
- en: '`pydsl`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pydsl
- en: '`pyobjects`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyobjects
- en: '`py`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: py
- en: '`stateconf`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stateconf
- en: '`yamlex`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: yamlex
- en: 'Salt has two types of renders. The first one is the one we just talked about:
    data-renders. The second one is the text render, which is the category `Jinja`
    falls into. This **text renders** instead of returning a Python data structure,
    they return text instead, which is later translated for the data render.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Salt有两种渲染类型。第一种是我们刚刚讨论的：数据渲染。第二种是文本渲染，这是`Jinja`所属的类别。这些**文本渲染**不是返回Python数据结构，而是返回文本，稍后会为数据渲染进行翻译。
- en: 'Text renders are useful for setting up variables or loops if we need to repeat
    several definitions with different values but the same structure. For example,
    instead of creating a YAML for each user, we could create a `Jinja` template and
    create several users with the same file, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文本渲染对于设置变量或循环非常有用，如果我们需要重复几个具有不同值但相同结构的定义。例如，我们可以创建一个`Jinja`模板，并使用相同的文件创建多个用户，而不是为每个用户创建一个YAML文件，如下所示：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example will create three users instead of creating one user by
    file or definition. This way is more efficient because we not only save time and
    work by not typing the same definition over and over again, we can also easily
    add more users if needed in the array, without having to create an entirely new
    file or definition for the extra user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例将创建三个用户，而不是通过文件或定义创建一个用户。这种方式更有效，因为我们不仅节省了时间和工作，而且不需要一遍又一遍地输入相同的定义，如果需要在数组中添加更多用户，也可以轻松实现，而不必为额外的用户创建全新的文件或定义。
- en: 'Besides `Jinja`, Salt text-renders support other templating engines, such as
    the following :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Jinja`，Salt文本渲染还支持其他模板引擎，例如以下：
- en: '`Cheetah`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cheetah`'
- en: '`Genshi`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Genshi`'
- en: '`GPG`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPG`'
- en: '`Jinja`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jinja`'
- en: '`Mako`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mako`'
- en: '`NaCl`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaCl`'
- en: '`Pass`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pass`'
- en: '`Py`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Py`'
- en: '`Wempy`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wempy`'
- en: We will be focusing on `Jinja` and YAML for the rest of the chapters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将专注于`Jinja`和YAML。
- en: The SaltStack platform
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SaltStack平台
- en: We previously talked about the different methods and approaches that IaC has.
    Salt is perfect for us to understand all of them because Salt uses both push and
    pull methods and also both **declarative** and **imperative** approaches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了IaC的不同方法和途径。Salt非常适合我们理解所有这些，因为Salt既使用推送和拉取方法，也同时使用**声明式**和**命令式**的方法。
- en: 'Let''s take an overview of Salt''s basic functionality:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一下Salt的基本功能：
- en: '![](img/d1d0cc5a-0093-4414-ae5e-e987537af5bb.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1d0cc5a-0093-4414-ae5e-e987537af5bb.png)'
- en: 'Like any other client/server cluster, Salt consists of two basic types of node:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他客户端/服务器集群一样，Salt由两种基本类型的节点组成：
- en: '**Master**: This server, or group of servers, is in charge of coordinating
    the minions and where they query for their desired states. Masters are also the
    ones that send the commands to be executed on minions.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Master**：这个服务器或服务器组负责协调minion，并在minion查询其所需状态时。主服务器也是发送要在minion上执行的命令的服务器。'
- en: '**Minion**: Servers managed by the master.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minion**：由主服务器管理的服务器。'
- en: 'The master server listens from two TCP ports: `4505` and `4506`. Both ports
    have very different roles and very different connection types.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 主服务器从两个TCP端口监听：`4505`和`4506`。这两个端口具有非常不同的角色和非常不同的连接类型。
- en: The `4505` port or **Publisher** is where all minions listen for messages from
    the master. The `4506` port or the **Request Server** is where minions request
    specific files or data directed directly through them through a secure way. Salt's
    network transport utilizes the ZeroMQ messaging queuing system, which uses **Elliptic
    Curve Cryptography** with 4,096-bit RSA keys that are generated in both the master
    and minions, as we will see later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`4505`端口或**发布者**是所有minion监听主服务器消息的地方。`4506`端口或**请求服务器**是minion通过安全方式直接请求特定文件或数据的地方。Salt的网络传输利用ZeroMQ消息队列系统，该系统使用**椭圆曲线加密**，使用在主服务器和minion中生成的4,096位RSA密钥，我们将在本章后面看到。'
- en: Salt is an agent-based tool and all communication between masters and minions
    is possible through the agent that is installed on the minions. Minions are in
    charge of initiating communications with the masters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Salt是一种基于代理的工具，主服务器和minion之间的所有通信都是通过安装在minion上的代理实现的。Minion负责与主服务器发起通信。
- en: This matters because, in a segmented network that might or might not have the
    internet in between, you will have many security boundaries between your masters
    and minions, and every minion may not have a unique address defined to it. In
    a scenario where the masters initiate the communications, all your minions in
    the stack might have to have a public IP address, or a lot of networking configuration
    and **network address translation** (**NAT**) has to be implemented every time
    you add a minion to be managed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为在可能或可能没有互联网的分段网络中，您的主服务器和minion之间会有许多安全边界，并且每个minion可能没有为其定义的唯一地址。在主服务器发起通信的情况下，您的堆栈中的所有minion可能都必须具有公共IP地址，或者每次添加要管理的minion时都必须实现大量的网络配置和**网络地址转换**（**NAT**）。
- en: Because of the way Salt communications work, you can have your masters in a
    DMZ zone with publicly addressable IP addresses, and all your minions connecting
    to those IPs. You will always have fewer masters than minions, and therefore the
    network configuration that needs to be implemented will decrease significantly.
    Salt is a highly scalable platform, where some stacks contain thousands of minions;
    imagine having to configure the network so that three or four masters can reach
    thousands of minions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Salt通信的方式，您可以将主服务器放在DMZ区域，具有公共可寻址的IP地址，并且所有minion连接到这些IP。您的主服务器将始终少于minion，因此需要实现的网络配置将大大减少。Salt是一个高度可扩展的平台，一些堆栈包含数千个minion；想象一下，必须配置网络以便三四个主服务器可以连接数千个minion。
- en: Having masters with public IPs can be scary, but remember that as long as you
    verify the RSA key fingerprints, you can be certain that all communications between
    the nodes are secured thanks to ZeroMQ's cryptography mechanisms.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有公共IP的主服务器可能会让人感到害怕，但请记住，只要验证RSA密钥指纹，您就可以确保节点之间的所有通信都得到了保护，这要归功于ZeroMQ的加密机制。
- en: Salt capabilities
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Salt功能
- en: After a brief overview of Salt's architecture, it is time to go through its
    different functionalities and capabilities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Salt的架构进行简要概述之后，现在是时候了解其不同的功能和能力了。
- en: Remote command execution modules
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程命令执行模块
- en: Remember that we said that Salt uses both push and pull methods alongside declarative
    and imperative approaches. The remote command execution feature is how we leverage
    Salt's push method in an imperative way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们说过Salt同时使用推送和拉取方法以及声明性和命令性方法。远程命令执行功能是我们如何以命令性方式利用Salt的推送方法。
- en: 'If you need to run a command in multiple minions or specific minions remotely,
    you will be using **execution modules**. Let''s take a look at a simple example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在多个随从或特定随从上远程运行命令，你将使用**执行模块**。让我们看一个简单的例子：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous command pushed an `ls` to the minions that are registered to the
    master. Let''s take a closer look at the commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令向注册到主服务器的随从推送了`ls`。让我们更仔细地看看这些命令：
- en: '`salt`: This is Salt''s most basic command to execute commands in parallel
    on remote minions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt`：这是Salt在远程随从上并行执行命令的最基本命令。'
- en: '`''*''`: Indicates that we will be running the command on all servers that
    are managed by our masters; you can also define specific targets.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''*''`：表示我们将在所有由我们的主服务器管理的服务器上运行该命令；你也可以定义特定的目标。'
- en: '`cmd.run`: The execution module to be invoked.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd.run`：要调用的执行模块。'
- en: '`''ls /home''`: The parameters of the execution module.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''ls /home''`：执行模块的参数。'
- en: '**Output**: Ordered by the minion''s name followed by the output of that server.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：按随从名称排序，后跟该服务器的输出。'
- en: Execution modules are the most basic form in which Salt uses its remote execution
    framework. Do you remember that Salt is written in Python? Well, execution modules
    are actually Python modules with a set of functions that serve a common purpose.
    Salt comes with several prebuilt modules that you can use, and you can even write
    your own modules and add them to your SaltStack platform. All execution modules
    are supposed to be distribution agnostic, but you can run into some that are not
    available in some distributions. Windows-specific modules are mostly defined by
    a starting `win_` at the beginning of the function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模块是Salt使用其远程执行框架的最基本形式。还记得我们说过Salt是用Python编写的吗？嗯，执行模块实际上是具有一组服务于共同目的的函数的Python模块。Salt附带了几个预构建模块，你可以使用它们，甚至可以编写自己的模块并将它们添加到你的SaltStack平台上。所有执行模块都应该是与发行版无关的，但你可能会遇到一些在某些发行版中不可用的模块。以`win_`开头的函数大多是特定于Windows的模块。
- en: 'In our previous example, we used the `cmd` module with the `run` function.
    The format in which we work with a function from a module involves defining the
    module to import followed by a period and the function. Whenever a function is
    called, Salt proceeds in the following way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了`cmd`模块的`run`函数。我们使用模块中的函数的格式涉及定义要导入的模块，后跟一个句点和函数。每当调用一个函数时，Salt都会按照以下方式进行：
- en: The Publisher port (`4505`) from the master in which the command was executed
    sends the command to the specified targets.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从执行命令的主服务器发送到指定目标的发布者端口（`4505`）。
- en: The targeted minions evaluate the command and decide whether they have to run
    the command.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标随从评估命令并决定是否要运行该命令。
- en: Minions that ran the command format the output and send it to the master's request
    server port (`4506`).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令的随从格式化输出并将其发送到主服务器的请求服务器端口（`4506`）。
- en: Knowing what execution modules are will not be enough for us to know what we
    have at our disposal. Many predefined modules are the ones most commonly used,
    and it's worth taking a look at them and what their main functions are.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 了解执行模块是不够的，我们还需要知道我们可以使用什么。许多预定义模块是最常用的，值得一看它们的主要功能是什么。
- en: The sys module
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sys模块
- en: 'This module is the equivalent of the `man` command. With `sys`, we can consult,
    list, and even check which argument accepts each function. You will find yourself
    using mostly the following functions of the `sys` module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块相当于`man`命令。使用`sys`，我们可以查询、列出，甚至检查每个函数接受哪些参数。你会发现自己主要使用`sys`模块的以下函数：
- en: '`list_modules`: This function will list the modules available to the target
    minion. It is important to note that execution modules are executed on the minions
    themselves and not in the master from where the command was executed.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_modules`：此函数将列出目标随从可用的模块。重要的是要注意，执行模块是在随从自身上执行的，而不是在执行命令的主服务器上。'
- en: '`list_functions`: With `list_functions`, you can list the available functions
    for a certain module.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_functions`：使用`list_functions`，你可以列出某个模块可用的函数。'
- en: '`argspec`: Lists available arguments and default values for the desired function.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argspec`：列出所需函数的可用参数和默认值。'
- en: 'Now we can run one of the preceding functions of the `sys` module to see a
    real example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`sys`模块的前述函数之一，看一个真实的例子：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The pkg module
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pkg模块
- en: Now that we have used a `pkg` function as an example for the `sys` module, I
    want to talk about the `pkg` module. This is another of the most common and used
    modules that Salt offers. This module handles all related package tasks, from
    installing and upgrading to deleting packages. As Salt tries to be as distro-agnostic
    as possible, the `pkg` module actually invokes a set of different modules and
    functions under the hood, specific to the distribution in which the module was
    invoked. For example, if a `pkg.install` was targeting Ubuntu-based systems when
    the minions receive the message, in reality the `aptpkg` module is the one that
    is going to be called in the minion. This is why `pkg` is called a **virtual module**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用了`pkg`函数作为`sys`模块的示例，我想谈谈`pkg`模块。这是Salt提供的另一个最常用的模块。该模块处理与包相关的所有任务，从安装和升级到删除包。由于Salt试图尽可能与发行版无关，`pkg`模块实际上在底层调用一组不同的模块和函数，这些模块和函数特定于调用模块的发行版。例如，如果`pkg.install`针对的是基于Ubuntu的系统，当随从收到消息时，实际上会调用`aptpkg`模块。这就是为什么`pkg`被称为**虚拟模块**。
- en: 'Some different modules invoked by `pkg` are the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg`调用的一些不同模块如下：'
- en: '`aptpkg`: For Debian distributions with `apt-get` package management.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aptpkg`：对于使用`apt-get`软件包管理的Debian发行版。'
- en: '`brew`: For macOS with Homebrew package management.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brew`：适用于使用Homebrew软件包管理的macOS。'
- en: '`yumpkg`: Red Hat-based distributions with `yum` or `dnf` as package managers.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yumpkg`：使用`yum`或`dnf`作为软件包管理器的基于Red Hat的发行版。'
- en: '`zypper`: For SUSE-based distributions with `zypper` as the package manager.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zypper`：对于使用`zypper`作为软件包管理器的基于SUSE的发行版。'
- en: 'The following is an example of installing the `nginx` web server with `pkg`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`pkg`安装`nginx` web服务器的示例：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test module
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模块
- en: Last, but not least, I want to talk to you about the **test module**. The test
    module will allow us to test our SaltStack platform. Things such as checking the
    health status of minions, the Salt version that they are running, and even just
    making them send an echo, are possible with the test module.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我想和你谈谈**测试模块**。测试模块将允许我们测试我们的SaltStack平台。例如，检查minions的健康状态、它们正在运行的Salt版本，甚至只是让它们发送一个回声，都是可能的。
- en: 'Different functions of the test module can be found with the `sys.list_functions`
    function, but it is worth mentioning some of the most common ones that you might
    use very frequently:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sys.list_functions`函数找到测试模块的不同功能，但值得一提的是，您可能会经常使用一些最常见的功能：
- en: '**ping**: The ping function tests for a response from the minions; this is
    not an ICMP ping command.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ping**：ping函数测试minions的响应；这不是一个ICMP ping命令。'
- en: '**version**: Returns Salt''s version of your minions.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**version**：返回您的minions的Salt版本。'
- en: '**versions_information**: Returns a full list of all of Salt''s dependencies,
    kernel version, distribution version, and Salt version.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**versions_information**：返回所有Salt依赖项、内核版本、发行版版本和Salt版本的完整列表。'
- en: Salt states
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盐状态
- en: 'Now that we know about the remote execution framework, we can start exploring
    the rest of the systems that Salt has to offer. The remote execution framework
    is the basis of something called the **state system**. The state system is a declarative
    and idempotent way that leverages IaC files to configure a minion''s desired state.
    The state system utilizes state modules that are much like execution modules but
    with the difference that Salt states actually check whether the desired configuration
    is already present in the minion. For example, let''s take a look at the following
    state definition:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了远程执行框架，我们可以开始探索Salt提供的其他系统。远程执行框架是所谓的**状态系统**的基础。状态系统是一种声明性和幂等的方式，利用IaC文件来配置minion的期望状态。状态系统利用状态模块，这些模块与执行模块非常相似，但不同之处在于Salt状态实际上会检查minion中是否已经存在所需的配置。例如，让我们看一下以下状态定义：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding state will install the `httpd` (Apache) package in targeted servers
    at runtime but only if the package is not present. If the package is not present,
    the state module will invoke the local `pkg.install` execution function and install
    the package in the minion(s).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述状态将在运行时在目标服务器上安装`httpd`（Apache）软件包，但仅当软件包不存在时。如果软件包不存在，状态模块将调用本地的`pkg.install`执行函数，并在minion(s)中安装软件包。
- en: Take a look at the fact that we `cat` that file from a `/srv/salt` directory. This
    directory is the default location of Salt's state directory tree where state definitions
    are placed. This directory is where you will be creating folders containing formulas,
    which are a set of Salt states that contain all the necessary configurations to
    deploy an application. For example, we can not only install `httpd`, we can also
    configure the virtual hosts and download the Git repos containing the actual websites
    that will be running on that Apache web server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们从`/srv/salt`目录中`cat`文件的事实。这个目录是盐状态目录树的默认位置，状态定义放在这里。在这个目录中，您将创建包含公式的文件夹，这些公式是一组包含部署应用程序所需的所有必要配置的盐状态。例如，我们不仅可以安装`httpd`，还可以配置虚拟主机并下载包含实际网站的Git存储库，这些网站将在Apache
    web服务器上运行。
- en: There is a set of rules that the directory tree follows for you to invoke state
    modules and run formulas, but this will be a subject for the [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*, where we will delve into configurations and actual
    usage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目录树遵循一组规则，以便您调用状态模块并运行公式，但这将是[第14章](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml)“Getting
    Your Hands Salty”的主题，届时我们将深入探讨配置和实际用法。
- en: Grains of Salt
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盐的特征
- en: We have learned that you can run execution modules by defining the minion name
    or via `*` when running on all minions. But running Salt states and execution
    modules on all the minions in the stack, or on individual minions, is less than
    ideal when you have hundreds or even thousands of minions being managed by your
    masters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了可以通过定义minion名称或通过`*`在所有minions上运行执行模块。但是，当您的主服务器管理数百甚至数千个minions时，在整个堆栈上或在单个minions上运行Salt状态和执行模块并不理想。
- en: Here is where Salt introduces the `grains` interface, which allows us to identify
    minions by specific characteristics or even set our own type of label or role
    to a group of minions that share a same purpose or characteristics, so we can
    perform more targeted configuration management.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Salt引入了`grains`接口，它允许我们通过特定特征识别minions，甚至为共享相同目的或特征的minions设置自己的标签或角色类型，因此我们可以执行更有针对性的配置管理。
- en: 'We can leverage the `grains` interface with the same syntax in which we would
    execute any command in Salt:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`grains`接口，使用与在Salt中执行任何命令相同的语法：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the preceding command, we list all the different hardware and software
    characteristics of the system that we targeted. In the output, we can see things
    such as the operating system family, the system architecture, and even the hypervisor
    that we are using to run the VM.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述命令，我们列出了我们所针对的系统的所有不同的硬件和软件特征。在输出中，我们可以看到诸如操作系统系列、系统架构，甚至我们用来运行VM的hypervisor等信息。
- en: 'This will help us to create state definitions targeting specific systems via
    something called a `top` file, which we will discuss in the [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*. An example of a Salt state top file definition using
    `grains` and targeting all `Debian` family VMs will look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As mentioned before, we can also create custom `grains` in our minions to define
    roles and tag our minions with unique value pairs. This is useful for grouping
    minions in specific tasks; for example, all the VMs of the QA team can be tagged
    with a key value pair, `departement: qa`, for example. Another way of grouping
    could be by role, such as `appfoo: frontend`, and so on. There are many ways to
    use grain targeting, and all will depend on how we want to administer or push
    and maintain the desired states.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Salt pillars
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With **grains**, we can target specific minions, but at the end, we defined
    those targeting policies that are in the top files, which form part of a formula.
    Formulas are usually stored in Git repositories and sometimes even in public ones.
    That's why we can't, or rather we shouldn't, declare sensitive information in
    Salt states. The same happens with Dockerfiles as we saw in our previous chapters,
    and Kubernetes solves this with the **Secrets** API object. Salt has its own version
    of secrets and it's called **Pillars**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Unlike grains, pillars are stored in the masters instead of the minions. Only
    minions that are targeted by the pillar will have access to the information in
    the pillar. This, again, makes it perfect for sensitive information. When storing
    sensitive information, pillars can also be encrypted at rest, and thanks to Salt's
    render system, pillars will be decrypted during pillar compilation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Pillars decreases the surface area of sensitive data by only storing it in
    the master:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44ef113-4680-4ff0-9da5-1e8e641f4288.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: With Salt pillars, we finish our brief overview of the basic components that
    the SaltStack platform has to offer. We will be discussing them in more depth
    and working with real-life examples in [Chapter 14](70b68225-f724-4ff8-a1bf-84c77ad23a2b.xhtml),
    *Getting Your Hands Salty*, so you can get hands-on and start managing systems
    through Salt.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the different problems that businesses face when
    it comes to maintaining their infrastructures. We went through different technologies
    such as IaC and centralized system management. We went through the different methods
    whereby IaC **pushes** or **pulls** changes into managed systems and learned about
    several applications that leverage IaC.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed what Salt is and its different components that help us achieve
    a centralized managed infrastructure.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to design a Salt solution and install
    the software.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is systems management?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the challenges behind systems' management?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What applications can help us with system management?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Infrastructure as Code?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of method with which we can manage our systems?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Salt?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Salt's different components?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gartner**: ''**Every budget is an IT budget**'''
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forrester:** [https://www.forrester.com/report/Cloud+Investments+Will+Reconfigure+Future+IT+Budgets/-/E-RES83041#](https://www.forrester.com/report/Cloud+Investments+Will+Reconfigure+Future+IT+Budgets/-/E-RES83041#)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative vs. Imperative Models for Configuration Management**: [https://www.upguard.com/blog/articles/declarative-vs.-imperative-models-for-configuration-management](https://www.upguard.com/blog/articles/declarative-vs.-imperative-models-for-configuration-management)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SALTSTACK**: [https://s.saltstack.com/beyond-configuration-management/](https://s.saltstack.com/beyond-configuration-management/)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Salt Configuration Management**: [https://red45.wordpress.com/2011/05/29/salt-configuration-management/](https://red45.wordpress.com/2011/05/29/salt-configuration-management/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salt配置管理：[https://red45.wordpress.com/2011/05/29/salt-configuration-management/](https://red45.wordpress.com/2011/05/29/salt-configuration-management/)
- en: '**Renderers**: [https://docs.saltstack.com/en/latest/ref/renderers/](https://docs.saltstack.com/en/latest/ref/renderers/)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器：[https://docs.saltstack.com/en/latest/ref/renderers/](https://docs.saltstack.com/en/latest/ref/renderers/)
- en: '**Remote Execution**: [https://docs.saltstack.com/en/getstarted/system/execution.html](https://docs.saltstack.com/en/getstarted/system/execution.html)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程执行：[https://docs.saltstack.com/en/getstarted/system/execution.html](https://docs.saltstack.com/en/getstarted/system/execution.html)
- en: '**Targeting using grains**: [https://docs.saltstack.com/en/latest/topics/targeting/grains.html](https://docs.saltstack.com/en/latest/topics/targeting/grains.html)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用grains进行目标定位：[https://docs.saltstack.com/en/latest/topics/targeting/grains.html](https://docs.saltstack.com/en/latest/topics/targeting/grains.html)
- en: '**Grains**: [https://docs.saltstack.com/en/latest/topics/grains/](https://docs.saltstack.com/en/latest/topics/grains/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grains：[https://docs.saltstack.com/en/latest/topics/grains/](https://docs.saltstack.com/en/latest/topics/grains/)
- en: '**Functions**: [https://docs.saltstack.com/en/getstarted/config/functions.html](https://docs.saltstack.com/en/getstarted/config/functions.html)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数：[https://docs.saltstack.com/en/getstarted/config/functions.html](https://docs.saltstack.com/en/getstarted/config/functions.html)

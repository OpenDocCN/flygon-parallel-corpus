- en: Adding an API Description Using OpenAPI/Swagger
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenAPI/Swagger添加API描述
- en: The value of an API, such as a RESTful service, to a large extent depends on
    how easy it is to consume! Good and easily accessible documentation is an important
    part of whether an API is useful. In this chapter, we will learn how we can use
    OpenAPI/Swagger to document APIs that we can make externally accessible from a
    microservice landscape.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: API的价值，例如RESTful服务，很大程度上取决于其易于使用的程度！良好且易于访问的文档是API是否有用的重要组成部分。在本章中，我们将学习如何使用OpenAPI/Swagger来记录我们可以从微服务架构中外部访问的API。
- en: As we mentioned in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml), *Introduction
    to Spring Boot*, Swagger is one of the most commonly used specifications when
    it comes to documenting RESTful services, and many of the leading API gateways
    have native support for Swagger. We will learn how to use SpringFox to produce
    such documentation, the kind of changes in source code required to document the
    eternal API using SpringFox. We will try out Swagger documentation, which shows
    how to use an embedded Swagger viewer to both inspect the documentation and to
    try out the API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml)中提到的，*Spring Boot简介*，Swagger是在记录RESTful服务时最常用的规范之一，许多主要的API网关都原生支持Swagger。我们将学习如何使用SpringFox来生成这样的文档，以及使用SpringFox记录外部API所需的源代码更改。我们将尝试Swagger文档，其中显示如何使用内嵌的Swagger查看器来检查文档并尝试API。
- en: By the end of this chapter, we will have Swagger-based API documentation about
    the external API that's exposed by the `product-composite-service` microservice.
    We will be able to use an embedded Swagger viewer to both visualize and test the
    API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有关于`product-composite-service`微服务所暴露的外部API的基于Swagger的API文档。我们将能够使用内嵌的Swagger查看器来可视化和测试API。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to using SpringFox
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SpringFox的介绍
- en: Changes in the source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码的更改
- en: Building and starting the microservice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和启动微服务
- en: Trying out the Swagger documentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试Swagger文档
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave, but should be straightforward to modify if you want to run
    them on another platform such as Linux or Windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在使用macOS Mojave的MacBook Pro上运行的，但如果您想在其他平台（如Linux或Windows）上运行它们，应该很容易进行修改。
- en: No new tools need to be installed before you can work through this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成本章之前，无需安装新工具。
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行本书中描述的命令，请下载源代码到一个文件夹，并设置一个指向该文件夹的环境变量`$BOOK_HOME`。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code in this book has been written for Java 8 and tested on
    Java 12. This chapter uses Spring Boot 2.1.0 (and Spring 5.1.2), which is the
    latest available version of Spring Boot at the time of writing this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的Java源代码是针对Java 8编写的，并在Java 12上进行了测试。本章使用的是Spring Boot 2.1.0（和Spring 5.1.2），这是撰写本章时可用的最新版本的Spring
    Boot。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter05` but
    have been, in many cases, edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter05`中的源代码，但在许多情况下已经进行了编辑，以删除源代码中的无关部分，如注释、导入和日志语句。
- en: If you want to view the changes that were applied to the source code in this
    chapter, that is, see what it took to create Swagger-based API documentation using
    SpringFox, you can compare it with the source code for [Chapter 4](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml),
    *Deploying Our Microservices Using Docker*. You can use your favorite `diff` tool
    and compare the two folders, that is, `$BOOK_HOME/Chapter04` and `$BOOK_HOME/Chapter05`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看本章应用于源代码的更改，即查看使用SpringFox创建基于Swagger的API文档所需的步骤，您可以将其与[第4章](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml)的源代码进行比较，即*使用Docker部署我们的微服务*。您可以使用您喜欢的`diff`工具比较两个文件夹，即`$BOOK_HOME/Chapter04`和`$BOOK_HOME/Chapter05`。
- en: Introduction to using SpringFox
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SpringFox的介绍
- en: SpringFox makes it possible to keep the documentation of the API together with
    the source code that implements the API. To me, this is an important feature.
    If the API documentation is maintained in a separate life cycle from the Java
    source code, they will diverge from each other over time. In many cases, this
    is sooner than expected (from my experience). As always, it is important to separate
    the interface of a component from its implementation. In terms of documenting
    a RESTful API, we should add the API documentation to the Java interface that
    describes the API, and not to the Java class that implements the API. To simplify
    updating the documentation of the API, we can place parts of the documentation
    in property files instead of in the Java code directly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox使得将API文档与实现API的源代码保持在一起成为可能。对我来说，这是一个重要的特性。如果API文档与Java源代码的生命周期分开维护，它们将随着时间的推移而分歧。在许多情况下，这比预期的要早（根据我的经验）。重要的是要将组件的接口与其实现分开。在记录RESTful
    API方面，我们应该将API文档添加到描述API的Java接口中，而不是添加到实现API的Java类中。为了简化更新API文档，我们可以将文档的部分放在属性文件中，而不是直接放在Java代码中。
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the OpenAPI Initiative and created the OpenAPI Specification. To create
    the API documentation, we will use **SpringFox**, which can create Swagger-based
    API documentation at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，SmartBear Software将Swagger规范捐赠给了Linux基金会的OpenAPI计划，并创建了OpenAPI规范。为了创建API文档，我们将使用**SpringFox**，它可以在运行时创建基于Swagger的API文档。
- en: 'It does this based on a configuration that we supply and by inspecting annotations
    that have been provided by Spring WebFlux and Swagger:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它是基于我们提供的配置和检查Spring WebFlux和Swagger提供的注释来实现这一点：
- en: '![](img/4b24888c-15c8-42ed-8f85-99bff144857c.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b24888c-15c8-42ed-8f85-99bff144857c.png)'
- en: Support for OpenAPI has been planned for v3 of SpringFox. SpringFox V3 was still
    under development at the time of writing this chapter, so we will use a snapshot
    version of SpringFox V3 and create the API documentation based on Swagger V2\.
    Once SpringFox V3 has been released, the source code for this book will be updated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SpringFox的v3版本已经计划支持OpenAPI。在撰写本章时，SpringFox V3仍在开发中，因此我们将使用SpringFox V3的快照版本，并基于Swagger
    V2创建API文档。一旦SpringFox V3发布，本书的源代码将进行更新。
- en: To enable SpringFox so that we can create the API documentation, we will set
    up a base configuration for SpringFox and add annotations to the Java interfaces
    that define the RESTful services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用SpringFox，以便我们可以创建API文档，我们将为SpringFox设置一个基本配置，并向定义RESTful服务的Java接口添加注释。
- en: If parts of the documentation have been placed in property files to simplify
    updating the API documentation, it is important that the property files are handled
    in the same life cycle and under the same version control as the source code,
    otherwise there is a risk that they will start to diverge from the implementation,
    that is, become out of date.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档的部分已放置在属性文件中，以简化更新API文档，那么重要的是属性文件与源代码具有相同的生命周期并受到相同的版本控制，否则有可能它们将开始与实现分歧，即变得过时。
- en: Changes in the source code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的更改
- en: 'To add Swagger-based documentation about the external API that''s exposed by
    the `product-composite-service` microservice, we need to change the source code
    in two modules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加关于`product-composite-service`微服务所公开的外部API的基于Swagger的文档，我们需要更改两个模块的源代码：
- en: '`product-composite-services`: Here, we will set up a SpringFox configuration
    in the Java application class, `ProductCompositeServiceApplication`, and describe
    general information about the API.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite-services`：在这里，我们将在Java应用程序类`ProductCompositeServiceApplication`中设置SpringFox配置，并描述有关API的一般信息。'
- en: '`api`: Here, we will add Swagger annotations to the Java interface, `ProductCompositeService`,
    describing each RESTful service. At this stage, we only have one RESTful service, `/product-composite/{productId}`,
    which is used for requesting composite information regarding a specific product.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`：在这里，我们将向Java接口`ProductCompositeService`添加Swagger注释，描述每个RESTful服务。在这个阶段，我们只有一个RESTful服务，即`/product-composite/{productId}`，用于请求有关特定产品的组合信息。'
- en: The actual texts that are used to describe the API operation will be placed
    in the default property file, `application.yml`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用于描述API操作的实际文本将放在默认属性文件`application.yml`中。
- en: Before we can start using SpringFox, we need to add it as a dependency in the
    Gradle build files. So, let's start with that!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用SpringFox之前，我们需要在Gradle构建文件中将其添加为依赖项。所以，让我们从那里开始！
- en: Adding dependencies to the Gradle build files
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Gradle构建文件添加依赖项
- en: 'As we mentioned previously, we will use a snapshot version of SpringFox V3\.
    The SpringFox product is divided into a number of modules. The modules that we
    need to specify dependencies are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将使用SpringFox V3的快照版本。SpringFox产品分为多个模块。我们需要指定依赖项的模块如下：
- en: '`springfox-swagger2`, so that we can create Swagger 2-based documentation'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springfox-swagger2`，以便我们可以创建基于Swagger 2的文档'
- en: '`springfox-spring-webflux`, so that we can support the use of Spring WebFlux-based
    RESTful operations'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springfox-spring-webflux`，以便我们可以支持基于Spring WebFlux的RESTful操作'
- en: '`springfox-swagger-ui`, so that we can embed a Swagger viewer in our microservice'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springfox-swagger-ui`，以便我们可以在我们的微服务中嵌入Swagger查看器'
- en: 'We can add these to the Gradle build file, `build.gradle`, for the `product-composite-service` module
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些添加到`product-composite-service`模块的Gradle构建文件`build.gradle`中，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `api` project only needs one dependency for the `springfox-swagger2` module,
    and so only the following dependency needs to be added to its `build.gradle` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`项目只需要`springfox-swagger2`模块的一个依赖项，因此只需要将以下依赖项添加到其`build.gradle`文件中：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The SpringFox project publishes snapshot builds in the Maven repository ([http://oss.jfrog.org/artifactory/oss-snapshot-local/](http://oss.jfrog.org/artifactory/oss-snapshot-local/)),
    so we need to add that as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox项目在Maven存储库中发布快照版本（[http://oss.jfrog.org/artifactory/oss-snapshot-local/](http://oss.jfrog.org/artifactory/oss-snapshot-local/)），因此我们也需要添加它：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To be able to build the core modules, that is, `product-service`, `recommendation-service`,
    and `review-service`, we need to add the Maven repository to their Gradle build
    files, `build.gradle`, as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建核心模块，即`product-service`，`recommendation-service`和`review-service`，我们需要将Maven存储库添加到它们的Gradle构建文件`build.gradle`中。
- en: Adding configuration and general API documentation to Product Composite Service
    Application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Product Composite Service Application添加配置和通用API文档
- en: To enable SpringFox in the `product-composite-service` microservice, we have
    to add a configuration. To keep the source code compact, we will add it directly
    to the `ProductCompositeServiceApplication` application class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`product-composite-service`微服务中启用SpringFox，我们必须添加一个配置。为了保持源代码的紧凑性，我们将直接将其添加到`ProductCompositeServiceApplication`应用程序类中。
- en: If you prefer, you can place the configuration of SpringFox in a separate Spring
    configuration class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以将SpringFox的配置放在一个单独的Spring配置类中。
- en: First, we need to add the `@EnableSwagger2WebFlux` annotation in order to get
    SpringFox to generate Swagger V2 documentation for our RESTful services, which
    is implemented using Spring WebFlux. Next, we need to define a Spring Bean that
    returns a SpringFox `Docket` bean, which is used to configure SpringFox.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加`@EnableSwagger2WebFlux`注解，以便让SpringFox为我们使用Spring WebFlux实现的RESTful服务生成Swagger
    V2文档。接下来，我们需要定义一个返回SpringFox `Docket` bean的Spring Bean，用于配置SpringFox。
- en: 'The source code that we will be adding to `$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplication.java`
    looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到`$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplication.java`的源代码如下：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From the preceding code, we can understand the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们可以理解以下内容：
- en: The `@EnableSwagger2WebFlux` annotation is the starting point for initiating
    SpringFox.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableSwagger2WebFlux`注解是启动SpringFox的起点。'
- en: The `Docket` bean is initiated to create Swagger V2 documentation.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docket` bean被初始化以创建Swagger V2文档。'
- en: Using the `apis()` and `paths()` methods, we can specify where SpringFox shall
    look for API documentation.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`apis()`和`paths()`方法，我们可以指定SpringFox应该在哪里查找API文档。
- en: Using the `globalResponseMessage()` method, we ask SpringFox not to add any
    default HTTP response codes to the API documentation, such as `401` and `403`,
    which we don't currently use.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`globalResponseMessage()`方法，我们要求SpringFox不要向API文档添加任何默认的HTTP响应代码，例如`401`和`403`，我们目前不使用。
- en: 'The `api*` variables that are used to configure the `Docket` bean with general
    information about the API are initialized from the property file using Spring
    `@Value` annotations. These are as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于使用Spring的`@Value`注解从属性文件初始化`Docket` bean的`api*`变量如下：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After adding a configuration and API documentation, we can now proceed to understand
    how to add an API specific documentation to ProductCompositeService.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加配置和API文档之后，我们现在可以继续了解如何向ProductCompositeService添加特定于API的文档。
- en: Adding API-specific documentation to ProductCompositeService
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向ProductCompositeService添加特定于API的文档
- en: To document the actual API, `ProductCompositeService`, and its RESTful operations,
    we will add an `@Api` annotation to the Java interface declaration so that we
    can provide a general description of the API. For each RESTful operation in the
    API, we will add an `@ApiOperation` annotation, along with `@ApiResponse` annotations
    on the corresponding Java method, to describe the operation and its expected error
    responses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录实际的API，`ProductCompositeService`及其RESTful操作，我们将在Java接口声明中添加`@Api`注解，以便我们可以提供API的一般描述。对于API中的每个RESTful操作，我们将在相应的Java方法上添加`@ApiOperation`注解，以及`@ApiResponse`注解，以描述操作及其预期的错误响应。
- en: SpringFox will inspect the `@GetMapping` Spring annotation to understand what
    input argument the operation takes and what the response will look like if a successful response
    is produced.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox将检查`@GetMapping` Spring注解，以了解操作接受什么输入参数，以及如果产生成功的响应，响应将是什么样子。
- en: In the following example, we have extracted the actual text from the `@ApiOperation` annotation to
    a property file. The annotation contains property placeholders that SpringFox
    will use to look up the actual text from the property files at runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们从`@ApiOperation`注解中提取了实际文本到属性文件。该注解包含属性占位符，SpringFox将在运行时从属性文件中查找实际文本。
- en: 'The documentation of the API on the resource level appears as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源级别的API文档如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The single API operation is documented as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单个API操作的文档如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the values specified in the `@ApiOperation` Swagger annotation, we can use
    property placeholders directly, without using Spring `@Value` annotations. For
    the description of the expected `ApiResponses`, that is, the expected error codes,
    SpringFox currently does not support the use of property placeholders, so in this
    case, the actual text describing each error code is placed directly in the Java
    source code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@ApiOperation`Swagger注解中指定的值，我们可以直接使用属性占位符，而不使用Spring的`@Value`注解。对于预期的`ApiResponses`的描述，即预期的错误代码，SpringFox目前不支持使用属性占位符，因此在这种情况下，描述每个错误代码的实际文本直接放在Java源代码中。
- en: For details, see `$BOOK_HOME/Chapter05/api/src/main/java/se/magnus/api/composite/product/ProductCompositeService.java`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅`$BOOK_HOME/Chapter05/api/src/main/java/se/magnus/api/composite/product/ProductCompositeService.java`。
- en: Adding textual descriptions of the API to the property file
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将API的文本描述添加到属性文件
- en: 'Finally, we need to add the textual descriptions of the API to the property
    file, `application.yml`. Here, we have `@Value` annotations, which look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将API的文本描述添加到属性文件`application.yml`中。在这里，我们有`@Value`注解，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each `@Value` annotation, we need to specify a corresponding property in
    the YAML file; for example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`@Value`注解，我们需要在YAML文件中指定相应的属性；例如：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the same way, we have Swagger annotations, which look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们有Swagger注解，看起来如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These expect a corresponding property in the YAML file; for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些期望在YAML文件中有相应的属性；例如：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to find out more about how a YAML file is constructed, view the
    specification: [https://yaml.org/spec/1.2/spec.html](https://yaml.org/spec/1.2/spec.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关如何构建YAML文件的更多信息，请查看规范：[https://yaml.org/spec/1.2/spec.html](https://yaml.org/spec/1.2/spec.html)。
- en: 'First, the general description of the API, which is configured in the SpringFox
    `Docket` bean, is described as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置在SpringFox `Docket` bean中的API的一般描述如下：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, a detailed description of the actual API operation is given:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给出了实际API操作的详细描述：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that SpringFox supports providing a multiline description of an API operation
    using markdown syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SpringFox支持使用markdown语法提供API操作的多行描述。
- en: For more details, see `$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/resources/application.yml`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅`$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/resources/application.yml`。
- en: Building and starting the microservice landscape
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和启动微服务架构
- en: Before we can try out the Swagger documentation, we need to build and start
    the microservice landscape!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试Swagger文档之前，我们需要构建和启动微服务架构！
- en: 'This can be done with the following commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令完成：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may run into an error message regarding port `8080` already being allocated.
    This will look as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到有关端口`8080`已被分配的错误消息。这将如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If this is the case, you might have forgotten to bring down the microservice
    landscape from the previous chapter. To find out the names of the executing containers,
    run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，您可能忘记了从上一章带下来的微服务架构。要找出正在执行的容器的名称，请运行以下命令：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A sample response when a microservice landscape from the previous chapter is
    still running is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一章的微服务架构仍在运行，则示例响应如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you find containers from other chapters in the output from the command,
    for example, from [Chapter 4](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml), *Deploying
    Our Microservices Using Docker*, as in the preceding example, you need to jump
    over to that chapter and bring down the containers for that chapter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在命令的输出中找到来自其他章节的容器，例如来自[第4章](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml)的容器，*使用Docker部署我们的微服务*，就像前面的例子一样，您需要跳转到该章节并关闭该章节的容器：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you can bring up the missing container for this chapter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以打开本章缺失的容器：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that only the missing container, `product-composite`, is started by the
    command since the other ones were already started successfully:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令只启动了缺失的容器`product-composite`，因为其他容器已经成功启动：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To wait for the microservice landscape to startup and verify that it works,
    you can run the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 等待微服务架构启动并验证其工作是否正常，您可以运行以下命令：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The successful start-up of this microservice helps us understand its landscape
    better and also aids in understanding the Swagger documentation which  we are
    about to study in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务的成功启动有助于我们更好地了解它的架构，并有助于理解我们将在下一节中学习的Swagger文档。
- en: Trying out the Swagger documentation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试Swagger文档
- en: 'To browse the Swagger documentation, we will use the embedded Swagger viewer.
    If we open the `http://localhost:8080/swagger-ui.html` URL in a web browser, we
    will see a web page that looks something like the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览Swagger文档，我们将使用内嵌的Swagger查看器。如果我们在Web浏览器中打开`http://localhost:8080/swagger-ui.html`
    URL，我们将看到一个类似以下截图的网页：
- en: '![](img/eb92fdb1-5db9-4a87-92d4-7c71147b6608.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb92fdb1-5db9-4a87-92d4-7c71147b6608.png)'
- en: 'Here, we can find the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以找到以下内容：
- en: The general information we specified in the SpringFox `Docket` bean and a link
    to the actual Swagger document, `http://localhost:8080/v2/api-docs`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在SpringFox `Docket` bean中指定的一般信息和实际Swagger文档的链接，`http://localhost:8080/v2/api-docs`
- en: A list of API resources; in our case, the `product-composite-service` API
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API资源列表；在我们的案例中是`product-composite-service` API
- en: At the bottom of the page, there is a section where we can inspect the models
    that are used in the API
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面底部，有一个部分，我们可以检查API中使用的模型
- en: 'This is how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：
- en: Click on the `product-composite-service` API resource to expand it. You will
    get a list of operations that are available on the resource.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`product-composite-service` API资源以展开它。您将获得可用于该资源的操作列表。
- en: 'You will only see one operation, /product-composite/{productId}. Click on it
    to expand it. You will see the documentation of the operation that we specified
    in the `ProductCompositeService` Java interface:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只会看到一个操作，即`/product-composite/{productId}`。点击它以展开它。您将看到我们在`ProductCompositeService`
    Java接口中指定的操作的文档：
- en: '![](img/8cfce8b6-7453-449a-a9ef-2e09eaa283fa.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cfce8b6-7453-449a-a9ef-2e09eaa283fa.png)'
- en: 'Here, we can see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到以下内容：
- en: The one-line description of the operation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的一行描述。
- en: A section with details regarding the operation, including the input parameters
    it supports. Note how the markdown syntax from the `notes` field in the `@ApiOperation`
    annotation has been nicely rendered!
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含有关操作的详细信息，包括它支持的输入参数。请注意`@ApiOperation`注释中的`notes`字段中的markdown语法已经很好地呈现出来！
- en: 'If you scroll down the web page, you will also find documentation regarding
    the expected responses, both a normal 200 response and the various 4xx error responses
    we defined, as shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下滚动网页，您还将找到有关预期响应的文档，包括正常的200响应和我们定义的各种4xx错误响应，如下截图所示：
- en: '![](img/552a2eb1-0907-4982-9bea-1c27987a129f.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/552a2eb1-0907-4982-9bea-1c27987a129f.png)'
- en: 'If we scroll back up to the parameter description, we will find the Try it
    out! button. If we click on that, we can fill in actual parameter values and send
    a request to the API by clicking on the Execute button. For example, if we put
    in productId `123`, we will get the following response:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向上滚动到参数描述，我们将找到“试一下！”按钮。如果我们点击它，我们可以填写实际的参数值，并通过点击“执行”按钮向API发送请求。例如，如果我们输入`productId`为`123`，我们将得到以下响应：
- en: '![](img/25e34f7c-852a-407f-a9ad-c7963c7808bb.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25e34f7c-852a-407f-a9ad-c7963c7808bb.png)'
- en: We will get an expected 200 (OK) as the response code and a JSON structure in
    the response body that we already are familiar with!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个预期的200（OK）作为响应代码，并且在响应体中已经熟悉的JSON结构！
- en: 'If we enter an incorrect input, such as `-1`, we will get a proper error code
    as the response code and a corresponding JSON-based error description in the response
    body:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入不正确的输入，例如`-1`，我们将得到一个正确的错误代码作为响应代码，并且在响应体中得到相应的基于JSON的错误描述：
- en: '![](img/3361c3ba-305c-4950-8454-afea6db7d2e4.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3361c3ba-305c-4950-8454-afea6db7d2e4.png)'
- en: 'If you want to try out calling the API without using the Swagger UI, you can
    copy the corresponding `curl` command from the response section and run it in
    a Terminal window! Look at the following by way of an example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试调用API而不使用Swagger UI，你可以从响应部分复制相应的`curl`命令，并在终端窗口中运行它！举个例子：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great, isn't it?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了，不是吗？
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Good documenting of an API is essential for its acceptance, and Swagger is one
    of the most commonly used specifications when it comes to documenting RESTful
    services. SpringFox is an opensource project that makes it possible to create
    Swagger-based API documentation on the fly at runtime by inspecting Spring WebFlux
    and Swagger annotations. Textual descriptions of an API can be extracted from
    the annotations in the Java source code and be placed in a property file for ease
    of editing. SpringFox can be configured to bring in an embedded Swagger viewer
    to a microservice, which makes it very easy to read about APIs that have been
    exposed by the microservice and also try them out from the viewer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的API文档对于其被接受是至关重要的，而Swagger是在记录RESTful服务时最常用的规范之一。SpringFox是一个开源项目，它可以通过检查Spring
    WebFlux和Swagger注解，在运行时动态创建基于Swagger的API文档。API的文本描述可以从Java源代码的注解中提取，并放在属性文件中以便编辑。SpringFox可以配置为将嵌入式Swagger查看器引入微服务，这样就可以很容易地阅读由微服务暴露的API，并且还可以从查看器中尝试它们。
- en: Now, what about bringing some life to our microservices by adding persistence,
    that is, the capability to save data in a database? To do this, we need to add
    some more APIs so that we can create and delete the information that's handled
    by the microservices. Head over to the next chapter to find out more!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加持久性来为我们的微服务注入一些生命力，也就是说，能够在数据库中保存数据的能力？为此，我们需要添加一些更多的API，以便我们可以创建和删除由微服务处理的信息。前往下一章了解更多信息！
- en: Questions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does SpringFox help us create API documentation for RESTful services?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringFox如何帮助我们为RESTful服务创建API文档？
- en: What specifications for documenting APIs does SpringFox support?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringFox支持哪些用于记录API的规范？
- en: What is the purpose of the SpringFox `Docket` bean?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringFox的`Docket` bean的目的是什么？
- en: Name some annotations that SpringFox reads at runtime to create the API documentation
    on the fly!
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些SpringFox在运行时读取的注解，以便动态创建API文档！
- en: 'What does `: |` mean in a YAML file?'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在YAML文件中，`: |`代表什么意思？'
- en: How can you repeat a call to an API that was performed using the embedded Swagger
    viewer without using the viewer again?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不再使用查看器的情况下重复调用使用嵌入式Swagger查看器执行的API？

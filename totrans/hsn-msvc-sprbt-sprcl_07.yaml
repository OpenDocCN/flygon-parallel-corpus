- en: Adding Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to persist data that a microservice is using. As
    already mentioned in [Chapter 2](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Spring Boot*, we will use the Spring Data project to persist
    data to MongoDB and MySQL databases. The `project` and `recommendation` microservices
    will use Spring Data for MongoDB and the `review` microservice will use Spring
    Data for the **JPA** (short for the **Java Persistence API**) to access a MySQL
    database. We will add operations to the RESTful APIs to be able to create and
    delete data in the databases. The existing APIs for reading data will be updated
    to access the databases. We will run the databases as Docker containers, managed
    by Docker Compose, that is, in the same way as we run our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a persistence layer to the core microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing automated tests that focus on persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the persistence layer in the service layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the composite service API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding databases to the Docker Compose landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing of the new APIs and the persistence layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the automated tests of the microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but should be straightforward to modify to run on another platform such as Linux
    or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To access the databases manually, we will use the CLI tools provided in the
    Docker images used to run the databases. We will, however, expose the standard
    ports used for each database in Docker Compose—`3306` for MySQL and `27017` for
    MongoDB. This will enable you to use your local favorite database tools for accessing
    the databases in the same way as if they were running locally on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Following are some sample commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Boot 2.1.0 (and Spring 5.1.2)—the latest available version of Spring
    Boot at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter06` but
    are, in many cases, edited to remove non-relevant parts of the source code, such
    as comments and import and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes applied to the source code in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),* Adding
    Persistence*, which sees what it took to add persistence to the microservices
    using Spring Data, you can compare it with the source code for [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding API Description Using OpenAPI/Swagger*. You can use your favorite diff tool
    and compare the two folders, `$BOOK_HOME/Chapter05` and `$BOOK_HOME/Chapter06`.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's see where we are heading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have layers inside our microservices that
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148fd8fc-30e4-4039-986a-554a4237bb7c.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Protocol layer** is very thin, only consisting of `RestController` annotations
    and the common `GlobalControllerExceptionHandler`. The main functionality of each
    microservice resides in the service layers. The `product-composite` service contains
    an integration layer to communicate with the three core microservices. The core microservices
    will all have a **Persistence layer** used for communicating with their databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be able to see data stored in MongoDB with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/396be685-3e82-4fc9-b871-3b6e72c7f6d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Regarding data stored in MySQL, we will be able to see it with a command like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05445cec-486e-426e-8b16-b611e61649e5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note:** The output from the `mongo` and `mysql` commands have been shortened
    for improved readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to go about this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a persistence layer to the core microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with adding a persistence layer to the core microservices. Besides
    using Spring Data, we will also use a Java bean mapping tool, MapStruct, that
    makes it easy to transform between Spring Data entity objects and the API model
    classes. For further details, see [http://mapstruct.org/](http://mapstruct.org/).
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add dependencies to MapStruct, Spring Data, and the JDBC drivers
    for the databases we intend to use. After that, we can define our Spring Data
    entity classes and repositories. The Spring Data entity classes and repositories
    will be placed in their own Java package, `persistence`. For example, for the
    product microservice, they will be placed in the Java package, `se.magnus.microservices.core.product.persistence`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use MapStruct V1.3.0-Beta 2, so we start by defining a variable holding
    the version information in the build file for each core microservice, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare a dependency on MapStruct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since MapStruct generates the implementation of the bean mappings at compile
    time by processing MapStruct annotations, we need to add an `annotationProcessor` and
    a `testAnnotationProcessor` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the compile-time generation work in popular IDEs such as IntelliJ IDEA,
    we also need to add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you are using IntelliJ IDEA, you also need to ensure that support for annotation
    processing is enabled. Open Preferences and navigate to Build, Execute, Deployment |
    Compiler | Annotations Processors. Verify that the checkbox named Enable annotation
    processing is selected!
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `project` and `recommendation` microservices, we declare the following
    dependencies to Spring Data for MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The test dependency to `de.flapdoodle.embed.mongo` enables us to run MongoDB
    embedded when we run JUnit-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `review` microservices will use Spring Data for JPA together with MySQL
    as its database in runtime and it will use an embedded database, H2, during tests.
    Therefore, it declares the following dependencies in its build file, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Storing data with entity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entity classes are similar to the corresponding API model classes in terms
    of what fields they contain—see the Java package, `se.magnus.api.core`, in the
    `api` project. We will add two fields, `id`, and `version`, in the entity classes
    compared to the fields in the API model classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field is used to hold the database identity of each stored entity—the
    primary key when using a relational database. We will delegate the responsibility
    to generate unique values of the identity field to Spring Data. Depending on the
    database used, Spring Data can delegate this responsibility to the database engine.
    In either case, the application code does not need to consider how a unique database
    `id` value is set. The `id` field is not exposed in the API, as a best practice
    from a security perspective. The fields in the model classes that identify an
    entity will be assigned a unique index in the corresponding entity class, to ensure
    consistency in the database from a business perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The `version` field is used to implement optimistic locking, that is, allowing
    Spring Data to verify that updates of an entity in the database do not overwrite
    a concurrent update. If the value of the version field stored in the database
    is higher than the value of the version field in an update request, it indicates
    that the update is performed on stale data—the information to be updated has been
    updated by someone else since it was read from the database. Attempts to perform
    updates based on stale data will be prevented by Spring Data. In the section on
    writing persistence tests, we will see tests that verify the optimistic locking
    mechanism in Spring Data prevent updates performed on stale data. Since we only
    implement APIs for create, read, and delete operations, we will, however, not
    expose the version field in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting parts of the product entity class look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the observations from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Document(collection="products")` annotation is used to mark the class
    as an entity class used for MongoDB, that is, mapped to a collection in MongoDB
    with the name, `products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Indexed(unique = true)` annotation is used to get a unique index created
    for the business key, `productId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most interesting parts of the `Recommendation` entity class look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Added to the explanations for the preceding product entity, we can see how a
    unique compound index is created using the `@CompoundIndex` annotation for the
    compound business key based on the fields, `productId` and `recommendationId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the most interesting parts of the `Review` entity class look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the observations from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` and `@Table` annotations are used to mark the class as an entity
    class used for JPA—mapped to a table in a SQL database with the name, `products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Table` annotation is also used to specify that a unique compound index
    shall be created for the compound business key based on the fields, `productId` and `reviewId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data as explained previously. To direct Spring Data
    for JPA to automatically generate unique `id` values for the `id` field, we are
    using the `@GeneratedValue` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For full source code of the entity classes, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.persistence.ProductEntity` in the `product`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationEntity` in
    the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.persistence.ReviewEntity` in the `review`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining repositories in Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data comes with a set of base classes for defining repositories. We will
    use the base classes, `CrudRepository` and `PagingAndSortingRepository`. The `CrudRepository` base
    class provides standard methods for performing basic create, read, update, and
    delete operations on the data stored in the databases. The `PagingAndSortingRepository` base
    class adds support for paging and sorting to the `CrudRepository` base class.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `CrudRepository` class as the base class for the `Recommendation`
    and `Review` repositories and the `PagingAndSortingRepository` class as the base
    class for the `Product` repository.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a few extra query methods to our repositories for looking up
    entities using the business key, `productId`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data supports defining extra query methods based on naming conventions
    for the signature of the method. For example, the `findByProductId(int productId)`
    method signature can be used to direct Spring Data to automatically create a query
    that returns entities from the underlying collection or table that has the `productId` field
    set to the value specified in the `productId` parameter when calling the query
    method. For more details on how to declare extra queries, see [https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Product` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since the `findByProductId` method might return zero or one product entity,
    the return value is marked to be optional by wrapping it in an `Optional` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Recommendation` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `findByProductId` method will return zero to many recommendation
    entities, so the return value is defined as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Review` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since SQL databases are transactional, we have to specify the default transaction
    type—read-only in our case—for the query method, `findByProductId()`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it—this is all it takes to establish a persistence layer for our core
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For full source code of the repository classes, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.persistence.ProductRepository` in the `product` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository` in
    the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.persistence.ReviewRepository` in the `review` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start using them by writing some persistence tests to verify that they
    work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Writing automated tests that focus on persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing persistence tests, we want to start an embedded database when the
    tests begin and tear it down when the tests complete. However, we don't want the
    tests to wait for other resources to start up, for example, a web server such
    as Netty (which is required in runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot comes with two class level annotations tailored for this specific
    requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@DataMongoTest`: This starts up an embedded MongoDB database when the test
    starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DataJpaTest`: This starts up an embedded SQL database when the test starts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we added a test dependency in the build file for the review microservice
    to the H2 database, it will be used as the embedded SQL database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Spring Boot configures the tests to roll back updates to the SQL
    database to minimize the risk of negative side effects on other tests. In our
    case, this behavior will cause some of the tests to fail. Therefore, automatic
    rollback is disabled with the class level annotation: `@Transactional(propagation
    = NOT_SUPPORTED)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The persistence tests for the three core microservices are similar to each other,
    so we will only go through the persistence tests for the `Product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class declares a method, `setupDb()`, annotated with `@Before`, which
    is executed before each test method. The setup method removes any entities from
    previous tests in the database and inserts an entity that the test methods can
    use as a base for their tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the various test methods. First out is a `create` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This test creates a new entity and verifies that it can be found using the `findByProductId()`
    method and wraps up with asserting that there are two entities stored in the database,
    the one created by the `setup` method and the one created by the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test updates the entity created by the setup method, reads it again from
    the database using the standard `findById()` method, and asserts that it contains
    expected values for some of its fields. Note that, when an entity is created,
    its `version` field is set to `0` by Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This test deletes the entity created by the `setup` method and verifies that
    it no longer exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This test uses the `findByProductId()` method to get the entity created by the
    `setup` method, verifies that it was found, and then uses the local helper method, `assertEqualsProduct()`, to
    verify that the entity returned by `findByProductId()` looks the same as the entity
    stored by the setup method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it follows two test methods that verify alternative flows—handling of
    error conditions. First, is a test that verifies that duplicates are handled correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The test tries to store an entity with the same business key as used by the
    entity saved by the setup method. The test will fail if the save operation succeeds
    or if the save fails with an exception other than the expected, `DuplicateKeyException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other negative test is, in my opinion, the most interesting test in the
    test class. It is a test that verifies a correct error handling in the case of
    updates of stale data—it verifies that the optimistic locking mechanism works.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the test reads the same entity twice and stores it in two different variables, `entity1`
    and `entity2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it uses one of the variables, `entity1`, to update the entity. The update
    of the entity in the database will cause the version field of the entity to be
    increased automatically by Spring Data. The other variable, `entity2`, now contains
    stale data, manifested by its version field that holds a lower value than the
    corresponding value in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the test tries to update the entity using the variable, `entity2`, that
    contains stale data, it is expected to fail by throwing an `OptimisticLockingFailureException`
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test wraps up by asserting that the entity in the database reflects the
    first update, that is, contains the name `"n1"`, and that the version field has
    the value `1`, that is, only one update has been performed on the entity in the
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the `product` service contains a test that demonstrates the usage
    of built-in support for sorting and paging in Spring Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The test starts with removing any existing data, then inserts 10 entities with
    the `productId` field ranging from `1001` to `1010`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it creates `PageRequest`, requesting a page count of `4` entities per
    page and a sort order based on `ProductId` in ascending order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it uses a helper method, `testNextPage`, to read the expected three
    pages, verifying the expected product IDs in each page and verifying that Spring
    Data correctly reports back whether more pages exist or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The helper method `testNextPage` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The helper method uses the page request object, `nextPage`, to get the next
    page from the repository method, `findAll()`. Based on the result, it extracts
    the product IDs from the returned entities into a string and compares it to the
    expected list of product IDs. Finally, it returns a Boolean indicating whether
    more pages can be retrieved or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For full source code of the three persistence test classes, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.PersistenceTests` in the `product` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.PersistenceTests` in the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.PersistenceTests` in the `review` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The persistence tests in the `product` microservice can be executed using Gradle
    with a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the tests, it should respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf9108ce-73db-41ea-ab82-0bf1eb098921.png)'
  prefs: []
  type: TYPE_IMG
- en: With a persistence layer in place, we can update the service layer in our core
    microservices to use the persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the persistence layer in the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to use the persistence layer in the service
    layer to store data and retrieve data from a database. We will go through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log the database connection URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add new APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the persistence layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a Java bean mapper.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the service tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log the database connection URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When scaling up the number of microservices where each microservice connects
    to its own database, I find myself, from time to time, in a situation where I'm
    not sure what database each microservice actually uses. Therefore, I usually add
    a log statement directly after the startup of a microservice that logs the connection
    URL that is used to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the startup code for the `Product` service looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the log, the following type of output should be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96ba31d3-159d-4cca-a6b9-b3000522b943.png)'
  prefs: []
  type: TYPE_IMG
- en: For the full source code, see the `se.magnus.microservices.core.product.ProductServiceApplication` class
    in the `product` project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use the persistence layer for creating and deleting information
    in the database, we need to create the corresponding API operations in our core
    service APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API operations for creating and deleting a product entity looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the delete operation will be idempotent, that is, it will
    return the same result if called several times. This is a valuable characteristic
    in fault scenarios. For example, if a client experience a network timeout during
    a call to a delete operation, it can simply call the delete operation again without
    worrying about varying responses, for example, OK (200) in response the first
    time and Not Found (404) in response to consecutive calls, or any unexpected side
    effects. This implies that the operation should return the status code OK (200)
    even though the entity no longer exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The API operations for the `recommendation` and `review` entities look similar;
    however, note that, when it comes to the delete operation for `recommendation`
    and `review` entities, it will delete all `recommendations` and `reviews` for
    the specified `productId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the full source code, see the following classes in the `api` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.api.core.product.ProductService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.api.core.recommendation.RecommendationService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.api.core.review.ReviewService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code in the service layer for using the persistence layer is structured
    in the same way for all core microservices. Therefore, we will only go through
    the source code for the `Product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to inject the repository class from the persistence layer and
    a Java bean mapper class into the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see how the Java mapper class is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `createProduct` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `create` method used the `save` method in the repository to store a new
    entity. It should be noted how the mapper class is used to convert Java beans
    between an API model class and an entity class using the two mapper methods, `apiToEntity()`
    and `entityToApi()`. The only error we handle for the `create` method is the `DuplicateKeyException`
    exception, which we convert into an `InvalidInputException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getProduct` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After some basic input validation (that is, ensuring that `productId` is not
    negative), the `findByProductId()` method in the repository is used to find the
    product entity. Since the repository method returns an `Optional` product, we
    can use the `orElseThrow()` method in the `Optional` class to conveniently throw
    a `NotFoundException` exception if no product entity is found. Before the product
    information is returned, the `serviceUtil` object is used to fill in the currently
    used address of the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see the `deleteProduct` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` method also uses the `findByProductId()` method in the repository
    and uses the `ifPresent()` method in the `Optional` class to conveniently delete
    the entity only if it exists. Note that the implementation is idempotent, that
    is, it will not report any failure if the entity is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the three service implementation classes can be found at
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.services.ReviewServiceImpl` in the `review` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring a Java bean mapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what about the magic Java bean mapper?
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, we use MapStruct to declare our mapper classes. The use
    of MapStruct is similar in all three core microservices, so we will only go through
    the source code for the mapper object in the `Product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapper class for the `product` service looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `entityToApi()` method maps entity objects to the API model object. Since
    the entity class does not have a field for `serviceAddress`, the `entityToApi()`
    method is annotated to ignore `serviceAddress`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apiToEntity()` method maps API model objects to entity objects. In the
    same way, the `apiToEntity()` method is annotated to ignore the `id` and `version`
    fields that are missing in the API model class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MapStruct does not only support mapping fields by name, but it can also be
    directed to map fields with different names. In the mapper class for the `Recommendation`
    service, the `rating` entity field is mapped to the API model field, `rate`, using
    the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After a successful Gradle build, the generated mapping implementation can be
    found in the `build/classes` folder, for example, the `Product` service: `$BOOK_HOME/Chapter06/microservices/product-service/build/classes/java/main/se/magnus/microservices/core/product/services/ProductMapperImpl.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the three mapper classes can be found at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.services.ProductMapper` in the `product`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationMapper` in
    the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.services.ReviewMapper` in the `review`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the service tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests of the APIs exposed by the core microservices have been updated since
    the previous chapter with tests on the create and delete API operations.
  prefs: []
  type: TYPE_NORMAL
- en: The added tests are similar in all three core microservices, so we will only
    go through the source code for the service tests in the `Product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure a known state for each test, a setup method, `setupDb()`, is declared
    and annotated with `@Before`, so it runs before each test runs. The setup method
    removes any previously created entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the create API verifies that a product entity can be retrieved
    after it has been created and that creating another product entity with the same
    `productId` results in an expected error, `UNPROCESSABLE_ENTITY`, in the response
    to the API request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the delete API verifies that a product entity can be deleted
    and that a second delete request is idempotent—it also returns the status code
    OK, even though the entity no longer exists in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify sending the create, read, and delete requests to the API and verify
    the response status, three helper methods have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `postAndVerifyProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Added to performing the actual HTTP request and verifying its response code,
    the helper method also returns the body of the response for further investigations
    by the caller, if required. The other two helper methods for read and delete requests
    are similar and can be found in the source code pointed out at the beginning of
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the three service tests classes can be found at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` in the `review`
    project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, lets move on to seeing how we extend a composite service API.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the composite service API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how we can extend the composite API with operations
    for creating and deleting composite entities. We will go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new operations in the composite service API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding methods in the integration layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the composite service tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new operations in the composite service API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The composite versions of creating and deleting entities and handling aggregated
    entities are similar to the create and delete operations in the core service APIs.
    The major difference is that they have annotations added for Swagger-based documentation. For
    an explanation of the usage of the Swagger annotations, `@ApiOperation` and `@ApiResponses`, 
    refer to [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml), *Adding API
    Description Using OpenAPI/Swagger*, the section, *Adding API specific documentation
    in ProductCompositeService*. The API operation for creating a composite product
    entity is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The API operation for deleting a composite product entity is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For the full source code, see the Java interface, `se.magnus.api.composite.product.ProductCompositeService`,
    in the `api` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to, as before, add the descriptive text of the API documentation
    to the property file, `application.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For details, see the configuration file, `src/main/resources/application.yml`,
    in the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated Swagger documentation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52f270b1-6039-4d6e-ad95-f4a9a7029063.png)'
  prefs: []
  type: TYPE_IMG
- en: Later on in this chapter, we will user the Swagger UI to try out the new composite
    API operations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods in the integration layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can implement the new create and delete APIs in the composite services, we
    need to extend the integration layer so it can call the underlying create and
    delete operations in the APIs of the core microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The methods in the integration layer for calling the create and delete operations
    in the three core microservices are straightforward and similar to each other,
    so we will only go through the source code for the methods that call the `Product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It simply delegates the responsibility of sending the HTTP request to the `RestTemplate`
    object and delegates error handling to the helper method, `handleHttpClientException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deleteProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It is implemented in the same way as for the create method, but performs an
    HTTP delete request instead.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for the integration layer can be seen in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class in
    the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can implement the composite create and delete methods!
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite''s create method will split up the aggregate product object into
    discrete objects for `product`, `recommendation`, and `review` and call the corresponding
    create methods in the integration layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The composite''s delete method simply calls the three delete methods in the
    integration layer to delete the corresponding entities in the underlying databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class in
    the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: For happy day scenarios, this implementation will work fine, but if we consider
    various error scenarios this implementation will cause trouble!
  prefs: []
  type: TYPE_NORMAL
- en: What if, for example, one of the underlying core microservices temporarily is
    not available, for example, due to internal, network, or database problems?
  prefs: []
  type: TYPE_NORMAL
- en: This might result in partly created or deleted composite products. For the delete
    operation, this can be fixed if the requestor simply calls the composite's delete
    method until it succeeds. However, if the underlying problem remains for a while,
    the requestor will probably give up, resulting in an inconsistent state of the
    composite product—not acceptable in most cases!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, we will see how we can address these types of shortcomings
    with synchronous APIs as a RESTful API!
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's move on with this fragile design in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the composite service tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing composite services, as already mentioned in [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating
    a Set of Cooperating Microservices* (refer to the *Automated tests of microservices
    in isolation *section), are limited to using simple mock components instead of
    the actual core services. This restricts us from testing more complex scenarios,
    for example, error handling when trying to create duplicates in the underlying
    databases. The tests of the composite create and delete API operations are therefore
    relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For the full source code, see the test class, `se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`,
    in the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to add databases to the landscape of Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Adding databases to the Docker Compose landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have all of the source code in place. Before we can start up the microservice
    landscape and try out the new APIs together with the new persistence layer, we
    must start up some databases.
  prefs: []
  type: TYPE_NORMAL
- en: We will bring MongoDB and MySQL into the system landscape controlled by Docker
    Compose and add configuration to our microservices so that they can find their
    databases when running, either with or without running as a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Compose configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB and MySQL are declared as follows in the Docker Compose configuration
    file, `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the official Docker image for MongoDB V3.6.9 and MySQL 5.7 and forward
    their default ports `27017` and `3306` to the Docker host, also made available
    on `localhost` when using Docker for Mac.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For MySQL, we also declare some environment variables, defining the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the database that will be created on image startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A username and password for a user that is set up for the database on image
    startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For MySQL, we also declare a health check that Docker will run to determine
    the status of the MySQL database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To avoid problems with microservices that try to connect to their databases
    before the database is up and running,  the `product` and `recommendation` services
    are declared dependent on the `mongodb` database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This means that Docker Compose will not start up the `product` and `recommendation`
    containers until the `mongodb` container is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the `review` service is declared dependent on the `mysql`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `review` service depends on the fact that the `mysql` container
    is not only launched, but also that the `mysql` containers health check reports
    are okay. The reason for this extra step is that the initialization of the `mysql`
    container includes setting up a database and creating a superuser for the database.
    This takes a few seconds and, to hold back the `review` service to startup before
    this is done, we direct Docker Compose to hold back the `review` container from
    being launched until the `mysql` container reports that it is operational through
    its health check.
  prefs: []
  type: TYPE_NORMAL
- en: Database connect configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the database in place, we now need to set up the configuration for the
    core microservices so they know how to connect to their databases. This is set
    up in each core microservice's configuration file, `src/main/resources/application.yml`,
    in the `product`, `recommendation`, and `review` projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the `product` and `recommendation` services are similar,
    so we will only look into the configuration of the `product` services. The following
    part of the configuration is of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker using the default Spring profile, the database is
    expected to be reachable on `localhost:27017`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting the log level for `MongoTemplate` to `DEBUG` will allow us to see which
    MongoDB statements are executed in the log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on `mongodb:27017`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration for the `review` service, which affects how it connects to
    its SQL database, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Hibernate will be used by Spring Data JPA as the JPA Entity Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `spring.jpa.hibernate.ddl-auto` property is used to tell Spring Data JPA
    to create new or update existing SQL tables during startup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Note:** It is strongly recommended to set the `spring.jpa.hibernate.ddl-auto` property to
    `none` in a production environment—this prevents Spring Data JPA to manipulate
    the structure of the SQL tables.'
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker, using the default Spring profile, the database
    is expected to be reachable on `localhost` using the default port `3306`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, HikariCP is used by Spring Data JPA as the JDBC connection pool. To
    minimize startup problems on computers with limited hardware resources, the `initializationFailTimeout`
    parameter is set to 60 seconds. This means that the Spring Boot application will
    wait for up to 60 seconds during startup to establish a database connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The log level settings for Hibernate will cause Hibernate to print the SQL statements
    used and the actual values used. Please note that, when used in a production environment,
    writing the actual values to the log should be avoided for privacy reasons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on the `mysql` hostname using the default port `3306`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MongoDB and MySQL CLI tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to run the database CLI tools, the Docker Compose `exec` command
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The commands described in this section will be used when we get to the manual
    tests in the next section. Don't try to run them now; they will fail since we
    have no databases up and running yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MongoDB CLI tool, `mongo`, inside the `mongodb` container, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Enter `exit` to leave the `mongo` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MySQL CLI tool, `mysql`, inside the `mysql` container and log
    in to `review-db` using the user created at startup, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable, `MYSQL_PASSWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `exit` to leave the `mysql` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the usage of these tools in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer graphical database tools, you can run them locally as well, since
    both the MongoDB and the MySQL containers expose their standard ports on localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Manual tests of the new APIs and the persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is finally time to start everything up and test it manually using the
    Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and start the system landscape with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Swagger UI in a web browser, `http://localhost:8080/swagger-ui.html`,
    and perform the following steps on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on product-composite-service-impl and the POST method to expand them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Try it out button and go down to the body field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default value, `0`,  of the `productId` field with `123456`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the Execute button and click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the returned response code is `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following is a sample screenshot after hitting the Execute button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb728f85-f6b7-42e9-89a2-41ed11559551.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the log output from the `docker-compose up` command, we should be able to
    see output like the following (abbreviated for increased readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b2a26c1-fe45-49c0-95e9-9a8d4384351e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also use the database CLI tools to see the actual content in the different
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up content in the `product` service, that is, the `products` collection
    in MongoDB, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b57bb76-075c-4cfd-9d65-43d2760a8200.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look up content in the `recommendation` service, that is, the `recommendations` collection
    in MongoDB, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12d6b674-b3ac-4819-9fc8-5423d00c17af.png)10'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up content in the `review` service, that is, the `reviews` table in MySQL, with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mysql` CLI tool will prompt you for a password; you can find it in the `docker-compose.yml` file.
    Look for the value of the environment variable, `MYSQL_PASSWORD`. Expect a response
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b408949c-fb6d-4b76-8976-556538b135d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Bring down the system landscape by interrupting the `docker-compose up` command
    with *Ctrl + C*, followed by the command, `docker-compose down`. After this, let
    us see how to update the automated tests in a microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the automated tests of the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automated tests of the microservice landscape, `test-em-all.bash`, needs
    to be updated so that they ensure that the database of each microservice has a
    known state before it runs the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The script is extended with a setup function, `setupTestdata()`, which uses
    the composite's create and delete APIs to recreate the products that the tests
    use into a known state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setupTestdata` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses a helper function, `recreateComposite()`, to perform the actual requests
    to the create and delete APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setupTestdata` function is called directly after the `waitForService`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of the `waitForService` function is to verify that all microservices
    are up and running. In the previous chapter, the get API on the composite product
    service was used. In this chapter, the delete API is used instead. When using
    the get API, only the product core microservice is called if the entity is not
    found; the recommendation and `review` services will not be called to verify that
    they are up and running. The call to the delete API will also ensure that the
    *Not Found*-test on `productId 13` will succeed. Later on in this book, we will
    see how we can define specific APIs for checking the health state of a microservice
    landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the updated test script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution should end by writing a log message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd02c04-4291-440a-96e4-0660e2792679.png)'
  prefs: []
  type: TYPE_IMG
- en: This ends updating of the automated tests of the microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can use Spring Data to add a persistence
    layer to the core microservices. We used the core concepts of Spring Data, repositories
    and entities, to store data in both MongoDB and MySQL using a programming model
    that is similar, even though not fully portable. We have also seen how Spring
    Boot's annotations, `@DataMongoTest` and `@DataJpaTest`, can be used to conveniently
    set up tests targeted for persistence; this is where an embedded database is started
    automatically before the test runs, but no other infrastructure that the microservice
    will need in runtime, for example, a web server such as Netty, is started up.
    This results in persistence tests that are easy to set up and that start with
    minimum overhead.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how the persistence layer can be used by the service layer
    and how we can add APIs for creating and deleting entities, both core and composite
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how convenient it is to start up databases such as MongoDB
    and MySQL in runtime using Docker Compose and how to use the new create and delete
    APIs to set up test data before running automated tests of the microservice-based
    system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: However, one major concern was identified in this chapter. Updating (creating
    or deleting) a composite entity—an entity whose parts are stored in a number of
    microservices—using synchronous APIs can lead to inconsistencies, if not all involved
    microservices are updated successfully. This is, in general, not acceptable. This
    leads us into the next chapter, where we will look into why and how to build reactive
    microservices, that is, microservices that are scalable and robust.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data, a common programming model based on entities and repositories,
    can be used for different types of database engines. From the source code examples
    in this chapter, what are the most important differences in the persistence code
    for MySQL and MongoDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to implement optimistic locking using Spring Data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is MapStruct used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean that an operation is idempotent and why is that useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we access the data that is stored in the MySQL and MongoDB databases without
    using the API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

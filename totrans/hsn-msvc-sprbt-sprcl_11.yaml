- en: Adding Service Discovery Using Netflix Eureka and Ribbon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka和Ribbon添加服务发现
- en: In this chapter, we will learn how to use Netflix Eureka as a discovery server
    for microservices based on Spring Boot. To allow our microservices to communicate
    with Netflix Eureka, we will use the Spring Cloud module for Netflix Eureka clients.
    Before we delve into the details, we will elaborate on why a discovery server
    is needed and why a DNS server isn't sufficient.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在基于Spring Boot的微服务中使用Netflix Eureka作为发现服务器。为了让我们的微服务能够与Netflix Eureka通信，我们将使用Spring
    Cloud模块作为Netflix Eureka客户端。在深入细节之前，我们将详细说明为什么需要发现服务器以及为什么DNS服务器不够用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to service discovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现介绍
- en: The problem with DNS-based service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DNS的服务发现的问题
- en: Challenges with service discovery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现的挑战
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud中使用Netflix Eureka的服务发现
- en: Setting up a Netflix Eureka server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务器
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: Setting up configuration for use in the development process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用于开发过程的配置
- en: Trying out the discovery service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试发现服务
- en: Introducing service discovery
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现介绍
- en: 'The concept of service discovery was described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*; please refer to the *Service discovery* section for
    more information. Netflix Eureka was introduced as a discovery service in [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*;
    please refer to the *Netflix Eureka as a discovery service* section for more information.
    Before we jump into the implementation details, we will look at the following
    topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现的概念在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中有所描述，请参考*服务发现*部分获取更多信息。Netflix
    Eureka在[第8章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中作为发现服务进行了介绍，请参考*Netflix
    Eureka作为发现服务*部分获取更多信息。在我们深入实现细节之前，我们将研究以下主题：
- en: The problem with DNS-based service discovery
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DNS的服务发现的问题
- en: Challenges with service discovery
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现的挑战
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud中使用Netflix Eureka的服务发现
- en: The problem with DNS-based service discovery
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于DNS的服务发现的问题
- en: So, what's the problem?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题出在哪里呢？
- en: Why can't we simply start new instances of a microservice and rely on round-robin
    DNS? In essence, given that the microservice instances have the same DNS name,
    the DNS server will resolve it to a list of IP addresses for the available instances.
    Due to this, the client can call the service instances in a round-robin fashion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能简单地启动微服务的新实例并依赖轮询DNS？实质上，鉴于微服务实例具有相同的DNS名称，DNS服务器将其解析为可用实例的IP地址列表。因此，客户端可以以轮询方式调用服务实例。
- en: 'Let''s try it out and see what happens, shall we? Follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，看看会发生什么，好吗？按照以下步骤进行：
- en: 'Assuming that you have followed the instructions from [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml),
    *Developing Reactive Microservices*, start the system landscape and insert some
    test data with the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您已经按照[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)中的说明*开发响应式微服务*，启动系统架构并使用以下命令插入一些测试数据：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scale up the `review` microservice to two instances:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`review`微服务扩展到两个实例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ask the composite product service for the IP addresses it finds for the `review`
    microservice:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问复合产品服务为`review`微服务找到的IP地址：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Expect an answer like the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望得到以下答复：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great, the composite product service sees two IP addresses—in my case, `172.19.0.8`
    and `172.19.0.9`—one for each instance of the `review` microservice instances!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，复合产品服务看到了两个IP地址——在我的案例中，`172.19.0.8`和`172.19.0.9`——每个`review`微服务实例一个！
- en: 'If you want to, you can verify that these are the correct IP addresses by using
    the following commands:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用以下命令验证这些是否是正确的IP地址：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last line in the output from each command should contain one of the IP addresses,
    as shown in the preceding code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令的输出中的最后一行应包含一个IP地址，就像前面的代码中所示。
- en: 'Now, let''s try out a couple of calls to the composite product service and
    see whether it uses both instances of the `review` microservice:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对*复合产品服务*进行一些调用，看看它是否使用了`review`微服务的两个实例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unfortunately, we will only get responses from one of the microservice instances,
    as in this example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们只会从微服务实例中得到一个响应，就像这个例子一样：
- en: '![](img/70f0682d-4f5b-4fae-a1a0-d96ea3c3c254.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70f0682d-4f5b-4fae-a1a0-d96ea3c3c254.png)'
- en: That was disappointing!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这太令人失望了！
- en: Okay, so what is going on here?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里到底发生了什么？
- en: A DNS client typically caches the resolved IP addresses and hangs on to the
    first working IP address it tries out when it receives a list of IP addresses
    that have been resolved for a DNS name. Neither the DNS servers nor the DNS protocol
    is well-suited for handling volatile microservices instances that come and go
    all of the time. Because of this, DNS-based service discovery isn't very appealing
    from a practical standpoint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DNS客户端通常会缓存解析的IP地址，并在收到为DNS名称解析的IP地址列表时保留尝试的第一个有效IP地址。无论是DNS服务器还是DNS协议都不适合处理不断出现和消失的易变微服务实例。因此，基于DNS的服务发现在实际上并不太吸引人。
- en: Using Spring Cloud Config for centralized configuration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Config进行集中配置
- en: To manage the configuration of a system landscape of microservices, Spring Cloud
    contains Spring Cloud Config, which provides the centralized management of configuration
    files according to the requirements described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Central configuration* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理微服务系统架构的配置，Spring Cloud包含Spring Cloud Config，根据[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中描述的要求提供配置文件的集中管理，*微服务简介*中的*中央配置*部分。
- en: 'Spring Cloud Config supports storing configuration files in a number of different
    backends, such as the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config支持将配置文件存储在多种不同的后端，例如以下内容：
- en: A Git repository, for example, on GitHub or Bitbucket
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，GitHub或Bitbucket上的Git存储库
- en: Local filesystem
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: HashiCorp Vault
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault
- en: A JDBC database
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC数据库
- en: Spring Cloud Config allows us to handle configuration in a hierarchical structure;
    for example, we can place common parts of the configuration in a common file and
    microservice-specific settings in separate configuration files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config允许我们以分层结构处理配置；例如，我们可以将配置的共同部分放在一个公共文件中，将微服务特定的设置放在单独的配置文件中。
- en: Spring Cloud Config also supports detecting changes in the configuration and
    pushing notifications to the affected microservices. It uses **Spring Cloud Bus**
    to transport the notifications. Spring Cloud Bus is an abstraction on top of Spring
    Cloud Stream that we already are familiar with; that is, it supports the use of
    either RabbitMQ or Kafka as the messaging system for transporting notifications
    out of the box.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config还支持检测配置更改并向受影响的微服务推送通知。它使用**Spring Cloud Bus**传输通知。Spring
    Cloud Bus是Spring Cloud Stream的一个抽象，我们已经熟悉；也就是说，它支持使用RabbitMQ或Kafka作为传输通知的消息系统。
- en: 'The following diagram illustrates the cooperation between Spring Cloud Config,
    its clients, a Git repository, and Spring Cloud Bus:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了Spring Cloud Config、其客户端、Git存储库和Spring Cloud Bus之间的合作：
- en: '![](img/a6dc8c02-132d-482d-bf64-2b2994b29eca.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6dc8c02-132d-482d-bf64-2b2994b29eca.png)'
- en: 'The diagram shows the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示以下内容：
- en: When the microservices starts up, they ask the configuration server for its
    configuration.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当微服务启动时，它们会向配置服务器请求其配置。
- en: The configuration server gets the configuration from, in this case, a Git repository.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器从Git存储库获取配置。
- en: Optionally, the Git repository can be configured to send notifications to the configuration
    server when Git commits are pushed to the Git repository.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以选择配置Git存储库，以便在将Git提交推送到Git存储库时向配置服务器发送通知。
- en: The configuration server will publish change events using Spring Cloud Bus.
    The microservices that are affected by the change will react and retrieve its
    updated configuration from the configuration server.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器将使用Spring Cloud Bus发布更改事件。受更改影响的微服务将做出反应，并从配置服务器检索其更新的配置。
- en: Finally, Spring Cloud Config also supports the encryption of sensitive information
    in the configuration, such as credentials.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Spring Cloud Config还支持对配置中的敏感信息进行加密，如凭据。
- en: We will learn about Spring Cloud Config in [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第12章](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml)中学习Spring Cloud Config，*集中式配置*。
- en: With Spring Cloud Config introduced, let's get introduced to how to use Resilience4j
    for improved resilience.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了Spring Cloud Config后，让我们了解如何使用Resilience4j来提高韧性。
- en: Using Resilience4j for improved resilience
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Resilience4j来提高韧性
- en: As we already mentioned in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the*Circuit breaker* section, things go wrong occasionally.
    In a fairly large-scaled system landscape of cooperating microservices, we must
    assume that there is something going wrong all of the time. Failures must be seen
    as a normal state, and the system landscape must be designed to handle it!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中已经提到的，在*微服务简介*中的*断路器*部分，偶尔会出现问题。在一个相当大规模的合作微服务系统中，我们必须假设一直有东西出错。故障必须被视为正常状态，并且系统架构必须设计成能够处理它！
- en: Initially, Spring Cloud came with Netflix Hystrix, a well-proven circuit breaker.
    But since the Spring Cloud Greenwich release, it is recommended to replace Netflix
    Hystrix with Resilience4j. The reason for this is that Netflix recently put Hystrix
    into maintenance mode. For more details, see [https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Spring Cloud配备了Netflix Hystrix，一个经过验证的断路器。但自从Spring Cloud Greenwich发布以来，建议用Resilience4j替换Netflix
    Hystrix。原因是Netflix最近将Hystrix置于维护模式。更多详情请参见[https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status)。
- en: '**Resilience4j** is an open source-based fault tolerance library. You can discover
    more about it at [https://github.com/resilience4j/resilience4j](http://resilience4j.github.io/resilience4j/).
    It comes with the following fault tolerance mechanisms built-in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Resilience4j**是一个基于开源的容错库。您可以在[https://github.com/resilience4j/resilience4j](http://resilience4j.github.io/resilience4j/)上了解更多信息。它内置了以下容错机制：'
- en: '**Circuit breaker** is used to prevent a chain of failure reactions if a remote
    service stops to respond.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Circuit breaker**用于防止远程服务停止响应时出现一系列故障反应。'
- en: '**Rate limiter** is used to limit the number of requests to service during
    a specified time period.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rate limiter**用于限制在指定时间段内对服务的请求数量。'
- en: '**Bulkhead** is used to limit the number of concurrent requests to a service.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bulkhead**用于限制对服务的并发请求数量。'
- en: '**Retries** is used to handle random errors that might happen from time to
    time.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retries**用于处理可能偶尔发生的随机错误。'
- en: '**Timeout** is used to avoid waiting too long for a response from slow or not
    responding service.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Timeout**用于避免等待来自缓慢或不响应的服务的响应时间过长。'
- en: 'In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j*, we will focus on the circuit breaker in Resilience4j.It follows
    the classic design of a circuit breaker, as illustrated in the following state
    diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](23795d34-4068-4961-842d-989cde26b642.xhtml)中，*使用Resilience4j改善韧性*，我们将专注于Resilience4j中的断路器。它遵循了经典的断路器设计，如下状态图所示：
- en: '![](img/39bdb1ab-dd3a-4238-8fe8-9b112d5f2125.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39bdb1ab-dd3a-4238-8fe8-9b112d5f2125.png)'
- en: 'Let''s take a look at the state diagram in more detail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下状态图：
- en: A circuit breaker starts as **Closed**, that is, allowing requests to be processed.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断路器初始状态为**Closed**，也就是允许处理请求。
- en: As long as the requests are processed successfully, it stays in the **Closed**
    state.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要请求成功处理，它就会保持在**Closed**状态。
- en: If failures start to happen, a counter starts to count up.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果故障开始发生，计数器开始计数。
- en: If a configured threshold of failures is reached, the circuit breaker will **trip**,
    that is, go to the **Open** state, not allowing further requests to be processed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果达到了配置的失败阈值，断路器将**跳闸**，也就是进入**Open**状态，不允许进一步处理请求。
- en: Instead, a request will **fast fail**, that is, return immediately with an exception.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，请求将**快速失败**，也就是立即返回一个异常。
- en: After a configurable time, the circuit breaker will enter a **Half Open** state
    and allow one request to go through, such as a probe, to see whether the failure
    has been resolved.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可配置的时间之后，断路器将进入**Half Open**状态，并允许一个请求通过，例如一个探测，以查看故障是否已经解决。
- en: If the probe request fails, the circuit breaker goes back to the **Open** state.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探测请求失败，断路器将返回**Open**状态。
- en: If the probe request succeeds, the circuit breaker goes to the initial **Closed**
    state, that is, allowing new requests to be processed.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探测请求成功，断路器将返回初始的**Closed**状态，也就是说，允许处理新的请求。
- en: Sample usage of the circuit breaker in Resilience4j
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Resilience4j中断路器的示例用法
- en: Let's assume we have a REST service that is protected by a circuit breaker via Resilience4j
    called `myService`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个由Resilience4j通过断路器保护的REST服务，名为`myService`。
- en: If the service starts to produce internal errors, for example, because it can't
    reach a service it depends on, we might get a response from the service such as `500
    Internal Server Error`. After a number of configurable attempts, the circuit will
    open and we will get a fast failure that returns an error message such as `CircuitBreaker
    'myService' is open`. When the error is resolved and we make a new attempt (after
    the configurable wait time), the circuit breaker will allow a new attempt as a
    probe. If the call succeeds, the circuit breaker will be closed again; that is,
    it is operating normally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务开始产生内部错误，例如因为无法访问其依赖的服务，我们可能会收到来自服务的响应，例如`500 Internal Server Error`。在一定数量的可配置尝试之后，断路器将打开，并且我们将获得一个快速失败，返回一个错误消息，例如`CircuitBreaker
    'myService' is open`。当错误解决并且我们进行新的尝试（在可配置的等待时间之后），断路器将允许一个新的尝试作为探测。如果调用成功，断路器将再次关闭；也就是说，它正常运行。
- en: 'When using Resilience4j together with Spring Boot, we will be able to monitor
    the state of the circuit breakers in a microservice using its Spring Boot Actuator
    `health` endpoint. We can, for example, use `curl` to see the state of the circuit
    breaker, that is, `myService`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Resilience4j与Spring Boot一起时，我们将能够使用其Spring Boot执行器`health`端点监视微服务中断路器的状态。例如，我们可以使用`curl`来查看断路器的状态，也就是`myService`：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If it operates normally, that is, the circuit is `closed`, it will respond
    with something such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它正常运行，也就是说，电路是“闭合”的，它将会做出如下的响应：
- en: '![](img/3fb19393-c8f6-46e4-a14b-f0850f75131e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb19393-c8f6-46e4-a14b-f0850f75131e.png)'
- en: 'If something is wrong and the circuit is **open**, it will respond with something
    such as the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，断路器处于**open**状态，它将会做出如下的响应：
- en: '![](img/0256fdb6-55bb-4ad8-9e24-532f801c9916.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0256fdb6-55bb-4ad8-9e24-532f801c9916.png)'
- en: With Resilience4j and specifically its circuit breaker introduced, we have seen
    an example of how the circuit breaker can be used to handle errors for a REST
    client. Let's get introduced to how to use Spring Cloud Sleuth and Zipkin for
    distributed tracing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Resilience4j，特别是其引入的断路器，我们已经看到了一个示例，断路器如何用于处理REST客户端的错误。让我们介绍一下如何使用Spring
    Cloud Sleuth和Zipkin进行分布式跟踪。
- en: Using Spring Cloud Sleuth and Zipkin for distributed tracing
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Sleuth和Zipkin进行分布式跟踪
- en: To understand what is going on in a distributed system such as a system landscape
    of cooperating microservices, it is crucial to be able to track and visualize
    how requests and messages flow between microservices when processing an external
    call to the system landscape.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解分布式系统中发生的情况，例如合作微服务系统景观，能够跟踪和可视化请求和消息在处理对系统景观的外部调用时在微服务之间的流动是至关重要的。
- en: Refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),* Introduction
    to Microservices*, the *Distributed tracing*section, for more information on this
    subject.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)，*微服务简介*，*分布式跟踪*部分。
- en: Spring Cloud comes with **Spring Cloud Sleuth**, which can mark requests and
    messages/events that are part of the same processing flow with a common *correlation
    ID*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud配备了**Spring Cloud Sleuth**，它可以使用一个共同的*关联ID*标记属于同一处理流程的请求和消息/事件。
- en: Spring Cloud Sleuth can also decorate log messages with correlation IDs to make
    it easier to track log messages from different microservices that come from the
    same processing flow. **Zipkin** is a distributed tracing system ([http://zipkin.io](http://zipkin.io/))
    that Spring Cloud Sleuth can send tracing data to for storage and visualization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth还可以使用关联ID装饰日志消息，以便更容易跟踪来自同一处理流程的不同微服务的日志消息。**Zipkin**是一个分布式跟踪系统（[http://zipkin.io](http://zipkin.io/)），Spring
    Cloud Sleuth可以将跟踪数据发送到Zipkin进行存储和可视化。
- en: The infrastructure for handling distributed tracing information in Spring Cloud
    Sleuth and Zipkinis based on Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    In Dapper, the tracing information from a complete workflow is called a **trace tree**,
    and subparts of the tree, such as the basic units of work, are called **spans**.
    Spans can, in turn, consist of sub-spans, which form the trace tree. A correlation
    ID is called `TraceId`, and a span is identified by its own unique `SpanId`, along
    with `TraceId` of the trace tree it belongs to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth和Zipkin中处理分布式跟踪信息的基础设施基于Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356))。在Dapper中，完整工作流程的跟踪信息称为**跟踪树**，树的子部分，如基本工作单元，称为**跨度**。跨度又可以由子跨度组成，形成跟踪树。相关ID称为`TraceId`，跨度由其自己的唯一`SpanId`标识，以及它所属的跟踪树的`TraceId`。
- en: 'Spring Cloud Sleuth can send requests to Zipkin either synchronously over HTTP
    or asynchronously using either RabbitMQ or Kafka. To avoid creating runtime dependencies
    to the Zipkin server from our microservices, we prefer sending trace information
    to Zipkin asynchronously using either RabbitMQ or Kafka. This is illustrated by
    the following diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth可以通过HTTP同步或使用RabbitMQ或Kafka异步发送请求到Zipkin。为了避免从我们的微服务向Zipkin服务器创建运行时依赖，我们更喜欢使用RabbitMQ或Kafka异步地将跟踪信息发送到Zipkin。下图说明了这一点：
- en: '![](img/0b718675-03d1-4367-8114-0def71168052.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b718675-03d1-4367-8114-0def71168052.png)'
- en: 'In [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml), *Understanding
    Distributed Tracing*, we will see how we can use Spring Cloud Sleuth and Zipkin
    to trace the processing that goes on in our microservice landscape. The following
    is a screenshot from the Zipkin UI, which visualizes the trace tree that was created
    as a result of processing the creation of an aggregated product:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)，*理解分布式跟踪*中，我们将看到如何使用Spring
    Cloud Sleuth和Zipkin跟踪我们的微服务架构中进行的处理。以下是来自Zipkin UI的屏幕截图，它可视化了由处理聚合产品创建而创建的跟踪树：
- en: '![](img/6b7b0b09-bac1-4528-ad88-ab30d6410fde.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b7b0b09-bac1-4528-ad88-ab30d6410fde.png)'
- en: An HTTP `POST` request is sent to the product-composite service and responds
    by publishing create events to the topics for products, recommendations, and reviews.
    These events are consumed by the three core microservices in parallel and the
    data in the create events are stored in each microservice's database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `POST`请求发送到产品组合服务，并通过发布创建事件到产品、推荐和评论主题来响应。这些事件被三个核心微服务并行消费，并且创建事件中的数据存储在每个微服务的数据库中。
- en: With Spring Cloud Sleuth and Zipkin for distributed tracing being introduced,
    we have seen an example of distributed tracing of the processing of an external
    synchronous HTTP request that includes asynchronous passing of events between
    the involved microservices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入Spring Cloud Sleuth和Zipkin进行分布式跟踪，我们已经看到了一个包括涉及的微服务之间的事件异步传递的外部同步HTTP请求处理的分布式跟踪的示例。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how Spring Cloud has evolved from being rather
    Netflix OSS-centric to having a much larger scope as of today. We also introduced
    how components from the latest release of Spring Cloud Greenwich can be used to
    implement some of the design patterns we described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Design patterns for microservices* section.
    These design patterns are required to make a landscape of cooperating microservices
    production-ready.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到Spring Cloud是如何从以前的Netflix OSS为中心演变为今天的更广泛范围。我们还介绍了如何使用Spring Cloud
    Greenwich的最新版本中的组件来实现我们在《微服务设计模式》部分描述的一些设计模式。这些设计模式是使一系列合作的微服务变得可投入生产的必要条件。
- en: Head over to the next chapter to see how we can implement service discovery
    using Netflix Eureka and Spring Cloud load balancer!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前往下一章，看看我们如何使用Netflix Eureka和Spring Cloud负载均衡器实现服务发现！
- en: Questions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of Netflix Eureka?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Netflix Eureka的目的是什么？
- en: What are the main features of Spring Cloud Gateway?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway的主要特性是什么？
- en: What backends are supported by Spring Cloud Config?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Config支持哪些后端？
- en: What are the capabilities that Resilience4j provides?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Resilience4j提供了哪些功能？
- en: What are the concepts of trace tree and span used for in distributed tracing,
    and what is the paper called that defined them?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式跟踪中的跟踪树和跨度的概念是用来做什么的，定义它们的论文叫什么？
- en: Technical requirements
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book have been run on a MacBook
    Pro using macOS Mojave, but it should be straightforward to modify it so that
    it can run on another platform, such as Linux or Windows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但应该很容易修改它，以便在其他平台上运行，如Linux或Windows。
- en: No new tools need to be installed in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不需要安装新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，下载源代码到一个文件夹，并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下是一些示例命令：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Java source code is written for Java 8 and has been tested on Java 12\.
    This chapter uses Spring Cloud 2.1.0 (also known as the **Greenwich** release),
    Spring Boot 2.1.3, and Spring 5.1.5—that is, the latest available version of the
    Spring components at the time of writing this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并已在Java 12上进行了测试。本章使用Spring Cloud 2.1.0（也称为**Greenwich**发布版），Spring
    Boot 2.1.3和Spring 5.1.5，即在编写本章时Spring组件的最新可用版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: The code examples in this chapter all come from the source code in the `$BOOK_HOME/Chapter09` directory
    but have been edited in several places in order to remove irrelevant parts of
    the source code, such as comments and import and log statements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter09`目录中的源代码，但已经在多个地方进行了编辑，以删除源代码的无关部分，例如注释、导入和日志语句。
- en: If you want to look at the changes that were applied to the source code in [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon*, to see what it took to add Netflix Eureka as a discovery
    service to the microservices landscape, you can compare it with the source code
    for [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive
    Microservices*. You can use your favorite `diff` tool and compare the two folders,
    `$BOOK_HOME/Chapter07` and `$BOOK_HOME/Chapter09`, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看在[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)中应用到源代码的更改，即*使用Netflix
    Eureka和Ribbon添加服务发现*，以查看将Netflix Eureka作为发现服务添加到微服务架构中所需的步骤，您可以将其与[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)中的源代码进行比较，即*开发响应式微服务*。您可以使用您喜欢的`diff`工具分别比较两个文件夹，即`$BOOK_HOME/Chapter07`和`$BOOK_HOME/Chapter09`。
- en: Challenges with service discovery
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现的挑战
- en: So, we need something a bit more powerful than a plain DNS to keep track of
    available microservice instances!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要比普通DNS更强大的东西来跟踪可用的微服务实例！
- en: 'We must take the following into consideration when we''re keeping track of
    many small moving parts, that is, microservice instances:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跟踪许多小的移动部分，即微服务实例时，我们必须考虑以下内容：
- en: New instances can start up at any point in time.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新实例可以随时启动。
- en: Existing instances can stop responding and eventually crash at any point in
    time.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有实例可能随时停止响应并最终崩溃。
- en: Some of the failing instances might be okay after a while and should start to
    receive traffic again, while others will not and should be removed from the service
    registry.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段时间后，一些失败的实例可能会恢复正常，并且应该再次开始接收流量，而另一些则不会，并且应该从服务注册表中删除。
- en: Some microservice instances might take some time to start up; that is, just
    because they can receive HTTP requests doesn't mean that traffic should be routed
    to them.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些微服务实例可能需要一些时间才能启动；也就是说，仅因为它们可以接收HTTP请求并不意味着流量应该路由到它们。
- en: Unintended network partitioning and other network-related errors can occur at
    any time.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的网络分区和其他与网络相关的错误可能随时发生。
- en: Building a robust and resilient discovery server is not an easy task, to say
    the least. Let's see how we can use Netflix Eureka to handle these challenges!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个强大而有韧性的发现服务器绝非易事。让我们看看如何使用Netflix Eureka来处理这些挑战！
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud中使用Netflix Eureka的服务发现
- en: 'Netflix Eureka implements client-side service discovery, meaning that the clients
    run software that talks to the discovery service, Netflix Eureka, to get information
    about the available microservice instances. This is illustrated in the following
    diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka实现了客户端服务发现，这意味着客户端运行软件与发现服务Netflix Eureka交谈，以获取有关可用微服务实例的信息。下图中有所示：
- en: '![](img/3e46d604-73a8-4747-8af4-23865c058d65.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e46d604-73a8-4747-8af4-23865c058d65.png)'
- en: 'The process is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程如下：
- en: Whenever a microservice instance starts up—for example, the **Review** service—it
    registers itself to one of the Eureka servers.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当一个微服务实例启动时，例如**Review**服务，它会向Eureka服务器之一注册自己。
- en: On a regular basis, each microservice instance sends a heartbeat message to
    the Eureka server, telling it that the microservice instance is okay and is ready
    to receive requests.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期，每个微服务实例向Eureka服务器发送心跳消息，告诉它微服务实例正常，并且准备好接收请求。
- en: Clients—for example, the **Product Composite** service—use a client library
    that regularly asks the Eureka service for information about available services.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，**产品组合**服务的客户端使用客户端库定期向Eureka服务请求有关可用服务的信息。
- en: When the client needs to send a request to another microservice, it already
    has a list of available instances in its client library and can pick one of them
    without asking the discovery server. Typically available instances are chosen
    in a round-robin fashion; that is, they are called one after another before the
    first one is called once more.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端需要向另一个微服务发送请求时，它已经在其客户端库中有一个可用实例列表，并且可以在不询问发现服务器的情况下选择其中一个。通常可用实例是以循环方式选择的；也就是说，在再次调用第一个实例之前，它们将依次被调用。
- en: In [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing Kubernetes
    Features as an Alternative*, we will look at an alternative approach to how to
    provide a discovery service using a server-side *service* concept in Kubernetes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml)中，*实现Kubernetes功能作为替代方案*，我们将看看如何使用Kubernetes中的服务器端*服务*概念提供发现服务的替代方法。
- en: Spring Cloud comes with an abstraction of how to communicate with a discovery
    service such as Netflix Eureka and provides an interface called `DiscoveryClient`.
    This can be used to interact with a discovery service to get information regarding
    available services and instances. Implementations of the `DiscoveryClient` interface
    are also capable of automatically registering a Spring Boot application with the
    discovery server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud提供了一个如何与Netflix Eureka等发现服务通信的抽象，并提供了一个名为`DiscoveryClient`的接口。这可以用来与发现服务交互，以获取有关可用服务和实例的信息。`DiscoveryClient`接口的实现还能够自动将Spring
    Boot应用程序注册到发现服务器。
- en: Spring Boot can find implementations of the `DiscoveryClient` interface automatically
    during startup, so we only need to bring in a dependency on the corresponding
    implementation to connect to a discovery server. In the case of Netflix Eureka,
    the dependency that's used by our microservices is `spring-cloud-starter-netflix-eureka-client`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot可以在启动时自动找到`DiscoveryClient`接口的实现，因此我们只需要引入与连接到发现服务器的相应实现的依赖项。对于Netflix
    Eureka，我们的微服务使用的依赖项是`spring-cloud-starter-netflix-eureka-client`。
- en: Spring Cloud also has `DiscoveryClient` implementations that support the use
    of either Apache Zookeeper or HashiCorp Consul as a discovery server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud还有支持使用Apache Zookeeper或HashiCorp Consul作为发现服务器的`DiscoveryClient`实现。
- en: Spring Cloud also comes with an abstraction—the `LoadBalancerClient` interface—for
    clients that want to make requests through a load balancer to registered instances
    in the discovery service. The standard reactive HTTP client, `WebClient`, can
    be configured to use the `LoadBalancerClient` implementation. By adding the `@LoadBalanced`
    annotation to an `@Bean` declaration that returns a `WebClient.Builder` object,
    a `LoadBalancerClient` implementation will be injected into the `Builder` instance
    as `ExchangeFilterFunction`. With the `spring-cloud-starter-netflix-eureka-client` dependency
    on the classpath, `RibbonLoadBalancerClient` will be automatically injected, that
    is, a load balancer based on Netflix Ribbon. So, even though a Netflix Ribbon
    is placed in maintenance mode, as described in [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud*, it is still used under the hood. Later in this
    chapter in the *Connecting microservices to a Netflix Eureka server *section,
    we will look at some source code examples of how this can be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud还提供了一个抽象——`LoadBalancerClient`接口，用于希望通过负载均衡器向发现服务中注册的实例发出请求的客户端。标准的响应式HTTP客户端`WebClient`可以配置为使用`LoadBalancerClient`实现。通过向返回`WebClient.Builder`对象的`@Bean`声明添加`@LoadBalanced`注解，`LoadBalancerClient`实现将被注入到`Builder`实例作为`ExchangeFilterFunction`。通过在类路径上添加`spring-cloud-starter-netflix-eureka-client`依赖项，将自动注入`RibbonLoadBalancerClient`，即基于Netflix
    Ribbon的负载均衡器。因此，即使Netflix Ribbon处于维护模式，如[第8章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中描述的那样，*Spring
    Cloud简介*，它仍然在幕后使用。本章后面的*将微服务连接到Netflix Eureka服务器*部分中，我们将看一些源代码示例，说明如何使用它。
- en: In summary, Spring Cloud makes it very easy to use Netflix Eureka as a discovery
    service. With this introduction to service discovery and its challenges and how
    Netflix Eureka can be used together with Spring Cloud, we are ready to learn how
    to set up a Netflix Eureka server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Spring Cloud非常容易使用Netflix Eureka作为发现服务。通过这个介绍，我们了解了服务发现及其挑战，以及Netflix Eureka如何与Spring
    Cloud一起使用，现在我们准备学习如何设置Netflix Eureka服务器。
- en: Trying out the discovery service
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试发现服务
- en: 'With all of the details in place, we are ready to try out the service:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，我们可以尝试服务：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, start the system landscape and run the usual tests with the following
    command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动系统架构，并使用以下命令运行通常的测试：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Expect output similar to what we have seen in previous chapters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出与我们在之前章节中看到的类似：
- en: '![](img/841fe8fc-968b-40e7-85fa-60fa73153679.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/841fe8fc-968b-40e7-85fa-60fa73153679.png)'
- en: With the system landscape up and running, we can start with testing how to scale
    up the number of instances for one of the microservices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构已经运行起来，我们可以开始测试如何扩展一个微服务的实例数量。
- en: Setting up a Netflix Eureka server
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务器
- en: 'In this section, we will learn how to set up a Netflix Eureka server for service
    discovery. Setting up a Netflix Eureka server using Spring Cloud is really easy—just
    follow these steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为服务发现设置Netflix Eureka服务器。使用Spring Cloud设置Netflix Eureka服务器非常简单，只需按照以下步骤操作：
- en: Create a Spring Boot project using Spring Initializr, as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices*, in the*Using Spring Initializr to generate skeleton code* section.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建一个Spring Boot项目，如[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)中描述的*创建一组协作微服务*，在*使用Spring
    Initializr生成骨架代码*部分。
- en: Add a dependency to `spring-cloud-starter-netflix-eureka-server`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个依赖项`spring-cloud-starter-netflix-eureka-server`。
- en: Add the `@EnableEurekaServer` annotation to the application class.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类中添加`@EnableEurekaServer`注解。
- en: Add a Dockerfile, similar to the Dockerfiles that are used for our microservices,
    with the exception that we export the Eureka default port, `8761`, instead of
    the default port for our microservices, `8080`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个Dockerfile，类似于我们的微服务使用的Dockerfile，唯一的区别是我们导出Eureka默认端口`8761`，而不是我们的微服务的默认端口`8080`。
- en: 'Add the Eureka server to our three Docker Compose files, that is, `docker-compose.yml`,
    `docker-compose-partitions.yml`, and `docker-compose-kafka.yml`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Eureka服务器添加到我们的三个Docker Compose文件中，即`docker-compose.yml`，`docker-compose-partitions.yml`和`docker-compose-kafka.yml`：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, add some configuration. Please go to the *Setting up configuration
    for use in the development process* section in this chapter, where we will go
    through the configuration for both the Eureka server and our microservices.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一些配置。请转到本章的*设置用于开发过程中的配置*部分，我们将介绍Eureka服务器和我们的微服务的配置。
- en: That's all it takes!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: You can find the source code for the Eureka server in the `$BOOK_HOME/Chapter09/spring-cloud/eureka-server`
    folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`$BOOK_HOME/Chapter09/spring-cloud/eureka-server`文件夹中找到Eureka服务器的源代码。
- en: Knowing how to set up a Netflix Eureka server for service discovery, we are
    ready to learn how to connect microservices to a Netflix Eureka server.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何为服务发现设置Netflix Eureka服务器后，我们准备学习如何将微服务连接到Netflix Eureka服务器。
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: In this section, we will learn how to connect microservice instances to a Netflix
    Eureka server. We will learn both how microservices instances register themselves
    to the Eureka server during their startup and how clients can use the Eureka server to
    find microservice instances it wants to call.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何将微服务实例连接到Netflix Eureka服务器。我们将学习微服务实例在启动过程中如何向Eureka服务器注册自己，以及客户端如何使用Eureka服务器来查找它想要调用的微服务实例。
- en: 'To be able to register a microservice instance in the Eureka server, we need
    to do the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在Eureka服务器中注册微服务实例，我们需要执行以下操作：
- en: 'Add a dependency to `spring-cloud-starter-netflix-eureka-client` in the build
    file, `build.gradle`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件`build.gradle`中添加对`spring-cloud-starter-netflix-eureka-client`的依赖：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When running tests on a single microservice, we don''t want to depend on having
    the Eureka server up and running. Therefore, we will disable the use of Netflix
    Eureka in all Spring Boot tests, that is, JUnit tests annotated with `@SpringBootTest`. This
    can be done by adding the `eureka.client.enabled` property and setting it to `false`
    in the annotation, like so:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个微服务上运行测试时，我们不希望依赖于Eureka服务器的运行。因此，我们将禁用所有Spring Boot测试中对Netflix Eureka的使用，即使用`@SpringBootTest`注解的JUnit测试。可以通过在注解中添加`eureka.client.enabled`属性并将其设置为`false`来实现：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, add some configuration. Please go to the *Set**ting up configuration
    for use in the development process* section, where we will go through the configuration
    for both the Eureka server and our microservices.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一些配置。请转到*设置用于开发过程中的配置*部分，我们将在那里讨论Eureka服务器和我们的微服务的配置。
- en: There is, however, one property in the configuration that is extra important: `spring.application.name`.
    It is used to give each microservice a virtual hostname, that is, a name used
    by the Eureka service to identify each microservice. Eureka clients will use this virtual
    hostname in the URLs that are used to make HTTP calls to the microservice, as
    we will see as we proceed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，配置中有一个属性非常重要：`spring.application.name`。它用于为每个微服务提供虚拟主机名，即Eureka服务用于识别每个微服务的名称。Eureka客户端将在用于向微服务发出HTTP调用的URL中使用这个虚拟主机名，随着我们的进行，我们将看到。
- en: 'To be able to look up available microservices instances through the Eureka
    server in the `product-composite` microservice, we also need to do the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够通过Eureka服务器在`product-composite`微服务中查找可用的微服务实例，我们还需要执行以下操作：
- en: 'Add a load balancer-aware `WebClient` builder, as described previously, in
    an application class, that is, `se.magnus.microservices.composite.product.ProductCompositeServiceApplication`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类`se.magnus.microservices.composite.product.ProductCompositeServiceApplication`中添加一个负载均衡感知的`WebClient`构建器，如前所述：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update how the `WebClient` object is created in the integration class, `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`.
    The `@LoadBalanced` annotation will, as described previously, result in that Spring
    will inject a load balancer-aware filter into the `WebClient.Builder` bean. Unfortunately,
    this isn''t done until after the constructor runs in the integration class. This
    means that we have to move the construction of `webClient` away from the constructor,
    as we did in [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, to a separate getter method that creates the `webClient`
    lazily, that is, once it''s used for the first time. This is shown in the following
    code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新集成类`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`中创建`WebClient`对象的方式。如前所述，`@LoadBalanced`注解将导致Spring将一个负载均衡感知过滤器注入到`WebClient.Builder`
    bean中。不幸的是，这并不会在构造函数运行之后立即完成，这意味着我们必须将`webClient`的构建从构造函数中移开，就像我们在[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)中所做的那样，*开发响应式微服务*，移到一个单独的getter方法中，该方法在第一次使用`webClient`时才会创建。如下代码所示：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Whenever `WebClient` is used to create an outgoing HTTP request, it is accessed
    via the `getWebClient()` getter method (instead of using the `webClient` field
    directly). See the following example:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当使用`WebClient`创建出站HTTP请求时，都是通过`getWebClient()` getter方法访问的（而不是直接使用`webClient`字段）。请参见以下示例：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now get rid of our hardcoded configuration of available microservices
    in `application.yml`. For example, consider the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以摆脱`application.yml`中对可用微服务的硬编码配置。例如，考虑以下代码：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The corresponding code in the integration class that handled the hardcoded
    configuration is replaced by a declaration of the base URLs to the APIs of the
    core microservices. This is shown in the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 处理硬编码配置的集成类中的相应代码被替换为对核心微服务API的基本URL的声明。如下代码所示：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The hostnames in the preceding URLs are not actual DNS names. Instead, they
    are the virtual hostnames that are used by the microservices when they register
    themselves to the Eureka server, that is, the values of the `spring.application.name` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述URL中的主机名不是实际的DNS名称。相反，它们是微服务在注册到Eureka服务器时使用的虚拟主机名，即`spring.application.name`属性的值。
- en: Knowing how to connect microservice instances to a Netflix Eureka server, we
    can move on and learn how to configure both a Eureka server and microservice instances
    that need to connect to a Eureka server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何将微服务实例连接到Netflix Eureka服务器后，我们可以继续学习如何配置Eureka服务器和需要连接到Eureka服务器的微服务实例。
- en: Setting up configuration for use in the development process
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用于开发过程中的配置
- en: 'Now, it''s time for the trickiest part of setting up Netflix Eureka as a discovery
    service, that is, setting up a working configuration for both the Eureka server
    and its clients: our microservice instances.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是设置Netflix Eureka作为发现服务的最棘手的部分，也就是为Eureka服务器和其客户端（我们的微服务实例）设置一个可工作的配置。
- en: Netflix Eureka is a highly configurable discovery server that can be set up
    for a number of different use cases, and it provides robust, resilient, and fault-tolerant
    runtime characteristics. One downside of this flexibility and robustness is that
    it has an almost overwhelming number of configuration options. Fortunately, Netflix
    Eureka comes with good default values for most of the configurable parameters—at
    least when it comes to using them in a production environment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka是一个高度可配置的发现服务器，可以为许多不同的用例进行设置，并提供强大、有弹性和容错的运行特性。这种灵活性和健壮性的一个缺点是它有几乎令人难以置信的多种配置选项。幸运的是，Netflix
    Eureka对大多数可配置参数都有很好的默认值，至少在生产环境中使用时是这样。
- en: When it comes to using Netflix Eureka during development, the default values
    cause long startup times. For example, it can take a long time for a client to
    make an initial successful call to a microservices instance that is registered
    in the Eureka server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中使用Netflix Eureka时，默认值会导致长时间的启动时间。例如，客户端可能需要很长时间才能成功调用注册在Eureka服务器中的微服务实例。
- en: Up to two minutes of wait time can be experienced when using the default configuration
    values. This wait time is added to the time it takes for the Eureka service and
    the microservices to start up. The reason for this wait time is that the involved
    processes need to synchronize registration information with each other.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置值时可能会遇到长达两分钟的等待时间。这个等待时间加上Eureka服务和微服务启动所需的时间。这个等待时间的原因是涉及的进程需要相互同步注册信息。
- en: The microservices instances need to register with the Eureka server, and the
    client needs to gather information from the Eureka server. This communication
    is mainly based on heartbeats, which happen every 30 seconds by default. A couple
    of caches are also involved, which slows down the propagation of updates.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实例需要向Eureka服务器注册，客户端需要从Eureka服务器收集信息。这种通信主要基于心跳，默认情况下每30秒发生一次。还涉及到一些缓存，这会减慢更新的传播速度。
- en: We will use a configuration that minimizes this wait time, which is useful during
    development. For use in production environments, the default values should be
    used as a starting point!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种最小化等待时间的配置，这在开发过程中很有用。在生产环境中，应该使用默认值作为起点！
- en: We will only use one Netflix Eureka server instance, which is okay in a development
    environment. In a production environment, you should always use two or more instances to
    ensure high availability for the Netflix Eureka server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会使用一个Netflix Eureka服务器实例，在开发环境中是可以的。在生产环境中，您应该始终使用两个或更多实例，以确保Netflix Eureka服务器的高可用性。
- en: Let's start to learn what types of configuration parameters we need to know
    about.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习我们需要了解的配置参数的类型。
- en: Eureka configuration parameters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka配置参数
- en: 'The configuration parameters for Eureka are divided into three groups:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka的配置参数分为三组：
- en: There are parameters for the Eureka server, prefixed with `eureka.server`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些用于Eureka服务器的参数，以`eureka.server`为前缀。
- en: There are parameters for Eureka clients, prefixed with `eureka.client`. This
    is for clients who want to communicate with a Eureka server.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些用于Eureka客户端的参数，以`eureka.client`为前缀。这是为了与Eureka服务器通信的客户端。
- en: There are parameters for Eureka instances, prefixed with `eureka.instance`.
    This is for the microservices instances that want to register themselves in the
    Eureka server.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些用于Eureka实例的参数，以`eureka.instance`为前缀。这是为了想要在Eureka服务器中注册自己的微服务实例。
- en: 'Some of the available parameters are described in the Spring Cloud documentation:
    *Service Discovery: Eureka Server*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server)
    *Service Discovery: Eureka Clients*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用参数在Spring Cloud文档中有描述：*服务发现：Eureka服务器*：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server)
    *服务发现：Eureka客户端*：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients)
- en: 'For an extensive list of available parameters, I recommend reading the source
    code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可用参数的详尽列表，我建议阅读源代码：
- en: For Eureka server parameters, look at the `org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean` class
    for default values and the `com.netflix.eureka.EurekaServerConfig` interface for
    the relevant documentation.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka服务器参数，请查看`org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean`类的默认值和`com.netflix.eureka.EurekaServerConfig`接口的相关文档。
- en: For Eureka client parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`
    class for the default values anddocumentation.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka客户端参数，请查看`org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`类的默认值和文档。
- en: For Eureka instance parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`
    class for default values and documentation.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka实例参数，请查看`org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`类的默认值和文档。
- en: Let's start to learn about configuration parameters for the Eureka server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习Eureka服务器的配置参数。
- en: Configuring the Eureka server
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Eureka服务器
- en: 'To configure the Eureka server for use in a development environment, the following
    configuration can be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first part of the configuration, for a Eureka `instance` and `client` is
    a standard configuration of a standalone Eureka server. For details, see the Spring
    Cloud documentation that we referred to previously. The last two parameters used
    for the Eureka `server`, `waitTimeInMsWhenSyncEmpty` and `response-cache-update-interval-ms`,
    are used to minimize the startup time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: With the Eureka server configured, we are ready to see how clients to the Eureka
    server, that is, the microservice instances, can be configured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Configuring clients to the Eureka server
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to connect to the Eureka server, the microservices have the following
    configuration:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `eureka.client.serviceUrl.defaultZone` parameter is used to find the Eureka
    server, whereas the other parameters are used to minimize the startup time and
    the time it takes to deregister a microservice instance that is stopped.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `product-composite` microservice, which uses the Eureka server to look
    up the other microservices, also has two Netflix Ribbon-specific parameters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These two parameters are also used to minimize startup time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have everything in place required to actually try out discovery service
    using the Netflix Eureka server together with our microservices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can try out the discovery service by launching two extra `review` microservice
    instances:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the preceding command, we ask Docker Compose to run three instances of
    the `review` service. Since one instance is already running, two new instances
    will be started up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new instances are up and running, browse to `http://localhost:8761/`
    and expect something like the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b53f6c5c-f964-4731-8907-8482ddd11cca.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: After running this localhost, verify that you can see three `review` instances
    in the Netflix Eureka web UI, as shown in the preceding screenshot.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of knowing when the new instances are up and running is to run the
    `docker-compose logs -f review` command and look for output that looks as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/249647b6-1f89-4d9a-800c-d84d740893f6.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'We can also use a REST API that the Eureka service exposes. To get a list of
    instance IDs, we can issue a `curl` command, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Expect a response that looks similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66ef4c5e-20f9-4056-8bdb-e4398a194d4e.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have all of the instances up and running, let''s try out the client-side
    load balancer by making some requests and focusing on the address of the `review`
    service in the responses, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect responses similar to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccd79bc6-a3e1-43aa-891f-553c6f727741.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Note that the address of the `review` service changes in each response; that
    is, the load balancer uses a round-robin to call the available `review` instances,
    one at a time!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also take a look into the `review` instances log with the following
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After this, you will see output that looks similar to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cadd482e-aa89-4949-972e-d8fb4f3f1145.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we can see how the three review microservice instances, `review_1`, `review_2`,
    and `review_3`, in turn, have responded to the requests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: After trying out scaling up microservice instances we will try out what happens
    when we scale down the instances.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Scaling down
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s also see what happens if we lose one instance of the `review` microservice.
    We can simulate that one instance stops unexpectedly by running the following
    command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the shutdown of the `review` instance, there is a short time slot when
    calls to the API might fail. This is caused by the time it takes for information
    regarding the lost instance to propagate to the client, that is, the `product-composite`
    service. During this time frame, the client-side load balancer might choose the
    instance that no longer exists. To prevent this from occurring, resilience mechanisms
    such as timeouts and retries can be used. In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving
    Resilience Using Resilience4j*, we will see how this can be applied. For now,
    let''s specify a timeout on our `curl` command, using the `-m 2` switch to specify
    that we will wait no longer than two seconds for a response:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`review`实例关闭后，API的调用可能会失败一小段时间。这是由于丢失实例的信息传播到客户端（即`product-composite`服务）所需的时间。在这段时间内，客户端负载均衡器可能会选择不再存在的实例。为了防止这种情况发生，可以使用超时和重试等弹性机制。在[第13章](23795d34-4068-4961-842d-989cde26b642.xhtml)中，*使用Resilience4j改善弹性*，我们将看到如何应用这一点。现在，让我们在我们的`curl`命令上指定一个超时，使用`-m
    2`开关来指定我们等待响应的时间不超过两秒：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If a timeout occurs, that is, the client-side load balancer tries to call an
    instance that no longer exists, the following response is expected from `curl`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生超时，即客户端负载均衡器尝试调用不再存在的实例，则从`curl`预期的响应如下：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Besides that, we should expect normal responses from the two remaining instances;
    that is, the `serviceAddresses.rev` field should contain the addresses of the
    two instances, as in the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们应该期望从剩下的两个实例中得到正常的响应；也就是说，`serviceAddresses.rev`字段应该包含两个实例的地址，如下所示：
- en: '![](img/25abdb94-b95c-4cb9-baea-c5917f2ce8af.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25abdb94-b95c-4cb9-baea-c5917f2ce8af.png)'
- en: In the preceding sample output, we can see that two different container names
    and IP addresses are reported. This means that the requests have been served by
    different microservice instances.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例输出中，我们可以看到报告了两个不同的容器名称和IP地址。这意味着请求已由不同的微服务实例提供。
- en: 'After trying out the scaling down of microservice instances, we can try out
    something that is a bit more disruptive: stopping the Eureka server and seeing
    what happens when the discovery service is temporarily unavailable.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试缩减微服务实例规模之后，我们可以尝试一些更具破坏性的事情：停止Eureka服务器并查看当发现服务暂时不可用时会发生什么。
- en: Disruptive tests with the Eureka server
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka服务器进行破坏性测试
- en: Let's bring some disorder to our Eureka server and see how the system landscape
    manages it!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的Eureka服务器带来一些混乱，看看系统景观如何管理它！
- en: To start with, what happens if we crash the Eureka server?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们崩溃Eureka服务器会发生什么？
- en: As long as clients have read the information regarding available microservice
    instances from the Eureka server before it is stopped, the clients will be fine
    since they cache the information locally. However, new instances will not be made
    available to clients, and they will not be notified if any running instances are
    terminated. So, calls to instances that are no longer running will cause failures.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 只要客户端在Eureka服务器停止之前从Eureka服务器读取了可用微服务实例的信息，客户端就会很好，因为它们会在本地缓存信息。然而，新实例将不会对客户端可用，并且如果任何正在运行的实例被终止，客户端也不会收到通知。因此，对不再运行的实例的调用将导致失败。
- en: Let's try this out!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试！
- en: Stopping the Eureka server
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止Eureka服务器
- en: 'To simulate that the Eureka server crashes, follow these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟Eureka服务器崩溃，请按照以下步骤进行操作：
- en: 'First, stop the Eureka server and keep the two `review` instances up and running:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，停止Eureka服务器并保持两个`review`实例正常运行：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Try a couple of calls to the API and extract the service address of the `review`
    service:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调用API并提取`review`服务的服务地址：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The response will—just like before we stopped the Eureka server—contain the
    addresses of the two `review` instances, like so:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将与我们停止Eureka服务器之前一样，包含两个`review`实例的地址。
- en: '![](img/91291ded-566c-4cea-b151-aeea0e4c6390.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91291ded-566c-4cea-b151-aeea0e4c6390.png)'
- en: This shows that the client can make calls to existing instances, even though
    the Eureka server is no longer running!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明客户端可以调用现有实例，即使Eureka服务器不再运行！
- en: Stopping a review instance
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个review实例
- en: 'To further investigate what the effects are of a crashed Eureka server, let''s
    simulate that one of the remaining `review` microservice instances also crashes.
    Terminate one of the two `review` instances with the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步调查崩溃的Eureka服务器的影响，让我们模拟剩下的`review`微服务实例中的一个也崩溃。使用以下命令终止其中一个两个`review`实例：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The client, that is, the `product-composite` service, will not be notified that
    one of the `review` instances has disappeared since no Eureka server is running.
    Due to this, it still thinks that there are two instances up and running. Every
    second call to the client will cause it to call a `review` instance that no longer
    exists, resulting in the response from the client not containing any information
    from the `review` service. The service address of the `review` service will be
    empty.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端，即`product-composite`服务，将不会收到通知，即`review`实例已经消失，因为没有运行Eureka服务器。因此，它仍然认为有两个实例正在运行。对客户端的每第二次调用将导致它调用一个不再存在的`review`实例，导致客户端的响应不包含来自`review`服务的任何信息。`review`服务的服务地址将为空。
- en: Try out the preceding `curl` command to verify that the service address of the
    `review` service will be empty every second time. This can be prevented, as described
    previously, by using resilience mechanisms such as timeouts and retries.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用前面的`curl`命令来验证`review`服务的服务地址每隔一秒钟会为空。可以通过使用诸如超时和重试之类的弹性机制来防止这种情况发生，如前所述。
- en: Starting up an extra instance of the product service
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动产品服务的额外实例
- en: 'As a final test of the effects of a crashed Eureka server, let''s see what
    happens if we start up a new instance of the `product` microservice. Perform the
    following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对崩溃的Eureka服务器影响的最终测试，让我们看看如果我们启动一个新的`product`微服务实例会发生什么。执行以下步骤：
- en: 'Let''s try starting a new instance of the `product` service:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试启动一个新的“product”服务实例：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Call the API a couple of times and extract the address of the `product` service
    with the following command:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次调用API并使用以下命令提取“product”服务的地址：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since no Eureka server is running, the client will not be notified of the new
    `product` instance, and so all calls will go to the first instance, as in the
    following example:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有运行Eureka服务器，客户端将不会收到新的“product”实例的通知，因此所有调用都将转到第一个实例，如下例所示：
- en: '![](img/a783eca8-e0b7-48be-947d-c972032e4c9b.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a783eca8-e0b7-48be-947d-c972032e4c9b.png)'
- en: Now we have seen some of the most important aspects of not having a Netflix
    Eureka server up and running. Let's conclude the section on disruptive tests by
    starting up the Netflix Eureka server again and seeing how the system landscape
    handles self-heals, that is, resilience.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了没有运行Netflix Eureka服务器的一些最重要的方面。让我们通过再次启动Netflix Eureka服务器来结束对破坏性测试的部分，并看看系统景观如何处理自我修复，即韧性。
- en: Starting up the Eureka server again
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次启动Eureka服务器
- en: 'In this section, we will wrap up the disruptive tests by starting up the Eureka
    server again. We shall also verify that the system landscape self-heals, that
    is, verify that the new instance of the `product` microservice gets registered
    with the Netflix Eureka server and that the client gets updated by the Eureka
    server. Perform the following steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过再次启动Eureka服务器来结束破坏性测试。我们还将验证系统景观是否自我修复，即验证“product”微服务的新实例是否已在Netflix
    Eureka服务器上注册，并且客户端是否已被Eureka服务器更新。执行以下步骤：
- en: 'Start the Eureka server with the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动Eureka服务器：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Make some new calls to the API and verify that the following happens:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对API进行一些新的调用，并验证以下情况发生：
- en: All calls go to the remaining `review` instance, that is, the client has detected
    that the second `review` instance has gone.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有调用都转到剩下的“review”实例，即客户端已检测到第二个“review”实例已经消失。
- en: Calls to the `product` service are load-balanced over the two `product` instances,
    that is, the client has detected that there are two `product` instances available.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对“product”服务的调用在两个“product”实例之间进行负载平衡，即客户端已检测到有两个“product”实例可用。
- en: 'Make the following call a couple of times to extract the addresses of the product
    and the `review` service:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次调用以下命令以提取产品和“review”服务的地址：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Verify that the responses from the API calls contain addresses to the involved
    `product` and `review` instances, like so:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证API调用的响应是否包含涉及“product”和“review”实例的地址，如下所示：
- en: '![](img/4c8c141a-2404-4b8c-bf33-b7a0b59c5476.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c8c141a-2404-4b8c-bf33-b7a0b59c5476.png)'
- en: 'This is the second response:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个响应：
- en: '![](img/03c25c97-63a7-49d6-82b1-72ea5a69ac79.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03c25c97-63a7-49d6-82b1-72ea5a69ac79.png)'
- en: The `192.168.128.3` and `192.168.128.7` IP addresses belong to the two `product`
    instances. `192.168.128.9` is the IP address of the `review` instance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.128.3`和`192.168.128.7` IP地址属于两个“product”实例。`192.168.128.9`是“review”实例的IP地址。'
- en: To summarize, the Eureka server provides a very robust and resilient implementation
    of a discovery service. If even higher availability is desired, multiple Eureka
    servers can be launched and configured to communicate with each other. Details
    on how to set up multiple Eureka servers can be found in the Spring Cloud documentation: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Eureka服务器提供了一个非常强大和有韧性的发现服务实现。如果需要更高的可用性，可以启动多个Eureka服务器并配置它们进行通信。有关如何设置多个Eureka服务器的详细信息，请参阅Spring
    Cloud文档：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness)。
- en: 'Finally, shut down the system landscape with the command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令关闭系统景观：
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This completes the tests of the discovery server, Netflix Eureka, where we have
    learned both how to scale up and scale down microservice instances and learned
    what happens if a Netflix Eureka server crashes and later on comes back online.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对发现服务器Netflix Eureka的测试，我们学会了如何扩展和缩减微服务实例，并了解了如果Netflix Eureka服务器崩溃后再次上线会发生什么。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Netflix Eureka for service discovery.
    First, we looked into the shortcomings of a simple DNS-based service discovery
    solution and the challenges that a robust and resilient service discovery solution
    must be able to handle.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Netflix Eureka进行服务发现。首先，我们研究了简单基于DNS的服务发现解决方案的缺点，以及强大和有韧性的服务发现解决方案必须能够处理的挑战。
- en: Netflix Eureka is a very capable service discovery solution that provides robust,
    resilient, and fault-tolerant runtime characteristics. However, it can be challenging
    to configure correctly, especially for smooth developer experience. With Spring
    Cloud, it becomes easy to set up a Netflix Eureka server and adapt Spring Boot-based
    microservices, both so that they can register themselves to Eureka during startup
    and, when acting as a client to other microservices, to keep track of available
    microservices instances.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka是一个非常有能力的服务发现解决方案，提供了强大、有韧性和容错的运行特性。然而，正确配置可能具有挑战性，特别是对于开发人员的顺畅体验。使用Spring
    Cloud，可以轻松设置Netflix Eureka服务器，并适应基于Spring Boot的微服务，使它们在启动时能够注册到Eureka，并在作为其他微服务的客户端时跟踪可用的微服务实例。
- en: With a discovery service in place, it's time to see how we can handle external
    traffic using Spring Cloud Gateway as an edge server. Head over to the next chapter
    to find out how!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有了发现服务，现在是时候看看如何使用Spring Cloud Gateway作为边缘服务器处理外部流量了。前往下一章了解详情！
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is required to turn a Spring Boot application created with Spring Initializr
    into a fully-fledged Netflix Eureka Server?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用Spring Initializr创建的Spring Boot应用程序转换为完整的Netflix Eureka服务器需要什么？
- en: What is required to make a Spring Boot-based microservice register itself automatically
    as a startup with Netflix Eureka?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使基于Spring Boot的微服务在启动时自动向Netflix Eureka注册，需要什么？
- en: What is required to make it possible for a Spring Boot-based microservice to
    call another microservice that is registered in a Netflix Eureka server?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使基于Spring Boot的微服务能够调用在Netflix Eureka服务器中注册的另一个微服务，需要什么？
- en: 'Let''s assume that you have a Netflix Eureka server up and running, along with
    one instance of microservice *A* and two instances of microservice *B*. All microservice
    instances register themselves with the Netflix Eureka server. Microservice *A*
    makes HTTP requests to microservice *B* based on the information it gets from
    the Eureka server. What will happen if, in turn, the following happens:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您已经启动并运行了Netflix Eureka服务器，以及一个微服务*A*的实例和两个微服务*B*的实例。所有微服务实例都会向Netflix Eureka服务器注册。微服务*A*根据从Eureka服务器获取的信息向微服务*B*发出HTTP请求。如果接下来发生以下情况，会发生什么：
- en: The Netflix Eureka server crashes
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器崩溃
- en: One of the instances of microservice *B* crashes
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个微服务*B*的实例崩溃
- en: A new instance of microservice *A* starts up
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的微服务*A*实例启动
- en: A new instance of microservice *B* starts up
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的微服务*B*实例启动
- en: The Netflix Eureka server starts up again
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器重新启动

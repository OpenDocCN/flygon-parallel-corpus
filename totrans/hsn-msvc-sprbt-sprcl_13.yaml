- en: Securing Access to APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn to
    use HTTPS to protect against eavesdropping on external access to our APIs and
    also how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will study the use of
    HTTP basic authentication to secure access to the discovery service, Netflix Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general discussion on how to secure the system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an authorization server to our system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting external communication with HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing access to the discovery service, Netflix Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with the local authorization server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with an OpenID Connect provider, Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying them so they run on another platform such as Linux or Windows should
    be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following commands can be used to perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, that is, the latest available version of the Spring
    components at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/eureka-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/authorization-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter11`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes applied to the source code in [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Secure
    Access to APIs*, that is, to see what it took to secure access to the APIs in
    the microservice landscape, you can compare it with the source code for [Chapter
    10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using Spring Cloud Gateway to
    Hide Microservices Behind an Edge Server*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before introducing OAuth 2.0 and OpenID Connect, let's clarify what we mean
    with authentication and authorization. **Authentication** means identifying a
    user by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated, that is, an identified user. In our case, a user will
    be assigned a set of privileges based on OAuth 2.0 scopes, as explained hereinafter.
    The microservices will be based on these privileges determine whether the user
    is allowed to access an API.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2.0** is an open standard for authorization, and **OpenID Connect** is
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users based on the authentication performed by the authorization server. Let''s
    look briefly at OAuth 2.0 and OpenID Connect separately to get an initial understanding
    of their purposes!'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OAuth 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OAuth** *2.0* is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with sorting out the concepts used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: The end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server:** The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client is registered in the authorization server and is given a **client ID** and
    a **client secret**. The client secret must be protected by the client, like a
    password. A client also gets registered with a set of allowed **redirect-URIs** that
    the authorization server will use after a user has been authenticated to send
    **grant codes** and **tokens** that have been issued back to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example by way of illustration. Let's say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as a *scope* in OAuth 2.0 terms. A **refresh token**
    can also be issued to a client application by the authorization server. A refresh
    token can be used by the client application to obtain new access tokens without
    having to involve the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization Code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interact with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Explanations for this diagram are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will authenticate the user and ask for the user's consent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will redirect the user back to the client application
    with a grant code. The authorization server will use the redirect-URI specified
    by the client in step 1 to know where to send the grant code. Since the grant
    code is passed back to the client application using the web browser, that is,
    to an insecure environment where malicious JavaScript code potentially can pick
    up the grant code, it is only allowed to be used once and only during a short
    time period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To exchange the grant code for an access token, the client application is expected
    to call the authorization server again, using server-side code. The client application
    must present its client ID and client secret together with the grant code for
    the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. Steps 6 and 7 can be repeated as long as the
    access token is valid. When the lifetime of the access token has expired, the
    client can use their refresh token to acquire a new access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicit grant flow**: This flow is also web browser-based, but intended
    for client applications that are not able to keep a client secret protected, for
    example, a single-page web application. It gets an access token back from the
    authorization server instead of a grant code, but cannot request a refresh token,
    since it is using the implicit grant flow that is less secure than the code grant
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Owner Password Credentials grant flow**: If a client application
    can''t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client Credentials grant flow:** In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the **Resource Owner Password Credentials grant flow** is very handy since it
    doesn't require manual interaction using a web browser. We will use this later
    on in this chapter with our test script; see the *Changes in the test script* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).'
  prefs: []
  type: TYPE_NORMAL
- en: One additional specification that is worth some extra attention is *RFC 7636
    – Proof Key for Code Exchange by OAuth Public Clients (PKCE), *[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).
    This specification describes how an otherwise insecure public client, such as
    a mobile native app or desktop application, can utilize the code grant flow by
    adding an extra layer of security.
  prefs: []
  type: TYPE_NORMAL
- en: Securing access to the discovery service, Netflix Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned to protect external communication with HTTPS. Now we
    will use HTTP basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka; that is, we will require a user to supply
    a username and password to get access. Changes are required both on the Eureka
    server and in the Eureka clients described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenID Connect** (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.'
  prefs: []
  type: TYPE_NORMAL
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating the digital signature using
    public keys from the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory according to the specification. Finally, OIDC
    defines a **discovery endpoint**, which is a standardized way to establish URLs
    to important endpoints, such as initiating a grant flow, getting the public keys
    to verify a digitally signed JWT token, and a **user-info endpoint**, which can
    be used to get extra information about an authenticated user given an access token
    for that user.
  prefs: []
  type: TYPE_NORMAL
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the system landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure access to the discovery service, Netflix Eureka, using HTTP basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter on service mesh ([Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*) that will appear
    later in this book, we will see how we can get help from a service mesh product
    to automatically provision HTTPS to secure communication inside a system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: For test purposes, we will add a local OAuth *2.0* authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the product-composite service
    will act as OAuth 2.0 resource servers; that is, they will require a valid OAuth
    2.0 access token to allow access.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWT tokens and that the authorization server exposes an
    endpoint that the resource servers can use to access the public keys, also known
    as `jwk-set`, required to validate the signing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system landscape will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding diagram, we can note that:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the edge server and the product composite microservice will validate access
    tokens as signed JWT tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The edge server and the product composite microservice will get the authorization
    server's public keys from its `jwk-set` endpoint, and use them to validate the
    signature of the JWT-based access tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the *Category:OWASP Top Ten Project*.
    Refer to [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
    for more information on the OWASP Top Ten.
  prefs: []
  type: TYPE_NORMAL
- en: With this overview of how the system landscape will be secured, let's start
    by adding a local authorization server to the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an authorization server to our system landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an OAuth 2.0-based authorization
    server to our system landscape. Spring Security 5.1 does not, unfortunately, provide
    an authorization server out of the box. But there is a legacy project (currently
    in maintenance mode), Spring Security OAuth, that provides an authorization server that
    we can use.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, in the samples provided by Spring Security 5.1, a project using the
    authorization server from Spring Security OAuth is available. It is configured
    to use JWT-encoded access tokens, and it also exposes an endpoint for a **JSON
    Web Key Set** (**JWKS**) (part of the OpenID Connect Discovery standard), a set
    of keys containing the public keys that can be used by resource servers to verify
    JWT tokens issued by the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if it isn't a full-blown OpenID Connect provider, it is suitable for
    use together with tests that we want to be able to run locally and in a fully
    automated manner.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on planned support for OAuth 2.0 in Spring Security, refer
    to [https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security).
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server in the Spring Security sample projects is available
    here: [https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Security sample project configures two OAuth clients, `reader` and
    `writer`, where the `reader` client is granted a read scope, and the `writer`
    client is granted both a read and a write scope. Both clients are configured to
    have the secret set to `secret`; refer to the `configure()` method in the `sample.AuthorizationServerConfiguration` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following changes have been applied to the sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: A Eureka client has been added in the same way as for the other microservices.
    See [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery
    Using Netflix Eureka and Ribbon;* refer to the *Connecting microservices to a
    Netflix Eureka server* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot Actuator has been added to get access to the `health` endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Dockerfile has been added to be able to run the authorization server as a
    Docker container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gradle build file, `spring-security-samples-boot-oauth2authorizationserver.gradle`,
    has been changed to become more like the `build.gradle` files used in the source
    code of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration in the `sample/AuthorizationServerConfiguration` class has
    been changed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Support has been added for the grant types: `code`, `authorization_code`, and
    `implicit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the scopes, `message:read` and `message:write`, have been changed to
    `product:read` and `product:write`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username of the user registered in the authorization server has been changed
    to `magnus`, with the password `password`; refer to the `userDetailsService()`
    method in the `UserConfig` class (found in the `sample/AuthorizationServerConfiguration.java` file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate the authorization server in the system landscape, a number of
    changes have been applied. The authorization server has been added to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The common build file, `settings.gradle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three Docker Compose files, `docker-compose*.yml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The edge server, `spring-cloud/gateway`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A health check has been added to `HealthCheckConfiguration`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route for URIs starting with `/oauth/` has been added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an understanding of how a local authorization server is added to the system
    landscape, let's move on and see how we can protect external communication from eavesdropping
    using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting external communication with HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example from the internet, via the public APIs exposed by the edge server. We
    will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The self-signed certificate is created with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The source code comes with a sample certificate file, so you don't need to run
    this command to run the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath in runtime at: `keystore/edge.p12`.
  prefs: []
  type: TYPE_NORMAL
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    The following shows how we can replace this certificate with an external certificate
    at runtime!
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the explanations for the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to the `classpath:keystore/edge.p12` value. This means that the certificate
    will be picked up on the classpath from the location, `keystore/edge.p12`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password for the certificate is specified in the `server.ssl.key-store-password` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: The three Docker Compose files, `docker-compose*.yml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test script, `test-em-all.bash`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing certificates using the classpath is as already mentioned previously
    only sufficient during development; let's see how we can replace this certificate
    with an external certificate in runtime!
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a self-signed certificate in runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  prefs: []
  type: TYPE_NORMAL
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the new certificate in the Docker volume.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction to
    Kubernetes*, we will learn about Kubernetes, where we will see more powerful solutions
    for how to handle secrets, such as certificates, that are suitable for running
    Docker containers in a cluster; that is, where containers are scheduled on a group
    of Docker hosts and not on a single Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: The changes described in this topic have **not** been applied to the source
    code in the book's GitHub repository; that is, you need to make them yourself
    to see them in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a second certificate and set the password to `testtest`, when asked
    for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location and password for the new certificate and a volume that maps to
    the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the `gateway` service, but it actually does not take changes in
    `docker-compose.yml` into consideration. Hence, it is not a useful command in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: The new certificate is now in use!
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section we will learn how to secure access to the discovery service,
    Netflix Eureka, using HTTP basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect the Eureka servers, the following changes have been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency in `build.gradle` has been added to Spring Security:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Security configuration has been added to the `se.magnus.springcloud.eurekaserver.SecurityConfig` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All APIs and web pages are protected using HTTP basic authentication by means
    of the following definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the test class, `se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`,
    uses the credentials from the configuration file when testing the APIs of the
    Eureka server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding are the steps required for restricting access to the APIs and
    web pages of the discovery server, Netflix Eureka. It will now use HTTP basic
    authentication and require a user to supply a username and password to get access. In
    the next section, we will learn how to configure Netflix Eureka clients so that
    they pass credentials when accessing the Netflix Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Eureka clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Eureka clients, the credentials have to be specified in the connection
    URL for the Eureka server. This is specified in each client''s configuration file,
    `application.yml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will see this configuration in use by Netflix Eureka clients when we test
    the secured system landscape in the *Testing with the local authorization server* section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to add credentials when we manually access
    the Netflix Eureka server, either using its API or its Web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the protected Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the protected Eureka server is up and running, we have to supply valid
    credentials to be able to access its APIs and web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an insecure connection, since our certificate is self-signed, and
    next we have to supply valid credentials, as specified in the preceding configuration
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the next section we will learn how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service so they become OAuth 2.0 resource servers; that
    is, they require a valid access token to allow access. We will configure the edge
    server to accept any access token it can validate using the signature provided
    by the authorization server. The `product-composite` service will also require
    the access token to contain some OAuth 2.0 scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product:read` scope will be required for accessing the read-only APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to enhance our test script, `test-em-all.bash`, so that it acquires
    access tokens before it runs the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in both the edge server and the product-composite service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following changes have been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security 5.1 dependencies have been added to `build.gradle` to support
    OAuth 2.0 resource servers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Security configurations have been added to the `se.magnus.springcloud.gateway.SecurityConfig`
    and `se.magnus.microservices.composite.product.SecurityConfig` classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding source code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow access to URLs
    that should be unprotected, for example, the `actuator` endpoints in this case.
    Refer to the source code for URLs that are treated as unprotected. Be careful
    about which URLs are exposed unprotected. For example, the `actuator` endpoints
    should be protected before going to production:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.oauth2ResourceServer().jwt()` specifies that authentication and authorization
    will be based on a JWT-encoded OAuth 2.0 access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The endpoint of the authorization server''s `jwk-set` endpoint has been registered
    in the configuration file, `application.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With these changes applied to both the edge server and the `product-composite`
    service to make them act as OAuth 2.0 resource servers, we also need to make some
    changes that only apply to the `product-composite` service.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the product-composite service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The security configuration has been refined by requiring OAuth 2.0 scopes in
    the access token in order to allow access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By convention, OAuth 2.0 scopes should be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security, `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class for
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests that permit access to all resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers. The last step we need to take to
    introduce the usage of OAuth 2.0 and OpenID Connect is to update the test script
    so it acquires access tokens and uses them when running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the test script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done using the OAuth 2.0 password flow.
    To be able to call the create and delete APIs, we acquire an access token as the
    `writer` client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test calls an API without supplying an access token. The API is expected
    to return the 401 Unauthorized HTTP status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other test calls an updating API using the `reader` client, which is only
    granted a read scope. The API is expected to return the 403 Forbidden HTTP status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the full source code, see `test-em-all.bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the test scripts updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try them out in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the local authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will try out the secured system landscape; that is, we will
    test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we learn how to acquire access tokens using OAuth 2.0 grant flows: password,
    implicit, and code grant flows.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use access tokens to call APIs. We will also verify that an
    access token issued for a reader client can't be used to call an updating API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and running the automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and run automated tests, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note the new negative tests at the end that verify that we get a 401 Unauthorized
    code back when not authenticated, and 403 Forbidden when not authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can acquire access tokens using the various grant flows defined by OAuth
    2.0\. We will try out the following grant flows: password, implicit, and code
    grant.'
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the password grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an access token for the `writer` client, that is, with both the `product:read` and `product:write` scopes,
    issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The client identifies itself using HTTP basic authentication, passing its `writer`
    client ID, and its secret, `secret`. It sends the credentials of the resource
    owners, that is the end user, using the `username` and `password` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the value of the `access_token` field in the response as the access token
    in an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Acquiring access tokens using the implicit grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To acquire an access token using the implicit grant flow, we need to involve
    a web browser. Open the URL in a web browser that accepts the use of self-signed
    certificates, for example, Chrome. Then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an access token for the `reader` client open the URL, `https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`.
    When asked to login by the web browser, use the credentials specified in the configuration
    of the authorization server, for example, `magnus` and `password`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will be asked to authorize the `reader` client to call the APIs in
    your name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will get the following response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect-URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
  prefs: []
  type: TYPE_NORMAL
- en: Great! We can find the access token in the new URL in the `access_token` request
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the access token in an environment variable, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an access token for the `writer` client, you can use the following URL:
    `https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`.'
  prefs: []
  type: TYPE_NORMAL
- en: You are already authenticated, so you do not need to log in again, but you must
    give your consent to the `writer` client.
  prefs: []
  type: TYPE_NORMAL
- en: Note that no client secret is required; that is, the implicit grant flow is
    not very secure.
  prefs: []
  type: TYPE_NORMAL
- en: Any application can claim that it is the `writer` client and can ask for the
    user's consent to use the requested scopes to access APIs in the name of the user,
    so beware!
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the code grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let's try out the most secure grant flow in OAuth 2.0 – the code grant
    flow!
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the code grant flow, things are a bit more complicated in order
    to make the flow more secure. In the first insecure step, we will use the web
    browser to acquire a code that can be used only once, when it is exchanged with
    an access token. The code shall be passed from the web browser to a secure layer,
    for example, server-side code, which can make a new request the authorization
    server again to exchange the code with an access token. In this exchange, the
    server has to supply a client secret to verify its origin.
  prefs: []
  type: TYPE_NORMAL
- en: To get a code for the `reader` client, use the following URL in the web browser: `https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`.
  prefs: []
  type: TYPE_NORMAL
- en: This time, you will get back a much shorter URL, for example, `http://my.redirect.uri/?code=T2pxvW&state=72489`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the authorization code from the `code` parameter and define an environment
    variable, `CODE`, with its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, pretend you are the backend server that exchanges the authorization code
    with an access token using the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, save the access token in an environment variable as previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To get a code for the `writer` client, use the following URL: `https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using access tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's use the access tokens we have acquired to call the protected APIs!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call an API to retrieve a composite product without a valid access token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return the following response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
  prefs: []
  type: TYPE_IMG
- en: The error message clearly states that the access token is invalid!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, try using the API to retrieve a composite product using one of the access
    tokens acquired for the `reader` client from the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It will fail with a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
  prefs: []
  type: TYPE_IMG
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with 200 OK in the response.
  prefs: []
  type: TYPE_NORMAL
- en: The delete operation should return `200` even if the product with the specified
    product ID does not exist in the underlying database, since the delete operation
    is idempotent, as described in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. Refer to the *Adding new APIs* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the log output using the `docker-compose logs -f product-composite` command, you
    should be able to find authorization information such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
  prefs: []
  type: TYPE_IMG
- en: This information was extracted by the new method, `logAuthorizationInfo()`,
    in the `product-composite` service from the JWT-encoded access token; that is,
    the `product-composite` service did not need to communicate with the authorization
    server to get this information!
  prefs: []
  type: TYPE_NORMAL
- en: With these tests, we have seen how to acquire an access token with the various
    grant flows, that is, password, implicit, and code grant flow. We have also seen
    how scopes can be used to limit what a client can do with a specific access token,
    for example only use is for reading operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will replace the local authorization server used in
    this section to an external OpenID Connect provider.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with an OpenID Connect provider – Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let's find out, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
    We will use Auth0, [https://auth0.com/](https://auth0.com/), for our tests with
    an OpenID provider. To be able to use Auth0 instead of our own authorization server,
    we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account with an OAuth client and a user in Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the changes required to use Auth0 as an OpenID provider and running
    the test script to verify whether it is working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acquiring access tokens using the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization code grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling protected APIs using the access tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **user info** endpoint to get more information about a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us understand each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account and OAuth 2.0 client in Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to sign up for a free account in Auth0, configure
    both an OAuth 2.0 client and the `product-composite` API, and finally register
    a user:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the URL, [https://auth0.com](https://auth0.com), in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the SIGN UP button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign up with an account of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a successful sign-up, you will be asked to create a tenant domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the tenant of your choice, in my case: `dev-ml.eu.auth0.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in information about your account as requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following sign-up, you will be directed to your dashboard. Select the Applications
    tab (on the left) to see the default client application that was created for you
    during the sign-up process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Default App to configure it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Client ID and Client Secret; you will need them later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As Application Type, select Machine to Machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As Token Endpoint Authentication Method, select POST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://my.redirect.uri` as the allowed callback URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Show Advanced Settings, go to the Grant Types tab, deselect Client
    Credentials, and select the Password box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on SAVE CHANGES.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now define authorizations for our API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the APIs tab (on the left) and click on the + CREATE API button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the API `product-composite`, give it the identifier `https://localhost:8443/product-composite`,
    and click on the CREATE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Permissions tab and create two permissions (that is, OAuth scopes)
    for `product:read` and `product:write`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Users & Roles and -> Users tab (on the left) and then on the +
    CREATE YOUR FIRST USER button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an `email` and `password` of your preference and click on the SAVE button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for a verification mail from Auth0 in the Inbox for the email address you
    supplied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, validate your Default Directory setting, used for the password grant
    flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on your tenant profile in the upper-right corner and select Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the tab named General, scroll down to the field named Default Directory and
    verify that it contains the `Username-Password-Authentication` value. If not,
    update the field and save the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! Note that both the default app and the API get a client ID and secret.
    We will use the client ID and secret for the default app; that is, the OAuth client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With an Auth0 account created and configured we can move on and apply the necessary
    configuration changes in the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the necessary changes to use Auth0 as an OpenID provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite`, and the `gateway` services. We also need to change our test
    script a bit, so that it acquires the access tokens from Auth0 instead of from
    our local authorization server. Let's start with the OAuth resource servers, that
    is, the `product-composite` and the `gateway` services.
  prefs: []
  type: TYPE_NORMAL
- en: The changes described in this topic have **not** been applied to the source
    code in the book's Git repository; that is, you need to make them yourself to
    see them in action!
  prefs: []
  type: TYPE_NORMAL
- en: Changing the configuration in the OAuth resource servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using an OpenID Connect provider, we only have to configure the base URI
    to the standardized discovery endpoint in the OAuth resource servers, that is,
    the `product-composite` and the `gateway` service. Spring Security will use the
    information in the response from the discovery endpoint to configure the resource
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product-composite` and `gateway` projects, make the following change
    to the `resource/application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now find the following property setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**: Replace `${TENANT_DOMAIN_NAME}` in the preceding configuration with
    your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`, and do not forget
    the trailing `/`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious, you can see what''s in the discovery document by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the `product-composite` and the `gateway` service updated, we can move
    on and also update the test script.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the test script so it acquires access tokens from Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace `${TENANT_DOMAIN_NAME}`, `${USER_EMAIL}`, `${USER_PASSWORD}`,
    `${CLIENT_ID}`, and `${CLIENT_SECRET}` in the preceding command with the values
    you collected during the registration process in Auth0, as described previously.
    Then, take the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Apply the preceding changes to the command. Also note that we only require the
    `product:read` scope and not the `product:write` scope. This is to simulate a
    client with read-only access.
  prefs: []
  type: TYPE_NORMAL
- en: Now access tokens are issued by Auth0 instead of our local authorization server,
    and our API implementations can verify that the access tokens (have been correctly
    signed by Auth0 and have not expired), using information from Auth0's discovery
    service flagged in the `application.yml` files. The API implementations can, as
    before, use the scopes in the access tokens to authorize the client to perform
    the call to the API, or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the required changes in place, let's run some tests to verify
    that we can acquire access tokens from Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test script with Auth0 as the OpenID Connect provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to give Auth0 a try!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the usual tests against Auth0 with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs (using the `docker-compose logs -f product-composite` command), you
    will be able to find authorization information from the access tokens issued by
    Auth0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see that both scopes are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the log output, we now get information regarding the intended
    audience for this access token. To strengthen security, we could add a test to
    our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would prevent the situation where
    someone tries to use an access token issued for another purpose to get access
    to our API.
  prefs: []
  type: TYPE_NORMAL
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let's start
    with the password grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the password grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn how to acquire an access token from Auth0 using
    the password grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Following the instruction in the *Calling protected APIs using the access tokens* section, you
    should be able to call the APIs using the acquired access token. The next grant
    flow we'll try out is the implicit grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the implicit grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the implicit grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try out the more involved implicit grant flow, you can open
    the following URL in a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Auth0 should present the following login screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The access token is now in the URL in the browser, just like when we tried
    out the implicit flow in our local authorization server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
  prefs: []
  type: TYPE_IMG
- en: To get an access token that corresponds to the `reader` client, remove the `product:write` scope from
    the preceding URL that we used to initiate the implicit grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to acquire an access token using the implicit grant flow,
    we can move on to the third and last grant flow that we will try out, the authorization
    code grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the authorization code grant flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we come to the most secure grant flow – the authorization code grant
    flow. We will follow the same procedure as with the local authorization server;
    that is, we first acquire code and then exchange it for an access token. Get the
    code by opening the following URL in a web browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect a redirect attempt in the web browser to a URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the code and run the following command to get the access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Replace `${TENANT_DOMAIN_NAME}`, `${CLIENT_ID}`, `${CLIENT_SECRET}`, and `${CODE}` in
    the preceding URL with the tenant domain name, client ID, and the client code
    you collected during the registration process in Auth0 as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to acquire access tokens using all three types
    of grant flows, we are ready to try calling the external API using an access token
    acquired from Auth0 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using the Auth0 access tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how we can use an access token acquired from Auth0
    to call the external API.
  prefs: []
  type: TYPE_NORMAL
- en: We can use access tokens issued by Auth0 to call our APIs  just like when we
    used access tokens issued by our local authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a read-only API, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For an updating API, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return 200 OK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting extra information about the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the log output, the ID of the subject, that is, the user,
    is a bit cryptic, for example, `auth0|5ca0b73c97f31e11bc85a5e6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want your API implementation to know a bit more about the user, it can
    call Auth0''s `userinfo_endpoint` as described in the response to the discovery
    request made previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Replace `${TENANT_DOMAIN_NAME}` in the preceding command with the tenant domain
    name you collected during the registration process in Auth0 as described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
  prefs: []
  type: TYPE_IMG
- en: This endpoint can also be used to verify that the user hasn't revoked the access
    token in Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section where we have learned how to replace the local OAuth
    2.0 Authorization server, only used for tests, with an external alternative. We
    have also seen how to reconfigure the microservice landscape to validate access
    tokens using an external OIDC provider.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access and the discovery server, Netflix Eureka,
    using HTTP basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client application. We have learned both how
    to set up a local OAuth 2.0 authorization server based on Spring Security and
    also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: One concern, however, is how to manage the configuration required. Many small
    pieces of configuration must be set up for the microservices involved and the
    configuration must be synchronized to match. Added to the scattered configuration
    is the fact that some of the configuration contains sensitive information, such
    as credentials or certificates. It seems like we need a better way to handle the
    configuration for a number of cooperating microservices and also a solution for
    how to handle sensitive parts of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Spring Cloud Configuration server and
    see how it can be used to handle these types of requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits and shortcomings of using self-signed certificates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 authorization codes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 scopes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean when a token is a JWT token?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we trust the information that is stored in a JWT token?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does OpenID Connect add to OAuth 2.0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

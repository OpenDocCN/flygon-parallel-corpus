- en: Using a Service Mesh to Improve Observability and Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the concept of a service mesh and
    see how its capabilities can be used to handle challenges in a system landscape
    of microservices in areas including security, policy enforcement, resilience,
    and traffic management. A service mesh can also be used to provide observability,
    that is, the capability to visualize how traffic flows between microservices in
    a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: A service mesh overlaps partly with the capabilities of Spring Cloud and Kubernetes
    we learned about earlier in this book. But most of the functionality in a service
    mesh complements Spring Cloud and Kubernetes, as we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the service mesh concept and Istio, a popular open source
    implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will also learn how to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy Istio in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a service mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe a service mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure a service mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that a service mesh is resilient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform zero downtime deployments using a service mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the microservice landscape using Docker Compose to ensure that the source
    code in the microservices is not locked into either Kubernetes or Istio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave,
    but modifying these commands should be sufficiently straightforward to run them
    on another platform such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only new tool required for this chapter is Istio''s command-line tool, `istioctl`.
    This can be installed using Homebrew with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter18](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter18).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands as described in the book, you need to download
    the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Examples of sample commands include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1, SR2 (also known as the **Greenwich** release), Spring Boot
    2.1.6, and Spring 5.1.8, that is, the latest available version of the Spring components
    at the time of writing this chapter. The source code has been tested using Kubernetes
    V1.15.
  prefs: []
  type: TYPE_NORMAL
- en: All source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter18`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, and import and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes applied to the source code in [Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml), *Using
    a Service Mesh to Improve Observability and Management*, that is, the changes
    required to create a service mesh using Istio, you can compare it with the source
    code for [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing
    Kubernetes Features as an Alternative*. You can use your favorite diff tool and
    compare the two folders, `$BOOK_HOME/Chapter17` and `$BOOK_HOME/Chapter18`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to service mesh using Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service mesh is an infrastructure layer that controls and observes the communication
    between services, for example, microservices. The capabilities in a service mesh,
    for example, observability, security, policy enforcement, resilience, and traffic
    management,are implemented by controlling and monitoring all internal communication
    inside the service mesh, that is, between the microservices in the service mesh.
    One of the core components in a service mesh is a lightweight **proxy **component
    that is injected into all microservices that will be part of the service mesh.
    All traffic in and out of a microservice is configured to go through its proxy
    component. The proxy components are configured in runtime by a **control plane** in
    the service mesh using API's exposed by the proxy. The control plane also collects
    telemetry data through these APIs from the proxies to visualize how the traffic
    flows in the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service mesh also contains a** data plane**, consisting of the proxy components
    in all microservices in the service mesh together with separate components for
    handling external incoming and outgoing traffic to and from the service mesh.
    This is illustrated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f4234c5-40c7-405d-856e-9e11009c242d.png)'
  prefs: []
  type: TYPE_IMG
- en: The first publicly available implementation of a service mesh was the open source
    project Linkerd, managed by Buoyant ([https://linkerd.io](https://linkerd.io)),
    having its origins in Twitter's Finagle project ([http://twitter.github.io/finagle](http://twitter.github.io/finagle)).
    It was launched during 2016 and, one year later, in 2017, IBM, Google, and Lyft
    launched the open source project, Istio ([https://istio.io](https://istio.io)).
  prefs: []
  type: TYPE_NORMAL
- en: One of the core components in Istio, the proxy component, is based on Lyft's Envoy
    proxy ([https://www.envoyproxy.io](https://www.envoyproxy.io)). Linkerd and Istio
    are, at the time of writing this chapter, the two most popular and widely used
    service mesh implementations. In this chapter, we will use Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Istio can be deployed in various environments, including Kubernetes (see [https://istio.io/docs/setup](https://istio.io/docs/setup)). When
    deploying Istio on Kubernetes, its runtime components are deployed into a separate
    Kubernetes namespace, `istio-system`. Istio also comes with a set of Kubernetes
    **Custom Resources Definitions** (**CRDs**). CRDs are used in Kubernetes to extend
    its API, that is, to add new objects to its API. The Istio objects added are used
    to configure how Istio will be used. Finally, Istio comes with a CLI tool, `istioctl`,
    which will be used to inject Istio proxies into the microservices that participate
    in the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Istio is, as explained previously, divided into a control plane and a data plane. As
    an operator, we will define a desired state by creating Istio objects in the Kubernetes
    API server, for example, declaring routing rules. The control plane will read
    these objects and send commands to the proxies in the data plane to take actions
    according to the desired state, for example, configuring routing rules. The proxies
    handle the actual communication between the microservices and report back telemetry
    data to the control plane. The telemetry data is used by various components in
    a control plane to visualize what's going on in the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following subsections, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Istio proxies are injected into microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Istio API objects that we will use in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime components in Istio that constitute the control plane and the data
    plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the microservice landscape as a result of the introduction of Istio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting Istio proxies into existing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservices we have deployed in Kubernetes in the previous chapters run
    as a single container in a Kubernetes pod (refer to the *Introducing Kubernetes
    API objects* section in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction
    to Kubernetes*, for a recap). To make a microservice join an Istio-based service
    mesh, an Istio proxy is injected into each microservice. This is done by adding
    an extra container to the pod that runs the Istio proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Containers added to a pod with the aim of supporting the main container, such
    as an Istio proxy, are referred to as a *sideca**r*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an Istio proxy has been injected into a sample
    pod, **Pod A**, as a sidecar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a824d18b-8f01-4c08-97ef-d697d7154fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: The main container in the pod, **Container A**, is configured to route all its
    traffic through the Istio proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Istio proxies can be injected either automatically when a deployment object
    is created or manually using the `istioctl` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will inject the Istio proxies manually. The reason for
    this is that Istio proxies do not support the protocols used by MySQL, MongoDB,
    and RabbitMQ, so we will only inject Istio proxies into pods where the HTTP protocol
    is used. An Istio proxy can be injected into the pods of an existing deployment
    object by means of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command may, at first glance, appear somewhat daunting, but it is actually
    just three separate commands. The previous command sends its output to the next
    command using pipes, that is, the `|` character. Let''s go through each command:'
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl get deployment` command gets the current definition of a deployment
    named `sample-deployment` from the Kubernetes API server and returns its definition
    in the YAML format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `istioctl kube-inject` command reads the definition from the `kubectl get
    deployment` command and adds an extra container for an Istio proxy in pods that
    the deployment handles. The configuration for the existing container in the deployment
    object is updated so that incoming and outgoing traffic goes through the Istio
    proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `istioctl` command returns the new definition of the deployment object,
    including a container for the Istio proxy.
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl apply` command reads the updated configuration from the `istioctl
    kube-inject` command and applies the updated configuration. A rolling upgrade
    of the pods belonging to the deployment will start up in the same way as we have
    seen before (refer to the *Performing a rolling upgrade* section in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying
    Our Microservices to Kubernetes)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deployment scripts in the `kubernetes/scripts` folder have been extended
    to use `istioctl` to inject the Istio proxies. Refer to the upcoming *Creating
    the service mesh* section for details.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Istio API objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Istio extends the Kubernetes API with a number of objects using its CRDs. Refer
    to the *Introducing Kubernetes API objects* section in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction
    to Kubernetes*, for a recap of the Kubernetes API. In this chapter we will use
    the following Istio objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gateway` is used to configure how to handle incoming traffic to, and outgoing
    traffic from, the service mesh. A gateway depends on a virtual service routing
    the incoming traffic to Kubernetes services. We will use a gateway object to accept
    incoming traffic to the DNS name, `minikube.me`, using HTTPS. Refer to the *Kubernetes
    Ingress resource replaced with Istio Ingress Gateway as an edge server* section
    for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualService` is used to define routing rules in the service mesh. We will
    use virtual services to describe how to route incoming traffic from an Istio gateway
    to the Kubernetes services and between services. We will also use virtual services to
    inject faults and delays in order to test the reliability and resilience capabilities
    of the service mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DestinationRule` is used to define policies and rules for traffic that is
    routed (using a virtual service) to a specific service (that is, a destination).
    We will use destination rules to set up encryption policies to encrypt internal
    HTTP traffic and define service subsets that describe available versions of the
    services. We will use service subsets when performing zero downtime (blue/green)
    deployments from an existing version of a microservice to a new version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Policy` is used to define how requests will be authenticated. We will use
    policies to require incoming requests to the service mesh to be authenticated
    using a JWT-based OAuth 2.0/OIDC access token. Refer to the *Authenticating external
    requests using OAuth 2.0/OIDC access tokens* section of this chapter. A policy
    can also be used to define how to secure parts of the internal communication in
    the service mesh. For example, a policy can require that internal requests are
    encrypted using HTTPS or allow plain text requests. Finally, a `MeshPolicy` object
    can be used to define global policies that apply to the whole service mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing runtime components in Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio contains a number of runtime components, is highly configurable in terms
    of what components to use, and provides fine-grained control over the configuration
    of each component. Refer to the *Deploying Istio in a Kubernetes cluster* section
    of this chapter for information on the configuration we will use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration used in this chapter, the Istio control plane consists
    of the following runtime components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pilot**:responsible for supplying all sidecars with updates of the service mesh
    configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixer**: consists of two different runtime components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy** – enforces network policies such as authentication, authorization,
    rate limits, and quotas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telemetry***–*collects telemetry information and sends it to Prometheus, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Galley**:responsible for collecting and validating configuration information
    and distribution to the other Istio components in the control plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Citadel**: responsible for issuing and rotating internally used certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kiali**: provides observability to the service mesh, visualizing what is
    going on in the mesh. Kiali is a separate open source project (see [https://www.kiali.io](https://www.kiali.io))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus**: performs data ingestion and storage for time series-based data,
    for example, performance metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prometheus is a separate open source project (refer to [https://prometheus.io](https://prometheus.io)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Grafana**: visualizes performance metrics and other time series-related data
    collected in Prometheus. Grafana is a separate open source project (see [https://grafana.com](https://grafana.com)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing**: handles and visualizes distributed tracing information. Based
    on Jaeger, it is an open source project for distributed tracing (refer to [https://www.jaegertracing.io](https://www.jaegertracing.io)).
    Jaeger provides the same type of functionality as Zipkin, which we used in [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kiali is accessed using a web browser and integrates Grafana for viewing performance
    metrics and Jaeger for visualizing distributed tracing information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Istio data plane consists of the following runtime components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingress** **Gateway**: handles incoming traffic to the service mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E****gress** **Gateway**: handles outgoing traffic from the service mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All pods with an Istio proxy are injected as a sidecar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The runtime components in Istio''s control plane and data plane are summarized
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc1d5d4f-c2d3-4504-8d01-506c8fec94c4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will go through changes applied to the microservice
    landscape arising from the introduction of Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen in the preceding section, Istio comes with components that
    overlap with components currently used in the microservice landscape in terms
    of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: The Istio Ingress Gateway can act as an edge server, an alternative to the Kubernetes
    Ingress resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jaeger component that comes bundled with Istio can be used for distributed
    tracing instead of Zipkin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following two subsections, we will learn why and how Kubernetes Ingress
    resources are replaced with Istio Ingress Gateway, and how and why Zipkin is replaced
    with Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Ingress resources are replaced with Istio Ingress Gateway as an edge
    server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced Kubernetes Ingress resources as edge
    servers (refer to the *Replacing the Spring Cloud Gateway* section in [Chapter
    17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing Kubernetes Features
    as an Alternative)*. Unfortunately, ingress resources cannot be configured to
    handle the fine-grained routing rules that come with Istio. Instead, Istio has
    its own edge server, the Istio ingress Gateway, introduced previously in the *Introducing
    runtime components in Istio* section. The Istio Ingress Gateway is used by creating
    `Gateway` and `VisualService` resources described previously in the *Introducing
    Istio API objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: The definition files for the following Kubernetes Ingress resources, `kubernetes/services/base/ingress-edge-server.yml`
    and `kubernetes/services/base/ingress-edge-server-ngrok.yml`, have therefore been
    removed. Definition files for Istio `Gateway` and `VirtualService` resources will
    be added in the *Creating the service mesh* section.
  prefs: []
  type: TYPE_NORMAL
- en: The Istio Ingress Gateway is reached using a different IP address than the IP
    address used to access Kubernetes Ingress resources, so we also need to update
    the IP address mapped to the hostname, `minikube.me`, which we use when running
    tests. This is handled in the *Setting up access to Istio services* section in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the system landscape and replacing Zipkin with Jaeger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Introducing runtime components in Istio* section, Istio
    comes with built-in support for distributed tracing using Jaeger*.* Using Jaeger,
    we can offload and simplify the microservice landscape by removing the Zipkin
    server we introduced in [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following changes have been applied to the source code to remove the Zipkin
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency to `org.springframework.cloud:spring-cloud-starter-zipkin` in
    all microservice build files, `build.gradle`, has been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the Zipkin server in the three Docker Compose files, `docker-compose.yml`, `docker-compose-partitions.yml`,
    and `docker-compose-kafka.yml`, has been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Kubernetes definition files for Zipkin have been removed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubernetes/services/base/zipkin-server.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubernetes/services/overlays/prod/zipkin-server-prod.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaeger will be installed in the *Creating the service mesh* section.
  prefs: []
  type: TYPE_NORMAL
- en: The changes were made to the microservice landscape due to the introduction
    of Istio. We are now ready to deploy Istio in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Istio in a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to deploy Istio in a Kubernetes cluster and
    how to access Istio services in it.
  prefs: []
  type: TYPE_NORMAL
- en: We will use v1.2.4 of Istio, the latest release available when this chapter
    was written.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a demo configuration of Istio that is suitable for testing
    Istio in a development environment, that is, with most features enabled but configured
    for minimalistic resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration is unsuitable for production usage and for performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: For other installation options, see [https://istio.io/docs/setup/kubernetes/install](https://istio.io/docs/setup/kubernetes/install).
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy Istio, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Istio as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that your Minikube instance is up-and-running with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response along the lines of the following, provided it is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b73dc4d8-a721-40eb-87be-a3395fc8c84f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install Istio-specific custom resource definitions (CRDs) in Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Istio demo configurations in Kubernetes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the Istio deployments to become available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The command will report deployment resources in Istio as available, one after
    another. Expect 12 messages such as `deployment.extensions/NNN condition met` before
    the command ends. It can take a couple of minutes (or more) depending on your
    hardware and internet connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update Kiali''s config map with URLs to Jaeger and Grafana with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The config map, `kubernetes/istio/setup/kiali-configmap.yml`, contains URLs
    to Jaeger and Grafana that utilize the DNS names set up by the `minikube tunnel`
    command used in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Istio is now deployed in Kubernetes, but before we move on and create the service
    mesh, we need to learn a bit about how to access Istio services in a Minikube
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up access to Istio services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The demo configuration used in the previous section to install Istio comes with
    a few connectivity-related issues that we need to resolve. The Istio Ingress Gateway
    is configured as a load-balanced Kubernetes service; that is, its type is `LoadBalancer`.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be reached using its node port, in the port range `30000`-`32767`,
    on the IP address of the Minikube instance. Unfortunately, HTTPS-based routing
    in Istio can't include port numbers; that is, Istio's Ingress Gateway must be
    reached over the default port for HTTPS (`443`). Therefore, a node port can't
    be used. Instead, a load balancer must be used to be able to use Istio's routing
    rules with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube contains a command that can be used to simulate a local load balancer,
    `minikube tunnel`. This command assigns an external IP address to each load-balanced
    Kubernetes service, including the Istio Ingress Gateway. This gives you what we
    need to update the translation of the hostname `minikube.me`, which we use in
    our tests. The hostname, `minikube.me`, now needs to be translated to the external
    IP address of the Istio Ingress Gateway, instead of to the IP address of the Minikube
    instance that we used in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `minikube tunnel` command also makes cluster-local Kubernetes services
    accessible using their DNS name. The DNS name is based on the naming convention:
    `{service-name}.{namespace}.svc.cluster.local`. For example, Istio''s Kiali service
    can be reached from a local web browser using the DNS name, `kiali.istio-system.svc.cluster.local`,
    when the tunnel is up and running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes how Istio services are accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6df8153e-3139-4cc7-9cb2-0f832f9e5129.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps to set up the Minikube tunnel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make Kubernetes services available locally. Run the following command in a
    separate terminal window (the command locks the terminal window when the tunnel
    is up and running):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command requires that your user has `sudo` privileges and that
    you enter your password during startup and shutdown. It takes a couple of seconds
    before the command asks for the password, so it is easy to miss!
  prefs: []
  type: TYPE_NORMAL
- en: 'Config `minikube.me` to be resolved to the IP address of the Istio Ingress
    Gateway as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the IP address exposed by the `minikube tunnel` command for the Istio Ingress
    Gateway and save it in an environment variable named `INGRESS_HOST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `/etc/hosts` so that `minikube.me` points to the Istio Ingress Gateway:'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the line in `/etc/hosts` where `minikube.me` that points to the IP address
    of the Minikube instance (`minikube ip`). Verify that `/etc/hosts` only contains
    one line that translates `minikube.me` and that it points to the IP address of
    the Istio Ingress Gateway; for example, the value of `$INGRESS_HOST`:'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/466a71aa-3959-4801-8017-ce9c50266daf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that Kiali, Jaeger, and Grafana can be reached through the tunnel with
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each command should return `200` (OK).
  prefs: []
  type: TYPE_NORMAL
- en: The `minikube tunnel` command can stop running if, for example, your computer
    or the Minikube instance in the virtual machine is paused or restarted. The command needs
    to be restarted manually in these cases. So, if you fail to call API's on the
    `https://minikube.me` URL or if Kiali's web UI can't reach Jaeger to visualize
    distributed tracing, or Grafana to visualize performance metrics, always check
    whether the Minikube tunnel is running and restart it if required.
  prefs: []
  type: TYPE_NORMAL
- en: An added bonus from using the minikube tunnel command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the `minikube tunnel` command also makes it possible to access some
    other cluster-internal Kubernetes services that may be of interest. Once the environment
    is up and running as described in the *Running commands to create the service
    mesh* section, the following can be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `health` endpoint of the `product-composite` microservice can be checked
    with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the *Observing the service mesh* section for an explanation of the
    use of port `4004`.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL tables in the review database can be accessed with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB collections in the `product` and `recommendations` databases can be
    accessed with the following commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: RabbitMQ's web UI can be accessed using the following URL: `http://rabbitmq.hands-on.svc.cluster.local:15672`.
    Log in using the credentials `rabbit-user-dev` and `rabbit-pwd-dev`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Minikube tunnel in place, we are now ready to create the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Istio deployed, we are ready to create the service mesh. We will use the
    `kubernetes/scripts/deploy-dev-env.bash` script to set up an environment for development
    and testing.
  prefs: []
  type: TYPE_NORMAL
- en: The steps required to create the service mesh are basically the same as those
    we used in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing
    Kubernetes Features as an Alternative* (refer to the *Testing with Kubernetes
    ConfigMaps, secrets, and ingress* section). Let's first see what additions have
    been made to the Kubernetes definition files to set up the service mesh before
    we run the commands to create the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Source code changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to run the microservices in a service mesh managed by Istio, the
    following changes have been applied to the Kubernetes definition files:'
  prefs: []
  type: TYPE_NORMAL
- en: The deployment scripts have been updated to inject Istio proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file structure of the Kubernetes definition files has been changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes definition files for Istio have been added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the deployment scripts to inject Istio proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scripts used to deploy microservices in Kubernetes, `deploy-dev-env.bash` and `deploy-prod-env.bash`,
    both in the `kubernetes/scripts` folder, have been updated to inject Istio proxies
    into the five microservices, that is, the `auth-server`, `product-composite`,
    `product`, `recommendation`, and `review` services.
  prefs: []
  type: TYPE_NORMAL
- en: The `deploy-prod-env.bash` script will be used in the *Performing zero downtime
    deploys *section*. *
  prefs: []
  type: TYPE_NORMAL
- en: 'The `istioctl kube-inject` command previously described in the *Injecting Istio
    proxies in existing microservices* section has been added to both deployment scripts
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `kubectl apply` command will start a rolling upgrade, the following
    command has been added to wait for the upgrade to be completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'During the rolling upgrade, we will have two pods running for each microservice:
    an old one without an Istio proxy and a new one with the Istio proxy injected.
    The `waitForPods` function will wait until the old pods are terminated; that is,
    the rolling upgrade is complete, and only the five new pods are running. To identify
    what pods to wait for, a label named `version` is used. In a development environment,
    all microservice pods are labeled with `version=latest`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the deployment file for the product microservice, `kubernetes/services/base/deployments/product-deployment.yml`, has
    the following definition of the `version` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the *Performing zero downtime deployments* section, where we will upgrade
    microservices from version `v1` to `v2`, the version label will be set to `v1` and `v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following command has been added to the scripts to make them wait
    until the deployments and their pods are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After reviewing the updates in the deployment scripts, let's see how the file
    structure of the Kubernetes definition files has been affected as a result of
    the introduction of Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the file structure of the Kubernetes definition files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file structure for the Kubernetes definition files in `kubernetes/services` has
    been expanded a bit since [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes* (refer to the *Introduction to Kustomize*
    section) and this now appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc35c1d8-4834-4161-9759-347150bb845d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `base` folder consists of three subfolders. The reason for this is that
    we will run two versions of the microservices concurrently in the *Performing zero
    downtime deploys* section, that is, one pod per microservice version. Since pods
    are managed by the deployment object, we also need two deployment objects per
    microservice. To be able to achieve this, the base version of the deployment objects
    has been placed in a separate folder, `deployments`. The service objects and the
    Istio definitions are placed in their own base folders: `services` and `istio`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the development environment, we will only run one version per microservice. Its
    kustomization file, `kubernetes/services/overlays/dev/kustomization.yml`, has
    been updated to include all three folders as base folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the following *Performing zero downtime deploys* section for details
    on how two concurrent versions of the microservices will be deployed using the
    setup for the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's also go through the new files in the Istio folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Kubernetes definition files for Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio definitions have been added to the `istio` folder. The Istio files of
    interest in this section are the gateway definition and its corresponding virtual
    services. The other Istio files will be explained in the *Authenticating external
    requests using OAuth 2.0/OIDC access tokens* and *Protecting internal communication
    using mutual authentication (mTLS)* sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Istio gateway is declared in the `kubernetes/services/base/istio/gateway.yml` file and
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some explanations of the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The gateway is named `hands-on-gw`; this name is used by the virtual services
    underneath.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `selector` field specifies that the gateway resource will be handled by
    the built-in Istio Ingress Gateway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hosts` and `port` fields specify that the gateway will handle incoming
    requests for the `minikube.me` hostname using HTTPS over port `443`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tls` field specifies where the Istio Ingress Gateway can find the certificate
    and private key used for HTTPS communication. Refer to the *Protecting external
    endpoints with HTTPS and certificates* section for details on how these certificate
    files are created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The virtual service object for routing requests from the gateway to the `product-composite`
    service, `kubernetes/services/base/istio/product-composite-virtual-service.yml`,
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding source code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `hosts` field specifies that the virtual service will route requests sent
    to the host, `minikube.me`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `match` and `route` blocks specify that requests that contain a URI starting
    with `/product-composite` will be forwarded to the Kubernetes service named `product-composite`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding source code, the destination host is specified using its short
    name, in other words, `product-composite`. This works since the example in this
    chapter keeps all Kubernetes definitions in one and the same namespace, `hands-on`.
    If that is not the case, it is recommended in the Istio documentation using the
    host's **fully qualified domain name **(**FQDN**) instead, that is, `product-composite.hands-on.svc.cluster.local`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the virtual service object for routing requests from the gateway to
    the auth server, `kubernetes/services/base/istio/auth-server-virtual-service.yml`,
    looks very similar, the difference being that it routes requests that start with `/oauth`
    to the Kubernetes service, `auth-server`.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes in the source code in place, we are now ready to create the
    service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Running commands to create the service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the service mesh by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build Docker images from source with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Recreate the `hands-on` namespace, and set it as the default namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the deployment by running the `deploy-dev-env.bash` script with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment is complete, verify that we have two containers in each
    of the microservice pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0040d84-3544-45f4-9dd2-fd7a30e5ea31.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the pods that run our microservices report two containers per pod;
    that is, they have the Istio proxy injected as a sidecar!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the usual tests with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The default values for `script test-em-all.bash` have been updated from previous
    chapters to accommodate Kubernetes running in Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect the output to be similar to what we have seen in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f18d0079-84bb-4a36-96db-00e71ec593df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can try out the APIs manually by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Expect the requested product ID, `2`, in the response.
  prefs: []
  type: TYPE_NORMAL
- en: With the service mesh up and running, let's see how we can observe what's going
    on in the service mesh using Kiali!
  prefs: []
  type: TYPE_NORMAL
- en: Observing the service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use Kiali together with Jaeger to observe what's going
    on in the service mesh. For performance monitoring using Grafana, refer to [Chapter
    20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, we need to get rid of some noise created by the health checks
    performed by Kubernetes' liveness and readiness probes. In the previous chapters,
    they have been using the same port as the API requests. This means that Istio
    will collect telematics data for both health checks and requests sent to the API.
    This will cause the graphs shown by Kiali to become unnecessarily cluttered. Kiali
    can filter out traffic that we are not interested in, but a simpler solution is
    to use a different port for the health checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices can be configured to use a separate port for requests sent to
    the actuator endpoints, for example, health checks sent to the `/actuator/health` endpoint. The
    following line has been added to the common configuration file for all microservices,
    `config-repo/application.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will make all microservices use port `4004` to expose the health endpoints.
    All deployment files in the `kubernetes/services/base/deployments` folder have
    been updated to use port `4004` in their liveness and readiness probes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring Cloud Gateway (this is retained so we can run tests in Docker Compose)
    will continue to use the same port for requests to the API and the `health` endpoint.
    In the `config-repo/gateway.yml` configuration file, the management port is reverted
    to the port used for the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the requests sent to the health endpoint out of the way, we can start to
    send some requests through the service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start a low-volume load test using `siege`, which we got to know in
    [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying Our Microservices
    to Kubernetes* (refer to the *Performing a rolling upgrade* section). After that,
    we will go through some of the most important parts of Kiali to see how Kiali
    can be used to observe a service mesh. We will also explore Kiali''s integration
    with Jaeger and how Jaeger is used for distributed tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the test with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first command will get an OAuth 2.0/OIDC access token that will be used
    in the next command, where `siege` is used to submit one HTTP request per second
    to the product-composite API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect output from the `siege` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/124bc0e4-2fda-4b01-be2f-81c0653eaa0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open Kiali''s web UI using the `http://kiali.istio-system.svc.cluster.local:20001/kiali` URL in
    a web browser and log in with the following username and password: `admin` and
    `admin`. Expect a web page similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/621bc3a8-d0ad-4254-9de3-fea188d12428.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Overview tab, if not already active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the graph icon in the hands-on namespace. Expect a graph to be shown,
    representing the current traffic flow through the service mesh, along the lines
    of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e6dcb80-2f70-4714-acb9-b8abcf8e49cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Display-button, unselect Service Nodes, and select Traffic Animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kiali displays a graph representing requests that are currently sent through
    the service mesh, where active requests are represented by small moving circles
    along with arrows.
  prefs: []
  type: TYPE_NORMAL
- en: This gives a pretty good initial overview of what's going on in the service
    mesh!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at some distributed tracing using Jaeger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36f57f31-b217-474d-8bd6-99ddb55b7370.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the product node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Service: product link. On the web page for the service, click
    on the Traces tab in the menu and Kiali will use Jaeger to show an embedded view
    of traces that the product service is involved in. Expect a web page such as the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e530bf8-fba4-4321-9f45-450dfb3fe9dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on one of the traces to examine it. Expect a web page such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/402e5bb3-c03c-48dc-a5aa-ed14e971ecb0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is basically the same tracing information as Zipkin, made available in
    [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml), *Understanding Distributed
    Tracing*.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to explore, but this is enough by way of an introduction.
    Feel free to explore the web UI in Kiali, Jaeger, and Grafana on your own.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*,
    we will explore performance monitoring capabilities further.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on and learn how Istio can be used to improve security in the service
    mesh!
  prefs: []
  type: TYPE_NORMAL
- en: Securing a service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to use Istio to improve the security of
    a service mesh. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to protect external endpoints with HTTPS and certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to require that external requests are authenticated using OAuth 2.0/OIDC
    access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to protect internal communication using mutual authentication (mTLS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now understand each of these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting external endpoints with HTTPS and certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Creating the service mesh* section, we saw how the Istio Ingress Gateway
    is configured to use the following certificate files to protect external requests
    sent to `minikube.me` using HTTPS. The Istio Ingress Gateway is configured as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But where did these files come from, you may ask?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how the Istio Ingress Gateway is configured by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will find that it is prepared to mount an optional secret named `istio-ingressgateway-certs`
    and that it will be mapped to the folder, `/etc/istio/ingressgateway-certs/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/206f48a3-7bfa-42df-97ad-e1be388adda9.png)'
  prefs: []
  type: TYPE_IMG
- en: This results in certificate files, `tls.crt` and `tls.key`, from a secret named `istio-ingressgateway-certs`
    being made available to the Istio Ingress Gateway on the `/etc/istio/ingressgateway-certs/tls.crt`
    and `/etc/istio/ingressgateway-certs/tls.key` file paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating of this secret is handled by means of the `deploy-dev-env.bash` and `deploy-prod-env.bash` deployment
    scripts, found in the `kubernetes/scripts` folder, by means of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The certificate files were created in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml),
    *Implementing Kubernetes Features as an Alternative* (refer to the *Testing with
    Kubernetes ConfigMaps, secrets, and ingress* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that it is these certificates that are used by the Istio Ingress
    Gateway, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5d99e95-d5ab-49fc-b2c3-62afb06295d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows that the certificate is issued for `minikube.se` and that it
    is self-signed; that is, the issuer is also `minikube.me`.
  prefs: []
  type: TYPE_NORMAL
- en: This self-signed certificate can be replaced with a certificate bought by a
    trusted certificate authority (CA) for production use cases. Istio has recently
    added support for the automated provisioning of trusted certificates using, for
    example, the cert manager and Let's Encrypt, as we did in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml),
    *Implementing Kubernetes Features as an Alternative* (refer to the *Provisioning
    certificates with the cert manager and Let's Encrypt* section). This support is
    currently a bit too complex to fit into this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With the certificate configuration verified, let's now move on to see how the
    Istio Ingress Gateway can protect microservices from unauthenticated requests**.**
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating external requests using OAuth 2.0/OIDC access tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio Ingress Gateway is capable of requiring and validating JWT-based OAuth
    2.0/OIDC access tokens, in other words, protecting the microservices in the service
    mesh from external unauthenticated requests. For a recap on JWT, OAuth 2.0, and
    OIDC, refer to [Chapter 11](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Secure
    Access to APIs* (see the *Authenticating and authorizing API access using OAuth
    2.0 and OpenID Connect* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable authentication, we need to create an Istio `Policy` object that specifies
    which targets should be protected and which access token issuers, that is, OAuth
    2.0/OIDC providers, should be trusted. This is done in the `kubernetes/services/base/istio/jwt-authentication-policy.yml`
    file and appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding source code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `targets` list specifies that the authentication check will be performed
    for requests sent to the `product-composite` microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `origins` list specifies the OAuth 2.0/OIDC providers we rely on. For each
    issuer, the name of the issuer and the URL for its JSON web key set are specified.
    For a recap, see [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Securing
    Access to APIs* (refer to the *Introducing OpenId Connect* section). We have specified
    the local auth server, `http://auth-server.local`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The policy file was applied by the `kubernetes/scripts/deploy-dev-env.bash` deployment
    script, when it was used in the *Running commands to create the service mesh* section.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to verify that an invalid request is rejected by the Istio Ingress
    Gateway and not the `product-composite` microservice is to make a request without
    an access token and observe the error message that is returned. The Istio Ingress
    Gateway returns the following error message, `Origin authentication failed.`,
    in the event of a failed authentication, while the `product-composite` microservice
    returns an empty string. Both return the HTTP code `401` (Unauthorized).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a request without an access token along the lines of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response saying `Origin authentication failed. HTTP Code: 401`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporarily delete the policy with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a minute to allow that policy change to be propagated to the Istio Ingress
    Gateway and then retry the request without an access token. The response should
    now only contain the HTTP code: `HTTP Code: 401`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the policy again with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Suggested additional exercise:** Try out the Auth0 OIDC provider, as described
    in [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Securing Access
    to APIs* (refer to the T*esting with an OpenID Connect provider, Auth0,* section.
    Add your Auth0 provider to `jwt-authentication-policy.yml`. In my case, it appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to the last security mechanism that we will cover in Istio
    – the automatic protection of internal communication in the service mesh using
    mutual authentication, mTLS.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting internal communication using mutual authentication (mTLS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how Istio can be configured to automatically
    protect internal communication within the service mesh using *mutual* *authentication*,
    mTLS. When using mutual authentication, not only does the service side prove its
    identity by exposing a certificate, but also the clients prove their identity
    to the servers by exposing a client-side certificate. This provides a higher level
    of security compared to normal TLS/HTTPS usage, where only the identity of the
    server is proven. Setting up and maintaining mutual authentication; that is, the
    provision of new, and the rotating of outdated, certificates, is known to be complex
    and is therefore seldom used. Istio fully automates the provisioning and rotation
    of certificates for mutual authentication used for internal communication inside
    the service mesh. This makes it much easier to use mutual authentication compared
    to setting it up manually.
  prefs: []
  type: TYPE_NORMAL
- en: So, why should we use mutual authentication? Isn't it sufficient to protect
    external APIs with HTTPS and OAuth 2.0/OIDC access tokens?
  prefs: []
  type: TYPE_NORMAL
- en: As long as the attacks come through the external API, it might be sufficient.
    But what if a pod inside the Kubernetes cluster becomes compromised? For example,
    if an attacker gains control over a pod, then the attacker can start listening
    to traffic between other pods in the Kubernetes cluster. If the internal communication
    is sent as plain text, it will be very easy for the attacker to gain access to
    sensitive information sent between pods in the cluster. To minimize the damage
    caused by such an intrusion, mutual authentication can be used to prevent an attacker
    from eavesdropping on internal network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the use of mutual authentication managed by Istio, Istio needs to
    be configured both on the server side, using a policy, and on the client side,
    using a destination rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the demo configuration of Istio, as we did in the *Deploying Istio
    in a Kubernetes cluster* section, we got a global mesh policy created that configures
    the server side to use a permissive mode, meaning the Istio proxies will allow
    both plain text and encrypted requests. This can be verified with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adef0bf8-61fd-484e-854c-a07e50609603.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To configure microservices to use mutual authentication when sending requests
    internally to other microservices, a destination rule is created for each microservice.
    This is done in the `kubernetes/services/base/istio/internal_mtls_destination_rules.yml` file. The destination
    rules all look the same; for example, for the `product-composite` service, they
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`trafficPolicy` is set to use `tls` with `ISTIO_MUTUAL`, meaning mutual authentication
    is managed by Istio.'
  prefs: []
  type: TYPE_NORMAL
- en: The destination rules were applied by the `kubernetes/scripts/deploy-dev-env.bash` deployment
    script, when it was used in the preceding *Running commands to create the service
    mesh* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the internal communication is protected, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the load tests started in the preceding *Observing the service mesh* section are
    still running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Kiali graph in a web browser ([http://kiali.istio-system.svc.cluster.local:20001/kiali](http://kiali.istio-system.svc.cluster.local:20001/kiali)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Display button to enable the Security label. The graph will show
    a padlock on all communication links that are protected by Istio''s automated
    mutual authentication, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc3e1088-449c-4140-8da3-9d90d416f1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Expect a padlock on all links except for those to resource managers – RabbitMQ,
    MySQL, and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Calls to RabbitMQ, MySQL, and MongoDB are not handled by Istio proxies, and
    therefore require manual configuration to be protected using TLS.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have seen all three security mechanisms in Istio in action, and
    it's now time to see how Istio can help us to verify that a service mesh is resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that a service mesh is resilient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use Istio to ensure that a service mesh
    is resilient; that is, it can handle temporary faults in a service mesh. Istio
    comes with mechanisms similar to what the Spring Framework offers in terms of
    timeouts, retries, and a type of circuit breaker called **outlier detection** to
    handle temporary faults. When it comes to deciding whether language-native mechanisms
    should be used to handle temporary faults, or whether this should be delegated
    to a service mesh such as Istio, I tend to favor using language-native mechanisms,
    as in the examples in [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml),
    *Improving Resilience Using Resilience4J*. In many cases, it is important to keep
    the logic for handling errors, for example, handling fallback alternatives for
    a circuit breaker, together with other business logic for a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases when the corresponding mechanisms in Istio could be of great
    help. For example, if a microservice is deployed and it is determined that it
    can't handle temporary faults that occur in production from time to time, then
    it can be very convenient to add a timeout or a retry mechanism using Istio instead
    of waiting for a new release of the microservice with corresponding error handling
    features put in place.
  prefs: []
  type: TYPE_NORMAL
- en: Another capability in the area of resilience that comes with Istio is the capability
    to inject faults and delays into an existing service mesh. Why would anyone want
    to do that?
  prefs: []
  type: TYPE_NORMAL
- en: Injecting faults and delays in a controlled way is very useful for verifying
    that the resilient capabilities in the microservices work as expected! We will
    try them out in this section, verifying that the retry, timeout, and circuit breaker
    in the `product-composite` microservice work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j* (refer to the *Adding programmable delays and random errors*
    section), we added support for injecting faults and delays in the microservices source
    code. That source code can preferably be replaced by using Istio's capabilities
    for injecting faults and delays at runtime, as demonstrated in the following.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by injecting faults to see whether the retry mechanisms in the
    `product-composite` microservice work as expected. After that, we will delay the
    responses from the product service and verify that the circuit breaker handles
    the delay as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing resilience by injecting faults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make the product service throw random errors and verify that the microservice
    landscape handles this correctly. We expect the retry mechanism in the `product-composite`
    microservice to kick in and retry the request until it succeeds or its limit of
    max numbers of retries is reached. This will ensure that a shortlived fault does
    not affect the end user more than the delay introduced by the retry attempts.
    Refer to the *Adding a retry mechanism* section in [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml),
    *Improving Resilience Using Resilience4j*, for a recap on the retry mechanism in
    the `product-composite` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Faults can be injected using `kubernetes/resilience-tests/product-virtual-service-with-faults.yml`.
    This appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The definition says that 20% of the requests sent to the product service shall
    be aborted with the HTTP status code 500 (Internal Server Error).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the load tests using `siege`, as started in the *Observing the service
    mesh*section, are running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apply fault injection with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Monitor the output from the `siege` load tests tool. Expect output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0bc01f04-88dd-4507-8e09-21be25135194.png)'
  prefs: []
  type: TYPE_IMG
- en: From the sample output, we can see that all requests are still successful, in
    other words, status 200 (OK) is returned; however, some of them (20%) take an
    extra second to complete. This indicates that the retry mechanism in the `product-composite`
    microservice has kicked in and has retried a failed request to the product service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kiali will also indicate that something is wrong with requests sent to the
    product service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the call graph in Kiali's web UI that we used earlier to observe the traffic
    in our namespace, `hands-on`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Display menu button and select Service Nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the menu button to the left of the Display button, named No edge labels,
    and select the Response time option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The graph will show something like the following:'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee4ac35f-e8a5-437f-b1de-261228e0ed60.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrow to the Service Node product will be shown in red to indicate that
    failed requests are detected. If we click on the arrow, we can see fault statistics
    to the right.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding sample screenshot, an error rate of 19.4% is reported, which
    corresponds well with the 20% we asked for. Note that the arrow from the Istio
    Gateway to the `product-composite` service is still green. This means that the
    retry mechanism in the `product-composite` service protects the end user; in other
    words, the faults do not propagate to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conclude the removal of the fault injection with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move on to the next section, where we will inject delays to trigger
    the circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: Testing resilience by injecting delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j* (refer to the *Introducing the circuit breaker* section),
    we know that a circuit breaker can be used to prevent problems due to the slow
    response of services, or the fact that the services do not respond at all.
  prefs: []
  type: TYPE_NORMAL
- en: Let's verify that the circuit breaker in the `product-composite` service works
    as expected by injecting a delay into the product service using Istio. A delay
    can be injected using a virtual service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to `kubernetes/resilience-tests/product-virtual-service-with-delay.yml`.
    Its code appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding definition says that all requests sent to the product service
    shall be delayed by 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Requests sent to the product service from the `product-composite` service are
    configured to timeout after 2 seconds. The circuit breaker is configured to open
    its circuit if 3 consecutive requests fail. When the circuit is open, it will
    fast-fail; in other words, it will immediately throw an exception, not attempting
    to call the underlying service. The business logic in the `product-composite`
    microservice will catch this exception and apply fallback logic. For a recap,
    see  [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j* (refer to the *Adding a circuit breaker* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to test the circuit breaker by injecting a delay:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the load test run by means of the `siege` command by pressing *Ctrl + C* in
    the terminal window where `siege` is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a temporary delay in the product service with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Acquire an access token as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Send six requests in a row. Expect the circuit to open up after the first three
    failed calls, that the circuit breaker applies fast-fail logic for the three last
    calls, and that a fallback response is returned, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The responses from the first 3 calls are expected to be a timeout-related error
    message, and a response time of 2 seconds, in other words, the timeout time. Expect
    responses for the first 3 calls along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/c61d561d-e023-488b-9e75-1dbb32bd2f5c.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The responses from the last 3 calls are expected to be a response from the
    fallback logic with a short response time. Expect responses for the last 3 calls
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/468fa43c-0a38-47fa-8baf-80de72b55711.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simulate the fact that the delay problem is fixed by removing the temporary
    delay with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Verify that correct answers are returned again and without any delay by sending
    a new request using the preceding command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to check the state of the circuit breaker, you can do it with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`curl product-composite.hands-on.svc.cluster.local:4004/actuator/health -s
    | jq -r .details.productCircuitBreaker.details.state`**'
  prefs: []
  type: TYPE_NORMAL
- en: It should report `CLOSED`, `OPEN`, or `HALF_OPEN`, depending on its state.
  prefs: []
  type: TYPE_NORMAL
- en: This proves that the circuit breaker reacts as expected when we inject a delay
    using Istio. This concludes testing features in Istio that can be used to verify
    that the microservice landscape is resilient. The final feature we will explore
    in Istio is its support for traffic management; we will establish how it can be
    used to enable deployments with zero downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Performing zero-downtime deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already mentioned in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes* (refer to the *Performing a rolling
    upgrade* section), being able to deploy an update without downtime becomes crucial
    with a growing number of autonomous microservices that are updated independently
    of one another.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about Istio's traffic management and routing
    capabilities and how they can be used to perform deployments of new versions of
    microservices without requiring any downtime. In [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes* (refer to the *Performing a rolling
    upgrade* section), we saw how Kubernetes can be used to perform a rolling upgrade
    without requiring any downtime. Using the Kubernetes rolling upgrade mechanism
    automates the entire process, but unfortunately provides no option to test the
    new version before all users are routed to the new version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Istio, we can deploy the new version, but initially route all users to
    the existing version (called the old version in this chapter). After that, we
    can use Istio''s fine-grained routing mechanism to control how users are routed
    to the new and the old versions. We will see how two popular upgrade strategies
    can be implemented using Istio:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canary deploys*: ***When using canary deploys, most users are routed to the
    old version, except for a group of selected test users who are routed to the new
    version. When the test users have approved the new version, regular users can
    be routed to the new version using a blue/green deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue/****green** **deploys*****: ***Traditionally, a blue/green deploy means
    that all users are switched to either the blue or the green version, one being
    the new version and the other being the old version. If something goes wrong when
    switching over to the new version, it is very simple to switch back to the old
    version. Using Istio, this strategy can be refined by gradually shifting users
    over to the new version, for example, starting with 20% of the users and then
    slowly increasing the percentage of users who are routed to the new version. At
    all times, it is very easy to route all users back to the old version if a fatal
    error is revealed in the new version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already stated in[ ](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)[Chapter
    16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying Our Microservices
    to Kubernetes* (refer to the *Performing a rolling upgrade* section), it is important
    to remember that a prerequisite for these types of upgrade strategies is that
    the upgrade is backward-compatible. Such an upgrade is compatible both in terms
    of APIs and message formats, which are used to communicate with other services
    and database structures. If the new version of the microservice requires changes
    to external APIs, message formats, or database structures that the old version
    can't handle, these upgrade strategies can't be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through the following deploy scenario in the following subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by deploying the `v1` and `v2` versions of the microservices,
    with routing configured to send all requests to the `v1` version of the microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will allow a test group to run canary tests; that is, we'll verify
    the new `v2` versions of the microservices. To simplify the tests somewhat, we
    will only route test users to the new versions of the core microservices, that
    is, the `product`, `recommendation`, and `review` microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we will start to move regular users over to the new versions using
    a blue/green deploy: initially, a small percentage of users and then, over time,
    more and more users until, eventually, they are all routed to the new version.
    We will also see how we can quickly switch back to the `v1` versions if a fatal
    error is detected in the new v2 version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first see what changes have been applied to the source code to deploy
    two concurrent versions, `v1` and `v2`, of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Source code changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already mentioned in the *Changing the file structure of the Kubernetes
    definition files *section, the file structure for the Kubernetes definition files
    in `kubernetes/services` has been expanded in this chapter to support the deployment
    of concurrent versions of the microservices in the production environment. The
    expanded file structure appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f33b74-c0c1-46ea-80f3-259b536c3bf8.png)'
  prefs: []
  type: TYPE_IMG
- en: Details regarding the development environment have been removed from the preceding
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first see how service and deployment objects for the `v1` and `v2` versions
    of the microservices are configured and created. After that, we will go through
    additional definition files for Istio objects used to control the routing.
  prefs: []
  type: TYPE_NORMAL
- en: Service and deployment objects for concurrent versions of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to run multiple versions of a microservice concurrently, the deployment
    objects and their corresponding pods must have different names, for example, `product-v1`
    and `product-v2`. There must, however, be only one Kubernetes service object per
    microservice. All traffic to a specific microservice always goes through one and
    the same service object, irrespective of what version of the pod the request will
    be routed to in the end. This is achieved using Kustomize by splitting up deployment
    objects and service objects into different folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give deployment objects and their pods version-dependent names, the `kustomization.yml`
    file can use the `nameSuffix` directive to tell Kustomize to add the given suffix
    to all Kubernetes objects it creates. For example, the `kustomization.yml` file
    used for the `v1` version of the microservices in the `kubernetes/services/overlays/prod/v1` folder
    appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nameSuffix: -v1` setting will result in all objects created using this `kustomization.yml` file
    being named with the `-v1` suffix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the objects without a version suffix, and the deployment objects
    and their pods with the `v1` and `v2` version suffixes, the `kubernetes/scripts/deploy-prod-env.bash` deployment
    script executes separate `kubectl apply` commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's also see what Istio definition files we have added to configure routing
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Added Kubernetes definition files for Istio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure routing rules, we will add Istio objects to the `kubernetes/services/overlays/prod/istio` folder.
    Each microservice has a virtual service object that defines the weight distribution
    for the routing between the old and the new versions. Initially, it is set to
    route 100% of the traffic to the old version. For example, the routing rule for
    the product microservice in `product-routing-virtual-service.yml` appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual service defines subsets for the old and the new versions. To define
    what actual versions the old and new versions are, each microservice also has
    a destination rule defined. The destination rule details how the old subset and
    the new subset shall be identified, for example, in the case of the product microservice
    in `old_new_subsets_destination_rules.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The subset named `old` points to product pods that have the `version` label
    set to `v1`, while the subset named `new` points to pods with the `version` label
    set to `v2`.
  prefs: []
  type: TYPE_NORMAL
- en: To route traffic to a specific version, Istio documentation recommends that
    pods are labeled with a label named `version` to identify its version. Refer to [https://istio.io/docs/setup/kubernetes/additional-setup/requirements/](https://istio.io/docs/setup/kubernetes/additional-setup/requirements/) for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to support canary testers, an extra routing rule has been added to
    the virtual services for the three core microservices: product, recommendation,
    and review. This routing rule states that any incoming request that has an HTTP
    header named `X-group` set to the value `test` will always be routed to the new
    version of the service. This appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `match` and `route` sections specify that requests with the HTTP header, `X-group`,
    set to the value, `test`, shall be routed to the subset named `new`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these Istio objects, the `kubernetes/scripts/deploy-prod-env.bash` deployment
    script executes the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to be able to route canary testers to the new version based on header-based
    routing, the `product-composite` microservice has been updated to forward the
    HTTP header `X-group`. Refer to the `getCompositeProduct()` method in the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class  for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have seen all the changes to the source code and we are ready to deploy
    v1 and v2 versions of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying v1 and v2 versions of the microservices with routing to the v1 version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to test the `v1` and `v2` versions of the microservices, we need
    to remove the development environment we have been using earlier in this chapter
    and create a production environment where we can deploy the v1 and v2 versions
    of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recreate the `hands-on` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the deployment by running the script with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The command takes a couple of minutes and should eventually list all the v1
    or v2 versions of the pods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ac160f5-b56c-46fd-8d26-d0cad647e4d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the usual tests to verify that everything works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If this command is executed immediately after the `deploy` command, it sometimes
    fails. Simply rerun the command and it should run fine!
  prefs: []
  type: TYPE_NORMAL
- en: Since we now have two pods (version V1 and V2) running for each microservice,
    the circuit breaker tests no longer work. The reason for this is that the test
    script can't control which pod it talks to, through the Kubernetes service. The
    test script asks about the state of the circuit breaker in the `product-composite`
    microservice using the actuator endpoint on port `4004`. This port is not managed
    by Istio, so its routing rules do no apply. The test script will therefore not
    know whether it is checking the state of the circuit breaker in V1 or V2 of the `product-composite`
    microservice. We can skip circuit breaker tests by using the `SKIP_CB_TESTS=true` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect output that is similar to what we have seen from the previous chapters,
    but excluding the circuit breaker tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ebb9d21-ccfc-4210-92a0-8be37b37fd74.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to run some *zero-downtime deploy* tests. Let's begin by verifying
    that all traffic goes to the v1 version of the microservices!
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that all traffic initially goes to the v1 version of the microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To verify that all requests are routed to the v1 version of the microservices,
    we will start up the load test tool, `siege`, and then observe the traffic that
    flows through the service mesh using Kiali.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a new access token and start the `siege` load test tool, with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the graph view in Kiali''s web UI ([http://kiali.istio-system.svc.cluster.local:20001/kiali](http://kiali.istio-system.svc.cluster.local:20001/kiali)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Display menu button and deselect Service Nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a minute or two, expect only traffic to the v1 version of the microservices as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2170279-e949-462e-b545-b0b5c6c69d54.png)'
  prefs: []
  type: TYPE_IMG
- en: Good! This means that, even though the v2 versions of the microservices are
    deployed, they do not get any traffic routed to them. Let's now try out canary
    tests where selected test users are allowed to try out the v2 versions of the
    microservices!
  prefs: []
  type: TYPE_NORMAL
- en: Running canary tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run a canary test, in other words, in order to be routed to the new versions
    while all other users are still routed to the old versions of the deployed microservices,
    we need to add the `X-group` HTTP header set to the value `test` in our requests
    sent to the external API.
  prefs: []
  type: TYPE_NORMAL
- en: To see which version of a microservice served a request, the `serviceAddresses`
    field in the response can be inspected. The `serviceAddresses` field contains
    the hostname of each service that took part in creating the response. The hostname
    is equal to the name of the pod, so we can find the version in the hostname; for
    example, `product-v1-...` for a product service of version V1, and `product-v2-...` for
    a product service of version V2.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by sending a normal request and verify that it is the v1 versions
    of the microservices that respond to our request. Next, send a request with the `X-group` HTTP
    header set to the value `test`, and verify that the new v2 versions are responding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform a normal request to verify that the request is routed to the v1 version
    of the microservices by using `jq` to filter out the `serviceAddresses` field
    in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/661a5a65-6610-40c6-aaf4-5a55f2e57b81.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, all three core services are v1 versions of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the `X-group=test` header, we expect the request to be served by
    v2 versions of the core microservices. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f63113a-ae33-446b-bdde-05fa4cf621c6.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, all three core microservices that respond are now v2 versions;
    that is, as a canary tester, we are routed to the new v2 versions!
  prefs: []
  type: TYPE_NORMAL
- en: Given that the canary tests returned the expected results, we are ready to allow
    normal users to be routed to the new v2 versions using blue/green deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Running blue/green tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To route parts of the normal users to the new v2 versions of the microservices,
    we have to modify the weight distribution in the virtual services. They are currently
    100/0; in other words, all traffic is routed to the old v1 versions. We can achieve
    this as we did before, that is, by editing the definition files of the virtual
    services in the `kubernetes/services/overlays/prod/istio` folder and then running
    a `kubectl apply` command to make the change take effect. As an alternative, we
    can use the `kubectl patch` command to change the weight distribution directly
    on the virtual service objects in the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: I find the patch command useful when making a number of changes to the same
    objects to try something out, for example, to change the weight distribution in
    the routing rules. In this section, we will use the `kubectl patch` command to
    quickly change the weight distribution in the routing rules between the v1 and
    v2 versions of the microservices. To get the state of a virtual service after
    a number of `kubectl patch` commands have been executed, a command such as `kubectl
    get vs NNN -o yaml` can be issued. For example, to get the state of the virtual
    service of the product microservice, issue the following command: `kubectl get
    vs product-vs -o yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we haven't used the `kubectl patch` command before and it can be a bit
    involved to start with, let's undertake a short introduction to how it works before
    we perform the green/blue deploy.
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to the kubectl patch command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `kubectl patch` command can be used to update specific fields in an existing
    object in the Kubernetes API server. We will try the patch command on the virtual
    service for the review microservice, named `review-vs`. The relevant parts of
    the definition for the virtual service, `review-vs`, appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For the full source code, refer to `kubernetes/services/overlays/prod/istio/review-routing-virtual-service.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample patch command that changes the weight distribution of the routing
    to the v1 and v2 pods in the `review` microservice appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The command will configure the routing rules of the review microservice to route
    80% of the requests to the old version, and 20% of the requests to the new version.
  prefs: []
  type: TYPE_NORMAL
- en: To specify that the `weight` value shall be changed in the `review-vs` virtual
    service, the `/spec/http/1/route/0/weight` path is given for the old version and `/spec/http/1/route/1/weight`
    for the new version.
  prefs: []
  type: TYPE_NORMAL
- en: The `0` and `1` in the path are used to specify the index of array elements
    in the definition of the virtual service. For example, `http/1` means the second
    element in the array under the `http` element. See the definition of the preceding `review-vs`
    virtual service.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding definition we can see that the second element is the `route`
    element. The first element with index `0` being the match element.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a bit more about the `kubectl patch` command, we are ready
    to test a blue/green deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the blue/green deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to gradually move more and more users to the new versions using
    blue/green deployment. To perform the deployment, run the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the load test tool, `Siege`, is still running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It was started in the preceding *Verifying that all traffic initially goes to
    the v1 version of the microservices* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow 20% of the users to be routed to the new v2 version of the review
    microservice, we can patch the virtual service and change weights with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To observe the change in the routing rule, go to the Kiali web UI ([http://kiali.istio-system.svc.cluster.local:20001/kiali](http://kiali.istio-system.svc.cluster.local:20001/kiali))
    and select the graph view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the edge label to `Requests percentage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for a minute before the statics are updated in Kiali so that we can observe
    the change. Expect the graph in Kiali to show something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a610a4da-ad35-4bbd-ab61-f30f72241355.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on how long you have waited, the graph might look a bit different!
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, we can see that Istio now routes traffic to both the v1 and
    v2 versions of the `review` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the 33% of the traffic that is sent to the `review` microservice from the
    `product-composite` microservice, 7% are routed to the new v2 pod, and 26% to
    the old v1 pod. This means that 7/33 (= 21%) of the requests are routed to the
    v2 pod, and 26/33 (= 79%) to the v1 pod. This is in line with the 20/80 distribution
    we have requested:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please feel free to try out the preceding `kubectl patch` command to affect
    the routing rules for the other core microservices: `product` and `recommendation`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to route all traffic to the v2 version of all microservices, you
    can run the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You have to give Kiali a minute or two to collect metrics before it can visualize
    the changes in routing between the v1 and v2 versions of the microservices, but
    remember that the change in the actual routing is immediate!
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect only v2 versions of the microservices to show up in the graph after
    a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafbc4a4-4e90-47d5-8a5f-b933a548edf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on how long you have waited, the graph might look a bit different!
  prefs: []
  type: TYPE_NORMAL
- en: 'If something goes terribly wrong after the upgrade to v2, the following command
    can be executed to revert all traffic back to the v1 version of all microservices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: After a short while, the graph in Kiali should look like the screenshot in the
    previous *Verifying that all traffic initially goes to the v1 version of the microservices* section;
    that is, visualize that all requests go to the v1 version of all microservices
    again.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the introduction to the service mesh concept and Istio as an
    implementation of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up the chapter, let's recap how we can run tests in Docker Compose
    to ensure that the source code of our microservices does not rely on deployment
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing
    Kubernetes Features as an Alternative* (refer to the *Verifying that the microservices
    work without Kubernetes* section), it is important to ensure that the source code
    of the microservices doesn't become dependent on a platform such as Kubernetes
    or Istio from a functional perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the microservices work as expected without the presence of Kubernetes
    and Istio, run the tests as described in [Chapter 1*7*](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml)*,
    Implementing Kubernetes Features as an Alternative* (refer to the T*esting with
    Docker Compose* section). Since the default values of the test script, `test-em-all.bash`,
    are changed, as described previously in the *Running commands to create the service
    mesh* section, the following parameters must be set when using Docker Compose: `HOST=localhost
    PORT=8443 HEALTH_URL=https://localhost:8443`. For example, to run the tests using
    the default Docker Compose file, `docker-compose.yml`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The tests should, as before, begin by starting all containers; it should then
    run the tests, and finally stop all containers. For details of the expected output,
    see [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing Kubernetes
    Features as an Alternative* (refer to the *Verifying that the microservices work
    without Kubernetes* section).
  prefs: []
  type: TYPE_NORMAL
- en: After successfully executing the tests using Docker Compose, we have verified
    that the microservices are dependent neither on Kubernetes nor Istio from a functional
    perspective. These tests conclude the chapter on using Istio as a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the service mesh concept and Istio, an open
    source project that implements it. A service mesh provides capabilities for handling
    challenges in a system landscape of microservices in areas such as security, policy
    enforcement, resilience, and traffic management. A service mesh can also be used
    to make a system landscape of microservices observable by visualizing the traffic
    that flows through the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: For observability, Istio uses Kiali, Jaeger, and Grafana (more on Grafana in
    [Chapter 20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*). When
    it comes to security, Istio can be configured to use a certificate to protect
    external APIs with HTTPS and require that external requests contain valid JWT-based
    OAuth 2.0/OIDC access tokens. Finally, Istio can be configured to automatically
    protect internal communication using **mutual authentication** (**mTLS**).
  prefs: []
  type: TYPE_NORMAL
- en: For resilience and robustness, Istio comes with mechanisms for handling retries,
    timeouts, and an outlier detection mechanism similar to a circuit breaker. In
    many cases, it is preferable to implement these resilience capabilities in the
    source code of the microservices, if possible. The ability in Istio to inject
    faults and delays is very useful for verifying that the microservices in the service
    mesh work together as a resilient and robust system landscape. Istio can also
    be used to handle zero-downtime deployments. Using its fine-grained routing rules,
    both canary and blue/green deployments can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: One important area that we haven't covered yet is how to collect and analyze
    log files created by all microservice instances. In the next chapter, we will
    see how this can be done using a popular stack of tools, known as the EFK stack,
    based on Elasticsearch, Fluentd, and Kibana.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of a proxy component in a service mesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a control plane and a data plane in a service
    mesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `istioctl kube-inject` command used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `minikube tunnel`  command used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tools are used in Istio for observability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What configuration is required to make Istio protect communication within the
    service mesh using mutual authentication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can the `abort` and `delay` elements in a virtual service be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What configuration is required to set up a blue/green deploy scenario?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

- en: Exploring ADO.NET with Examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用示例探索ADO.NET
- en: If you have any exposure to web development, you might have heard of ASP.NET,
    which is a framework for web development. Similarly, if you have worked with databases
    before in .NET projects, you should have heard of or used ADO.NET. ADO.NET is
    a framework that's similar to ASP.NET, but instead of web development, this framework
    is used for database-related work. **ActiveX Data Object** (**ADO**) was an old
    technology created by Microsoft, but the evolution to ADO.NET has been extraordinary. ADO.NET
    contains classes and methods that can be used to easily establish a connection
    with a database management system such as SQL Server or Oracle. Not only that,
    it also provides methods and objects that help to execute commands in the database, such
    as select, insert, update, and delete.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何与Web开发的经验，您可能听说过ASP.NET，这是一个用于Web开发的框架。同样，如果您以前在.NET项目中使用过数据库，您应该听说过或使用过ADO.NET。ADO.NET是一个类似于ASP.NET的框架，但是与Web开发不同，这个框架用于与数据库相关的工作。**ActiveX
    Data Object**（**ADO**）是微软创建的一个旧技术，但是演变为ADO.NET是非凡的。ADO.NET包含可以用于轻松与数据库管理系统（如SQL
    Server或Oracle）建立连接的类和方法。不仅如此，它还提供了帮助在数据库中执行命令的方法和对象，比如select、insert、update和delete。
- en: We need a separate framework for database connection and activity because there
    are a lot of different database systems that can be used when developing an application.
    Databases are a very important part of an application; applications need data
    and data needs to be stored in a database. Because databases are so important
    and there are so many databases available, it would be very hard for a developer
    to write all of the necessary code. It's not worth writing separate bits of code
    when we could write one piece of code that is reusable. This is why Microsoft
    came up with the ADO.NET framework. This framework has different data providers,
    datasets, data adapters, and various other things that are related to databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个单独的框架来进行数据库连接和活动，因为在开发应用程序时可以使用许多不同的数据库系统。数据库是应用程序的一个非常重要的部分；应用程序需要数据，数据需要存储在数据库中。由于数据库如此重要且有如此多的数据库可用，开发人员要编写所有必要的代码将会非常困难。当我们可以编写可重用的代码时，写入单独的代码片段是不值得的。这就是为什么微软推出了ADO.NET框架。这个框架有不同的数据提供程序、数据集、数据适配器和与数据库相关的各种其他东西。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The fundamentals of ADO.NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADO.NET的基础知识
- en: '`DataProvider`, `Connection`, Command, `DataReader`, and `DataAdapter`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataProvider`、`Connection`、Command、`DataReader`和`DataAdapter`'
- en: Connecting SQL Server Database and the Oracle Database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接SQL Server数据库和Oracle数据库
- en: Stored Procedures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程
- en: Entity Frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体框架
- en: Transactions in SQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL中的事务
- en: The fundamentals of ADO.NET
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADO.NET的基础知识
- en: To learn about ADO.NET, we need to know how an application works with a database.
    Then, we need to know how ADO.NET provides support for this process. Let's start
    by learning about some important concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解ADO.NET，我们需要知道应用程序如何与数据库交互。然后，我们需要了解ADO.NET如何支持这个过程。让我们先学习一些重要的概念。
- en: Data providers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据提供程序
- en: 'There are different kinds of data providers available in ADO.NET. The most
    popular data providers are SQL Server, **Open Database Connectivity** (**ODBC**),
    **Object Linking and Embedding Database** (**OLE DB**), and **Java Database Connectivity**
    (**JDBC**). These data providers have a very similar code structure, which makes
    a developer''s life much easier. If you have used one in the past, you will be
    able to use any of the others without much difficulty. These data providers can
    be divided into different components: Connection, Command, DataReader, and DataAdapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ADO.NET中有不同类型的数据提供程序。最流行的数据提供程序是SQL Server、**Open Database Connectivity**（**ODBC**）、**Object
    Linking and Embedding Database**（**OLE DB**）和**Java Database Connectivity**（**JDBC**）。这些数据提供程序具有非常相似的代码结构，这使得开发人员的生活变得更加轻松。如果您以前使用过其中一个，您将能够在不太困难的情况下使用其他任何一个。这些数据提供程序可以分为不同的组件：连接、命令、DataReader和DataAdapter。
- en: Connection objects
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接对象
- en: 'Connection is a component that establishes a connection with a database to
    execute a command on the database. It doesn’t matter which database you want to
    connect, you can use ADO.NET for them all. Even if there is no specific data provider
    for a particular database, you can use the OLE DB data provider to connect with
    any database. This connection object has a property called `connectionstring`.
    That is one of the most important elements of connection. The `connection` string
    is a string that holds data as key-value pairs. For example, a `connection` string
    contains information about the server in which the database is located, the name
    of the database, the user credentials, and some more information. If the database
    is in the same computer, you have to use `localhost` as the server. `ConnectionString` contains
    the database name and the authorization data, such as the username and password
    required to access the database. Let''s see an example of `connectionString` for
    SQL Server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是一个组件，用于与数据库建立连接以在数据库上执行命令。无论您想连接哪个数据库，都可以使用ADO.NET。即使没有特定的数据提供程序用于特定的数据库，您也可以使用OLE
    DB数据提供程序与任何数据库连接。这个连接对象有一个名为`connectionstring`的属性。这是连接的最重要的元素之一。`connection`字符串是一个包含数据的键值对的字符串。例如，`connection`字符串包含有关数据库所在服务器、数据库名称、用户凭据以及一些其他信息。如果数据库在同一台计算机上，您必须使用`localhost`作为服务器。`ConnectionString`包含数据库名称和授权数据，例如访问数据库所需的用户名和密码。让我们看一个SQL
    Server的`connectionString`的例子：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `Data Source` is the server name as the database is located in the same
    computer. The `database` keyword in the `connection` string holds the name of
    the database, which is `testdb` in this example. You will see in some `connection`
    strings that `Initial Catalog` is used instead of the `database` keyword in the
    `connection` string to store the name of the database. You can use either `Initial
    Catalog` or `database` to specify the name of the database in `connection` string.
    The last part of the `connectionString` property that we have here is `Integrated
    Security`, which is used as authentication. If you set it as `TRUE` or `SSPI`,
    this means that you are instructing the program to use Windows authentication
    to access the database. If you have a specific database user that you want to
    use, you can specify that by adding a `user` key and a `password` key in the `connection`
    string. You can provide some other data as well, including connection timeout
    and connect timeout. This `connection` string contains the minimum information
    required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Data Source`是服务器名称，因为数据库位于同一台计算机中。`connection`字符串中的`database`关键字保存了数据库的名称，在这个例子中是`testdb`。您会在一些`connection`字符串中看到`Initial
    Catalog`而不是`connection`字符串中的`database`关键字用于存储数据库的名称。您可以在`connection`字符串中使用`Initial
    Catalog`或`database`来指定数据库的名称。我们在这里的`connectionString`属性的最后一部分是`Integrated Security`，它用作身份验证。如果将其设置为`TRUE`或`SSPI`，这意味着您正在指示程序使用Windows身份验证来访问数据库。如果您有特定的数据库用户要使用，您可以通过在`connection`字符串中添加`user`关键字和`password`关键字来指定。您还可以提供一些其他数据，包括连接超时和连接超时。这个`connection`字符串包含了所需的最少信息。
- en: The Command object
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Command对象
- en: 'The Command object is used to give instructions to the database. Every data
    provider has its own `command` object that is inherited from the `DbCommand` object.
    The `command` object in the SQL data provider is `SqlCommand`, whereas the OLE
    DB provider has an `OleDbCommand` object. The command object is used to execute
    any kind of SQL statement, such as `SELECT`, `UPDATE`, `INSERT`, or `DELETE`.
    Command objects can also execute Stored Procedures. Later in the *Working with
    stored procedures* section, we will look at how to do that. They also have a few
    methods that are used to let the compiler know what type of command we are executing.
    For example, the `ExecuteReader` method queries in the database and returns a
    `DataReader` object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Command对象用于向数据库发出指令。每个数据提供程序都有其自己的`command`对象，该对象继承自`DbCommand`对象。SQL数据提供程序中的`command`对象是`SqlCommand`，而OLE
    DB提供程序具有`OleDbCommand`对象。命令对象用于执行任何类型的SQL语句，如`SELECT`，`UPDATE`，`INSERT`或`DELETE`。命令对象还可以执行存储过程。稍后在*使用存储过程*部分，我们将看看如何做到这一点。它们还有一些方法，用于让编译器知道我们正在执行的命令类型。例如，`ExecuteReader`方法在数据库中查询并返回一个`DataReader`对象：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6f96dd52-b7d0-43c7-b7e0-2f3fee8e016c.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f96dd52-b7d0-43c7-b7e0-2f3fee8e016c.png)'
- en: 'The database table appears as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表如下所示：
- en: '![](img/ebac9153-a68e-4396-a835-8fd820be2ee0.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebac9153-a68e-4396-a835-8fd820be2ee0.png)'
- en: '`ExecuteNonQuery` is another method that is mainly used to execute non-query
    methods, such as `INSERT`, `UPDATE`, and `DELETE`. When you insert some data into
    a database, you are not querying anything in the database, you just want to insert
    the data. The same goes for update and delete. The `ExecuteNonQuery` method returns
    an `INT` value, which represents how many rows in the database were affected by
    the command. For example, if you are inserting a person in a `Person` table, you
    are inserting one new row in the table, so only one row is getting affected. The
    method will therefore return `1` to you.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteNonQuery`是另一个主要用于执行非查询方法的方法，例如`INSERT`，`UPDATE`和`DELETE`。当您向数据库中插入一些数据时，您不会在数据库中查询任何内容，您只是想要插入数据。更新和删除也是一样。`ExecuteNonQuery`方法返回一个`INT`值，表示命令影响了数据库中多少行。例如，如果您在`Person`表中插入一个人，您将在表中插入一行新数据，因此只有一行受到影响。该方法将因此向您返回`1`。'
- en: 'Let''s see an example code of the `ExecuteNonQuery()` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ExecuteNonQuery()`方法的示例代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3f35418b-b946-4445-ae17-8ee44902ed6c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f35418b-b946-4445-ae17-8ee44902ed6c.png)'
- en: 'Let''s say you want to update the `Age` of Mr. John Nash. When you execute
    the `UPDATE` query, it will affect only one row of the table, so it will return
    `1`. But, for example, if you execute a query in which the condition matches several
    different rows, it will update all of the rows and return the total number of
    rows that were affected. Take a look at the following example. Here, we have a
    `Food` table that has different food items. Every item has a category:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要更新John Nash先生的`Age`。当您执行`UPDATE`查询时，它将只影响表的一行，因此它将返回`1`。但是，例如，如果您执行一个条件匹配多个不同行的查询，它将更新所有行并返回受影响的总行数。看看以下示例。在这里，我们有一个`Food`表，其中有不同的食物项目。每个项目都有一个类别：
- en: '![](img/9f6d39da-42f7-4e37-ad95-9bdc5224b034.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f6d39da-42f7-4e37-ad95-9bdc5224b034.png)'
- en: 'Here, we can see that there is no discount on any food items. Let''s say that
    we now want to give a discount of 5% on every breakfast item. To change the `Discount`
    value, you will have to execute an `UPDATE` command to update all of the rows.
    From the table, we can see that there are two breakfast items in the table. If
    we run an `UPDATE` command with a condition that applies only to `Category= ''Breakfast''`,
    it should affect two rows. Let''s see the C# code for this process. We are going
    to use the `ExecuteNonQuery` command here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到任何食物项目都没有折扣。假设我们现在想要在每个早餐项目上打5%的折扣。要更改`Discount`值，您将需要执行`UPDATE`命令来更新所有行。从表中，我们可以看到表中有两个早餐项目。如果我们运行一个带有条件的`UPDATE`命令，该条件仅适用于`Category=
    'Breakfast'`，它应该影响两行。让我们看看这个过程的C#代码。我们将在这里使用`ExecuteNonQuery`命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/5c24b2fb-f033-42d2-9852-6161247fb734.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c24b2fb-f033-42d2-9852-6161247fb734.png)'
- en: 'We can see from the output that `2` rows were affected. Now, let''s take a
    look at the database table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到影响了`2`行。现在，让我们看看数据库表：
- en: '![](img/c81a6489-b638-46c0-be38-ab3ab8e8bf1c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: We can see that two rows were changed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If you execute a `DELETE` command using the `ExecuteNonQuery` method, it will
    return the amount of rows that were affected. If you get `0` as a result, this
    means that your command wasn't successfully executed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: There are many other methods in the `SQLCommand` object. `ExecuteScalar` returns
    a scalar value from the query. `ExecuteXMLReader` returns an `XmlReader` object.
    There are other methods that work in an asynchronous way. All of these methods
    work in a similar way to the examples shown here.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: There is a property in the Command object called `CommandType`. `CommandType`
    is an `enum` type that states how the command is provided. The enum values are
    `Text`, `StoredProcedure`, and `TableDirect`. If text is selected, the SQL command
    will be executed as an SQL query in the data source directly. In `StoredProcedure`,
    you can set parameters and execute `storedprocedures` to execute a command in
    the database. By default, the value is set as `TEXT`. This is why, in the earlier
    examples, we didn't set the value of `CommandType`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The DataReader object
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DataReader objects provide a way of reading a forward-only stream of rows from
    database. Like the others, a DataReader is an object of a data provider. Every
    data provider has different DataReader objects that inherit from `DbDataReader`.
    When you execute an `ExecuteReader` command, it returns a `DataReader` object.
    You can process this `DataReader` object to collect the data you have queried
    for. If you are using SQL Server as your database, you should use the `SqlDataReader`
    object. `SqlDataReader` has a method called `Read()`, which returns `true` when
    you have available data in the `DataReader` object to read. If there is no data
    in the `SqlDataReader` object, the `Read()` method will return `false`. It''s
    a common practice to first check whether the `Read()` method is `true` and then
    read the data. The following example shows how `SqlDataReader` is used:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the `command.ExecuteReader()` method returns an `SqlDataReader` object,
    which holds the result of the query:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, we hold the returned object in a variable called **reader**, which is
    of the `SqlDataReader` type. Then, we check whether its `Read()` method is `true`.
    If it is, we execute the following statement:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the reader is working as an array and we get the value of the database
    table columns sequentially from the index. As we can see from the following table
    structure in the database, it has four columns, Id, FirstName, LastName, and Age:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7a7aba8-e697-45b4-8491-53aeafdc4e76.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: These columns will be mapped one after another. `reader[0]` refers to the Id
    column, `reader[1]` refers to the Firstname column, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The statement we have written will print the value of the FirstName column, where
    it will find `reader[1]`. It will then print the value of the LastName column,
    where it will find `reader[2]`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'If this array index is confusing for you and if you want more readability,
    feel free to use named indexes instead of numbers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will print the same thing. Instead of putting `reader[1]`, we have written
    `reader["FirstName"]`, so it's clearer which column we are accessing. If you use
    this approach, make sure the name is written correctly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: DataAdapter
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DataAdapter` is another way to read and use data from a data source. DataAdapter
    gives you an easy way to store the data directly to a dataset. You can also use
    DataAdapter to write back in the data source from the dataset. Every provider
    has its own DataAdapter. An SQL data provider, for example, has `SqlDataAdapter`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to various databases
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see some examples of how to connect to different databases using ADO.NET.
    If you are using ADO.NET, the most probable database system you are going to use
    is SQL Server Database as that is the best match when you are using a Microsoft
    stack. You won't, however, have any reduction in performance or encounter problems
    if you use any other source. Let's see how we can connect with other databases
    with ADO.NET.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to SQL Server, we need to use the SQL Server provider in ADO.NET.
    Take a look at the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Oracle database
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to the Oracle database, we need to use the ODBC provider in ADO.NET.
    Take a look at the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working with DataReaders and DataAdapters
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DataReaders` and `DataAdapter`s are core objects of a data provider. These
    are some of the most important features that ADO.NET provides. Let''s see how
    to work these objects.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: DataReaders
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every provider has DataReaders. Underneath, all classes do the same thing.
    `SqlDataReader`, `OdbcDataReader`, and `OleDbDataReader` all implement the `IDataReader` interface.
    The main use of DataReader is to read data from a data source when it is coming
    from a stream. Let''s take a look at the different properties that a data reader
    has:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `Depth` | The depth of nesting for a row |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `FieldCount` | Returns the number of columns in a row |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `IsClosed` | Returns `TRUE` if `DataReader` is closed |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `Item` | Returns the value of a column |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| `RecordsAffected` | The number of rows affected |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: 'A DataReader has the following methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `Close` | This method will close the `DataReader` object. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `Read` | This method will read the next piece of data in `DataReader`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `NextResult` | This method will move the head to the next result. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `GetString`,`GetChar`, and so on | The `GetString` method will return the
    value in string format. `GetChar` will return the value in `Char` format. There
    are other methods that will return a value in that particular type. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: 'The following code snippet shows an example of `DataReader`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: DataAdapters
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DataAdapters work like a bridge between disconnected ADO.NET objects and the
    data source. This means that they help to establish a connection and execute commands
    in the database. They also map back the query results to the disconnected ADO.NET
    objects. Data Adapters use `DataSet` or `DataTable` to store data after its retrieval
    from a data source. `DataAdapter` has a method called `Fill()`,which collects
    data from a data source and populates `DataSet` or `DataTable`. If you want to
    retrieve the schema information, you can use another method called `FillSchema()`.
    A further method, named `Update()`, transfers all changes made in `DataSet` or `DataTable`
    to the data source.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of using Data Adapters is that no information about the
    connection, database, tables, columns, or any other information related to the
    data source is passed to the disconnected object. It's therefore safe to use when
    passing a value to an external source.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Working with stored procedures
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stored Procedures** are batches of SQL statements that are stored in a database
    for the purpose of reuse. ADO.NET has support for Stored Procedures, which means
    that we can use ADO.NET to call stored procedures in a database and get results
    from them. It is a very common practice to pass parameters, which could be input
    or output parameters, to stored procedures. The ADO.NET command object has parameters
    that are objects of the parameter type. Depending on the provider, the parameter
    object changes, but they all follow the same base. Let''s take a look at how to
    use stored procedures instead of normal SQL statements in ADO.NET.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a stored procedure, the SQL string that is passed in `SQLCommand` should
    be the name of the Stored Procedure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We normally pass parameters to stored procedures as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now see the stored procedure to get an idea of how the parameter is
    used:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Working with the Entity Framework
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework
- en: '**The Entity Framework** (**EF**) is an **Object Relational Mapper** (**ORM**)
    framework developed by Microsoft. It was developed for .NET developers to work
    with databases easily using entity objects. It sits in the middle of your backend
    code or business logic and the database. It allows the developer to write code
    in the application language, C#, to talk with the database. This means that there
    is no need to use and write the ADO.NET code manually, which we did in the preceding
    sections. EF has different kinds of commands to the normal SQL commands. EF commands,
    which look very similar to C# code, will communicate with the database using SQL
    in the background. It can communicate with any type of data source, so you don''t
    have to worry about setting up or writing different code for each DBMS.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework**（**EF**）是由Microsoft开发的**对象关系映射器**（**ORM**）框架。它是为.NET开发人员开发的，以便使用实体对象轻松地与数据库一起工作。它位于后端代码或业务逻辑与数据库之间。它允许开发人员使用应用程序语言C#编写代码与数据库交互。这意味着不需要手动使用和编写ADO.NET代码，而我们在前面的部分中所做的。EF具有不同类型的命令，用于普通SQL命令。EF命令看起来非常类似于C#代码，将使用后台的SQL与数据库通信。它可以与任何类型的数据源通信，因此您无需担心为每个DBMS设置或编写不同的代码。'
- en: What is an entity in the Entity Framework?
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Entity Framework中，什么是实体？
- en: 'An entity is a class in the application domain that is also included as a `DbSet` property
    in the derived `DbContext` class. An entity is transformed into a table and the
    properties of an entity are transformed as columns when EF executes it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是应用程序域中的一个类，也包括在派生的`DbContext`类中作为`DbSet`属性。实体在执行时被转换为表，实体的属性被转换为列：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Different types of Entity properties
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的实体属性
- en: 'Let''s see what different types of properties an Entity can have:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实体可以具有哪些不同类型的属性：
- en: Scalar properties
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量属性
- en: 'Navigation properties. These include the following:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航属性。这些包括以下内容：
- en: Reference Navigation properties
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用导航属性
- en: Collection Navigation properties
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合导航属性
- en: Scalar properties
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量属性
- en: 'These are the properties that are used as columns in the database directly.
    They are used to save and query in the database. Let''s see an example of these
    properties:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性直接在数据库中用作列。它们用于在数据库中保存和查询。让我们看一个这些属性的示例：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following properties are scalar properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性是标量属性：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Navigation properties
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航属性
- en: 'This type of property represents relationships between entities. They are not
    related directly to particular columns. There are two types of navigation properties:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的属性表示实体之间的关系。它们与特定列没有直接关联。导航属性有两种类型：
- en: '**Reference navigation property:** If another entity type is used as a property,
    it is called a reference navigation property'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用导航属性：**如果另一个实体类型用作属性，则称为引用导航属性'
- en: '**Collection navigation property:** If an entity is included as a collection
    type, it is called a collection navigation property'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合导航属性：**如果实体被包括为集合类型，则称为集合导航属性'
- en: 'An example of navigation properties is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 导航属性的一个示例如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `Student` is a reference navigation property and `Students` is a collection
    navigation property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Student`是一个引用导航属性，`Students`是一个集合导航属性。
- en: 'Now let''s see the two approaches of using EF: the **code-first approach**
    and the **database-first approach**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用EF的两种方法：**代码优先方法**和**数据库优先方法**。
- en: The code-first approach
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码优先方法
- en: This can be thought of as similar to domain-driven design. In this approach,
    you write the entity objects and the domain and then use the domain to generate
    a database using EF. Using different attributes in the entity objects, EF can
    understand what to do with the database and how. For example, if you want a particular
    property in your model to be treated as a primary key, you can use data annotations
    or a fluent API to indicate to the EF that it should treat this column as a primary
    key when creating the table in the database.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被认为类似于领域驱动设计。在这种方法中，您编写实体对象和域，然后使用域使用EF生成数据库。使用实体对象中的不同属性，EF可以理解要对数据库执行的操作以及如何执行。例如，如果您希望模型中的特定属性被视为主键，可以使用数据注释或流畅API指示EF在创建数据库中的表时将此列视为主键。
- en: The database-first approach
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库优先方法
- en: In this approach, you create the database first and then ask EF to generate
    the entity for you. You make all of your changes at the database level and not
    in your entities in the backend application. Here, the EF does a different job
    to in the code-first approach. In the database-first approach, EF reads through
    the database tables and columns and generates C# classes models in which each
    column is treated as a property. The EF also takes care of the relationship between
    different database tables and creates the same kind of relationship in the generated
    models.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，您首先创建数据库，然后要求EF为您生成实体。您在数据库级别进行所有更改，而不是在后端应用程序中的实体中进行更改。在这里，EF的工作方式与代码优先方法不同。在数据库优先方法中，EF通过数据库表和列生成C#类模型，其中每个列都被视为属性。EF还负责不同数据库表之间的关系，并在生成的模型中创建相同类型的关系。
- en: Using the Entity Framework
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework
- en: Both approaches have their benefits, but the code-first approach is more popular
    among developers as you have to deal less with the database and work more in C#.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其好处，但代码优先方法在开发人员中更受欢迎，因为您不必过多处理数据库，而是更多地在C#中工作。
- en: 'An EF doesn''t comes with the .NET framework by default. You have to download
    the library from the NuGet package manager and install it in the project you are
    working with. To download and install the entity framework, you can open the Nuget
    Package Manager Console and write the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: EF不会默认随.NET框架一起提供。您必须从NuGet软件包管理器下载库并将其安装在您正在使用的项目中。要下载和安装实体框架，您可以打开Nuget软件包管理器控制台并编写以下命令：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will download and install the Entity Framework in your project:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在您的项目中下载并安装Entity Framework：
- en: '![](img/b6bbdf13-aa11-4bf5-835c-2fd98bb06f76.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6bbdf13-aa11-4bf5-835c-2fd98bb06f76.png)'
- en: 'If you are not comfortable with the Package Manager Console, you can also use
    the GUI''s Manage Packages for Solution window to install entity framework. Go
    to the Browse tab and search for Entity Framework. You will see it at the top
    of the search results. Click it and install it in your project:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉**包管理器控制台**，也可以使用GUI的**解决方案包管理器**窗口来安装实体框架。转到**浏览**选项卡，搜索**Entity Framework**。您将在搜索结果的顶部看到它。单击它并在您的项目中安装它。
- en: '![](img/9f3940da-0cc2-4ff0-8fa3-76fa73a0036e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f3940da-0cc2-4ff0-8fa3-76fa73a0036e.png)'
- en: Installing Entity Framework using Nuget Package Manager
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nuget包管理器安装Entity Framework
- en: In this book, we are focusing more on C#, so we will look more closely at the
    code-first approach than the database-first approach. In the code-first approach,
    as we don't touch the database code, we need to make our entity objects in a way
    that can be followed when creating a database. After we have created the database
    tables, if we want to update the tables or change the tables, we need to use migrations.
    Database migration creates a new instance of the database and applies the new
    changes in the new instance. By using migrations, it's easier to manipulate the
    database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们更专注于C#，因此我们将更仔细地看一下代码优先方法，而不是数据库优先方法。在代码优先方法中，由于我们不会触及数据库代码，因此我们需要以一种可以在创建数据库时遵循的方式创建我们的实体对象。在创建了数据库表之后，如果我们想要更新表或更改表，我们需要使用迁移。数据库迁移会创建数据库的新实例，并在新实例中应用新的更改。通过使用迁移，更容易操作数据库。
- en: Let's now learn a little bit more about the history and the flow of EF. It was
    first published in the year 2008 with .NET 3.5\. At the time of writing this book,
    the latest version of EF is version 6\. EF also has a .NET Core version that is
    called **Entity Framework Core**. Both frameworks are open source. When you install
    an entity framework in your project and write a **Plain Old CLR Object** (**POCO**)
    class, that POCO class is used by the entity framework. First, EF creates an **Entity
    Data Model** (**EDM**) from it. This EDM is used later to save and query in the
    database. **Language Integrated Queries **(**LINQs**) and SQL can both be used
    to give instructions to EF. When one entity object is used in EDM, it is tracked.
    When it is updated, the database will also be updated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更多地了解一下EF的历史和流程。它首次发布于2008年，与.NET 3.5一起。在撰写本书时，EF的最新版本是版本6。EF还有一个称为**Entity
    Framework Core**的.NET Core版本。这两个框架都是开源的。当您在项目中安装实体框架并编写**POCO**类（**Plain Old CLR
    Object**）时，该POCO类将被实体框架使用。首先，EF从中创建**Entity Data Model**（**EDM**）。稍后将使用此EDM来保存和查询数据库。**语言集成查询**（**LINQs**）和SQL都可以用来向EF发出指令。当一个实体对象在EDM中使用时，它会被跟踪。当它被更新时，数据库也会被更新。
- en: We can use the `SaveChanges()` method to execute insert, update, and delete
    activity in the database. For asynchronous programming, the `SaveChangesAsync()`
    method is used. For a better query experience, EF has first-level caching, so
    when repeated queries are executed, EF returns the results from the cache instead
    of going to the database to collect the same result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SaveChanges()`方法来执行数据库中的插入、更新和删除操作。对于异步编程，使用`SaveChangesAsync()`方法。为了获得更好的查询体验，EF具有一级缓存，因此当执行重复查询时，EF会从缓存中返回结果，而不是去数据库中收集相同的结果。
- en: 'An EF API mainly does four things:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: EF API主要做四件事：
- en: Maps classes to the database schema
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类映射到数据库模式
- en: Translates LINQs into Entity Queries to SQL and executes them
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将LINQ转换为实体查询到SQL并执行它们
- en: Tracks changes
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪更改
- en: Saves changes in the database
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中保存更改
- en: 'EF converts entity objects and context classes into EDM, and EDM is used in
    the database. For example, let''s say we have the following class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: EF将实体对象和上下文类转换为EDM，并且EDM在数据库中使用。例如，假设我们有以下类：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The EF will convert it into EDM, which looks as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: EF将其转换为EDM，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, this EDM will be used to create or update the `Person` database table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个EDM将用于创建或更新`Person`数据库表。
- en: Transactions in SQL
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL中的交易
- en: A transaction is a single unit of work that either has to complete the whole
    work or roll back to its previous state. A transaction can't stop in the middle
    of a piece of work. It's a very important feature for sensitive data-handling.
    One of the best uses of transactions is when dealing with money-transfer processes.
    When a person transfers some money to another person's account, if any error occurs in
    the middle of the process, the whole process should be cancelled or rolled back.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是一个单独的工作单元，要么完成整个工作，要么回滚到其先前的状态。事务不能在工作的中间停止。这是一个非常重要的特性，用于处理敏感数据。事务的最佳用途之一是处理转账过程。当一个人向另一个人的账户转账一些钱时，如果在过程中发生任何错误，整个过程应该被取消或回滚。
- en: There are four properties of a transaction in SQL: **Atomic, Consistent, Isolated,
    and Durable** (**ACID**).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SQL中交易的四个属性：**原子、一致、隔离和持久**（**ACID**）。
- en: Atomic
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子
- en: Atomic means that all statements in a group must be executed. If one of the
    statements in a group doesn't get executed, none of the statement should be executed.
    The whole group of the statement should work as a single unit.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 原子意味着组中的所有语句必须被执行。如果组中的语句之一没有被执行，那么没有一个语句应该被执行。整个语句组应该作为一个单一单元工作。
- en: Consistent
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致
- en: When a transaction is executed, the database should reach from one state to
    another. We call the initial point the starting point and the point after execution
    the end point. In a transaction, the start and end points should be clear. If
    the transaction is successful, the database state should be at the end point,
    otherwise it should be at the start point. Maintaining this consistency is what
    this property is about.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行事务时，数据库应该从一个状态达到另一个状态。我们称初始点为起点，执行后的点为终点。在事务中，起点和终点应该是清晰的。如果事务成功，数据库状态应该在终点，否则应该在起点。保持这种一致性就是这个属性的作用。
- en: Isolated
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离
- en: A group of a statements that are part of a transaction should be isolated from
    other statements in another transaction or manual statements. While a transaction
    is running, if another statement changes a particular piece of data, the whole
    transaction would produce bad data. When a transaction is run, all other outside
    statements are not allowed to run on that particular piece of data in the database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事务一部分的一组语句应该与另一个事务或手动语句中的其他语句隔离开来。当一个事务正在运行时，如果另一个语句改变了特定的数据，整个事务将产生错误的数据。当一个事务运行时，所有其他外部语句都不被允许在数据库中运行在特定的数据上。
- en: Durable
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久
- en: After a group of statements is executed, the result needs to be stored in a
    permanent place. If, in the middle of a transaction, an error occurs, the statements
    can be rolled back and the database goes to its previous position.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一组语句执行后，结果需要存储在一个永久的位置。如果在事务中间发生错误，这些语句可以被回滚，数据库回到之前的位置。
- en: Transactions plays a very important role in SQL, so the SQL data provider provides
    the `SQLTransaction` class, which can be used to execute transactions using ADO.NET.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事务在SQL中扮演着非常重要的角色，因此SQL数据提供程序提供了`SQLTransaction`类，可以用于使用ADO.NET执行事务。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Data is a very important part of a software application. To maintain data, we
    need some kind of database that will store the data in a structured way, so that
    it can be easily retrieved, saved, updated, and deleted. It's essential that our
    software is able to communicate with a data source to use the data. The ADO.NET
    framework provides this facility to .NET developers. Learning and understanding
    ADO.NET is one of the basic requirements of any .NET developer. In this chapter,
    we covered the fundamentals of ADO.NET elements, such as `DataProvider`s, `Connection`,
    Command, `DataReader`, and `DataAdapter`. We also learned how to connect with
    the SQL Server database and the Oracle Database using ADO.NET. We discussed stored
    procedures and explained what the Entity Framework is and how to use it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是软件应用程序的一个非常重要的部分。为了维护数据，我们需要一种数据库来以结构化的方式存储数据，以便可以轻松地检索、保存、更新和删除数据。我们的软件能够与数据源通信以使用数据是至关重要的。ADO.NET框架为.NET开发人员提供了这种功能。学习和理解ADO.NET是任何.NET开发人员的基本要求之一。在本章中，我们涵盖了ADO.NET元素的基础知识，如`DataProvider`、`Connection`、`Command`、`DataReader`和`DataAdapter`。我们还学习了如何使用ADO.NET连接到SQL
    Server数据库和Oracle数据库。我们讨论了存储过程，并解释了实体框架是什么以及如何使用它。
- en: 'In the next chapter, we will be talking about a very interesting topic: Reflection.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个非常有趣的话题：反射。

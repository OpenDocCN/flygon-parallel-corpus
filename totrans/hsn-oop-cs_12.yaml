- en: Understanding Design Patterns and Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式和原则
- en: 'Over the years, software has become increasingly complicated. Now, software
    is not only used for mathematical calculations or simple **create, read, update,
    and delete **(**CRUD**) operations: we are employing it to carry out complex tasks,
    such as controlling rocket engines or managing huge amounts of data every day.
    Businesses from a vast range of sectors have started to adopt software systems,
    including banks, insurance companies, research institutes, education institutes,
    and government agencies. The higher the demand for software, the more people begin
    to build careers in software development. From assembly-language programming,
    came procedural programming, before the introduction of the era of **Object-oriented
    programming** (**OOP**), which is still the most popular model, despite the emergence
    of other types of programming, such as functional programming. OOP has helped
    developers write good, modular software that is easy to maintain and extend. In
    this chapter, we are going to discuss some of the most important design principles
    and patterns that are followed by thousands of developers, and we are going to
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除**（CRUD）操作：我们正在使用它来执行复杂的任务，如控制火箭发动机或每天管理大量数据。来自各行各业的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始在软件开发领域建立职业。从汇编语言编程开始，经过过程式编程，然后引入了面向对象编程（OOP）时代，尽管出现了其他类型的编程，如函数式编程，但OOP仍然是最受欢迎的模型。OOP帮助开发人员编写良好的、模块化的软件，易于维护和扩展。在本章中，我们将讨论一些最重要的设计原则和模式，这些原则和模式被成千上万的开发人员遵循，我们将涵盖以下主题：
- en: Design principles in software development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发中的设计原则
- en: Different design patterns in software development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发中的不同设计模式
- en: Creational design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设计模式
- en: Behavioral design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: Structural design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: The **Model-View-Controller** (**MVC**) pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（MVC）模式'
- en: Design principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: Before we start discussing design principles, let's think about what we mean
    by **design principles **in software development. When we develop software, we
    first design its architecture, and then we start writing its code. We want to
    write our code in such a way that it generates no bugs, or so it is easy to find
    bugs if there are any. We also want the code to be easily understandable when
    we read it and we want it to be structured in such a way that it can be changed
    later if required. Although it is difficult to write the best-possible code, there
    are various principles in software development that have been developed by experienced
    computer scientists. Using these, developers can write very clean code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论设计原则之前，让我们思考一下在软件开发中我们所说的**设计原则**是什么意思。当我们开发软件时，我们首先设计其架构，然后开始编写其代码。我们希望以这样的方式编写我们的代码，使其不会产生错误，或者如果有错误，很容易找到。当我们阅读代码时，我们也希望代码易于理解，并且希望它的结构能够在以后需要时进行更改。虽然编写最佳代码是困难的，但有许多在软件开发中由经验丰富的计算机科学家制定的原则。使用这些原则，开发人员可以编写非常干净的代码。
- en: 'The software developer Robert C. Martin, also known as Uncle Bob, came up with
    five software design principles. These principles are so effective and helpful
    for developers that they have become a norm in the software industry. Collectively,
    they are known as the SOLID principle, which represents the following different
    definitions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员罗伯特·C·马丁，也被称为Uncle Bob，提出了五个软件设计原则。这些原则对开发人员非常有效和有帮助，以至于它们已经成为软件行业的一种规范。它们统称为SOLID原则，代表以下不同的定义：
- en: '**S **stands for the **single responsibility principle**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S **代表**单一职责原则**'
- en: '**O **stands for the **open-closed principle**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O **代表**开闭原则**'
- en: '**L **stands for the **Liskov substitution principle**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L **代表**里氏替换原则**'
- en: '**I **stands for the **interface segregation principle**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I **代表**接口隔离原则**'
- en: '**D **stands for the **dependency inversion principle**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D **代表**依赖反转原则**'
- en: Let's discuss these principles one by one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论这些原则。
- en: The single responsibility principle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: '"A class should have one, only one reason to change."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个类应该只有一个改变的原因。"'
- en: – *Robert C. Martin*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: – *罗伯特·C·马丁*
- en: This means that when we write a class, we should design it in such a way that
    it has only one responsibility. You should only need to change the class for one
    reason. If you have multiple reasons to change the class, it is violating the
    single responsibility principle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们编写一个类时，我们应该以只有一个职责的方式设计它。你应该只需要为一个原因更改类。如果你有多个原因更改类，那么它违反了单一职责原则。
- en: If a class has more than one responsibility and you make changes to a piece
    of code, this might break another piece of code, as they are in the same class
    and share some dependencies. Your code might not be very decoupled.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类有多个职责，并且你对一段代码进行了更改，这可能会破坏另一段代码，因为它们在同一个类中并共享一些依赖关系。你的代码可能并不是非常解耦的。
- en: The open-closed principle
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Code needs to be written in such a way that adding new things in a software
    entity, such as classes, modules, or functions, is good, but modifying the entity
    itself should not be allowed. This reduces the possibility of bugs being generated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要以这样的方式编写，即在软件实体（如类、模块或函数）中添加新内容是好的，但不应允许修改实体本身。这减少了产生错误的可能性。
- en: The Liskov substitution principle
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: '"Derived types must be completely substitutable for their base types."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"派生类型必须完全可替代其基本类型。"'
- en: – *Barbara Liskov*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: – *芭芭拉·里斯科夫*
- en: This principle states that when you write a class, if it is derived from another
    class, it should be replaceable with the base class. Otherwise, your code will
    be very fragile and coupled. This principle was first discovered by Barbara Liskov,
    so it is named after her.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, developers create large interfaces that contain too much information.
    Many classes might use this interface, but they might not need everything in it.
    This is what you should avoid in order to follow this principle. This principle
    supports small interfaces instead of big interfaces and, if necessary, a class
    can inherit multiple small interfaces that are actually applicable for the class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules; both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    upon abstractions"'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: We know that, in software development, we work with layers. To make the layers
    decoupled, we have to design the dependencies of these layers in such a way that,
    instead of depending on each other, the layers should depend on abstraction. Therefore,
    if you change something in a high-level module or a low-level module, it won't
    harm the system. When we create these abstractions, we have to design them in
    such a way that they are not dependent on the implementation details. The abstractions
    should be independent and the classes that implement these interfaces or abstract
    classes should depend on those abstractions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, where all things are treated as objects, it's very important to keep
    track of how an object is created and managed. If a developer doesn't pay much
    attention to this topic, the objects of the software could make the software fragile
    and coupled. It's important to maintain the objects appropriately to keep the
    application easily extendable. Creational design patterns are patterns that help
    create objects in a manner where the most common problems regarding object creation
    can be avoided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts that exist in creational design patterns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating knowledge about the concrete classes the system uses
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide creating and combining instances of the concrete classes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns are classified into object-creational patterns and
    class-creational patterns, in which **object-creational patterns** deal with the
    creation of objects and **class-creational patterns** deal with the discovery
    of classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main creational design patterns in the industry:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method pattern
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of this pattern from *Design Patterns: Elements of Reusable
    Object-Oriented* *Software* by the Gang of Four is to provide a combination to
    build families of similar or reliant objects without specifying their concrete
    classes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing that this pattern offers is separation or abstraction
    of object creation. If you are not following any pattern, the simplest thing that
    comes to mind when you are creating an object is to use the `new` keyword and
    create an object wherever you need it. For example, if I need a `Person` object
    in my `Bank` class, the easiest way to do this would be to instantiate a `Person`
    object using a `new` keyword in the `Bank` class. However, using this approach
    sometimes creates complexity in the software. To avoid that, we can use the abstract
    factory pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern is mainly used in cases where you have objects
    from the same family, or that are related or dependent in some way. The idea is
    to create factory classes to carry out the work of object creation. If an object `A`,
    needs an instance of another object `B`, object `A` should ask the factory of
    object `B` to create an object of `B` and pass it to object `A`. In this way,
    object `A` is independent of the creation of object `B`. Now, in the abstract
    factory pattern, there is another layer of abstraction. The factory classes are
    also abstracted. This means that object `A` won't call the factory of object `B`
    directly, but instead use an abstraction. There should be a mechanism that determines
    which `Factory` class needs to be called. This means that object `A` is not dependent
    on any particular factory of another object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separating the plan of a complicated object from its imitation is the main idea
    of the builder pattern. In object-oriented software development, we sometimes
    need to create objects that are quite complex. For example, we might create an
    object that uses other objects, which in turn use other objects. Creating or instantiating
    this kind of object could be difficult when you just need that object to carry
    out another kind of work. It might also make the code more complex and reduce
    its readability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. Imagine that you are making some burgers, some
    of which are chicken burgers and some of which are beef burgers. When creating
    the chicken burger objects, you have to create a chicken burger patty object,
    a tomato ketchup object, a cheese object, and a bread object every time you create
    a chicken burger object, which leads to messy code. You also have to follow the
    same process when creating a beef burger object. This is a really complex way
    of handling and creating these objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern provides a nice way to solve this complexity. Using this
    pattern, we create a class called `Builder` whose main task is to create complex
    objects and return the newly-created object. With the builder pattern, we use
    another type of class, which is normally called the `director` class. The task
    of this class is to call the `Builder` class and get the object from it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to our burger example. We can have a `ChickenBurgerBuilder` class
    and a `BeefBurgerBuilder` class. These will set the items, the burger patty, the
    bread, the ketchup, and the cheese, in the class. When the `BurgerDirector` class
    wants to create a `chicken burger`, it will call `ChickenBurgerBuilder`. To create
    a `beef burger`, it will call `BeefBurgerBuilder`. The complexity of creating
    the `burger patty` and the other ingredients will be handled by the `Builder`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method pattern is very similar to the abstract factory pattern.
    The difference is that, in the factory method pattern, the factory layer is not
    abstracted. Using this pattern means that you will create a factory class that
    will handle the creation of classes that implement the same abstraction. This
    means that, if there is an interface that is defined by many subclasses, a `Factory`
    class can create any of those subclasses depending on the logic passed to `Factory`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. We will use the Factory method pattern to solve
    our burger-creating problem from the Builder pattern example we mentioned in the
    section, *The builder Pattern*. We will create a `Factory`, called `BurgerFactory`,
    that will take an input, such as `typeOfBurger` (Chicken or Beef). Then, `BurgerFactory`
    will decide which `Burger` type of object should be created. Let's suppose we
    have an Interface called `Burger` that both `ChickenBurger` and `BeefBurger` implement.
    This means that `BurgerFactory` will return an object of the `Burger` type. The
    client will not be aware which `Burger` Object will be created and returned. By
    using this pattern, we are isolating the client from a specific object, which
    increases the flexibility of the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一个例子。我们将使用工厂方法模式来解决我们在“生成器模式”示例中提到的制作汉堡的问题。我们将创建一个名为`BurgerFactory`的`Factory`，它将接受一个输入，比如`typeOfBurger`（鸡肉或牛肉）。然后，`BurgerFactory`将决定应该创建哪种`Burger`类型的对象。假设我们有一个名为`Burger`的接口，`ChickenBurger`和`BeefBurger`都实现了这个接口。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端将不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定对象隔离开来，从而增加了代码的灵活性。
- en: The prototype pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: This design pattern is used when you want to avoid creating new classes of the
    same type or sub-type using traditional object-creation mechanisms, such as new
    keywords. Put simply, this pattern states that we should clone an object and then
    work with the cloned object as another newly-created object. This way, the traditional
    method of object creation is avoided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要避免使用传统的对象创建机制（如new关键字）创建相同类型或子类型的新类时，可以使用这种设计模式。简而言之，这种模式规定我们应该克隆一个对象，然后使用克隆的对象作为另一个新创建的对象。这样就避免了传统的对象创建方法。
- en: The singleton pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is a very simple design pattern. It involves creating
    only one object of a class in the whole application. A **singleton object** is
    an object that can't have multiple instances. Whenever a piece of code needs to
    use this singleton object, it won't create a new object; instead, it will use
    the old object that is already available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一种非常简单的设计模式。它涉及在整个应用程序中只创建一个类的对象。**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象；相反，它将使用已经存在的旧对象。
- en: This design pattern is applicable when you want to handle some information from
    one source only. The best example of when we might use a singleton pattern is
    in a database connection string. In an application, if there are multiple database
    connections used, the database might get corrupted and cause exceptions in the
    application. Here, it's better to make the connection string a singleton object,
    meaning that only one instance is used for all communication. This reduces the
    chance of discrepancy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式适用于当您只想处理来自一个来源的一些信息时。使用单例模式的最佳示例是在数据库连接字符串中。在应用程序中，如果使用多个数据库连接，数据库可能会损坏并导致应用程序异常。在这种情况下，最好将连接字符串设置为单例对象，这意味着所有通信都只使用一个实例。这减少了出现差异的机会。
- en: Structural design patterns
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: 'Some of the design patterns that are available in software development are
    related to the code structure. These patterns help you to design your code in
    such a way that you will be able to avoid common structural problems. In the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four,
    there are seven structural design patterns. In this section, we are just going
    to discuss four of these, which are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中可用的一些设计模式与代码结构有关。这些模式可以帮助您以一种避免常见结构问题的方式设计代码。在《设计模式：可复用面向对象软件的元素》一书中，Gang
    of Four提出了七种结构设计模式。在本节中，我们将讨论其中的四种，分别是：
- en: The adapter pattern
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The decorator pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The facade pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: The proxy pattern
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'If you want to find out more about the other three, take a look at the book
    *Design Patterns: Elements of Reusable Object-Oriented Software* by the Gang of
    Four. At first, it might be a little confusing to start using these patterns,
    but, as you get more experienced, it will become easier to identify which pattern
    is appropriate for which situation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解其他三种模式的更多信息，请参阅Gang of Four的《设计模式：可复用面向对象软件的元素》一书。起初，开始使用这些模式可能会有点困惑，但随着经验的增加，识别哪种模式适合哪种情况将变得更容易。
- en: The adapter pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Normally, when we think of the word adapter, we think about a small device that
    helps us plug our electronic devices into a power socket with a different kind
    of interface on the plug. The adapter design pattern actually does the same thing
    in software code. This design pattern states that, if two modules of a software
    want to communicate with each other, but the interface that one module expects
    is different from the interface that the other module has, instead of changing
    one interface to match the other interface, an adapter should be used. The benefit
    of doing this is that, in the future, if you want your code to talk to another
    interface, you won't have to change your code, but just use another adapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入具有不同接口的电源插座。适配器设计模式实际上在软件代码中也是这样的。这种设计模式规定，如果软件的两个模块想要相互通信，但一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口以匹配另一个接口。这样做的好处是，将来如果您希望您的代码与另一个接口进行通信，您不必更改您的代码，只需使用另一个适配器。
- en: For example, imagine you have an Interface, `A`, but the code that you want
    to talk to wants another Interface, `B`. Instead of changing Interface `A` to
    Interface `B`, you use an adapter that converts interface `A` to interface `B`.
    This way, the code that uses interface `A` will not break, and you will be able
    to communicate with the code that asks for interface `B`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你有一个接口`A`，但你想要与之交流的代码需要另一个接口`B`。你可以使用一个适配器将接口`A`转换为接口`B`，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码不会出错，你将能够与要求接口`B`的代码进行通信。
- en: The decorator pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The decorator pattern allows us to add new behaviors to objects dynamically.
    When this new behavior is added to an object, it shouldn't affect any other behavior
    that already exists on that object. This pattern provides a solution when you
    have to add new behaviors to an object at runtime. It also removes the need to
    create subclasses just to add a behavior to a task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式允许我们动态地向对象添加新的行为。当这种新行为被添加到一个对象时，它不应该影响该对象上已经存在的任何其他行为。当你需要在运行时向对象添加新的行为时，这种模式提供了一个解决方案。它还消除了创建子类只是为了向任务添加行为的需要。
- en: The facade pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'Sometimes, if you have complex object relationships, it is hard to map them
    all and use them in your code. The facade pattern states that you should use a
    middle object to deal with the object-relational issues and give the client an
    easy point of contact. Let''s think about an example: when you go to a restaurant
    and order some food, you actually don''t go to each chef or person in the kitchen
    and collect food portions and make your own food; you tell the waiter what food
    you want. You don''t know how the item will be prepared or who will prepare it.
    You have no control over the making of the food, you just know that you will get
    the item that you have asked for. Here, the person taking the order is working
    as a facade. They take your order and ask different people to prepare the item
    you asked for.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果你有复杂的对象关系，很难将它们全部映射并在代码中使用。外观模式表明，你应该使用一个中间对象来处理对象关系问题，并给客户端一个简单的接触点。让我们想想一个例子：当你去餐厅点餐时，你实际上不会去找厨师或厨房里的人收集食物，然后自己做饭；你告诉服务员你想要什么食物。你不知道食物将如何准备或谁会准备它。你无法控制食物的制作，你只知道你会得到你要的东西。在这里，接受订单的人就是一个外观。他们接受你的订单，并要求不同的人准备你要的东西。
- en: 'Let''s say that you ordered a beef burger. You call a `GetBeefBurger()` method
    and the facade will actually call the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你点了一份牛肉汉堡。你调用一个`GetBeefBurger()`方法，外观实际上会调用以下内容：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding methods are not real methods. I just want to give you an idea
    that the work of a facade is actually to hide the complexity from the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法并不是真正的方法。我只是想给你一个概念，即外观的工作实际上是为了隐藏客户端的复杂性。
- en: The proxy pattern
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: This pattern is very similar to the other structural design patterns that we
    have discussed. If there is a situation in which a piece of code should not call
    another piece of code directly for whatever reason, the proxy pattern can be used.
    The proxy pattern is especially useful when a piece of code doesn't have access
    rights to call another piece of code or when calling a piece of code directly
    is expensive in terms of resources. An example of when we might want to use a
    proxy pattern would be if we wanted to use a third-party library in our application,
    but we don't want our code to call the library directly for security reasons.
    In this case, we can create a proxy and let it communicate with the third-party
    code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与我们讨论过的其他结构设计模式非常相似。如果有一种情况，代码不应该直接调用另一段代码，无论出于什么原因，都可以使用代理模式。代理模式在代码没有权限调用另一段代码或直接调用一段代码在资源方面昂贵时特别有用。我们可能想使用代理模式的一个例子是，如果我们想在应用程序中使用第三方库，但出于安全原因，我们不希望我们的代码直接调用该库。在这种情况下，我们可以创建一个代理，让它与第三方代码进行通信。
- en: Behavioral design patterns
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: 'Behavioral design patterns are design patterns that deal with communication
    between objects. These design patterns allow your objects to communicate in a
    way that avoids the common issues that developers face related to object behavior.
    There are many patterns in this category:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式是处理对象之间通信的设计模式。这些设计模式允许你的对象以一种避免开发人员面临的与对象行为相关的常见问题的方式进行通信。在这个类别中有许多模式：
- en: The chain-of-responsibility pattern
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The command pattern
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The interpreter pattern
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The iterator pattern
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The mediator pattern
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The memento pattern
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The observer pattern
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The state pattern
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: The strategy pattern
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The template-method pattern
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The visitor pattern
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: 'In this book, however, we are only going to talk about the following behavioral
    design patterns:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这本书中，我们只会讨论以下行为设计模式：
- en: The command pattern
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The observer pattern
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The strategy pattern
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'If you want to find out more, refer to the *Design Patterns: Elements of Reusable
    Object-Oriented Software* book by the Gang of Four that we mentioned earlier.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，请参考我们之前提到的《设计模式：可复用面向对象软件的元素》一书，作者是四人组。
- en: The command pattern
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: This pattern states that, when an object wants to notify another object or call
    a method of another object, it should use another object instead of doing so directly.
    The object that will establish the communication is known as the command object.
    The command will encapsulate the object that holds the method to be called, the
    method name to be called, and the parameters that are to be passed, if there are
    any. The command pattern helps to decouple the relationship between the invoker
    and the receiver.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，应该使用另一个对象而不是直接这样做。建立通信的对象被称为命令对象。命令将封装持有要调用的方法、要调用的方法名以及要传递的参数（如果有的话）的对象。命令模式有助于解耦调用者和接收者之间的关系。
- en: The observer pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The **observer pattern** is a solution to a problem in which many objects need
    to know when a particular object changes because they might have to update the
    data on their end. One way to do this is that all the objects, or observers, should
    ask the object, or the observable, whether the data has changed. If the data has
    changed in the observable, the observer will do its work. However, if we do this,
    the observers have to ask the observable about data changes very frequently to
    avoid slowing down your application. This requires a lot of resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者模式**是解决一个问题的解决方案，即许多对象需要知道特定对象何时发生变化，因为它们可能需要更新其端上的数据。一种方法是，所有对象或观察者都应该询问对象或可观察对象数据是否发生了变化。如果可观察对象中的数据发生了变化，观察者将执行其工作。然而，如果这样做，观察者必须经常询问可观察对象关于数据变化，以避免减慢应用程序的速度。这需要大量的资源。'
- en: The observer pattern says that the observable should know the list of the observers
    that want to know about the data changes in the subject and notify each observer
    when the data in the subject is changed. This could be done by calling a method
    of the observers. A good use of this pattern is event and delegate in C#.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式表示可观察对象应该知道想要了解主题中数据变化的观察者列表，并在主题中的数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的应用是C#中的事件和委托。
- en: The strategy pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'Let''s take a look at a definition of the strategy pattern from the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下《设计模式：可复用面向对象软件的元素》一书中四人帮对策略模式的定义：
- en: For example, a method could have different types of implementations depending
    on which class is using it. The definition, therefore, means that we need to make
    these different algorithms implement a base class or interface so that they belong
    to the same family and can be used interchangeably by the clients. The last part
    of the definition means that this pattern will allow clients to use different
    algorithms without affecting other clients.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个方法可以根据使用它的类的不同类型有不同的实现。因此，这个定义意味着我们需要使这些不同的算法实现一个基类或接口，以便它们属于同一个家族，并可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法而不影响其他客户端。
- en: Let's imagine that we have a class, called `Animal`, that has a few common properties,
    such as `eat`, `walk`, and `noise`. Now, let's say you want to add another property,
    such as `fly`. Most of the animals in your class can fly, but a few can't. You
    could break the `Animal` class into two different classes, such as `AnimalWhichCanFly`
    and `AnimalWhichCantFly`. However, splitting this `Animal` class into two could
    over-complicate things as these animals could have other different attributes
    as well. Instead of using inheritance, therefore, you could use composition, which
    means you can add a property called `fly` in the `Animal` class and use it to
    indicate this behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`Animal`的类，它具有一些常见属性，如`eat`、`walk`和`noise`。现在，假设你想添加另一个属性，比如`fly`。你的类中的大多数动物都会飞，但有一些不会。你可以将`Animal`类分成两个不同的类，比如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将`Animal`类分成两个可能会使事情变得过于复杂，因为这些动物可能还有其他不同的属性。因此，你可以使用组合而不是继承，在`Animal`类中添加一个名为`fly`的属性，并用它来指示这种行为。
- en: The strategy pattern states that instead of using a fixed type, `fly`, as the
    property type, we should use an interface, such as `IFly`, and then create `subclasses`
    that implement `IFly` and have different algorithms. Then, we can take advantage
    of polymorphism and assign the specific subclass at runtime when the subclasses
    of the `Animal` class are created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式规定，我们应该使用接口（如`IFly`）而不是固定类型`fly`作为属性类型，然后创建实现`IFly`并具有不同算法的`子类`。然后，我们可以利用多态性，在创建`Animal`类的子类时在运行时分配特定的子类。
- en: 'Let''s try to apply this on the preceding example. In the `Animal` class, instead
    of using the `Fly` property, we will use `IFly` and then implement different classes
    that implement `IFly`. For example, we create the `CanFly : IFly` and `CannotFly
    : IFly` classes. `CanFly` and `CannotFly` will have different implementations
    of the `Fly` method. If we create a `Dog` class that implements the `Animal` class,
    we will set the `Fly` property as the `CannotFly` class. If we create a `Bird`
    class, we will create an instance of `CanFly` and assign it to the `Fly` property.
    By applying this pattern, we have achieved a less-complicated object structure
    and easily-changeable algorithms.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在前面的例子中应用这一点。在`Animal`类中，我们将使用`IFly`而不是`Fly`属性，然后实现实现`IFly`的不同类。例如，我们创建`CanFly：IFly`和`CannotFly：IFly`类。`CanFly`和`CannotFly`将有不同的`Fly`方法实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建`CanFly`的实例并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不那么复杂的对象结构和易于更改的算法。
- en: The MVC pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC模式
- en: 'The MVC pattern is one of the most popular design patterns in the industry.
    You might have heard about it already, even if you are very new to the industry.
    This pattern is heavily used in web development. Many popular web-development
    frameworks use this design pattern. Some popular frameworks that use the MVC pattern
    are given here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式是行业中最流行的设计模式之一。即使你是行业的新手，你可能已经听说过它。这种模式在 web 开发中被广泛使用。许多流行的 web 开发框架都使用这种设计模式。一些使用
    MVC 模式的流行框架如下：
- en: '**C#:** ASP.NET MVC Web Framework'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C#: ASP.NET MVC Web Framework'
- en: '**Java:** Spring framework'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java:** Spring 框架'
- en: '**PHP:** Laravel framework, Codeigniter framework'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP:** Laravel 框架，Codeigniter 框架'
- en: '**Ruby:** Rails framework'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ruby:** Rails 框架'
- en: 'The MVC design pattern states that we should divide a web application into
    three parts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 设计模式规定我们应该将 web 应用程序分为三个部分：
- en: Model
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: View
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Controller
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: The **model** is the part that will hold the data models or objects and will
    be used in database transactions. **View** refers to the frontend of the application,
    which the users or customers look at. Finally, the **controller** is the part
    that handles all the business logic of the application. All the logic and decision-making
    parts will be in the controller.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型** 是将保存数据模型或对象并用于数据库事务的部分。**视图** 指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器** 是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。'
- en: The benefit of the MVC pattern is that your application is decoupled. Your view
    is independent from your business logic and your business logic is independent
    of your data source. This way, you can easily change one part of your application
    without affecting other parts of the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式的好处是你的应用程序是解耦的。你的视图独立于你的业务逻辑，你的业务逻辑独立于你的数据源。这样，你可以轻松地更改应用程序的一部分而不影响应用程序的其他部分。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Software development is interesting because it changes all the time. There are
    many ways in which you can develop, design, or code something. None of these can
    be classified as the best way, because your code might need to change depending
    on the situation. However, because software development is a type of engineering,
    there are various rules that will make your software stronger and more reliable.
    Software design principles and design patterns are examples of these kinds of
    rules. Knowing these concepts and applying them to your own situation will make
    your life as a developer much easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发很有趣，因为它一直在变化。你可以用许多方式来开发、设计或编写某些东西。这些方式都不能被归类为最好的方式，因为你的代码可能需要根据情况进行更改。然而，因为软件开发是一种工程类型，有各种规则可以使你的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将它们应用到你自己的情况中将会让你作为开发者的生活变得更加容易。
- en: This chapter has hopefully given you an idea of the basics of design patterns
    and shown you where you can look for more information. In the next chapter, we
    will get to know a very powerful and interesting software called Git. Git is a
    version-control system that helps to keep track of software code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节希望给你一个设计模式基础的概念，并告诉你在哪里可以寻找更多信息。在下一章中，我们将了解一个非常强大和有趣的软件，叫做 Git。Git 是一个版本控制系统，可以帮助跟踪软件代码的变化。

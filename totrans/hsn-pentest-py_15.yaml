- en: Other Wonders of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cyber security is a vast and dynamically growing field. So far in this book,
    we have discussed various use cases in which Python comes in handy. The reader
    can utilize this knowledge to explore further scenarios in which Python can be
    applied in the cyber security domain. In this concluding chapter, we will try
    to cover a few other ways in which we can use Python. We will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Nessus and Nmap reports with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom Linux- and Windows-based keyloggers in Python and sharing logs
    across the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing Tweeter tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting browser-saved passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Antivirus-free persistence shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing host-based firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Report parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **report parser** is a piece of code written in order to parse a report or
    a file. The files under discussion in this case are Nessus and Nmap files. The
    detailed description and functionality of each are covered in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nmap produces outputs in various formats (text, CSV, and XML). In this section,
    we are going to learn how we can quickly and easily parse Nmap report files in
    XML format. There are two approaches we can use to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is to build a parser from scratch and employ the same concepts
    that we discussed in [Chapter 4](a102c7fe-a6cb-41de-9a5c-392fd05f828a.xhtml),
    *Advanced Python Modules*, which focused on XML parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second and recommended approach is to avoid re-inventing the wheel. Always
    make it a habit to search on the internet before developing any automation solutions
    in Python. Python has got amazing community support and there are many different
    modules that offer out-of-the-box solutions not only in the cyber security domain,
    but also for other more general use cases. Let''s use one of these pre-built Python
    modules. We will install the `libnmap` Python module, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file called `nmap_parser.py` and place the following code in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/954b1411-cf2f-4281-b696-c940a034cfcf.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is pretty self-explanatory. What we are doing is creating
    a class and calling it `nmap_parser`. In the constructor of the class, we are
    initializing a `self.report_file` instance variable with the file path including
    the name of the report, which the user should pass as the first argument to the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: In line 9, we initialize the instance of the `NmapParser` class and pass the
    path of the file that we wish to parse. It returns `NmapObject`, which we will
    further iterate on to get the results. In line 11, we extract the list of `hosts()`
    from the `NmapObject` we created earlier, which is called `report` in the preceding
    code. It should be noted that although `NmapObject ` returns a list, each list
    element is an object of the `host()` class, which the module creates internally
    by mapping the host tags from the file appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: In line 13, we check if the host currently being iterated over is alive using
    the `is_up()` method. In line 15, we extract all the open ports for a host. The
    method returns a list that we iterate over in line 18\. The internal format it
    uses is `[(``"22","ssh"),("21","ftp"``)]`.
  prefs: []
  type: TYPE_NORMAL
- en: In line 20, we invoke a `host.get_service` method , which returns the instance
    of the service class. It expects the port and name of the service to be passed
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, between lines 21 and 26, we print all the relevant information by invoking
    appropriate instance variables and instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete API documentation of this module can be found on the official
    website: [https://libnmap.readthedocs.io/en/latest/index.html](https://libnmap.readthedocs.io/en/latest/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the code, we need to invoke it as a normal Python script. However, we
    also need to pass the path/name of the Nmap file that we wish to parse as an argument.
    I have taken a sample file, `nmap.xml`, which lies on the same path as our parser
    code. The file contains a scan report conducted against multiple hosts. The `nmap`
    command used to produce the output file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A screenshot of the report is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f43b44ef-438e-410f-9889-2332ea9491eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the parser code using the following command to see the output it
    produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`nmap.xml` is the name of the file placed in the same folder as the parser
    code. If your `report` file is at a different path, provide the absolute path
    as an argument to the script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output obtained is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0201a5-cc04-4a1e-aa2c-6e5dbd2d81e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Nessus parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nessus also produces output in various formats (CSV, XML, DB-file, JSON, HTML,
    and so on). In this section, we are going to understand how we can quickly and
    easily parse Nessus report files of XML format. Again, we can either create a
    custom parser manually, or get the job done with an out-of-the-box Python module,
    which makes life very easy for us. Install the required module as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file called `Nessus_parser.py` and place the following code
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e49a40e-4f72-42a2-9c38-4dcbfe9a4a3c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is pretty self-explanatory. What we are doing is creating
    a class and calling it `Nessus_parser`. In the constructor of the class, we are
    initializing an instance variable called `self.n_file` with the file path including
    the name of the report, which the user should pass as the first argument to the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: In line 30, we initialize the instance of the `NessusParser` class and pass
    the path of the file that we wish to parse. It returns `NessusObject`, which we
    will further iterate on to get the results. In line 35, we simply invoke the `demo_print()`
    method and pass the `NessusObject()` instance to it, which contains a list of
    hosts that we wish to iterate over. Between lines 12 and 25, we simply iterate
    over Nessus Host instances and print the relevant information. The Nessus parser
    is very similar to the Nmap parser we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The complete API details of the class can be found at the official website: [https://libnessus.readthedocs.io/en/stable/](https://libnessus.readthedocs.io/en/stable/.).
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code, we need to invoke it as a normal Python script, but we also
    need to pass the path/name of the Nessus file that we wish to parse as an argument.
    I have taken a sample file, `report.nessus`, which lies on the same path as our
    parser code. The file contains a scan report conducted against multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the report is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08d0bb26-b71e-46f8-80cf-be3666180d24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the parser code using the following command to see the output it
    produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`report.nessus` is the name of the file placed in the same folder as the parser
    code. If your report file is at a different path, provide the absolute path as
    an argument to the script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output obtained is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e85e498-7fb9-46b0-9297-c4defe64369c.png)'
  prefs: []
  type: TYPE_IMG
- en: The need to have custom parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical use case where I have found these custom parsers very handy is during
    client engagements. After every typical pen test, a pen tester will usually consolidate
    all the Nessus report findings, Nmap output, and POCs generated by manual exploitation
    and put them in a custom Excel template created by the client, or use the companies
    report generating portal to produce a consolidated report. The approach discussed
    previously can be used to automate this process. Using the concepts we discussed,
    I would recommend that the reader make a general-purpose report generating module
    that would consolidate the findings from Nmap and Nessus and that would also take
    custom POC screenshots into account to generate Excel and PDF format reports.
  prefs: []
  type: TYPE_NORMAL
- en: Keylogger and exfiltration via sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **keylogger** is a notorious piece of software that records all keystrokes
    the user presses. It silently runs as an operating system process in the background.
    They are capable of recording user passwords, browsing history, confidential data,
    and much more. There are many keyloggers freely available and ready to use out
    of the box. In this section, we are going to see how we can create a powerful
    custom keylogger in Python. A custom keylogger is always better, as we can tailor
    it according to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a very powerful module known as pyHook for Windows and there
    is a modification on top of this module to support Linux-based systems, called
    `pyxhook`. There are tons of tutorials out on the internet on the usage of the `pyhook` Windows-based
    Python keylogger, but there aren't as many tutorials concerning  the Linux version.
    In this section, we will focus on the Linux-based keylogger. I will also provide
    a simple code snippet that works for the Windows module as well.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this section is to simulate a real-world attack scenario, so
    our keylogger will not only save the keystrokes in a file, but also send the generated
    logs to the attacker machine at specific time intervals. We will explore how the concepts
    to do with socket programming that we looked at previously will come in very handy
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the Linux version of the keylogger module from the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to install the Windows version of the Python keylogger and you
    are working in the Windows environment, this can be achieved using `pip`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: pyxhook – a Linux based Keylogger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we have successfully cloned the GitHub repository of `pyxhook`, let''s
    run a `cd` command in the directory of the downloaded repository and create a
    file called `key_logg.py` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The keylogger makes use of the downloaded `pyxhook` repository module. As can
    be seen in line 2, we are importing the `pyxhook` module. The following code creates
    a custom class file called `Mylogger`. It defines a method, `startlogin()`, in
    which the central logic triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a84b24-c818-4bb2-83e1-a1bd6566eea7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, within our `my_event` custom method, we get the key pressed by invoking
    the current keyboard event. In line 20, we check if the user has pressed the spacebar,
    the ASCII key code of which is 32\. If this is the case, we replace the `space`
    keyword with an empty space string, `" "`. In line 22, we update our `self.log_string` instance
    variable, and append to it whatever the user has pressed.
  prefs: []
  type: TYPE_NORMAL
- en: In line 23, we check for the keylogger termination condition, which is determined
    by checking if the user has entered the `quitkhan` string. That will set `self.running
    flag=False` and will stop the keylogger. If the user has not entered this string,
    the keylogger will keep updating the `self.log_string` string, and after every
    5 seconds it will send `log_string` to the attacker machine using sockets. This
    is handled by lines 25–30\. The method that is used to send `log_string` to attacker
    machine is the `send_to_attacker()` method, the definition of which starts from
    line 8.
  prefs: []
  type: TYPE_NORMAL
- en: In line 32, we create an instance of the `pyxhook` module called `hm`. Once
    it is created, we bind the `hm` instance with a custom method called `self.my_event`.
    This triggers the `my_event` method when a key is pressed. In line 33, we bind
    the `hm` instance with the keyboard of the computer, which means that whenever
    any key is pressed on the keyboard, the `keyDown` action is invoked, which is
    bound to our `my_event` custom method. In line 34, we have an infinite loop that
    will keep running till until the `self.running` flag is set to `True`. This means
    that the `my_event` method will be invoked after every millisecond and the pressed
    keystroke will be recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that the attacker IP and port can be changed as appropriate.
    At the attacker end, we have a socket server that keeps listening on port `8080` and
    accepts connections from clients. Whenever it receives any data, it places it
    in the `log_file` log file. The code snippet that implements the attacker server
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf648c25-0961-4214-b183-986f2431c796.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is straightforward and has been discussed in detail in the
    socket programming section of the *Advanced Python Modules* chapter. It simply
    opens a socket and listens to client connections. When it receives data, it places
    it in a log file. Let's run the server and the keylogger and see which keystrokes
    will be recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the processes in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the Terminal output produced by the logger while
    we were typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dd3a5df-2bff-4826-ba4f-6ff13c3eae41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Meanwhile, we opened the browser and typed [www.google.com](http://www.google.com).
    We can also pass the current window to the attacker, on which the data has been
    typed. Refer to the example shared on the GitHub repository, `example.py`: [https://github.com/JeffHoogland/pyxhook/blob/master/example.py](https://github.com/JeffHoogland/pyxhook/blob/master/example.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the log file generated at the server and analyze what it captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/989e2309-1b7c-4f1f-b531-cb4f0390c954.png)'
  prefs: []
  type: TYPE_IMG
- en: Bingo! It can be seen from the preceding screenshot that the logger was successfully
    able to capture all the keystrokes. Feel free to explore this further; it is a
    very powerful and destructive utility.
  prefs: []
  type: TYPE_NORMAL
- en: pyhook – a Windows-based keylogger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the code snippet to get started with the Windows-based keylogger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bff0f153-913c-4103-b72f-e1d5e87770ab.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen from the preceding screenshot, the code is identical to that
    we discussed previously in the Linux use case. The preceding code simply logs
    all the keystrokes in a file called `mylog.txt`. It does not, however, send it
    across to the attacker. With this, we come to the end of the keylogger section.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Twitter tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being in the offensive security domain, we might wonder why we need to parse
    Twitter tweets. This question is valid, as this use case is more suited to defensive
    security. It may help, however, to uncover a good amount of information if we
    are targeting a specific individual or a specific organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Twitter-tweet-parsing can be used by cyber intelligence
    teams to see if any defamation or sensitive content has been posted under the
    organization''s name. Let''s take a look at the following example that explains
    Twitter tweet parsing. First, we need to install the Python module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example takes a Twitter feed as an input JSON file and parses all tweets
    to produce the output. Let''s create a file called `sample.py` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21d15e30-a1a9-4039-9ce1-c7af89368645.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use a sample Twitter feed file called `exp.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a5306b-b979-40f8-92d0-0b6b2f55024a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, run the code to print all the tweets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/039b2d62-486f-45ee-abdc-85ea2a4925f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Twitter class object created in line 14, `tweet=Tweet(tweet_dict)`,has
    many other methods and variables that can give granular information about tweets
    such as the date, time, likes, and retweets. The different supported methods can
    be obtained by running `dir(tweet)`, the output of which is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Stealing browser passwords with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a very powerful language when it comes to cyber security. There are
    tons of amazing offensive and defensive security tools written in Python and its
    very easy to customize and modify them to serve our needs. In this section, we
    will see how we can use Python in order to steal passwords that are stored in
    browser. Again, since we have so many amazing tools already available and out
    of the box ready to use, we will not be reinventing the wheel, but instead reusing
    what is already out there. Let''s download the GitHub repository as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, simply run the tool to see the browser passwords as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This tool is very handy. It doesn''t just extract browser passwords, it is
    also capable of extracting passwords from the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sysadmin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wallet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mails`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`databases`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WiFi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browsers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python for antivirus-free persistence shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, one of the finest techniques to evade antivirus software is to write
    custom exploits. If the exploit is written from scratch, there is very little
    chance for the antivirus engine to match the code signature against the known
    malicious signatures. In this section, we will write a custom shell that returns
    a reverse shell from the victim's machine and see how many AV engines can detect
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a custom exploit, name it `my_car.py`, and place the following
    code in it :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e17adf32-3de2-4d59-b1a3-b997ee0c56f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we observe the preceding code, we can see that it is an adaption of a Python
    code to spawn a reverse shell to an attacker''s IP address. We are importing the
    Python modules and assigning an alias to the imported modules locally. The AV
    engines mostly work on the signature approach, and the known signatures, such
    as `subprocess.call["/bin/sh","-i"''\]`, are likely to be detected. In this case,
    we are playing around with local variables to ensure to ensure the attacker IP,
    the port number, the OS modules, and other Python modules are not detected. The
    original code that the preceding code is adapted from is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the code to see if we get the shell. We will use a Netcat listener
    to receive the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command when implemented produces the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/005f4f32-081f-49bf-a68e-694f61a4c0cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the preceding code works pretty well. It''s important for us
    to see if this would be picked up by any AV engine. Let''s check it using the
    VirusTotal tool, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1310a260-8cd5-4e90-aece-b03f27f315b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now see whether we were detected by any of the scanning engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ab459e3-fec5-4f28-9eb0-ca9379387868.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, none of the 57 scanning engines tested detected the file.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that we had zero detection results on the day this chapter
    was written and prepared. There is a possibility that over time readers might
    upload more samples and the backend team may update the signatures based on the
    code sample, as I have already uploaded it. Static analysis by the backend human
    team will mark it as malicious. However, with a slight modification, it will be
    able to avoid detection again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about developing custom exploits that are able to
    avoid antivirus software. We have also studied how to develop a custom Linux-based
    key logger that sends keystrokes across the network to the remote attacker. We
    also explored various concepts to do with parsing Nessus and Nmap reports. We
    came to understand how to extract browser passwords with Python utilities and
    how to go about parsing Twitter feeds.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the conclusion of this book. I would recommend you explore
    more about Python and apply it more often in offensive security. A good place
    to start would be to take all the examples, use cases, and exploits discussed
    in this book and to make them as general as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can we send the keylogger strokes through email?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we improve the keylogger code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we improve the persistent shell exploit code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python keylogger: [https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python exploit development assistance: [https://github.com/longld/peda](https://github.com/longld/peda)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Veil: [https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

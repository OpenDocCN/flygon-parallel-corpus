- en: Introduction to Parallel Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程简介
- en: Parallel programming has been supported in .NET since the start and it has gained
    a strong footing since the introduction of the **Task Parallel Library** (**TPL**)
    from .NET framework 4.0 onward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET开始就支持并行编程，并自.NET框架4.0引入**任务并行库**（**TPL**）以来，它已经获得了牢固的基础。
- en: Multithreading is a subset of parallel programming and is one of the least understood
    aspects of programming; it's one that many new developers struggle to understand.
    C# has evolved significantly since its inception. It has very strong support,
    not only for multithreading but also for asynchronous programming. Multithreading
    in C# goes way back to C# version 1.0. C# is primarily synchronous, but with the
    strong async support that has been added from C# 5.0 onward, it has become the
    first choice for application programmers. Whereas multithreading only deals with
    how to parallelize within processes, parallel programming also deals with inter-process
    communication scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是并行编程的一个子集，也是编程中最不被理解的方面之一；许多新开发人员很难理解。C#自诞生以来已经发生了很大的变化。它不仅对多线程有很强的支持，还对异步编程有很强的支持。C#的多线程可以追溯到C#
    1.0。C#主要是同步的，但从C# 5.0开始增加了强大的异步支持，使其成为应用程序程序员的首选。而多线程只涉及如何在进程内并行化，而并行编程还涉及进程间通信的场景。
- en: Prior to the introduction of the TPL, we relied on `Thread`, `BackgroundWorker`, and `ThreadPool` to
    provide us with multithreading capabilities. At the time of C# v1.0, it relied
    on threads to split up work and free up the **user interface** (**UI**), thereby
    allowing the user to develop responsive applications. This model is now referred
    to as classic threading. With time, this model made way for another model of programming,
    called TPL, which relies on tasks and still uses threads internally.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在TPL引入之前，我们依赖于`Thread`、`BackgroundWorker`和`ThreadPool`来提供多线程能力。在C# v1.0时，它依赖于线程来分割工作并释放**用户界面**（**UI**），从而使用户能够开发响应式应用程序。这个模型现在被称为经典线程。随着时间的推移，这个模型为另一个编程模型让路，称为TPL，它依赖于任务，并且在内部仍然使用线程。
- en: In this chapter, we will learn about various concepts that will help you learn
    about writing multithreaded code from scratch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习各种概念，这些概念将帮助您从头开始学习编写多线程代码。
- en: 'We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Basic concepts of multi-core computing, starting with an introduction to the
    concepts and processes related to the **operating system** (**OS**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多核计算的基本概念，从介绍与**操作系统**（**OS**）相关的概念和进程开始。
- en: Threads and the difference between multithreading and multitasking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程以及多线程和多任务之间的区别
- en: Advantages and disadvantages of writing parallel code and scenarios in which
    parallel programming is useful
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并行代码的优缺点以及并行编程有用的场景
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the examples demonstrated in this book have been created in Visual Studio
    2019 using C# 8. All the source code can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中演示的所有示例都是在使用C# 8的Visual Studio 2019中创建的。所有源代码都可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter01)。
- en: Preparing for multi-core computing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多核计算做准备
- en: In this section, we will introduce the core concepts of the OS, starting with
    the process, which is where threads live and run. Then, we will consider how multitasking
    evolved with the introduction of hardware capabilities, which make parallel programming
    possible. After that, we will try to understand the different ways of creating
    a thread with code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍操作系统的核心概念，从进程开始，线程所在和运行的地方。然后，我们将考虑随着硬件能力的引入，多任务处理是如何演变的，这使得并行编程成为可能。之后，我们将尝试理解使用代码创建线程的不同方式。
- en: Processes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: In layman's terms, the word *process* refers to a program in execution. In terms
    of the OS, however, a process is an address space in the memory. Every application,
    whether it is a Windows, web, or mobile application, needs processes to run. Processes
    provide security for programs against other programs that run on the same system
    so that data that's allocated to one cannot be accidentally accessed by another.
    They also provide isolation so that programs can be started and stopped independently
    of each other and independently of the underlying OS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗地说，*进程*一词指的是正在执行的程序。然而，在操作系统方面，进程是内存中的地址空间。无论是Windows、Web还是移动应用程序，每个应用程序都需要进程来运行。进程为程序提供安全性，防止其他在同一系统上运行的程序意外访问分配给另一个程序的数据。它们还提供隔离，使得程序可以独立于其他程序和底层操作系统启动和停止。
- en: Some more information about the OS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关操作系统的更多信息
- en: 'The performance of applications largely depends on the quality and configuration
    of the hardware. This includes the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的性能在很大程度上取决于硬件的质量和配置。这包括以下内容：
- en: CPU speed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU速度
- en: Amount of RAM
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM的数量
- en: Hard disk speed (5400/7200 RPM)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘速度（5400/7200 RPM）
- en: Disk type, that is, HDD or SSD
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘类型，即HDD或SSD
- en: Over the last few decades, we have seen huge jumps in hardware technology. For
    example, microprocessors used to have a single core, which is a chip with one
    **central processing unit** (**CPU**). By the turn of the century, we saw the
    advent of multi-core processors, which are chips with two or more processors,
    each with its own cache.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，我们已经看到了硬件技术的巨大飞跃。例如，微处理器过去只有一个核心，即一个**中央处理单元**（**CPU**）的芯片。到了世纪之交，我们看到了多核处理器的出现，这是具有两个或更多处理器的芯片，每个处理器都有自己的缓存。
- en: Multitasking
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多任务处理
- en: Multitasking refers to the ability of a computer system to run more than one
    process (application) at a time. The number of processes that can be run by a
    system is directly proportional to the number of cores in that system. Therefore,
    a single-core processor can only run one task at a time, a dual-core processor
    can run two tasks at a time, and a quad-core processor can run four tasks at a
    time. If we add the concept of CPU scheduling to this, we can see that the CPU
    runs more applications at a time by scheduling or switching them based on CPU
    scheduling algorithms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务处理是指计算机系统同时运行多个进程（应用程序）的能力。系统可以运行的进程数量与系统中的核心数量成正比。因此，单核处理器一次只能运行一个任务，双核处理器一次可以运行两个任务，四核处理器一次可以运行四个任务。如果我们将CPU调度的概念加入其中，我们可以看到CPU通过基于CPU调度算法进行调度或切换来同时运行更多应用程序。
- en: Hyper-threading
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超线程
- en: '**Hyper-threading** (**HT**) technology is a proprietary technology that was
    developed by Intel that improves the parallelization of computations that are
    performed on x86 processors. It was first introduced in Xeon server processors
    in 2002\. HT-enabled single-processor chips run with two virtual (logical) cores
    and are capable of executing two tasks at a time. The following diagram shows
    the difference between single- and multi-core chips:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**超线程**（**HT**）技术是英特尔开发的专有技术，它改进了在x86处理器上执行的计算的并行化。它首次在2002年的至强服务器处理器中引入。HT启用的单处理器芯片运行具有两个虚拟（逻辑）核心，并且能够同时执行两个任务。以下图表显示了单核和多核芯片之间的区别：'
- en: '![](img/0bf4dc71-2221-42f3-b90f-ffaccf0bbd82.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bf4dc71-2221-42f3-b90f-ffaccf0bbd82.png)'
- en: 'The following are a few examples of processor configurations and the number
    of tasks that they can perform:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些处理器配置的示例以及它们可以执行的任务数量：
- en: '**A single processor with a single-core chip**: One task at a time'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单核芯片的单处理器**：一次一个任务'
- en: '**A single processor with an HT-enabled single-core chip**: Two tasks at a
    time'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HT启用的单核芯片的单处理器**：一次两个任务'
- en: '**A single processor with a dual-core chip**: Two tasks at a time'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双核芯片的单处理器**：一次两个任务'
- en: '**A single processor with an HT-enabled dual-core chip**: Four tasks at a time'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HT启用的双核芯片的单处理器**：一次四个任务'
- en: '**A single processor with a quad-core chip**: Four tasks at a time'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四核芯片的单处理器**：一次四个任务'
- en: '**A single processor with an HT-enabled quad-core chip**: Eight tasks at a
    time'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HT启用的四核芯片的单处理器**：一次八个任务'
- en: 'The following is a screenshot of a CPU resource monitor for an HT-enabled quad-core
    processor system. On the right-hand side, you can see that there are eight available
    CPUs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HT启用的四核处理器系统的CPU资源监视器的屏幕截图。在右侧，您可以看到有八个可用的CPU：
- en: '![](img/47af0d87-7dcb-4f51-843d-dcba28bb0ab6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47af0d87-7dcb-4f51-843d-dcba28bb0ab6.png)'
- en: You might be wondering how much you can improve the performance of your computer
    simply by moving from a single-core to a multi-core processor. At the time of
    writing, most of the fastest supercomputers are built on the **Multiple Instruction,
    Multiple Data** (**MIMD**) architecture, which was one of the classifications
    of computer architecture proposed by Michael J. Flynn in 1966.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，仅通过从单核处理器转换到多核处理器，您可以提高计算机的性能多少。在撰写本文时，大多数最快的超级计算机都是基于**多指令，多数据**（**MIMD**）架构构建的，这是迈克尔·J·弗林在1966年提出的计算机架构分类之一。
- en: Let's try to understand this classification.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解这个分类。
- en: Flynn's taxonomy
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弗林的分类
- en: 'Flynn classified computer architectures into four categories based on the number
    of concurrent instruction (or control) streams and data streams:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 弗林根据并发指令（或控制）流和数据流的数量将计算机架构分为四类：
- en: '**Single Instruction, Single Data (SISD)**:In this model, there is a single
    control unit and a single instruction stream. These systems can only execute one
    instruction at a time without any parallel processing. All single-core processor
    machines are based on the SISD architecture.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单指令，单数据（SISD）**：在这种模型中，有一个单一的控制单元和一个单一的指令流。这些系统只能一次执行一个指令，没有任何并行处理。所有单核处理器机器都基于SISD架构。'
- en: '**Single Instruction, Multiple Data (SIMD)**:In this model, we have a single
    instruction stream and multiple data streams. The same instruction stream is applied
    to multiple data streams in parallel. This is handy in speculative-approach scenarios
    where we have multiple algorithms for data and we don''t know which one will be
    faster. It provides the same input to all the algorithms and runs them in parallel
    on multiple processors.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单指令，多数据（SIMD）**：在这种模型中，我们有一个单一的指令流和多个数据流。相同的指令流并行应用于多个数据流。这在猜测性方法的场景中很方便，其中我们有多个数据的多个算法，我们不知道哪一个会更快。它为所有算法提供相同的输入，并在多个处理器上并行运行它们。'
- en: '**Multiple Instructions, Single Data (MISD)**:In this model, multiple instructions
    operate on one data stream. Therefore, multiple operations can be applied in parallel
    on the same data source. This is generally used for fault tolerance and in space
    shuttle flight control computers.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多指令，单数据（MISD）**：在这种模型中，多个指令在一个数据流上操作。因此，可以并行地在相同的数据源上应用多个操作。这通常用于容错和航天飞行控制计算机。'
- en: '**Multiple Instructions, Multiple Data (MIMD)**:In this model, as the name
    suggests, we have multiple instruction streams and multiple data streams. Due
    to this, we can achieve true parallelism, where each processor can run different
    instructions on different data streams. Nowadays, this architecture is used by
    most computer systems.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多指令，多数据（MIMD）**：在这种模型中，正如名称所示，我们有多个指令流和多个数据流。因此，我们可以实现真正的并行，其中每个处理器可以在不同的数据流上运行不同的指令。如今，大多数计算机系统都使用这种架构。'
- en: Now that we've covered the basics, let's move our discussion to threads.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基础知识，让我们把讨论转移到线程上。
- en: Threads
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: A thread is a unit of execution inside a process. At any point, a program may
    consist of one or more threads for better performance. GUI-based Windows applications,
    such as legacy **Windows Forms** (**WinForms**) or **Windows Presentation Foundation**
    (**WPF**), have a dedicated thread for managing the UI and handling user actions.
    This thread is also called the UI thread, or the **foreground thread**. It owns
    all the controls that are created as part of the UI.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Types of threads
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different types of managed threads, that is, a foreground thread
    and a background thread. The difference between these is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Foreground threads:** These have a direct impact on an application''s lifetime.
    The application keeps running until there is a foreground thread.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background threads:** These have no impact on the application''s lifetime.
    When the application exits, all the background threads are killed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application may comprise any number of foreground or background threads.
    While active, a foreground thread keeps the application running; that is, the
    application's lifetime depends on the foreground thread. The application stops
    completely when the last foreground thread is stopped or aborted. When the application
    exits, the system stops all the background threads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Apartment state
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important aspect of threads to understand is the apartment state. This
    is the area inside a thread where **Component Object Model** (**COM**) objects
    reside.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: COM is an object-oriented system for creating binary software that the user
    can interact with and is distributed and cross-platform. COM has been used to
    create Microsoft OLE and ActiveX technologies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may be aware, all Windows forms controls are wrapped over COM objects.
    Whenever you create a .NET WinForms application, you are actually hosting COM
    components. A thread apartment is a distinct area inside the application process
    where COM objects are created. The following diagram demonstrates the relationship
    between the thread apartment and COM objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91fa5328-4ca2-4cde-8046-b3246100b68a.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, every thread has thread apartments
    where COM objects reside.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'A thread can belong to one of two apartment states:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-Threaded Apartment** (**STA**):The underlying COM object can be accessed
    via a single thread only'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Threaded Apartment** (**MTA**):The underlying COM object can be accessed
    via multiple threads at a time'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list highlights some important points regarding thread apartment
    states:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Processes can have multiple threads, either foreground or background.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each thread can have one apartment, either STA or MTA.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every apartment has a concurrency model, either single-threaded or multithreaded.
    We can change the thread state programmatically as well.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application process may have more than one STA, but a maximum of one MTA.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of an STA application is a Windows application, and an example of
    an MTA application is a web application.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COM objects are created in apartments. One COM object can only lie in one thread
    apartment, and apartments cannot be shared.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An application can be forced to start in STA mode by using the `STAThread`
    attribute over the main methods. The following is an example of the `Main` method
    of a legacy WinForm:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `STAThread` attribute is also present in WPF but is hidden from users.
    The following is the code for the compiled `App.g.cs` class, which can be found
    in the `obj/Debug` directory of your WPF project after compilation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `Main` method is decorated with the `STAThread` attribute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel execution of code in .NET is achieved through multithreading. A process
    (or application) can utilize any number of threads, depending on its hardware
    capabilities. Every application, including console, legacy WinForms, WPF, and
    even web applications, is started by a single thread by default. We can easily
    achieve multithreading by creating more threads programmatically as and when they
    are required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中实现代码的并行执行是通过多线程实现的。一个进程（或应用程序）可以利用任意数量的线程，取决于其硬件能力。每个应用程序，包括控制台、传统的WinForms、WPF，甚至Web应用程序，默认情况下都是由单个线程启动的。我们可以通过在需要时以编程方式创建更多线程来轻松实现多线程。
- en: 'Multithreading typically functions using a scheduling component known as a **thread
    scheduler**, which keeps track of when a thread should run out of active threads
    inside a process. Every thread that''s created is assigned a `System.Threading.ThreadPriority`,
    which can have one of the following valid values. `Normal` is the default priority
    that''s assigned to any thread:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程通常使用称为**线程调度器**的调度组件来运行，该组件跟踪线程何时应该在进程内运行。创建的每个线程都被分配一个`System.Threading.ThreadPriority`，可以具有以下有效值之一。`Normal`是分配给任何线程的默认优先级：
- en: '`Highest`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最高`'
- en: '`AboveNormal`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AboveNormal`'
- en: '`Normal`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Normal`'
- en: '`BelowNormal`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BelowNormal`'
- en: '`Lowest`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lowest`'
- en: 'Every thread that runs inside a process is assigned a time slice by the OS
    based on the thread priority scheduling algorithm. Every OS can have a different
    scheduling algorithm for running threads, so the order of execution may vary in
    different operating systems. This makes it more difficult to troubleshoot threading
    errors. The most common scheduling algorithm is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程内运行的每个线程都根据线程优先级调度算法由操作系统分配一个时间片。每个操作系统可以有不同的运行线程的调度算法，因此在不同的操作系统中执行顺序可能会有所不同。这使得更难以排除线程错误。最常见的调度算法如下：
- en: Find the threads with the highest priority and schedule them to run.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到具有最高优先级的线程并安排它们运行。
- en: If there is more than one thread with the highest priority, each thread is assigned
    a fixed time slices in which they can execute.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有多个具有最高优先级的线程，则每个线程被分配固定的时间片段来执行。
- en: Once the highest-priority threads finish executing, the lower-priority threads
    start to be allocated to time slices in which it can begin executing.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦最高优先级的线程执行完毕，低优先级线程开始被分配时间片，可以开始执行。
- en: If a new highest-priority thread is created, low-priority threads are pushed
    back again.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果创建了一个新的最高优先级线程，则低优先级线程将再次被推迟。
- en: Time slicing refers to switching the execution between the active threads. It
    can vary, depending on the hardware configuration. A single-core processor machine
    can only run one thread at a time, so the thread scheduler carries out the time
    slicing. The time slice largely depends on the clock speed of the CPU, but there still aren't
    many performance gains that can be achieved via multithreading in such systems.
    Moreover, context switching comes with performance overheads. If the work that's
    allocated to a thread spans multiple time slices, then the thread needs to be
    switched in and out of memory. Every time it switches out, it needs to bundle
    and save its state (data) and reload it when it switches back in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 时间片切换是指在活动线程之间切换执行。它可以根据硬件配置而变化。单核处理器机器一次只能运行一个线程，因此线程调度器执行时间片切换。时间片的大小很大程度上取决于CPU的时钟速度，但在这种系统中仍然无法通过多线程获得很多性能提升。此外，上下文切换会带来性能开销。如果分配给线程的工作跨越多个时间片，那么线程需要在内存中切换进出。每次切换出时，它都需要捆绑和保存其状态（数据），并在切换回时重新加载。
- en: '**Concurrency** is a concept that''s primarily used in the context of multi-core
    processors. A multi-core processor has a higher number of CPUs available, as we
    discussed previously, and therefore different threads can be run simultaneously
    on different CPUs. A higher number of processors means a higher degree of concurrency.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是一个主要用于多核处理器的概念。多核处理器具有更多可用的CPU，因此不同的线程可以同时在不同的CPU上运行。更多的处理器意味着更高的并发度。'
- en: 'There are multiple ways that threads can be created in programs. These include
    the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中可以有多种方式创建线程。这些包括以下内容：
- en: The `Thread` class
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程类
- en: The `ThreadPool` Class
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池类
- en: The `BackgroundWorker` Class
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`类'
- en: Asynchronous delegates
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步委托
- en: TPL
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TPL
- en: We will cover asynchronous delegates and TPL in depth during the course of this
    book, but in this chapter, we will provide an explanation of the remaining three
    methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的过程中深入介绍异步委托和TPL，但在本章中，我们将解释剩下的三种方法。
- en: Thread class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类
- en: 'The simplest and easiest way of creating threads is via the `Thread` class,
    which is defined in the `System.Threading` namespace. This approach has been used
    since the arrival of .NET version 1.0 and it works with .NET core as well. To
    create a thread, we need to pass a method that the thread needs to execute. The
    method can either be parameter-less or parameterized. There are two delegates
    that are provided by the framework to wrap these functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的最简单和最简单的方法是通过`Thread`类，该类定义在`System.Threading`命名空间中。这种方法自.NET 1.0版本以来一直在使用，并且在.NET核心中也可以使用。要创建一个线程，我们需要传递一个线程需要执行的方法。该方法可以是无参数或带参数的。框架提供了两个委托来包装这些函数：
- en: '`System.Threading.ThreadStart`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.ThreadStart`'
- en: '`System.Threading.ParameterizedThreadStart`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.ParameterizedThreadStart`'
- en: 'We will learn both of these through examples. Before showing you how to create
    a thread, I will try to explain how a synchronous program works. Later on, we
    will introduce multithreading so that we understand the asynchronous way of execution.
    An example of *how to create a thread* is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过示例学习这两个概念。在向您展示如何创建线程之前，我将尝试解释同步程序的工作原理。之后，我们将介绍多线程，以便了解异步执行的方式。创建线程的示例如下：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, everything runs in the main thread. We have called the
    `PrintNumber10Times` method from within the `Main` method, and since the `Main`
    method is invoked by the main GUI thread, the code runs synchronously. This can
    cause unresponsive behavior if the code runs for a long time as the main thread
    will be busy during execution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，一切都在主线程中运行。我们从`Main`方法中调用了`PrintNumber10Times`方法，由于`Main`方法是由主GUI线程调用的，代码是同步运行的。如果代码运行时间很长，这可能会导致无响应的行为，因为主线程在执行期间将会很忙。
- en: 'The output of the code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![](img/74b9065b-8199-44b6-85ed-09d87800ba86.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74b9065b-8199-44b6-85ed-09d87800ba86.png)'
- en: 'In the following timeline, we can see that everything happens in the **Main
    Thread**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下时间表中，我们可以看到一切都发生在**主线程**中：
- en: '![](img/850babff-8666-46f4-b77e-93d4daf8b18e.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/850babff-8666-46f4-b77e-93d4daf8b18e.png)'
- en: The preceding diagram shows sequential code execution on the `Main` thread.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了在`Main`线程上的顺序代码执行。
- en: 'Now, we can make the program multithreaded by creating a thread to do the printing.
    The main thread prints the statements that are written in the `Main` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过创建一个线程来使程序成为多线程。主线程打印在`Main`方法中编写的语句：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have delegated the execution of `PrintNumber10Times()`
    to a new thread that has been created via the `Thread` class. The `Console.WriteLine`
    statements in the `Main` method are still executed via the main thread, but `PrintNumber10Times`
    is not called via the child thread.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经将`PrintNumber10Times()`的执行委托给了通过`Thread`类创建的新线程。`Main`方法中的`Console.WriteLine`语句仍然通过主线程执行，但`PrintNumber10Times`不是通过子线程调用的。
- en: The output of the code is as follows**:**
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下**：**
- en: '![](img/4d9fdc64-b6d5-4c8d-bb76-34205f269081.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d9fdc64-b6d5-4c8d-bb76-34205f269081.png)'
- en: 'The timeline for this process is as follows. You can see that `Console.WriteLine`
    executes on the **Main Thread** and that the loop executes on the **Child Thread**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的时间表如下。您可以看到`Console.WriteLine`在**主线程**上执行，而循环在**子线程**上执行：
- en: '![](img/bf617bfc-229f-469d-896c-c5b883ffd3c0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf617bfc-229f-469d-896c-c5b883ffd3c0.png)'
- en: The preceding diagram is an example of multithreaded execution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表是多线程执行的一个示例。
- en: If we compare the outputs, we can see that the program finishes everything in
    the main thread and then starts to print the number 10 times. The operations in
    this example are very small and thus work in a deterministic manner. If there
    are time-consuming statements in the main thread before **Finish Execution** is
    printed, however, the results can vary. We will look at how multithreading works
    and how it is related to CPU speed and numbers later on in this chapter in order
    to fully understand this idea.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较输出，我们可以看到程序在主线程中完成所有操作，然后开始打印数字10次。在这个例子中，操作非常小，因此以确定的方式工作。然而，如果在**完成执行**被打印之前，主线程中有耗时的语句，结果可能会有所不同。我们将在本章后面详细了解多线程的工作原理以及它与CPU速度和数字的关系，以充分理解这个概念。
- en: 'Here is another example to show you how to pass data to the thread using the `System.Threading.ParameterizedThreadStart` delegate:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个示例，向您展示如何使用`System.Threading.ParameterizedThreadStart`委托将数据传递给线程：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of the preceding code is as follows**:**
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下**：**
- en: '![](img/ca3f74e9-6fa1-47f9-9920-7544030afeb1.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca3f74e9-6fa1-47f9-9920-7544030afeb1.png)'
- en: Using the `Thread` class has some advantages and disadvantages. Let's try to
    understand them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Thread`类有一些优点和缺点。让我们试着理解它们。
- en: Advantages and disadvantages of threads
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的优缺点
- en: 'The `Thread` class has the following advantages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类具有以下优点：'
- en: Threads can be utilized to free up the main thread.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可用于释放主线程。
- en: Threads can be used to break up a task into smaller units that can be executed
    concurrently.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可用于将任务分解为可以并发执行的较小单元。
- en: 'The `Thread` class has the following disadvantages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类具有以下缺点：'
- en: With more threads, the code becomes difficult to debug and maintain.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更多线程，代码变得难以调试和维护。
- en: Thread creation puts a load on the system in terms of memory and CPU resources.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建会在内存和CPU资源方面对系统造成负担。
- en: We need to do exception handling inside the worker method as any unhandled exceptions
    can result in the program crashing.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在工作方法内部进行异常处理，因为任何未处理的异常都可能导致程序崩溃。
- en: The ThreadPool class
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池类
- en: Thread creation is an expensive operation in terms of both memory and CPU resources.
    On average, every thread consumes around 1 MB of memory and a few hundred microseconds
    of CPU time. Application performance is a relative concept, so it will not necessarily
    improve by creating a large number of threads. Conversely, creating a large number
    of threads can sometimes decrease application performance drastically. We should
    always aim to create an optimal number of threads, depending on the target system's
    CPU load, that is, other programs running on the system. This is because every
    program gets a time slice by the CPU, which is then distributed among the threads
    inside the application. If you create too many threads, they may not be able to
    do any constructive work before being swapped out of memory to give the time slice
    other similar-priority threads.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建在内存和CPU资源方面是昂贵的操作。平均而言，每个线程消耗大约1 MB的内存和几百微秒的CPU时间。应用程序性能是一个相对的概念，因此通过创建大量线程不一定会提高性能。相反，创建大量线程有时可能会严重降低应用程序性能。我们应该始终根据目标系统的CPU负载，即系统上运行的其他程序，来创建一个最佳数量的线程。这是因为每个程序都会获得CPU的时间片，然后将其分配给应用程序内部的线程。如果创建了太多线程，它们可能无法在被换出内存之前完成任何有益的工作，以便将时间片给其他具有相似优先级的线程。
- en: Finding the optimal number of threads can be tricky as it can vary from one
    system to another, depending on the configuration and the number of applications
    that are running concurrently on the system. What may be an optimal number on
    one system may cause a negative impact on another. Rather than finding the optimal
    number of threads ourselves, we can leave it to the **Common Language Runtime**
    (**CLR**). The CLR has an algorithm to determine the optimal number based on the
    CPU load at any point in time. It maintains a pool of threads, known as the `ThreadPool`.
    The `ThreadPool` resides in a process and each application has its own pool of
    threads. The advantage of thread pooling is that it maintains an optimal number
    of threads and assigns them to a task. When the work is finished, the threads
    are returned to the pool, where they can be assigned to the next work item, thereby
    preventing the cost of creating and destroying threads.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最佳线程数可能会很棘手，因为它可能因系统配置和同时在系统上运行的应用程序数量而异。在一个系统上可能是最佳数量的东西可能会对另一个系统产生负面影响。与其自己找到最佳线程数，不如将其留给**公共语言运行时**（**CLR**）。CLR有一个算法来确定基于任何时间点的CPU负载的最佳数量。它维护一个线程池，称为`ThreadPool`。`ThreadPool`驻留在一个进程中，每个应用程序都有自己的线程池。线程池的优势在于它维护了一个最佳数量的线程，并将它们分配给一个任务。当工作完成时，线程将返回到池中，可以分配给下一个工作项，从而避免创建和销毁线程的成本。
- en: 'The following is a list of the optimal number of threads that can be created
    in different frameworks inside `ThreadPool`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`ThreadPool`中可以创建的不同框架内的最佳线程数列表：
- en: 25 per core in .NET Framework 2.0
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 2.0中每核25个
- en: 250 per core in .NET Framework 3.5
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 3.5中每核250个
- en: 1,023 in .NET Framework 4.0 in a 32-bit environment
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在32位环境中的.NET Framework 4.0中为1,023
- en: 32,768 in .NET Framework 4.0 onward, as well as in .NET core in a 64-bit environment
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 4.0及以后版本中每核32,768个，以及64位环境中的.NET core
- en: While working with an investment bank, we came across a scenario where a trade process
    was taking almost 1,800 seconds to book close to 1,000 trades synchronously. After
    trying various optimal numbers, we finally switched to `ThreadPool` and made the
    process multithreaded. With .NET Framework version 2.0, the application finished
    in close to 72 seconds. With version 3.5, the same application finished in just
    a few seconds. This is a typical example of using the framework that's been provided
    rather than reinventing the wheel. You can get much-needed performance gains just
    by updating the framework.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在与投资银行合作时，我们遇到了一个场景，一个交易流程几乎需要1,800秒来同步预订近1,000笔交易。在尝试了各种最佳数量后，我们最终切换到`ThreadPool`并使流程多线程化。使用.NET
    Framework 2.0版本，应用程序在接近72秒内完成。使用3.5版本，同一应用程序在几秒内完成。这是一个典型的例子，使用提供的框架而不是重新发明轮子。通过更新框架，您可以获得所需的性能提升。
- en: We can create a thread via `ThreadPool` by calling `ThreadPool.QueueUserWorkItem`,
    as shown in the following example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`ThreadPool.QueueUserWorkItem`来通过`ThreadPool`创建一个线程，如下例所示。
- en: 'Here is the method that we want to call in parallel:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要并行调用的方法：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how we can create a thread using `ThreadPool.QueueUserWorkItem` while
    passing the `WaitCallback` delegate:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`ThreadPool.QueueUserWorkItem`创建一个线程，同时传递`WaitCallback`委托：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is a call from the `Main` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Main`方法中的一个调用：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/e4f970e1-5ed9-4167-8849-cdd81c5faf05.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4f970e1-5ed9-4167-8849-cdd81c5faf05.png)'
- en: 'Every thread pool maintains a minimum and a maximum number of threads. These
    values can be modified by calling the following static methods:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程池都维护最小和最大线程数。可以通过调用以下静态方法来修改这些值：
- en: '`ThreadPool.SetMinThreads`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPool.SetMinThreads`'
- en: '`ThreadPool.SetMaxThreads`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPool.SetMaxThreads`'
- en: A thread is created via `System.Threading`. The `Thread` class doesn't belong
    to the `ThreadPool`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`System.Threading`创建一个线程。`Thread`类不属于`ThreadPool`。
- en: Let's take a look at the advantages and disadvantages associated with using
    the `ThreadPool` class and when to avoid using it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`ThreadPool`类的优点和缺点以及何时避免使用它。
- en: Advantages, disadvantages, and when to avoid using ThreadPool
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点、缺点以及何时避免使用ThreadPool
- en: 'The advantages of the `ThreadPool` are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`的优点如下：'
- en: Threads can be utilized to free up the main thread.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以用来释放主线程。
- en: Threads are created and maintained in an optimal way by CLR.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程由CLR以最佳方式创建和维护。
- en: 'The disadvantages of the `ThreadPool` are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`的缺点如下：'
- en: With more threads, the code becomes difficult to debug and maintain.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着线程数量的增加，代码变得难以调试和维护。
- en: We need to do exception handling inside the worker method as any unhandled exception
    can result in the program crashing.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在工作方法内部进行异常处理，因为任何未处理的异常都可能导致程序崩溃。
- en: Progress reporting, cancellations, and completion logic need to be written from
    scratch.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要从头开始编写进度报告、取消和完成逻辑。
- en: 'The following are the reasons when we should avoid `ThreadPool`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应该避免使用`ThreadPool`的原因：
- en: When we need a foreground thread.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要一个前台线程时。
- en: When we need to set an explicit priority to a thread.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要为线程设置显式优先级时。
- en: When we have long-running or blocking tasks. Having a large number of blocked
    threads in the pool will prevent new tasks from starting due to the limited number
    of threads that are available per process in `ThreadPool`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们有长时间运行或阻塞的任务时。在池中有大量阻塞的线程将阻止新任务启动，因为`ThreadPool`中每个进程可用的线程数量有限。
- en: If we need STA threads since `ThreadPool` threads are MTA by default.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要STA线程，因为`ThreadPool`线程默认为MTA。
- en: If we need to dedicate a thread to a task by providing it a distinct identity
    since we cannot name a `ThreadPool` thread.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要为任务分配一个独特的标识来专门提供一个线程，因为我们无法为`ThreadPool`线程命名。
- en: BackgroundWorker
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BackgroundWorker
- en: '`BackgroundWorker` is a construct provided by .NET to create more manageable
    threads from a `ThreadPool`. When explaining  GUI-based applications, we saw that
    the `Main` method was decorated with the `STAThread` attribute. This attribute
    guarantees control safety as controls are created in the apartment owned by the
    thread and cannot be shared with other threads. In Windows applications, there
    is the main thread of execution that owns the UI and controls, which is created
    when the application starts. It is responsible for accepting user inputs and painting
    or repainting the UI based on the actions of the user. For a great user experience,
    we should try to make the UI as thread-free as possible and delegate all time-consuming
    tasks to worker threads. Some common tasks that are usually assigned to worker
    threads are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`是.NET提供的一个构造，用于从`ThreadPool`创建更可管理的线程。在解释基于GUI的应用程序时，我们看到`Main`方法被装饰了`STAThread`属性。这个属性保证了控件的安全性，因为控件是在线程所拥有的单元中创建的，不能与其他线程共享。在Windows应用程序中，有一个主执行线程，它拥有UI和控件，这在应用程序启动时创建。它负责接受用户输入，并根据用户的操作来绘制或重新绘制UI。为了获得良好的用户体验，我们应该尽量使UI不受线程的影响，并将所有耗时的任务委托给工作线程。通常分配给工作线程的一些常见任务如下：'
- en: Downloading images from a server
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器下载图像
- en: Interacting with a database
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: Interacting with a filesystem
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: Interacting with web services
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Web服务交互
- en: Complex local computations
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的本地计算
- en: As you can see, most of these are **input/output** (**I/O**) operations. I/O
    operations are carried out by the CPU. The moment we call a piece of code that
    encapsulates an I/O operation, the execution is passed from the thread to the
    CPU, which performs the task. When it is complete, the result of the operation
    is returned to the caller thread. This period from passing the baton and receiving
    results is a period of inactivity for the thread as it just has to wait for the
    operation to complete. If this occurs in the main thread, the application becomes
    unresponsive. For this reason, it makes sense to delegate these tasks to the worker
    threads. There are still several challenges to overcome with regard to responsive
    applications. Let's look at an example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些大多数是**输入/输出**（**I/O**）操作。I/O操作由CPU执行。当我们调用封装I/O操作的代码时，执行从线程传递到CPU，CPU执行任务。当任务完成时，操作的结果将返回给调用线程。这段时间从传递权杖到接收结果是线程的无活动期，因为它只需等待操作完成。如果这发生在主线程中，应用程序将变得无响应。因此，将这些任务委托给工作线程是有意义的。在响应式应用程序方面仍然有一些挑战需要克服。让我们看一个例子。
- en: '**Case study**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例研究**：'
- en: We need to fetch data from a service that streams data. We would like to update
    the user with the percentage completion of work. Once the work is complete, we
    need to update the user with all the data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从流数据的服务中获取数据。我们希望更新用户工作完成的百分比。一旦工作完成，我们需要向用户更新所有数据。
- en: '**Challenges**:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**挑战**：'
- en: The service call takes time, so we need to delegate the call in a worker thread
    to avoid UI freeze.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务调用需要时间，因此我们需要将调用委托给工作线程，以避免UI冻结。
- en: '**Solution**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: '`BackgroundWorker` is a class provided in `System.ComponentModel` that can
    be used to create a worker thread utilizing `ThreadPool`, as we discussed previously.
    This means that it works in an efficient way. `BackgroundWorker` also supports
    progress reporting and cancellations, apart from notifying the result of the operation.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`是`System.ComponentModel`中提供的一个类，可以用来创建一个利用`ThreadPool`的工作线程，正如我们之前讨论的那样。这意味着它以一种高效的方式工作。`BackgroundWorker`还支持进度报告和取消，除了通知操作的结果。'
- en: 'This scenario can be further explained with the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以通过以下代码进一步解释：
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`BackgroundWorker` provides an abstraction over raw threads, which gives more
    control and options to the user. The best part about using `BackgroundWorker`
    is that it uses an **Event-Based Asynchronous Pattern** (**EAP**), which means
    it is able to interact with the code more efficiently than raw threads. The code
    is more or less self-explanatory. In order to raise progress reporting and cancellation
    events, you need to set the following properties to `true`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`提供了对原始线程的抽象，为用户提供了更多的控制和选项。使用`BackgroundWorker`的最好之处在于它使用了**基于事件的异步模式**（**EAP**），这意味着它能够比原始线程更有效地与代码交互。代码多多少少是不言自明的。为了引发进度报告和取消事件，您需要将以下属性设置为`true`：'
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You need to subscribe to the `ProgressChanged` event to receive progress, the `DoWork`
    event to pass a method that needs to be invoked by the thread, and the `RunWorkerCompleted` event
    to receive either the final results or any error messages from the thread''s execution:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要订阅`ProgressChanged`事件以接收进度，`DoWork`事件以传递需要由线程调用的方法，以及`RunWorkerCompleted`事件以接收线程执行的最终结果或任何错误消息：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once this has been set up, you can invoke the worker by calling the following
    command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这些之后，您可以通过调用以下命令来调用工作线程：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At any point in time, you can cancel the execution of the thread by calling
    the `backgroundWorker.CancelAsync()` method, which sets the `CancellationPending`
    property on the worker thread. We need to write some code that keeps checking
    this flag and exits gracefully.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，您都可以通过调用`backgroundWorker.CancelAsync()`方法来取消线程的执行，这会在工作线程上设置`CancellationPending`属性。我们需要编写一些代码来不断检查这个标志，并优雅地退出。
- en: 'If there are no exceptions, the result of the thread''s execution can be returned
    to the caller by setting the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有异常，线程执行的结果可以通过设置以下内容返回给调用者：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If there are any unhandled exceptions in the program, they are returned to the
    caller gracefully. We can do this by wrapping it into `RunWorkerCompletedEventArgs`
    and passing it as a parameter to the `RunWorkerCompleted` event handler.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序中有任何未处理的异常，它们会被优雅地返回给调用者。我们可以通过将其包装成`RunWorkerCompletedEventArgs`并将其作为参数传递给`RunWorkerCompleted`事件处理程序来实现这一点。
- en: We will look at the advantages and disadvantages of using `BackgroundWorker`
    in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论使用`BackgroundWorker`的优缺点。
- en: Advantages and disadvantages of using BackgroundWorker
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BackgroundWorker的优缺点
- en: 'The advantages of using `BackgroundWorker` are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`的优点如下：
- en: Threads can be utilized to free up the main thread.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以用来释放主线程。
- en: Threads are created and maintained in an optimal way by the `ThreadPool` class's
    CLR.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程由`ThreadPool`类的CLR以最佳方式创建和维护。
- en: Graceful and automatic exception handling.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅和自动的异常处理。
- en: Supports progress reporting, cancellation, and completion logic using events.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件支持进度报告、取消和完成逻辑。
- en: The disadvantage of using `BackgroundWorker` is that, with more threads, the
    code becomes difficult to debug and maintain.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`的缺点是，使用更多线程后，代码变得难以调试和维护。
- en: Multithreading versus multitasking
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程与多任务处理
- en: 'We have seen how both multithreading and multitasking work. Both have advantages
    and disadvantages and you can use either, depending on your specific use case.
    The following are some examples where multithreading can come in handy:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了多线程和多任务处理的工作原理。两者都有优缺点，您可以根据具体的用例选择使用。以下是一些多线程可能有用的示例：
- en: '**If you need a system that is easy to set up and terminate**: Multithreading
    can be useful when you have a process that has a large overhead. With threads,
    all you need to do is copy the thread stack. Creating a duplicate process, however,
    means recreating the entire data process in a separate memory space.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您需要一个易于设置和终止的系统**：当您有一个具有大量开销的进程时，多线程可能很有用。使用线程，您只需复制线程堆栈。然而，创建一个重复的进程意味着在单独的内存空间中重新创建整个数据过程。'
- en: '**If you require fast task switching**: The CPU caches and program context
    can be easily maintained between threads in a process. If you have to switch the
    CPU to a different process, however, it has to be reloaded.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您需要快速任务切换**：在进程中，CPU缓存和程序上下文可以在线程之间轻松维护。然而，如果必须将CPU切换到另一个进程，它必须重新加载。'
- en: '**If you need to share data with other threads**:All the threads inside a process
    share the same memory pool, which makes it easier for them to share data to compare
    processes. If processes want to share data, they need I/O operation and transport
    protocols, which is expensive.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您需要与其他线程共享数据**：进程内的所有线程共享相同的内存池，这使它们更容易共享数据以比较进程。如果进程想要共享数据，它们需要I/O操作和传输协议，这是昂贵的。'
- en: In this section, we have discussed the basics of multithreading and multitasking,
    alongside various approaches that were used to create threads in older versions
    of .NET. In the next section, we will try to understand some scenarios where you
    can utilize parallel programming techniques.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了多线程和多任务处理的基础知识，以及在较早版本的.NET中用于创建线程的各种方法。在下一节中，我们将尝试了解一些可以利用并行编程技术的场景。
- en: Scenarios where parallel programming can come in handy
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程可能有用的场景
- en: 'The following are the scenarios in which parallel programming can be useful:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是并行编程可能有用的场景：
- en: '**Creating a responsive UI for GUI-based applications**:We can delegate all
    of the heavy lifting and time-consuming tasks to the worker thread, thereby allowing
    the UI thread to process user interactions and the UI repainting tasks.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为基于GUI的应用程序创建响应式UI**：我们可以将所有繁重和耗时的任务委托给工作线程，从而允许UI线程处理用户交互和UI重绘任务。'
- en: '**Processing simultaneous requests**:In server-side programming scenarios,
    we need to process a large number of concurrent users. We can create a separate
    thread to process each request. For example, we can use an ASP.NET request model,
    which makes use of `ThreadPool` and assigns a thread to every request that hits
    the server. Then, the thread takes care of processing the request and returning
    a response to the client. In a client-side scenario, we can call multiple mutually
    exclusive API calls via multithreading to save time.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理同时请求**：在服务器端编程场景中，我们需要处理大量并发用户。我们可以创建一个单独的线程来处理每个请求。例如，我们可以使用`ThreadPool`和为命中服务器的每个请求分配一个线程的ASP.NET请求模型。然后，线程负责处理请求并向客户端返回响应。在客户端场景中，我们可以通过多线程调用多个互斥的API调用来节省时间。'
- en: '**Making efficient use of CPU**:With multi-core processors, only one core is
    generally utilized without multithreading and is overburdened. We can make full
    use of CPU resources by creating multiple threads, each running on separate CPUs.
    Sharing the burden in this way results in improved performance. This is useful
    for long-running and complex calculations, which can be performed faster using
    a divide-and-conquer strategy.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**充分利用CPU资源**：使用多核处理器时，如果不使用多线程，通常只有一个核被利用，而且负担过重。通过创建多个线程，每个线程在单独的CPU上运行，我们可以充分利用CPU资源。以这种方式分享负担会提高性能。这对于长时间运行和复杂计算非常有用，可以通过分而治之的策略更快地执行。'
- en: '**Speculative approaches**:Scenarios involving more than one algorithm, such
    as for an input set of numbers, where we want to get a sorted set as quickly as
    possible. The only way to do this is to pass the input to all the algorithms and
    run them in parallel, and whichever finishes first is accepted, while the rest
    are canceled.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推测性方法**：涉及多个算法的场景，例如对一组数字进行排序，我们希望尽快获得排序好的集合。唯一的方法是将输入传递给所有算法并并行运行它们，先完成的算法被接受，而其余的被取消。'
- en: Advantages and disadvantages of parallel programming
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程的优缺点
- en: Multithreading leads to parallelism, which has its own programming and pitfalls.
    Now that we have grasped the basic concepts of parallel programming, it is important
    to understand its advantages and disadvantages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程导致并行性，具有自己的编程和缺陷。现在我们已经掌握了并行编程的基本概念，了解其优缺点非常重要。
- en: 'The following are the benefits of parallel programming:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程的好处：
- en: '**Enhanced performance**: We can achieve better performance since tasks are
    distributed across threads that run in parallel.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：由于任务分布在并行运行的线程中，我们可以实现更好的性能。'
- en: '**Improved GUI responsiveness**: Since tasks perform non-blocking I/O, this
    means the GUI thread is always free to accept user inputs. This results in better
    responsiveness.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的GUI响应性**：由于任务执行非阻塞I/O，这意味着GUI线程始终空闲以接受用户输入。这会导致更好的响应性。'
- en: '**The simultaneous and parallelized occurrence of tasks**: Since tasks run
    in parallel, we can simultaneously run different programming logic.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务的同时和并行发生**：由于任务并行运行，我们可以同时运行不同的编程逻辑。'
- en: Better use of cache storage by utilizing resources and better use of CPU resources.
    Tasks can run on different cores, thereby ensuring maximizing throughput.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用资源更好地使用缓存存储和更好地利用CPU资源。任务可以在不同的核心上运行，从而确保最大化吞吐量。
- en: 'Parallel programming also has the following disadvantages:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程也有以下缺点：
- en: '**Complex debugging and testing processes**: It''s not easy to debug threads
    without good multithreading tool support as different threads runs in parallel.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的调试和测试过程**：没有良好的多线程工具支持，调试线程不容易，因为不同的线程并行运行。'
- en: '**Context switching overheads**: Every thread works on a slice of time that''s
    been allocated to it. Once the time slice expires, context switching happens,
    which also wastes resources.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文切换开销**：每个线程都在分配给它的时间片上工作。一旦时间片到期，就会发生上下文切换，这也会浪费资源。'
- en: '**High chance of deadlock occurrence**: If multiple threads work on a shared
    resource, we need to apply locks to achieve thread-safety. This can lead to deadlocks
    if multiple threads are simultaneously locking and waiting for shared resources.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁发生的机会很高**：如果多个线程在共享资源上工作，我们需要应用锁来实现线程安全。如果多个线程同时锁定并等待共享资源，这可能导致死锁。'
- en: '**Difficult to program**: With code branching, parallel programs can be difficult
    to write compared to synchronous versions.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程困难**：与同步版本相比，使用代码分支，并行程序可能更难编写。'
- en: '**Unpredictable results**: Since parallel programming relies on CPU cores,
    we can get different results on different configuration machines.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果不可预测**：由于并行编程依赖于CPU核心，因此在不同配置的机器上可能会得到不同的结果。'
- en: We should always understand that parallel programming is a relative concept
    and that something that worked for others may or may not work for you. You are
    advised to implement this approach and validate it yourself.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终明白并行编程是一个相对的概念，对别人有效的方法未必对你有效。建议你实施这种方法并自行验证。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the scenarios, benefits, and pitfalls of parallel
    programming. Computer systems have evolved over the last few decades from single-core
    processors to multi-core processors. The hardware in chips has become HT-enabled,
    thereby increasing the performance of modern systems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了并行编程的场景、好处和陷阱。计算机系统在过去几十年里从单核处理器发展到多核处理器。芯片中的硬件已经启用了HT，从而提高了现代系统的性能。
- en: Before embarking on your journey in parallel programming, it's a good idea to
    understand the basic concepts related to the OS, such as processes, tasks, and
    the difference between multithreading and multitasking.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始并行编程之前，了解与操作系统相关的基本概念，如进程、任务以及多线程和多任务之间的区别，是一个好主意。
- en: In the next chapter, we will focus our discussion entirely on the TPL and its
    associated implementations. In the real world, however, there is a lot of legacy
    code that still relies on older constructs, so knowledge of these will be handy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完全专注于TPL及其相关实现的讨论。然而，在现实世界中，仍然有很多依赖于旧构造的遗留代码，因此对这些代码的了解将会很有用。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Multithreading is a superset of parallel programming.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多线程是并行编程的一个超集。
- en: 'True'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: How many cores will there be in a single-processor dual-core machine with hyper-threading
    enabled?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用超线程的单处理器双核机器上会有多少个核心？
- en: '2'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '2'
- en: '4'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '4'
- en: '8'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8'
- en: When an application exits, all the foreground threads are killed as well. There
    is no separate logic required to close foreground threads on an application's
    exit.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序退出时，所有前台线程也会被终止。在应用程序退出时不需要单独的逻辑来关闭前台线程。
- en: 'True'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Which exception is thrown when a thread has tried to access controls it has
    not owned/created?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当线程尝试访问它没有拥有/创建的控件时会抛出哪个异常？
- en: '`ObjectDisposedException`'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ObjectDisposedException`'
- en: '`InvalidOperationException`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InvalidOperationException`'
- en: '`CrossThreadException`'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CrossThreadException`'
- en: Which of these provides cancellation support and progress reporting?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个提供了取消支持和进度报告？
- en: '`Thread`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`线程`'
- en: '`BackgroundWorker`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`'
- en: '`ThreadPool`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThreadPool`'

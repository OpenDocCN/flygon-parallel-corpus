- en: Task Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务并行性
- en: In the previous chapter, we introduced the concept of parallel programming.
    In this chapter, we will move on to discussing TPL and task parallelism.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了并行编程的概念。在本章中，我们将继续讨论TPL和任务并行性。
- en: One of the major goals of .NET as a programming framework is to make a developer's
    life easier by wrapping up all the commonly required tasks as APIs. As we have
    already seen, threads have existed since the earliest versions of .NET, but they
    were initially very complex and were associated with a lot of overhead. Microsoft
    has introduced a lot of new parallel primitives that make it easier to write,
    debug, and maintain parallel programs from scratch, without having to deal with
    the complexities that are involved with legacy threading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: .NET作为一个编程框架的主要目标之一是通过将所有常见的任务封装为API来使开发人员的生活更轻松。正如我们已经看到的，线程自.NET的早期版本以来就存在，但最初它们非常复杂，并且伴随着很多开销。微软引入了许多新的并行原语，使得从头开始编写、调试和维护并行程序变得更加容易，而无需处理与传统线程相关的复杂性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating and starting a task
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和启动任务
- en: Getting results from finished tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从已完成的任务获取结果
- en: How to cancel tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何取消任务
- en: How to wait on running tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何等待运行任务
- en: Handling task exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理任务异常
- en: Converting **Asynchronous Programming Model** (**APM**) patterns into tasks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**异步编程模型**（**APM**）模式转换为任务
- en: Converting **Event-Based Asynchronous Patterns** (**EAPs**) into tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**基于事件的异步模式**（**EAPs**）转换为任务
- en: 'More on tasks:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于任务的内容：
- en: Continuation tasks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续任务
- en: Parent and child tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父任务和子任务
- en: Local and global queues and storage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地和全局队列和存储
- en: Work-stealing queues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作窃取队列
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you should have a good understanding of C# and some
    advanced concepts such as delegates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您应该对C#和一些高级概念（如委托）有很好的理解。
- en: The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter02)。
- en: Tasks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: '**Tasks** are abstractions in .NET that provide units of asynchrony, just like
    promises in JavaScript. In initial versions of .NET, we had to rely on threads
    only, which were created either directly or using the `ThreadPool` class. The
    `ThreadPool` class provided a managed abstraction layer over threads but developers still relied
    on the `Thread` class for better control. By creating a thread via the `Thread`
    class, we gained access to the underlying object, which we can wait for, cancel,
    or move to the foreground or background. In real time, however, we required threads
    to perform work continuously. This required us to write lots of code, which was
    difficult to maintain. The `Thread` class was also unmanaged, which put a high
    burden on both the memory and the CPU. We needed the best of both worlds, which
    is where tasks come to the rescue. A task is nothing but a wrapper over a thread,
    which is created via `ThreadPool`. Tasks provide features such as await, cancellation,
    and continuation, and these run after a task has finished.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务**是.NET中提供异步单元的抽象，就像JavaScript中的promise一样。在.NET的初始版本中，我们只能依赖于线程，这些线程是直接创建或使用`ThreadPool`类创建的。`ThreadPool`类提供了对线程的托管抽象层，但开发人员仍然依赖于`Thread`类来获得更好的控制。通过使用`Thread`类创建线程，我们可以获得底层对象，可以等待、取消或移动到前台或后台。然而，在实时中，我们需要线程持续执行工作。这要求我们编写大量难以维护的代码。`Thread`类也是不受管理的，这对内存和CPU都造成了很大的负担。我们需要两全其美，这就是任务的用武之地。任务只是通过`ThreadPool`创建的线程的包装器。任务提供了等待、取消和继续等功能，这些功能在任务完成后运行。'
- en: 'Tasks have the following important features:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任务具有以下重要特点：
- en: Tasks are executed by a `TaskScheduler` and the default scheduler simply runs
    on `ThreadPool`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务由`TaskScheduler`执行，默认调度程序简单地在`ThreadPool`上运行。
- en: We can return values from tasks.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从任务中返回值。
- en: Tasks let you know when they finish, unlike `ThreadPool` or threads.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务让您知道它们何时完成，不像`ThreadPool`或线程。
- en: A task can be run in continuation using the `ContinueWith()` construct.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`ContinueWith()`构造来运行任务的后续任务。
- en: We can wait on tasks by calling `Task.Wait()`. This blocks the calling thread
    until it has finished.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`Task.Wait()`来等待任务。这会阻塞调用线程，直到任务完成为止。
- en: Tasks make the code much more readable compared to legacy threads or `ThreadPool`.
    They also paved the way to the introduction of the asynchronous programming construct
    in C# 5.0.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与传统线程或`ThreadPool`相比，任务使代码更易读。它们还为引入C# 5.0中的异步编程构造铺平了道路。
- en: We can establish a parent/child relationship when one task is started from another
    task.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个任务从另一个任务启动时，我们可以建立父/子关系。
- en: We can propagate child task exceptions to parent tasks.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将子任务的异常传播到父任务。
- en: A task can be canceled using the `CancellationToken` class.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`CancellationToken`类取消任务。
- en: Creating and starting a task
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和启动任务
- en: 'There are many ways in which we can create and run a task using the TPL. In
    this section, we will try to understand all of these approaches and do a comparative
    analysis wherever we can. First, you need to add a reference to the `System.Threading.Tasks`
    namespace:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用TPL的许多方法来创建和运行任务。在本节中，我们将尝试理解所有这些方法，并在可能的情况下进行比较分析。首先，您需要向`System.Threading.Tasks`命名空间添加引用：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will try to create a task using the following approaches:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用以下方法创建任务：
- en: The `System.Threading.Tasks.Task` class
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task`类'
- en: The `System.Threading.Tasks.Task.Factory.StartNew` method
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.Factory.StartNew` 方法'
- en: The `System.Threading.Tasks.Task.Run` method
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.Run` 方法'
- en: '`System.Threading.Tasks.Task.Delay`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.Delay`'
- en: '`System.Threading.Tasks.Task.Yield`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.Yield`'
- en: '`System.Threading.Tasks.Task.FromResult<T> Method`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromResult<T>方法`'
- en: '`System.Threading.Tasks.Task.FromException` and `Task.FromException<T>`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromException`和`Task.FromException<T>`'
- en: '`System.Threading.Tasks.Task.FromCancelled` and `Task.FromCancelled<T>`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Task.FromCancelled`和`Task.FromCancelled<T>`'
- en: The System.Threading.Tasks.Task class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task类
- en: A task class is a way of executing work asynchronously as a `ThreadPool` thread
    and is based on the **Task-Based Asynchronous Pattern** (**TAP**). The non-generic `Task`
    class doesn't return results, so whenever we need to return values from a task,
    we need to use the generic version, `Task<T>`. The tasks that are created via
    the `Task` class are not scheduled to run until we call the `Start` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任务类是一种以`ThreadPool`线程异步执行工作的方式，它基于**基于任务的异步模式**（**TAP**）。非泛型的`Task`类不返回结果，所以每当我们需要从任务中返回值时，我们需要使用泛型版本`Task<T>`。通过`Task`类创建的任务直到我们调用`Start`方法才被安排运行。
- en: We can create a task using the `Task` class in various ways, all of which we'll
    cover in the following subsections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Task`类的各种方式创建一个任务，所有这些方式我们将在以下小节中讨论。
- en: Using lambda expressions syntax
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a lambda expression containing the method we want to execute:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的lambda表达式来创建一个任务：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the Action delegate
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a task by calling the `Task` constructor
    and passing a delegate containing the method we want to execute:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的delegate来创建一个任务：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using delegate
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `task` object by calling the `Task`
    constructor and passing an anonymous `delegate` containing the method we want
    to execute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过调用`Task`构造函数并传递包含我们要执行的方法的匿名`delegate`来创建一个`task`对象：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In all of these cases, the output will be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，输出将如下所示：
- en: '![](img/40ef715e-dff5-40e9-a0a0-acafb3317b7c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ef715e-dff5-40e9-a0a0-acafb3317b7c.png)'
- en: All the preceding methods do the same thing – they just have different syntaxes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的方法都是做同样的事情 - 它们只是有不同的语法。
- en: We can only call the `Start` method on tasks that have not run previously. If
    you need to rerun a task that has already been completed, you need to create a
    new task and call the `Start` method on that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能对以前未运行过的任务调用`Start`方法。如果您需要重新运行已经完成的任务，您需要创建一个新的任务并在其上调用`Start`方法。
- en: The System.Threading.Tasks.Task.Factory.StartNew method
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Factory.StartNew方法
- en: We can also create a task using the `StartNew` method of the `TaskFactory` class,
    as follows. In this approach, the task is created and scheduled for execution
    inside the `ThreadPool` and a reference of that `Task` is returned to the caller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`TaskFactory`类的`StartNew`方法创建一个任务，如下所示。在这种方法中，任务被创建并安排在`ThreadPool`内执行，并将该任务的引用返回给调用者。
- en: We can create a task using the `Task.Factory.StartNew` method. We'll go over
    this in the following subsections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Task.Factory.StartNew`方法创建一个任务。我们将在以下小节中讨论这个问题。
- en: Using lambda expressions syntax
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a lambda expression containing the method
    we want to execute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递包含我们要执行的方法的lambda表达式来创建一个`Task`：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Action delegate
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing a delegate wrapping method that we want to
    execute:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递包装我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using delegate
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `Task` by calling the `StartNew()`
    method on `TaskFactory` and passing the `delegate` wrapping method we want to
    execute:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`TaskFactory`上调用`StartNew()`方法并传递我们要执行的`delegate`包装方法来创建一个`Task`：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All the preceding methods do the same thing – they just have different syntaxes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的方法都是做同样的事情 - 它们只是有不同的语法。
- en: The System.Threading.Tasks.Task.Run method
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Run方法
- en: We can also create a task using the `Task.Run` method. This works just like
    the `StartNew` method and returns a `ThreadPool` thread.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`Task.Run`方法创建一个任务。这与`StartNew`方法的工作方式相同，并返回一个`ThreadPool`线程。
- en: We can create a `Task` using the `Task.Run` method in the following ways, all
    of which will be discussed in the following subsections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用`Task.Run`方法创建一个`Task`，所有这些方式将在以下小节中讨论。
- en: Using lambda expressions syntax
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式语法
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a lambda expression containing the method we want
    to execute:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的lambda表达式来创建一个`Task`：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the Action delegate
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Action delegate
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a delegate containing the method we want to execute:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using delegate
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用delegate
- en: 'In the following code, we are creating a `Task` by calling the static `Run()`
    method on `Task` and passing a `delegate` containing the method we want to execute:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们通过在`Task`上调用静态的`Run()`方法并传递包含我们要执行的方法的delegate来创建一个`Task`：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The System.Threading.Tasks.Task.Delay method
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Delay方法
- en: 'We can create a task that completes after a specified interval of time or that
    can be canceled at any time by the user using the `CancellationToken` class. In
    the past, we used the `Thread.Sleep()` method of the `Thread` class to create
    blocking constructs to wait on other tasks. The problem with this approach, however,
    was that it still used CPU resources and ran synchronously. `Task.Delay` provides
    a better alternative to waiting on tasks without utilizing CPU cycles. It also
    runs asynchronously:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个在指定时间间隔后完成或可以随时被用户取消的任务，使用`CancellationToken`类。过去，我们使用`Thread`类的`Thread.Sleep()`方法创建阻塞构造以等待其他任务。然而，这种方法的问题是它仍然使用CPU资源并且同步运行。`Task.Delay`提供了一个更好的等待任务的替代方法，而不利用CPU周期。它也是异步运行的：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code asks the user a question and then waits for two seconds before
    presenting the answer. During those two seconds, the main thread doesn't have
    to wait but has to carry out other tasks to improve the user's experience. The
    code runs asynchronously on the system clock and, once the time expires, the rest
    of the code is executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码询问用户一个问题，然后等待两秒钟才呈现答案。在这两秒钟内，主线程不必等待，但必须执行其他任务以改善用户体验。代码在系统时钟上异步运行，一旦时间到期，其余代码就会被执行。
- en: 'The output of the preceding code is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/e92b0ddd-683c-4c1f-92e9-6d9092ff30b0.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e92b0ddd-683c-4c1f-92e9-6d9092ff30b0.png)'
- en: 'Before looking at the other methods we can use to create a task, we''ll take
    a look at two asynchronous programming constructs that were introduced in C# 5.0:
    the `async` and `await` keywords.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们可以用来创建任务的其他方法之前，我们将看一下在C# 5.0中引入的两个异步编程构造：`async`和`await`关键字。
- en: '`async` and `await` are code markers that make it easier for us to write asynchronous
    programs. We will learn about these keywords in depth in [Chapter 9](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml),
    *Async, Await, and Task-Based Asynchronous Programming Basics**.* As the name
    suggests, we can wait on any asynchronous call using the `await` keyword. The
    moment the executing thread encounters the `await` keyword inside a method, it
    returns to `ThreadPool`, marks the rest of the method as a continuation delegate,
    and starts executing the other queued tasks. Once the asynchronous task finishes,
    any available thread from `ThreadPool` finishes the rest of the method.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`是代码标记，使我们更容易编写异步程序。我们将在[第9章](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml)中深入学习这些关键字，*异步、等待和基于任务的异步编程基础*。顾名思义，我们可以使用`await`关键字等待任何异步调用。一旦执行线程在方法内遇到`await`关键字，它就返回到`ThreadPool`，将方法的其余部分标记为继续委托，并开始执行其他排队的任务。一旦异步任务完成，`ThreadPool`中的任何可用线程都会完成方法的其余部分。'
- en: The System.Threading.Tasks.Task.Yield method
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.Yield方法
- en: 'This is another way of creating an `await` task. The underlying task is not
    directly accessible to the caller but is used in some scenarios involving asynchronous
    programming that are related to program execution. It is more like a promise than
    a task. Using `Task.Yield`, we can force our method to be asynchronous and return
    control to the OS. When the rest of the method executes at a later point in time,
    it may still run as asynchronous code. We can achieve the same effect using the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`await`任务的另一种方式。底层任务对调用者不直接可访问，但在涉及与程序执行相关的异步编程的某些场景中使用。它更像是一个承诺而不是一个任务。使用`Task.Yield`，我们可以强制我们的方法是异步的，并将控制返回给操作系统。当方法的其余部分在以后的时间点执行时，它可能仍然作为异步代码运行。我们可以使用以下代码实现相同的效果：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This approach can be used to make UI applications responsive by providing control
    to the UI thread from time to time inside long-running tasks. However, this is
    not the preferred approach for UI applications. There are better alternatives,
    which are available in the form of `Application.DoEvents()` in WinForms and `Dispatcher.Yield
    (DispatcherPriority.ApplicationIdle)` in WPF:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以通过在长时间运行的任务中不时地将控制权交给UI线程来使UI应用程序响应。然而，这不是UI应用程序的首选方法。有更好的替代方法，例如WinForms中的`Application.DoEvents()`和WPF中的`Dispatcher.Yield(DispatcherPriority.ApplicationIdle)`：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the case of console or web applications, when we run the code and apply a
    breakpoint on the task's yield, we will see random thread pool threads switching
    context to run the code. The following screenshots depict various threads controlling
    execution at various stages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台或Web应用程序的情况下，当我们运行代码并在任务的yield上应用断点时，我们会看到随机线程池线程切换上下文来运行代码。以下截图描述了各个阶段控制执行的各个线程。
- en: 'The following screenshot shows all the threads executing at the same time in
    the program flow. We can see that the current thread ID is 1664:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序流中所有线程同时执行。我们可以看到当前线程ID为1664：
- en: '![](img/5a633f20-226e-49d4-aa64-3d7f3ca6092d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a633f20-226e-49d4-aa64-3d7f3ca6092d.png)'
- en: 'If we press *F5* and allow the breakpoint to get hit for another value of `i`,
    we will see that the code is now being executed by another thread with an ID of 10244:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下*F5*并允许断点命中`i`的另一个值，我们会看到代码现在由ID为10244的另一个线程执行：
- en: '![](img/e7dd5bc6-0a11-4692-8ade-63a6fef19e9d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7dd5bc6-0a11-4692-8ade-63a6fef19e9d.png)'
- en: We will learn more about thread windows and debugging techniques in [Chapter
    11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing Unit Test Cases for
    Parallel and Asynchronous Code*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](86c487fc-641d-47e9-9270-e9d667bca405.xhtml)中学习更多关于线程窗口和调试技术，*为并行和异步代码编写单元测试用例*。
- en: The System.Threading.Tasks.Task.FromResult<T> method
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.Threading.Tasks.Task.FromResult<T>方法
- en: 'This approach, which was introduced recently in .NET framework 4.5, is very
    much underrated. We can return a completed task with results via this approach,
    as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是最近在.NET框架4.5中引入的，它非常被低估。我们可以通过这种方法返回带有结果的完成任务，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the preceding code, we have actually converted a synchronous
    `Sum` method to return results in an asynchronous manner using the `Task.FromResult<int>`
    class. This approach is frequently used in TDD for mocking asynchronous methods,
    as well as inside asynchronous methods to return default values based on conditions.
    We will explain these approaches in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code**.*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromException and System.Threading.Tasks.Task.FromException<T>
    methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods create tasks that have completed with a predefined exception
    and are used to throw exceptions from asynchronous tasks, as well as in TDD. We
    will explain this approach further in [Chapter 11](86c487fc-641d-47e9-9270-e9d667bca405.xhtml), *Writing
    Unit Test Cases for Parallel and Asynchronous Code*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the preceding code, we are wrapping `FileNotFoundException`
    as a task and returning it to the caller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The System.Threading.Tasks.Task.FromCanceled and System.Threading.Tasks.Task.FromCanceled<T>
    methods
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods are used to create tasks that have completed as a result of cancellation
    via the cancellation token:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the preceding code, we created a cancellation token using the `CancellationTokenSource`
    class. Then, we created a task from that token. The important thing to consider
    here is that the token needs to be canceled before we can use it with the `Task.FromCanceled`
    method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful if we want to return values from asynchronous methods,
    as well as in TDD.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Getting results from finished tasks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To return values from tasks, TPL provides a generic variant of all of the classes
    that we defined previously:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`Task<T>`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Factory.StartNew<T>`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Run<T>`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a task finishes, we should be able to get results from it by accessing
    the `Task.Result` property. Let''s try to understand this using some code examples.
    We will create various tasks and try to return values from them on completion:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding code, we have created tasks using generic variants.
    Once they finished, we were able to get the results using the result property:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc4ef585-380d-4bed-82c2-49d3ea97a72a.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn about how we can cancel tasks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How to cancel tasks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important function of the TPL is to equip developers with ready-made
    data structures to cancel running tasks. Those of you that have a classic threading
    background will be aware of how difficult it used to be to make threads support
    canceling with all the custom home-grown logic, but this is no longer the case.
    The .NET Framework provides two classes to support task cancellation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationTokenSource`**: **This class is responsible for creating cancellation
    tokens and passing the cancellation request to all the tokens that were created
    via the source'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancellationToken`**: **This class is used by listeners to monitor the current
    state of a request'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create tasks that can be canceled, we need to perform the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `System.Threading.CancellationTokenSource` class,
    which further provides a `System.Threading.CancellationToken` via the `Token Property`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the token while creating the task.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When required, call the `Cancel()` method on the `CancellationTokenSource`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to understand how to create a token and how to pass it to the task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating a token
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tokens can be created using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we created a `tokenSource` using the `CancellationTokenSource` constructor.
    Then, we got our token using the token property of **`tokenSource`**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task using tokens
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a task by passing `CancellationToken` as the second argument
    to the task constructor, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the classic threading model, we used to call the `Abort()` method on a thread
    that was non-deterministic. This would stop the thread abruptly, thereby leaking
    memory if resources were unmanaged. With TPL, we can call the `Cancel` method,
    which is a cancellation token source that will, in turn, set up the `IsCancellationRequested`
    property on the token. The underlying method that's being executed by the task
    should watch for this property and should exit gracefully if it is set.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的线程模型中，我们曾经在非确定性的线程上调用`Abort()`方法。这会突然停止线程，从而导致资源未受管理时内存泄漏。使用TPL，我们可以调用`Cancel`方法，这是一个取消令牌源，将进而在令牌上设置`IsCancellationRequested`属性。任务执行的底层方法应该监视此属性，并且如果设置了，应该优雅地退出。
- en: 'There are various ways of keeping a watch of whether the token source has requested
    a cancellation:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以监视令牌源是否请求了取消：
- en: Polling the status of the `IsCancellationRequested` property on the token
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过轮询令牌的`IsCancellationRequested`属性的状态
- en: Registering for a request cancellation callback
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册请求取消回调
- en: Polling the status of the token via the IsCancellationRequested property
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过轮询令牌的状态来检查`IsCancellationRequested`属性
- en: This approach is handy in scenarios that involve recursive methods or methods
    that contain long-running computational logic via loops. Within our method or
    loops, we write code that polls `IsCancellationRequested` at certain optimal intervals.
    If it is set, it breaks the loop by calling the `ThrowIfCancellationRequested`
    method of the `token` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在涉及递归方法或包含通过循环进行长时间计算逻辑的方法的场景中非常有用。在我们的方法或循环中，我们编写代码以在某些最佳间隔时轮询`IsCancellationRequested`。如果设置了，它通过调用`token`类的`ThrowIfCancellationRequested`方法来中断循环。
- en: 'The following code is an example of canceling a task by polling the token:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是通过轮询令牌来取消任务的示例：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we created a cancellation token via the `CancellationTokenSource`
    class. Then, we created a task by passing the token. The task executes a long-running
    method, `LongRunningSum` (simulated), which keeps polling for the `IsCancellationRequested`
    property of the token. It throws an exception if the user has called `cancellationTokenSource.Cancel()`
    before the method finishes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过`CancellationTokenSource`类创建了一个取消令牌。然后，我们通过传递令牌创建了一个任务。该任务执行一个长时间运行的方法`LongRunningSum`（模拟），该方法不断轮询令牌的`IsCancellationRequested`属性。如果用户在方法完成之前调用了`cancellationTokenSource.Cancel()`，它会抛出异常。
- en: Polling doesn't come with any significant performance overhead and can be used
    according to your requirements. Use it when you have full control over the work
    that's performed by the task, such as if it's core logic that you wrote yourself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询不会带来任何显著的性能开销，并且可以根据您的需求使用。当您对任务执行的工作有完全控制时使用它，例如如果它是您自己编写的核心逻辑。
- en: Registering for a request cancellation using the Callback delegate
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调委托注册请求取消
- en: This approach makes use of a `Callback` delegate that gets invoked when the
    cancellation is requested by the underlying token. We should use this with operations
    that are blocked in a way that makes it not possible to check the value of `CancellationToken`
    in a regular fashion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了一个`Callback`委托，当底层令牌请求取消时会被调用。我们应该将其与那些以一种使得无法以常规方式检查`CancellationToken`值的方式阻塞的操作一起使用。
- en: 'Let''s have a look at the following code, which downloads files from a remote
    URL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码，它从远程URL下载文件：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see from the preceding method, once we call the `DownloadStringAsync`
    method of `WebClient`, the control leaves the user. Although the `WebClient` class
    allows us to cancel the task via the `webClient.CancelAsync()` method, we don't
    have any control over when to invoke that.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方法中可以看到，一旦我们调用`WebClient`的`DownloadStringAsync`方法，控制权就离开了用户。虽然`WebClient`类允许我们通过`webClient.CancelAsync()`方法取消任务，但我们无法控制何时调用它。
- en: 'The preceding code can be modified to make use of a `Callback` delegate so
    that we can gain more control over task cancellation, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以修改为使用`Callback`委托，以便更好地控制任务取消，如下所示：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, in this modified version, we passed a cancellation token and
    subscribed to the cancellation callback via the `Register` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个修改后的版本中，我们传递了一个取消令牌，并通过`Register`方法订阅了取消回调。
- en: As soon as the user calls the `cancellationTokenSource.Cancel()` method, it
    will cancel the download operation by calling `webClient.CancelAsync()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户调用`cancellationTokenSource.Cancel()`方法，它将通过调用`webClient.CancelAsync()`取消下载操作。
- en: '`CancellationTokenSource` works well with the legacy `ThreadPool.QueueUserWorkItem`
    as well.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`也可以与传统的`ThreadPool.QueueUserWorkItem`很好地配合使用。'
- en: 'Here is code that creates a `CancellationTokenSource` that can be passed to
    `ThreadPool` to support cancellation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建`CancellationTokenSource`的代码，可以传递给`ThreadPool`以支持取消：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we discussed various ways of canceling tasks. Canceling tasks
    can really save us a lot of CPU time in cases where tasks may have become redundant.
    For example, say we have created multiple tasks to sort a list of numbers using
    different algorithms. Although all the algorithms will return the same result
    (a sorted list of numbers), we are interested in getting results as fast as we
    can. We will accept the result for the first (fastest) algorithm and cancel the
    rest to improve system performance. In the next section, we will discuss how to
    wait on running tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了取消任务的各种方法。取消任务可以在任务可能变得多余的情况下节省大量CPU时间。例如，假设我们创建了多个任务，使用不同的算法对一组数字进行排序。虽然所有算法都会返回相同的结果（一组排序好的数字），但我们希望尽快获得结果。我们将接受第一个（最快的）算法的结果，并取消其余的任务以提高系统性能。在下一节中，我们将讨论如何等待运行中的任务。
- en: How to wait on running tasks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何等待运行中的任务
- en: In the previous examples, we called the `Task.Result` property to get a result
    from a completed task. This blocks the calling thread until a result is available.
    TPL provides another way for us to wait on one or more tasks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们调用了`Task.Result`属性来从已完成的任务中获取结果。这会阻塞调用线程，直到结果可用。TPL为我们提供了另一种等待一个或多个任务的方法。
- en: 'There are various APIs available in TPL so that we can wait on one or more
    tasks. These are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: TPL中有各种API可供我们等待一个或多个任务。这些包括：
- en: '`Task.Wait`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Wait`'
- en: '`Task.WaitAll`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WaitAll`'
- en: '`Task.WaitAny`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WaitAny`'
- en: '`Task.WhenAll`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WhenAll`'
- en: '`Task.WhenAny`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.WhenAny`'
- en: These APIs will be defined in the following subsections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API将在以下子节中定义。
- en: Task.Wait
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.Wait
- en: 'This is an instance method that can be used to wait on a single task. We can
    specify the maximum amount of time for which the caller will wait for the task
    to complete before unblocking itself with a timeout exception. We can also have
    full control over monitoring events that have been canceled by passing a cancellation
    token to the method. The calling method will be blocked until the thread either
    completes, is canceled, or throws an exception:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实例方法，用于等待单个任务。我们可以指定调用者等待任务完成的最长时间，然后在超时异常中解除阻塞。我们还可以通过向方法传递取消令牌来完全控制已取消的监视事件。调用方法将被阻塞，直到线程完成、取消或抛出异常：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are five overloaded versions of the `Wait` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wait`方法有五个重载版本：'
- en: '`Wait()`:Waits indefinitely for the task to finish. The calling thread is blocked
    until the child thread has finished.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait()`:无限期地等待任务完成。调用线程将被阻塞，直到子线程完成。'
- en: '`Wait(CancellationToken)`:Waits for the task to finish execution indefinitely
    or when the cancellation token is canceled.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(CancellationToken)`:等待任务无限期地执行或取消令牌被取消时。'
- en: '`Wait(int)`: Waits for the task to finish execution within a specified period
    of time, in milliseconds.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(int)`:在指定的时间段内等待任务完成执行，以毫秒为单位。'
- en: '`Wait(TimeSpan)`: Waits for the task to finish execution within a specified
    time interval.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(TimeSpan)`:在指定的时间间隔内等待任务完成执行。'
- en: '`Wait(int, CancellationToken)`: Waits for the task to finish execution within
    a specified period of time, in milliseconds, or when the cancellation token is
    canceled.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait(int, CancellationToken)`:在指定的时间段内等待任务完成执行，以毫秒为单位，或者取消令牌被取消时。'
- en: Task.WaitAll
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WaitAll
- en: 'This is a static method that is defined in the `Task` class and used to wait
    on multiple tasks. The tasks are passed as an array to the method and the caller
    is blocked until all the tasks are completed. This method also supports timeout
    and cancellation tokens. Some example code that uses this method is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Task`类中定义的静态方法，用于等待多个任务。任务作为数组传递给方法，调用者将被阻塞，直到所有任务完成。该方法还支持超时和取消令牌。使用此方法的一些示例代码如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/d8f72c1c-e31b-45b7-a3f7-083ea597cfa8.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8f72c1c-e31b-45b7-a3f7-083ea597cfa8.png)'
- en: As you can see, the Calling method finishes statement is executed when both
    tasks have finished executing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当两个任务都完成执行时，调用方法完成语句被执行。
- en: An example use case of this method might be when we need data from multiple
    sources (we have one task for each source) and we want to combine the data from
    all the tasks so that they can be displayed on the UI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个示例用例可能是当我们需要来自多个来源的数据（我们为每个来源都有一个任务），并且我们希望将所有任务的数据组合起来，以便在UI上显示。
- en: Task.WaitAny
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WaitAny
- en: 'This is another static method that is defined in the `Task` class. Just like
    `WaitAll`, `WaitAny` is used to wait on multiple tasks, but the caller is unblocked
    as soon as any of the tasks that are passed as arrays to the method finish executing.
    Like the other methods, `WaitAny` supports the timeout and cancellation tokens.
    Some example code that uses this method is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Task`类中定义的另一个静态方法。就像`WaitAll`一样，`WaitAny`用于等待多个任务，但只要传递给方法的任何任务完成执行，调用者就会解除阻塞。与其他方法一样，`WaitAny`支持超时和取消令牌。使用此方法的一些示例代码如下：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we started two tasks and waited on them using `WaitAny`.
    This method blocks the current thread. As soon as any of the tasks complete, the
    calling thread is unblocked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们启动了两个任务，并使用`WaitAny`等待它们。这个方法会阻塞当前线程。一旦任何一个任务完成，调用线程就会解除阻塞。
- en: An example use case of this method might be when the data we require is available
    from different sources and we need it as quickly as possible. Here, we create
    tasks that make requests to different sources. As soon as any of the tasks finish,
    we will unblock the calling thread and get the result from the finished task.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个示例用例可能是当我们需要的数据来自不同的来源并且我们需要尽快获取它时。在这里，我们创建了请求不同来源的任务。一旦任何一个任务完成，我们将解除调用线程的阻塞并从完成的任务中获取结果。
- en: Task.WhenAll
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WhenAll
- en: 'This is a non-blocking variant of the `WaitAll` method. It returns a task that
    represents a waiting action for all of the specified tasks. Unlike `WaitAll`,
    which blocks the calling thread, `WhenAll` can be awaited inside an asynchronous
    method, thus freeing up the calling thread to perform other operations. Some example
    code that uses this method is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WaitAll`方法的非阻塞变体。它返回一个代表所有指定任务的等待操作的任务。与阻塞调用线程的`WaitAll`不同，`WhenAll`可以在异步方法中等待，从而释放调用线程以执行其他操作。使用此方法的一些示例代码如下：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code works the same way as `Task.WaitAll`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式与`Task.WaitAll`相同，除了调用线程返回到`ThreadPool`而不是被阻塞。
- en: Task.WhenAny
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Task.WhenAny
- en: 'This is a non-blocking variant of `WaitAny`. It returns a task that encapsulates
    a waiting action on a single underlying task. Unlike `WaitAny`, it doesn''t block
    the calling thread. The calling thread can call await on it inside an asynchronous
    method. Some example code that uses this method is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WaitAny`的非阻塞变体。它返回一个封装了对单个基础任务的等待操作的任务。与`WaitAny`不同，它不会阻塞调用线程。调用线程可以在异步方法内调用await。使用此方法的一些示例代码如下：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code works the same way as `Task.WaitAny`, apart from the fact that the
    calling thread returns to the `ThreadPool` instead of being blocked.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式与`Task.WaitAny`相同，除了调用线程返回到`ThreadPool`而不是被阻塞。
- en: In this section, we discussed how to write efficient code while working with
    multiple threads without code branching. Code flow looks synchronous though it
    works in parallel wherever required. In the next section, we will learn about
    how tasks deal with exceptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何在处理多个线程时编写高效的代码，而不需要代码分支。代码流看起来是同步的，尽管在需要的地方是并行的。在下一节中，我们将学习任务如何处理异常。
- en: Handling task exceptions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理任务异常
- en: Exception handling is one of the most important aspects of parallel programming.
    All good clean code practitioners focus on handling exceptions efficiently. This
    becomes even more important with parallel programming as any unhandled exceptions
    in threads or tasks can cause the application to crash abruptly. Fortunately,
    TPL provides a nice, efficient design to handle and manage exceptions. Any unhandled
    exceptions that occur in a task are deferred and then propagated to a joining
    thread, which observes the task for exceptions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是并行编程中最重要的方面之一。所有良好的干净代码从业者都专注于高效处理异常。这在并行编程中变得更加重要，因为线程或任务中的任何未处理异常都可能导致应用程序突然崩溃。幸运的是，TPL提供了一个很好的、高效的设计来处理和管理异常。在任务中发生的任何未处理异常都会被延迟，然后传播到一个观察任务异常的加入线程。
- en: Any exception that occurs inside a task is always wrapped under the `AggregateException`
    class and returned to the caller that is observing the exceptions. If the caller
    is waiting on a single task, the inner exception property of the `AggregateException` class
    will return the original exception. If the caller is waiting for multiple tasks,
    however, such as `Task.WaitAll`, `Task.WhenAll`, `Task.WaitAny`, or `Task.WhenAny`,
    all the exceptions that occur from tasks are returned to the caller as a collection.
    They are accessible via the `InnerExceptions` property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在任务内部发生的异常都会被包装在`AggregateException`类下，并返回给观察异常的调用者。如果调用者正在等待单个任务，`AggregateException`类的内部异常属性将返回原始异常。然而，如果调用者正在等待多个任务，比如`Task.WaitAll`、`Task.WhenAll`、`Task.WaitAny`或`Task.WhenAny`，所有来自任务的异常都将作为集合返回给调用者。它们可以通过`InnerExceptions`属性访问。
- en: Now, let's look at the various ways we can handle exceptions inside tasks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在任务内部处理异常的各种方法。
- en: Handling exception from single tasks
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单个任务处理异常
- en: 'In the following code, we''re creating a simple task that tries to divide a
    number by 0, thereby causing a `DivideByZeroException`. The exception is returned
    to the caller and handled inside the catch block. Since it''s a single task, the
    exception object is wrapped under the `InnerException` property of the `AggregateException`
    object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们创建了一个简单的任务，试图将一个数字除以0，从而引发`DivideByZeroException`。异常被返回给调用者，并在catch块内处理。由于它是一个单一任务，异常对象被包装在`AggregateException`对象的`InnerException`属性下：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output when we run the preceding code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，输出如下：
- en: '![](img/f806dff4-80eb-4d19-88da-254dbe97be32.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f806dff4-80eb-4d19-88da-254dbe97be32.png)'
- en: Handling exceptions from multiple tasks
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多个任务处理异常
- en: 'Now, we''ll create multiple tasks and then try to throw exceptions from them.
    Then, we''ll learn how to list different exceptions from different tasks from
    the caller:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建多个任务，然后尝试从中抛出异常。然后，我们将学习如何从调用者列出来自不同任务的不同异常：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the output when we run the preceding code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，输出如下：
- en: '![](img/e1465881-0a19-42c5-979e-243cdf7845c6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1465881-0a19-42c5-979e-243cdf7845c6.png)'
- en: In the preceding code, we created three tasks that throw different exceptions
    and all threads are awaited using `Task.WaitAll`. As you can see, the exceptions
    are observed by calling `WaitAll` and not just by starting the task, which is
    why we wrapped `WaitAll` inside the `try` block. The `WaitAll` method will return
    when all the tasks that have been passed to it have faulted by throwing exceptions
    and the corresponding `catch` block is executed. We can find all the exceptions
    that originated from all the tasks by iterating over the `InnerExceptions` property
    of the `AggregateException` class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了三个抛出不同异常的任务，并使用`Task.WaitAll`等待所有线程。正如你所看到的，通过调用`WaitAll`观察异常，而不仅仅是启动任务，这就是为什么我们将`WaitAll`包装在`try`块中。`WaitAll`方法将在所有传递给它的任务都通过抛出异常而故障，并执行相应的`catch`块时返回。我们可以通过迭代`AggregateException`类的`InnerExceptions`属性找到所有任务产生的异常。
- en: Handling task exceptions with a callback function
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调函数处理任务异常
- en: 'Another option to find out about these exceptions is to use the callback function
    to access and handle the exceptions that originate from tasks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 找出这些异常的另一个选项是使用回调函数来访问和处理来自任务的异常：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the output when we run the preceding code in Visual Studio:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中运行上述代码时，输出如下：
- en: '![](img/68deb400-78ae-4c72-9467-8a6008210a12.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68deb400-78ae-4c72-9467-8a6008210a12.png)'
- en: As shown in the preceding code, rather than integrating over `InnerExceptions`,
    we have subscribed to the handle callback function on `AggregateException`. This
    is fired for all the tasks that throw the exception and we can return `true`,
    indicating that the exception has been handled gracefully.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们订阅了`AggregateException`上的处理回调函数，而不是整合`InnerExceptions`。这对所有抛出异常的任务都会触发，我们可以返回`true`，表示异常已经得到了优雅处理。
- en: Converting APM patterns into tasks
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将APM模式转换为任务
- en: 'The legacy APM approach used the `IAsyncResult` interface to create asynchronous
    methods with a design pattern using two methods: `BeginMethodName` and `EndMethodName`.
    Let''s try to understand the journey of a program from being synchronous, to an
    APM, and then to a task.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的APM方法使用`IAsyncResult`接口来创建使用两种方法设计模式的异步方法：`BeginMethodName`和`EndMethodName`。让我们试着理解程序从同步到APM再到任务的过程。
- en: 'Here is a synchronous method that reads data from a text file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个从文本文件中读取数据的同步方法：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is nothing fancy in the preceding code. First, we created a `FileStream`
    object and called the `Read` method, which reads the file from the disk synchronously
    into a buffer and then writes the buffer to the console. We converted the buffer
    into a string using the `UTF8Encoding` class. The problem with this approach,
    however, is that the moment a call to `Read` is made, the thread is blocked until
    the read operation has finished. I/O operations are managed by the CPU using CPU
    cycles, so there is no point in keeping the thread waiting for the I/O operation
    to complete. Let''s try to understand the APM way of doing this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中没有什么花哨的。首先，我们创建了一个`FileStream`对象并调用了`Read`方法，该方法将文件从磁盘同步读入缓冲区，然后将缓冲区写入控制台。我们使用`UTF8Encoding`类将缓冲区转换为字符串。然而，这种方法的问题在于一旦调用`Read`，线程就会被阻塞，直到读取操作完成。I/O操作由CPU使用CPU周期来管理，因此没有必要让线程等待I/O操作完成。让我们试着理解APM的做法：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As shown in the preceding code, we have replaced the synchronous `Read` method
    with an asynchronous version, that is, `BeginRead`. The moment the compiler encounters
    `BeginRead`, an instruction is sent to the CPU to start reading the file and the
    thread is unblocked. We can perform other tasks in the same method before blocking
    the thread again by calling `EndRead` to wait for the `Read` operation to finish
    and collect the result. This is a simple yet efficient approach in order to make
    responsive applications, though we are also blocking the thread to fetch results.
    Rather than calling `EndRead` in the same method, we can make use of `Overload`,
    which accepts a callback method that gets called automatically when the read operation
    finishes, to avoid blocking the thread. The signature of this method is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们用异步版本替换了同步的`Read`方法，即`BeginRead`。一旦编译器遇到`BeginRead`，就会向CPU发送指令开始读取文件，并解除线程阻塞。我们可以在同一方法中执行其他任务，然后通过调用`EndRead`再次阻塞线程，等待`Read`操作完成并收集结果。这是一个简单而有效的方法，以便制作响应式应用程序，尽管我们也在阻塞线程以获取结果。我们可以使用`Overload`而不是在同一方法中调用`EndRead`，它接受一个回调方法，当读取操作完成时会自动调用，以避免阻塞线程。该方法的签名如下：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we have seen how we moved from a synchronous method to APM. Now, we are
    going to convert the APM implementation into a task. This is demonstrated in the
    following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了我们是如何从同步方法转换为APM的。现在，我们将把APM实现转换为一个任务。这在以下代码中进行了演示：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding code, we replaced the `BeginRead` method with `Task<int>.Factory.FromAsync`.
    This is a way of implementing a TAP. The method returns a task, which runs in
    the background while we continue doing other work in the same method, before blocking
    the thread again to get the results using `task.Wait()`. This is how you can easily
    convert any APM code into TAP.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们用`Task<int>.Factory.FromAsync`替换了`BeginRead`方法。这是一种实现TAP的方法。该方法返回一个任务，在我们在同一方法中继续做其他工作的同时在后台运行，然后通过`task.Wait()`再次阻塞线程以获取结果。这就是你可以轻松地将任何APM代码转换为TAP的方法。
- en: Converting EAPs into tasks
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将EAP转换为任务
- en: EAPs are used to create components that wrap expensive and time-consuming operations.
    Due to this, they need to be made asynchronous. This pattern has been used in
    the .NET Framework to create components such as `BackgroundWorker` and `WebClient`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: EAP用于创建包装昂贵和耗时操作的组件。因此，它们需要被异步化。这种模式已经被用于.NET Framework中创建诸如`BackgroundWorker`和`WebClient`等组件。
- en: Methods that implement this pattern carry out long-running tasks asynchronously
    in the background but keep notifying the user of their progress and status via
    events, which is why they are known as event-based.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种模式的方法在后台异步执行长时间运行的任务，但通过事件不断通知用户它们的进度和状态，这就是为什么它们被称为基于事件的。
- en: 'The following code shows an implementation of a component that uses EAP:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个使用EAP的组件的实现：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we subscribed to the `DownloadStringCompleted` event,
    which gets fired once `webClient` has downloaded the file from the URL. As you
    can see, we tried to read various result options, such as exception, cancellation,
    and result, using the if-else construct. Converting EAP into TAP is tricky compared
    to APM as it requires a good understanding of the internal nature of EAP components
    because we need to plug the new code into the correct events to make it work.
    Let''s take a look at the converted implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们订阅了`DownloadStringCompleted`事件，一旦`webClient`从URL下载文件，该事件就会触发。正如你所看到的，我们尝试使用if-else结构来读取各种结果选项，如异常、取消和结果。与APM相比，将EAP转换为TAP更加棘手，因为它需要对EAP组件的内部性质有很好的理解，因为我们需要将新代码插入到正确的事件中使其工作。让我们来看一下转换后的实现：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The simplest way of converting EAP into TAP is via the `TaskCompletionSource`
    class. We have plugged in all the scenarios and set the result, exception, or
    cancellation results to the instance of the `TaskCompletionSource` class. Then,
    we returned the wrapped implementation as a task to the user.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将EAP转换为TAP的最简单方法是使用`TaskCompletionSource`类。我们已经插入了所有的情景，并将结果、异常或取消结果设置为`TaskCompletionSource`类的实例。然后，我们将包装的实现作为任务返回给用户。
- en: More on tasks
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于任务
- en: Now, let's learn some more important concepts about tasks that might come in
    handy. Up until now, we have created tasks that are independent. To create more
    complex solutions, however, we sometimes need to define relationships between
    tasks. We can create subtasks, child tasks, as well as continuation tasks to do
    this. Let's try to understand each of these with examples. Later in this section,
    we will learn about thread storage and queues.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习一些关于任务的更重要的概念，这可能会派上用场。到目前为止，我们创建的任务是独立的。然而，为了创建更复杂的解决方案，有时我们需要在任务之间定义关系。我们可以创建子任务、子任务以及继续任务来做到这一点。让我们通过例子来理解每一个。在本节的后面，我们将学习有关线程存储和队列的知识。
- en: Continuation tasks
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续任务
- en: 'Continuation tasks work more like promises. We can make use of them when we
    need to chain multiple tasks. The second task starts when the first one finishes
    and the result of the first task or the exceptions are passed to the child task.
    We can chain more than one task to create a long chain of tasks, or we can create
    a selective continuation chain with the methods provided by TPL. The following
    constructs are provided by TPL for task continuation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 继续任务更像是承诺。当我们需要链接多个任务时，我们可以利用它们。第二个任务在第一个任务完成时开始，并且第一个任务的结果或异常被传递给子任务。我们可以链式地创建多个任务，也可以使用TPL提供的方法创建选择性的继续链。TPL提供了以下任务继续构造：
- en: '`Task.ContinueWith`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.ContinueWith`'
- en: '`Task.Factory.ContinueWhenAll`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAll`'
- en: '`Task.Factory.ContinueWhenAll<T>`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAll<T>`'
- en: '`Task.Factory.ContinueWhenAny`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAny`'
- en: '`Task.Factory.ContinueWhenAny<T>`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.ContinueWhenAny<T>`'
- en: Continuing tasks using the Task.ContinueWith method
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Task.ContinueWith方法继续任务
- en: The continuation of a task can be easily achieved using the `ContinueWith` method
    that's provided by TPL.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TPL提供的`ContinueWith`方法可以轻松实现任务的继续。
- en: 'Let''s try to understand simple chaining with an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解简单的链接：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding example, we need to fetch and display data. The **primary
    task** calls the `FetchData` method. When it has finished, the result is passed
    as input to the **continuation task**, which takes care of printing the data.
    The output is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们需要获取并显示数据。**主任务**调用`FetchData`方法。当它完成时，结果作为输入传递给**继续任务**，负责打印数据。输出如下：
- en: '![](img/7f9e4067-d9cf-4c5d-8f73-8e08028d1cf7.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f9e4067-d9cf-4c5d-8f73-8e08028d1cf7.png)'
- en: 'We can chain multiple tasks as well, thereby creating a chain of tasks, as
    shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以链式地创建多个任务，从而创建一系列任务，如下所示：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can control when the continuation task will run by passing the `System.Threading.Tasks.TaskContinuationOptions`
    enumeration as a parameter that has the following options:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`System.Threading.Tasks.TaskContinuationOptions`枚举作为参数传递来控制继续任务何时运行，该枚举具有以下选项：
- en: '`None`: This is the default option. The continuation task will run when the
    primary task has completed.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`: 这是默认选项。当主任务完成时，继续任务将运行。'
- en: '`OnlyOnRanToCompletion`: The continuation task will run when the primary task
    has completed successfully, meaning it has not canceled or faulted.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlyOnRanToCompletion`: 当主任务成功完成时，继续任务将运行，这意味着它未被取消或出现故障。'
- en: '`NotOnRanToCompletion`: The continuation task will run when the primary task
    has been canceled or faulted.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotOnRanToCompletion`: 当主任务已被取消或出现故障时，继续任务将运行。'
- en: '`OnlyOnFaulted`: The continuation task will run only when the primary task
    has faulted.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlyOnFaulted`: 当主任务出现故障时，继续任务将运行。'
- en: '`NotOnFaulted`: The continuation task will run only when the primary task has
    not faulted.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotOnFaulted`: 当主任务未出现故障时，继续任务将运行。'
- en: '`OnlyOnCancelled`: The continuation task will run only when the primary task
    has been canceled.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlyOnCancelled`: 当主任务已被取消时，继续任务将运行。'
- en: '`NotOnCancelled`: The continuation task will run only when the primary task
    has not been canceled.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotOnCancelled`: 当主任务未被取消时，继续任务将运行。'
- en: Continuing tasks using Task.Factory.ContinueWhenAll and Task.Factory.ContinueWhenAll<T>
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Task.Factory.ContinueWhenAll和Task.Factory.ContinueWhenAll<T>继续任务
- en: 'We can wait for multiple tasks and chain a continuation code that will only
    run when all the tasks are completed successfully. Let''s look at an example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以等待多个任务，并链式地继续代码，只有当所有任务都成功完成时才会运行。让我们看一个例子：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we want to calculate `a*a + b*b +2 *a *b`. We break
    down the task into three units: `a*a`, `b*b`, and `2*a*b`. Each of these units
    is executed by three different threads: `taskA`, `taskB`, and `taskC`. Then, we
    wait for all the tasks to finish and pass them as a first parameter to the `ContinueWhenAll`
    method. When all the threads finish executing, the continuation delegate executes,
    which is specified by the second parameter to the `ContinueWhenAll` method. The
    continuation delegate sums the result of the execution from all the threads and
    returns them to the caller, which is printed in the next line.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们想要计算`a*a + b*b +2 *a *b`。我们将任务分解为三个单元：`a*a`、`b*b`和`2*a*b`。每个单元由三个不同的线程执行：`taskA`、`taskB`和`taskC`。然后，我们等待所有任务完成，并将它们作为第一个参数传递给`ContinueWhenAll`方法。当所有线程完成执行时，由`ContinueWhenAll`方法的第二个参数指定的继续委托执行。继续委托对所有线程执行的结果进行求和，并将其返回给调用者，然后在下一行打印出来。
- en: Continuing tasks using Task.Factory.ContinueWhenAny and Task.Factory.ContinueWhenAny<T>
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Task.Factory.ContinueWhenAny和Task.Factory.ContinueWhenAny<T>继续任务
- en: 'We can wait for multiple tasks and chains in continuation code that will run
    when any of the tasks are completed successfully:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以等待多个任务，并链式地继续代码，只有当任何一个任务成功完成时才会运行：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As shown in the preceding code, we have three different pieces of logic to find
    out whether a number is odd. Let's assume that we don't know which of these pieces
    of logic is going to be the fastest. To calculate the result, we create three
    tasks, each of which encapsulates a different odd-number-finding logic, and run
    them concurrently. Since a number can be either odd or even at a time, the result
    from all the threads will be the same and will differ in terms of their speed
    of execution. Due to this, it makes sense to just get the first result and discard
    the rest. This is what we have achieved using the `ContinueWhenAny` method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们有三种不同的逻辑来判断一个数字是否为奇数。假设我们不知道哪种逻辑会最快。为了计算结果，我们创建了三个任务，每个任务封装了不同的奇数查找逻辑，并并发运行它们。由于一个数字同时可以是奇数或偶数，所有线程的结果将是相同的，但在执行速度上会有所不同。因此，只需获取第一个结果并丢弃其余结果是有意义的。这就是我们使用`ContinueWhenAny`方法实现的。
- en: Parent and child tasks
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 父任务和子任务
- en: 'Another type of relationship that can occur between threads is a parent-child
    relationship. The child task is created as a nested task inside the body of the
    parent task. The child task can be created either as attached or detached. Both
    types of tasks are created inside the parent task and, by default, the created
    tasks are detached. We can make an attached task by setting the `AttachedToParent`
    property of the task to `true`. You may want to consider creating an attached
    task in any of the following scenarios:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 线程之间可能发生的另一种关系是父子关系。子任务作为父任务主体内的嵌套任务创建。子任务可以作为附加或分离创建。默认情况下，创建的任务是分离的。我们可以通过将任务的`AttachedToParent`属性设置为`true`来创建附加任务。您可能希望在以下情况之一中考虑创建附加任务：
- en: All the exceptions that are thrown in the child task need to be propagated to
    the parent
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在子任务中抛出的异常都需要传播到父任务
- en: The status of the parent task is dependent on the child task
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父任务的状态取决于子任务
- en: The parent needs to wait for the child task to finish
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父任务需要等待子任务完成
- en: Creating a detached task
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个分离的任务
- en: 'The code to create a detached class is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分离类的代码如下：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we have created another task within the body of a task. By
    default, the child or nested task is created as detached. We waited for the parent
    task to finish by calling `parentTask.Wait()`. In the following output, you can
    see that the parent task doesn''t wait for the child task to finish and finishes
    first, followed by the child task starting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在一个任务的主体内创建了另一个任务。默认情况下，子任务或嵌套任务是作为分离的创建的。我们通过调用`parentTask.Wait()`等待父任务完成。在以下输出中，您可以看到父任务不等待子任务完成，先完成，然后是子任务的开始：
- en: '![](img/3b1d53c7-a4a2-40a7-8dcd-ef1160ffd33d.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b1d53c7-a4a2-40a7-8dcd-ef1160ffd33d.png)'
- en: Creating an attached task
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个附加任务
- en: 'An attached task is created similarly to a detached one. The only difference
    is that we set the `AttachedParent` property of the task to `true`. This is demonstrated
    in the following snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 附加任务的创建方式与分离任务类似。唯一的区别是我们将任务的`AttachedParent`属性设置为`true`。这在以下代码片段中得到了演示：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3d5d2a16-4cbe-48c5-8ecd-66c57980b423.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5d2a16-4cbe-48c5-8ecd-66c57980b423.png)'
- en: Here, you can see that the parent task does not finish until the child task
    has finished executing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到父任务直到子任务执行完成才结束。
- en: In this section, we discussed advanced aspects of tasks, including creating
    relationships among tasks. In the next section, we will dig more into working
    internally on tasks by understanding the concept of work queues and how tasks
    deal with them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了任务的高级方面，包括创建任务之间的关系。在下一节中，我们将更深入地了解任务内部的工作，理解工作队列的概念以及任务如何处理它们。
- en: Work-stealing queues
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作窃取队列
- en: Work-stealing is a performance optimization technique for a thread pool. Every
    thread pool maintains a single global queue of tasks that are created inside a
    process. In [Chapter 1](ec9722fc-d60f-410b-9db6-edd401804d3c.xhtml), *Introduction
    to Parallel Programming*, we learned that the thread pool maintains an optimal
    number of worker threads to work on tasks. The `ThreadPool` also maintains a thread
    global queue, where it queues all the work items before they can be assigned to
    available threads. Since this is a single queue and we work in multithreaded scenarios,
    we need to implement thread-safety using synchronization primitives. With a single
    global queue, synchronization leads to performance loss.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 工作窃取是线程池的性能优化技术。每个线程池维护一个任务的全局队列，这些任务是在进程内创建的。在[第1章](ec9722fc-d60f-410b-9db6-edd401804d3c.xhtml)中，*并行编程简介*，我们了解到线程池维护了一定数量的工作线程来处理任务。`ThreadPool`还维护一个线程全局队列，在这里它将所有工作项排队，然后才能分配给可用线程。由于这是一个单一队列，并且我们在多线程场景中工作，我们需要使用同步原语来实现线程安全。由于存在单一全局队列，同步会导致性能损失。
- en: The .NET Framework works around this performance loss by introducing the concept
    of local queues, which are managed by threads. Each thread has access to a global
    queue and also maintains its own thread-local queue to store work items in. Parent
    tasks can be scheduled inside the global queue. When tasks execute and need to
    create subtasks, they can be stacked up on local queues and processed using the
    FIFO algorithm as soon as the thread finishes executing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework通过引入本地队列的概念来解决这种性能损失，本地队列由线程管理。每个线程都可以访问全局队列，并且还维护自己的线程本地队列来存储工作项。父任务可以在全局队列中调度。当任务执行并且需要创建子任务时，它们可以堆叠在本地队列上，并且在线程执行完成后立即使用FIFO算法进行处理。
- en: 'The following diagram depicts the relationship between a global queue, a local
    queue, the thread, and the `Threadpool`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了全局队列、本地队列、线程和`Threadpool`之间的关系：
- en: '![](img/f8426a23-055d-4869-ba04-97bc06d88270.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8426a23-055d-4869-ba04-97bc06d88270.png)'
- en: 'Let''s say that the main thread creates a set of tasks. All of these tasks
    are queued to the global queue to be executed later based on the availability
    of the thread inside the thread pool. The following diagram depicts the global
    queue with all the queued tasks:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df6416be-11a8-4b46-9021-b2016fb2b9e9.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say **Task 1** is scheduled on **Thread 1**, **Task 2** on **Thread
    2**, and so on, as shown in the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd8f4d1-e506-4240-9917-bf715c603c82.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'If **Task 1** and **Task 2** generate more tasks, the new tasks will be stored
    in the thread-local queue, as shown in the following diagram:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d08e9c26-4b93-413a-8a96-3f403a3877a3.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Similarly, if more tasks are created by these child tasks, they will go inside
    the local queue instead of the global queue. Once **Thread 1** has finished with
    **Task 1**, it will look into its local queues and pick up the last task (LIFO).
    There is a high chance that the last task may still be in the cache and so it
    doesn't need to be reloaded. Again, this improves performance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Once a thread (T1) exhausts its local queue, it will search in the global queue.
    If there are no items in the global queue, it will search in the local queues
    for other threads (say T2). This technique is called work-stealing and is an optimization
    technique. This time, it doesn't pick the last task (LIFO) from T2 since the last
    item may still be in the T2 thread's cache. Instead, it picks up the first task
    (FIFO) since there is a high chance that the thread has moved out of T2's cache.
    This technique improves performance by making cached tasks available to the local
    thread and out-of-cache tasks to other threads.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed how to break up tasks into smaller units
    so that each unit can be handled independently by a thread. We have also learned
    about various ways we can create tasks by utilizing `ThreadPool`. We introduced
    various techniques related to the internal workings of tasks, including the concepts
    of work-stealing and task creation or cancellation. We will be utilizing the knowledge
    we gained in this chapter in the rest of this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concepts of data parallelism. This
    will include working with parallel loops and handling exceptions in them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL

- en: Synchronization Primitives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the potential pitfalls of parallel programming.
    One of these was synchronization overheads. As we break down work into tasks to
    be processed by multiple work items, there arises a need to synchronize the results
    from each thread. We discussed the concept of thread-local-storage and partition-local-storage,
    which can be used to work around this synchronization issue to a certain extent.
    However, it is still necessary to synchronize threads so that we can write data
    to a shared memory location and so that we can perform I/O operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the synchronization primitives that are provided
    by the .NET Framework and the TPL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization primitives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interlocked operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking primitives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signaling primitives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight synchronization primitives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barriers and countdown events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the various
    locking and signaling primitives that are provided by .NET Framework, including
    some lightweight synchronization primitives that should be used as much as possible
    wherever there are synchronization needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you should have a good understanding of TPL, primarily
    parallel loops. The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: What are synchronization primitives?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before understanding synchronization primitives, we need to understand critical
    section. Critical section is part of the execution path of a thread that must
    be protected from concurrent access in order to maintain some invariants. Critical
    section is not a synchronization primitive in itself but relies on synchronization
    primitives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization primitives are simple software mechanisms that are provided
    by the underlying platform (the OS). They help in multithreading the kernel. Synchronization
    primitives internally use low-level atomic operations, as well as memory barriers.
    This means that users of synchronization primitives don't have to worry about
    implementing locks and memory barriers themselves. Some common examples of synchronization
    primitives are locks, mutexes, conditional variables, and semaphores. The monitor
    is a higher-level synchronization tool that makes use of other synchronization
    primitives internally.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET Framework provides a range of synchronization primitives to deal with
    the interaction among threads, as well as to avoid potential race conditions.
    Synchronization primitives can be broadly divided into five categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Interlocked operations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signaling
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight synchronization types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpinWait`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will discuss each category and their respective
    low-level primitives.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Interlocked operations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interlocked class encapsulates synchronization primitives and is used to
    provide atomic operations to variables that are shared across threads. It provides
    methods such as `Increment`, `Decrement`, `Add`, `Exchange`, and `CompareExchange`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, which tries to increment a counter inside a parallel
    loop:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run this code, we will see the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02d70e3d-6df9-4fb4-824e-222489691f08.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: As you can see, the expected value and the actual value do not match. This is
    because of the race condition among the threads, which has arisen because the
    thread wants to read a value from a variable to which the value has been written
    but not yet committed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the preceding code using the `Interlocked` class to make it thread-safe,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expected output is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3406d7f-f496-46c5-a762-0cc384cd4b01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can use `Interlocked.Decrement(ref _counter)` to decrement the
    value in a thread-safe manner.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`Interlocked.Decrement(ref _counter)`以线程安全的方式减少值。
- en: 'The following code shows the complete list of operations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的操作列表：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the preceding methods, two new methods were added in .NET Framework
    4.5: `Interlocked.MemoryBarrier()` and `Interlocked.MemoryBarrierProcessWide()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的方法，.NET Framework 4.5中还添加了两个新方法：`Interlocked.MemoryBarrier()`和`Interlocked.MemoryBarrierProcessWide()`。
- en: In the next section, we will learn more about memory barriers in .NET.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于.NET中的内存屏障。
- en: Memory barriers in .NET
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的内存屏障
- en: Threading models work differently on single-core versus multicore processors.
    On single-core processors, only one thread gets a CPU slice while other threads
    wait for their turn. This ensures that whenever a thread accesses the memory (for
    loading and storing), it is in the right order. This model is also known as a
    **sequential consistency model**. In the case of multicore processor systems,
    multiple threads run concurrently. Sequential consistency is not guaranteed in
    these systems since either the hardware or the **Just in Time** (**JIT**) compiler
    might reorder the memory instructions to improve performance. The memory instructions
    may also be reordered for performance purposes for caching, load speculations,
    or delaying store operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单核处理器和多核处理器上的线程模型工作方式不同。在单核处理器上，只有一个线程获得CPU时间片，而其他线程则等待它们的轮次。这确保了每当一个线程访问内存（用于加载和存储）时，它都是按正确的顺序进行的。这个模型也被称为**顺序一致性模型**。在多核处理器系统中，多个线程同时运行。在这些系统中，无法保证顺序一致性，因为硬件或**即时**（**JIT**）编译器可能会重新排序内存指令以提高性能。内存指令也可能会因为缓存、加载推测或延迟存储操作而进行重新排序以提高性能。
- en: 'An example of a load speculation is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 加载推测的示例如下：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An example of a store operation is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存储操作的示例如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Load and store statements, when encountered by the compiler, are not always
    executed in the same order as they are written. Compilers do some reordering for
    performance benefits. Let's try to understand more about reordering.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到加载和存储语句时，并不总是按照它们被编写的顺序执行。编译器会进行一些重新排序以获得性能上的好处。让我们试着更多地了解重新排序。
- en: What is reordering?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是重新排序？
- en: 'For a given sequence of code statements, the compiler can choose to either
    execute them in the same order as they are received or reorder them to gain performance
    if multiple threads are working on the same code. For example, take a look at
    the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的代码语句序列，编译器可以选择按照接收到的顺序执行它们，或者重新排序它们以提高性能，如果多个线程正在处理相同的代码。例如，看一下以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code can be reordered and executed in the following order for
    another thread:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以被重新排序并以以下顺序执行给另一个线程：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Code reordering is a problem for multicore processors with weak memory models,
    such as Intel Itanium processors. It has no impact on single-core processors,
    however, due to the sequential consistency model. The code is restructured so
    that another thread can take advantage or store an instruction that is already
    in the memory. Code reordering can be done either by hardware or by a JIT compiler.
    To guarantee code reordering, we need some sort of **memory barrier**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有弱内存模型的多核处理器（如英特尔Itanium处理器），代码重新排序是一个问题。然而，对于单核处理器来说，由于顺序一致性模型，它没有影响。代码被重组，以便另一个线程可以利用或存储已经在内存中的指令。代码重新排序可以由硬件或JIT编译器来完成。为了保证代码重新排序，我们需要某种**内存屏障**。
- en: Types of memory barriers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存屏障的类型
- en: 'Memory barriers ensure that any code statements above or below the barrier
    will not cross the barrier, thereby enforcing the order of the code. There are
    three types of memory barrier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内存屏障确保屏障上方或下方的任何代码语句都不会越过屏障，从而强制执行代码的顺序。有三种类型的内存屏障：
- en: '**Store (write) memory barrier: **A store memory barrier ensures that no store
    operations are allowed to move across the barrier. It has no effect on load operations;
    these can still be reordered. The equivalent CPU instruction to achieve this effect
    is **SFENCE**:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储（写入）内存屏障：**存储内存屏障确保不允许存储操作越过屏障。它对加载操作没有影响；这些操作仍然可以被重新排序。实现此效果的等效CPU指令是**SFENCE**：'
- en: '![](img/d03a60bd-ad17-46a1-afdc-8157aeae929d.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d03a60bd-ad17-46a1-afdc-8157aeae929d.png)'
- en: '**Load (read) memory barrier: **A load barrier ensures that no load operations
    are allowed to move across the barrier but places no such enforcement on store
    operations. The equivalent CPU instruction to achieve this effect is **LFENCE**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载（读取）内存屏障：**加载屏障确保不允许加载操作越过屏障，但对存储操作不做任何强制。实现此效果的等效CPU指令是**LFENCE**：'
- en: '![](img/6ad7473e-6976-40c6-8282-08b4300a9bf5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ad7473e-6976-40c6-8282-08b4300a9bf5.png)'
- en: '**Full memory barrier: **A full memory barrier ensures ordering by not allowing
    store or load operations to move across the memory barrier. The equivalent CPU
    instruction to achieve this effect is **MFENCE**. The behavior of the full memory
    barrier is often implemented by .NET synchronization constructs such as the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整内存屏障：**完整内存屏障通过不允许存储或加载操作越过内存屏障来确保顺序。实现此效果的等效CPU指令是**MFENCE**。完整内存屏障的行为通常由.NET同步构造实现，例如以下内容：'
- en: '`Task.Start`, `Task.Wait`, and `Task.Continuation`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Start`、`Task.Wait`和`Task.Continuation`'
- en: '`Thread.Sleep`, `Thread.Join`, `Thread.SpinWait`, `Thread.VolatileRead`, and `Thread.VolatileWrite`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`、`Thread.Join`、`Thread.SpinWait`、`Thread.VolatileRead`和`Thread.VolatileWrite`'
- en: '`Thread.MemoryBarrier`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.MemoryBarrier`'
- en: '`Lock`, `Monitor.Enter`, and `Monitor.Exit`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`、`Monitor.Enter`和`Monitor.Exit`'
- en: '`Interlocked` class operations'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`类的操作'
- en: Half barriers are provided by the `Volatile` keyword and the `Volatile` class
    methods. The .NET Framework provides some built-in patterns using volatile fields
    in classes such as `Lazy<T>` and `LazyInitializer`. We will discuss these further
    in [Chapter 7](584edc9a-7c38-480b-a280-b6c17008ae94.xhtml), *Improving Performance
    with Lazy Initialization*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Volatile`关键字和`Volatile`类方法提供了半屏障。.NET Framework提供了一些内置模式，使用类中的`Volatile`字段，如`Lazy<T>`和`LazyInitializer`。我们将在[第7章](584edc9a-7c38-480b-a280-b6c17008ae94.xhtml)中进一步讨论这些，*使用延迟初始化提高性能*。'
- en: Avoiding code reordering using constructs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造避免代码重排序
- en: 'We can avoid reordering using `Thread.MemoryBarrier`, as shown in the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Thread.MemoryBarrier`避免重排序，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Thread.MemoryBarrier` creates a full barrier that doesn’t allow load or store
    operations to pass. It has been wrapped inside `Interlocked.MemoryBarrier`, so
    the same code can be written as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.MemoryBarrier`创建一个不允许加载或存储操作通过的完整屏障。它已经包装在`Interlocked.MemoryBarrier`中，因此可以将相同的代码编写如下：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to create a process- and system-wide barrier, we can make use of
    `Interlocked.MemoryBarrierProcessWide`, which was introduced in .NET Core 2.0\.
    This is a wrapper over the `FlushProcessWriteBuffer` Windows API or `sys_membarrier` on
    a Linux kernel:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个进程范围和系统范围的屏障，我们可以使用.NET Core 2.0中引入的`Interlocked.MemoryBarrierProcessWide`。这是对`FlushProcessWriteBuffer`
    Windows API或Linux内核上的`sys_membarrier`的包装：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example shows us how we can create a process-wide barrier. Now,
    let's look at what locking primitives are.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子向我们展示了如何创建一个进程范围的屏障。现在，让我们来看看锁定原语是什么。
- en: Introduction to locking primitives
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定原语简介
- en: Locks can be used to limit access to a protected resource to only a single thread
    or group of threads. To be able to implement locking efficiently, we need to identify
    appropriate critical sections that can be protected via locking primitives.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 锁可以用来限制对受保护资源的访问，只允许单个线程或一组线程。为了能够有效地实现锁定，我们需要识别可以通过锁定原语保护的适当的临界区。
- en: How locking works
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定的工作原理
- en: 'When we apply a lock to a shared resource, the following steps are performed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对共享资源应用锁时，执行以下步骤：
- en: A thread or group of threads access a shared resource by acquiring a lock.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程或一组线程通过获取锁来访问共享资源。
- en: Other threads that cannot get access to a lock go into a wait state.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法访问锁定的其他线程进入等待状态。
- en: As soon as the lock is freed by one of the threads, it is acquired by another
    thread, which starts its execution.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦锁被一个线程释放，另一个线程就会获取它，并开始执行。
- en: To understand locking primitives, we need to understand various thread states,
    as well as concepts such as blocking and spinning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解锁定原语，我们需要了解各种线程状态，以及阻塞和自旋等概念。
- en: Thread state
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程状态
- en: 'At any point during the thread''s life cycle, we can query a thread state using
    the `ThreadState` property of the thread. A thread can be in any one of the following
    states:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程的生命周期的任何时刻，我们都可以使用线程的`ThreadState`属性查询线程状态。线程可以处于以下任一状态：
- en: '`Unstarted`: The thread has been created by CLR but the `System.Threading.Thread.Start`
    method hasn''t been invoked on the thread yet.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未启动`：线程已被CLR创建，但尚未调用`System.Threading.Thread.Start`方法。'
- en: '`Running`: The thread has been started via a call to `Thread.Start`. It is
    not waiting for any pending operations.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行`：线程已通过调用`Thread.Start`启动。它不在等待任何未决操作。'
- en: '`WaitSleepJoin`: The thread is in a blocked state as a result of invoking the
    `Wait()`, `Sleep()`, or `Join()` methods by calling the thread.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitSleepJoin`：由于调用`Wait()`、`Sleep()`或`Join()`方法，线程处于阻塞状态。'
- en: '`StopRequested`: The thread has been requested to stop.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`停止请求`：线程已被请求停止。'
- en: '`Stopped`: The thread has stopped executing.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已停止`：线程已停止执行。'
- en: '`AbortRequested`: The `Abort()` method has been called on the thread, but the
    thread hasn''t been aborted yet as it is waiting for `ThreadAbortException`, which
    will try to terminate it.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止请求`：在线程上调用了`Abort()`方法，但线程尚未被中止，因为它正在等待`ThreadAbortException`来尝试终止它。'
- en: '`Aborted`: The thread has been aborted.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止`：线程已被中止。'
- en: '`SuspendRequested`: The thread is requested to suspend as a result of calling
    the `Suspend` method.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`暂停请求`：由于调用`Suspend`方法，线程被请求暂停。'
- en: '`Suspended`: The thread has been suspended.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已暂停`：线程已被暂停。'
- en: '`Background`: The thread is being executed in the background.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`后台`：线程在后台执行。'
- en: 'Let''s try to explore the journey of a thread from its initial state, `UnStarted`,
    to its final state, `Stopped`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试探索线程从初始状态`未启动`到最终状态`已停止`的过程：
- en: '![](img/77801852-0e65-4a02-853e-ac10b7ad47c4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77801852-0e65-4a02-853e-ac10b7ad47c4.png)'
- en: 'When a thread is created by CLR, it is in an `Unstarted` state. It makes a
    transition from `Unstarted` to `Running` when the external thread calls the `Thread.Start()`
    method on it. From the `Running` state, a thread can transition to the following
    states:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当CLR创建线程时，它处于`未启动`状态。当外部线程调用`Thread.Start()`方法时，它从`未启动`状态转换到`运行`状态。从`运行`状态，线程可以转换到以下状态：
- en: '`WaitSleepJoin`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitSleepJoin`'
- en: '`AbortRequested`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止请求`'
- en: '`Stopped`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已停止`'
- en: A thread is said to be blocked when it is in the `WaitSleepJoin` state. The
    execution of a blocked thread is paused since it is waiting for some external
    conditions to be met, which may be the result of some CPU-bound I/O operation
    or some other thread. Once blocked, the thread immediately yields the CPU time
    slice and doesn't use the processor slice until the blocked condition is satisfied.
    At this point, the thread is unblocked. Blocking and unblocking constitutes a
    performance overhead as this requires the CPU to carry out context switching.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程处于`WaitSleepJoin`状态时，就说它被阻塞了。被阻塞的线程的执行被暂停，因为它正在等待一些外部条件的满足，这可能是一些CPU绑定的I/O操作或其他线程的结果。一旦被阻塞，线程立即放弃CPU时间片，并且在满足阻塞条件之前不使用处理器时间片。在这一点上，线程被解除阻塞。阻塞和解除阻塞构成了性能开销，因为这需要CPU进行上下文切换。
- en: 'A thread can be unblocked in any of the following events:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: If the blocking condition is satisfied
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By calling `Thread.Interrupt` on the blocked thread
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By aborting a thread using `Thread.Abort`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the specified timeout is reached
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking versus spinning
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A blocked thread relinquishes the processor slice for a specified amount of
    time. This improves performance by making it available for other threads but incurs
    the overhead of context switching. It is good in a scenario where the thread has
    to be blocked for a considerable amount of time. If the waiting time is less,
    it makes sense to go for spinning without relinquishing the processor slice. For
    example, the following code simply loops infinitely:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is just an empty `while` loop that checks for a Boolean variable. When
    the wait is over, the variable will be set to false and the loop can break. Although
    this is a waste of processor time, it can significantly improve performance if
    the wait isn't very long. The .NET Framework provides some special constructs,
    which we will discuss later in this chapter, such as `SpinWait` and `SpinLock`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to understand some locking primitives with code examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Lock, mutex, and semaphore
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lock and mutex are locking constructs that allow only one thread to access a
    protected resource. Lock is a shortcut implementation that uses another higher-level
    synchronization class called `Monitor`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Semaphore is a locking construct that allows a specified number of threads to
    access a protected resource. Lock can only synchronize access inside a process,
    but if we need to access a system-level resource or shared memory, we need to
    actually synchronize access across multiple processes. A mutex allows us to synchronize
    access to resources across processes by providing a kernel-level lock.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table provides a comparison of the capabilities of these constructs:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3333def0-bb0b-4805-b86c-ca1607865494.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: As we can see, **Lock** and **Mutex** only allow single-thread access to shared
    resources, whereas **Semaphore** and **SemaphoreSlim** can be used to allow access
    to resources that have been shared by multiple threads. Also, where **Lock** and
    **SemaphoreSlim** only work inside a process, **Mutex** and **Semaphore** have
    a process-wide lock.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Lock
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following code, which tries to write a number to a text
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output when we run the preceding code is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e55e8a1f-df02-483a-80bc-a2ae13ed28d3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: As you can see, the task is composed of 1,000 work items and each work item
    takes approximately 10 milliseconds to execute. The time that's taken by the task
    is 1,000 multiplied by 10, which is 10,000 milliseconds. We also have to take
    into consideration the time taken to perform I/O, so the total time turns out
    to be 11,949.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to parallelize this task using the `AsParallel()` and `AsOrdered()`
    clauses, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we try to run this code, we get the following `System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: What actually happened here is that the file is a shared resource with a critical
    section and therefore only allows atomic operations. With the parallel code, we
    have a situation where multiple threads are actually trying to write to the file
    and causing an exception. We need to make sure that the code runs in parallel
    as fast as possible but also maintains atomicity while writing to the file. We
    need to modify the preceding code using a lock statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'First, declare a `static` reference type variable. In our case, we take a variable
    of the `object` type. We need a reference type variable since the lock can only
    be applied on the heap memory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we modify the code inside the `ForAll()` method to include a `lock`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when we run this code, we won''t get any exceptions, but the time that
    the task took was actually more than the sequential execution:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6f865f-a773-43e8-80d5-9907b0703fd5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'What went wrong here? Lock ensures atomicity by making sure that only one thread
    is allowed to access the vulnerable code, but this comes with the overhead of
    blocking the thread that is waiting for the lock to be freed. We call this a dumb
    lock. We can modify the program slightly to only lock the critical section to
    improve performance while maintaining atomicity, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出了什么问题？锁通过确保只有一个线程被允许访问易受攻击的代码来确保原子性，但这会带来阻塞等待锁被释放的线程的开销。我们称之为愚蠢的锁。我们可以稍微修改程序，只锁定关键部分以提高性能，同时保持原子性，如下所示：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following is the output of the preceding code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/63589a04-4827-411e-a907-dd302daa543f.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63589a04-4827-411e-a907-dd302daa543f.png)'
- en: As you can see, we achieved significant gains by mixing synchronization along
    with parallelization. We can achieve similar results using another locking primitive,
    that is, the `Monitor` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过混合同步和并行化，我们取得了显著的收益。我们可以使用另一个锁原语来实现类似的结果，即`Monitor`类。
- en: 'Lock is actually a shorthand syntax for achieving `Monitor.Enter()` and `Monitor.Exit()`
    wrapped inside a `try`-`catch` block. The same code can, therefore, be written
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 锁实际上是一种简写语法，用于在`try`-`catch`块中包装`Monitor.Enter()`和`Monitor.Exit()`以实现原子性。因此，可以将相同的代码编写如下：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![](img/5da8d712-da99-4097-804c-d9174d3951ae.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5da8d712-da99-4097-804c-d9174d3951ae.png)'
- en: Mutex
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥体
- en: The preceding code works well for a single instance application since tasks
    run inside a process and the lock actually locks a memory barrier inside the process.
    If we run multiple instances of the application, both applications will have their
    own copy of the static data members and will, therefore, lock their own memory
    barriers. This will allow one thread per process to actually enter the critical
    section and try to write the file. This causes the following `System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码适用于单个实例应用程序，因为任务在进程内运行，锁实际上锁定了进程内的内存屏障。如果我们运行应用程序的多个实例，两个应用程序将拥有自己的静态数据成员的副本，因此将锁定自己的内存屏障。这将允许每个进程中的一个线程实际进入临界区并尝试写入文件。这将导致以下`System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`。
- en: To be able to apply locks to shared resources, we can apply a lock at the kernel
    level using the `mutex` class. Like lock, mutex allows only one thread to access
    a protected resource but can work across processes as well, thereby allowing only
    one thread per system to access a protected resource, irrespective of the number
    of processes that are executing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将锁应用于共享资源，我们可以使用`mutex`类在内核级别应用锁。与锁类似，互斥体只允许一个线程访问受保护的资源，但也可以跨进程工作，因此只允许系统中的一个线程访问受保护的资源，而不管执行的进程数量如何。
- en: A mutex can be named or unnamed. An unnamed mutex works like a lock and cannot
    work across processes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥体可以是命名的或未命名的。未命名的互斥体的工作方式类似于锁，不能跨进程工作。
- en: 'First, we''ll create an unnamed `Mutex`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个未命名的`Mutex`：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we''ll modify the preceding parallel code so that we can use `Mutex`
    like a lock:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将修改前面的并行代码，以便我们可以像使用锁一样使用`Mutex`：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/063ee14e-1885-46c5-b045-59ecacdb5a61.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/063ee14e-1885-46c5-b045-59ecacdb5a61.png)'
- en: With a `Mutex` class, we can call the `WaitHandle.WaitOne()` method to lock
    the critical section and `ReleaseMutex()` to unlock the critical sections. Closing
    or disposing of a mutex automatically releases it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Mutex`类，我们可以调用`WaitHandle.WaitOne()`方法来锁定临界区，并使用`ReleaseMutex()`来解锁临界区。关闭或处理互斥体会自动释放它。
- en: 'The preceding program works well, but if we try to run it on multiple instances,
    it will throw an `IOException`. For this, we can create a `namedMutex`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序运行良好，但如果我们尝试在多个实例上运行它，它将抛出一个`IOException`。为此，我们可以创建一个`namedMutex`，如下所示：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Optionally, we can specify a timeout while calling `WaitOne()` on the mutex
    so that it waits for a signal for a specified amount of time before unblocking
    itself. This is shown in the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`WaitOne()`时，我们可以选择指定一个超时，以便在等待一定时间内等待信号，然后解除阻塞。下面是一个示例：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding mutex will wait for three seconds before unblocking itself if
    it doesn't receive a signal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未收到信号，上述互斥体将在三秒后解除阻塞。
- en: Lock and mutex can only be released from the thread that obtained them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和互斥体只能从获取它们的线程中释放。
- en: Semaphore
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: Lock, mutex, and monitor allow only one thread to access a protected resource.
    Sometimes, however, we need to allow multiple threads to be able to access a shared
    resource. Examples of these include resource pooling scenarios and throttling
    scenarios. A `semaphore`, unlike lock or mutex, is thread-agnostic, which means
    that any thread can call a release of `semaphore`. Just like a mutex, it works
    across processes as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 锁，互斥体和监视器只允许一个线程访问受保护的资源。然而，有时我们需要允许多个线程能够访问共享资源。这些情况包括资源池化场景和限流场景。与锁或互斥体不同，`semaphore`是线程不可知的，这意味着任何线程都可以调用`semaphore`的释放。就像互斥体一样，它也可以跨进程工作。
- en: 'A typical `semaphore` constructor is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的`semaphore`构造函数如下：
- en: '![](img/c903a4bf-5953-4af1-a3f2-7d0ae9503f5f.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c903a4bf-5953-4af1-a3f2-7d0ae9503f5f.png)'
- en: 'As you can see, it accepts two parameters: the `initialCount`, which specifies
    how many threads are initially allowed to enter, and `maximumCount`, which specifies
    the total number of threads that can enter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它接受两个参数：`initialCount`，指定最初允许进入的线程数，以及`maximumCount`，指定可以进入的总线程数。
- en: 'Let''s say we have a remote service that only allows three concurrent connections
    per client and takes one second to process a request, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个远程服务，每个客户端只允许三个并发连接，并且需要一秒来处理一个请求，如下所示：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a method that has 1,000 work items that need to call the service with
    parameters. We need to process a task in parallel but also make sure that there
    are no more than three calls to the service at any time. We can achieve this by
    creating a `semaphore` with a max count of `3`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can write some code that can simulate making 1,000 requests in parallel,
    but only three at a time, using the following `semaphore`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of this is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34020bb8-f6f0-4ee6-8496-f03b46823fb5.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: As you can see, three threads enter and call the service while other threads
    wait for the lock to be released. As soon as a thread releases the lock, another
    thread enters but only if three threads are inside the critical section at any
    one time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of semaphores: local and global. We will discuss these
    next.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Local semaphore
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A local `semaphore` is local to the application where it''s used. Any `semaphore`
    that is created without a name will be created as a local `semaphore`, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Global semaphore
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A global `semaphore` is global to the operating system as it applies kernel-
    or system-level locking primitives. Any `semaphore` that is created with a name
    will be created as a global `semaphore`, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we create a `semaphore` with only one thread, it will act like a lock.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: ReaderWriterLock
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ReaderWriterLock` class defines a lock that supports multiple readers and
    a single writer at a time. This is handy in scenarios where a shared resource
    is read frequently by many threads but updated infrequently. There are two reader-writer
    lock classes that are provided by the .NET Framework: `ReaderWriterLock` and `ReaderWriterLockSlim`.
    `ReaderWriterLock` is almost outdated now since it can incur potential deadlocks,
    reduced performance, complex recursion rules, and upgrading or downgrading of
    locks. We will discuss `ReaderWriterLockSlim` in more detail later in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to signaling primitives
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of parallel programming is task coordination. While creating
    tasks, you may come across a producer/consumer scenario where a thread (the consumer)
    is waiting for a shared resource to be updated by another thread (the producer).
    Since the consumer doesn't know when the producer is going to update the shared
    resource, it keeps on polling the shared resource, which can lead to race conditions.
    Polling is highly inefficient in dealing with these scenarios. It is better to
    use the signaling primitives that are provided by the .NET Framework. With signaling
    primitives, the consumer thread is paused until it receives a signal from the
    producer thread. Let's discuss some common signaling primitives, such as `Thread.Join`,
    `WaitHandles`, and `EventWaitHandlers`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Join
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the simplest way in which we can make a thread wait for a signal from
    another thread. `Thread.Join` is blocking in nature, which means that the caller
    thread is blocked until the joined thread is complete. Optionally, we can specify
    a timeout that allows the blocked thread to come out of its blocking state once
    the timeout has been reached.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will create a child thread that simulates a long-running
    task. Once complete, it will update the output in the local variable, which is
    called `result`. The program is supposed to print the result `10` to the console.
    Let''s try to run the code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5be7850-e091-49c4-8be9-8d495b974ed5.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'We expected the result to be `10`, but it has come out as `0`. This happened
    because the main thread that was supposed to write the value runs before the child
    thread has finished execution. We can achieve the desired behavior by blocking
    the main thread until the child thread completes. This can be done by calling
    `Join()` on the child thread, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the code again now, we will see the desired output after a wait of
    five seconds, during which the main thread is blocked:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29f82897-6ec0-4906-b64e-f59cccc732df.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: EventWaitHandle
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `System.Threading.EventWaitHandle` class represents a synchronization event
    for a thread. It serves as a base class for the `AutoResetEvent` and `ManualResetEvent`
    classes. We can signal an `EventWaitHandle` by calling `Set()` or `SignalAndWait()`.
    The `EventWaitHandle` class doesn't have any thread affinity, so it can be signaled
    by any thread. Let's learn more about `AutoResetEvent` and `ManualResetEvent`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: AutoResetEvent
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refers to `WaitHandle` classes that are automatically reset. Once they
    are reset, they allow one thread to pass through the barrier that is created.
    As soon as the thread is passed, they are set again, thereby blocking threads
    until the next signal.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are trying to find out the sum of 10 numbers in
    a thread-safe manner, without using locks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an `AutoResetEvent` with the initial state as non-signaled, or
    `false`. This means that all the threads should wait until a signal is received.
    If we set the initial state to signaled, or `true`, the first thread will go through
    while the others wait for a signal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create a signaling task that fires a signal 10 times per second using
    the `autoResetEvent.Set()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare a variable sum and initialize it to `0`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a parallel `for` loop that creates 10 tasks. Each task will start immediately
    and wait for a signal to enter, thereby blocking at the `autoResetEvent.WaitOne()`
    statement. After every second, a signal will be sent by the signaling task and
    one thread will enter and update the `sum`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3369c0d3-6e1a-4209-a1d0-a27351c60e85.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: As you can see, all 10 tasks blocked initially and released one per second after
    receiving the signal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ManualResetEvent
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refers to wait handles that need to be reset manually. Unlike `AutoResetEvent`,
    which only allows one thread to pass per signal, `ManualResetEvent` allows threads
    to keep passing through until it is set again. Let's try to understand this using
    a simple example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we need to make 15 service calls in batches of 5
    in parallel, with a 2-second delay between each batch. While making the service
    call, we need to make sure that the system is connected to the network. To simulate
    the network status, we will create two tasks: one that signals the network off
    and one that signals the network on.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a manual reset event with the initial state *off*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we''ll create two tasks that simulate the network turning on and off
    by firing the network *off* event every two seconds (which blocks all the network
    calls) and the network *on* event every five seconds (which allows all the network
    calls to go through):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see from the preceding code, we have signaled a manual reset event
    every five seconds using `manualResetEvent.Set()`. We turn it off every two seconds
    using `manualResetEvent.Reset()`. The following code makes the actual service
    calls:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see from the preceding code, we have created a `for` loop that creates
    five tasks in each iteration with a sleep interval of two seconds between iterations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Before making service calls, we wait for the network to be up by calling `manualResetEvent.WaitOne();`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we''ll receive the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bab3114-6be3-4e91-8980-4779dac5779e.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: As you can see, five tasks are started and blocked immediately to wait for the
    network to be up. After five seconds, when the network is up, we signal using
    the `Set()` method and all five threads pass through to make the service call.
    This is repeated with each iteration of the `for` loop.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: WaitHandles
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`System.Threading.WaitHandle` is a class that inherits from the `MarshalByRefObject`
    class and is used to synchronize threads that are running in an application. Blocking
    and signaling are used to synchronize threads using wait handles. Threads can
    be blocked by calling any of the methods of the `WaitHandle` class. They are released,
    depending on the type of signaling construct that is selected. The methods of
    the `WaitHandle` class are as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`WaitOne`: Blocks the calling thread until it receives a signal from the wait
    handles that it''s waiting for.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitAll`: Blocks the calling thread until it receives a signal from all of
    the wait handles it''s waiting for.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example that shows us how `WaitAll` works:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is an example that makes use of two threads to simulate two different
    service calls. Both threads will execute in parallel but will wait at `WaitHandle.WaitAll(waitHandles)`
    before printing the sum to the console:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8381fd4-8d56-4b68-aeca-cd815f15d19e.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '`WaitAny`: Blocks the calling thread until it receives a signal from any of
    the wait handles it''s waiting for.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the signature of the `WaitAny` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here is an example that makes use of two threads to perform an item search.
    Both threads will execute in parallel and the program waits for any of the threads
    to finish execution at the `WaitHandle.WaitAny(waitHandles)` method before printing
    the item index to the console.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two methods, binary search and linear search, that perform a search
    using binary and linear algorithms. We want to get a result as soon as possible
    from either of these methods. We can achieve this via signaling using `AutoResetEvent` 
    and store the results in the `findIndex` and `winnerAlgo` global variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code calls both algorithms in parallel using `ThreadPool`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`SignalAndWait`: This method is used to call `Set()` on a wait handle and calls `WaitOne`
    for another wait handle. In a multithreaded environment, this method can be utilized
    to release one thread at a time and then resets to wait for the next thread:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Lightweight synchronization primitives
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Framework also provides lightweight synchronization primitives, which
    are better in performance than their counterparts. They avoid dependency on kernel
    objects such as wait handles wherever possible, so they only work inside the process.
    These primitives should be used when the thread's wait time is short. We can divide
    them into two categories, both of which we'll look at in this section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Slim locks
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slim locks are slim implementations of legacy synchronization primitives that
    can improve performance by reducing overheads.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the legacy synchronization primitives and their slim
    counterparts:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/254c3dd1-bfc8-4e51-b3fd-0d025205ff9a.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Let's try to learn more about slim locks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: ReaderWriterLockSlim
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ReaderWriterLockSlim` is a lightweight implementation of `ReaderWriterLock`.
    It represents a lock that can be used to manage protected resources in a way that
    allows multiple threads to share read access while allowing only one thread write
    access.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses `ReaderWriterLockSlim` to protect access on a list
    that is shared by three reader threads and one writer thread:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of this code is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8c8ea67-cbde-4075-92ef-5fba32c0e226.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: SemaphoreSlim
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SemaphoreSlim` is a lightweight implementation of `semaphore`. It throttles
    access to a protected resource to a number of threads.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slim version of the `semaphore` program that we showed earlier in
    this chapter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The difference we can see here, apart from replacing the `Semaphore` class with `SemaphoreSlim`,
    is that we now have the `Wait()` method instead of `WaitOne()`. This makes much
    more sense as we are allowing more than one thread to pass through.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Another important difference is that `SemaphoreSlim` is always created as a
    local `semaphore`, unlike `semaphore`, which can be created globally as well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ManualResetEventSlim
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ManualResetEventSlim` is a lightweight implementation of `ManualResetEvent`.
    It has better performance and less overhead than `ManualResetEvent`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an object using the following syntax, just like `ManualResetEvent`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Just like other slim counterparts, one major difference here is that we have
    replaced the `WaitOne()` method with `Wait()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: You can try running some `ManualResetEvent` demonstration code by making the
    preceding changes and see if it works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Barrier and countdown events
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The .NET Framework has some built-in signaling primitives that help us synchronize
    multiple threads without us having to write lots of synchronization logic. All
    the synchronization is handled internally by the provided data structures. In
    this section, let''s discuss two very important signaling primitives: `CountDownEvent`
    and `Barrier`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**CountDownEvent**: The `System.Threading.CountDownEvent` class refers to an
    event that''s signaled when its count becomes 0.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Barrier**: The `Barrier` class allows multiple threads to run without having
    the master thread controlling them. It creates a barrier that participating threads
    must wait in until all the threads have arrived. `Barrier` works well for cases
    where work needs to be carried out in parallel and in phases.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A case study using Barrier and CountDownEvent
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, let's say we need to fetch data from two services that are dynamically
    hosted. Before fetching the data from service one, we need to host it. Once the
    data has been fetched, it needs to be closed down. Only when service one has been
    closed down can we start service two and fetch data from it. The data needs to
    be fetched as quickly as possible. Let's create some code to meet the requirements
    of this scenario.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Barrier` with `5` participants:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create two `CountdownEvents` that will trigger the start or close of services
    when six threads have passed through it. Five worker tasks will participate, along
    with a task that will manage the start or close of services:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, create another `CountdownEvent` with a count of `5`. This refers to
    the number of threads that can pass through before the event is signaled. `CountdownEvent`
    will trigger when all the worker tasks finish executing:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is our `serviceManagerTask` implementation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the method that is executed by the worker tasks:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67c1de2f-4302-412d-817c-3fad0b113ae1.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: In this section, we have looked at various built-in signaling primitives that
    help make code synchronization easier without the need to lock ourselves as a
    developer. Blocking still comes at a performance cost as it involves context switching.
    In the next section, we will look at some spinning techniques that can help remove
    that context switching overhead.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: SpinWait
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we mentioned that spinning is much more efficient
    than blocking for smaller waits. Spinning has fewer kernel overheads related to
    context switching and transitioning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `SpinWait` object as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, wherever we need to make a `spin`, we can just call the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: SpinLock
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locks and interlocking primitives can significantly slow down performance if
    the wait time to get a lock is very low. `SpinLock` provides a lightweight, low-level
    alternative to locking. `SpinLock` is a value type, so if we want to use the same
    object in multiple places, we need to pass it by a reference. For performance
    reasons, even when `SpinLock` hasn't even acquired the lock, it yields the time
    slice of the thread so that the garbage collector can work efficiently. By default,
    `SpinLock` doesn't support thread tracking, which refers to determining which
    thread has acquired the lock. However, this feature can be turned on. This is
    only recommended for debugging and not for production as it reduces performance.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取锁的等待时间非常短，锁和互锁原语可能会显著降低性能。`SpinLock`提供了一种轻量级、低级别的替代锁定方法。`SpinLock`是一个值类型，因此如果我们想在多个地方使用相同的对象，我们需要通过引用传递它。出于性能原因，即使`SpinLock`甚至还没有获取锁，它也会让出线程的时间片，以便垃圾收集器可以有效工作。默认情况下，`SpinLock`不支持线程跟踪，这意味着确定哪个线程已经获取了锁。但是，这个特性可以被打开。这只建议用于调试，而不是用于生产，因为它会降低性能。
- en: 'Create a `SpinLock` object as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SpinLock`对象如下：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a method that will be called by various threads and update a global
    static list:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个将被各个线程调用并更新全局静态列表的方法：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, the lock is acquired using `_spinLock.Enter(ref lockTaken)`
    and released via `_spinLock.Exit(false)`**.** Everything between these two statements
    will be executed as synchronized between all the threads.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，锁是使用`_spinLock.Enter(ref lockTaken)`获取的，并且通过`_spinLock.Exit(false)`释放。在这两个语句之间的所有内容将在所有线程之间同步执行。
- en: 'Let''s call this method in a parallel loop:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个并行循环中调用这个方法：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the synchronized output if we had used locking primitives:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用锁定原语，这里是同步的输出：
- en: '![](img/66d8c9c2-ca57-40d0-bd38-97c542db9ed7.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66d8c9c2-ca57-40d0-bd38-97c542db9ed7.png)'
- en: As a rule of thumb, if we have small tasks, context switching can be completely
    avoided by using spinning.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果我们有小任务，可以通过自旋完全避免上下文切换。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the synchronization primitives that are
    provided by .NET Core. Synchronized primitives are a must if you want to write
    parallel code and ensure that it is correct, even when multiple threads are working
    on it. Synchronization primitives come with performance overheads and the use
    of their slim counterparts is advised wherever possible.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了.NET Core提供的同步原语。如果要编写并行代码并确保其正确性，同步原语是必不可少的，即使多个线程在处理它。同步原语会带来性能开销，建议尽可能使用它们的精简版本。
- en: We learned about signaling primitives as well, which can come in very handy
    when threads need to work on some external events. We also discussed the barrier
    and countdown events, which help us avoid code synchronization issues without
    the need to write additional logic. Finally, we introduced some spinning techniques,
    which take away performance overheads that arise from blocking code, that is, `SpinLock`
    and `SpinWait`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了信号原语，当线程需要处理一些外部事件时，这些原语非常有用。我们还讨论了屏障和倒计时事件，它们帮助我们避免代码同步问题，而无需编写额外的逻辑。最后，我们介绍了一些自旋技术，它们消除了由阻塞代码引起的性能开销，即`SpinLock`和`SpinWait`。
- en: In the next chapter, we will learn about the various data structures provided
    by .NET Core. These are synchronized automatically and are parallel at the same
    time.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解.NET Core提供的各种数据结构。这些数据结构是自动同步的，同时也是并行的。
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these can be used for cross-process synchronization?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中哪个可以用于跨进程同步？
- en: '`Lock`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁
- en: '`Interlocked.Increment`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interlocked.Increment`'
- en: '`Interlocked.MemoryBarrierProcessWide`'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interlocked.MemoryBarrierProcessWide`'
- en: Which of these is not a valid memory barrier?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是有效的内存屏障？
- en: Read memory barrier
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取内存屏障
- en: Half memory barrier
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 半内存屏障
- en: Full memory barrier
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整内存屏障
- en: Read and execute memory barrier
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和执行内存屏障
- en: From which of the following states can we not resume a thread?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能从以下哪种状态恢复线程？
- en: '`WaitSleepJoin`'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待、休眠、加入
- en: '`Suspended`'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停
- en: '`Aborted`'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`中止`'
- en: An unnamed `semaphore` can provide synchronization where?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个无名的`信号量`可以提供同步的地方？
- en: Within process
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程内部
- en: Across process
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨进程
- en: Which of these constructs support tracking threads?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些结构中哪个支持跟踪线程？
- en: '`SpinWait`'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpinWait`'
- en: '`SpinLock`'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpinLock`'

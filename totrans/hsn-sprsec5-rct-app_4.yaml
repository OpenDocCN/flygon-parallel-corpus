- en: Authentication Using CAS and JAAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter picks up from where we left off in the previous chapter by looking
    at other authentication mechanisms, namely CAS and JAAS, supported by Spring Security.
    Again, this is also a fully hands-on coding chapter, and we will build small applications,
    most of them starting from the base application that we built in [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*. These authentication mechanisms are well-known in
    the industry and many enterprises have these as established mechanism by which
    they authenticate the user and give access to many of their employee and consumer
    facing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the authentication mechanisms has a project that you can see in the
    book’s GitHub page. However, in the book, we will only cover important aspects
    of the sample code to reduce clutter within the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Authentication and Authorization Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom AuthenticationEntryPoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password Encoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <q>The</q> Central Authentication Service (CAS) <q>is a single-sign-on/single-sign-off
    protocol for the web. It permits a user to access multiple applications while
    providing their credentials (such as userid and password) only once to a central
    CAS Server application.</q>
  prefs: []
  type: TYPE_NORMAL
- en: <q>– CAS Protocol Specification</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'CAS is an open source, platform-independent, central **single sign-on** (**SSO**)
    service supporting a variety of well-known protocols. Spring Security has first-class
    support for CAS, and the implementation is quite simple for an enterprise having
    a central CAS server. CAS is based on Spring Framework, and the architecture is
    quite simple, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aed55c9b-b2b1-43d3-99ad-f9414a16474a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: CAS architecture (figure adapted from https://apereo.github.io)'
  prefs: []
  type: TYPE_NORMAL
- en: The **CAS server** is a Java servlet-based application built on Spring Framework
    (Spring MVC and Spring Web Flow). It authenticates and grants access to CAS-enabled
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Upon the successful login of the user, an SSO session is created, and the server
    issues a **ticket-granting-ticket** (**TGT**), and this token is validated against
    the backend for subsequent calls from the client.
  prefs: []
  type: TYPE_NORMAL
- en: The **CA****S** **client** is a CAS-enabled application that communicates with
    CAS using supported protocols (CAS, SAML, OAuth, and so on). A number of language
    supports are already available for CAS, and a number of applications have implemented
    this methodology. Some of the well-known applications are Atlassian products (JIRA
    and Confluence), Drupal, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the authentication flow (sequence diagram) involving
    a CAS server and client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60a7c9a-1ea7-4707-ab9f-066eeaec965c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: CAS authentication flow'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a working hands-on example now. We will have to create a CAS server
    and then a client that uses the CAS server to connect and get itself authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: CAS server setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CAS project source code can be found in GitHub at [https://github.com/apereo/cas](https://github.com/apereo/cas).
    It is not really required to check out the source code, build the CAS server,
    and then deploy it. WAR overlay is an approach wherein, rather than downloading
    the source and building, we get a pre-built CAS web application and then we can
    customize certain behavior as needed for achieving our use case. We will be using
    this approach to set up our CAS server. Also, we will use Maven-based WAR overlay,
    which can be found in GitHub at [https://github.com/apereo/cas-overlay-template](https://github.com/apereo/cas-overlay-template).
  prefs: []
  type: TYPE_NORMAL
- en: Git clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch your favorite command prompt and clone the CAS overlay project into
    your desired project. I am going to create a folder named `cas-sample`, wherein
    I will clone the server in the `server` folder by executing the following command
    from the `cas-sample` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding additional dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CAS server doesn''t allow any client to connect to it. Each client has
    to be registered with the desired CAS server. There are multiple mechanisms by
    which we can register a client to the server. We will use the JSON/YML configuration
    to register our client to the server. Go ahead and add the following dependency
    to your `pom.xml` file within the server project that you just cloned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of the versions in the `pom.xml` file are managed by the parent POM.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the resources folder in the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `server` project, create a folder called `src/main/resources`. Copy
    the `etc` folder within the `server` folder into `src/main/resources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the application.properties file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now fill in the following details in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file sets the port and SSL keystore values (a very important step
    in setting up a CAS server), and also sets up the CAS server `config` folder.
    Clearly, we need to create a keystore as indicated in this file.
  prefs: []
  type: TYPE_NORMAL
- en: Please note, the overlay project has a file, namely the `build.sh` file, that
    contains most of these details in it. We are manually doing this to have a clear
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The last line in `application.properties` sets up a test user with the credentials `casuser`/`password`,
    which can be used to log into the CAS server for various demo purposes. This approach
    is not recommended in the production setup.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local SSL keystore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the `cas-sample/server/src/main/resources/etc/cas` folder in a
    shell and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the successful execution of the preceding command
    in a command prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca9b9d48-46a3-4470-aac9-c83c8c497c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Creation of SSL keystore'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that for the SSL handshake to work properly, most of
    the values while generating the keystore are put as localhost. This is an important
    step and needs to be followed without fail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the .crt file to be used by the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the client to connect to the CAS server, out of the generated keystore,
    we need to create a `.crt` file. In the same folder (`cas-sample/server/src/main/resources/etc/cas`),
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When asked for a password, provide the same password (we have set the password
    as `password`). Executing the preceding command will create `thekeystore.crt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the .crt file to Java and the JRE cacert keystore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following command to find your Java installation directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, execute the following command directly to add the `.crt` file
    to Java cacerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows successful execution of the preceding command in
    a command prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d6189e2-8121-45a1-84e2-d61464d841a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Exporting .crt file to Java keystore'
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a client, make sure that the JDK used is the same as the one
    in which we have added the `.crt` file. To reflect the certification addition
    on to Java, a restart of the machine is suggested.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CAS server project and running it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From within the cas-sample/cas-server folder, execute the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, as shown in the following figure, you should see a
    log message which says READY:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60793f9a-7ac4-424f-8cb7-c3ed8951cf73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: CAS server ready logging'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open a browser and navigate to the URL `https://localhost:6443/cas`. This
    will navigate you to the default login form of the CAS server. Enter the default
    credentials (`casuser`/`Mellon`) and you are in. Most browsers would say that
    the connection is insecure. Add the domain as an exception and soon after that
    the application will work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bae5e52-91be-4143-9e0e-4dd08597257a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Default CAS server login form'
  prefs: []
  type: TYPE_NORMAL
- en: Log in with the demo test user (`testcasuser`/`password`) and you should be
    logged in and navigated to a user home page.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a client with the CAS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, every client has to be registered with the CAS server
    to allow participation in SSO. The section shows how we can register a client
    with the CAS server.
  prefs: []
  type: TYPE_NORMAL
- en: JSON service configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways by which a client/service can register itself to a CAS server. We
    will be using JSON configuration here and have already included dependencies to
    our `pom.xml` file in the earlier step. Apart from JSON, other formats such as
    YAML, Mongo, LDAP and others do exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder named `clients` in the `src/main/resources` folder. Create
    a new file in the newly created folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file with the name `newYmlFile-5000.yml`. Let''s go into the details
    of a couple of important attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serviceId`: URL, in a regular expression pattern, of clients who want to connect
    to the CAS server. In our example, we refer to a client Spring Boot application
    running on port `9090`, which connects to the CAS server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: unique identifier for this configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other configurable attributes are documented in the official website at [https://goo.gl/CGsDp1](https://goo.gl/CGsDp1).
  prefs: []
  type: TYPE_NORMAL
- en: Additional application.properties file changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, we let the CAS server about the usage of YML configuration and
    the location to find these YMLs in the server. Add the following property to the
    `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's good practice to separate CAS-related configuration properties into a different
    properties file. So, go ahead and create a `cas.properties` file and include CAS-related
    properties there.
  prefs: []
  type: TYPE_NORMAL
- en: CAS client setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Spring Initializr to create our CAS client project setup. We used
    a similar approach earlier. Let's go through it once again.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap Spring project using Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit [http://start.spring.io/](http://start.spring.io/) and enter the following
    details as shown in the following figure. Make sure you select the right dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbf118e6-2bf0-48f2-ab88-21c044d2548f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Spring Initializr for creating secured-cas-client project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Generate Project button and download the ZIP file to a folder
    of your choice (I will be keeping this inside the `cas-sample` folder). Execute
    the `unzip` command as follows. I am using macOS for running all my sample application,
    so I will be using commands, if any, suitable for this platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Including CAS libraries in pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify your project''s `pom.xml` by adding the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Changing the application.properties file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just to make sure that we don''t use any other commonly used ports, we are
    going to set the client to listen to port `9090`. In the CAS server, we have also
    configured it so that the client will be listening to port `9090`. Add the following
    property to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Additional bean configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now set up various beans, as needed by the CAS Spring Security module.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceProperties bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Convey to CAS that this is your CAS client/service by setting up this bean.
    Open `SpringBootCasClientApplication.java` and add the following bean definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The URL `http://localhost:9090/login/cas` that is configured will internally
    get mapped to `CasAuthenticationFilter`. The parameter `sendRenew `is set to `false`.
    Being set as `false`, this tells the login service that username/password is required
    to gain access to the service, every time. It also gives the user access to all
    services/client without having to enter a username/password (if already done once).
    When logged out, the user is logged out automatically from all services.
  prefs: []
  type: TYPE_NORMAL
- en: AuthenticationEntryPoint bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following code. Quite straightforward, isn''t it?. This
    is where we let  know where our CAS server is running. When a user tries to log
    in, the application will be redirected to this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: TicketValidator bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the client application gets a ticket that has already been given to a
    particular user, this bean is used to validate its authenticity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: CasAuthenticationProvider bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bind all the beans declared earlier to the authentication provider bean. We
    will be loading users from a static list provided as part of `UserDetailsService `in
    the authentication provider. In a production scenario, this will point to a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this we are ready to set up the all-important Spring Security configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s bring in the bean references that we have done in the previous step
    to the Spring Security configuration file. Create a new Java file called `SpringSecurityConfig` and
    add member variables. After that, create a constructor with `@Autowired` annotation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When a user accesses a client application that is secured by a CAS server, the
    configured bean `AuthenticationEntryPoint` is triggered, and the user is taken
    to the CAS server URL that is configured in this bean. Once the user enters credentials
    and submits the page, the CAS server authenticates the user and creates a service
    ticket. This ticket is now appended to the URL and the user is taken to the requested
    client application. The client application uses the `TicketValidator `bean to
    validate the ticket with the CAS server and, if valid, allows user to access the
    requested page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to override a couple of important methods before we configure our HTTP
    security. The first method uses `AuthenticationManagerBuilder`, in which we tell
    it to use our `AuthenticationProvider`. Please create the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now override another method that indicates to the `AuthenticationManager `to
    put our created `AuthenticationProvider` in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to create a filter named `CasAuthenticationFilter `(as a bean),
    which actually intercepts the requests and does CAS ticket validation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CasAuthenticationFilter bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating the `CasAuthenticationFilter` bean is quite straightforward, as we
    just assign the `serviceProperties `that we created to the `CasAuthenticationFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final setup in our CAS client project setup. We will have an unsecured
    page containing a link to a secured page. When the secured page is accessed, CAS
    SSO kicks in and the user is navigated to the CAS authentication page. Once you
    log in using the credentials (`casuser`/`password`), the user is taken to the
    secured page, where we display the authenticated username.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an `ndexController` that has the root folder routing (`/`). This
    navigates the user to the `index.html` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `IndexController.java` in a new package (preferably in the controllers
    package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `index.html` file in the `src/resources/templates` folder with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new controller named `CasController.java` within the same controllers
    package. We will be mapping all secured pages as well as setting up various request
    mappings in this controller. In the controller class, copy the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new HTML file named `secured.html` with the following content. This
    is our secured page and will just display the authenticated username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start the CAS server (within `cas-server`, run `./build.sh run`). After that,
    start the spring boot project (`secured-cas-client`) by executing `./mvnw spring-boot:run`.
    Navigate your browser to `http://localhost:9090`. This will take the user to `index.html`,
    and when they click on the link (which navigates to the `secured.html` page),
    the user is taken to the CAS authentication page. To be authenticated, enter the
    CAS credentials and, with the ticket set as query string, you will then be taken
    to the secured page. The secured page validates the ticket with the CAS server
    and then displays the username.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete our CAS sample using Spring Security. In the next section,
    similar to CAS, we will detail usage of JAAS authentication by employing Spring
    Security.
  prefs: []
  type: TYPE_NORMAL
- en: Java Authentication and Authorization Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Authentication and Authorization Service** (**JAAS**) ([https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html](https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html))
    implements a Java version of the standard **Pluggable Authentication Module**
    (**PAM**) framework. It was introduced as an optional package (extension) to the
    J2SDK (1.3) and then was integrated into the J2SDK 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JAAS is a standard library which provides your application with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A representation of identity (principal) by providing credentials (username/password
    – subject).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login service that will call back your application to gather credentials from
    user and then returns a subject after successful authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A mechanism to grant necessary grants (authorization) to a user after successful
    authentication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0cdf1f55-cdf8-4ce3-a790-4a1a28c1f976.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Working of JAAS'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, JAAS has predefined login modules for most
    of the login mechanisms built in. Custom login modules can be imported or built
    according to application requirements. JAAS allows application to be independent
    from the actual authentication mechanism. It's truly pluggable, as new login modules
    can be integrated without any change to the application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'JAAS is simple and the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application instantiates a `LoginContext` object and invokes appropriate
    (controlled by configuration) `LoginModule`, which performs authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the authentication is successful, the *s**ubject* (who runs the code) is
    updated with principle and credentials by `LoginModule`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soon after that, JAAS kick starts the authorization process (using standard
    Java SE access control model). Access is granted based on the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codesource**: where the code originated and who signed the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The user**: who (also called as **subject**) is running the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a rough idea of JAAS and its working, we will see working of
    JAAS using Spring Security by going through an example in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample application that we are going to build is very similar to the one
    that we created at the start of [Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml),
    *Authentication Using SAML, LDAP, and OAuth/OIDC*. Many aspects are similar but
    differ in a subtle manner. Each step will be explained; however, at times we won't
    go into details as we have seen some aspects in earlier samples.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating a Maven project using the IntelliJ IDE. Add the following
    dependencies and build setup in your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We add Spring Framework, Spring Security, JSP/JSTL, and the logging framework
    (SLF4J and Logback) dependencies. We will be using an embedded jetty server (look
    at the build section) to run our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up LoginModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LoginModule` is responsible for authenticating a user. We will be creating
    our own `LoginModule` named `JaasLoginModule `and then implementing the `login`
    method. Being a sample application, our login logic is quite trivial. The `LoginModule` interface
    has to be implemented for you to write your own custom login module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class, `JaasLoginModule.java` (which implements `LoginModule`), and
    implement all the methods. In this class, we will be focusing on two important
    methods. In the `initialize` method, we get all the necessary information, such
    as username/password/subject, that is stored as field variables to be used in
    our main `login` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `login` method, we will log in using the values stored in the `initialize`
    method. In our case, if the hard-coded username/password is valid, set the principal
    in the subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a custom principal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created our own custom principal class by implementing the `java.security.Principal`
    interface. It''s a very simple class in which we take in the username through
    a constructor and then use that to return in the `getName` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a custom AuthorityGranter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AuthorityGranter `is entrusted to provide relevant roles to the authenticated
    user. We will be creating our own custom class by implementing `org.springframework.security.authentication.jaas.AuthorityGranter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Being a sample implementation, in this class, we look at the logged in users
    username and grant a hard-coded role to it. In real-life applications, we would
    be doing something more serious in here by actually querying a database and then
    granting appropriate roles to the logged in user.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to have a number of configuration files (Java configuration) in our
    sample, most of which have been covered earlier. For the remaining files (yet
    to be covered), we will either run through them quickly or go into details when
    they are covered.
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't have any application-specific configuration here but it's always good
    to have such a file in your application. We have `ApplicationConfig.java` as our
    application-level Java configuration (it doesn't have any content in it).
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in the following code, here we will be creating Spring MVC specific
    Java configurations (`SpringMVCConfig.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, set the view's *prefix* and *suffix*. Make sure that
    your login view controller is added explicitly, as we don't have a route defined
    in our controller (we will see the controller later).
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very important configuration example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an `AuthenticationProvider `bean. We will be using our custom `LoginModule `and
    then use `org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider` to
    set things up. We then set this authentication provider as the global provider.
    Any request will pass through this provider (`SpringSecurityConfig.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next most important method is the `configure` method, in which we will
    make sure that we set the right path which need to be secured and we will also
    set up some important configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just have one controller in which we will configure all the routes (`JaasController.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Setting up pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a few trivial pages. I don''t want to paste the code in here, as it
    is quite self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login.jsp`: Our custom login page, which is used to collect username and password
    from the end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user.jsp`: The page that is set as root in the sample. After login, the user
    is navigated to this page. We just print the session ID and also the username
    to showcase the login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moresecured.jsp`: This is just to showcase how the role of the user matters.
    This page can only be accessed by a user having the `ADMIN` role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noaccess.jsp`: When the user doesn''t have access to any page, this dummy
    page comes in for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full sample project can be found in the book’s GitHub page within the *jetty-jaas-authentication *project.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the root of the project, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Open a browser and navigate to `http://localhost:8080`. You will be provided
    with a dirty-looking login page. Enter username/password (admin/password or user/password)
    and you will be navigated to the root page (`user.jsp`).
  prefs: []
  type: TYPE_NORMAL
- en: This completes our JAAS example using Spring Security. As shown in Figure 8
    above, JAAS can be used to achieve authentication using other protocols. One of
    the well-known mechanism is authentication using Kerberos protocol. Next brief
    section gives you a rough idea of how JAAS can be used to achieve Kerberos based
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAAS provides a number of built-in types of `LoginModule `and one of them is `rb5LoginModule`,
    which is used to authenticate users using the Kerberos protocol. So, indeed, JAAS
    methodology can be used to achieve Kerberos authentication within your Spring-based
    application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into some more important details about authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Custom AuthenticationEntryPoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A custom `AuthenticationEntryPoint` can be used to set necessary response headers,
    content-type, and so on before sending the response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint` class is
    a built-in `AuthenticationEntryPoint` implementation, which will get invoked for
    basic authentication to commence. A custom entry point can be created by implementing
    the `org.springframework.security.web.AuthenticationEntryPoint` interface. The
    following is an example implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When a client accesses resources without authentication, this entry point kicks
    in and throws a 401 status code (`Unauthorized`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring Security Java configuration file, make sure that the `configure`
    method has this custom `AuthenticationEntryPoint` defined, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Multiple AuthenticationEntryPoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security does allow you to configure multiple `AuthenticationEntryPoint` for
    your application, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Security 3.0.2, `org.springframework.security.web.authentication.DelegatingAuthenticationEntryPoint`
    looks at all declared `AuthenticationEntryPoint` in the configurations and executes
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Security 5.x, we have `org.springframework.security.web.server.DelegatingServerAuthenticationEntryPoint`,
    which uses reactive data types and brings in asynchronous nature to its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defaultAuthenticationEntryPointFor()` method in the Spring Security configuration
    can also be employed to set up multiple entry points looking at different URL
    matching (see the following code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: PasswordEncoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Spring Security 5, the framework allowed only one `PasswordEncoder`
    throughout the application and also had weak password encoders such as MD5 and
    SHA. These encoders also didn''t have dynamic salt, rather it had more static
    salt which had to be supplied. With Spring Security 5, there have been huge changes
    in this area and with the new version, the password encoding concept employs delegation
    and allows multiple password encoding within the same application. The password
    which has been encoded has a identifier prefixed to indicate what algorithm has
    been used (see the following example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This approach enables multiple encoding as needed within the application to
    be employed. If no identifier is mentioned, this means it uses the default encoder,
    which is `StandardPasswordEncoder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you decide on the password encoding, this can be used within the `AuthenticationManager`.
    One such example is the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security 5, as mentioned earlier, introduced a delegation approach by
    introducing `DelegationPasswordEncoder`. `DelegatingPasswordEncoder` has replaced `PasswordEncoder`
    and can be created by two approaches as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Approach 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`DelegatingPasswordEncoder` allows passwords to be validated against old encoding
    approaches and upgrades the password over a period of time without any hassle.
    This approach can be used to automatically upgrade passwords (old encoding to
    new encoding) as and when the user authenticates.'
  prefs: []
  type: TYPE_NORMAL
- en: Salt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make brute force attacks harder, while encoding we also can supply a random
    string. This random string is called **salt**. Salt text is included in `PasswordEncoder` as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained earlier, Spring Security works on servlet filters. There are number
    of built-in servlet filters that do almost all the necessary functionalities.
    If needed, Spring Security does provide a mechanism to write your own custom filter
    and can be plugged in at the right point in the filter chain execution. Create
    your own filter by extending `org.springframework.web.filter.GenericFilterBean`
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you create your own filter, plug it into the filter chain in the Spring
    Security configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can place the new filter before, after, or at a particular location in the
    filter chain. If you want to extend an existing filter, you have that provision
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered two more authentication mechanisms, namely
    CAS and JAAS, supported by Spring Security, through hands-on coding examples.
    Again, we have used the sample application build as part of [Chapter 2](e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml), *Deep
    Diving into Spring Security*, as a base to explain the working and implementation
    of other authentication mechanisms. We then covered some important concepts and
    the customization possible in Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we intentionally didn't use reactive programming in our coding
    examples. This chapter was aimed at making you understand the core concepts of
    each CAS and JAAS authentication mechanism by making use of the familiar Spring
    Web MVC application framework. We will cover reactive programming in more detail
    in [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml), *Integrating with
    Spring WebFlux*. We will start the next chapter by introducing you to Spring WebFlux
    and, in due course, implement Spring Security. While going through the main contents
    of [Chapter 5](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=168&action=edit#post_29), *Integrating
    with Spring WebFlux*, you will clearly understand that making the code examples
    in this chapter comply to reactive is quite easy.
  prefs: []
  type: TYPE_NORMAL

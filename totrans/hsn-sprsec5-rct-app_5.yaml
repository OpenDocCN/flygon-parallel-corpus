- en: Integrating with Spring WebFlux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Spring WebFlux集成
- en: One of the new features introduced as a part of Spring Framework 5 is the introduction
    of a new reactive web application framework, Spring WebFlux. WebFlux lives alongside
    the well-established web application framework Spring MVC. The book aims to introduce
    reactive parts of Spring Security in which Spring WebFlux is one of the core components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5引入的新功能之一是引入了一个新的响应式Web应用程序框架，Spring WebFlux。WebFlux与成熟的Web应用程序框架Spring
    MVC并存。该书旨在介绍Spring Security的响应式部分，其中Spring WebFlux是核心组件之一。
- en: Making your application reactive brings in an asynchronous nature to your application.
    Traditional Java applications used threads to achieve parallel and asynchronous
    nature to the application, however, usage of threads for a web application is
    not scalable and efficient in any manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的应用程序具有响应式特性会为您的应用程序带来异步性。传统的Java应用程序使用线程来实现应用程序的并行和异步特性，但是对于Web应用程序来说，使用线程是不可伸缩和高效的。
- en: This chapter starts by introducing you to the core differences between Spring
    MVC and Spring WebFlux. It then delves into the Spring Security module and how
    reactive aspects have been brought into it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了Spring MVC和Spring WebFlux之间的核心区别，然后深入探讨了Spring Security模块以及如何将响应式方面引入其中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Spring MVC versus WebFlux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC与WebFlux
- en: Reactive support in Spring 5
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 5中的响应式支持
- en: Spring WebFlux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring WebFlux authentication architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux身份验证架构
- en: Spring WebFlux authorization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux授权
- en: Sample project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例项目
- en: Customization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义
- en: Spring MVC versus WebFlux
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC与WebFlux
- en: Spring WebFlux was brought in as part of Spring 5 to bring in a new alternative
    to existing Spring MVC. Spring WebFlux brings in non-blocking event loop style
    programming to provide asynchronicity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux作为Spring 5的一部分引入，为现有的Spring MVC带来了一个新的替代方案。Spring WebFlux引入了非阻塞的事件循环式编程，以提供异步性。
- en: Event loop was brought in and made famous by Node.js. Node.js was able to perform
    non-blocking operations using single-threaded JavaScript by offloading operations
    to the system kernel whenever possible. The kernel, being multithreaded, is able
    to do these offloaded operations and after successful execution notifies Node.js
    through callbacks. There is a constantly running process that checks the call
    stack (where operations are stacked which need to be executed) and keeps executing
    processes in **First In, First Out** (**FIFO**) manner. If the call stack is empty,
    it looks into the *Event Queue* for operations. It picks them up and then moves
    them to the call stack to be further picked for execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是由Node.js引入并因此而出名。Node.js能够使用单线程的JavaScript执行非阻塞操作，通过在可能的情况下将操作卸载到系统内核。内核是多线程的，能够执行这些卸载的操作，并在成功执行后通过回调通知Node.js。有一个不断运行的进程来检查调用堆栈（其中堆叠了需要执行的操作），并以**先进先出**（**FIFO**）的方式继续执行进程。如果调用堆栈为空，它会查看*事件队列*中的操作。它会将它们拾起，然后将它们移动到调用堆栈中以供进一步执行。
- en: 'The following diagram shows what is in both web application frameworks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了两个Web应用程序框架中的内容：
- en: '![](img/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png)'
- en: 'Figure 1: Spring MVC and Spring WebFlux'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Spring MVC和Spring WebFlux
- en: As shown in the preceding figure, Spring MVC is based on the Servlet API (works
    on thread pools) and Spring WebFlux is based on reactive streams (it works on
    an event loop mechanism). Both the frameworks, however, supports commonly used
    annotations such as `@Controller` and also support some well-known servers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Spring MVC基于Servlet API（在线程池上工作），而Spring WebFlux基于响应式流（它基于事件循环机制）。然而，这两个框架都支持常用的注解，如`@Controller`，并且也支持一些知名的服务器。
- en: 'Let''s see the workings of Spring MVC and Spring WebFlux side-by-side in the
    following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下图中并排看一下Spring MVC和Spring WebFlux的工作方式：
- en: '![](img/bf631caa-8c2b-4e35-ab85-e1374c4005be.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf631caa-8c2b-4e35-ab85-e1374c4005be.png)'
- en: 'Figure 2: Working of Spring MVC and Spring WebFlux'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Spring MVC和Spring WebFlux的工作方式
- en: As you can see, the fundamental difference between the working of the two frameworks
    is that Spring MVC is blocking and Spring WebFlux is non-blocking.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这两个框架的工作方式的根本区别在于Spring MVC是阻塞的，而Spring WebFlux是非阻塞的。
- en: In Spring WebFlux, Servlet APIs behave as an adapter layer, enabling it to support
    both servlet containers such as **Tomcat** and **Jetty** and non-servlet runtimes
    such as **Undertow** and **Netty**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring WebFlux中，Servlet API充当适配器层，使其能够支持诸如**Tomcat**和**Jetty**等Servlet容器以及**Undertow**和**Netty**等非Servlet运行时。
- en: Spring MVC comprises synchronous APIs (Filter, Servlet, and so on) and blocking
    I/O (`InputStream`, `OutputStream`, and so on) as against Spring WebFlux's asynchronous
    APIs (`WebFilter`, `WebHandler`, and so on) and non-blocking I/O (Reactor Mono
    for *0..1* elements and Rector Flux for *0..N* elements).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC包括同步API（过滤器、Servlet等）和阻塞I/O（`InputStream`、`OutputStream`等），而Spring
    WebFlux包括异步API（`WebFilter`、`WebHandler`等）和非阻塞I/O（Reactor Mono用于*0..1*元素和Reactor
    Flux用于*0..N*元素）。
- en: 'Spring WebFlux supports various asynchronous and Reactive APIs, namely Java
    9 Flow API, RxJava, Reactor, and Akka Streams. By default, it uses Spring''s very
    own reactive framework, Reactor, and it does do its job quite well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持各种异步和响应式API，即Java 9 Flow API、RxJava、Reactor和Akka Streams。默认情况下，它使用Spring自己的响应式框架Reactor，并且它的工作相当出色：
- en: '![](img/f8ce06eb-8094-44e7-b218-18d92d1711fa.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8ce06eb-8094-44e7-b218-18d92d1711fa.png)'
- en: 'Figure 3: Spring WebFlux reactive API support'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：Spring WebFlux响应式API支持
- en: As mentioned earlier, Spring WebFlux was brought in as an alternative to Spring
    MVC. It doesn't mean in any way that Spring MVC is deprecated. Applications written
    in Spring MVC can continue running on the same stack without any migration to
    Spring WebFlux. If needs be, we can bring in reactive coding practices to an existing
    Spring MVC application by running a reactive client to make calls to remote services.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the features of the two web application frameworks in
    Spring, the next section will give an idea as to when to choose what framework
    while building your application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: When to choose what?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is quite good but that doesn't mean that we have to go
    reactive for every application. Along the same lines, not all the applications
    are a good fit for Spring WebFlux. Choose the framework by looking at the requirements
    and how these frameworks can solve them. If an application is working fine with
    Spring MVC as a framework, there is no need to port that to Spring WebFlux. In
    fact, as mentioned earlier, good parts of reactive can be brought into Spring
    MVC if needs be without much trouble.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the application already has blocking dependencies (JDBC, LDAP, and
    so on), then it's better to stick with Spring MVC as there would be complications
    bringing in reactive concepts. Even if we bring in reactive concepts, many parts
    of the application are in blocking mode, which will prevent taking full advantage
    of such a programming paradigm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Adopt Spring WebFlux if your application deals with streams of data (input and
    output). Also, consider this as the web application choice if scalability and
    performance is of utmost importance. By their sheer nature, asynchronous and non-blocking,
    these applications would be performant compared to synchronous and blocking. Being
    asynchronous, they can deal with latencies and are more scalable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Reactive support in Spring 5
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework 5 has extensive support for a reactive programming paradigm.
    Many of the modules have embraced this concept with both hands and are making
    it a first-class citizen. The following diagram summarizes the Spring 5 support
    of reactive:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc2a49cf-86fc-4206-978d-46f156a7d0ca.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Spring 5 and reactive support'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux module is a full-fledged web application framework built on top
    of a reactive programming paradigm (it uses Reactor and RxJava). Some of the early
    adopters of reactive programming in the Spring/Java ecosystem were **Spring Data**,
    **Spring Security**, and **Thymeleaf**. Spring Security has a number of features
    that supports reactive programming.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data has reactive support for Redis, MongoDB, Couchbase, and Cassandra.
    It also supports infinite streams (records emitted one by one in the form of a
    stream) from the database with `@Tailable`. JDBC inherently is blocking in nature,
    because of which, Spring Data JPA is blocking and cannot be made reactive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Reactive in Spring MVC
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Spring MVC is inherently blocking, some aspects can be made reactive
    by using reactive programming capabilities available as part of Spring 5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Spring MVC controller, you can employ reactive types, `Flux` and `Mono`,
    as shown in the following diagram. The only rule is that you can use these reactive
    types only as the controller''s return values:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f41618-09a4-408c-b922-567bdd742bd5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Spring MVC becoming non-blocking with usage of reactive types'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC annotations such as `@Controller`, `@RequestMapping`, and so on are
    also supported in Spring WebFlux. So converting a Spring MVC web application to
    Spring WebFlux can be done over a period of time in a slow-paced manner.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will go into a bit more detail on Spring WebFlux. There
    are two (programming model) ways by which Spring WebFlux can be used. They are
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Using annotations**: By using annotations such as `@Controller` similar to
    how it is been done in Spring MVC'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using functional style**: By using routing and handling with Java Lambdas'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用函数式风格**：使用Java Lambdas进行路由和处理'
- en: 'The following code shows the annotation-based style of using Spring WebFlux.
    We will be going through the entire code sample in subsequent sections in this
    chapter. This section, however, is aimed at giving an introduction before we delve
    deeper:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用Spring WebFlux的基于注解的风格。我们将在本章的后续部分中逐步介绍整个代码示例。然而，本节旨在在深入探讨之前进行介绍：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The functional-style programming model of Spring WebFlux uses two fundamental
    components:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux的函数式编程模型使用了两个基本组件：
- en: '`HandlerFunction`: Entrusted to handle an HTTP request. Equivalent to `@Controller`
    handler methods we have seen in our previous code snippet.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerFunction`：负责处理HTTP请求。相当于我们在之前的代码片段中看到的`@Controller`处理方法。'
- en: '`RouterFunction`: Entrusted to route an HTTP request. Equivalent to `@RequestMapping`
    in annotation-based.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunction`：负责路由HTTP请求。相当于基于注解的`@RequestMapping`。'
- en: HandlerFunction
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HandlerFunction
- en: '`HandlerFunction` accepts a `ServerRequest` object and returns `Mono<ServerResponse>`.
    Both `ServerRequest` and `ServerResponse` objects are immutable and fully reactive,
    built on top of Reactor.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFunction`接受一个`ServerRequest`对象，并返回`Mono<ServerResponse>`。`ServerRequest`和`ServerResponse`对象都是不可变的，并且完全是响应式的，建立在Reactor之上。'
- en: '`ServerRequest` exposes the body as `Mono` or `Flux`. Traditionally, `BodyExtractor`
    is used to achieve this. However, it also has utility methods which exposes these
    objects as shown in the following code. `ServerRequest` also gives access to all
    HTTP request elements, such as method, URI, and query string parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerRequest`将body公开为`Mono`或`Flux`。传统上，使用`BodyExtractor`来实现这一点。但是，它还具有实用方法，可以将这些对象公开为下面代码中所示的对象。`ServerRequest`还可以访问所有HTTP请求元素，如方法、URI和查询字符串参数：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ServerResponse` object gives you access to various HTTP responses. The
    `ServerResponse` object can be created by using a builder, which allows setting
    response status and response headers. It also allows you to set the response body:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerResponse`对象让您访问各种HTTP响应。`ServerResponse`对象可以通过使用构建器创建，允许设置响应状态和响应头。它还允许您设置响应体：'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`HandlerFunction` can be created using a Lambda function as in the following
    code and return `ServerResponse` with status 200 OK and with a body based on a
    `String`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFunction`可以使用Lambda函数创建，如下面的代码，并返回状态为200 OK的`ServerResponse`，并且基于`String`的body。'
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is recommended to group all `HandlerFunction` objects into a single class
    having multiple methods, each handling a specific function, as shown in the following
    code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将所有的`HandlerFunction`对象分组到一个单独的类中，每个方法处理一个特定的功能，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: RouterFunction
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterFunction
- en: Incoming requests are intercepted by `RouterFunction`, and, according to the
    configured route, it is navigated to the right `HandlerFunction`. If the route
    is matched; `RouterFunction` takes in `ServerRequest` and returns back `Mono<HandlerFunction>`.
    If not, empty `Mono` is returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的请求被`RouterFunction`拦截，并根据配置的路由导航到正确的`HandlerFunction`。如果匹配路由，则`RouterFunction`接受`ServerRequest`并返回`Mono<HandlerFunction>`。如果不匹配，则返回空的`Mono`。
- en: '`RouterFunction` is created as shown in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterFunction`如下面的代码片段所示创建：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`RequestPredicate` is a utility class that has predefined matching patterns
    for most of the common use cases, such as matching based on path, content type,
    HTTP method, and so on. An example code snippet for `RouterFunction` is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestPredicate`是一个实用类，具有大多数常见用例的预定义匹配模式，例如基于路径、内容类型、HTTP方法等的匹配。`RouterFunction`的示例代码片段如下：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multiple `RouterFunction` objects can be composed by invoking the following
    method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用以下方法组合多个`RouterFunction`对象：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is also a convenient method, as follows, which is a combination of the
    `RouterFunction.and()` and `RouterFunctions.route()` methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方便的方法，如下所示，它是`RouterFunction.and()`和`RouterFunctions.route()`方法的组合：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RouterFunction` for the previous `HandlerFunction` is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面`HandlerFunction`的`RouterFunction`如下：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spring WebFlux server support
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux服务器支持
- en: 'Spring Webflux supports a number of servers, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Webflux支持多个服务器，如下所示：
- en: Netty
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netty
- en: Jetty
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetty
- en: Tomcat
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat
- en: Undertow
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Undertow
- en: Servlet 3.1+ containers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet 3.1+容器
- en: Spring Boot 2+ uses Netty by default, when the web application framework selected
    is Spring WebFlux.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 2+在选择Spring WebFlux作为Web应用程序框架时，默认使用Netty。
- en: 'The `RouterFunction` created can be run on any of the servers listed previously.
    To do that, `RouterFunction` needs to be converted to `HttpHandler`, using the
    following method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`RouterFunction`可以在之前列出的任何服务器上运行。为了做到这一点，需要将`RouterFunction`转换为`HttpHandler`，使用以下方法：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to run the previously created `RouterFunction` in Netty, the following
    code snippet can be used:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在Netty中运行先前创建的`RouterFunction`，可以使用以下代码片段：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we look at our sample application in subsequent sections of this chapter,
    we will look at code for other Spring WebFlux supported servers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章的后续部分查看示例应用程序时，我们将查看其他Spring WebFlux支持的服务器的代码。
- en: Reactive WebClient
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式WebClient
- en: Spring WebFlux includes a reactive client named `WebClient`, enabling us to
    perform HTTP requests in a non-blocking manner and to use reactive streams. `WebClient`
    can be used as an alternative to `RestTemplate`, which is used more traditionally.
    `WebClient` exposes reactive `ClientHttpRequest` and `ClientHttpResponse` objects.
    The bodies of these objects consist of reactive `Flux<DataBuffer>`, as opposed
    to traditional blocking stream implementation (`InputStream` and `OutputStream`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux包括一个名为`WebClient`的响应式客户端，使我们能够以非阻塞的方式执行HTTP请求并使用响应式流。`WebClient`可以作为传统上更常用的`RestTemplate`的替代品。`WebClient`公开了响应式`ClientHttpRequest`和`ClientHttpResponse`对象。这些对象的body由响应式`Flux<DataBuffer>`组成，而不是传统的阻塞流实现（`InputStream`和`OutputStream`）。
- en: 'Create an instance of `WebClient`, perform a request, and then handle the response.
    The following is a code snippet showing the `WebClient` usage:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`WebClient`的实例，执行请求，然后处理响应。以下是显示`WebClient`用法的代码片段：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`WebClient` can be used from within both Spring MVC and Spring WebFlux web
    applications. `RestTemplate` usage can quite easily be swapped with `WebClient`,
    making use of the reactive advantages it provides.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient`可以在Spring MVC和Spring WebFlux Web应用程序中使用。`RestTemplate`的使用可以很容易地替换为`WebClient`，利用其提供的响应式优势。'
- en: In our sample project, we will cover the concepts and functionality of `WebClient`,
    using an example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将使用一个示例来介绍`WebClient`的概念和功能。
- en: Reactive WebTestClient
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式WebTestClient
- en: Similar to `WebClient`, Spring WebFlux provides you with a non-blocking, reactive
    client named `WebTestClient`, to test your reactive APIs on your server. It has
    utilities that make testing these APIs easily in a test environment setup. `WebTestClient`
    can connect to any of the servers, as detailed earlier over an HTTP connection
    and execute necessary tests. However, the client has the capability of running
    the tests with and without a running server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WebClient`类似，Spring WebFlux为您提供了一个非阻塞的响应式客户端`WebTestClient`，用于测试服务器上的响应式API。它具有使在测试环境设置中轻松测试这些API的实用程序。`WebTestClient`可以连接到任何服务器，如前面详细介绍的那样，通过HTTP连接执行必要的测试。但是，该客户端具有在运行服务器时运行测试和在没有运行服务器时运行测试的能力。
- en: '`WebTestClient` also has a number of utilities to verify the response produced
    by executing these server side APIs. It can quite easily bind itself to the WebFlux
    web application and mock necessary request and response objects to ascertain the
    API''s functional aspects. `WebTestClient` can mutate the headers as needed, to
    simulate the desired test environment. You can get an instance of `WebTestClient`
    for your entire application (by using the `WebTestClient.bindToApplicationContext`
    method), or you can restrict it to specific controller (using the `WebTextClient.bindToController`
    method), `RouterFunction` (using the `WebTestClient.bindToRouterFunction` method),
    and so on.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient`还有许多实用工具，可以验证执行这些服务器端API产生的响应。它可以很容易地绑定到WebFlux Web应用程序，并模拟必要的请求和响应对象，以确定API的功能方面。`WebTestClient`可以根据需要修改标头，以模拟所需的测试环境。您可以通过使用`WebTestClient.bindToApplicationContext`方法获取整个应用程序的`WebTestClient`实例，或者可以将其限制为特定的控制器（使用`WebTextClient.bindToController`方法），`RouterFunction`（使用`WebTestClient.bindToRouterFunction`方法）等等。'
- en: We will see a detailed example of how `WebTestClient` works in a subsequent
    hands-on section (The *Sample project* section, under the *Testing (WebTestClient)*
    sub-section).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在随后的实践部分（*示例项目*部分，*测试（WebTestClient）*子部分下）看到`WebTestClient`的工作示例。
- en: Reactive WebSocket
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式WebSocket
- en: Spring WebFlux includes a reactive `WebSocket` client and server support based
    on the Java WebSocket API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux包括基于Java WebSocket API的响应式`WebSocket`客户端和服务器支持。
- en: 'On the server, create `WebSocketHandlerAdapter`, and then map each of those
    handlers to the URL. Since we don''t cover `WebSocket` in our sample application,
    let''s go into a bit more detail:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，创建`WebSocketHandlerAdapter`，然后将每个处理程序映射到URL。由于我们的示例应用程序中不涉及`WebSocket`，让我们更详细地了解一下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `handle()` method takes in the `WebSocketSession` object and returns `Mono<Void>`
    when the handling of session is complete. `WebSocketSession` handles inbound and
    outbound messages using the `Flux<WebSocketMessage> receive()` and `Mono<Void>
    send(Publisher<WebSocketMessage>)` methods, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle()`方法接受`WebSocketSession`对象，并在会话处理完成时返回`Mono<Void>`。`WebSocketSession`使用`Flux<WebSocketMessage>
    receive()`和`Mono<Void> send(Publisher<WebSocketMessage>)`方法处理入站和出站消息。'
- en: 'In the web application Java configuration, declare a bean for `WebSocketHandlerAdpater`
    and create another bean to map the URL to the appropriate `WebSocketHandler`,
    as shown in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序Java配置中，声明`WebSocketHandlerAdpater`的bean，并创建另一个bean将URL映射到适当的`WebSocketHandler`，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Spring WebFlux also provides `WebSocketClient` and has abstractions for all
    of the web servers discussed earlier, such as Netty, Jetty, and so on. Use appropriate
    server abstractions and create the client, as shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux还提供了`WebSocketClient`，并为之前讨论的所有Web服务器提供了抽象，如Netty、Jetty等。使用适当的服务器抽象并创建客户端，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the client code, we can now subscribe to the `WebSocket`, endpoint and listen
    to messages and do the needful (basic `WebSocket` implementation). The code snippet
    for such a client on the frontend is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们现在可以订阅`WebSocket`端点并监听消息并执行必要的操作（基本的`WebSocket`实现）。前端的这样一个客户端的代码片段如下：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To keep the chapter focused and concise, we will not go over `WebSocket` security
    provided by Spring Security. In the last chapter of this book, we will quickly
    cover the `WebSocket` security, using an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章专注而简洁，我们将不讨论Spring Security提供的`WebSocket`安全性。在本书的最后一章中，我们将快速介绍`WebSocket`安全性，使用一个示例。
- en: Spring WebFlux authentication architecture
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux身份验证架构
- en: With the core Spring WebFlux concepts covered, we will now get into the crux
    of this chapter; introducing you to Spring Security for Spring WebFlux based reactive
    web applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了核心Spring WebFlux概念之后，我们现在将进入本章的重点；为您介绍Spring WebFlux基于响应式Web应用程序的Spring
    Security。
- en: 'As seen earlier, Spring Security in Spring MVC web applications is based on
    ServletFilter, and for Spring WebFlux, it is based on WebFilter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring MVC Web应用程序中的Spring Security基于ServletFilter，而Spring WebFlux中的Spring
    Security基于WebFilter：
- en: '![](img/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png)'
- en: 'Figure 6: Spring MVC and Spring WebFlux authentication approach'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Spring MVC和Spring WebFlux身份验证方法
- en: 'We saw Spring Security in detail in Spring MVC web applications in previous
    chapters. We will now look at the inner details of Spring Security authentication
    for a Spring WebFlux based web application. The following diagram shows the interaction
    of various classes when an authentication process kicks in for a WebFlux application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中详细了解了Spring MVC web应用中的Spring Security。现在我们将看一下基于Spring WebFlux的Web应用的Spring
    Security认证的内部细节。下图显示了在WebFlux应用程序的认证过程中各种类的交互：
- en: '![](img/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png)'
- en: 'Figure 7: Spring WebFlux authentication architecture'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Spring WebFlux认证架构
- en: The preceding diagram is quite self-explanatory, and is very similar to what
    you saw earlier for Spring MVC. The core difference is that `ServletFilter` is
    now replaced with `WebFilter`, and we have reactive-based classes for other blocking
    classes in Spring MVC. However, the core concepts of Spring Security remain intact
    with `WebFilter` dealing with many aspects in the initial authentication process;
    the core authentication is handled by `ReactiveAuthenticationManager` and related
    classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表相当不言自明，并且与您之前在Spring MVC中看到的非常相似。核心区别在于`ServletFilter`现在被`WebFilter`取代，并且我们在Spring
    MVC中有基于阻塞类的反应式类。然而，Spring Security的核心概念仍然保持完整，`WebFilter`处理初始认证过程中的许多方面；核心认证由`ReactiveAuthenticationManager`和相关类处理。
- en: Spring WebFlux authorization
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux授权
- en: 'Similar to authentication, the core concepts, in regard to authorization remains
    similar to what we have seen earlier in Spring MVC. However, the classes performing
    the operation have changed, and are, reactive and non-blocking. The following
    diagram shows the authorization-related main classes and their interactions in
    a Spring WebFlux application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证类似，就授权而言，核心概念与我们之前在Spring MVC中看到的相似。但是，执行操作的类已经改变，并且是响应式和非阻塞的。下图显示了Spring
    WebFlux应用程序中与授权相关的主要类及其交互：
- en: '![](img/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png)'
- en: 'Figure 8: Authorization-related classes in a Spring WebFlux application'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Spring WebFlux应用程序中与授权相关的类
- en: As we all know by now, Spring WebFlux security works on `WebFilter`, and `AuthorizationWebFilter` intercepts
    the request and uses `ReactiveAuthorizationManager` to check whether the `Authentication`
    object has access to a protected resource. `ReactiveAuthorizationManager` has
    two methods, namely, `check` (checks whether access is granted to an `Authentication`
    object) and `verify`(checks whether access has to be granted for an `Authentication`
    object). In the event of any exception, `ExceptionTranslationWebFilter` takes
    care of handling this by following the appropriate paths.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在都知道的那样，Spring WebFlux安全性基于`WebFilter`工作，`AuthorizationWebFilter`拦截请求并使用`ReactiveAuthorizationManager`检查`Authentication`对象是否有权访问受保护的资源。`ReactiveAuthorizationManager`有两种方法，即`check`（检查`Authentication`对象是否被授予访问权限）和`verify`（检查`Authentication`对象是否被授予访问权限）。在任何异常情况下，`ExceptionTranslationWebFilter`负责通过遵循适当的路径来处理异常。
- en: Sample project
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例项目
- en: Enough explanation; it's time to get our hands dirty with actual code. In this
    section, we will create a movie catalog site with integrated Spring Security.
    We will be using reactive concepts throughout and will use form-based login. We
    will start with hardcoded users and then see how we can look at a persistent user
    store to authenticate the users against. We will then into testing in more detail
    and finally look at some customizations that we can bring to Spring Security pages.
    Finally, we will touch base on authorization aspects and close the sample application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的解释；现在是时候动手写实际的代码了。在本节中，我们将创建一个集成了Spring Security的电影目录网站。我们将贯穿始终地使用响应式概念，并使用基于表单的登录。我们将从硬编码的用户开始，然后看看如何查看持久用户存储来对用户进行认证。然后我们将更详细地进行测试，最后看看我们可以为Spring
    Security页面带来的一些自定义。最后，我们将涉及授权方面，并关闭示例应用程序。
- en: WebFlux project setup
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebFlux项目设置
- en: We will create a basic WebFlux-based web application first, and will slowly
    add other features, including security, in it. The whole code is available in
    our book's GitHub page, under the chapter's folder, namely `spring-boot-webflux`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个基本的基于WebFlux的Web应用程序，然后慢慢添加其他功能，包括安全性。整个代码都可以在我们书的GitHub页面上找到，在章节的文件夹下，即`spring-boot-webflux`。
- en: I am using IntelliJ as my IDE, and since we are using *Lombok library* (annotation
    `preprocessor`), make sure to enable the Lombok plugin, so as to generate appropriate
    boilerplate code for your model. Our project is kept quite simple, and does the
    function of movie management (the movie CRUD operation).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用IntelliJ作为我的IDE，由于我们使用了*Lombok库*（注解`preprocessor`），请确保启用Lombok插件，以便为您的模型生成适当的样板代码。我们的项目非常简单，只执行电影管理的功能（电影CRUD操作）。
- en: Maven setup
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven设置
- en: Using Spring Initializr for generating a Spring WebFlux project is really easy.
    But for us to get a handle on the various aspects of a WebFlux application, we
    will build aspect by ourselves. However, we will be using Spring Boot to run our
    application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Initializr生成Spring WebFlux项目非常容易。但是为了让我们掌握WebFlux应用程序的各个方面，我们将逐步构建。但是，我们将使用Spring
    Boot来运行我们的应用程序。
- en: 'We will create a maven project, and will then add the following main dependencies
    (to make the code shorter, only important dependencies are shown in the following
    code) to our `pom.xml`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个maven项目，然后将添加以下主要依赖项（为了使代码更简洁，以下代码只显示了重要的依赖项）到我们的`pom.xml`中：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will include snapshot repositories for both the library and plugin dependencies.
    Finally, we will add the all-important maven plugin for our Spring Boot, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为库和插件依赖项包括快照存储库。最后，我们将为我们的Spring Boot添加非常重要的maven插件，如下所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Configuration class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: Even though we are going to use default configurations as much as possible,
    we will still have separate configuration classes for various components. In our
    project, we are building a basic WebFlux application, thus we have only one configuration
    class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将尽可能使用默认配置，但我们仍将为各种组件编写单独的配置类。在我们的项目中，我们正在构建一个基本的WebFlux应用程序，因此我们只有一个配置类。
- en: The SpringWebFluxConfig class
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringWebFluxConfig类
- en: 'The main configuration class for a Spring WebFlux web application is achieved
    by this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux Web应用程序的主要配置类是通过这个类实现的：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have an empty class with just some very important annotations as shown in
    the preceding code. `@EnableWebFlux` makes the application reactive and makes
    it WebFlux.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个空的类，只有一些非常重要的注释，如前面的代码所示。`@EnableWebFlux`使应用程序具有反应性，并使其成为WebFlux。
- en: Repository
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库
- en: 'We will be using hardcoded movies as our data structure for this sample and
    will write methods in a reactive way, to expose methods in our repository class.
    These methods can be used to manipulate the data structure of the movies. Our
    repository class is a conventional one, but the right data structures, in the
    form of `Mono` and `Flux`, aid in bringing a reactive nature to the application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用硬编码的电影作为我们的样本数据结构，并以一种反应性的方式编写方法，以公开我们存储库类中的方法。这些方法可以用于操作电影的数据结构。我们的存储库类是一个传统的类，但正确的数据结构，以`Mono`和`Flux`的形式，有助于为应用程序带来反应性的特性：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The class is just a snippet extracted from the class, and shows only one method
    (`getMovieById`). As always, our class implements an interface (`MovieRepository`),
    and this reference will be used in other parts of the application (using Spring's Dependency
    Injection capability).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该类只是从类中提取的片段，仅显示一个方法（`getMovieById`）。与往常一样，我们的类实现了一个接口（`MovieRepository`），并且这个引用将在应用程序的其他部分中使用（使用Spring的依赖注入功能）。
- en: Handler and router
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序和路由器
- en: 'As detailed previously, we have two approaches, namely **functional-based**
    and **annotation-based**, for implementing a WebFlux application. Annotation-based
    is similar to Spring MVC, and because of this, we will be using functional-based
    approach in our sample application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有两种方法，即**基于功能的**和**基于注释的**，用于实现WebFlux应用程序。基于注释的方法类似于Spring MVC，因此我们将在我们的样本应用程序中使用基于功能的方法：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The class is quite straightforward and uses a repository class for data structure
    query and manipulation. Each method accomplishes the functionality, and finally
    returns `Mono<ServerResponse>`. Another important aspect of WebFlux in functional-based
    programming is the routing configuration class, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该类非常简单直接，使用存储库类进行数据结构查询和操作。每个方法都完成了功能，并最终返回`Mono<ServerResponse>`。基于功能的编程中WebFlux的另一个重要方面是路由配置类，如下所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the class that looks at the request and routes it to the appropriate
    handler method. In your application, you can have any number of router configuration
    files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查看请求并将其路由到适当处理程序方法的类。在您的应用程序中，您可以拥有任意数量的路由器配置文件。
- en: Bootstrap application
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导应用程序
- en: 'Our sample application uses Spring Boot. Spring WebFlux runs on a Reactor Netty
    server within Spring Boot by default. Our Spring Boot class is very basic and
    is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样本应用程序使用Spring Boot。Spring WebFlux默认在Spring Boot中运行Reactor Netty服务器。我们的Spring
    Boot类非常基本，如下所示：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can run the application on any other server, apart from Spring Boot, and
    it is quite easy to achieve. We have a separate project named `spring-boot-tomcat-webflux`
    that runs on Spring Boot, but rather than running on Reactor Netty, it runs on
    a Tomcat server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在除Spring Boot之外的任何其他服务器上运行应用程序，这是非常容易实现的。我们有一个名为`spring-boot-tomcat-webflux`的单独项目，它在Spring
    Boot上运行，但不是在Reactor Netty上运行，而是在Tomcat服务器上运行。
- en: 'No change is required in any part of the code, apart from `pom.xml`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pom.xml`之外，代码的任何部分都不需要更改：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the `spring-boot-starter-webflux` artifact, exclude Reactor Netty. Thereafter,
    explicitly add the Tomcat dependency, `spring-boot-starter-tomcat`. The rest of
    the `pom.xml` is kept intact. For other server runtimes, such as Undertow, Jetty,
    and so on, the approach is similar to the one detailed here.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从`spring-boot-starter-webflux`工件中排除Reactor Netty。然后，显式添加Tomcat依赖项，`spring-boot-starter-tomcat`。其余的`pom.xml`保持不变。对于其他服务器运行时，如Undertow、Jetty等，方法与此处详细介绍的方法类似。
- en: Running the application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Now, for the most important part: running the application that we built. As
    it is a Spring Boot application, execute the default command as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们构建的最重要的部分：运行应用程序。由于它是一个Spring Boot应用程序，执行默认命令如下：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the server has started (default Rector Netty or Tomcat), open a browser
    and navigate to `localhost:8080/movies`. We have created default routing to point
    to "list all movies" endpoint and if all went well, you should see the JSON which
    shows all the hardcoded movies in our repository class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动（默认为Rector Netty或Tomcat），打开浏览器并导航到`localhost:8080/movies`。我们已经创建了默认路由指向“列出所有电影”终点，如果一切顺利，您应该看到显示我们存储库类中所有硬编码电影的JSON。
- en: In this section, we have created a sample Spring WebFlux movie application.
    We will add the all important security to this application in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个样本Spring WebFlux电影应用程序。在下一节中，我们将为这个应用程序添加所有重要的安全性。
- en: Adding security
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全性
- en: To separate from what we have achieved up until now, we will have a separate
    project, `spring-boot-security-webflux` (the same as `spring-boot-webflux`). In
    it we will build all the security aspects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止所取得的成就分开，我们将有一个单独的项目，`spring-boot-security-webflux`（与`spring-boot-webflux`相同）。在其中，我们将构建所有安全方面。
- en: Configuration classes
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: We will be creating a new configuration class for Spring Security: `SpringSecurityWebFluxConfig`.
    Firstly, we will annotate the class with the most important annatation: `@EnableWebFluxSecurity`.
    This instructs it to enable Spring Security for WebFlux web applications. In the
    configuration class, we will look at two important beans, as follows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Spring Security创建一个新的配置类：`SpringSecurityWebFluxConfig`。首先，我们将使用最重要的注解对类进行注释：`@EnableWebFluxSecurity`。这指示它为WebFlux
    Web应用程序启用Spring Security。在配置类中，我们将查看两个重要的bean，如下所示。
- en: The UserDetailsService bean
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserDetailsService bean
- en: 'We will use hardcoded user details, against which we will authenticate. This
    is not how it has to be done for a production-ready application, but for simplicity
    and to explain the concepts, let''s take this shortcut:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用硬编码的用户详细信息进行身份验证。这不是生产就绪应用程序的操作方式，但为了简单起见并解释概念，让我们采取这种捷径：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The bean returns the reactive user details service, containing hardcoded credentials
    for two users; one a normal user and the other an admin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该bean返回了包含两个用户的硬编码凭据的响应式用户详细信息服务；一个是普通用户，另一个是管理员。
- en: The SpringSecurityFilterChain bean
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringSecurityFilterChain bean
- en: 'This is the bean where we actually specify the Spring Security configuration:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实际指定Spring Security配置的bean：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similar to what we saw earlier, in the Spring MVC application earlier, we match
    URL patterns and specify the role that is needed to access it. We are configuring
    the login method as a form in which the user will be shown the default login form
    by Spring Security.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前在Spring MVC应用程序中看到的类似，我们匹配URL模式并指定访问所需的角色。我们正在将登录方法配置为一个表单，用户将通过Spring
    Security显示默认登录表单。
- en: Running the application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Execute the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the server starts up, you have two ways in which you can test the application,
    as follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动时，您有两种方式可以测试应用程序，如下所示。
- en: CURL
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CURL
- en: 'Open your favorite Command Prompt and execute the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您喜欢的命令提示符并执行以下命令：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will be redirected to the `http://localhost:8080/login` page. Your entire
    application is secured and without logging in, you will not be able to access
    any content. With form login as the method, you won''t be able to test it using
    `curl`. Let''s change the login method from form (`formLogin`) to basic (`httpBasic`)
    in the Spring Security configuration (the `springWebFilterChain` bean). Now, execute
    the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到`http://localhost:8080/login`页面。您的整个应用程序都是安全的，如果不登录，您将无法访问任何内容。使用表单登录作为方法，您将无法使用`curl`进行测试。让我们将登录方法从表单（`formLogin`）更改为基本（`httpBasic`）在Spring
    Security配置（`springWebFilterChain` bean）中。现在，执行以下命令：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should now see the raw JSON displaying all of the hardcoded movies. Use
    other common CURL commands, as follows, to test other endpoints:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到显示所有硬编码电影的原始JSON。使用其他常见的CURL命令，如下所示，测试其他端点：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Browser
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: 'Let''s put the login method back to form, and then open a browser and navigate
    to `http://localhost:8080`. You will be navigated to the default Spring Security
    login page. Enter the username as `admin` and the password as `password`, and
    click on Sign in:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将登录方法改回表单，然后打开浏览器并导航到`http://localhost:8080`。您将被导航到默认的Spring Security登录页面。输入用户名为`admin`，密码为`password`，然后单击登录：
- en: '![](img/fe1f91c0-67a5-4870-8c70-74d01fe378db.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe1f91c0-67a5-4870-8c70-74d01fe378db.png)'
- en: 'Figure 9: Default Spring Security login form'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：默认的Spring Security登录表单
- en: 'After successfully logging in, you will be navigated to the list all movies
    endpoint, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，您将被导航到列出所有电影的端点，如下所示：
- en: '![](img/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png)'
- en: 'Figure 10: List all movies default home page after login'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：登录后默认主页上列出所有电影
- en: WebClient
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: On the book's GitHub page, we have a separate project (`spring-boot-security-webclient-webflux`),
    in which you can see the entire code that will be detailed in this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在该书的GitHub页面上，我们有一个单独的项目（`spring-boot-security-webclient-webflux`），您可以在其中看到本节中将详细介绍的整个代码。
- en: Maven setup
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven设置
- en: 'Create a base maven project and add the following main dependency to your `pom.xml`
    file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的maven项目，并将以下主要依赖项添加到您的`pom.xml`文件中：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, add other dependencies, as well as the default Spring Boot build section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加其他依赖项，以及默认的Spring Boot构建部分。
- en: Creating a WebClient instance
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个WebClient实例
- en: 'A `WebClient` instance can be created by using the `create()` method, or by
    using the `builder()` method. In our sample, we have used the `builder()` method,
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient`实例可以通过使用`create()`方法或使用`builder()`方法来创建。在我们的示例中，我们使用了`builder()`方法，如下所示：'
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will be using all of the endpoints that we have created earlier in our base
    Spring WebFlux project, and will be accessing them using the `WebClient`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在基本Spring WebFlux项目中创建的所有端点，并将使用`WebClient`访问它们。
- en: 'Use the `create()` method to create an instance of `WebClient`, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create()`方法创建`WebClient`的实例，如下所示：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you have a base URL, `WebClient` can be created as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有基本URL，则可以创建`WebClient`如下：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `builder()` method provides bunch of utility methods, such as filters, setting
    headers, setting cookies, and so on. In our example, we have set some default
    headers and have also set the base URL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder()`方法提供了一堆实用方法，如过滤器、设置标头、设置cookie等。在我们的示例中，我们设置了一些默认标头，并设置了基本URL。'
- en: Handling errors
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'A `WebClient` instance allows you to handle errors (the `WebClientTestImpl`
    class) in the `listMovies()` method, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient`实例允许您处理错误（`WebClientTestImpl`类）在`listMovies()`方法中，如下所示：'
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`SampleException` is a custom exception class that we created by extending
    the `Exception` class. We are handling 4xx and 5xx errors, and, when encountered,
    it sends the custom exception as response.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleException`是我们通过扩展`Exception`类创建的自定义异常类。我们正在处理4xx和5xx错误，并且在遇到时，它会将自定义异常作为响应发送。'
- en: Sending requests and retrieving responses
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送请求和检索响应
- en: 'The `retrieve()` method is a simple method, using which the response body can
    be retrieved. If you want to have more control over returned responses, the `exchange()`
    method can be used to retrieve the response. We have used both of the methods
    in our sample application; the code snippets for the two methods in the `WebClientTestImpl`
    class are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieve()`方法是一个简单的方法，可以用来检索响应主体。如果您想对返回的响应有更多控制，可以使用`exchange()`方法来检索响应。我们在示例应用程序中使用了这两种方法；`WebClientTestImpl`类中这两种方法的代码片段如下：'
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first method, we execute a GET method on the URI `http://localhost:8080/api/movie/{id}`,
    use the `retrieve()` method, and then convert into `Mono`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，我们在URI `http://localhost:8080/api/movie/{id}` 上执行GET方法，使用`retrieve()`方法，然后转换为`Mono`。
- en: In the second method, we execute a POST method on the URL `http://localhost:8080/api/movie`,
    use the `exchange()` method, and use the `flatMap()` method to create the response.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，我们在URL `http://localhost:8080/api/movie` 上执行POST方法，使用`exchange()`方法，并使用`flatMap()`方法创建响应。
- en: Running and testing the application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试应用程序
- en: We will be using the same movie model in this sample project. Since this is
    the only class that we need from our previous sample application, we will copy
    the class here. In an ideal scenario, we would have a JAR file containing all
    common classes, and it can be included in our `pom.xml` file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例项目中，我们将使用相同的电影模型。由于这是我们从之前的示例应用程序中需要的唯一类，我们将在这里复制该类。在理想情况下，我们将有一个包含所有公共类的JAR文件，并且可以将其包含在我们的`pom.xml`文件中。
- en: 'Create the `Run` class (as seen earlier) and call the `WebClient` methods.
    The code snippet for one of the methods is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Run`类（如前所示）并调用`WebClient`方法。其中一个方法的代码片段如下：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After executing each `WebClient` call, we will sleep for three seconds. Since
    `WebClient` methods emit reactive types (`Mono` or `Flux`), you have to subscribe,
    as shown in the preceding code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行每个`WebClient`调用后，我们将休眠三秒。由于`WebClient`方法发出反应类型（`Mono`或`Flux`），您必须订阅，如前面的代码所示。
- en: Start the `spring-boot-webflux` project, exposing the endpoints, which we will
    test by using `WebClient` in this project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`spring-boot-webflux`项目，暴露端点，我们将使用此项目中的`WebClient`进行测试。
- en: 'Make sure that your application''s default port is changed in your `application.properties`
    file by including the following entry:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的`application.properties`文件中更改应用程序的默认端口，包括以下条目：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Start the application by executing the Spring Boot command, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行Spring Boot命令启动应用程序，如下所示：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If all goes well, you should see the output in the server console, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在服务器控制台中看到输出，如下所示：
- en: '![](img/22f55554-5b13-4aa5-aeeb-10c9acc37545.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22f55554-5b13-4aa5-aeeb-10c9acc37545.png)'
- en: 'Figure 11: WebClient test execution'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：WebClient测试执行
- en: Unit testing (WebTestClient)
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试（WebTestClient）
- en: 'In our base `spring-boot-webflux` project, we have written test cases using
    `WebTestClient`. We have two test cases: one to get all movies, and other to save
    movie.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本`spring-boot-webflux`项目中，我们使用`WebTestClient`编写了测试用例。我们有两个测试用例：一个是获取所有电影，另一个是保存电影。
- en: Maven dependency
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖
- en: 'Make sure that you have the following dependencies in your `pom.xml` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的`pom.xml`文件中有以下依赖项：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, in the preceding code, all of the dependencies can be scoped
    for testing purposes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在前面的代码中，所有依赖项都可以用于测试目的。
- en: Test class
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类
- en: 'Create a normal test class, as follows. Use the `@Autowired` annotation to
    inject the `WebTestClient` instance in your test class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个普通的测试类，如下所示。在测试类中使用`@Autowired`注解来注入`WebTestClient`实例：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `WebTestClient` object's functionality is similar to `WebClient`, as seen
    earlier. We can check for various properties in the response to ascertain what
    we want to test. In the preceding example, for the first test, we are firing a
    GET request and checking for OK status, an application/JSON content type header,
    and, finally, a body having a list of `Movie` objects. In the second test, we
    are firing a POST request with a `Movie` object as the body, and, expecting an
    OK status and an empty body.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient`对象的功能与之前看到的`WebClient`类似。我们可以检查响应中的各种属性，以确定我们要测试的内容。在前面的示例中，对于第一个测试，我们正在发送GET请求并检查OK状态，应用程序/JSON内容类型标头，最后，一个包含`Movie`对象列表的主体。在第二个测试中，我们正在发送一个带有`Movie`对象的POST请求作为主体，并期望一个OK状态和一个空主体。'
- en: Spring Data
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: Even though this book is focused on Spring Security on reactive concepts, I
    really want you to have some idea of reactive concepts in other areas as well.
    So, there is a separate project, `spring-boot-security-mongo-webflux`, which looks
    at implementing reactive concepts by integrating the earlier project with reactive
    MongoDB, using Spring Data. Covering every aspect in regard to this is not something
    that we will do. However, with the earlier project as a base, we will cover some
    of the important aspects in this section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书侧重于响应式概念上的Spring Security，但我真的希望您也对其他领域的响应式概念有一些了解。因此，有一个单独的项目`spring-boot-security-mongo-webflux`，它通过将之前的项目与响应式MongoDB集成，使用Spring
    Data来实现响应式概念。我们不会涵盖与此相关的每个方面。但是，基于之前的项目，我们将在本节中涵盖一些重要方面。
- en: Maven dependency
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖
- en: 'In your application `pom.xml`, add the following dependencies, both dealing
    with MongoDB inclusion into the project:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序`pom.xml`中，添加以下依赖项，都涉及将MongoDB包含到项目中：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I have installed MongoDB on my machine. I have started the database locally
    on the default port (`27017`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我已在我的机器上安装了MongoDB。我已在默认端口（`27017`）上本地启动数据库。
- en: MongoDB configuration
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB配置
- en: 'Add the following to your application.properties file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到您的application.properties文件中：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will be pointing our DB to a locally running DB on the default port utilizing
    the movie database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的数据库指向本地运行的默认端口上的数据库，利用电影数据库。
- en: Setting up a model
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模型
- en: In our already existing `Movie` model, we just added one more annotation: `@Document(collection
    = "movies")`. This annotation will inform MongoDB as to the name of the collection
    in the DB where this model will be stored.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经存在的`Movie`模型中，我们只添加了一个注解：`@Document(collection = "movies")`。此注解将告知MongoDB该模型将存储在DB中的集合的名称。
- en: Implementing a repository
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现存储库
- en: 'We will create a new repository, `ReactiveMovieRepository`, with our two curated
    methods and all of the default methods provided by our extended class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的存储库`ReactiveMovieRepository`，其中包含我们的两个精心策划的方法和我们扩展类提供的所有默认方法：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will extend our repository from `ReactiveMongoRepository`. `ReactiveMongoRepository`
    has loads of common methods that can be used right away, without any trouble.
    The methods that we have implemented use plain queries against the MongoDB and
    return the list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`ReactiveMongoRepository`扩展我们的存储库。`ReactiveMongoRepository`有很多通用方法，可以立即使用，毫不费力。我们实现的方法使用普通查询来对MongoDB进行操作并返回列表。
- en: Implementing a controller
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制器
- en: 'To make it separate from our existing functional-based programming, we have
    created a new controller that will expose some of the methods in a RESTful way,
    using the newly created `ReactiveMovieRepository`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其与我们现有的基于功能的编程分离，我们创建了一个新的控制器，它将以RESTful方式暴露一些方法，使用新创建的`ReactiveMovieRepository`：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The class is quite straightforward; each method has appropriate mapping and
    uses corresponding repository classes to actually do the job.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单；每个方法都有适当的映射，并使用相应的存储库类来实际完成工作。
- en: Running the application
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Using the `mongod` command, we will start the locally installed MongoDB and
    then using the following command, we will start the project we just created:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mongod`命令，我们将启动本地安装的MongoDB，然后使用以下命令，我们将启动刚刚创建的项目：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Head over to postman and call the URL `http://localhost:8080/movies` (GET).
    You will see an array with zero elements in it. Now, call the URL `http://localhost:8080/movies`
    (POST), with the following JSON in the body:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 转到postman并调用URL `http://localhost:8080/movies`（GET）。您将看到其中有零个元素的数组。现在，调用URL
    `http://localhost:8080/movies`（POST），在请求体中使用以下JSON：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will get a 200 OK status, and should see the newly created JSON as a response.
    Now, if you run the GET request on movies endpoint, you should see the newly created
    `Movie` as a response.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得一个200 OK状态，并应该看到新创建的JSON作为响应。现在，如果您在电影端点上运行GET请求，您应该会看到新创建的`Movie`作为响应。
- en: Here, we implemented CRUD in our `Movie` model by using MongoDB as a persistence
    store in a reactive programming paradigm.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用MongoDB作为响应式编程范式中的持久存储库，实现了对我们的`Movie`模型的CRUD。
- en: Authorization
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: In the past, we already saw that using the `@EnableWebFluxSecurity` annotation,
    we can get URL security. Spring Security also allows you to secure method execution
    in a reactive way, by using another annotation, `@EnableReactiveMethodSecurity`.
    The concept is the same what we saw in earlier examples based on Spring MVC. We
    will just cover method security in this section; the rest of the aspects are exactly
    the same and we will avoid replication here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我们已经看到使用`@EnableWebFluxSecurity`注解，我们可以获得URL安全性。Spring Security还允许您以一种响应式的方式保护方法执行，通过使用另一个注解`@EnableReactiveMethodSecurity`。这个概念与我们之前基于Spring
    MVC的示例中看到的是相同的。我们将在本节中只涵盖方法安全性；其他方面完全相同，我们将避免在此重复。
- en: Method security
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法安全性
- en: 'To enable method security, first, annotate the Spring Security configurations
    class with `@EnableReactiveMethodSecurity`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用方法安全性，首先要用`@EnableReactiveMethodSecurity`注解Spring Security配置类：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, for any method that you would like to have some security features
    for, use all of the various security-related annotations discussed in previous
    chapters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，对于任何您希望具有一些安全功能的方法，使用前几章讨论的各种安全相关注解：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding method, we are directing Spring Security that the method execution
    for `getAllMovies()` should be allowed if the user is authenticated and has the `ADMIN`
    role granted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，我们指示Spring Security，如果用户经过身份验证并被授予`ADMIN`角色，则应允许`getAllMovies()`的方法执行。
- en: Customization
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制
- en: Spring Security allows for a number of customizations. The default pages produced
    by Spring Security, such as login form, logout form, and so on, can be fully customized
    in all aspects suiting your application's brand. If you would like to tweak Spring
    Security's default execution, implementing your own filter is appropriate. Since
    Spring Security depends heavily on filters to achieve its functionality, let's
    look at the customization opportunity in this.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许进行许多定制。Spring Security生成的默认页面，如登录表单、注销表单等，可以在所有方面完全定制，以适应您应用程序的品牌。如果您想要调整Spring
    Security的默认执行，实现自己的过滤器是合适的。由于Spring Security在很大程度上依赖过滤器来实现其功能，让我们看看在这方面的定制机会。
- en: In addition, almost all parts of Spring Security can be customized by using
    your own classes, and then plugged into the Spring Security default flow to manage
    your own customizations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，几乎可以通过使用自己的类来定制Spring Security的几乎所有部分，并将其插入Spring Security默认流程中以管理自己的定制。
- en: Writing custom filters
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义过滤器
- en: As we saw earlier, in a WebFlux web application, Spring Security works based
    on `WebFilter` (similar to Servlet Filter in Spring MVC). If you would like to
    customize certain aspects in Spring Security, especially in request and response
    manipulation, implementing a custom `WebFilter` is one of the approaches that
    can be looked at.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在WebFlux Web应用程序中，Spring Security基于`WebFilter`（类似于Spring MVC中的Servlet
    Filter）工作。如果您想要定制Spring Security中的某些方面，特别是在请求和响应操作中，实现自定义`WebFilter`是可以考虑的方法之一。
- en: 'Spring WebFlux offers two approaches to implement filters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux提供了两种实现过滤器的方法：
- en: '**Using** `WebFilter`: Works for both annotation-based and functional-based
    (`routerhandler`)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `WebFilter`：适用于基于注解和基于功能的（`routerhandler`）'
- en: '**Using** `HandlerFilterFunction`: Works only with functional-based'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `HandlerFilterFunction`：仅适用于基于功能的'
- en: Using WebFilter
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebFilter
- en: 'We will be building on top of our project, `spring-boot-webflux`. To make it
    isolated from other projects, we will create a new project, `spring-boot-webflux-custom`.
    As indicated previously, using `WebFilter` applies to both annotation-based and
    functional-based WebFlux approaches. In our example, we''ll have two paths: `filtertest1`
    and `filtertest2`. We will write test cases using `WebFluxTestClient`, and will
    assert certain conditions. Being separate from the rest, we will create a new
    routing config, a handler, and an entirely new REST controller. We will not go
    into detail on some of the aspects already covered. In this section, we will just
    go through the `WebFilter` code, and also some important aspects of the test cases:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目`spring-boot-webflux`的基础上进行构建。为了使其与其他项目隔离，我们将创建一个新项目`spring-boot-webflux-custom`。如前所述，使用`WebFilter`适用于基于注解和基于功能的WebFlux方法。在我们的示例中，我们将有两个路径：`filtertest1`和`filtertest2`。我们将使用`WebFluxTestClient`编写测试用例，并断言某些条件。作为与其他部分分离，我们将创建一个新的路由配置、一个处理程序和一个全新的REST控制器。我们不会详细介绍一些已经涵盖的方面。在本节中，我们只会介绍`WebFilter`代码，以及测试用例的一些重要方面：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `SampleWebFilter` class implements `WebFilter`, and also implements the
    `filter` method. In this class, we will add a new response header, `filter-added-header`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleWebFilter`类实现了`WebFilter`，并实现了`filter`方法。在这个类中，我们将添加一个新的响应头，`filter-added-header`：'
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In both test cases, for both paths, we will check for newly added headers. When
    you run the test cases (using `mvn test`), it will confirm this finding.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个测试用例中，我们将检查新添加的头。当您运行测试用例（使用`mvn test`）时，它将确认这一发现。
- en: Using HandlerFilterFunction
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HandlerFilterFunction
- en: 'We will implement a new `HandlerFilterFunction`, `SampleHandlerFilterFunction`,
    in which we will look at a path variable (`pathVariable`) and check for its value.
    If the value is equal to `value2`, we will mark the status as `BAD_REQUEST`. It''s
    important to note that since `HandlerFilterFunction` applies only to functional-based,
    even though the path variable value is equal to `value2`, the status is not stamped
    as `BAD_REQUEST`, and the response received is OK:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个新的`HandlerFilterFunction`，`SampleHandlerFilterFunction`，在其中我们将查看一个路径变量（`pathVariable`）并检查其值。如果该值等于`value2`，我们将标记状态为`BAD_REQUEST`。需要注意的是，由于`HandlerFilterFunction`仅适用于基于功能的，即使路径变量值等于`value2`，状态也不会被标记为`BAD_REQUEST`，而接收到的响应是OK：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`SampleHandlerFilterFunction` implements the `HandlerFilterFunction` class,
    and also implements the `filter` method. In this class, we will explicitly set
    the response status as a bad request, if a condition is met:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleHandlerFilterFunction`实现了`HandlerFilterFunction`类，并实现了`filter`方法。在这个类中，如果满足条件，我们将明确将响应状态设置为`bad
    request`：'
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding test cases, the path tested is different, and since `HandlerFilterFunction`
    applies only to functional-based, the response is OK when the path is `filtertest1`,
    and it's `BAD_REQUEST` when the path is `filtertest2`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，测试的路径是不同的，由于`HandlerFilterFunction`仅适用于基于功能的，因此当路径为`filtertest1`时，响应为OK，当路径为`filtertest2`时，响应为`BAD_REQUEST`。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, for the first time in this book, we went over the details of
    reactive programming, using the Spring WebFlux framework. We started off by giving
    adequate details on the framework itself at a high level. We went over a very
    basic example, and then, introduced you to Spring Security and its functionality
    with Spring WebFlux.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首次详细介绍了响应式编程，使用了Spring WebFlux框架。我们首先从高层次上对框架本身进行了充分的介绍。我们介绍了一个非常基本的例子，然后介绍了Spring
    Security及其在Spring WebFlux中的功能。
- en: Finally, we went through a hands-on coding session, with a sample application.
    In this example, we covered other reactive aspects, such as Spring Data Mongo,
    so as to give you more insight into the reactive world.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行了一个实际的编码会话，使用了一个示例应用程序。在这个例子中，我们涵盖了其他响应式方面，比如Spring Data Mongo，以便让您更深入地了解响应式世界。
- en: We ended the chapter with some of the customization possible in Spring WebFlux
    with Spring Security.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以Spring WebFlux与Spring Security中可能的一些自定义结束了本章。
- en: Having read this chapter, you should have a clear idea of the differences between
    the Spring MVC and Spring WebFlux frameworks. You should also have a good understanding
    of the workings of Spring WebFlux security using the Spring Security module. The
    examples are meant to be simple in nature and as we are undressing Spring Security
    in this book, those aspects are given more value in the explanations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该清楚了解了Spring MVC和Spring WebFlux框架之间的区别。您还应该对使用Spring Security模块的Spring
    WebFlux安全性有很好的理解。这些示例旨在简单易懂，因为在本书中我们正在介绍Spring Security，所以在解释中给予了更多的价值。

- en: REST API Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API安全
- en: Spring Security can be used to secure REST APIs. This chapter begins with the
    introduction of some of the important concepts in regard to REST and the JWT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security可以用于保护REST API。本章首先介绍了有关REST和JWT的一些重要概念。
- en: The chapter then introduces OAuth concepts and by using hands-on coding examples,
    explains simple and advanced REST API security utilizing the Spring Security and
    Spring Boot modules in the Spring Framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章介绍了OAuth概念，并通过实际编码示例，解释了在Spring框架的Spring Security和Spring Boot模块中利用简单和高级REST
    API安全。
- en: We will be using the OAuth protocol in our examples to secure exposed REST API's
    utilizing Spring Security features to the fullest. We will be using the JWT to
    exchange claims between the server and client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中使用OAuth协议来保护暴露的REST API，充分利用Spring Security功能。我们将使用JWT在服务器和客户端之间交换声明。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下概念：
- en: Modern application architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代应用程序架构
- en: Reactive REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式REST API
- en: Simple REST API security
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的REST API安全
- en: Advanced REST API security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级REST API安全
- en: Spring Security OAuth project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security OAuth项目
- en: OAuth2 and Spring WebFlux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2和Spring WebFlux
- en: Spring Boot and OAuth2
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot和OAuth2
- en: Important concepts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要概念
- en: Before getting into coding, we need to be conversant with some important concepts.
    This section is aimed at introducing you to some of these concepts in detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行编码之前，我们需要熟悉一些重要概念。本节旨在详细介绍一些这些概念。
- en: REST
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: '**Representational State Transfer** (**REST**) is an architectural style presented
    by Roy Fielding in the year 2000 for developing web services. It is built on top
    of the well-known **Hypertext Transfer Protocol** (**HTTP**) and can transfer
    data in multiple formats, the most common being **JavaScript Object Notation**
    (**JSON**) and **eXtensible Markup Language** (**XML**). The status of a request
    in REST is indicated using standard HTTP status code (200: OK, 404: Page not found!,
    and so on). Being based on HTTP, security is taken care of using the already familiar
    **Secure Sockets Layer** (**SSL**) and **Transport Layer Security** (**TLS**).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述性状态转移**（**REST**）是Roy Fielding于2000年提出的一种用于开发Web服务的架构风格。它建立在著名的**超文本传输协议**（**HTTP**）之上，可以以多种格式传输数据，最常见的是**JavaScript对象表示法**（**JSON**）和**可扩展标记语言**（**XML**）。在REST中，请求的状态使用标准的HTTP状态码表示（200：OK，404：页面未找到！等）。基于HTTP，安全性是通过已熟悉的**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）来处理的。'
- en: While writing such web services, you are free to use any programming language
    (Java, .NET, and so on) that is capable of making web requests based on HTTP (which
    is a de facto standard that every language supports). You have a number of well-known
    frameworks, using which developing RESTful APIs on the server side is quite easy
    and simple. Also, on the client side, there are a number of frameworks that make
    invoking RESTful APIs and handling responses straightforward and easy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写此类Web服务时，您可以自由选择任何编程语言（Java，.NET等），只要它能够基于HTTP进行Web请求（这是每种语言都支持的事实标准）。您可以使用许多知名的框架来开发服务器端的RESTful
    API，这样做非常容易和简单。此外，在客户端，有许多框架可以使调用RESTful API和处理响应变得简单直接。
- en: 'Since REST works on internet protocol, the caching of a web service response
    can be achieved quite easily by supplying appropriate HTTP headers (Cache-Control,
    Expires, and so on). The HTTP methods `PUT` and `DELETE` are not cacheable in
    any scenario. The following table summarizes the use of HTTP methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST是基于互联网协议工作的，通过提供适当的HTTP头部（Cache-Control，Expires等），可以很容易地实现对Web服务响应的缓存。`PUT`和`DELETE`方法在任何情况下都不可缓存。以下表格总结了HTTP方法的使用：
- en: '| **HTTP method** | **Description** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP方法** | **描述** |'
- en: '| `GET` | Retrieves a resource |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 检索资源 |'
- en: '| `POST` | Creates a new resource |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建新资源 |'
- en: '| `PUT` | Updates an existing resource |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新现有资源 |'
- en: '| `DELETE` | Deletes an existing resource |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除现有资源 |'
- en: '| `PATCH` | Makes a partial update to a resource |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 对资源进行部分更新 |'
- en: 'Table 1: HTTP method usage'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：HTTP方法使用
- en: A REST API request/response (data sent over the wire) can be compressed by specifying
    appropriate HTTP headers, similar to caching. The HTTP header, Accept-Encoding,
    is sent by the client to the server, to let the server know the compression algorithms
    it can understand. The server successfully compresses a response and puts out
    another HTTP header, Content-Encoding, letting the client know which algorithm
    has to be used to decompress.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: REST API请求/响应（通过网络发送的数据）可以通过指定适当的HTTP头部进行压缩，类似于缓存。客户端发送Accept-Encoding的HTTP头部，让服务器知道它可以理解哪些压缩算法。服务器成功压缩响应并输出另一个HTTP头部Content-Encoding，让客户端知道应该使用哪种算法进行解压缩。
- en: JSON Web Token (JWT)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Token（JWT）
- en: <q>"JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties."</q>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <q>"JSON Web Tokens是一种开放的、行业标准的RFC 7519方法，用于在两个当事方之间安全地表示声明。"</q>
- en: '*- [https://jwt.io/](https://jwt.io/)*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*- [https://jwt.io/](https://jwt.io/)*'
- en: 'In the past, the stateless nature of HTTP was circumvented in a web application
    (most of them are stateful in nature) by associating each request with a session
    ID created on the server and then stored by the client using cookies. Each request
    sends the cookie (session ID) in the form of an HTTP header, which gets validated
    by the server, and a state (a user session) is associated with each request. In
    modern applications (we will cover this in a bit more detail in the next section),
    a server-side session ID is replaced with the JWT. The following diagram shows
    the workings of the JWT:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，HTTP的无状态性质在Web应用程序中被规避（大多数Web应用程序的性质是有状态的），方法是将每个请求与在服务器上创建的会话ID相关联，然后由客户端使用cookie存储。每个请求都以HTTP头部的形式发送cookie（会话ID），服务器对其进行验证，并将状态（用户会话）与每个请求相关联。在现代应用程序中（我们将在下一节中更详细地介绍），服务器端的会话ID被JWT替代。以下图表显示了JWT的工作原理：
- en: '![](img/f181c449-77aa-498b-a77a-2104f1bb75ad.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f181c449-77aa-498b-a77a-2104f1bb75ad.png)'
- en: 'Figure 1: Workings of the JWT in modern applications'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：JWT在现代应用程序中的工作原理
- en: The web server, in this case, doesn't create a user session and the user session
    management capability needed for a stateful application is offloaded to other
    mechanisms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Web服务器不会创建用户会话，并且对于需要有状态应用程序的用户会话管理功能被卸载到其他机制。
- en: In the world of the Spring Framework, the Spring Session module can be employed
    to externalize the session from the web server to a central persistence store
    (Redis, Couchbase, and so on). Every request containing a valid token (JWT) is
    validated against this external store of authenticity and validity. After successful
    authentication, applications can generate a valid token and send it as a response
    to the client. The client can then store this token in any client storage mechanism
    it uses (sessionStorage, localStorage, cookies, and so on, in a browser). Using
    Spring Security, we can validate this token to ascertain the authenticity and
    validity of the user and then do whatever is required. We have a dedicated example
    in a subsequent section (Simple REST API security) of this chapter, which uses
    a basic authentication mechanism and, if successful, creates the JWT. Subsequent
    requests use the token in the HTTP header, which gets validated on the server
    to give access to other secured resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架的世界中，Spring Session模块可以用于将会话从Web服务器外部化到中央持久性存储（Redis、Couchbase等）。每个包含有效令牌（JWT）的请求都会针对这个外部的真实性和有效性存储进行验证。验证成功后，应用程序可以生成有效令牌并将其作为响应发送给客户端。然后客户端可以将此令牌存储在其使用的任何客户端存储机制中（sessionStorage、localStorage、cookies等，在浏览器中）。使用Spring
    Security，我们可以验证此令牌以确定用户的真实性和有效性，然后执行所需的操作。本章的后续部分（简单REST API安全性）中有一个专门的示例，该示例使用基本身份验证机制，并在成功时创建JWT。随后的请求使用HTTP标头中的令牌，在服务器上进行验证以访问其他受保护的资源。
- en: 'The following points highlight some of the advantages of using the JWT:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点突出了使用JWT的一些优点：
- en: '**Better performance**: Each request, when reaching the server, has to check
    the authenticity of the token send. The authenticity of the JWT can be checked
    locally and doesn''t require an external call (say, to a database). This local
    validation is performant and reduces the overall response time for a request.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：每个到达服务器的请求都必须检查发送的令牌的真实性。JWT的真实性可以在本地检查，不需要外部调用（比如到数据库）。这种本地验证性能良好，减少了请求的整体响应时间。'
- en: '**Simplicity**: JWT is easy and simple to implement. Also, it is a well established
    format in the industry for tokens. There are a number of well-known libraries
    which can be used to easily work with the JWT.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：JWT易于实现和简单。此外，它是行业中已经建立的令牌格式。有许多知名的库可以轻松使用JWT。'
- en: Structure of a token
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌的结构
- en: 'Unlike common security mechanisms, such as encryption, obscuring, and hiding,
    the JWT doesn''t encrypt or hide the data contained within. But, it does the destination
    system to check whether the token is from an authentic source. The structure of
    the JWT consists of a header, payload, and a signature. As mentioned, rather than
    encryption, the data contained within the JWT is encoded and then signed. Encoding
    does the job of transforming the data in a way that is acceptable by a variety
    of parties and signing allows us to check for its authenticity and, in fact, its
    origin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与常见的安全机制（如加密、混淆和隐藏）不同，JWT不会加密或隐藏其中包含的数据。但是，它确实让目标系统检查令牌是否来自真实来源。JWT的结构包括标头、有效载荷和签名。如前所述，与其加密，JWT中包含的数据被编码，然后签名。编码的作用是以一种可被各方接受的方式转换数据，签名允许我们检查其真实性，实际上是其来源：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's go into more detail about each of the components constituting the token.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解构成令牌的每个组件。
- en: Header
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标头
- en: 'This is a JSON object and takes the following format. It gives information
    on how the signature should be computed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON对象，采用以下格式。它提供有关如何计算签名的信息：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value of `typ` specifies type of the object, and in this case, it is the
    `JWT`. The value of `alg` specifies the algorithm used to create the signature,
    and in this case it is `HMAC-SHA256`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`typ`的值指定对象的类型，在这种情况下是`JWT`。`alg`的值指定用于创建签名的算法，在这种情况下是`HMAC-SHA256`。'
- en: Payload
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效载荷
- en: 'The payload forms the actual data (also known as a **claim**) stored in the
    JWT. According to your application''s requirements, you can put any number of
    claims into your JWT payload component. There are some predefined claims, such
    as `iss` (issuer), `sub` (subject), `exp` (expiration time), `iat` (issued at),
    and so on, that can be used, but all of these are optional:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷形成JWT中存储的实际数据（也称为**声明**）。根据应用程序的要求，您可以将任意数量的声明放入JWT有效载荷组件中。有一些预定义的声明，例如`iss`（发行人）、`sub`（主题）、`exp`（过期时间）、`iat`（发布时间）等，可以使用，但所有这些都是可选的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Signature
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名
- en: 'The signature is formed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 签名形成如下：
- en: 'The `header` is `base64` encoded: `base64(header)`.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`标头`是`base64`编码的：`base64(标头)`。'
- en: 'The `payload` is `base64` encoded: `base64(payload)`.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`有效载荷`是`base64`编码的：`base64(有效载荷)`。'
- en: 'Now join the values in *Step 1* and *Step 2* with a `"."` in the middle:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用中间的“.”连接*步骤1*和*步骤2*中的值：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, the signature is attained by hashing, using the algorithm specified in
    the header, the value attained in *Step 3*, and then appending it with the secret
    text (say `packtpub`) of your choice:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，签名是通过使用标头中指定的算法对*步骤3*中获得的值进行哈希，然后将其与您选择的秘密文本（例如`packtpub`）附加而获得的：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final JWT is as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的JWT如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The website [https://jwt.io/](https://jwt.io/) is a place I always visit for
    any of my JWT needs. The sample data used in this example is from that site:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 网站[https://jwt.io/](https://jwt.io/)是我在任何JWT需求中经常访问的地方。此示例中使用的示例数据来自该网站：
- en: '![](img/6e508052-e050-47bd-8b70-db78d22598e2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e508052-e050-47bd-8b70-db78d22598e2.png)'
- en: 'Figure 2: Screen grab from https://jwt.io/'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：来自https://jwt.io/的屏幕截图
- en: Modern application architecture
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代应用程序架构
- en: Frontends of most modern applications are not built using server-side web application
    frameworks, such as Spring MVC, **Java Server Faces** (**JSF**), and so on. Infact,
    many are built using full-fledged client-side frameworks, such as React (to be
    full-fledged, it has to be combined with other libraries), Angular, and so on.
    The previous statement doesn't mean in any way that there is no place for such
    server-side web application frameworks. According to the application you are building,
    there are specific places for each of these frameworks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: When using client-side frameworks, the client code (HTML, JS, CSS, and so on)
    in general is not secured. However, the data required to render these dynamic
    pages is secured behind a RESTful endpoint.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To secure a RESTful backend, the JWT is used to exchange claims between the
    server and the client. The JWT enables the stateless exchange of tokens between
    the two parties and takes away the burden of session management (no more sticky
    sessions or session replication between multiple server nodes) by the server.
    This enables the application to scale horizontally in a cost-effective manner:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/841b4165-d61d-41e8-89ec-89647e225641.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: API-based modern application architecture'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: SOFEA
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Service-Oriented Front-End Architecture** (**SOFEA**) is of the architectural
    style which had gained popularity in the past when **S****ervice Oriented Architecture** (**SOA**)
    and was becoming common in many enterprises. In modern days, SOA is more of less
    with microservices-based architecture and the backend is reduced to a bunch of
    RESTful endpoints. The client on the other hand is becoming thicker and uses client-side
    MVC frameworks such as Angular and React, just to name a couple. However, the
    core concept of SOFEA, in which backend is just endpoints and frontend (UI) becoming
    thicker is something everyone considers in modern age web application development.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of SOFEA are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The client in this is thicker (similar to thick client applications) as against
    thin client web applications that we have seen in the past. After initial view/rendering
    of pages, all the assets are downloaded from server and resides/caches on the
    client (browser). Thereafter, the server is contacted only for data when required
    by the client through XHR (Ajax) calls.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the client code is downloaded, only data flows from the server to the
    client, as opposed to presentation code (HTML, JavaScript, and so on), better
    utilizing the bandwidth. As there is less data being transferred, response times
    are faster, making applications perform better.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of clients can be written utilizing the same RESTful server endpoints,
    reusing APIs to the fullest.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These endpoints can externalize a session (in the Spring Framework, there is
    a module called **Spring Session**, which can be used to achieve this technical
    capability), thus easily achieving the horizontal scalability of the server.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better role segregation of team members in a project with APIs managed by a
    team and UI code managed by a different team.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive REST API
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication
    Using CAS and JAAS*, we went through the reactive Spring WebFlux web application
    framework in detail. We also looked into a lot of the reactive programming support
    provided by the Spring Framework and other Spring modules. Knowingly or unknowingly,
    we created a reactive REST API in the previous chapter's example sections. We
    used a handler and router mechanism for creating a RESTful application and also
    secured it using the *BASIC* authentication mechanism.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We saw the workings of `WebClient` (a reactive way of calling REST APIs, as
    opposed to using a blocking `RestTemplate`) and `WebTestClient` (a reactive way
    of writing test cases). We also saw the workings of Spring Data in a reactive
    way using MongoDB as the persistent store.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We will not go through these aspects here; we will only mention that, if you
    wish, you can make yourself comfortable with this topic by going through the section
    in [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication Using
    CAS and JAAS*. In this chapter, we will cover where we left off from the previous
    chapter by getting to REST API security using the JWT, and then going through
    REST API security using OAuth (implementing a custom provider as opposed to using
    public providers, such as Google, Facebook, and so on).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍这些方面；我们只会提到，如果你愿意，你可以通过阅读[第4章](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml)中的部分来熟悉这个主题，*使用CAS和JAAS进行身份验证*。在本章中，我们将继续上一章的内容，介绍使用JWT进行REST
    API安全，然后介绍使用OAuth进行REST API安全（实现自定义提供者，而不是使用公共提供者，如Google、Facebook等）。
- en: Simple REST API security
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的REST API安全
- en: 'We will use the example that we created in [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml), *Integrating
    with Spring WebFlux* (*spring-boot-spring-webflux*) and expand on it by doing
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第5章](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml)中创建的示例，*与Spring WebFlux集成*（*spring-boot-spring-webflux*），并通过以下方式进行扩展：
- en: Bringing the JWT support to the already existing Spring WebFlux application
    secured using basic authentication.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JWT支持引入到已使用基本身份验证进行安全保护的现有Spring WebFlux应用程序中。
- en: Creating a new controller (`path /auth/**`) that will have new endpoints, using
    which you can authenticate the user.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的控制器（`路径/auth/**`），将有新的端点，使用这些端点可以对用户进行身份验证。
- en: Using basic authentication or the auth REST endpoint, we will generate the JWT
    on the server and send it as a response to the client. Subsequent calls from the
    client to access secured REST APIs can be achieved by using the JWT supplied as
    a HTTP header (authorization, bearer token).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本身份验证或auth REST端点，我们将在服务器上生成JWT并将其作为响应发送给客户端。客户端对受保护的REST API的后续调用可以通过使用作为HTTP头部（授权，令牌）提供的JWT来实现。
- en: We won't be able to go into each and every detail of this project (we have a
    more important topic that we need to cover in this chapter within the stipulated
    page count). However, while going through the example, important code snippets
    will be listed down and explained in detail to some extent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法详细介绍这个项目的每一个细节（我们在规定的页数内需要涵盖一个更重要的主题）。然而，在浏览示例时，重要的代码片段将被列出并进行详细解释。
- en: Spring Security configuration
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security配置
- en: 'In the Spring Security configuration, we tweak the `springSecurityFilterChain`
    bean, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security配置中，我们调整了`springSecurityFilterChain` bean，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have a new `AuthenticationWebFilter` and a `AuthenticationSuccessHandler`
    configured. We also have a new `JWTAuthWebFilter` class for handling the JWT-based
    authentication configured.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们配置了一个新的`AuthenticationWebFilter`和一个`AuthenticationSuccessHandler`。我们还有一个新的`JWTAuthWebFilter`类来处理基于JWT的身份验证。
- en: 'We will be using `ReactiveUserDetailsService` with hardcoded user credentials
    for testing, as shown in the following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ReactiveUserDetailsService`和硬编码的用户凭据进行测试，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Authentication success handler
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证成功处理程序
- en: 'We set up a custom `AuthenticationSuccessHandler` (the source code for this
    class is shown next) in our Spring Security configuration class. On successful
    authentication, it will generate the JWT and also set a HTTP response header:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Spring Security配置类中设置了自定义的`AuthenticationSuccessHandler`（该类的源代码将在下面显示）。在成功验证后，它将生成JWT并设置HTTP响应头：
- en: '**Header name**: `Authorization`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部名称**：`Authorization`'
- en: '**Header value**: `Bearer JWT`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部值**：`Bearer JWT`'
- en: 'Let''s take a look at the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的代码：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `JWTUtil` class contains a number of utility methods dealing with the JWTs,
    such as the generation of tokens, verification of tokens, and so on. The `generateToken`
    method in the `JWTUtil` class is as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTUtil`类包含许多处理JWT的实用方法，例如生成令牌、验证令牌等。`JWTUtil`类中的`generateToken`方法如下所示：'
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Custom WebFilter namely JWTAuthWebFilter
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义WebFilter，即JWTAuthWebFilter
- en: 'Our custom `WebFilter`, named `JWTAuthWebFilter`, is entrusted with converting
    the JWT token received into appropriate classes that the Spring Security understands.
    It makes use of a converter named `JWTAuthConverter`, which does a number of things,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义`WebFilter`，名为`JWTAuthWebFilter`，负责将接收到的JWT令牌转换为Spring Security理解的适当类。它使用了一个名为`JWTAuthConverter`的转换器，该转换器执行了许多操作，如下所示：
- en: Gets the authorization `payload`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取授权`payload`
- en: Extracts the token by discarding the `Bearer` string
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过丢弃`Bearer`字符串来提取令牌
- en: Verifies the token
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证令牌
- en: Creates a `UsernamePasswordAuthenticationToken` class understood by Spring Security
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Spring Security理解的`UsernamePasswordAuthenticationToken`类
- en: The code snippet below shows the `JWTAuthWebFilter` class and its important
    method which does operations listed above.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了`JWTAuthWebFilter`类及其上面列出的操作的重要方法。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After this conversion, it does the actual authentication using Spring Security,
    which sets `SecurityContext` in the application, as shown in the following code
    snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此转换之后，使用Spring Security进行实际的身份验证，该身份验证在应用程序中设置了`SecurityContext`，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `JWTAuthWebFilter` class filter method does the necessary conversions and
    then the `authenticate` method does the actual authentication, and finally calls
    the `onAuthSuccess` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTAuthWebFilter`类的过滤器方法进行必要的转换，然后`authenticate`方法进行实际的身份验证，最后调用`onAuthSuccess`方法。'
- en: New controller classes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的控制器类
- en: 'We have two controllers, namely `DefaultController` (mapped to the `/` and
    `/login` paths) and `AuthController` (mapped to the `/auth` main route and `/token`
    sub-route). The `/auth/token` path can be used to retrieve the token, which can
    be used for a subsequent API call (`Bearer <Token>`). The code snippet for `AuthController`
    is as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个控制器，分别是`DefaultController`（映射到`/`和`/login`路径）和`AuthController`（映射到`/auth`主路由和`/token`子路由）。`/auth/token`路径可用于检索令牌，该令牌可用于后续的API调用（`Bearer
    <Token>`）。`AuthController`的代码片段如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the application and testing
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序并进行测试
- en: 'Run the application using the Spring Boot command shown below:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面显示的Spring Boot命令运行应用程序：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I will be using Postman to execute the REST endpoints.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Postman执行REST端点。
- en: 'You can get hold of the token, to include it in subsequent calls, by employing
    two methods as detailed below:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下两种方法获得令牌，并在随后的调用中包含它：
- en: 'If you access any route using basic authentication credentials, in the response
    header, you should get the token. I will be using the `/login` path with Basic
    Auth (authorization header) to get the token, as shown here:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用基本身份验证凭据访问任何路由，在响应头中，您应该获得令牌。我将使用`/login`路径与基本身份验证（授权头）获取令牌，如图所示：
- en: '![](img/d417a89e-0a43-4612-964b-8d12a8c02328.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d417a89e-0a43-4612-964b-8d12a8c02328.png)'
- en: 'Figure 4: Getting token using Basic Auth in Postman'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：在Postman中使用基本身份验证获取令牌
- en: 'Access the `/auth/token` endpoint with Basic Auth credentials supplied in the
    form of JSON (using the `JWTAuthRequest` class), as shown here, in Postman:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON形式的基本身份验证凭据（使用`JWTAuthRequest`类），如图所示，在Postman中访问`/auth/token`端点：
- en: '![](img/b601600b-0c3b-4c15-8c9a-9414f2a45049.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b601600b-0c3b-4c15-8c9a-9414f2a45049.png)'
- en: 'Figure 5: Getting token using /auth/token endpoint using Basic Auth credentials
    in JSON'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：使用JSON中的基本身份验证凭据使用/auth/token端点获取令牌
- en: 'Using the token retrieved, call the movie endpoint, as shown here, using Postman:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检索到的令牌，如图所示，在Postman中调用电影端点：
- en: '![](img/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png)'
- en: 'Figure 6: Retrieving movie listing using a JWT token in Postman'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：在Postman中使用JWT令牌检索电影列表
- en: This completes the example that we were building. In this example, we secured
    the REST APIs by making use of JWT and validated them using Spring Security. As
    mentioned, this is a basic way in which you can secure your REST APIs using Spring
    Security with JWTs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们正在构建的示例。在这个示例中，我们使用JWT保护了REST API，并使用Spring Security进行了验证。如前所述，这是您可以使用Spring
    Security和JWT保护REST API的基本方法。
- en: Advanced REST API security
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级REST API安全性
- en: REST APIs can be secured by another mechanism in your web application, OAuth.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: REST API可以通过您的Web应用程序中的另一种机制进行保护，即OAuth。
- en: OAuth is an authorization framework that allows other applications with the
    right credentials access to partial/limited user profile details stored on platforms
    such as Google and Facebook. The authentication part is delegated to these services
    and if successful, appropriate grants are given to the calling client/application,
    which can be used to get access to secured resources (in our case RESTful APIs).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个授权框架，允许其他应用程序使用正确的凭据访问存储在Google和Facebook等平台上的部分/有限用户配置文件详细信息。认证部分被委托给这些服务，如果成功，适当的授权将被授予调用客户端/应用程序，这可以用来访问受保护的资源（在我们的情况下是RESTful
    API）。
- en: We have seen OAuth security using a public authentication provider in [Chapter
    3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication Using CAS and
    JAAS* (in the *OAuth 2 and OpenID connect* section). However, we need not use
    these public providers; you have the choice of using your own. We will cover one
    such example in this chapter, where we will be using our own authentication provider
    and securing our Spring Boot-based reactive REST endpoints.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](69913c59-1186-44b2-8707-dceca721e206.xhtml)中看到了使用公共身份验证提供程序的OAuth安全性，*使用CAS和JAAS进行身份验证*（在*OAuth
    2和OpenID连接*部分）。但是，我们不需要使用这些公共提供程序；您可以选择使用自己的提供程序。在本章中，我们将涵盖一个这样的示例，我们将使用自己的身份验证提供程序并保护基于Spring
    Boot的响应式REST端点。
- en: Before getting into the example, we need to understand a bit more about OAuth,
    and also need to understand its various components. We already went through a
    lot of the details of OAuth in [Chapter 3](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&action=edit#post_28), *Authentication
    Using CAS and JAAS*. We will add to those details in this section and then go
    through the code example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入示例之前，我们需要更多地了解OAuth，并且需要了解它的各个组件。我们已经在[第3章](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&action=edit#post_28)中详细介绍了OAuth的许多细节，*使用CAS和JAAS进行身份验证*。我们将在本节中添加这些细节，然后通过代码示例进行讲解。
- en: OAuth2 roles
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2角色
- en: 'OAuth stipulates four roles for users and applications. The interactions between
    these roles are shown in the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth为用户和应用程序规定了四种角色。这些角色之间的交互如下图所示：
- en: '![](img/6d946741-9ac2-4e7f-8504-a46b832ebb27.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d946741-9ac2-4e7f-8504-a46b832ebb27.png)'
- en: 'Figure 7: OAuth role interaction'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：OAuth角色交互
- en: We will look into each of these OAuth roles in some detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细了解这些OAuth角色中的每一个。
- en: Resource owner
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者
- en: This is the user who owns the protected resource that is needed by the consuming
    client application. If we take Facebook or Google as the authentication provider,
    the resource owner is the actual user who has data saved on these platforms.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拥有所需受保护资源的消费客户端应用程序的用户。如果我们以Facebook或Google作为身份验证提供程序，资源所有者就是在这些平台上保存数据的实际用户。
- en: Resource server
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: This is the server that has the secured resources in the form of hosted APIs.
    If we take Google or Facebook as an example, they hold the profile information,
    as well as other information, in the form of APIs. If the client application successfully
    authenticates (using the credentials provided by the user) and then the user grants
    appropriate permissions, they can get access to this information through their
    exposed APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以托管API的形式拥有受保护资源的服务器。如果以Google或Facebook为例，它们以API的形式保存配置文件信息以及其他信息。如果客户端应用程序成功进行身份验证（使用用户提供的凭据），然后用户授予适当的权限，他们可以通过公开的API访问这些信息。
- en: Client
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: This is the application that to access the secured resources available on the
    resource server. If the user is successfully authenticated and the client application
    is given permission by the user to access the right information, the client application
    can retrieve the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于访问资源服务器上可用的受保护资源的应用程序。如果用户成功验证并且客户端应用程序被用户授权访问正确的信息，客户端应用程序可以检索数据。
- en: Authorization server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: This is the server that authenticates and authorizes client applications to
    access the secured resources owned by the resource owner and on the resource server. It
    is not uncommon to see the same server performing both roles.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个验证和授权客户端应用程序访问资源所有者和资源服务器上拥有的受保护资源的服务器。同一个服务器执行这两个角色并不罕见。
- en: 'To participate in OAuth, your application has to first register with the service
    provider (Google , Facebook, and so on) against which you plan to authenticate
    by providing the application name, application URL, and callback URL. Successful
    registration of your application with the service provider gives you two values
    unique to your application: `client application_id` and `client_secret`. `client_id`
    can be exposed publicly but `client_secret` is kept hidden (private). Both these
    values are needed whenever you access the service provider. The following diagram
    shows the interactions between these roles:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要参与OAuth，您的应用程序必须首先向服务提供商（如Google、Facebook等）注册，以便通过提供应用程序名称、应用程序URL和回调URL进行身份验证。成功注册应用程序与服务提供商后，您将获得两个应用程序唯一的值：`client
    application_id`和`client_secret`。`client_id`可以公开，但`client_secret`保持隐藏（私有）。每当访问服务提供商时，都需要这两个值。以下图显示了这些角色之间的交互：
- en: '![](img/5115c019-94ee-4e31-abfd-1458d4305577.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5115c019-94ee-4e31-abfd-1458d4305577.png)'
- en: 'Figure 8: OAuth role interaction'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：OAuth角色交互
- en: 'The steps in the preceding diagram are covered in detail here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的步骤在这里有详细介绍：
- en: The client application requests the resource owner to give them authorization
    to access the secured resources
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序请求资源所有者授权它们访问受保护资源
- en: If the resource owner authorizes this, the authorization grant is sent to the
    client application
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者授权，授权授予将发送到客户端应用程序
- en: The client application asks for a token, using the grant provided by the resource
    owner along with authentication credentials from the authorization server
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序请求令牌，使用资源所有者提供的授权以及来自授权服务器的身份验证凭据
- en: If the credentials and grant from the client application are valid, the authorization
    server issues an Access Token to the client application
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端应用程序的凭据和授权有效，授权服务器将向客户端应用程序发放访问令牌
- en: The client application accesses the protected resources on the resource server
    using the Access Token provided
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用提供的访问令牌访问资源服务器上的受保护资源
- en: If the Access Token sent by the client application is valid, the resource server
    gives access to the secured resources
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端应用程序发送的访问令牌有效，资源服务器将允许访问受保护资源
- en: Authorization grant types
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权授予类型
- en: As shown in the diagram, for the client to start calling APIs, it needs to obtain
    an authorization grant in the form of an Access Token. OAuth provides four grant
    types, which can be used according to different application requirements. The
    as to which authorization grant type to use is left with the client application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，为了让客户端开始调用API，它需要以访问令牌的形式获得授权授予。OAuth提供了四种授权类型，可以根据不同的应用程序需求使用。关于使用哪种授权授予类型的决定留给了客户端应用程序。
- en: Authorization code flow
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权码流程
- en: 'This a is very commonly used grant type and works on redirection at the server.
    It is highly suitable for server-side applications where the source code is hosted
    on the server and nothing is available on the client. The following diagram explains
    the authorization code grant type flow:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常常用的授权类型，它在服务器上进行重定向。它非常适用于服务器端应用程序，其中源代码托管在服务器上，客户端上没有任何内容。以下图解释了授权码授权类型的流程：
- en: '![](img/54908998-f191-4a15-bc07-7a7469a08aa6.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54908998-f191-4a15-bc07-7a7469a08aa6.png)'
- en: 'Figure 9: Authorization code flow'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：授权码流程
- en: 'The steps in the preceding diagram are explained in detail here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的步骤在这里有详细介绍：
- en: 'The resource owner of the secured resource is presented with a screen in the
    browser to authorize the request. Here is a sample authorization link: `https://<DOMAIN>/oauth/authorize?response_type=code&client_id=<CLIENT_ID>&redirect_uri=<CALLBACK_URL>&scope=<SCOPE>`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 受保护资源的资源所有者将在浏览器中呈现一个屏幕，以授权请求。这是一个示例授权链接：`https://<DOMAIN>/oauth/authorize?response_type=code&client_id=<CLIENT_ID>&redirect_uri=<CALLBACK_URL>&scope=<SCOPE>`。
- en: 'These are the important query parameters in the previous link:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述链接中的重要查询参数：
- en: '`client_id`: The client application ID that we got while registering the application
    with the service provider'
  id: totrans-165
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id`：我们在向服务提供商注册应用程序时获得的客户端应用程序ID'
- en: '`redirect_uri`: After successful authorization, the server redirects to this
    URL supplied'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect_uri`：成功授权后，服务器将重定向到提供的URL'
- en: '`response_type`: A very important parameter the client uses to ask the server
    for the authorization code'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response_type`：客户端用来向服务器请求授权码的非常重要的参数'
- en: '`scope`: Specifies the level of access that it requires'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：指定所需的访问级别'
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者（用户）允许，他们点击授权链接，该链接被发送到授权服务器。
- en: If the authorization request sent to the authorization server is validated and
    found to be successful, the client receives the authorization code grant from
    the authorization server appended as a query parameter in the callback URL (<`CALLBACK_URL>?code=<AUTHORIZATION_CODE>`)
    specified in `Step 1`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发送到授权服务器的授权请求经过验证并且成功，客户端将从授权服务器接收授权码授权，附加为回调URL（`<CALLBACK_URL>?code=<AUTHORIZATION_CODE>`）中的查询参数，指定在`步骤1`中。
- en: Using the authorization grant, the client application requests an Access Token
    from the authorization server (`https://<DOMAIN>/oauth/token?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&grant_type=authorization_code&code=<AUTHORIZATION_CODE>&redirect_uri=CALLBACK_URL`).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用授权授予，客户端应用程序从授权服务器请求访问令牌（`https://<DOMAIN>/oauth/token?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&grant_type=authorization_code&code=<AUTHORIZATION_CODE>&redirect_uri=CALLBACK_URL`）。
- en: In this URL, the client application's `client_secret` also has to be passed,
    along with the `grant_type` parameter, which states that the code passed is the
    authorization code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此URL中，还必须传递客户端应用程序的`client_secret`，以及声明传递的代码是授权代码的`grant_type`参数。
- en: The authorization server validates the credentials and authorization grant and
    sends the Access Token to the client application, preferably in the form of JSON.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器验证凭据和授权授予，并向客户端应用程序发送访问令牌，最好以JSON形式。
- en: The client application calls the protected resource on the resource server using
    the Access Token received in *Step 5*.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用*步骤5*中收到的访问令牌调用资源服务器上的受保护资源。
- en: If the Access Token supplied in *Step 5* is valid, the resource server gives
    access to the secured resource.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*步骤5*中提供的访问令牌有效，则资源服务器允许访问受保护资源。
- en: Implicit flow
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式流
- en: 'This is commonly used in mobile and web applications, and also works based
    on redirection. The following diagram explains the implicit code grant type flow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这在移动和Web应用程序中通常使用，并且也基于重定向工作。以下图表解释了隐式代码授权类型的流程：
- en: '![](img/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png)'
- en: 'Figure 10: Implicit flow'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：隐式流
- en: 'The steps in the preceding diagram are explained in detail here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图表中的步骤在这里进行了详细解释：
- en: 'The resource owner is presented with a screen (browser) to authorize the request.
    Here is an example authorization link: `https://<DOMAIN>/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=<SCOPE>`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源所有者被呈现一个屏幕（浏览器）来授权请求。这是一个示例授权链接：`https://<DOMAIN>/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=<SCOPE>`。
- en: It is important to note that the `response_type` specified in the previous link
    is `token`. This indicates the server should give the Access Token (this is one
    of the main differences from the authorization code flow grant type discussed
    in the previous section).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，前面链接中指定的`response_type`是`token`。这表示服务器应该给出访问令牌（这是与前一节讨论的授权代码流授权类型的主要区别之一）。
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源所有者（用户）允许此操作，则点击授权链接，该链接将发送到授权服务器。
- en: The user-agent (browser or mobile app) receives the Access Token in the `CALLBACK_URL`
    specified (`https://<CALLBACK_URL>#token=<ACCESS_TOKEN>`).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户代理（浏览器或移动应用程序）在指定的`CALLBACK_URL`中接收访问令牌（`https://<CALLBACK_URL>#token=<ACCESS_TOKEN>`）。
- en: The user-agent goes to the specified `CALLBACK_URL`, retaining the Access Token.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户代理转到指定的`CALLBACK_URL`，保留访问令牌。
- en: The client application opens the web page (using any mechanism), which extracts
    the Access Token from the `CALLBACK_URL`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序打开网页（使用任何机制），从`CALLBACK_URL`中提取访问令牌。
- en: The client application now has access to the Access Token.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序现在可以访问访问令牌。
- en: The client application calls the secured API using the Access Token.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用访问令牌调用受保护的API。
- en: Client credentials
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭据
- en: This is one the simplest grant to implement. The client application sends credentials
    (the client's service account), along with `client_ID` and `client_secret,` to
    the authorization server. If the supplied values are valid, the authorization
    server sends the Access Token, which can be used to get access to the secured
    resources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的授权方式之一。客户端应用程序将凭据（客户端的服务帐户）与`client_ID`和`client_secret`一起发送到授权服务器。如果提供的值有效，授权服务器将发送访问令牌，该令牌可用于访问受保护的资源。
- en: Resource owner password credentials
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭据
- en: Again, this is another simple type that can be easily used, but it is considered
    the most insecure of all. In this grant type, the resource owner (user) has to
    key their credentials directly into the client application interface (remember,
    the client application has access to the resource owner's credentials). The credentials
    are then used by the client application to send to the authorization server to
    get the Access Token. This grant type only works if the resource owner fully trusts
    the application through which they give their credentials to the service provider,
    as these credentials pass through the application server of the client application (they
    can therefore be stored, if the client application decides to).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种简单易用的类型，但被认为是所有类型中最不安全的。在这种授权类型中，资源所有者（用户）必须直接在客户端应用程序界面中输入他们的凭据（请记住，客户端应用程序可以访问资源所有者的凭据）。然后客户端应用程序使用这些凭据发送到授权服务器以获取访问令牌。只有在资源所有者完全信任他们提供凭据给服务提供者的应用程序时，这种授权类型才有效，因为这些凭据通过客户端应用程序的应用服务器传递（因此如果客户端应用程序决定的话，它们可以被存储）。
- en: Access Token and Refresh Token
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问令牌和刷新令牌
- en: The Access Token can be used by the client application to retrieve information
    from the resource server for a stipulated time for which the token is deemed valid.
    After this, the server will reject the request with the appropriate HTTP response
    error code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序可以使用访问令牌从资源服务器检索信息，该信息在令牌被视为有效的规定时间内。之后，服务器将使用适当的HTTP响应错误代码拒绝请求。
- en: Along with the Access Token, OAuth allows the authorization server to also send
    another token, the Refresh Token. When the Access Token expires, the client application
    can use this second token to request the authorization server to provide a new
    Access Token.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth允许授权服务器在访问令牌的同时发送另一个令牌，即刷新令牌。当访问令牌过期时，客户端应用程序可以使用第二个令牌请求授权服务器提供新的访问令牌。
- en: Spring Security OAuth project
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security OAuth项目
- en: Currently in the Spring ecosystem, OAuth support has spread to a number of projects,
    including Spring Security Cloud, Spring Security OAuth, Spring Boot, and the edition
    of Spring Security (5.x+). This has created a lot of confusion within the community
    and no single source of ownership. The approach taken by the Spring team is to
    consolidate this and start maintaining everything regarding to OAuth with Spring
    Security. Important components that are part of OAuth, namely the authorization
    server, the resource server, and next-level support for OAuth2, as well as OpenID
    Connect 1.0, are expected to be added to Spring Security by the end of 2018\.
    The Spring Security roadmap clearly states that by mid-2018, support for the resource
    server would be added, and the authorization server by the end of 2018.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Security OAuth project, as it stands at the time of writing this
    book, is in maintenance mode. This means that there will be a release for bug/security
    fixes, along with minor features. No major features are planned to be added to
    this project going forward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The full OAuth2 feature matrix available in various Spring projects can be found
    at [https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix](https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, most of the features that we require to implement
    OAuth is available as part Spring Security OAuth project, which is in maintenance
    mode.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 and Spring WebFlux
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full-fledged OAuth2 support for a Spring WebFlux application is not available
    in Spring Security at the time of writing this book. However, there is a community
    urgency around this and many things are slowly and steadily getting into Spring
    Security in this regard. Many examples are also getting baked into the Spring
    Security project that show OAuth2 with Spring WebFlux. In the [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*, we saw one such example in detail. As of writing
    this book, Spring Security OAuth2 has a hard dependency on Spring MVC.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot and OAuth2
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of writing this book, Spring Boot has announced that it is dropping support
    for the Spring Security OAuth module. Instead, it will from now on with the Spring
    Security 5.x OAuth2 login features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'A new module named Spring Security OAuth Boot 2 Autoconfig (its dependency
    in pom.xml is as shown in the following code snippet), ported from Spring Boot
    1.5.x, can be used to integrate Spring Security with Spring Boot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The project source code can be found at [https://github.com/spring-projects/spring-security-oauth2-boot](https://github.com/spring-projects/spring-security-oauth2-boot)).
    The full documentation for this module can be found at [https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/](https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Sample project
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our sample project, we will set up our own authorization server, against
    which we will authorize the APIs exposed through our resource server. We have
    movie APIs exposed on our resource server, and the client application will authenticate
    with the application (the client application is Spring Security protected) and
    then try accessing one of the movie APIs, at which point the OAuth flow will kick
    in. After a successful authorization check with the authorization server, the
    client will be given access to the requested movie APIs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a parent project containing three Spring Boot projects: `oauth-authorization-server`,
    `oauth-resource-server`, and `oauth-client-app`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a82e06b-986d-4bde-8d68-05c3fd9afa17.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Project structure in IntelliJ'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at each of the individual Spring Boot projects in the subsequent
    sections. The full source code is available on the book's GitHub page under the
    `spring-boot-spring-security-oauth` project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: This is a conventional Spring Boot project, which implements the authorization
    server OAuth role.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的Spring Boot项目，实现了授权服务器OAuth角色。
- en: Maven dependencies
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖
- en: 'The main dependencies to be included in the Spring Boot project''s `pom.xml`
    file are as shown in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含在Spring Boot项目的`pom.xml`文件中的主要依赖项如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Spring Boot run class
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot运行类
- en: 'There is nothing special in this Spring Boot `run` class, as shown in the following
    code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Spring Boot的`run`类并没有什么特别之处，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Spring Security config
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring安全配置
- en: 'The Spring Security config class extends `WebSecurityConfigurerAdapter`. We
    will override three methods, as shown in the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring安全配置类扩展了`WebSecurityConfigurerAdapter`。我们将重写三个方法，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We `autowire` the password encoder. We then override the following methods: `globalUserDetails`,
    `authenticationManagerBean`, and `configure`. There isn't anything special to
    mention here. We define two users, managed in-memory (user and admin).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`autowire`密码编码器。然后我们重写以下方法：`globalUserDetails`、`authenticationManagerBean`和`configure`。这里没有什么特别要提到的。我们在内存中定义了两个用户（用户和管理员）。
- en: Authorization server config
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器配置
- en: 'This is the the most important in this Spring Boot project, where we will set
    up the authorization server configuration. We will use a new annotation, `@EnableAuthorizationServer`.
    Our configuration class will extend `AuthorizationServerConfigurerAdapter`. We
    will be using the JWT token store and will also showcase a token enhancer, using
    which you can enhance your JWT token with more claims, if deemed necessary for
    your application. The most important method in this configuration class is extracted
    as the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个Spring Boot项目中最重要的部分，我们将在其中设置授权服务器配置。我们将使用一个新的注解`@EnableAuthorizationServer`。我们的配置类将扩展`AuthorizationServerConfigurerAdapter`。我们将使用JWT令牌存储，并展示一个令牌增强器，使用它可以在需要时增强JWT令牌的声明。这个配置类中最重要的方法被提取为下面的代码片段：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is where we set up the client-related OAuth configuration. We set up just
    one client, and we use the in-memory option to make the example simpler to understand.
    Throughout the application, we will be using `BCrypt` as our password encoder.
    The client ID for our client app is `oAuthClientAppID` and the client secret is
    `secret`. We set up three grant types and while accessing the client, we need
    to specify the necessary scopes (movie, read, and write). After successful execution,
    the authorization server will redirect you to the specified URL (`http://localhost:8080/movie/`
    or `http://localhost:8080/movie/index`). If the URL is not correctly specified
    by the client, the server will throw an error.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设置与客户端相关的OAuth配置的地方。我们只设置了一个客户端，并使用内存选项使示例更容易理解。在整个应用程序中，我们将使用`BCrypt`作为我们的密码编码器。我们的客户端应用程序的客户端ID是`oAuthClientAppID`，客户端密钥是`secret`。我们设置了三种授权类型，访问客户端时需要指定必要的范围（movie、read和write）。执行成功后，授权服务器将重定向到指定的URL（`http://localhost:8080/movie/`或`http://localhost:8080/movie/index`）。如果客户端没有正确指定URL，服务器将抛出错误。
- en: 'The JWT token store and enhancer-related methods are as shown in the following
    code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌存储和增强相关方法如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, we specify the token store, which will be used in the `tokenStore`
    method, and we also declare a `tokenEnhancer` bean. To showcase the token enhancer,
    we will be using a custom class named `CustomTokenEnhancer`; the class is as shown
    in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们指定了将在`tokenStore`方法中使用的令牌存储，并声明了一个`tokenEnhancer` bean。为了展示令牌增强器，我们将使用一个名为`CustomTokenEnhancer`的自定义类；该类如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The custom token `enhancer` class implements `TokenEnhancer`. We just add new
    information (`principalinfo`) into the JWT token that contains the `toString`
    version of the `principal` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义令牌`enhancer`类实现了`TokenEnhancer`。我们只是将新信息（`principalinfo`）添加到包含`principal`对象的`toString`版本的JWT令牌中。
- en: Application properties
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: 'Since we are running all three servers locally, we have to specify different
    ports. Also, it''s important that the authorization server runs on a different
    context path. The following code snippet shows what we have in our `application.properties`
    file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本地运行了所有三个服务器，我们必须指定不同的端口。此外，授权服务器运行在不同的上下文路径上是很重要的。下面的代码片段显示了我们在`application.properties`文件中的内容：
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个Spring Boot项目，可以通过执行`mvn spring-boot:run`命令来运行。
- en: Resource server
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: This is a conventional Spring Boot project, which implements the resource server
    OAuth role.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的Spring Boot项目，实现了资源服务器OAuth角色。
- en: Maven dependencies
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖
- en: There isn't anything new that we are going to add in our `pom.xml`. The same
    dependencies that we had in our authorization server project apply here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`pom.xml`中，我们不会添加任何新的内容。我们在授权服务器项目中使用的相同依赖项也适用于这里。
- en: Spring Boot run class
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot运行类
- en: This is a typical Spring Boot `run` class, into which we put the `@SpringBootApplication`
    annotation, which does all the magic behind the scenes. Again, nothing specific
    in our Spring Boot run class applies to this project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的Spring Boot `run`类，我们在其中放置了`@SpringBootApplication`注解，它在幕后完成了所有的魔术。同样，在我们的Spring
    Boot运行类中没有特定于这个项目的内容。
- en: Resource server config
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器配置
- en: 'This is the main resource server configuration class, where we annotate it
    with the `@EnableResourceServer` annotation and extend it from `ResourceServerConfigurerAdapter`,
    as shown in the following code snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的资源服务器配置类，我们在其中使用`@EnableResourceServer`注解，并将其扩展自`ResourceServerConfigurerAdapter`，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Spring Security config
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring安全配置
- en: 'Being the resource server, we are enabling global method security so that every
    method exposing an API is secured, as shown in the following code snippet:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为资源服务器，我们启用了全局方法安全，以便每个暴露API的方法都受到保护，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we are using `OAuth2MethodSecurityExpressionHandler` as the method security
    exception handler so that we can use annotations, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`OAuth2MethodSecurityExpressionHandler`作为方法安全异常处理程序，以便我们可以使用注解，如下所示：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Spring MVC config class
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC配置类
- en: We have seen Spring MVC configuration in detail in previous chapters. In our
    example, it's a very basic Spring MVC `config` class in which `@EnableWebMvc`
    is used and implements `WebMvcConfigurer`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中详细介绍了Spring MVC配置。在我们的示例中，这是一个非常基本的Spring MVC `config`类，其中使用了`@EnableWebMvc`并实现了`WebMvcConfigurer`。
- en: Controller class
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'We have one controller class, which exposes just one method (we can extend
    it further to expose more APIs). This method lists all the movies in the hardcoded
    movie list under a URL, `/movie`, as shown in the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个控制器类，只公开一个方法（我们可以进一步扩展以公开更多的API）。这个方法列出了硬编码的电影列表中的所有电影，位于URL`/movie`下，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are using a `Movie` model class utilizing all the features of the `lombok`
    library, as shown in the following code snippet:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个`Movie`模型类，利用了`lombok`库的所有功能，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It has three attributes and the annotations will do all the magic and keep the
    model concise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个属性，注解将完成所有的魔术并保持模型简洁。
- en: Application properties
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: Similar to the authorization server, `application.properties` just has the context
    path and port assigned.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与授权服务器类似，`application.properties`只有上下文路径和端口分配。
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个Spring Boot项目，可以通过执行`mvn spring-boot:run`命令来运行。
- en: Client application
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端应用程序
- en: This is a conventional Spring Boot project, which implements the client OAuth
    role.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的Spring Boot项目，实现了客户端OAuth角色。
- en: Maven dependencies
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: In our Spring Boot `pom.xml` file, new Maven dependencies for `Thymeleaf` and
    for the `lombok` library are added. The rest are all typical of a Spring Boot
    `pom.xml` file, which you are now conversant with.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Spring Boot `pom.xml`文件中，添加了`Thymeleaf`和`lombok`库的新Maven依赖项。其余部分都是典型的Spring
    Boot `pom.xml`文件，你现在已经熟悉了。
- en: Spring Boot class
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot类
- en: In our example Spring Boot `run` class, there isn't anything worth mentioning.
    It is a simple class containing the all-important `main` method and the `@SpringBootApplication`
    annotation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例Spring Boot `run`类中，没有什么值得一提的。这是一个简单的类，包含了至关重要的`main`方法和`@SpringBootApplication`注解。
- en: OAuth client config
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth客户端配置
- en: 'This is the main configuration class in the client application, which is annotated
    with `@EnableOAuth2Client`, as shown in the following code snippet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端应用程序中的主配置类，使用了`@EnableOAuth2Client`注解，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The important aspect to look at in this class is that we initialize the OAuth2
    REST template by providing the client details, which are configured in the `application.yml`
    file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中要注意的重要方面是，我们通过在`application.yml`文件中配置客户端详细信息来初始化OAuth2 REST模板。
- en: Spring Security config
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring安全配置
- en: In the Spring Security `config` class, we set up the user credentials (in-memory)
    that can be used to log in to the application and can access secured resources.
    In the `configure` method, some of the resources are marked as secured and some
    as unsecured.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring安全`config`类中，我们设置了可以用于登录到应用程序并访问受保护资源的用户凭据（内存中）。在`configure`方法中，一些资源被标记为受保护的，一些资源被标记为未受保护的。
- en: Controller classes
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类
- en: 'We have two controller classes, `SecuredController` and `NonSecuredController`.
    As the name suggests, one is for declared secured routes and the other for unsecured
    routes. The `main` method in the secured controller that we are interested is
    shown in the following code snippet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个控制器类，`SecuredController`和`NonSecuredController`。顾名思义，一个用于声明的受保护路由，另一个用于未受保护的路由。我们感兴趣的受保护控制器中的`main`方法如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We copied the `model` class used in the resource server project into the client
    application project as well. In an ideal scenario, all this common stuff would
    be converted into reusable JARs and set up as a dependency to both the projects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将资源服务器项目中使用的`model`类复制到客户端应用程序项目中。在理想情况下，所有这些共同的东西都将被转换为可重用的JAR，并设置为两个项目的依赖项。
- en: Templates
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: The templates are quite straightforward. The root context of the application
    redirects the user to an unsecured page. We have our own custom login page and
    after a successful login, the user is navigated to a secured page containing a
    link to the secured OAuth-backed movie listing API.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 模板非常简单。应用程序的根上下文将用户重定向到一个未安全的页面。我们有自己的自定义登录页面，登录成功后，用户将被导航到一个包含指向受保护的OAuth支持的电影列表API的链接的受保护页面。
- en: Application properties
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序属性
- en: 'In this project, we are using `application.yml` files and the code is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用`application.yml`文件，代码如下：
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The very important aspect of this YML file is the `movie-app-client` properties
    setup. Again, being a Spring Boot project, it can be run by executing the `mvn
    spring-boot:run` command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YML文件的非常重要的方面是`movie-app-client`属性设置。同样，作为一个Spring Boot项目，可以通过执行`mvn spring-boot:run`命令来运行。
- en: Running the project
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'Start all the projects individually using the Spring Boot `mvn spring-boot:run` command.
    I am using Spring Dashboard in IntelliJ, where I can launch all the projects,
    as shown in the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot的`mvn spring-boot:run`命令分别启动所有项目。我在IntelliJ中使用Spring Dashboard，可以启动所有项目，如下面的截图所示：
- en: '![](img/f21f02f6-d40c-4e79-a32c-324886db5c03.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f21f02f6-d40c-4e79-a32c-324886db5c03.png)'
- en: 'Figure 12: Spring Dashboard in IntelliJ'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：IntelliJ中的Spring Dashboard
- en: 'Navigate to `http://localhost:8080` and you will be redirected to the unsecured
    page of the client application, as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8080`，您将被重定向到客户端应用程序的未安全页面，如下所示：
- en: '![](img/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png)'
- en: 'Figure 13: Unsecured page of client app'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：客户端应用程序的未安全页面
- en: 'Click on the link, and you will be taken to the custom login page, as shown
    here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接，您将被带到自定义登录页面，如下所示：
- en: '![](img/88846da5-d718-452c-9193-ea3637bd0b20.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88846da5-d718-452c-9193-ea3637bd0b20.png)'
- en: 'Figure 14: Custom login page of client app'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：客户端应用程序的自定义登录页面
- en: 'Enter the username/password as required on the page; then, clicking on Log
    In will take you to the secured page, as shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 根据页面上的要求输入用户名/密码；然后，点击登录将带您到安全页面，如下所示：
- en: '![](img/e0fe14e3-c9f7-45a3-8341-763f88434956.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0fe14e3-c9f7-45a3-8341-763f88434956.png)'
- en: 'Figure 15: Secured page in client app'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：客户端应用程序中的安全页面
- en: 'Click on the movie API link, and you will be taken to the OAuth flow and then
    to the authorization server default login page to enter credentials, as shown
    here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 点击电影API链接，您将被带到OAuth流程，然后到授权服务器的默认登录页面以输入凭据，如下所示：
- en: '![](img/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png)'
- en: 'Figure 16: Authorization server login page'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图16：授权服务器登录页面
- en: 'Enter the username/password (we have kept that as user/password) and click
    on the Login button. You will be taken to the authorization page, as shown in
    the following screenshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输入用户名/密码（我们将其保留为user/password），然后点击登录按钮。您将被带到授权页面，如下面的截图所示：
- en: '![](img/c0889860-4aef-44de-bb61-3bd099664046.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0889860-4aef-44de-bb61-3bd099664046.png)'
- en: 'Figure 17: Authorization page on authorization server'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图17：授权服务器上的授权页面
- en: 'Click on Authorize and you will be taken back to the client application page,
    which displays all the movies from the resource server, as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 点击授权，您将被带回客户端应用程序页面，显示来自资源服务器的所有电影，如下所示：
- en: '![](img/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png)'
- en: 'Figure 18: Movie listing page in the client app displaying a movie API exposed
    on resource server'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图18：客户端应用程序中显示资源服务器上暴露的电影API的电影列表页面
- en: With this, we have completed our sample application, in which we have implemented
    all the roles that are part of OAuth.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了我们的示例应用程序，其中我们实现了OAuth的所有角色。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by introducing you to some of the important concepts
    that are needed to follow along with it. We then covered the important characteristics
    needed in a modern web application. We quickly covered an architecture called
    **SOFEA**, which aptly covers how we would like to build modern applications.
    We then got our hands dirty by implementing security for REST APIs in the simplest
    of ways.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时向您介绍了一些需要跟进的重要概念。然后我们介绍了现代Web应用程序所需的重要特征。我们迅速介绍了一个称为**SOFEA**的架构，它恰当地介绍了我们想要构建现代应用程序的方式。然后我们通过最简单的方式实现了REST
    API的安全性。
- en: In the following section, we covered how we can secure a REST API in a more
    advanced fashion employing OAuth, using a JWT. We started this section by introducing
    many concepts in regards to OAuth and finally concluded the chapter with a full-fledged
    sample project that uses OAuth and JWT.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们介绍了如何以更高级的方式使用OAuth来保护REST API，使用JWT。我们通过介绍了许多关于OAuth的概念开始了本节，最后以使用OAuth和JWT的完整示例项目结束了本章。
- en: After reading this chapter, you should have a clear understanding of REST, OAuth,
    and JWT. You should also be comfortable with using Spring Security in the next
    chapter, to secure the RESTful endpoints exposed in your application.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该对REST、OAuth和JWT有清晰的理解。您还应该在下一章中，对在应用程序中暴露的RESTful端点使用Spring Security感到舒适。

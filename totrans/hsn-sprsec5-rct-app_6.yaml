- en: REST API Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security can be used to secure REST APIs. This chapter begins with the
    introduction of some of the important concepts in regard to REST and the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then introduces OAuth concepts and by using hands-on coding examples,
    explains simple and advanced REST API security utilizing the Spring Security and
    Spring Boot modules in the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the OAuth protocol in our examples to secure exposed REST API's
    utilizing Spring Security features to the fullest. We will be using the JWT to
    exchange claims between the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple REST API security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced REST API security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security OAuth project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2 and Spring WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot and OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into coding, we need to be conversant with some important concepts.
    This section is aimed at introducing you to some of these concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style presented
    by Roy Fielding in the year 2000 for developing web services. It is built on top
    of the well-known **Hypertext Transfer Protocol** (**HTTP**) and can transfer
    data in multiple formats, the most common being **JavaScript Object Notation**
    (**JSON**) and **eXtensible Markup Language** (**XML**). The status of a request
    in REST is indicated using standard HTTP status code (200: OK, 404: Page not found!,
    and so on). Being based on HTTP, security is taken care of using the already familiar
    **Secure Sockets Layer** (**SSL**) and **Transport Layer Security** (**TLS**).'
  prefs: []
  type: TYPE_NORMAL
- en: While writing such web services, you are free to use any programming language
    (Java, .NET, and so on) that is capable of making web requests based on HTTP (which
    is a de facto standard that every language supports). You have a number of well-known
    frameworks, using which developing RESTful APIs on the server side is quite easy
    and simple. Also, on the client side, there are a number of frameworks that make
    invoking RESTful APIs and handling responses straightforward and easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since REST works on internet protocol, the caching of a web service response
    can be achieved quite easily by supplying appropriate HTTP headers (Cache-Control,
    Expires, and so on). The HTTP methods `PUT` and `DELETE` are not cacheable in
    any scenario. The following table summarizes the use of HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Retrieves a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Creates a new resource |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Updates an existing resource |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Deletes an existing resource |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Makes a partial update to a resource |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1: HTTP method usage'
  prefs: []
  type: TYPE_NORMAL
- en: A REST API request/response (data sent over the wire) can be compressed by specifying
    appropriate HTTP headers, similar to caching. The HTTP header, Accept-Encoding,
    is sent by the client to the server, to let the server know the compression algorithms
    it can understand. The server successfully compresses a response and puts out
    another HTTP header, Content-Encoding, letting the client know which algorithm
    has to be used to decompress.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Token (JWT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <q>"JSON Web Tokens are an open, industry standard RFC 7519 method for representing
    claims securely between two parties."</q>
  prefs: []
  type: TYPE_NORMAL
- en: '*- [https://jwt.io/](https://jwt.io/)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, the stateless nature of HTTP was circumvented in a web application
    (most of them are stateful in nature) by associating each request with a session
    ID created on the server and then stored by the client using cookies. Each request
    sends the cookie (session ID) in the form of an HTTP header, which gets validated
    by the server, and a state (a user session) is associated with each request. In
    modern applications (we will cover this in a bit more detail in the next section),
    a server-side session ID is replaced with the JWT. The following diagram shows
    the workings of the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f181c449-77aa-498b-a77a-2104f1bb75ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Workings of the JWT in modern applications'
  prefs: []
  type: TYPE_NORMAL
- en: The web server, in this case, doesn't create a user session and the user session
    management capability needed for a stateful application is offloaded to other
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of the Spring Framework, the Spring Session module can be employed
    to externalize the session from the web server to a central persistence store
    (Redis, Couchbase, and so on). Every request containing a valid token (JWT) is
    validated against this external store of authenticity and validity. After successful
    authentication, applications can generate a valid token and send it as a response
    to the client. The client can then store this token in any client storage mechanism
    it uses (sessionStorage, localStorage, cookies, and so on, in a browser). Using
    Spring Security, we can validate this token to ascertain the authenticity and
    validity of the user and then do whatever is required. We have a dedicated example
    in a subsequent section (Simple REST API security) of this chapter, which uses
    a basic authentication mechanism and, if successful, creates the JWT. Subsequent
    requests use the token in the HTTP header, which gets validated on the server
    to give access to other secured resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points highlight some of the advantages of using the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better performance**: Each request, when reaching the server, has to check
    the authenticity of the token send. The authenticity of the JWT can be checked
    locally and doesn''t require an external call (say, to a database). This local
    validation is performant and reduces the overall response time for a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: JWT is easy and simple to implement. Also, it is a well established
    format in the industry for tokens. There are a number of well-known libraries
    which can be used to easily work with the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike common security mechanisms, such as encryption, obscuring, and hiding,
    the JWT doesn''t encrypt or hide the data contained within. But, it does the destination
    system to check whether the token is from an authentic source. The structure of
    the JWT consists of a header, payload, and a signature. As mentioned, rather than
    encryption, the data contained within the JWT is encoded and then signed. Encoding
    does the job of transforming the data in a way that is acceptable by a variety
    of parties and signing allows us to check for its authenticity and, in fact, its
    origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's go into more detail about each of the components constituting the token.
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a JSON object and takes the following format. It gives information
    on how the signature should be computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value of `typ` specifies type of the object, and in this case, it is the
    `JWT`. The value of `alg` specifies the algorithm used to create the signature,
    and in this case it is `HMAC-SHA256`.
  prefs: []
  type: TYPE_NORMAL
- en: Payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The payload forms the actual data (also known as a **claim**) stored in the
    JWT. According to your application''s requirements, you can put any number of
    claims into your JWT payload component. There are some predefined claims, such
    as `iss` (issuer), `sub` (subject), `exp` (expiration time), `iat` (issued at),
    and so on, that can be used, but all of these are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signature is formed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `header` is `base64` encoded: `base64(header)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `payload` is `base64` encoded: `base64(payload)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now join the values in *Step 1* and *Step 2* with a `"."` in the middle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the signature is attained by hashing, using the algorithm specified in
    the header, the value attained in *Step 3*, and then appending it with the secret
    text (say `packtpub`) of your choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final JWT is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The website [https://jwt.io/](https://jwt.io/) is a place I always visit for
    any of my JWT needs. The sample data used in this example is from that site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e508052-e050-47bd-8b70-db78d22598e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Screen grab from https://jwt.io/'
  prefs: []
  type: TYPE_NORMAL
- en: Modern application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frontends of most modern applications are not built using server-side web application
    frameworks, such as Spring MVC, **Java Server Faces** (**JSF**), and so on. Infact,
    many are built using full-fledged client-side frameworks, such as React (to be
    full-fledged, it has to be combined with other libraries), Angular, and so on.
    The previous statement doesn't mean in any way that there is no place for such
    server-side web application frameworks. According to the application you are building,
    there are specific places for each of these frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: When using client-side frameworks, the client code (HTML, JS, CSS, and so on)
    in general is not secured. However, the data required to render these dynamic
    pages is secured behind a RESTful endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To secure a RESTful backend, the JWT is used to exchange claims between the
    server and the client. The JWT enables the stateless exchange of tokens between
    the two parties and takes away the burden of session management (no more sticky
    sessions or session replication between multiple server nodes) by the server.
    This enables the application to scale horizontally in a cost-effective manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/841b4165-d61d-41e8-89ec-89647e225641.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: API-based modern application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: SOFEA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Service-Oriented Front-End Architecture** (**SOFEA**) is of the architectural
    style which had gained popularity in the past when **S****ervice Oriented Architecture** (**SOA**)
    and was becoming common in many enterprises. In modern days, SOA is more of less
    with microservices-based architecture and the backend is reduced to a bunch of
    RESTful endpoints. The client on the other hand is becoming thicker and uses client-side
    MVC frameworks such as Angular and React, just to name a couple. However, the
    core concept of SOFEA, in which backend is just endpoints and frontend (UI) becoming
    thicker is something everyone considers in modern age web application development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of SOFEA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client in this is thicker (similar to thick client applications) as against
    thin client web applications that we have seen in the past. After initial view/rendering
    of pages, all the assets are downloaded from server and resides/caches on the
    client (browser). Thereafter, the server is contacted only for data when required
    by the client through XHR (Ajax) calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the client code is downloaded, only data flows from the server to the
    client, as opposed to presentation code (HTML, JavaScript, and so on), better
    utilizing the bandwidth. As there is less data being transferred, response times
    are faster, making applications perform better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of clients can be written utilizing the same RESTful server endpoints,
    reusing APIs to the fullest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These endpoints can externalize a session (in the Spring Framework, there is
    a module called **Spring Session**, which can be used to achieve this technical
    capability), thus easily achieving the horizontal scalability of the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better role segregation of team members in a project with APIs managed by a
    team and UI code managed by a different team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication
    Using CAS and JAAS*, we went through the reactive Spring WebFlux web application
    framework in detail. We also looked into a lot of the reactive programming support
    provided by the Spring Framework and other Spring modules. Knowingly or unknowingly,
    we created a reactive REST API in the previous chapter's example sections. We
    used a handler and router mechanism for creating a RESTful application and also
    secured it using the *BASIC* authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the workings of `WebClient` (a reactive way of calling REST APIs, as
    opposed to using a blocking `RestTemplate`) and `WebTestClient` (a reactive way
    of writing test cases). We also saw the workings of Spring Data in a reactive
    way using MongoDB as the persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go through these aspects here; we will only mention that, if you
    wish, you can make yourself comfortable with this topic by going through the section
    in [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml), *Authentication Using
    CAS and JAAS*. In this chapter, we will cover where we left off from the previous
    chapter by getting to REST API security using the JWT, and then going through
    REST API security using OAuth (implementing a custom provider as opposed to using
    public providers, such as Google, Facebook, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Simple REST API security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the example that we created in [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml), *Integrating
    with Spring WebFlux* (*spring-boot-spring-webflux*) and expand on it by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the JWT support to the already existing Spring WebFlux application
    secured using basic authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new controller (`path /auth/**`) that will have new endpoints, using
    which you can authenticate the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using basic authentication or the auth REST endpoint, we will generate the JWT
    on the server and send it as a response to the client. Subsequent calls from the
    client to access secured REST APIs can be achieved by using the JWT supplied as
    a HTTP header (authorization, bearer token).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't be able to go into each and every detail of this project (we have a
    more important topic that we need to cover in this chapter within the stipulated
    page count). However, while going through the example, important code snippets
    will be listed down and explained in detail to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Spring Security configuration, we tweak the `springSecurityFilterChain`
    bean, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a new `AuthenticationWebFilter` and a `AuthenticationSuccessHandler`
    configured. We also have a new `JWTAuthWebFilter` class for handling the JWT-based
    authentication configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using `ReactiveUserDetailsService` with hardcoded user credentials
    for testing, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Authentication success handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We set up a custom `AuthenticationSuccessHandler` (the source code for this
    class is shown next) in our Spring Security configuration class. On successful
    authentication, it will generate the JWT and also set a HTTP response header:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header name**: `Authorization`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header value**: `Bearer JWT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JWTUtil` class contains a number of utility methods dealing with the JWTs,
    such as the generation of tokens, verification of tokens, and so on. The `generateToken`
    method in the `JWTUtil` class is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Custom WebFilter namely JWTAuthWebFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our custom `WebFilter`, named `JWTAuthWebFilter`, is entrusted with converting
    the JWT token received into appropriate classes that the Spring Security understands.
    It makes use of a converter named `JWTAuthConverter`, which does a number of things,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the authorization `payload`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts the token by discarding the `Bearer` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies the token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a `UsernamePasswordAuthenticationToken` class understood by Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code snippet below shows the `JWTAuthWebFilter` class and its important
    method which does operations listed above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After this conversion, it does the actual authentication using Spring Security,
    which sets `SecurityContext` in the application, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `JWTAuthWebFilter` class filter method does the necessary conversions and
    then the `authenticate` method does the actual authentication, and finally calls
    the `onAuthSuccess` method.
  prefs: []
  type: TYPE_NORMAL
- en: New controller classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two controllers, namely `DefaultController` (mapped to the `/` and
    `/login` paths) and `AuthController` (mapped to the `/auth` main route and `/token`
    sub-route). The `/auth/token` path can be used to retrieve the token, which can
    be used for a subsequent API call (`Bearer <Token>`). The code snippet for `AuthController`
    is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the application and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the application using the Spring Boot command shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I will be using Postman to execute the REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get hold of the token, to include it in subsequent calls, by employing
    two methods as detailed below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you access any route using basic authentication credentials, in the response
    header, you should get the token. I will be using the `/login` path with Basic
    Auth (authorization header) to get the token, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d417a89e-0a43-4612-964b-8d12a8c02328.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Getting token using Basic Auth in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the `/auth/token` endpoint with Basic Auth credentials supplied in the
    form of JSON (using the `JWTAuthRequest` class), as shown here, in Postman:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b601600b-0c3b-4c15-8c9a-9414f2a45049.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Getting token using /auth/token endpoint using Basic Auth credentials
    in JSON'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the token retrieved, call the movie endpoint, as shown here, using Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/967a0611-eeb5-44d1-91ad-c9373acbc3cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Retrieving movie listing using a JWT token in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: This completes the example that we were building. In this example, we secured
    the REST APIs by making use of JWT and validated them using Spring Security. As
    mentioned, this is a basic way in which you can secure your REST APIs using Spring
    Security with JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced REST API security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs can be secured by another mechanism in your web application, OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth is an authorization framework that allows other applications with the
    right credentials access to partial/limited user profile details stored on platforms
    such as Google and Facebook. The authentication part is delegated to these services
    and if successful, appropriate grants are given to the calling client/application,
    which can be used to get access to secured resources (in our case RESTful APIs).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen OAuth security using a public authentication provider in [Chapter
    3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication Using CAS and
    JAAS* (in the *OAuth 2 and OpenID connect* section). However, we need not use
    these public providers; you have the choice of using your own. We will cover one
    such example in this chapter, where we will be using our own authentication provider
    and securing our Spring Boot-based reactive REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into the example, we need to understand a bit more about OAuth,
    and also need to understand its various components. We already went through a
    lot of the details of OAuth in [Chapter 3](https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=30&action=edit#post_28), *Authentication
    Using CAS and JAAS*. We will add to those details in this section and then go
    through the code example.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth stipulates four roles for users and applications. The interactions between
    these roles are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d946741-9ac2-4e7f-8504-a46b832ebb27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: OAuth role interaction'
  prefs: []
  type: TYPE_NORMAL
- en: We will look into each of these OAuth roles in some detail.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the user who owns the protected resource that is needed by the consuming
    client application. If we take Facebook or Google as the authentication provider,
    the resource owner is the actual user who has data saved on these platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the server that has the secured resources in the form of hosted APIs.
    If we take Google or Facebook as an example, they hold the profile information,
    as well as other information, in the form of APIs. If the client application successfully
    authenticates (using the credentials provided by the user) and then the user grants
    appropriate permissions, they can get access to this information through their
    exposed APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the application that to access the secured resources available on the
    resource server. If the user is successfully authenticated and the client application
    is given permission by the user to access the right information, the client application
    can retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the server that authenticates and authorizes client applications to
    access the secured resources owned by the resource owner and on the resource server. It
    is not uncommon to see the same server performing both roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To participate in OAuth, your application has to first register with the service
    provider (Google , Facebook, and so on) against which you plan to authenticate
    by providing the application name, application URL, and callback URL. Successful
    registration of your application with the service provider gives you two values
    unique to your application: `client application_id` and `client_secret`. `client_id`
    can be exposed publicly but `client_secret` is kept hidden (private). Both these
    values are needed whenever you access the service provider. The following diagram
    shows the interactions between these roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5115c019-94ee-4e31-abfd-1458d4305577.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: OAuth role interaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in the preceding diagram are covered in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application requests the resource owner to give them authorization
    to access the secured resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the resource owner authorizes this, the authorization grant is sent to the
    client application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application asks for a token, using the grant provided by the resource
    owner along with authentication credentials from the authorization server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the credentials and grant from the client application are valid, the authorization
    server issues an Access Token to the client application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application accesses the protected resources on the resource server
    using the Access Token provided
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Access Token sent by the client application is valid, the resource server
    gives access to the secured resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorization grant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the diagram, for the client to start calling APIs, it needs to obtain
    an authorization grant in the form of an Access Token. OAuth provides four grant
    types, which can be used according to different application requirements. The
    as to which authorization grant type to use is left with the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This a is very commonly used grant type and works on redirection at the server.
    It is highly suitable for server-side applications where the source code is hosted
    on the server and nothing is available on the client. The following diagram explains
    the authorization code grant type flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54908998-f191-4a15-bc07-7a7469a08aa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Authorization code flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in the preceding diagram are explained in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource owner of the secured resource is presented with a screen in the
    browser to authorize the request. Here is a sample authorization link: `https://<DOMAIN>/oauth/authorize?response_type=code&client_id=<CLIENT_ID>&redirect_uri=<CALLBACK_URL>&scope=<SCOPE>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the important query parameters in the previous link:'
  prefs: []
  type: TYPE_NORMAL
- en: '`client_id`: The client application ID that we got while registering the application
    with the service provider'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_uri`: After successful authorization, the server redirects to this
    URL supplied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response_type`: A very important parameter the client uses to ask the server
    for the authorization code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope`: Specifies the level of access that it requires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the authorization request sent to the authorization server is validated and
    found to be successful, the client receives the authorization code grant from
    the authorization server appended as a query parameter in the callback URL (<`CALLBACK_URL>?code=<AUTHORIZATION_CODE>`)
    specified in `Step 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the authorization grant, the client application requests an Access Token
    from the authorization server (`https://<DOMAIN>/oauth/token?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&grant_type=authorization_code&code=<AUTHORIZATION_CODE>&redirect_uri=CALLBACK_URL`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this URL, the client application's `client_secret` also has to be passed,
    along with the `grant_type` parameter, which states that the code passed is the
    authorization code.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server validates the credentials and authorization grant and
    sends the Access Token to the client application, preferably in the form of JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application calls the protected resource on the resource server using
    the Access Token received in *Step 5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Access Token supplied in *Step 5* is valid, the resource server gives
    access to the secured resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implicit flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is commonly used in mobile and web applications, and also works based
    on redirection. The following diagram explains the implicit code grant type flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8da3f363-ff0a-4d4a-9058-9247f0dc33e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Implicit flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps in the preceding diagram are explained in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource owner is presented with a screen (browser) to authorize the request.
    Here is an example authorization link: `https://<DOMAIN>/oauth/authorize?response_type=token&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=<SCOPE>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that the `response_type` specified in the previous link
    is `token`. This indicates the server should give the Access Token (this is one
    of the main differences from the authorization code flow grant type discussed
    in the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: If the resource owner (user) allows this, they click on the authorize link,
    which is sent to the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user-agent (browser or mobile app) receives the Access Token in the `CALLBACK_URL`
    specified (`https://<CALLBACK_URL>#token=<ACCESS_TOKEN>`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user-agent goes to the specified `CALLBACK_URL`, retaining the Access Token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application opens the web page (using any mechanism), which extracts
    the Access Token from the `CALLBACK_URL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application now has access to the Access Token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application calls the secured API using the Access Token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one the simplest grant to implement. The client application sends credentials
    (the client's service account), along with `client_ID` and `client_secret,` to
    the authorization server. If the supplied values are valid, the authorization
    server sends the Access Token, which can be used to get access to the secured
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner password credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, this is another simple type that can be easily used, but it is considered
    the most insecure of all. In this grant type, the resource owner (user) has to
    key their credentials directly into the client application interface (remember,
    the client application has access to the resource owner's credentials). The credentials
    are then used by the client application to send to the authorization server to
    get the Access Token. This grant type only works if the resource owner fully trusts
    the application through which they give their credentials to the service provider,
    as these credentials pass through the application server of the client application (they
    can therefore be stored, if the client application decides to).
  prefs: []
  type: TYPE_NORMAL
- en: Access Token and Refresh Token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Access Token can be used by the client application to retrieve information
    from the resource server for a stipulated time for which the token is deemed valid.
    After this, the server will reject the request with the appropriate HTTP response
    error code.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the Access Token, OAuth allows the authorization server to also send
    another token, the Refresh Token. When the Access Token expires, the client application
    can use this second token to request the authorization server to provide a new
    Access Token.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security OAuth project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently in the Spring ecosystem, OAuth support has spread to a number of projects,
    including Spring Security Cloud, Spring Security OAuth, Spring Boot, and the edition
    of Spring Security (5.x+). This has created a lot of confusion within the community
    and no single source of ownership. The approach taken by the Spring team is to
    consolidate this and start maintaining everything regarding to OAuth with Spring
    Security. Important components that are part of OAuth, namely the authorization
    server, the resource server, and next-level support for OAuth2, as well as OpenID
    Connect 1.0, are expected to be added to Spring Security by the end of 2018\.
    The Spring Security roadmap clearly states that by mid-2018, support for the resource
    server would be added, and the authorization server by the end of 2018.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Security OAuth project, as it stands at the time of writing this
    book, is in maintenance mode. This means that there will be a release for bug/security
    fixes, along with minor features. No major features are planned to be added to
    this project going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The full OAuth2 feature matrix available in various Spring projects can be found
    at [https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix](https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, most of the features that we require to implement
    OAuth is available as part Spring Security OAuth project, which is in maintenance
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 and Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full-fledged OAuth2 support for a Spring WebFlux application is not available
    in Spring Security at the time of writing this book. However, there is a community
    urgency around this and many things are slowly and steadily getting into Spring
    Security in this regard. Many examples are also getting baked into the Spring
    Security project that show OAuth2 with Spring WebFlux. In the [Chapter 5](df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml),
    *Integrating with Spring WebFlux*, we saw one such example in detail. As of writing
    this book, Spring Security OAuth2 has a hard dependency on Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot and OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of writing this book, Spring Boot has announced that it is dropping support
    for the Spring Security OAuth module. Instead, it will from now on with the Spring
    Security 5.x OAuth2 login features.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new module named Spring Security OAuth Boot 2 Autoconfig (its dependency
    in pom.xml is as shown in the following code snippet), ported from Spring Boot
    1.5.x, can be used to integrate Spring Security with Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The project source code can be found at [https://github.com/spring-projects/spring-security-oauth2-boot](https://github.com/spring-projects/spring-security-oauth2-boot)).
    The full documentation for this module can be found at [https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/](https://docs.spring.io/spring-security-oauth2-boot/docs/current-SNAPSHOT/reference/htmlsingle/).
  prefs: []
  type: TYPE_NORMAL
- en: Sample project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our sample project, we will set up our own authorization server, against
    which we will authorize the APIs exposed through our resource server. We have
    movie APIs exposed on our resource server, and the client application will authenticate
    with the application (the client application is Spring Security protected) and
    then try accessing one of the movie APIs, at which point the OAuth flow will kick
    in. After a successful authorization check with the authorization server, the
    client will be given access to the requested movie APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a parent project containing three Spring Boot projects: `oauth-authorization-server`,
    `oauth-resource-server`, and `oauth-client-app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a82e06b-986d-4bde-8d68-05c3fd9afa17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Project structure in IntelliJ'
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at each of the individual Spring Boot projects in the subsequent
    sections. The full source code is available on the book's GitHub page under the
    `spring-boot-spring-security-oauth` project.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a conventional Spring Boot project, which implements the authorization
    server OAuth role.
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main dependencies to be included in the Spring Boot project''s `pom.xml`
    file are as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Spring Boot run class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is nothing special in this Spring Boot `run` class, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Spring Security config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Security config class extends `WebSecurityConfigurerAdapter`. We
    will override three methods, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We `autowire` the password encoder. We then override the following methods: `globalUserDetails`,
    `authenticationManagerBean`, and `configure`. There isn't anything special to
    mention here. We define two users, managed in-memory (user and admin).
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the the most important in this Spring Boot project, where we will set
    up the authorization server configuration. We will use a new annotation, `@EnableAuthorizationServer`.
    Our configuration class will extend `AuthorizationServerConfigurerAdapter`. We
    will be using the JWT token store and will also showcase a token enhancer, using
    which you can enhance your JWT token with more claims, if deemed necessary for
    your application. The most important method in this configuration class is extracted
    as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is where we set up the client-related OAuth configuration. We set up just
    one client, and we use the in-memory option to make the example simpler to understand.
    Throughout the application, we will be using `BCrypt` as our password encoder.
    The client ID for our client app is `oAuthClientAppID` and the client secret is
    `secret`. We set up three grant types and while accessing the client, we need
    to specify the necessary scopes (movie, read, and write). After successful execution,
    the authorization server will redirect you to the specified URL (`http://localhost:8080/movie/`
    or `http://localhost:8080/movie/index`). If the URL is not correctly specified
    by the client, the server will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWT token store and enhancer-related methods are as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we specify the token store, which will be used in the `tokenStore`
    method, and we also declare a `tokenEnhancer` bean. To showcase the token enhancer,
    we will be using a custom class named `CustomTokenEnhancer`; the class is as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The custom token `enhancer` class implements `TokenEnhancer`. We just add new
    information (`principalinfo`) into the JWT token that contains the `toString`
    version of the `principal` object.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are running all three servers locally, we have to specify different
    ports. Also, it''s important that the authorization server runs on a different
    context path. The following code snippet shows what we have in our `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a conventional Spring Boot project, which implements the resource server
    OAuth role.
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There isn't anything new that we are going to add in our `pom.xml`. The same
    dependencies that we had in our authorization server project apply here.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot run class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a typical Spring Boot `run` class, into which we put the `@SpringBootApplication`
    annotation, which does all the magic behind the scenes. Again, nothing specific
    in our Spring Boot run class applies to this project.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the main resource server configuration class, where we annotate it
    with the `@EnableResourceServer` annotation and extend it from `ResourceServerConfigurerAdapter`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Spring Security config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being the resource server, we are enabling global method security so that every
    method exposing an API is secured, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using `OAuth2MethodSecurityExpressionHandler` as the method security
    exception handler so that we can use annotations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Spring MVC config class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen Spring MVC configuration in detail in previous chapters. In our
    example, it's a very basic Spring MVC `config` class in which `@EnableWebMvc`
    is used and implements `WebMvcConfigurer`.
  prefs: []
  type: TYPE_NORMAL
- en: Controller class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have one controller class, which exposes just one method (we can extend
    it further to expose more APIs). This method lists all the movies in the hardcoded
    movie list under a URL, `/movie`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using a `Movie` model class utilizing all the features of the `lombok`
    library, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It has three attributes and the annotations will do all the magic and keep the
    model concise.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the authorization server, `application.properties` just has the context
    path and port assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Being a Spring Boot project, it can be run by executing the `mvn spring-boot:run`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a conventional Spring Boot project, which implements the client OAuth
    role.
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our Spring Boot `pom.xml` file, new Maven dependencies for `Thymeleaf` and
    for the `lombok` library are added. The rest are all typical of a Spring Boot
    `pom.xml` file, which you are now conversant with.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example Spring Boot `run` class, there isn't anything worth mentioning.
    It is a simple class containing the all-important `main` method and the `@SpringBootApplication`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth client config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the main configuration class in the client application, which is annotated
    with `@EnableOAuth2Client`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The important aspect to look at in this class is that we initialize the OAuth2
    REST template by providing the client details, which are configured in the `application.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring Security `config` class, we set up the user credentials (in-memory)
    that can be used to log in to the application and can access secured resources.
    In the `configure` method, some of the resources are marked as secured and some
    as unsecured.
  prefs: []
  type: TYPE_NORMAL
- en: Controller classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two controller classes, `SecuredController` and `NonSecuredController`.
    As the name suggests, one is for declared secured routes and the other for unsecured
    routes. The `main` method in the secured controller that we are interested is
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We copied the `model` class used in the resource server project into the client
    application project as well. In an ideal scenario, all this common stuff would
    be converted into reusable JARs and set up as a dependency to both the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The templates are quite straightforward. The root context of the application
    redirects the user to an unsecured page. We have our own custom login page and
    after a successful login, the user is navigated to a secured page containing a
    link to the secured OAuth-backed movie listing API.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we are using `application.yml` files and the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The very important aspect of this YML file is the `movie-app-client` properties
    setup. Again, being a Spring Boot project, it can be run by executing the `mvn
    spring-boot:run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start all the projects individually using the Spring Boot `mvn spring-boot:run` command.
    I am using Spring Dashboard in IntelliJ, where I can launch all the projects,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f21f02f6-d40c-4e79-a32c-324886db5c03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Spring Dashboard in IntelliJ'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `http://localhost:8080` and you will be redirected to the unsecured
    page of the client application, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d35a94e3-cbdb-4023-9afd-1e6a48b46cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Unsecured page of client app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the link, and you will be taken to the custom login page, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88846da5-d718-452c-9193-ea3637bd0b20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Custom login page of client app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the username/password as required on the page; then, clicking on Log
    In will take you to the secured page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0fe14e3-c9f7-45a3-8341-763f88434956.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Secured page in client app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the movie API link, and you will be taken to the OAuth flow and then
    to the authorization server default login page to enter credentials, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dea5c50-4ea6-4b8e-9507-b3105e8ac5e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: Authorization server login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the username/password (we have kept that as user/password) and click
    on the Login button. You will be taken to the authorization page, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0889860-4aef-44de-bb61-3bd099664046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: Authorization page on authorization server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Authorize and you will be taken back to the client application page,
    which displays all the movies from the resource server, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68d63f0a-c1a8-460b-8739-1fa9ae252fbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18: Movie listing page in the client app displaying a movie API exposed
    on resource server'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have completed our sample application, in which we have implemented
    all the roles that are part of OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by introducing you to some of the important concepts
    that are needed to follow along with it. We then covered the important characteristics
    needed in a modern web application. We quickly covered an architecture called
    **SOFEA**, which aptly covers how we would like to build modern applications.
    We then got our hands dirty by implementing security for REST APIs in the simplest
    of ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we covered how we can secure a REST API in a more
    advanced fashion employing OAuth, using a JWT. We started this section by introducing
    many concepts in regards to OAuth and finally concluded the chapter with a full-fledged
    sample project that uses OAuth and JWT.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should have a clear understanding of REST, OAuth,
    and JWT. You should also be comfortable with using Spring Security in the next
    chapter, to secure the RESTful endpoints exposed in your application.
  prefs: []
  type: TYPE_NORMAL

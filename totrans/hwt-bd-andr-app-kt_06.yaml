- en: 6\. RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to add lists and grids of items to your
    apps and effectively leverage the recycling power of `RecyclerView`. You'll also
    learn how to handle user interaction with the item views on the screen and support
    different item view types—for example, for titles. Later in the chapter, you'll
    add and remove items dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have the skills required to present your
    users with interactive lists of rich items.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to fetch data, including lists of items
    and image URLs, from APIs, and how to load images from URLs. Combining that knowledge
    with the ability to display lists of items is the goal of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, you will want to present your users with a list of items. For example,
    you might want to show them a list of pictures on their device, or let them select
    their country from a list of all countries. To do that, you would need to populate
    multiple views, all sharing the same layout but presenting different content.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, this was achieved by using `ListView` or `GridView`. While both
    are still viable options, they do not offer the robustness and flexibility of
    `RecyclerView`. For example, they do not support large datasets well, they do
    not support horizontal scrolling, and they do not offer rich divider customization.
    Customizing the divider between items in `RecyclerView` can be easily achieved
    using `RecyclerView.ItemDecorator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does `RecyclerView` do? `RecyclerView` orchestrates the creation,
    population, and reuse (hence the name) of views representing lists of items. To
    use `RecyclerView`, you need to familiarize yourself with two of its dependencies:
    the adapter (and through it, the view holder) and the layout manager. These dependencies
    provide our `RecyclerView` with the content to show, as well as telling it how
    to present that content and how to lay it out on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter provides `RecyclerView` with child views (nested Android views
    within `RecyclerView` used to represent individual data items) to draw on the
    screen, binds those views to data (via `ViewHolder` instances), and reports user
    interaction with those views. The layout manager tells `RecyclerView` how to lay
    its children out. We are provided with three layout types by default: linear,
    grid, and staggered grid—managed by `LinearLayoutManager`, `GridLayoutManager`,
    and `StaggeredGridLayoutManager`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop an app that lists secret agents and whether
    they are currently active or sleeping (and thus unavailable). The app will then
    allow us to add new agents or delete existing ones by swiping them away. There
    is a twist, though—as you saw in *Chapter 5*, *Essential Libraries: Retrofit,
    Moshi, and Glide*, all our agents will be cats.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding RecyclerView to Our Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 3*, *Screens and UI*, we saw how we can add views to our layouts
    to be inflated by activities, fragments, or custom views. `RecyclerView` is just
    another such view. To add it to our layout, we need to add the following tag to
    our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should already be able to recognize the `android:id` attribute, as well
    as the `android:layout_width` and `android:layout_height` ones.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the optional `tools:listitem` attribute to tell Android Studio which
    layout to inflate as a list item in our preview toolbar. This will give us an
    idea of how `RecyclerView` might look in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a `RecyclerView` tag to our layout means we now have an empty container
    to hold the child views representing our list items. Once populated, it will handle
    the presenting, scrolling, and recycling of child views for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Adding an Empty RecyclerView to Your Main Activity'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use `RecyclerView` in your app, you first need to add it to one of your
    layouts. Let''s add it to the layout inflated by our main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new empty activity project (`File` | `New` | `New Project`
    | `Empty Activity`). Name your application `My RecyclerView App`. Make sure your
    package name is `com.example.myrecyclerviewapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the save location to where you want to save your project. Leave everything
    else at its default values and click `Finish`. Make sure you are on the `Android`
    view in your `Project` pane:![Figure 6.1: Android view in the Project pane](img/B15216_06_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.1: Android view in the Project pane'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `activity_main.xml` file in `Text` mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To turn your label into a title at the top of the screen under which you can
    add your `RecyclerView`, add an ID to `TextView` and align it to the top, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following after `TextView` tag to add an empty `RecyclerView` element
    to our layout, constrained below your `hello_label` `TextView` title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Your layout file should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app by clicking the `Run app` button or pressing *Ctrl* + *R* (*Shift*
    + *F10* on Windows). On the emulator, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2: App with an empty RecyclerView (image cropped for space)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: App with an empty RecyclerView (image cropped for space)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our app runs and our layout is presented on the screen. However,
    we do not see our `RecyclerView`. Why is that? At this stage, our `RecyclerView`
    has no content. `RecyclerView` with no content does not render by default—so,
    while our `RecyclerView` is indeed on the screen, it is not visible. This brings
    us to the next step—populating `RecyclerView` with content that we can actually
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we added `RecyclerView` to our layout. For us to benefit from `RecyclerView`,
    we need to add content to it. Let's see how we go about doing that.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, to add content to our `RecyclerView`, we would need
    to implement an adapter. An adapter binds our data to child views. In simpler
    terms, this means it tells `RecyclerView` how to plug data into views designed
    to present that data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say we want to present a list of employees.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to design our UI model. This will be a data object holding all
    the information needed by our view to present a single employee. Because this
    is a UI model, one convention is to suffix its name with `UiModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define `EmployeeRole` and `Gender` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The values are provided as an example, of course. Feel free to add more of your
    own!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The model’s hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: The model''s hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know what data to expect when binding to a view—so, we can design our
    view to present this data (this is a simplified version of the actual layout,
    which we''ll save as `item_employee.xml`). We''ll start with the `ImageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add each `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, there is nothing new. You should be able to recognize all of the different
    view types from *Chapter 2*, *Building User Screen Flows*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Preview of the item_cat.xml layout file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Preview of the item_cat.xml layout file'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a data model and a layout, we now have everything we need to bind our
    data to the view. To do that, we will implement a view holder. Usually, a view
    holder has two responsibilities: it holds a reference to a view (as its name implies),
    but it also binds data to that view. We will implement our view holder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things worth noting in the preceding code. First, by convention,
    we suffixed the name of our view holder with `ViewHolder`. Second, note that `EmployeeViewHolder`
    needs to implement the abstract `RecyclerView.ViewHolder` class. This is required
    so that the generic type of our adapter can be our view holder. Lastly, we lazily
    keep references to the views we are interested in. The first time `bindData(EmployeeUiModel)`
    is called, we will find these views in the layout and keep references to them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced a `bindData(EmployeeUiModel)` function. This function will
    be called by our adapter to bind the data to the view held by the view holder.
    The last but most important thing to note is that we always make sure to set a
    state for all modified views for any possible input.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our view holder set up, we can proceed to implement our adapter. We will
    start by implementing the minimum required functions, plus a function to set the
    data. Our adapter will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over this implementation. First, we inject our dependencies to the
    adapter via its constructor. This will make testing our adapter much easier—but
    will also allow us to change some of its behavior (for example, replace the image
    loading library) painlessly. In fact, we would not need to change the adapter
    at all in that case.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a private mutable list of `EmployeeUiModel` to store the data
    currently provided by the adapter to `RecyclerView`. We also introduce a method
    to set that list. Note that we keep a local list and set its contents, rather
    than allowing `employeesData` to be set directly. This is mainly because Kotlin,
    just like Java, passes variables by reference. Passing variables by reference
    means changes to the content of the list passed into the adapter would change
    the list held by the adapter. So, for example, if an item was removed from outside
    the adapter, the adapter would have that item removed as well. This becomes a
    problem because the adapter would not be aware of that change, and so would not
    be able to notify `RecyclerView`. There are other risks around the list being
    modified from outside the adapter, but covering them is beyond the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of encapsulating the modification of the data in a function
    is that we avoid the risk of forgetting to notify `RecyclerView` that the dataset
    has changed, which we do by calling `notifyDataSetChanged()`.
  prefs: []
  type: TYPE_NORMAL
- en: We proceed to implement the adapter's `onCreateViewHolder(ViewGroup, Int)` function.
    This function is called when the `RecyclerView` needs a new `ViewHolder` to render
    data on the screen. It provides us with a container `ViewGroup` and a view type
    (we'll look into view types later in this chapter). The function then expects
    us to return a view holder initialized with a view (in our case, an inflated one).
    So, we inflate the view we designed earlier, passing it to a new `EmployeeViewHolder`
    instance. Note that the last argument to the inflated function is `false`. This
    makes sure we do not attach the newly inflated view to the parent. Attaching and
    detaching views will be managed by the layout manager. Setting it to `true` or
    omitting it would result in `IllegalStateException` being thrown. Finally, we
    return the newly created `EmployeeViewHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: To implement `getItemCount()`, we simply return the size of our `employeesData`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we implement `onBindViewHolder(EmployeeViewHolder, Int)`. This is done
    by passing `EmployeeUiModel`, stored in `catsData`, at the given position to the
    `bindData(EmployeeUiModel)` function of our view holder. Our adapter is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we tried to plug our adapter into our `RecyclerView` at this point and run
    our app, we would still see no content. This is because we are still missing two
    small steps: setting data to our adapter and assigning a layout manager to our
    `RecyclerView`. The complete working code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running our app now, we would see a list of our employees.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we hardcoded the list of employees. In a production app, following
    a `ViewModel`. It is also important to note that we kept a reference to `employeesAdapter`.
    This is so that we could indeed, at a later time, set the data to different values.
    Some implementations rely on reading the adapter from `RecyclerView` itself—this
    can potentially result in unnecessary casting operations and unexpected states
    where the adapter is not yet assigned to `RecyclerView`, and so this is generally
    not a recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note that we chose to use `LinearLayoutManager`, providing it with the
    activity for context, a `VERTICAL` orientation flag, and `false` to tell it that
    we do not want the order of the items in the list reversed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Populating Your RecyclerView'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RecyclerView` is not very interesting without any content. It is time you
    populate `RecyclerView` by adding your secret cat agents to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick recap before you dive in: in the previous exercise, we introduced an
    empty list designed to hold a list of secret cat agents that the users have at
    their disposal. In this exercise, you will be populating that list to present
    the users with the available secret cat agents in the agency:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our file structure tidy, we will start by creating a model package.
    Right-click on the package name of our app, then select `New` | `Package`:![Figure
    6.5: Creating a new package'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Creating a new package'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new package `model`. Click `OK` to create the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create our first model data class, right-click on the newly created model
    package, then select `New` | `Kotlin File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `name`, fill in `CatUiModel`. Leave `kind` as `File` and click on `OK`.
    This will be the class holding the data we have about every individual cat agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the newly created `CatUiModel.kt` file to define the data
    class with all the relevant properties of a cat agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For each cat agent, other than their name and photo, we want to know the gender,
    breed, and biography. This will help us choose the right agent for a mission.
  prefs: []
  type: TYPE_NORMAL
- en: Again, right-click on the model package, then navigate to `New` | `Kotlin File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, name the new file `CatBreed` and set `kind` to the `Enum` class.
    This class will hold our different cat breeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your newly created enum with some initial values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Repeat *steps 6* and *7*, only this time call your file `Gender`. This will
    hold the accepted values for a cat agent's gender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `Gender` enum like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to define the layout of the view holding the data about each cat agent,
    create a new layout resource file by right-clicking on `layout` and then selecting
    `New` | `Layout resource file`:![Figure 6.6: Creating a new layout resource file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Creating a new layout resource file'
  prefs: []
  type: TYPE_NORMAL
- en: Name your resource `item_cat`. Leave all the other fields as they are and click `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the contents of the newly created `item_cat.xml` file. (The following
    code block has been truncated for space. Use the link below to see the full code
    that you need to add.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will create a layout with an image and text fields for a name, breed, and
    biography to be used in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that *line 14* is highlighted in red. This is because you haven''t
    declared `item_cat_photo` in `strings.xml` under the `res/values` folder yet.
    Do so now by placing the text cursor over `item_cat_photo` and pressing *Alt*
    + *Enter* (*Option* + *Enter* on Mac), then select `Create string value resource
    ''item_cat_photo''`:![Figure 6.7: A string resource is not yet defined'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: A string resource is not yet defined'
  prefs: []
  type: TYPE_NORMAL
- en: Under `Resource value`, fill in `Photo`. Press `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need a copy of `ImageLoader.kt`, introduced in *Chapter 5*, *Essential
    Libraries: Retrofit, Moshi, and Glide*, so right-click on the package name of
    your app, navigate to `New` | `Kotlin File/Class`, and then set the name to `ImageLoader`
    and `kind` to `Interface`, and click `OK`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to *Chapter 5*, *Essential Libraries: Retrofit, Moshi, and Glide*,
    you only need to add one function here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to import `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the package name of your app again, then select `New` | `Kotlin
    File/Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the new file `CatViewHolder`. Click `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement `CatViewHolder`, which will bind the cat agent data to your views,
    replace the contents of the `CatViewHolder.kt` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Still under our app package name, create a new Kotlin file named `CatsAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement `CatsAdapter`, which is responsible for storing the data for `RecyclerView`,
    as well as creating instances of your view holder and using them to bind data
    to views, replace the contents of the `CatsAdapter.kt` file with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you need to include Glide in your project. Start by adding the
    following line of code to the `dependencies` block inside your app''s `gradle.build`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `GlideImageLoader` class in your app package path, containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple implementation assuming the loaded image should always be center-cropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `MainActivity` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will define your adapter, attach it to `RecyclerView`, and populate it
    with some hardcoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `AndroidManifest.xml` file, add the following in the `manifest` tag
    before the application tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will allow your app to download images off the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some final touches, such as giving our title view a proper name and text,
    update your `activity_main.xml` file like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, update your `strings.xml` file to give your app a proper name and title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8: RecyclerView with hardcoded secret cat agents'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: RecyclerView with hardcoded secret cat agents'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `RecyclerView` now has content, and your app is starting to
    take shape. Note how the same layout is used to present different items based
    on the data bound to each instance. As you would expect, if you added enough items
    for them to go off-screen, scrolling works. Next, we'll look into allowing the
    user to interact with the items inside our `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to Clicks in RecyclerView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we want to let our users select an item from the presented list? To
    achieve that, we need to communicate clicks back to our app.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in implementing click interaction is to capture clicks on items
    at the `ViewHolder` level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain separation between our view holder and the adapter, we define a
    nested `OnClickListener` interface in our view holder. We choose to define the
    interface within the view holder because they are tightly coupled. The interface
    will, in our case, have only one function. The purpose of this function is to
    inform the owner of the view holder about the clicks. The owner of a view holder
    is usually a Fragment or an Activity. Since we know that a view holder can be
    reused, we know that it can be challenging to define it at construction time in
    a way that would tell us which item was clicked (since that item will change over
    time with reuse). We work around that by passing the currently presented item
    back to the owner of the view holder on clicking. This means our interface would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add this listener as a parameter to our `ViewHolder` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want our adapter to pass in a listener. In turn, that listener will
    be responsible for informing the owner of the adapter of the click. This means
    our adapter, too, would need a nested listener interface, quite similar to the
    one we implemented in our view holder.
  prefs: []
  type: TYPE_NORMAL
- en: While this seems like duplication that can be avoided by reusing the same listener,
    that is not a great idea, as it leads to tight coupling between the view holder
    and the adapter through the listener. What happens when you want your adapter
    to also report other events through the listener? You would have to handle those
    events coming from the view holder, even though they would not actually be implemented
    in the view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to handle the click event and show a dialog, we define a listener in
    our activity and pass it to our adapter. We set that listener to show a dialog
    on clicking. In an MVVM implementation, you would be notifying `ViewModel` of
    the click at this point instead. `ViewModel` would then update its state, telling
    the view (our activity) that it should display the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Responding to Clicks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your app already shows the user a list of secret cat agents. It is time to
    allow your user to choose a secret cat agent by clicking on its view. Click events
    are delegates from the view holder to the adapter to the activity, as shown in
    *Figure 6.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: The flow of click events'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: The flow of click events'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps that you need to follow to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `CatViewHolder.kt` file. Add a nested interface to it right before
    the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will be the interface a listener would have to implement in order to register
    for click events on individual cat items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `CatViewHolder` constructor to accept `OnClickListener` and make
    containerView accessible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of your `bindData(CatUiModel)` function, add the following to intercept
    clicks and report them to the provided listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open your `CatsAdapter.kt` file. Add this nested interface right before
    the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This defines the interface that listeners would have to implement to receive
    item click events from the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `CatsAdapter` constructor to accept a call implementing the `OnClickListener`
    adapter you just defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In `onCreateViewHolder(ViewGroup, Int)`, update the creation of the view holder,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open your `MainActivity.kt` file. Update your `catsAdapter` construction
    as follows to provide the required dependencies to the adapter in the form of
    an anonymous listener handling click events by showing a dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function right before the final closing curly bracket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This function will show a dialog with the name of the cat whose data was passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to import the right version of `AlertDialog`, which is `androidx.appcompat.app.AlertDialog`,
    not `android.app.AlertDialog`. This is usually a better choice to support backward
    compatibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your app. Clicking on one of the cats should now show a dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10: A dialog showing an agent was selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: A dialog showing an agent was selected'
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking the different items and note the different messages presented.
    You now know how to respond to users clicking on items inside your `RecyclerView`.
    Next, we will look at how we can support different item types in our lists.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Different Item Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to handle a list of items of a single
    type (in our case, all our items were `CatUiModel`). What happens if you want
    to support more than one type of item? A good example of this would be having
    group titles within our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that instead of getting a list of cats, we instead get a list containing
    happy cats and sad cats. Each of the two groups of cats is preceded by a title
    of the corresponding group. Instead of a list of `CatUiModel` instances, our list
    would now contain `ListItem` instances. `ListItem` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list of items may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this case, having just one layout type will not do. Luckily, as you may have
    noticed in our earlier exercises, `RecyclerView.Adapter` provides us with a mechanism
    to handle this (remember the `viewType` parameter used in the `onCreateViewHolder(ViewGroup,
    Int)` function?).
  prefs: []
  type: TYPE_NORMAL
- en: 'To help the adapter determine which view type is needed for each item, we override
    its `getItemViewType(Int)` function. An example of an implementation that would
    do the trick for us is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT` are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This implementation maps the data type at a given position to a constant value
    representing one of our known layout types. In our case, we know of titles and
    cats, thus the two types. The values we use can be any integer values, as they're
    passed back to us as is in the `onCreateViewHolder(ViewGroup, Int)` function.
    All we need to do is make sure not to repeat the same value more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have told the adapter which view types are needed and where, we
    also need to tell it which view holder to use for each view type. This is done
    by implementing the `onCreateViewHolder(ViewGroup, Int)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the earlier implementations of this function, we now take the value of
    `viewType` into account.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know, `viewType` is expected to be one of the values we returned from
    `getItemViewType(Int)`.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these values (`VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT`), we inflate
    the corresponding layout and construct a suitable view holder. Note that we never
    expect to receive any other value, and so throw an exception if such a value is
    encountered. Depending on your needs, you could instead return a default view
    holder with a layout showing an error or nothing at all. It may also be a good
    idea to log such values to allow you to investigate why you received them and
    decide how to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: For our title layout, a simple `TextView` may be sufficient. The `item_cat.xml`
    layout can remain as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now onto the view holder. We need to create a view holder for the title. This
    means we will now have two different view holders. However, our adapter only supports
    one adapter type. The easiest solution is to define a common view holder that
    both `GroupViewHolder` and `CatViewHolder` will extend. Let''s call it `ListItemViewHolder`.
    The `ListItemViewHolder` class can be abstract, as we never intend to use it directly.
    To make it easy to bind data, we can also introduce a function in our abstract
    view holder—`abstract fun bindData(listItem: ListItemUiModel)`. Our concrete implementations
    can expect to receive a specific type, and so we can add the following lines to
    both `GroupViewHolder` and `CatViewHolder`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, in `CatViewHolder`, thanks to some Kotlin magic, we can then use
    `define val catData = listItem.data` and leave the rest of the class unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Having made those changes, we can now expect to see the `Happy Cats` and `Sad
    Cats` group titles, each followed by the relevant cats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Adding Titles to RecyclerView'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now want to be able to present our secret cat agents in two groups: active
    agents that are available for us to deploy to the field, and sleeper agents, which
    cannot currently be deployed. We will do that by adding a title above the active
    agents and another above the sleeper agents:'
  prefs: []
  type: TYPE_NORMAL
- en: Under `com.example.myrecyclerviewapp.model`, create a new Kotlin file called
    `ListItemUiModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the `ListItemUiModel.kt` file, defining our two data types—titles
    and cats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Kotlin file in `com.example.myrecyclerviewapp` named `ListItemViewHolder`.
    This will be our base view holder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the `ListItemViewHolder.kt` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Open the `CatViewHolder.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make `CatViewHolder` extend `ListItemViewHolder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `bindData(CatUiModel)` parameter with `ListItemUiModel` and make
    it override the `ListItemViewHolder` abstract function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following two lines to the top of the `bindData(ListItemUiModel)` function
    to enforce casting `ListItemUiModel` to `ListItemUiModel.Cat` and to fetch the
    cat data from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Leave the rest of the file untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new layout file. Name your layout `item_title`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the default content of the newly created `item_title.xml` file with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This new layout, containing only a `TextView` with a 16sp-sized bold font,
    will host our titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Preview of the item_title.xml layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Preview of the item_title.xml layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `TitleViewHolder` in a new file with the same name under `com.example.myrecyclerviewapp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to `CatViewHolder`, but since we only set the text on `TextView`,
    it is also much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to make things tidier, select `CatViewHolder`, `ListItemViewHolder`, and
    `TitleViewHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move all the files to a new namespace: right-click on one of the files, and
    then select `Refactor` | `Move` (or press *F6*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append `/viewholder` to the prefilled `To directory` field. Leave `Search references`
    and `Update package directive (Kotlin files)` checked and `Open moved files in
    editor` unchecked. Click `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CatsAdapter.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, rename `CatsAdapter` to `ListItemsAdapter`. It is important to maintain
    the naming of variables, functions, and classes to reflect their actual usage
    to avoid future confusion. Right-click on the `CatsAdapter` class name in the
    code window, then select `Refactor` | `Rename` (or *Shift* + *F6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `CatsAdapter` is highlighted, type `ListItemsAdapter` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the adapter generic type to `ListItemViewHolder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `listData` and `setData(List<CatUiModel>)` to handle `ListItemUiModel`
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `onBindViewHolder(CatViewHolder)` to comply with the adapter contract
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, after the imports and before the class definition,
    add the view type constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `getItemViewType(Int)` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, change your `onCreateViewHolder(ViewGroup, Int)` implementation, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Update `MainActivity` to populate the adapter with appropriate data, replacing
    the previous `catsAdapter.setData(List<CatUiModel>)` call. (Please note that the
    code below has been truncated for space. Refer to the link below to access the
    full code that you need to add.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since `catsAdapter` is no longer holding `CatsAdapter` but `ListItemsAdapter`,
    rename it accordingly. Name it `listItemsAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app. You should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12: RecyclerView with the Sleeper Agents/Active Agents header views'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: RecyclerView with the Sleeper Agents/Active Agents header views'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we now have titles above our two agent groups. Unlike the `Our
    Agents` title, these titles will scroll with our content. Next, we will learn
    how to swipe an item to remove it from `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping to Remove Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to present different view types. However,
    up until now, we have worked with a fixed list of items. What if you want to be
    able to remove items from the list? There are a few common mechanisms to achieve that—fixed
    delete buttons, swipe to delete, and long-click to select then a "click to delete"
    button, to name a few. In this section, we will focus on the "swipe to delete"
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the deletion functionality to our adapter. To tell the
    adapter to remove an item, we need to indicate which item we want to remove. The
    simplest way to achieve this is by providing the position of the item. In our
    implementation, this will directly correlate to the position of the item in our
    `listData` list. So, our `removeItem(Int)` function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Just like when setting data, we need to notify `RecyclerView` that the dataset
    has changed—in this case, an item was removed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to define the swipe gesture detection. This is done by utilizing
    `ItemTouchHelper`. Now, `ItemTouchHelper` handles certain touch events, namely
    dragging and swiping, by reporting them to us via a callback. We handle these
    callbacks by implementing `ItemTouchHelper.Callback`. Also, `RecyclerView` provides
    `ItemTouchHelper.SimpleCallback`, which takes away the writing of a lot of boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to respond to swipe gestures but ignore move gestures. More specifically,
    we want to respond to swipes to the right. Moving is used to reorder items, which
    is beyond the scope of this chapter. So, our implementation of `SwipToDeleteCallback`
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Because our implementation is tightly coupled to our adapter and its view types,
    we can comfortably define it as an inner class. The benefit we gain is the ability
    to directly call methods on the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we return `false` from the `onMove(RecyclerView, ViewHolder,
    ViewHolder)` function. This means we ignore move events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to tell `ItemTouchHelper` which items can be swiped. We achieve
    this by overriding `getMovementFlags(RecyclerView, ViewHolder)`. This function
    is called when a user is about to start a drag or swipe gesture. `ItemTouchHelper`
    expects us to return the valid gestures for the provided view holder. We check
    the `ViewHolder` class, and if it is `CatViewHolder`, we want to allow swiping—otherwise,
    we do not. We use `makeMovementFlags(Int, Int)`, which is a helper function used
    to construct flags in a way that `ItemTouchHelper` can decipher them. Note that
    we define rules for `ACTION_STATE_IDLE`, which is the starting state of a gesture,
    thus allowing a gesture to start from the left or the right. We then combine it
    (using `or`) with the `ACTION_STATE_SWIPE` flags, allowing the ongoing gesture
    to swipe left or right. Returning `0` means neither swiping nor moving will occur
    for the provided view holder.
  prefs: []
  type: TYPE_NORMAL
- en: Once a swipe action is completed, `onSwiped(ViewHolder, Int)` is called. We
    then obtain the position from the passed-in view holder by calling `adapterPosition`.
    Now, `adapterPosition` is important because it is the only reliable way to obtain
    the real position of the item presented by the view holder.
  prefs: []
  type: TYPE_NORMAL
- en: With the correct position, we can remove the item by calling `removeItem(Int)`
    on the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: To expose our newly created `SwipeToDeleteCallback` implementation, we define
    a read-only variable within our adapter, namely `swipeToDeleteCallback`, and set
    it to a new instance of `SwipeToDeleteCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to plug our `callback` mechanism to `RecyclerView`, we need to construct
    a new `ItemTouchHelper` and attach it to our `RecyclerView`. We should do this
    when setting up our `RecyclerView`, which we do in the `onCreate(Bundle?)` function
    of our main activity. This is how the creation and attaching will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can now swipe items to remove them from the list. Note how our titles cannot
    be swiped, just as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed a small glitch: the last item is cut off as it animates
    up. This is happening because `RecyclerView` shrinks to accommodate the new (smaller)
    number of items before the animation starts. A quick fix to this would be to fix
    the height of our `RecyclerView` by confining its bottom to the bottom of its
    parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Adding Swipe to Delete Functionality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously added `RecyclerView` to our app and then added items of different
    types to it. We will now allow users to delete some items (we want to let the
    users remove secret cat agents, but not titles) by swiping them left or right:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add item removal functionality to our adapter, add the following function
    to `ListItemsAdapter` right after the `setData(List<ListItemUiModel>)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, right before the closing curly bracket of your `ListItemsAdapter` class,
    add the following `callback` implementation to handle the user swiping a cat agent
    left or right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented an `ItemTouchHelper.SimpleCallback` instance, passing in
    the directions we were interested in—`LEFT` and `RIGHT`. Joining the values is
    achieved by using the `or` Boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: We have overridden the `getMovementFlags` function to make sure we have only
    handled swiping on a cat agent view, not a title. Creating flags for both `ItemTouchHelper.ACTION_STATE_SWIPE`
    and `ItemTouchHelper.ACTION_STATE_IDLE` allows us to intercept both swipe and
    release events, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Once a swipe is completed (the user has lifted their finger from the screen),
    `onSwiped` will be called, and in response, we remove the item at the position
    provided by the dragged view holder.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of your adapter, expose an instance of the `SwipeToDeleteCallback`
    class you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, tie it all together by implementing `ItemViewHelper` and attaching
    it to our `RecyclerView`. Add the following code to the `onCreate(Bundle?)` function
    of your `MainActivity` file right after assigning the layout manager to your adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To address the small visual glitch you would get when items are removed, scale
    `RecyclerView` to fit the screen by updating the code in `activity_main.xml`,
    as follows. The changes are in `RecyclerView` tag, right before the `app:layout_constraintTop_toBottomOf`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app. You should now be able to swipe secret cat agents left or right
    to remove them from the list. Note that `RecyclerView` handles the collapsing
    animation for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14: A cat being swiped to the right'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: A cat being swiped to the right'
  prefs: []
  type: TYPE_NORMAL
- en: Note how even though titles are item views, they cannot be swiped. You have
    implemented a callback for swiping gestures that distinguishes between different
    item types and responds to a swipe by deleting the swiped item. Now we know how
    to remove items interactively. Next, we will learn how to add new items as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Items Interactively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned how to remove items interactively. What about adding new
    items? Let's look into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the way we implemented the removal of items, we start by adding
    a function to our adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the implementation is very similar to the `removeItem(Int)`
    function we implemented earlier. This time, we also receive an item to add and
    a position to add it. We then add it to our `listData` list and notify `RecyclerView`
    that we added an item in the requested position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger a call to `addItem(Int, ListItemUiModel)`, we could add a button
    to our main activity layout. This button could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The app will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: The main layout with a button to add a cat'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: The main layout with a button to add a cat'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to update your `RecyclerView` so that its bottom will be constrained
    to the top of this button. Otherwise, the button and `RecyclerView` will overlap.
  prefs: []
  type: TYPE_NORMAL
- en: In a production app, you could add a rationale around what a new item would
    be. For example, you could have a form for the user to fill in different details.
    For the sake of simplicity, in our example, we will always add the same dummy
    item—an anonymous female secret cat agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the item, we set `OnClickListener` on our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: And that is it. We add the item at position 1 so that it is added right below
    our first title, which is the item at position 0\. In a production app, you could
    have logic to determine the correct place to insert an item. It could be below
    the relevant title or always be added at the top, bottom, or in the correct place
    to preserve some existing order.
  prefs: []
  type: TYPE_NORMAL
- en: We can now run the app. We will now have a new `Add A Cat` button. Every time
    we click the button, an anonymous secret cat agent will be added to `RecyclerView`.
    The newly added cats can be swiped away to be removed, just like the hardcoded
    cats before them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.06: Implementing an "Add A Cat" Button'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having implemented a mechanism to remove items, it is time we implemented a
    mechanism to add items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to `ListItemsAdapter` to support adding items. Add it below
    the `removeItem(Int)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a button to `activity_main.xml`, right after `RecyclerView` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that `android:text="Add A Cat"` is highlighted. If you hover
    your mouse over it, you will see that this is because of the hardcoded string.
    Click on the `Add` word to place the editor cursor over it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Option* + *Enter* (iOS) or *Alt* + *Enter* (Windows) to show the context
    menu, then *Enter* again to show the `Extract Resource` dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the resource `add_button_label`. Press `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To change the bottom constraint on `RecyclerView` so that the button and `RecyclerView`
    do not overlap, within your `RecyclerView` tag, locate the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a lazy field holding a reference to the button at the top of the class,
    right after the definition of `recyclerView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice `addItemButton` is defined as a View. This is because in our code we
    don't need to know the type of View to add a click listener to it. Choosing the
    more abstract type allows us to later change the type of the view in the layout
    without having to modify this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, update `MainActivity` to handle the click. Find the line that says
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after it, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This will add a new item to `RecyclerView` every time the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app. You should see a new button at the bottom of your app:![Figure
    6.16: An anonymous cat is added with the click of a button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: An anonymous cat is added with the click of a button'
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking it a few times. Every time you click it, a new anonymous secret
    cat agent is added to your `RecyclerView`. You can swipe away the newly added
    cats just like you could the hardcoded ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you added new items to `RecyclerView` in response to user
    interaction. You now know how to change the contents of `RecyclerView` at runtime.
    It is useful to know how to update lists at runtime because quite often, the data
    you are presenting to your users changes while the app is running, and you want
    to present your users with a fresh, up-to-date state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Managing a List of Items'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you want to develop a recipe management app. Your app would support
    sweet and savory recipes. Users of your app could add new sweet or savory recipes,
    scroll through the list of added recipes—grouped by flavor (sweet or savory)—click
    a recipe to get information about it, and finally, they could delete recipes by
    swiping them aside.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to create an app with `RecyclerView` that lists
    the title of recipes, grouped by flavor. `RecyclerView` will support user interaction.
    Each recipe will have a title, a description, and a flavor. Interactions will
    include clicks and swipes. A click will present the user with a dialog showing
    the description of the recipe. A swipe will remove the swiped recipe from the
    app. Finally, with two `EditText` fields (see *Chapter 3, Screens and UI*) and
    two buttons, the user can add a new sweet or savory recipe, respectively, with
    the title and description set to the values set in the `EditText` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to complete are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty activity app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `RecyclerView` support to the app's `build.gradle` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `RecyclerView`, two `EditText` fields, and two buttons to the main layout.
    Your layout should look something like this:![Figure 6.17: Layout with RecyclerView,
    two EditText fields, and two buttons'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Layout with RecyclerView, two EditText fields, and two buttons'
  prefs: []
  type: TYPE_NORMAL
- en: Add models for flavor titles and recipes, and an enum for flavor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a layout for flavor titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a layout for recipe titles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add view holders for flavor titles and recipe titles, as well as an adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add click listeners to show a dialog with recipe descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `MainActivity` to construct the new adapter and hook up the buttons for
    adding new savory and sweet recipes. Make sure the form is cleared after the recipe
    is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a swipe helper to remove items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: The Recipe Book app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: The Recipe Book app'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to add `RecyclerView` to our project. We also
    learned how to add it to our layout and how to populate it with items. We went
    through adding different item types, which is particularly useful for titles.
    We covered interaction with `RecyclerView`: responding to clicks on individual
    items and responding to swipe gestures. Lastly, we learned how to dynamically
    add and remove items to and from `RecyclerView`. The world of `RecyclerView` is
    very rich, and we have only scratched the surface. Going further would be beyond
    the scope of this book. However, it is strongly recommended that you investigate
    it on your own so that you can have carousels, designed dividers, and fancier
    swipe effects in your apps. You could start your exploration here: [https://awesomeopensource.com/projects/recyclerview-adapter](https://awesomeopensource.com/projects/recyclerview-adapter).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into requesting special permissions on behalf
    of our app to enable performing certain tasks, such as accessing the user's contacts
    list or their microphone. We will also look into using Google's Maps API and accessing
    the user's physical location.
  prefs: []
  type: TYPE_NORMAL

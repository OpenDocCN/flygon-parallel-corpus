- en: 8\. Services, WorkManager, and Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the concepts of managing long-running tasks
    in the background of an app. By the end of this chapter, you will be able to trigger
    a background task, create a notification for the user when a background task is
    complete, and launch an application from a notification. This chapter will give
    you a solid understanding of how to manage background tasks and keep the user
    informed about the progress of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to request permissions from the user
    and use Google's Maps API. With that knowledge, we obtained the user's location
    and allowed them to deploy an agent on a local map. In this chapter, we will learn
    how to track a long-running process and report its progress to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We will build an example app where we will assume that **Secret Cat Agents**
    (**SCAs**) get deployed in a record time of 15 seconds. That way, we'll avoid
    having to wait for very long before our background task completes. When a cat
    successfully deploys, we will notify the user and let them launch the app, presenting
    them with a successful deployment message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ongoing background tasks are quite common in the mobile world. Background tasks
    run even when an application is not active. Examples of long-running background
    tasks include the downloading of files, resource cleanup jobs, playing music,
    and tracking the user''s location. Historically, Google offered Android developers
    multiple ways of executing such tasks: services, `JobScheduler`, and Firebase''s
    `JobDispatcher` and `AlarmManager`. With the fragmentation in the Android world,
    it was quite a mess to cope with. Luckily for us, since March 2019 we have had
    a better (more stable) option. With the introduction of `WorkManager`, Google
    has abstracted the logic of choosing a background executing mechanism based on
    the API version away for us. We still use a foreground service, which is a special
    kind of service, for certain tasks that should be known to the user while running—such
    as playing music or tracking the location of the user in a running app.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, a quick step back. We have mentioned services, and we will
    be focusing on foreground services, but we haven't quite explained what services
    are. Services are application components designed to run in the background, even
    when an app is not running. With the exception of foreground services, which are
    tied to a notification, services have no user interface. It is important to note
    that services run on the main thread of their hosting process. This means that
    their operations can block the app. It is up to us to start a separate thread
    from within a service to avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and look at the implementation of the multiple approaches
    available in Android for managing a background task.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Background Task Using WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first question we will address here is, Should we opt for `WorkManager`
    or a foreground service? To answer that, a good rule of thumb is to ask; do you
    need the action to be tracked by the user in real time? If the answer is yes (for
    example, if you have a task such as responding to the user's location or playing
    music in the background), then you should use a foreground service, with its attached
    notification to give the user a real-time indication of state. When the background
    task can be delayed or does not require user interaction (for example, downloading
    a large file), use `WorkManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 2.3.0-alpha02 of the `WorkManager`, you can launch a foreground
    service via the `WorkManager` by calling `setForegroundAsync(ForegroundInfo)`.
    Our control over that foreground service is quite limited. It does allow you to
    attach a (pre-defined) notification to the work, which is why it is worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, in our app, we will track the SCAs' preparation for deployment.
    Before an agent can head out, they need to stretch, groom their fur, visit the
    litter box, and suit up. Each one of these tasks takes some time. Because you
    can't rush a cat, the agent will finish each step in its own time. All we can
    do is wait (and let the user know when the task is done). `WorkManager` is perfect
    for such a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `WorkManager`, we need to familiarize ourselves with its four main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is `WorkManager` itself. `WorkManager` receives work and enqueues
    it based on provided arguments and constraints (such as internet connectivity
    and the device charging).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is `Worker`. Now, `Worker` is a wrapper around the work that needs
    doing. It has one function, `doWork()`, which we override to implement the background
    work code. `doWork()` will be executed in a background thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third class is `WorkRequest`. This class binds a `Worker` class to arguments
    and constraints. There are two types of `WorkRequest`: `OneTimeWorkRequest`, which
    runs the work once, and `PeriodicWorkRequest`, which can be used to schedule work
    to run at a fixed interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth class is `ListenableWorker.Result`. You probably guessed it, but
    this is the class holding the result of the executed work. The result can be one
    of `Success`, `Failure`, or `Retry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these four classes, we also have the `Data` class, which holds data
    passed to and from the worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to our example. We want to define four tasks that need to occur
    in sequential order: the cat needs to stretch, then it needs to groom its fur,
    then visit the litter box, and finally, it needs to suit up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start using `WorkManager`, we have to first include its dependency
    in our app `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With `WorkManager` included in our project, we''ll go ahead and create our
    workers. The first worker will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by extending `Worker` and overriding its `doWork()` function. We then
    read the SCA ID from the input data. Then, because we have no real sensors to
    track the progress of the cat stretching, we fake our wait by introducing a 3-second
    (3,000-millisecond) `Thread.sleep(Long)` call. Finally, we construct an output
    data class with the ID we received in our input and return it with the successful
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve created workers for all our tasks (`CatStretchingWorker`, `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`), similarly to how we created
    the first one, we can call `WorkManager` to chain them. Let''s also assume we
    can''t tell the progress of the agent unless we''re connected to the internet.
    Our call would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first construct a `Constraints` instance declaring
    we need to be connected to the internet for the work to execute. We then define
    our input data, setting it to the SCA ID. Next, we bind the constraints and input
    data to our `Worker` class by constructing `OneTimeWorkRequest`. The construction
    of the other `WorkRequest` instances has been left out, but they are pretty much
    identical to the one shown here. We can now chain all the requests and enqueue
    them on the `WorkManager` class. You can enqueue a single `WorkRequest` instance
    by passing it directly to the `WorkManager` `enqueue()` function, or you can also
    have multiple `WorkRequest` instances run in parallel by passing them all to the
    `WorkManager` `enqueue()` function as a list.
  prefs: []
  type: TYPE_NORMAL
- en: Our tasks will be executed by `WorkManager` when the constraints are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Request` instance has a unique identifier. `WorkManager` exposes a `LiveData`
    property for each request, allowing us to track the progress of its work by passing
    its unique identifier as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The state of work can be `BLOCKED` (there is a chain of requests, and it is
    not next in the chain), `ENQUEUED` (there is a chain of requests, and this work
    is next), `RUNNING` (the work in `doWork()` is executing), and `SUCCEEDED`. Work
    can also be canceled, leading to a `CANCELLED` state, or it can fail, leading
    to a `FAILED` state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there's `Result.retry`. Returning this result tells the `WorkManager`
    class to enqueue the work again. The policy governing when to run the work again
    is defined by a `backoff` criteria set on `WorkRequest` `Builder`. The default
    `backoff` policy is exponential, but we can set it to be linear instead. We can
    also define the initial `backoff` time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put into practice the knowledge gained so far in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will track our SCA from the moment we fire off the command
    to deploy it to the field to the moment it arrives at its destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Executing Background Work with the WorkManager Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first exercise, we will track the SCA as it prepares to head out by
    enqueuing chained `WorkRequest` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new `Empty Activity` project (`File -> New -> New Project
    -> Empty Activity`). Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your application `Cat Agent Tracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your package name is `com.example.catagenttracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the save location to where you want to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave everything else at its default values and click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you are on the Android view in your `Project` pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your app''s `build.gradle` file. In the `dependencies` block, add the
    `WorkManager` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a new package under your app package (right-click on `com.example.catagenttracker`,
    then `New` | `Package`). Name the new package `com.example.catagenttracker.worker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class under `com.example.catagenttracker.worker` named `CatStretchingWorker`
    (right-click on `worker`, then `New` | `New Kotlin File/Class`). Under `Kind`,
    choose `Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To define a `Worker` instance that will sleep for `3` seconds, update the new
    class like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the required dependencies for a `Worker` implementation and then
    extend the `Worker` class. To implement the actual work, you will override `doWork():
    Result`, making it read the Cat Agent ID from the input, sleep for `3` seconds
    (`3000` milliseconds), construct an output data instance with the Cat Agent ID,
    and pass it inside a `Result.success` value.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat steps 9 and 10 to create three more identical workers named `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `MainActivity`. Right before the end of the class, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This helper function constructs an input `Data` instance for you with the Cat
    Agent ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the `onCreate(Bundle?)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the class, define your `WorkManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a chained `enqueue` request right below the code you just added, still
    within the `onCreate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function to show a toast with a provided message. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To track the progress of the enqueued `WorkRequest` instances, add the following
    after the `enqueue` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1: Toasts showing in order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: Toasts showing in order'
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a simple `Hello World!` screen. However, if you wait a few
    seconds, you will start seeing toasts informing you of the progress of your SCA
    preparing to deploy to the field. You will notice that the toasts follow the order
    in which you enqueued the requests and execute their delays sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Background Operations Noticeable to the User – Using a Foreground Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our SCA all suited up, they are now ready to get to the assigned destination.
    To track the SCA, we will periodically poll the location of the SCA using a foreground
    service and update the sticky notification (a notification that cannot be dismissed
    by the user) attached to that service with the new location. For the sake of simplicity,
    we will fake the location. Following what you learned in *Chapter 7*, *Android
    Permissions and Google Maps*, you could later replace this implementation with
    a real one that uses a map.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground services are another way of performing background operations. The
    name may be a bit counter-intuitive. It is meant to differentiate these services
    from the base Android (background) services. The former are tied to a notification,
    while the latter run in the background with no user-facing representation built
    in. Another important difference between foreground services and background services
    is that the latter are candidates for termination when the system is low on memory,
    while the former are not.
  prefs: []
  type: TYPE_NORMAL
- en: As of Android 9 (Pie, or API level 28), we have to request the `FOREGROUND_SERVICE`
    permission to use foreground services. Since it is a normal permission, it will
    be granted to our app automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can launch a foreground service, we must first create one. A foreground
    service is a subclass of the Android abstract `Service` class. If we do not intend
    to bind to the service, and in our example, we indeed do not, we can simply override
    `onBind(Intent)` so that it returns `null`. As a side note, binding is one of
    the ways for interested clients to communicate with a Service. We will not focus
    on this approach in this book, as there are other, easier approaches, as you will
    discover below.
  prefs: []
  type: TYPE_NORMAL
- en: 'A foreground service must be tied to a notification. On Android 8 (Oreo, or
    API level 26) and above, if a foreground service is not tied to one within the
    `onCreate()` function of the service. A quick implementation would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the channel ID. This is only required for Android Oreo
    or above and is ignored in earlier versions of Android. In Android Oreo, Google
    introduced the concept of channels. Channels are used to group notifications and
    allow users to filter out unwanted notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define `pendingIntent`. This will be the intent launched if the user
    taps on the notification. In this example, the main activity would be launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the channel ID and `pendingIntent`, we can construct our notification.
    We use `NotificationCompat`, which takes away some of the boilerplate around supporting
    older API levels. We pass in the service as the context and the channel ID. We
    define the title, text, small icon, intent, and ticker message and build the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To start a service in the foreground, attaching the notification to it, we
    call it `startForeground(Int, Notification)` function, passing in a notification
    ID (any unique int value to identify this service, which must not be 0) and a
    notification, which must have its priority set to `PRIORITY_LOW` or higher. In
    our case, we have not specified the priority, which sets it to `PRIORITY_DEFAULT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If launched, our service will now show a sticky notification. Clicking on the
    notification would launch our main activity. However, our service won't be doing
    anything useful. To add some functionality to it, we need to override `onStartCommand(Intent?,
    Int, Int)`. This function gets called when the service is launched via an intent,
    which also gives us the opportunity to read any extra data passed via that intent.
    It also provides us with flags (which may be set to `START_FLAG_REDELIVERY` or
    `START_FLAG_RETRY`) and a unique request ID. We will get to reading the extra
    data later in this chapter. You don't need to worry about the flags or the request
    ID in a simple implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that `onStartCommand(Intent?, Int, Int)` gets called
    on the UI thread, so don't perform any long-running operations here, or your app
    will freeze, giving the user a poor experience. Instead, we could create a new
    handler using a new `HandlerThread` (a thread with a looper, a class used to run
    a message loop for a thread) and post our work to it. This means we'll have an
    infinite loop running, waiting for us to post to it via a `Handler`. When we receive
    a start command, we can post the work we want done to it. That work will then
    be executed on that thread.
  prefs: []
  type: TYPE_NORMAL
- en: When our long-running work is done, there are a few things we may want to happen.
    First, we may want to inform whoever is interested (our main activity, if it is
    running, for example) that we are done. Then, we probably want to stop running
    in the foreground. Lastly, if we do not expect to require the service again, we
    could stop it.
  prefs: []
  type: TYPE_NORMAL
- en: An app has several ways to communicate with a service—binding, using broadcast
    receivers, using a bus architecture, or using a result receiver, to name a few.
    For our example, we will use Google's `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers
    allow our app to send and receive messages using a pattern much like the *publish-subscribe
    design pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: The system broadcasts events such as the device booting up or charging having
    started. Our services can broadcast status updates as well. For example, they
    can broadcast a long calculation result on completion.
  prefs: []
  type: TYPE_NORMAL
- en: If our app registers to receive a certain message, the system will inform it
    when that message is broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: This used to be a common way to communicate with services, but the `LocalBroadcastManager`
    class is now deprecated as it was an application-wide event bus that encouraged
    anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, broadcast receivers are still useful for system-wide events.
    We first define a class overriding the `BroadcastReceiver` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When an event is received by `ToastBroadcastReceiver`, it will show a toast
    showing the action and URI of the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register our receiver via the `Manifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Specifying `android:exported="true"` tells the system that this receiver can
    receive messages from outside of the application. The action defines the message
    we are interested in. We can specify multiple actions. In this example, we listen
    for when the device starts charging. Keep in mind that setting this value to "true"
    allows other apps, including malicious ones, to activate this receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also register for messages in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Adding this code to an activity or in our custom application class would register
    a new instance of our receiver as well. This receiver will live so long as the
    context (activity or application) is valid. So, correspondingly, if the activity
    or application is destroyed, our receiver will be freed to be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to our implementation. To use `LiveData` in our app, we must add a
    dependency in our `app/build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define a `LiveData` instance in the companion object of the service,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that we hide the `MutableLiveData` instance behind a `LiveData` interface.
    This is so that consumers can only read the data. We can now use the `mutableWorkCompletion`
    instance to report completion by assigning it a value. However, we must remember
    that values can only be assigned to `LiveData` instances on the main thread. This
    means once our work is done, we must switch back to the main thread. We can easily
    achieve that—all we need is a new handler with the main `Looper` (obtained by
    calling `Looper.getMainLooper()`) to which we can post our update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our service is ready to do some work, we can finally launch it. Before
    we do, we must make sure we added the service to our `AndroidManifest.xml` file
    within the `<application></application>` block as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch the service we just added to our manifest, we create `Intent`, passing
    in any extra data required as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And then we call `ContextCompat.startForegroundService(Context, Intent)` to
    fire off `Intent` and launch the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Tracking Your SCA''s Work with a Foreground Service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first exercise, you tracked the SCA as it was preparing to head out
    using the `WorkManager` class. In this exercise, you will track the SCA as it
    deploys to the field and moves toward the assigned target by showing a sticky
    notification counting down the time to arrival at the destination. This notification
    will be driven by a foreground service, which will present and continuously update
    it. Clicking the notification at any time will launch your main activity if it''s
    not already running and will always bring it to the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `LiveData` dependency to your project by updating your
    app''s `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new class called `RouteTrackingService`, extending the abstract
    `Service` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will not rely on binding in this exercise, so it is safe to simply return
    `null` in the `onBind(Intent)` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the newly created service, define some constants that you will later need,
    as well as the `LiveData` instance used to observe progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`NOTIFICATION_ID` has to be a unique identifier for the notification owned
    by this service and must not be `0`. Now, `EXTRA_SECRET_CAT_AGENT_ID` is the constant
    you would use to pass data to the service. `mutableTrackingCompletion` is private
    and is used to allow you to post completion updates internally via `LiveData`
    without exposing the mutability outside of the service. `trackingCompletion` is
    then used to expose the `LiveData` instance for observation in an immutable fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to your `RouteTrackingService` class to provide `PendingIntent`
    to your sticky notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will launch `MainActivity` whenever the user clicks on `Notification`.
    You call `PendingIntent.getActivity()`, passing a context, no request code (`0`),
    `Intent` that will launch `MainActivity`, and no flags (`0`) to it. You get back
    `PendingIntent`, which will launch that activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another function to create `NotificationChannel` for devices running Android
    Oreo or newer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You start by defining the channel ID. This needs to be unique to a package.
    Next, you define a channel name that will be visible to the user. This can (and
    should) be localized. We skipped that part for the sake of simplicity. A `NotificationChannel`
    instance is then created with importance set to `IMPORTANCE_DEFAULT`. The importance
    dictates how disruptive the notifications posted to this channel are. Lastly,
    a channel is created using `Notification Service` with the data provided in the
    `NotificationChannel` instance. The function returns the channel ID so that it
    can be used to construct `Notification`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function to provide you with `Notification.Builder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the `pendingIntent` and `channelId` instances generated
    from the functions you created earlier and constructs a `NotificationCompat.Builder`
    class. The builder lets you define a title (the first row), text (the second row),
    a small icon (size differs based on the device) to use, the intent to be triggered
    when the user clicks on `Notification`, and a ticker (used for accessibility;
    before Android Lollipop, this showed before the notification was presented). You
    can set other properties, too. Explore the `NotificationCompat.Builder` class.
    In a real project, remember to use string resources from strings.xml rather than
    hardcoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the following code to introduce a function to start the foreground service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You first get `PendingIntent` using the function you introduced earlier. Then,
    depending on the API level of the device, you create a notification channel and
    get its ID or set an empty ID. You pass `pendingIntent` and `channelId` to the
    function that constructs `NotificationCompat.Builder`, and start the service as
    a foreground service, providing it with `NOTIFICATION_ID` and a notification built
    using the builder. The function returns `NotificationCompat.Builder`, to be used
    later to update the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define two fields in your service—one to hold a reusable `NotificationCompat.Builder`
    class, and another to hold a reference to `Handler`, which you will later use
    to post work in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, override `onCreate()` to start the service as a foreground service, keep
    a reference to the `Notification.Builder`, and create `serviceHandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that to create the `Handler` instance, you must first define and start
    `HandlerThread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a call that tracks your deployed SCA as it approaches its designated destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will count down from `10` to `1`, sleeping for 1 second between updates
    and then updating the notification with the remaining time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function to notify observers of completion on the main thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By posting on a handler using the main `Looper`, you make sure that updates
    occur on the main (UI) app thread. When setting the value to the agent ID, you
    are notifying all observers that that agent ID has reached its destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override `onStartCommand(Intent?, Int, Int)` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You first delegate the call to `super`, which internally calls `onStart()` and
    returns a backward-compatible state you could return. You store this returned
    value. Next, you obtain the SCA ID from the extras passed via the intent. This
    service would not work without an agent ID, so you throw an exception if one is
    not provided. Next, you switch to the background thread defined in `onCreate`
    to track the agent to its destination in a blocking way. When tracking is done,
    you notify observers that the task is complete, stop the foreground service (removing
    the notification by passing `true`), and stop the service itself, as you don't
    expect to require it again soon. You then return the earlier stored return value
    from `super`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `AndroidManifest.xml` to request the `FOREGROUND_SERVICE` permission
    and introduce the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to your `MainActivity`. Introduce a function to launch `RouteTrackingService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function first observes `LiveData` for completion updates, showing a result
    on completion. Then, it defines `Intent` for launching the service, setting the
    SCA ID as an extra parameter for that `Intent`. It then launches the service as
    a foreground service using `ContextCompat`, which hides away compatibility-related
    logic for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, update `onCreate()` to start tracking the SCA as soon as it is suited
    up and ready to go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.2: Notification counting down'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: Notification counting down'
  prefs: []
  type: TYPE_NORMAL
- en: After the notifications informing you of the SCA's preparation steps, you should
    see a notification in your status bar. That notification should then count down
    from 10 to 0, disappear, and be replaced by a toast informing you that the agent
    arrived at its destination. Seeing that last toast tells you that you managed
    to communicate the SCA ID to the service as well as getting it back on completion
    of the background task.
  prefs: []
  type: TYPE_NORMAL
- en: With all the knowledge gained from this chapter, let's complete the following
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Reminder to Drink Water'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The average human loses about 2,500 ml of water per day (see [https://en.wikipedia.org/wiki/Fluid_balance#Output](https://en.wikipedia.org/wiki/Fluid_balance#Output)).
    To stay healthy, we need to consume as much water as we lose. However, due to
    the busy nature of modern life, a lot of us forget to stay hydrated regularly.
    Suppose you wanted to develop an app that keeps track of your water loss (statistically)
    and gives you a constant update of your fluid balance. Starting from a balanced
    state, the app would gradually decrease the user's tracked water level. The user
    could tell the app when they drank a glass of water, and it would update the water
    level accordingly. The continuous updating of the water level will leverage your
    knowledge of running a background task, and you will also utilize your knowledge
    of communicating with a service to update a balance in response to user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty activity project and name your app `My Water Tracker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a foreground service permission to your `AndriodManifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a variable in your service to track the water level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define constants for a notification ID and for an extra intent data key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the creation of the notification from the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add functions to start the foreground service and to update the water level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the water level to decrease every 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the addition of fluids from outside the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the service cleans up callbacks and messages when destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the service in the `Manifest.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the service from `MainActivity` when the activity is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to the main activity layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks the button, notify the service that it needs to increment
    the water level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to execute long-running background tasks using
    `WorkManager` and foreground services. We discussed how to communicate progress
    to the user, and how to get the user back into an app once a task is finished
    executing. All the topics covered in this chapter are quite broad, and you could
    explore communicating with services, building notifications, and using the `WorkManager`
    class further. Hopefully, for most common scenarios, you now have the tools you
    need. Common use cases include background downloads, the background cleaning up
    of cached assets, playing music while the app is not running in the foreground,
    and, combined with the knowledge we gained from *Chapter 7*, *Android Permissions
    and Google Maps*, tracking the user's location over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into making our apps more robust and maintainable
    by writing unit tests and integration tests. This is particularly helpful when
    the code you write runs in the background and it is not immediately evident when
    something goes wrong.
  prefs: []
  type: TYPE_NORMAL

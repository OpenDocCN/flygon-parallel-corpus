- en: Managing Objects, Strings, Time, and Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes that we will be discussing in this chapter, belong—together with
    Java collections and arrays discussed in the previous chapters—to the group of
    classes (mostly utilities from the Java Standard Library and Apache Commons) that
    every programmer has to master in order to become an effective coder. They also
    illustrate various software designs and solutions that are instructive and can
    be used as patterns for best coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following areas of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of the overviewed classes includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Objects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.lang3.ObjectUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.lang3.StringUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalDateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Math`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Random`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may not need to manage arrays and may even not need to manage collections
    (for some time, at least), but you cannot avoid managing objects, which means
    that the classes described in this section you are probably going to use every
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `java.util.Objects` class was added to the Java Standard Libraries
    in 2011 (with the Java 7 release), while the `ObjectUtils` class has existed in
    the Apache Commons libraries since 2002, their use grew slowly. This may be partially
    explained by the small number of methods they had originally—only six in `ObjectUtils` in
    2003 and only nine in `Objects` in 2011\. However, they were very helpful methods
    that could make the code more readable and robust—less prone to errors. So, why
    these classes were not used more often from the very beginning remains a mystery.
    We hope that you start using them immediately with your very first project.
  prefs: []
  type: TYPE_NORMAL
- en: Class java.util.Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class `Objects` has only 17 methods—all static. We have already used some
    of them in the previous chapter when we implemented the class `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person implements Comparable<Person> {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: 'this.name = name == null ? "" : name;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getAge(){ return this.age; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getName(){ return this.name; }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = this.name.compareTo(p.getName());
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return this.age - p.getAge();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if(!(o instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person)o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.getAge() &&
  prefs: []
  type: TYPE_NORMAL
- en: Objects.equals(name, person.getName()); //line 25
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int hashCode(){
  prefs: []
  type: TYPE_NORMAL
- en: return Objects.hash(age, name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{age=" + age + ", name=" + name + "}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We used the class `Objects` in the methods `equals()` and `hashCode()` previously.
    Everything worked fine. But, notice how we check the parameter `name` in the preceding
    constructor. If the parameter is `null`, we assign to the field `name` an empty `String` value.
    We did it to avoid `NullPointerException` in line 25\. Another way to do it is
    to use the class `ObjectUtils` from the Apache Commons library. We will demonstrate
    it in the next section. Methods of the class `ObjectUtils` handle `null` values
    and make the conversion of a `null` parameter to an empty `String` unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's review the methods of the class `Objects`.
  prefs: []
  type: TYPE_NORMAL
- en: equals() and deepEquals()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about the `equals()` method implementation extensively, but always
    assumed that it was invoked on a non-`null` object, `obj`, so the call `obj.equals(anotherObject)` could
    not generate `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, sometimes we need to compare two objects, `a` and `b`, when one or both
    of them can be `null`. Here is typical code for such a case:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean equals(Object a, Object b) {
  prefs: []
  type: TYPE_NORMAL
- en: return (a == b) || (a != null && a.equals(b));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This is the actual source code of the `boolean Objects.equals(Object a, Object
    b)` method. It allows comparing two objects using the method `equals(Object)` and
    handles cases where one or both of them are `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another related method of the class `Objects` is `boolean deepEquals(Object a, Object
    b)`. Here is its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean deepEquals(Object a, Object b) {
  prefs: []
  type: TYPE_NORMAL
- en: if (a == b)
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: else if (a == null || b == null)
  prefs: []
  type: TYPE_NORMAL
- en: return false;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: return Arrays.deepEquals0(a, b);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is based on `Arrays.deepEquals()`, which we discussed in
    the previous section. The demonstration code for these methods helps to understand
    the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] as1 = {1,2,3};
  prefs: []
  type: TYPE_NORMAL
- en: Integer[] as2 = {1,2,3};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.equals(as1, as2));        //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.deepEquals(as1, as2));    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.equals(as1, as2));        //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.deepEquals(as1, as2));    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][] aas1 = {{1,2,3},{1,2,3}};
  prefs: []
  type: TYPE_NORMAL
- en: Integer[][] aas2 = {{1,2,3},{1,2,3}};
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.equals(aas1, aas2));       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Arrays.deepEquals(aas1, aas2));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.equals(aas1, aas2));       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.deepEquals(aas1, aas2));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `Objects.equals(as1, as2)` and `Objects.equals(aas1,
    aas2)` return `false` because arrays cannot override the method `equals()` of
    the class `Object` and are compared by references, not by value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `Arrays.equals(aas1, aas2)` returns `false` for the same reason:
    because the elements of the nested array are arrays and are compared by references.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, if you would like to compare two objects, `a` and `b`, by the
    values of their fields, then:'
  prefs: []
  type: TYPE_NORMAL
- en: If they are not arrays and `a` is not `null`, use `a.equals(b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are not arrays and both objects can be `null`, use `Objects.equals(a,
    b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both can be arrays and both can be `null`, use `Objects.deepEquals(a, b)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, we can see that the method `Objects.deepEquals()` is the safest one,
    but it does not mean you must always use it. Most of the time, you will know whether
    the compared objects can be `null` or can be arrays, so you can safely use other `equals()` methods
    too.
  prefs: []
  type: TYPE_NORMAL
- en: hash() and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hash values returned by the methods `hash()` or `hashCode()` are typically
    used as a key for storing the object in a hash-using collection, such as `HashSet()`.
    The default implementation in the  `Object` superclass is based on the object
    reference in memory.  It returns different hash values for two objects of the
    same class with the same values of the instance fields. That is why, if you need
    two class instances to have the same hash value for the same state, it is important
    to override the default `hashCode()` implementation using one of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int hashCode(Object value)`: calculates a hash value for a single object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int hash(Object... values)`: calculates a hash value for an array of objects
    (see how we used it in the class `Person` in our previous example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please notice that these two methods return different hash values for the same
    object when it is used as a single-element input array of the method `Objects.hash()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.hash("s1"));           //prints: 3645'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.hashCode("s1"));       //prints: 3614'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only value that yields the same hash from both methods is `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.hash(null));      //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.hashCode(null));  //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When used as a single not-null parameter, the same value has different hash
    values returned from the methods `Objects.hashCode(Object value)` and `Objects.hash(Object...
    values)`. The value `null` yields the same hash value, `0`, returned from each
    of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using the class `Objects` for hash value calculation is
    that it tolerates `null` values, while the attempt to call the instance method `hashCode()` on
    the `null` reference generates `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: isNull() and nonNull()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These two methods are just thin wrappers around Boolean expressions, `obj == null` and  `obj
    != null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean isNull(Object obj)`: returns the same value as `obj == null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean nonNull(Object obj)`: returns the same value as `obj != null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(object == null);           //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.isNull(object));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(object != null);           //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(Objects.nonNull(object));  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: requireNonNull()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following methods of the class `Objects` check the value of the first parameter
    and, if the value is `null`, either throw `NullPointerException` or return the
    provided default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNull(T obj)`: Throws `NullPointerException` without a message
    if the parameter is `null`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNull(object);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage());  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNull(T obj, String message)`: Throws `NullPointerException` with
    the message provided if the first parameter is `null`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNull(object, "Parameter 'object' is null");
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: //Parameter 'object' is null
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNull(T obj, Supplier<String> messageSupplier)`: returns the message
    generated by the provided function if the first parameter is `null` or, if the
    generated message or the function itself is `null`, throws `NullPointerException`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> msg1 = () -> {
  prefs: []
  type: TYPE_NORMAL
- en: String msg = "Msg from db";
  prefs: []
  type: TYPE_NORMAL
- en: //get the corresponding message from database
  prefs: []
  type: TYPE_NORMAL
- en: return msg;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNull(object, msg1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage());  //prints: Msg from db'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> msg2 = () -> null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNull(object, msg2);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage());  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> msg3 = null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNull(object, msg3);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage());  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNullElse(T obj, T defaultObj)`: returns the first parameter value
    if it is non-null, or the second parameter value if it is non-null, or throws `NullPointerException` with
    the message `defaultObj`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Objects.requireNonNullElse(object,
  prefs: []
  type: TYPE_NORMAL
- en: '"Default value"));'
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Default value'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.requireNonNullElse(object, null);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage());     //prints: defaultObj'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`T requireNonNullElseGet(T obj, Supplier<? extends T> supplier)`: returns the
    first parameter value if it is non-null, or the object produced by the provided
    function if it is non-null, or throws `NullPointerException` with the message
    `defaultObj`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String object = null;
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> msg1 = () -> {
  prefs: []
  type: TYPE_NORMAL
- en: String msg = "Msg from db";
  prefs: []
  type: TYPE_NORMAL
- en: //get the corresponding message from database
  prefs: []
  type: TYPE_NORMAL
- en: return msg;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: String s = Objects.requireNonNullElseGet(object, msg1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);                //prints: Msg from db'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<String> msg2 = () -> null;
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Objects.requireNonNullElseGet(object, msg2));
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage()); //prints: supplier.get()'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Objects.requireNonNullElseGet(object, null));
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NullPointerException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ex.getMessage()); //prints: supplier'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: checkIndex()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following group of methods checks whether the index and the length of a
    collection or an array are compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int checkIndex(int index, int length)`: throws `IndexOutOfBoundsException` if
    the provided `index` is bigger than `length - 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int checkFromIndexSize(int fromIndex, int size, int length)`: throws `IndexOutOfBoundsException` if
    the provided `index + size` is bigger than `length - 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int checkFromToIndex(int fromIndex, int toIndex, int length)`: throws `IndexOutOfBoundsException` if
    the provided `fromIndex` is bigger than `toIndex`, or `toIndex` is bigger than `length
    - 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = List.of("s0", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.checkIndex(3, list.size());
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IndexOutOfBoundsException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Index 3 out-of-bounds for length 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.checkFromIndexSize(1, 3, list.size());
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IndexOutOfBoundsException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Range [1, 1 + 3) out-of-bounds for length 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Objects.checkFromToIndex(1, 3, list.size());
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (IndexOutOfBoundsException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(ex.getMessage());
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Range [1, 3) out-of-bounds for length 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: compare()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `int compare(T a, T b, Comparator<T> c)` of the class `Objects` uses
    the provided comparator''s method `compare(T o1, T o2)` for comparing the two
    objects. We have described already the behavior of the `compare(T o1, T o2)` method while
    talking about sorting collections, so the following results should be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int diff = Objects.compare("a", "c", Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(diff);  //prints: -2'
  prefs: []
  type: TYPE_NORMAL
- en: diff = Objects.compare("a", "c", Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(diff);  //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: diff = Objects.compare(3, 5, Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(diff);  //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: diff = Objects.compare(3, 5, Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(diff);  //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned already, the method `compare(T o1, T o2)` returns the difference
    of positions of objects `o1` and `o2` in a sorted list for `String` objects and
    just `-1`, `0`, or `1` for `Integer` objects. The API describes it as returning
    `0` when objects are equal and a negative number when the first object is smaller
    than the second; otherwise, it returns a positive number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how the method `compare(T a, T b, Comparator<T> c)` works, let''s
    assume that we want to sort objects of the class `Person` so that the name and
    age are arranged in a natural order of `String` and `Integer` classes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = Objects.compare(this.name, p.getName(),
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return Objects.compare(this.age, p.getAge(),
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the result of this new implementation of the `compareTo(Object)` method
    of the class `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person(15, "Zoe");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person(45, "Adam");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person(37, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p4 = new Person(30, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>(List.of(p1, p2, p3, p4));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);//[{15, Zoe}, {45, Adam}, {37, Bob}, {30, Bob}]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);//[{45, Adam}, {30, Bob}, {37, Bob}, {15, Zoe}]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `Person` objects are ordered by name in their natural order
    first, then by age in their natural order too. If we need to reverse the order
    of names, for example, we change the `compareTo(Object)` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = Objects.compare(this.name, p.getName(),
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return Objects.compare(this.age, p.getAge(),
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results looks as like we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person(15, "Zoe");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person(45, "Adam");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person(37, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p4 = new Person(30, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>(List.of(p1, p2, p3, p4));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);//[{15, Zoe}, {45, Adam}, {37, Bob}, {30, Bob}]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);//[{15, Zoe}, {30, Bob}, {37, Bob}, {45, Adam}]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The weakness of the method `compare(T a, T b, Comparator<T> c)` is that it does
    not handle `null` values. Adding the `new Person(25, null)` object to the list
    triggers `NullPointerException` during sorting. In such cases, it is better to
    use the `org.apache.commons.lang3.ObjectUtils.compare(T o1, T o2)` method, which
    we are going to demonstrate in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: toString()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are cases when you need to convert an `object` (which is a reference
    to some class type) to its `String` representation. When the reference `obj` is
    assigned a `null` value (the object is not created yet), writing `obj.toString()` 
    generates `NullPointerException`. For such cases, using the following methods
    of the class `Objects` is a better choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String toString(Object o)`: returns the result of calling `toString()` on
    the first parameter when it is not `null` and `null` when the first parameter
    value is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toString(Object o, String nullDefault)`: returns the result of calling `toString()` on
    the first parameter when it is not `null` and the second parameter value `nullDefault` when
    the first parameter value is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that demonstrates how to use these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>(List.of("s0 "));
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String e: list){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(e);                   //prints: s0 null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String e: list){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(Objects.toString(e)); //prints: s0 null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String e: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(Objects.toString(e, "element was null"));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: s0 element was null'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, unrelated to the current discussion, please notice how we used the
    method `print()` instead of `println()` to show all the results in one line, because
    the method `print()` does not add an end-of-line symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Class lang3.ObjectUtils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `org.apache.commons.lang3.ObjectUtils` of the Apache Commons library
    complements the methods of the class `java.util.Objects` described previously.
    The scope of this book and the allocated size does not allow for a detailed review
    of all the methods of the class `ObjectUtils`, so we will describe them briefly,
    grouped by related functionality, and will demonstrate only those that are aligned
    with the examples we have provided already.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the methods of the class `ObjectUtils` can be organized into seven groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object cloning methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T clone(T obj)`: returns a copy of the provided object if it implements the
    interface `Cloneable`; otherwise, returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T cloneIfPossible(T obj)`: returns a copy of the provided object if it implements
    the interface `Cloneable`; otherwise, returns the original provided object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that support object comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int compare(T c1, T c2)`: compares newly ordered positions of the two objects
    that implement the interface `Comparable`; allows any or both parameters to be `null`;
    places a `null` value in front of a non-null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int compare(T c1, T c2, boolean nullGreater)`: behaves exactly as the previous
    method if the value of parameter `nullGreater` is `false`; otherwise, places a
    `null` value behind a non-null value. We can demonstrate the last two methods
    by using them in our class `Person`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = ObjectUtils.compare(this.name, p.getName());
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return ObjectUtils.compare(this.age, p.getAge());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this change allows us to use a `null` value for the `name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person(15, "Zoe");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person(45, "Adam");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person(37, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p4 = new Person(30, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p5 = new Person(25, null);
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>(List.of(p1, p2, p3, p4, p5));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);  //[{15, Zoe}, {45, Adam}, {37, Bob}, {30, Bob}, {25,
    }]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);  //[{25, }, {45, Adam}, {30, Bob}, {37, Bob}, {15,
    Zoe}]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have used the method `Objects.compare(T c1, T c2)`, the `null` value
    was placed in front of non-null values. By the way, have you noticed that we do
    not display `null` anymore? That is because we have changed the method `toString()` of
    the class `Person` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: //return "{" + age + ", " + name + "}";
  prefs: []
  type: TYPE_NORMAL
- en: return "{" + age + ", " + Objects.toString(name, "") + "}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just displaying the value of the field `name`, we used the method `Objects.toString(Object
    o, String nullDefault)`, which substitutes the object with the provided `nullDefault` value
    when the object is `null`. As to whether to use this method, in this case, is
    a matter of style. Many programmers would probably argue that we must display
    the actual value without substituting it for something else. But, we have done
    it just to show how the method `Objects.toString(Object o, String nullDefault)` could
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now use the second `compare(T c1, T c2, boolean nullGreater)` method,
    the `compareTo()` method of the class `Person` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = ObjectUtils.compare(this.name, p.getName(), true);
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return ObjectUtils.compare(this.age, p.getAge());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, `Person` objects with their `name` set to `null` will be shown at the
    end of the sorted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person(15, "Zoe");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person(45, "Adam");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person(37, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p4 = new Person(30, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p5 = new Person(25, null);
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>(List.of(p1, p2, p3, p4, p5));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);
  prefs: []
  type: TYPE_NORMAL
- en: //[{15, Zoe}, {45, Adam}, {37, Bob}, {30, Bob}, {25, }]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);
  prefs: []
  type: TYPE_NORMAL
- en: //[{45, Adam}, {30, Bob}, {37, Bob}, {15, Zoe}, {25, }]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, to complete the discussion of `null` values, the preceding code will break
    with `NullPointerException` when a `null` object is added to the list: `list.add(null)`.
    To avoid the exception, you can use a special `Comparator` object that handles
    the `null` elements of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p1 = new Person(15, "Zoe");
  prefs: []
  type: TYPE_NORMAL
- en: Person p2 = new Person(45, "Adam");
  prefs: []
  type: TYPE_NORMAL
- en: Person p3 = new Person(37, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p4 = new Person(30, "Bob");
  prefs: []
  type: TYPE_NORMAL
- en: Person p5 = new Person(25, null);
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>(List.of(p1, p2, p3, p4, p5));
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);
  prefs: []
  type: TYPE_NORMAL
- en: //[{15, Zoe}, {45, Adam}, {37, Bob}, {30, Bob}, {25, }, null]
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list,
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.nullsLast(Comparator.naturalOrder()));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);
  prefs: []
  type: TYPE_NORMAL
- en: //[{45, Adam}, {30, Bob}, {37, Bob}, {15, Zoe}, {25, }, null]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, you can see how we have indicated the desire to see the `null` objects
    at the end of the list. Instead, we could use another `Comparator` that places
    null objects at the beginning of the sorted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Collections.sort(list,
  prefs: []
  type: TYPE_NORMAL
- en: Comparator.nullsFirst(Comparator.naturalOrder()));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);
  prefs: []
  type: TYPE_NORMAL
- en: //[null, {45, Adam}, {30, Bob}, {37, Bob}, {15, Zoe}, {25, }]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`notEqual`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean notEqual(Object object1, Object object2)`: compares two objects for
    inequality, where either one or both objects may be `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identityToString`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String identityToString(Object object)`: returns the `String` representation
    of the provided object as if produced by the default method `toString()` of the
    base class `Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void identityToString(StringBuffer buffer, Object object)`: appends the `String` representation
    of the provided object as if produced by the default method `toString()` of the
    base class `Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void identityToString(StringBuilder builder, Object object)`: appends the `String` representation
    of the provided object as if produced by the default method `toString()` of the
    base class `Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void identityToString(Appendable appendable, Object object)`: appends the `String` representation
    of the provided object as if produced by the default method `toString()` of the
    base class `Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates two of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "s0 " + ObjectUtils.identityToString("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: s0 java.lang.String@5474c6c'
  prefs: []
  type: TYPE_NORMAL
- en: StringBuffer sb = new StringBuffer();
  prefs: []
  type: TYPE_NORMAL
- en: sb.append("s0");
  prefs: []
  type: TYPE_NORMAL
- en: ObjectUtils.identityToString(sb, "s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: s0 java.lang.String@5474c6c'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`allNotNull` and `anyNotNull`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean allNotNull(Object... values)`: returns `true` when all values in the
    provided array are not `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean anyNotNull(Object... values)`: returns `true` when at least one value
    in the provided array is not `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstNonNull` and `defaultIfNull`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T firstNonNull(T... values)`: returns the first value from the provided array
    that is not `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T defaultIfNull(T object, T defaultValue)`: returns the provided default value
    if the first parameter is `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`, `min`, `median`, and `mode`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T max(T... values)`: returns the last in the ordered list of provided values
    that implement the `Comparable` interface; returns `null` only when all values
    are `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T min(T... values)`: returns the first in the ordered list of provided values
    that implement the `Comparable` interface; returns `null` only when all values
    are `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T median(T... items)`: returns the value that is in the middle of the ordered
    list of provided values that implement the `Comparable` interface; if the count
    of the values is even, returns the smallest of the two in the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T median(Comparator<T> comparator, T... items)`: returns the value that is
    in the middle of the list of provided values ordered according to the provided `Comparator` object;
    if the count of the values is even, returns the smallest of the two in the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T mode(T... items)`: returns the most frequently occurring item from the items provided;
    returns `null` when such an item occurs most often or when there is no one item
    that occurs most often; here is the code that demonstrates this last method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = ObjectUtils.mode("s0", "s1", "s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);     //prints: s1'
  prefs: []
  type: TYPE_NORMAL
- en: s = ObjectUtils.mode("s0", "s1", "s2");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: s = ObjectUtils.mode("s0", "s1", "s2", "s1", "s2");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: s = ObjectUtils.mode(null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: s = ObjectUtils.mode("s0", null, null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);     //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Managing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `String` is used a lot. So, you have to have a good handle on its
    functionality. We talked already talked about `String` value immutability in [Chapter
    5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements and Types*.
    We have shown that every time a `String` value is "modified", a new copy of the
    value is created, which means that in the case of multiple "modifications", many `String` objects
    are created, consuming memory and putting a burden on the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, it is advisable to use the class `java.lang.StringBuilder` or `java.lang.StringBuffer` because
    they are modifiable objects and do not have an overhead of creating `String` value
    copies. We will show how to use them and explain the difference between these
    two classes in the first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will review the methods of the class `String` and then provide
    an overview of the class `org.apache.commons.lang3.StringUtils`, which complements
    the class `String` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder and StringBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes `StringBuilder` and `StringBuffer` have exactly the same list of
    methods. The difference is that the methods of the class `StringBuilder` perform
    faster than the same methods of the class `StringBuffer`. That is because the
    class `StringBuffer` has an overhead of not allowing concurrent access to its
    values from different application threads. So, if you are not coding for multithreaded
    processing, use `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many methods in the classes `StringBuilder` and `StringBuffer`.  But,
    we are going to show how to use only the method `append()`, which is by far the
    most popular, used for cases when multiple `String` value modifications are required.
    Its main function is to append a value to the end of the value already stored
    inside the `StringBuilder` (or `StringBuffer`) object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `append()` is overloaded for all primitive types and for the classes `String`, `Object`, `CharSequence`,
    and `StringBuffer`, which means that a `String` representation of the passed-in
    object of any of these classes can be appended to the existing value. For our
    demonstration, we are going use only the `append(String s)` version because that
    is what you are probably going to use most of the time. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list =
  prefs: []
  type: TYPE_NORMAL
- en: List.of("That", "is", "the", "way", "to", "build", "a", "sentence");
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder sb = new StringBuilder();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String s: list){'
  prefs: []
  type: TYPE_NORMAL
- en: sb.append(s).append(" ");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String s = sb.toString();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: That is the way to build a sentence'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are also methods `replace()`, `substring()`, and `insert()` in the class `StringBuilder` (and `StringBuffer`)
    that allow modifying the value further. They are used much less often than the
    method `append()` though, and we are not going to discuss them as they are outside
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Class java.lang.String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `String` has 15 constructors and almost 80 methods. To talk details
    and demonstrate each of them is just too much for this book, so we will comment
    only on the most popular methods and just mention the rest. After you master the
    basics, you can read the online documentation and see what else you can do with
    other methods of the class `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The constructors of the class `String` are useful if you are concerned that
    the strings your application creates consume too much memory. The problem is that `String` literals
    (`abc`, for example) are stored in a special area of the memory called the "string
    constant pool" and never garbage collected. The idea behind such a design is that `String` literals
    consume substantially more memory than numbers. Also, the handling of such large
    entities has an overhead that may tax the JVM. That is why the designers figured
    it is cheaper to store them and share them between all application threads than
    allocate new memory and then clean it up several times for the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if the rate of reuse of the `String` values is low, while the stored `String` values
    consume too much memory, creating a `String` object with a constructor may be
    the solution to the problem. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String veryLongText = new String("asdakjfakjn akdb aakjn... akdjcnak");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: A `String` object created this way resides in the heap area (where all objects
    are stored) and is garbage collected when not used anymore. That is when the `String` constructor
    shines.
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, you can use the method `intern()` of the class `String` to create
    a copy of the heap `String` object in the string constant pool. It allows us not
    only to share the value with other application threads (in multithreaded processing),
    but also to compare it with another literal value by reference (using the operator
    `==`). If the references are equal, it means they point to the same `String` value
    in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: But, mainstream programmers rarely manage the memory this way, so we will not
    discuss this topic further.
  prefs: []
  type: TYPE_NORMAL
- en: format()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `String format(String format, Object... args)` allows insertion
    of the provided objects into specified locations of a string and formatting them
    as needed. There are many format specifiers in the class `java.util.Formatter`.
    We will demonstrate here only `%s`, which converts the passed-in object to its `String` representation
    by invoking it on the object method `toString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String format = "There is a %s in the %s";
  prefs: []
  type: TYPE_NORMAL
- en: String s = String.format(format, "bear", "woods");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s); //prints: There is a bear in the woods'
  prefs: []
  type: TYPE_NORMAL
- en: format = "Class %s is very useful";
  prefs: []
  type: TYPE_NORMAL
- en: s = String.format(format, new A());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: Class A is very useful'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: replace()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `String replace(CharSequence target, CharSequence replacement)` in
    the `String` value replaces the value of the first parameter with the value of
    the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 = "There is a bear in the woods";
  prefs: []
  type: TYPE_NORMAL
- en: String s2 = s1.replace("bear", "horse").replace("woods", "field");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s2);     //prints: There is a horse in the field'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are also the methods `String replaceAll(String regex, String replacement)` and `String
    replaceFirst(String regex, String replacement)`, which have similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: compareTo()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used the `int compareTo(String anotherString)` method in our
    examples. It returns the difference between the positions of this `String` value
    and the value of `anotherString` in an ordered list. It is used for the natural
    ordering of strings since it is an implementation of the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The method `int compareToIgnoreCase(String str)` performs the same function
    but ignores the case of the compared strings and is not used for natural ordering
    because it is not an implementation of the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: valueOf(Objectj)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The static method `String valueOf(Object obj)` returns `null` if the provided
    object is `null`, or calls the method `toString()` on the object provided.
  prefs: []
  type: TYPE_NORMAL
- en: valueOf(primitive or char[])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any primitive type value can be passed as the parameter into the static method `String
    valueOf(primitive value)`, which returns the String representation of the value provided.
    For example, `String.valueOf(42)` returns `42`. This group of methods includes
    the following static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String valueOf(boolean b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(char c)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(double d)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(float f)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(int i)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(long l)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(char[] data)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String valueOf(char[] data, int offset, int count)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: copyValueOf(char[])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method `String copyValueOf(char[] data)` is equivalent to `valueOf(char[])`,
    while the method `String copyValueOf(char[] data, int offset, int count)` is equivalent
    to `valueOf(char[], int, int)`. They return a `String` representation of a char
    array or its subarray.
  prefs: []
  type: TYPE_NORMAL
- en: And the method `void getChars(int srcBegin, int srcEnd, char[] dest, int dstBegin)` copies
    characters from this `String` value into the destination character array.
  prefs: []
  type: TYPE_NORMAL
- en: indexOf() and substring()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Various `int indexOf(String str)` and `int lastIndexOf(String str)` methods
    return the position of a substring  in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "Introduction";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.indexOf("I"));      //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.lastIndexOf("I"));  //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.lastIndexOf("i"));  //prints: 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.indexOf("o"));      //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.lastIndexOf("o"));  //prints: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.indexOf("tro"));    //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the position count starts from zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `String substring(int beginIndex)` returns the rest of the string
    value, starting from the position (index) passed in as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "Introduction";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(1));        //prints: ntroduction'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(2));        //prints: troduction'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The character with the `beginIndex` position is the first that is present in
    the preceding substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `String substring(int beginIndex, int endIndex)` returns the substring,
    starting from the position passed in as the first parameter, to the position passed
    in as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "Introduction";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(1, 2));        //prints: n'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(1, 3));        //prints: nt'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As with the method `substring(beginIndex)`, the character with the `beginIndex` position
    is the first that is present in the preceding substring, while the character with
    the `endIndex` position is not included. The difference `endIndex - beginIndex` equals
    the length of the substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the following two substrings are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(1));              //prints: ntroduction'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.substring(1, s.length()));  //prints: ntroduction'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: contains() and matches()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `boolean contains(CharSequence s)` returns `true` when the provided
    sequence of characters (substring) is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "Introduction";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.contains("x"));          //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.contains("o"));          //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.contains("tro"));        //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s.contains("trx"));        //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other similar methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean matches(String regex)`: uses a regular expression (not a subject of
    this book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean regionMatches(int tOffset, String other, int oOffset, int length)`:
    compares regions of two strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean regionMatches(boolean ignoreCase, int tOffset, String other, int oOffset,
    int length)`: same as above, but with the flag `ignoreCase` indicating whether
    to ignore the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: split(), concat(), and join()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods `String[] split(String regex)` and `String[] split(String regex,
    int limit)` use the passed-in regular expression to split the strings into substrings.
    We do not explain regular expressions in this book. However, there is a very simple
    one that is easy to use even if you know nothing about regular expressions: if
    you just pass into this method any symbol or substring present in a string, the
    string will be broken (split) into parts separated by the passed-in value, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String[] substrings = "Introduction".split("o");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(substrings));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [Intr, ducti, n]'
  prefs: []
  type: TYPE_NORMAL
- en: substrings = "Introduction".split("duct");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(substrings));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [Intro, ion]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code just illustrates the functionality. But the following code snippet
    is more practical:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s = "There is a bear in the woods";
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = s.split(" ");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(arr));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [There, is, a, bear, in, the, woods]'
  prefs: []
  type: TYPE_NORMAL
- en: arr = s.split(" ", 3);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Arrays.toString(arr));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: [There, is, a bear in the woods]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the second parameter in the `split()` method limits the number
    of resulting substrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `String concat(String str)` adds the passed-in value to the end
    of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s1 =  "There is a bear";
  prefs: []
  type: TYPE_NORMAL
- en: String s2 =  " in the woods";
  prefs: []
  type: TYPE_NORMAL
- en: String s = s1.concat(s2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: There is a bear in the woods'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `concat()` method creates a new `String` value with the result of concatenation,
    so it is quite economical. But if you need to add (concatenate) many values, using `StringBuilder` (or `StringBuffer`,
    if you need protection from concurrent access) would be a better choice. We discussed
    it in the previous section. Another option would be to use the operator `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String s =  s1 + s2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: There is a bear in the woods'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The operator `+`, when used with `String` values, is implemented based on `StringBuilder`,
    so allows the addition of `String` values by modifying the existing one. There
    is no performance difference between using StringBuilder and just the operator
    `+` for adding `String` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods `String join(CharSequence delimiter, CharSequence... elements)` and `String
    join(CharSequence delimiter, Iterable<? extends CharSequence> elements)` are based
    on `StringBuilder` too. They assemble the provided values in one `String` value
    using the passed-in `delimiter` to separate the assembled values inside the created `String` result.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: s = String.join(" ", "There", "is", "a", "bear", "in", "the", "woods");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: There is a bear in the woods'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list =
  prefs: []
  type: TYPE_NORMAL
- en: List.of("There", "is", "a", "bear", "in", "the", "woods");
  prefs: []
  type: TYPE_NORMAL
- en: s = String.join(" ", list);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);  //prints: There is a bear in the woods'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: startsWith() and endsWith()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following methods return `true` when the String value starts (or ends)
    with the provided substring `prefix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean startsWith(String prefix)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean startsWith(String prefix, int toffset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean endsWith(String suffix)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = "Introduction".startsWith("Intro");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b);             //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: b = "Introduction".startsWith("tro", 2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b);             //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: b = "Introduction".endsWith("ion");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(b);             //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: equals() and equalsIgnoreCase()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used the method `boolean equals(Object anObject)` of the class `String` several
    times already and have pointed out that it compares this `String` value with other
    objects. This method returns `true` only when the passed-in object is `String` with
    the same value.
  prefs: []
  type: TYPE_NORMAL
- en: The method `boolean equalsIgnoreCase(String anotherString)` does the same but
    also ignores case, so the strings `AbC` and `ABC` are considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: contentEquals() and copyValueOf()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method `boolean contentEquals(CharSequence cs)` compares this `String` value
    with the `String` representation of an object that implements the interface `CharSequence`.
    The popular `CharSequence` implementations are `CharBuffer`, `Segment`, `String`, `StringBuffer`,
    and `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `boolean contentEquals(StringBuffer sb)` does the same but for `StringBuffer` only.
    It has slightly different implementation than `contentEquals(CharSequence cs)` and
    may have some performance advantages in certain situations, but we are not going
    to discuss such details. Besides, you probably will not even notice which of the
    two methods is used when you call `contentEquals()` on a `String` value unless
    you make an effort to exploit the difference.
  prefs: []
  type: TYPE_NORMAL
- en: length(), isEmpty(), and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method `int length()` returns the number of characters in a `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: The method `boolean isEmpty()` returns `true` when there are no characters in
    the `String` value and the method `length()` returns zero.
  prefs: []
  type: TYPE_NORMAL
- en: The method `int hashCode()` returns a hash value of the `String` object.
  prefs: []
  type: TYPE_NORMAL
- en: trim(), toLowerCase(), and toUpperCase()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method `String trim()` removes leading and trailing whitespaces from a `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods change the case of the characters in a `String` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String toLowerCase()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toUpperCase()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toLowerCase(Locale locale)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toUpperCase(Locale locale)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: getBytes(), getChars(), and toCharArray()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following methods convert the `String` value to a byte array, optionally
    encoding it using the given charset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte[] getBytes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[] getBytes(Charset charset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[] getBytes(String charsetName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And these methods convert all the `String` value to other types, or only part
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntStream chars()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char[] toCharArray()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char charAt(int index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharSequence subSequence(int beginIndex, int endIndex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get code point by index or stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following group of methods convert all the `String` value, or only part
    of it, into Unicode code points of its characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntStream codePoints()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int codePointAt(int index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int codePointBefore(int index)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int codePointCount(int beginIndex, int endIndex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int offsetByCodePoints(int index, int codePointOffset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explained Unicode code points in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*. These methods are especially useful when you need
    to represent characters that *do not fit* into the two bytes of the `char` type.
    Such characters have code points bigger than `Character.MAX_VALUE`, which is  `65535`.
  prefs: []
  type: TYPE_NORMAL
- en: Class lang3.StringUtils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `org.apache.commons.lang3.StringUtils` of the Apache Commons library
    has more than 120 static utility methods that complement those of the class `String` we
    described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the most popular are the following static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean isBlank(CharSequence cs)`: returns `true` when the passed-in parameter
    is an empty `String` "", `null`, or whitespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isNotBlank(CharSequence cs)`: returns `true` when the passed-in parameter
    is not an empty `String` "", `null`, or whitespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isAlpha(CharSequence cs)`: returns `true` when the passed-in parameter
    contains only Unicode letters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isAlphaSpace(CharSequence cs)`: returns `true` when the passed-in
    parameter contains only Unicode letters and spaces (''  '')'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isNumeric(CharSequence cs)`: returns `true` when the passed-in parameter
    contains only digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isNumericSpace(CharSequence cs)`: returns `true` when the passed-in
    parameter contains only digits and spaces (''  '')'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isAlphaNumeric(CharSequence cs)`: returns `true` when the passed-in
    parameter contains only Unicode letters and digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isAlphaNumericSpace(CharSequence cs)`: returns `true` when the passed-in
    parameter contains only Unicode letters, digits, and spaces (''  '')'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We highly recommend you look through the API of this class and get a feel for
    what you can find there.
  prefs: []
  type: TYPE_NORMAL
- en: Managing time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many classes in the `java.time` package and its sub-packages. They
    were introduced as a replacement for other—older—packages that handle date and
    time. The new classes are thread-safe (so better suited for multithreaded processing)
    and, no less important, are more consistently designed and easier to understand.
    Also, the new implementation follows the **International Standard Organization**
    (**ISO**) for date and time formats, but allows the use of any other custom format
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will describe the main five classes and demonstrate how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.LocalDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.LocalTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.LocalDateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Period`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Duration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these, and other classes of the `java.time` package and its sub-packages,
    are rich in various functionalities that cover all practical and any imaginable
    cases. But we are not going to cover all of them, just introduce the basics and
    most popular use cases.
  prefs: []
  type: TYPE_NORMAL
- en: java.time.LocalDate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class `LocalDate` does not carry time. It represents a date in ISO 8601
    format, yyyy-MM-DD:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(LocalDate.now());   //prints: 2018-04-14'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the method `now()` returns the current date as it is set on
    your computer: `April 14, 2018` was the date when this section was written.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly,  you can get the current date in any other timezone using the static
    method `now(ZoneId zone)`. The `ZoneId` object can be constructed using the static
    method `ZoneId.of(String zoneId)`, where `String zoneId` is any of the `String` values
    returned by the method `ZonId.getAvailableZoneIds()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> zoneIds = ZoneId.getAvailableZoneIds();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String zoneId: zoneIds){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(zoneId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code prints many timezone IDs, one of them being `Asia/Tokyo`. Now, we
    can find what the date is now, in that time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ZoneId zoneId = ZoneId.of("Asia/Tokyo");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(LocalDate.now(zoneId));   //prints: 2018-04-15'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object of `LocalDate` can represent any date in the past or in the future
    too, using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalDate parse(CharSequence text)`: constructs an object from a string in ISO
    8601 format, yyyy-MM-DD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate parse(CharSequence text, DateTimeFormatter formatter) `: constructs
    an object from a string in a format specified by the object `DateTimeFormatter`, which
    has many predefined formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate of(int year, int month, int dayOfMonth)`: constructs an object form
    a year, month, and day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate of(int year, Month month, int dayOfMonth)`: constructs an object
    from a year, month (as `enum` constant), and day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate ofYearDay(int year, int dayOfYear)`: constructs an object from a
    year and day-of-year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc1 =  LocalDate.parse("2020-02-23");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc1);                     //prints: 2020-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc2 =  LocalDate.parse("23/02/2020", formatter);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc2);                     //prints: 2020-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc3 =  LocalDate.of(2020, 2, 23);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc3);                     //prints: 2020-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc4 =  LocalDate.of(2020, Month.FEBRUARY, 23);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc4);                     //prints: 2020-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc5 = LocalDate.ofYearDay(2020, 54);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5);                     //prints: 2020-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `LocalDate` object, you can get various values:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.getYear());          //prints: 2020'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.getMonth());         //prints: FEBRUARY'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.getMonthValue());    //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.getDayOfMonth());    //prints: 23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.getDayOfWeek());     //prints: SUNDAY'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.isLeapYear());       //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.lengthOfMonth());    //prints: 29'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.lengthOfYear());     //prints: 366'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalDate` object can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.withYear(2021));     //prints: 2021-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.withMonth(5));       //prints: 2020-05-23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.withDayOfMonth(5));  //prints: 2020-02-05'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.withDayOfYear(53));  //prints: 2020-02-22'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.plusDays(10));       //prints: 2020-03-04'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.plusMonths(2));      //prints: 2020-04-23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.plusYears(2));       //prints: 2022-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.minusDays(10));      //prints: 2020-02-13'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.minusMonths(2));     //prints: 2019-12-23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc5.minusYears(2));      //prints: 2018-02-23'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalDate` objects can be compared:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc6 =  LocalDate.parse("2020-02-22");
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate lc7 =  LocalDate.parse("2020-02-23");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc6.isAfter(lc7));       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lc6.isBefore(lc7));      //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other helpful methods in the `LocalDate` class. If you have to
    work with dates, we recommend that you read the API of this class and other classes
    of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: java.time.LocalTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `LocalTime` contains the time without a date. It has methods similar
    to those of the class `LocalDate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how an object of the `LocalTime` class can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(LocalTime.now());         //prints: 21:15:46.360904'
  prefs: []
  type: TYPE_NORMAL
- en: ZoneId zoneId = ZoneId.of("Asia/Tokyo");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(LocalTime.now(zoneId));   //prints: 12:15:46.364378'
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt1 =  LocalTime.parse("20:23:12");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt1);                     //prints: 20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt2 =  LocalTime.of(20, 23, 12);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2);                     //prints: 20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each component of the time value can be extracted from a `LocalTime` object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.getHour());          //prints: 20'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.getMinute());        //prints: 23'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.getSecond());        //prints: 12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.getNano());          //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The object can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.withHour(3));        //prints: 03:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.withMinute(10));     //prints: 20:10:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.withSecond(15));     //prints: 20:23:15'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.withNano(300));      //prints: 20:23:12:000000300'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.plusHours(10));      //prints: 06:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.plusMinutes(2));     //prints: 20:25:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.plusSeconds(2));     //prints: 20:23:14'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.plusNanos(200));     //prints: 20:23:14:000000200'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.minusHours(10));      //prints: 10:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.minusMinutes(2));     //prints: 20:21:12'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.minusSeconds(2));     //prints: 20:23:10'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt2.minusNanos(200));     //prints: 20:23:11.999999800'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And two objects of the `LocalTime` class can be compared as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt3 =  LocalTime.parse("20:23:12");
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt4 =  LocalTime.parse("20:25:12");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt3.isAfter(lt4));       //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(lt3.isBefore(lt4));      //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other helpful methods in the `LocalTime` class. If you have to
    work with time, we recommend you read the API of this class and other classes
    of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: java.time.LocalDateTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class `LocalDateTime` contains both date and time, and has all the methods
    the classes `LocalDate` and `LocalTime` have, so we are not going to repeat them
    here. We will only show how an object of `LocalDateTime` can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(LocalDateTime.now());  //2018-04-14T21:59:00.142804
  prefs: []
  type: TYPE_NORMAL
- en: ZoneId zoneId = ZoneId.of("Asia/Tokyo");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(LocalDateTime.now(zoneId));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: 2018-04-15T12:59:00.146038'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt1 =  LocalDateTime.parse("2020-02-23T20:23:12");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt1);                 //prints: 2020-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: DateTimeFormatter formatter =
  prefs: []
  type: TYPE_NORMAL
- en: DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt2 =
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime.parse("23/02/2020 20:23:12", formatter);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt2);                 //prints: 2020-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt3 = LocalDateTime.of(2020, 2, 23, 20, 23, 12);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt3);                 //prints: 2020-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt4 =
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime.of(2020, Month.FEBRUARY, 23, 20, 23, 12);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt4);                     //prints: 2020-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate ld = LocalDate.of(2020, 2, 23);
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt =  LocalTime.of(20, 23, 12);
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt5 = LocalDateTime.of(ld, lt);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt5);                     //prints: 2020-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other helpful methods in the `LocalDateTime` class. If you have
    to work with date and time, we recommend you read the API of this class and other
    classes of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: Period and Duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classes `java.time.Period` and `java.time.Duration` are designed to contain
    an amount of time:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Period` object contains an amount of time in units of years, months, and
    days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Duration` object contains an amount of time in hours, minutes, seconds,
    and nanoseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates their creation and use with the class `LocalDateTime`,
    but the same methods exist in the classes `LocalDate` (for `Period`) and `LocalTime` (for `Duration`):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt1 = LocalDateTime.parse("2020-02-23T20:23:12");
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime ldt2 = ldt1.plus(Period.ofYears(2));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(ldt2); //prints: 2022-02-23T20:23:12'
  prefs: []
  type: TYPE_NORMAL
- en: '//The following methods work the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Period.ofYears(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Period.ofMonths(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Period.ofMonths(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Period.ofWeeks(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Period.ofWeeks(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Period.ofDays(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Period.ofDays(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Duration.ofHours(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Duration.ofHours(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Duration.ofMinutes(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Duration.ofMinutes(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.plus(Duration.ofMillis(2));
  prefs: []
  type: TYPE_NORMAL
- en: ldt.minus(Duration.ofMillis(2));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other ways to create and use `Period` objects are demonstrated in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate ld1 =  LocalDate.parse("2020-02-23");
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate ld2 =  LocalDate.parse("2020-03-25");
  prefs: []
  type: TYPE_NORMAL
- en: Period period = Period.between(ld1, ld2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(period.getDays());       //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(period.getMonths());     //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(period.getYears());      //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(period.toTotalMonths()); //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: period = Period.between(ld2, ld1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(period.getDays());       //prints: -2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects of `Duration` can be similarly created and used:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt1 =  LocalTime.parse("10:23:12");
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime lt2 =  LocalTime.parse("20:23:14");
  prefs: []
  type: TYPE_NORMAL
- en: Duration duration = Duration.between(lt1, lt2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.toDays());     //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.toHours());    //prints: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.toMinutes());  //prints: 600'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.toSeconds());  //prints: 36002'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.getSeconds()); //prints: 36002'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.toNanos());    //prints: 36002000000000'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(duration.getNano());    //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other helpful methods in the classes `Period` and `Duration`.
    If you have to work with the amount of time, we recommend you read the API of
    these classes and other classes of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: Managing random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating a truly random number is a big topic that does not belong to this
    book. But for the vast majority of practical purposes, the pseudo-random number
    generators provided by Java are good enough, and that is what we are going to
    discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two primary ways to generate a random number in Java Standard Library:'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.lang.Math.random()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.util.Random` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the `java.security.SecureRandom` class, which provides a cryptographically
    strong random number generator, but it is outside the scope of an introductory
    course.
  prefs: []
  type: TYPE_NORMAL
- en: Method java.lang.Math.random()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The static method `double random()` of the class `Math` returns a `double` type
    value greater than or equal to `0.0` and less than `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Math.random());
  prefs: []
  type: TYPE_NORMAL
- en: //0.9350483840148613
  prefs: []
  type: TYPE_NORMAL
- en: //0.0477353019234189
  prefs: []
  type: TYPE_NORMAL
- en: //0.25784245516898985
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We captured the result in the previous comments. But in practice, more often
    than not, a random integer from a certain range is required. To accommodate such
    a need, we can write a method that, for example, produces a random integer number
    from 0 (inclusive) to 10 (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int getInteger(int max){
  prefs: []
  type: TYPE_NORMAL
- en: return (int)(Math.random() * max);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of one run of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(getInteger(10) + " "); //prints: 2 5 6'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it generates a random integer value that can be one of the
    following 10 numbers: 0, 1, ..., 9\. And here is the code that uses the same method
    and produces random integer numbers from 0 (inclusive) to 100 (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(getInteger(100) + " "); //prints: 48 11 97'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And when you need a random number between 100 (inclusive) and 200 (exclusive),
    you can just add 100 to the preceding result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(100 + getInteger(100) + " "); //prints: 114 101 127'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Including both ends of the range in the result can be done by rounding the
    generated `double` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int getIntegerRound(int max){
  prefs: []
  type: TYPE_NORMAL
- en: return (int)Math.round(Math.random() * max);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we used the preceding method, the results were:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(100 + getIntegerRound(100) + " "); //179 147 200
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the upper end of the range (the number 200) is included in
    the possible results set. The same effect can be achieved by just adding 1 to
    the requested upper range:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int getInteger2(int max){
  prefs: []
  type: TYPE_NORMAL
- en: return (int)(Math.random() * (max + 1));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the previous method, we can get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(100 + getInteger2(100) + " "); //167 200 132
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But if you look at the source code of the `Math.random()` method, you will see
    that it uses the `java.util.Random` class and its `nextDouble()` method to generate
    a random double value. So, let's look at how to use the `java.util.Random` class directly.
  prefs: []
  type: TYPE_NORMAL
- en: Class java.util.Random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `doubles()` of the class `Random` generates a `double` type value
    greater than or equal to `0.0` and less than `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Random random = new Random();
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(random.nextDouble() + " ");
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: 0.8774928230544553 0.7822070124559267 0.09401796000707807'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the method `nextDouble()` the same way we used `Math.random()` in
    the previous section. But class have other methods that can be used without creating
    a custom `getInteger()` method when a random integer value of a certain range
    is required. For example, the `nextInt()` method returns an integer value between `Integer.MIN_VALUE` (inclusive)
    and `Integer.MAX_VALUE` (inclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.print(random.nextInt() + " ");
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: -2001537190 -1148252160 1999653777'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the same method with a parameter allows us to limit the range of the returned
    values by the upper limit (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(random.nextInt(11) + " "); //prints: 4 6 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates a random integer value between 0 (inclusive) and 10 (inclusive).
    And the following code returns a random integer value between 11 (inclusive) and
    20 (inclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: for(int i =0; i < 3; i++){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(11 + random.nextInt(10) + " "); //prints: 13 20 15'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to generate a random integer from the range is by using the `IntStream` object
    returned by the method `ints(int count, int min, int max)`, where `count` is the
    number of requested values, `min` is the minimum value (inclusive), and `max` is the
    maximum value (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String result = random.ints(3, 0, 101)
  prefs: []
  type: TYPE_NORMAL
- en: .mapToObj(String::valueOf)
  prefs: []
  type: TYPE_NORMAL
- en: '.collect(Collectors.joining(" ")); //prints: 30 48 52'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This code returns three integer values from 0 (inclusive) to 100 (inclusive).
    We will talk more about streams in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Objects.equals() result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class A{}
  prefs: []
  type: TYPE_NORMAL
- en: public class B{}
  prefs: []
  type: TYPE_NORMAL
- en: public class Exercise {
  prefs: []
  type: TYPE_NORMAL
- en: private A a;
  prefs: []
  type: TYPE_NORMAL
- en: private B b;
  prefs: []
  type: TYPE_NORMAL
- en: public Exercise(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(java.util.Objects.equals(a, b));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args){
  prefs: []
  type: TYPE_NORMAL
- en: new Exercise();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: What is going to be displayed when we run the `main()` method of the `Exercise` class?
    `Error`? `False`? `True`?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The display will show only one value: `True`. The reason is that both private
    fields—`a` and `b`—are initialized to `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the reader to the most popular utilities and
    some other classes from the Java Standard Library and Apache Commons libraries.
    Every Java programmer has to have a solid understanding of their capabilities
    in order to become an effective coder. Studying them also helps to get exposure
    to various software designs pattern and solutions that are instructive and can
    be used as patterns for best coding practices in any application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to demonstrate to the reader how to write
    Java code that can manipulate—insert, read, update, and delete—data in a database.
    It will also provide a short introduction to SQL and basic database operations.
  prefs: []
  type: TYPE_NORMAL

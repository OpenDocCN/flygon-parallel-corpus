- en: Lambda Expressions and Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains the concept of functional programming. It provides an
    overview of the functional interfaces that come with JDK, explains how to use
    them in lambda expressions, and how to write lambda expressions in the most concise
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Using method references for creating a new object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming allows us to treat a block of code (a function) like
    an object, passing it as a parameter or as a return value of a method. This feature
    is present in many programming languages. It does not require us to manage the
    object state. The function is stateless. Its result depends only on the input
    data, no matter how many times it was called. This style makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Without functional programming, the only way to pass a functionality as a parameter
    in Java would be through writing a class that implements an interface, creating
    its object, and then passing it as a parameter. But even the least involved style—using
    the anonymous class—requires writing too much of the boilerplate code. Using functional
    interfaces and lambda expressions makes the code shorter, clearer, and more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Adding it to Java increases parallel programming capabilities by shifting the
    responsibility for parallelism from the client code to the library. Before that,
    in order to process elements of Java collections, the client code had to iterate
    over the collection and organize processing. In Java 8, new (default) methods
    were added that accept a function (the implementation of a functional interface)
    as a parameter and then apply it to each element of the collection in parallel
    or not, depending on the internal processing algorithm. So, it is the library's
    responsibility to organize parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will define and explain these Java features—functional
    interfaces and lambda expressions—and demonstrate their applicability in code
    examples. They make functions the first-class citizens of the language on the
    same level of importance as objects.
  prefs: []
  type: TYPE_NORMAL
- en: What is a functional interface?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In fact, you have already seen elements of functional programming in our demonstration
    code. One example is the `forEach(Consumer consumer)` method, available for every `Iterable`,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate
    predicate)` method, available for every `Collection` object. The passed-in `Predicate` object
    is a function – an implementation of a functional interface. Similarly, the `sort(Comparator
    comparator)` and `replaceAll(UnaryOperator uo)` methods in the `List` interface
    and several `compute()` methods in `Map` are examples of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: A functional interface is an interface that has only one abstract method, including
    those that were inherited from the parent interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help avoid runtime errors, an `@FunctionalInterface` annotation was introduced
    in Java 8 that tells the compiler about the intent, so the compiler can check
    to see whether there is truly only one abstract method in the annotated interface.
    Let''s review the following interfaces of the same line of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs: []
  type: TYPE_NORMAL
- en: interface A {
  prefs: []
  type: TYPE_NORMAL
- en: void method1();
  prefs: []
  type: TYPE_NORMAL
- en: default void method2(){}
  prefs: []
  type: TYPE_NORMAL
- en: static void method3(){}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs: []
  type: TYPE_NORMAL
- en: interface B extends A {
  prefs: []
  type: TYPE_NORMAL
- en: default void method4(){}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs: []
  type: TYPE_NORMAL
- en: interface C extends B {
  prefs: []
  type: TYPE_NORMAL
- en: void method1();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //@FunctionalInterface  //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: interface D extends C {
  prefs: []
  type: TYPE_NORMAL
- en: void method5();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Interface `A` is a functional interface because it has only one abstract method: `method1()`.
    Interface `B` is also a functional interface because it has only one abstract
    method too – the same `method1()` inherited from interface `A`. Interface `C`
    is a functional interface because it has only one abstract method, `method1()`,
    which overrides the abstract `method1()` method of the parent interface `A`. Interface
    `D` cannot be a functional interface because it has two abstract methods – `method1()`,
    from the parent interface `A`, and `method5()`.
  prefs: []
  type: TYPE_NORMAL
- en: When the `@FunctionalInterface` annotation is used, it tells the compiler to
    check on the presence of only one abstract method, and it warns the programmer,
    who reads the code, that this interface has only one abstract method intentionally.
    Otherwise, the programmer may waste time enhancing the interface only to discover
    later that it cannot be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, the `Runnable` and `Callable` interfaces that existed
    in Java since its early versions were annotated in Java 8 as `@FunctionalInterface`.
    It makes this distinction explicit and serves as a reminder to its users and to
    those who might attempt to add another abstract method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs: []
  type: TYPE_NORMAL
- en: interface Runnable {
  prefs: []
  type: TYPE_NORMAL
- en: void run();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@FunctionalInterface'
  prefs: []
  type: TYPE_NORMAL
- en: interface Callable<V> {
  prefs: []
  type: TYPE_NORMAL
- en: V call() throws Exception;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, creating a functional interface is easy. But before doing that,
    consider using one of the 43 functional interfaces provided in the `java.util.function` package.
  prefs: []
  type: TYPE_NORMAL
- en: Ready-to-use standard functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the interfaces provided in the `java.util.function` package are specializations
    of the following four interfaces: `Function`, `Consumer`, `Supplier`, and `Predicate`.
    Let''s review them and then have a short overview of the rest of the 39 standard
    functional interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Function<T, R>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notation of this and other functional `<indexentry content="standard functional
    interfaces:function">` interfaces includes listing of the types of the input data
    (`T`) and the returned data (`R`). So, `Function<T, R>` means that the only abstract
    method of this interface accepts an argument of type `T` and produces a result
    of type `R`. You can find the name of that abstract method by reading the online
    documentation. In the case of the `Function<T, R>` interface, its method is `R
    apply(T)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning all that, we can create an implementation of this interface
    using an anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByTen = new Function<Integer, Double>(){
  prefs: []
  type: TYPE_NORMAL
- en: public Double apply(Integer i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * 10.0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is up to the programmer to decide which actual type will be `T` (the input
    parameter) and which type will be `R` (the returned value). In our example, we
    have decided that the input parameters will be of the `Integer` type and the result
    will be of the `Double` type. As you have probably realized by now, the types
    can be reference types only, and the boxing and unboxing of primitive types is
    performed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our new `Function<Integer, Double> multiplyByTen` function any
    way we need. We can just use it directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(multiplyByTen.apply(1)); //prints: 10.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can create a method that accepts this function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void useFunc(Function<Integer, Double> processingFunc, int input){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(processingFunc.apply(input));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then pass our function into this method and let the method use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'useFunc(multiplyByTen, 10);     //prints: 100.00'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a method that will generate a function whenever we need
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> createMultiplyBy(double num){
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> func = new Function<Integer, Double>(){
  prefs: []
  type: TYPE_NORMAL
- en: public Double apply(Integer i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * num;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding method, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(multiplyByFive.apply(1)); //prints: 5.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'useFunc(multiplyByFive, 10);                 //prints: 50.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce lambda expressions and will show how
    they can be used to express the functional interface implementation with much
    less code.
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By looking at the `Consumer<T>` interface definition, you can already guess
    that this interface has an abstract method that accepts a parameter of the `T`
    type <indexentry content="standard functional interfaces:Consumer">and does not
    return anything. From the documentation of the `Consumer<T>` interface, we learn
    that its abstract method is `void accept(T)`, which means that, for example, we
    can implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = new Consumer<Double>() {
  prefs: []
  type: TYPE_NORMAL
- en: public void accept(Double d) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Result=" + d);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'printResult.accept(10.0);         //prints: Result=10.0'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can create a method that will generate the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> func = new Consumer<Double>() {
  prefs: []
  type: TYPE_NORMAL
- en: public void accept(Double d) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(prefix + d + postfix);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: 'printResult.accept(10.0);    //prints: Result=10.0 Great!'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a new method that not only accepts a processing function
    as a parameter but also a printing function too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void processAndConsume(int input,
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> processingFunc,
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> consumer){
  prefs: []
  type: TYPE_NORMAL
- en: consumer.accept(processingFunc.apply(input));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: processAndConsume(10, multiplyByFive, printResult); //Result=50.0 Great!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned before, in the next section, we will introduce lambda expressions
    and will show how they can be used to express the functional interface implementation
    with much less code.
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a trick question: guess the input and the output types of the abstract
    method of the `Supplier<T>` interface. The answer is: it accepts no parameters
    and returns the `T` type. As you understand now, the difference is in the name
    of the interface itself. It should give you a hint: the consumer just consumes
    and returns nothing, while the supplier just supplies without any input. The abstract
    method of the `Supplier<T>` interface is `T get()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous functions, we can write the supplier generating method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> createSuppplier(int num){
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> func = new Supplier<Integer>() {
  prefs: []
  type: TYPE_NORMAL
- en: public Integer get() { return num; }
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write a method that accepts only functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void supplyProcessAndConsume(Supplier<Integer> input,
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> process,
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> consume){
  prefs: []
  type: TYPE_NORMAL
- en: consume.accept(processFunc.apply(input.get()));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the output type of the `input` function is the same as the input
    of the `process` function, which returns the same type as consumed by the `consume` function.
    It makes the following code possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> supply7 = createSuppplier(7);
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: supplyProcessAndConsume(supply7, multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Result=35.0 Great!'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we hope, you start to appreciate the value functional programming
    brings to the table. It allows us to pass around chunks of functionality that
    can be plugged into the middle of an algorithm without needing to create an object.
    Static methods do not require creating an object either, but they are shared by
    all application threads because they are unique in the JVM. Meanwhile, each function
    is an object and can be either unique in the JVM (if assigned to a static variable)
    or created for each processing thread (which typically is the case). It has very
    little coding overhead and can have even less plumbing when used in a lambda expression
    – the topic of our next section.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have demonstrated how a function can be plugged into the existing
    control-flow expression. And now we will describe the last missing piece – a function
    that represents the decision-making construct that can be passed around as an
    object too.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an interface that represents a Boolean-valued function that has a single
    method: `boolean test(T)`. Here is an example of a method that creates a `Predicate<Integer>`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> createTestSmallerThan(int num){
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> func = new Predicate<Integer>() {
  prefs: []
  type: TYPE_NORMAL
- en: public boolean test(Integer d) {
  prefs: []
  type: TYPE_NORMAL
- en: return d < num;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it to add some logic to the processing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void supplyDecideProcessAndConsume(Supplier<Integer> input,
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test,
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> process,
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> consume){
  prefs: []
  type: TYPE_NORMAL
- en: int in = input.get();
  prefs: []
  type: TYPE_NORMAL
- en: if(test.test(in)){
  prefs: []
  type: TYPE_NORMAL
- en: consume.accept(process.apply(in));
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Input " + in +
  prefs: []
  type: TYPE_NORMAL
- en: '" does not pass the test and not processed.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the following code demonstrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = createSuppplier(7);
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test = createTestSmallerThan(5);
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Input 7 does not pass the test and not processed.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the input to 3, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = createSuppplier(3)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code would result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Result=15.0 Great!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Other standard functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other 39 functional interfaces in the `java.util.function` package are
    variations of the four interfaces we have just reviewed. These variations are
    created in order to achieve one or any combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Better performance by avoiding autoboxing and unboxing via the explicit usage
    of the integer, double, or long primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing two input parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shorter notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are just a few of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IntFunction<R>` with the `R apply(int)` method provides shorter notation (without
    generics for the input parameter type) and avoids autoboxing by requiring the `int` primitive
    as the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiFunction<T,U,R>` with the `R apply(T,U)` method allows two input parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BinaryOperator<T>` with the `T apply(T,T)` method allows two input parameters
    of the `T` type and returns a value of the same `T` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntBinaryOperator` with the `int applAsInt(int,int)` method accepts two parameters
    of the `int` type and returns the value of the `int` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are going to use functional interfaces, we encourage you to study the
    API of the interfaces of the `java.util.functional` package.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining standard functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the functional interfaces in the `java.util.function` package have default
    methods that allow us to build a chain (also called a pipe or pipeline) of functions
    that pass the result of one as the input parameter to another, thus composing
    a new complex function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, Long> f1 = d -> Double.valueOf(d / 2.).longValue();
  prefs: []
  type: TYPE_NORMAL
- en: 'Function<Long, String> f2 = l -> "Result: " + (l + 1);'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, String> f3 = f1.andThen(f2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(f3.apply(4.));            //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding code, we have created a new `f3` function
    by combining the `f1` and `f2` functions using the `andThen()` method. That's
    the idea behind the methods we are going to explore in this section. First, we
    express the functions as anonymous classes and, in the following section, we introduce
    the lambda expressions that we used in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Chain two Function<T,R>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `andThen(Function after)` default method of the `Function` interface.
    We have already created the `Function<Integer, Double> createMultiplyBy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> createMultiplyBy(double num){
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> func = new Function<Integer, Double>(){
  prefs: []
  type: TYPE_NORMAL
- en: public Double apply(Integer i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * num;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write another method that creates a subtracting function with the `Double` input
    type, so we can chain it to the multiplying function:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private static Function<Double, Long> createSubtractInt(int num){
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, Long> func = new Function<Double, Long>(){
  prefs: []
  type: TYPE_NORMAL
- en: public Long apply(Double dbl){
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(dbl - num);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(multiplyByFive.apply(2));  //prints: 10.0'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, Long> subtract7 = createSubtractInt(7);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(subtract7.apply(11.0));   //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: long r = multiplyByFive.andThen(subtract7).apply(2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);                          //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `multiplyByFive.andThen(subtract7)` chain acts effectively
    as `Function<Integer, Long> multiplyByFiveAndSubtractSeven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Function` interface has another default method, `Function<V,R> compose(Function<V,T>
    before)`, that also allows us to chain two functions. The function that has to
    be executed first can be passed as the `before` parameter into the `compose()` method
    of the second function:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: boolean r = subtract7.compose(multiplyByFive).apply(2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);                          //prints: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Chain two Consumer<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Consumer` interface has the `andThen(Consumer after)` method too. We have
    already written the method that creates the printing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> func = new Consumer<Double>() {
  prefs: []
  type: TYPE_NORMAL
- en: public void accept(Double d) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(prefix + d + postfix);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we can create and chain two printing functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> print21By = createPrintingFunc("21 by ", "");
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> equalsBy21 = createPrintingFunc("equals ", " by 21");
  prefs: []
  type: TYPE_NORMAL
- en: print21By.andThen(equalsBy21).accept(2d);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: 21 by 2.0'
  prefs: []
  type: TYPE_NORMAL
- en: //        equals 2.0 by 21
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the `Consumer` chain, both functions consume the same value
    in the sequence defined by the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Chain two Predicate<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Supplier` interface does not have default methods, while the `Predicate` interface
    has one static method, `isEqual(Object targetRef)`, and three default methods:
    `and(Predicate other)`, `negate()`, and `or(Predicate other)`. To demonstrate
    usage of the `and(Predicate other)` and `or(Predicate other)` methods, for example,
    let''s write the methods that create two `Predicate<Double>` functions. One function
    checks whether the value is smaller than the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> testSmallerThan(double limit){
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> func = new Predicate<Double>() {
  prefs: []
  type: TYPE_NORMAL
- en: public boolean test(Double num) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Test if " + num + " is smaller than " + limit);
  prefs: []
  type: TYPE_NORMAL
- en: return num < limit;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function checks whether the value is bigger than the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> testBiggerThan(double limit){
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> func = new Predicate<Double>() {
  prefs: []
  type: TYPE_NORMAL
- en: public boolean test(Double num) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Test if " + num + " is bigger than " + limit);
  prefs: []
  type: TYPE_NORMAL
- en: return num > limit;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create two `Predicate<Double>` functions and chain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> isSmallerThan20 = testSmallerThan(20d);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(isSmallerThan20.test(10d));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Test if 10.0 is smaller than 20.0'
  prefs: []
  type: TYPE_NORMAL
- en: //        true
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Double> isBiggerThan18 = testBiggerThan(18d);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(isBiggerThan18.test(10d));
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Test if 10.0 is bigger than 18.0'
  prefs: []
  type: TYPE_NORMAL
- en: //        false
  prefs: []
  type: TYPE_NORMAL
- en: boolean b = isSmallerThan20.and(isBiggerThan18).test(10.);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Test if 10.0 is smaller than 20.0'
  prefs: []
  type: TYPE_NORMAL
- en: //        Test if 10.0 is bigger than 18.0
  prefs: []
  type: TYPE_NORMAL
- en: //        false
  prefs: []
  type: TYPE_NORMAL
- en: b = isSmallerThan20.or(isBiggerThan18).test(10.);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(b);
  prefs: []
  type: TYPE_NORMAL
- en: '//prints: Test if 10.0 is smaller than 20.0'
  prefs: []
  type: TYPE_NORMAL
- en: //        true
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `and()` method required execution of each of the functions,
    while the `or()` method did not execute the second function as soon as the first
    one in the chain returned `true`.
  prefs: []
  type: TYPE_NORMAL
- en: identity() and other default methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional interfaces of the `java.util.function` package have other helpful
    default methods. The one that stands out is the `identity()` method, which returns
    a function that always returns its input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Integer> id = Function.identity();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(id.apply(4));          //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `identity()` method is very helpful when some procedure requires providing
    a certain function, but you do not want the provided function to change anything.
    In such cases, you create an identity function with the necessary output type.
    For example, in one of our previous code snippets, we may decide that the `multiplyByFive`
    function should not change anything in the `multiplyByFive.andThen(subtract7)`
    chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, Double> multiplyByFive = Function.identity();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(multiplyByFive.apply(2.));  //prints: 2.0'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Double, Long> subtract7 = createSubtractInt(7);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(subtract7.apply(11.0));    //prints: 4'
  prefs: []
  type: TYPE_NORMAL
- en: long r = multiplyByFive.andThen(subtract7).apply(2.);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(r);                       //prints: -5'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the  `multiplyByFive` function did not do anything with the
    input parameter `2`, so the result (after `7` was subtracted) is `-5`.
  prefs: []
  type: TYPE_NORMAL
- en: Other default methods are mostly related to conversion and boxing and unboxing,
    but also extracting minimum and maximum values of two parameters. If you are interested,
    you can look through the API of interfaces of the `java.util.function` package
    and get a feeling for the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples in the previous section (that used anonymous classes for the implementation
    of functional interfaces) looked bulky and felt excessively verbose. For one,
    there was no need to repeat the interface name, because we had declared it already
    as the type for the object reference. And, second, in the case of a functional
    interface that had only one abstract method, there is no need to specify the method
    name that has to be implemented. The compiler and Java runtime can figure it out.
    All we need is to provide the new functionality. Lambda expressions were introduced
    for exactly this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: What is a lambda expression?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term lambda comes from lambda calculus—a universal model of computation
    that can be used to simulate any Turing machine. It was introduced by mathematician,
    Alonzo Church, in the 1930s. A lambda expression is a function, implemented in
    Java as an anonymous method, that also allows us to omit modifiers, return types,
    and parameter types. That makes for a very compact notation.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of a lambda expression includes the list of parameters, an arrow
    token `->`, and a body. The list of parameters can be empty `()`, without brackets
    (if there is only one parameter), or a comma-separated list of parameters surrounded
    by brackets. The body can be a single expression or a statement block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`() -> 42;` always returns `42`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -> x + 1;` increments the `x` variable by `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(x, y) -> x * y;` multiplies `x` by `y` and returns the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(char x) -> x == ''$'';` compares the value of the `x` variable and the `$` symbol,
    and returns a Boolean value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x -> {  System.out.println("x=" + x); };` prints the `x` value with the `x=` prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-implementing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can rewrite our functions, created in the previous section, using lambda
    expressions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> createMultiplyBy(double num){
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> func = i -> i * num;
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> func = d -> System.out.println(prefix + d + postfix);
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> createSuppplier(int num){
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> func = () -> num;
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> createTestSmallerThan(int num){
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> func = d -> d < num;
  prefs: []
  type: TYPE_NORMAL
- en: return func;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We don't repeat the name of the implemented interface because it is specified
    as the return type in the method signature. And we do not specify the name of
    the abstract method either because it is the only method of the interface that
    has to be implemented. Writing such a compact and efficient code became possible
    because of the combination of the lambda expression and functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding examples, you probably realize that there is no need
    to have methods that create a function anymore. Let''s change the code that calls
    the `supplyDecideProcessAndConsume()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void supplyDecideProcessAndConsume(Supplier<Integer> input,
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test,
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> process,
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> consume){
  prefs: []
  type: TYPE_NORMAL
- en: int in = input.get();
  prefs: []
  type: TYPE_NORMAL
- en: if(test.test(in)){
  prefs: []
  type: TYPE_NORMAL
- en: consume.accept(process.apply(in));
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Input " + in +
  prefs: []
  type: TYPE_NORMAL
- en: '" does not pass the test and not processed.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = createSuppplier(7);
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test = createTestSmallerThan(5);
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the preceding code to the following without changing the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = () -> 7;
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test = d -> d < 5.;
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = i -> i * 5.;;
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult =
  prefs: []
  type: TYPE_NORMAL
- en: d -> System.out.println("Result=" + d + " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even inline the preceding functions and write the preceding code in
    one line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
  prefs: []
  type: TYPE_NORMAL
- en: d -> System.out.println("Result=" + d + " Great!"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how much more transparent the definition of the printing function has
    become. That is the power and the beauty of lambda expressions in combination
    with functional interfaces. In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*, you will see that lambda expressions are, in fact, the
    only way to process streamed data.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two aspects of a lambda expression that we would like to point out
    and clarify, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: If a lambda expression uses a local variable created outside it, this local
    variable has to be final or effectively final (not re-assigned in the same context)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword in a lambda expression refers to the enclosing context, and
    not the lambda expression itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively final local variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the anonymous class, the variable, created outside and used inside the
    lambda expression, becomes effectively final and cannot be modified. You can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int x = 7;
  prefs: []
  type: TYPE_NORMAL
- en: //x = 3;       //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: int y = 5;
  prefs: []
  type: TYPE_NORMAL
- en: double z = 5.;
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(() -> x, d -> d < y, i -> i * z,
  prefs: []
  type: TYPE_NORMAL
- en: d -> { //x = 3;      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Result=" + d + " Great!"); } );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But, as you can see, we cannot change the value of the local variable used in
    the lambda expression. The reason for this restriction is that a function can
    be passed around and executed in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would defeat the original idea of
    the stateless function and independent distributed evaluation of the expression.
    That is why all the local variables used in the lambda expression are effectively
    final, meaning that they can either be declared final explicitly or become final
    by virtue of their usage in a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one possible workaround for this limitation. If the local variable
    is of a reference type (but not `String` or a primitive wrapping type), it is
    possible to change its state even if this local variable is used in the lambda
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: private int x;
  prefs: []
  type: TYPE_NORMAL
- en: public int getX(){ return this.x; }
  prefs: []
  type: TYPE_NORMAL
- en: public void setX(int x){ this.x = x; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void localVariable2(){
  prefs: []
  type: TYPE_NORMAL
- en: A a = new A();
  prefs: []
  type: TYPE_NORMAL
- en: a.setX(7);
  prefs: []
  type: TYPE_NORMAL
- en: a.setX(3);
  prefs: []
  type: TYPE_NORMAL
- en: int y = 5;
  prefs: []
  type: TYPE_NORMAL
- en: double z = 5.;
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(() -> a.getX(), d -> d < y, i -> i * z,
  prefs: []
  type: TYPE_NORMAL
- en: d -> { a.setX(5);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Result=" + d + " Great!"); } );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But this workaround should be used only when really needed and has to be done
    with care because of the danger of unexpected side effects.
  prefs: []
  type: TYPE_NORMAL
- en: The this keyword interpretation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One principal difference between the anonymous class and lambda expressions
    is the interpretation of the `this` keyword. Inside an anonymous class, it refers
    to the instance of the anonymous class. Inside a lambda expression, `this` refers
    to the instance of the class that surrounds the expression, also called an *enclosing
    instance*, *enclosing context*, or *enclosing scope*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `ThisDemo` class that illustrates the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class ThisDemo {
  prefs: []
  type: TYPE_NORMAL
- en: private String field = "ThisDemo.field";
  prefs: []
  type: TYPE_NORMAL
- en: public void useAnonymousClass() {
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<String> consumer = new Consumer<>() {
  prefs: []
  type: TYPE_NORMAL
- en: private String field = "AnonymousClassConsumer.field";
  prefs: []
  type: TYPE_NORMAL
- en: public void accept(String s) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(this.field);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: consumer.accept(this.field);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void useLambdaExpression() {
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<String> consumer = consumer = s -> {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(this.field);
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: consumer.accept(this.field);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `this` inside the anonymous class refers to the anonymous class
    instance, while `this` in the lambda expression refers to the enclosing class
    instance. Lambda expressions just do not have and cannot have a field. If we execute
    the preceding methods, the output confirms our assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ThisDemo d = new ThisDemo();
  prefs: []
  type: TYPE_NORMAL
- en: 'd.useAnonymousClass();   //prints: AnonymousClassConsumer.field'
  prefs: []
  type: TYPE_NORMAL
- en: 'd.useLambdaExpression(); //prints: ThisDemo.field'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda expression is not a class instance and cannot be referred to by `this`.
    According to Java Specification, such an approach *allows more flexibility for
    implementations* by *treating [this] the same as in the surrounding context.*
  prefs: []
  type: TYPE_NORMAL
- en: Method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at our last implementation of the call to the `supplyDecidePprocessAndConsume()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
  prefs: []
  type: TYPE_NORMAL
- en: d -> System.out.println("Result=" + d + " Great!"));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions we have used are pretty trivial. In real-life code, each of them
    may require a multiple-line implementation. In such a case, to put a code block
    inline would make the code almost unreadable. In such cases, referring to the
    methods with the necessary implementation helps. Let''s assume we have the following `Helper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Helper {
  prefs: []
  type: TYPE_NORMAL
- en: public double calculateResult(int i){
  prefs: []
  type: TYPE_NORMAL
- en: // Maybe many lines of code here
  prefs: []
  type: TYPE_NORMAL
- en: return i* 5;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void printResult(double d){
  prefs: []
  type: TYPE_NORMAL
- en: // Maybe many lines of code here
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Result=" + d + " Great!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda expressions in the `Lambdas` class may refer to the methods of the
    `Helper` and `Lambdas` classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Lambdas {
  prefs: []
  type: TYPE_NORMAL
- en: public void methodReference() {
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = () -> generateInput();
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test = d -> checkValue(d);
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive =
  prefs: []
  type: TYPE_NORMAL
- en: i -> new Helper().calculateResult(i);
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = d -> Helper.printResult(d);
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(input, test,
  prefs: []
  type: TYPE_NORMAL
- en: multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private int generateInput(){
  prefs: []
  type: TYPE_NORMAL
- en: // Maybe many lines of code here
  prefs: []
  type: TYPE_NORMAL
- en: return 7;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private static boolean checkValue(double d){
  prefs: []
  type: TYPE_NORMAL
- en: // Maybe many lines of code here
  prefs: []
  type: TYPE_NORMAL
- en: return d < 5;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code reads better already, and the functions may be inlined again:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(() -> generateInput(), d -> checkValue(d),
  prefs: []
  type: TYPE_NORMAL
- en: i -> new Helper().calculateResult(i), Helper.printResult(d));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But in such cases, the notation can be made even more compact. When a one-line
    lambda expression consists of a reference to an existing method, it is possible
    to further simplify the notation by using a method reference without listing the
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found,
    and the two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the method reference, the preceding code under `methodReference()` method
    in the `Lambdas` class can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<Integer> input = this::generateInput;
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<Integer> test = Lambdas::checkValue;
  prefs: []
  type: TYPE_NORMAL
- en: Function<Integer, Double> multiplyByFive = new Helper()::calculateResult;;
  prefs: []
  type: TYPE_NORMAL
- en: Consumer<Double> printResult = Helper::printResult;
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To inline such functions makes even more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: supplyDecideProcessAndConsume(this::generateInput, Lambdas::checkValue,
  prefs: []
  type: TYPE_NORMAL
- en: new Helper()::calculateResult, Helper::printResult);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed that we have intentionally used different locations
    and two instance methods and two static methods in order to demonstrate the variety
    of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: If it feels like too much to remember, the good news is that a modern IDE (IntelliJ
    IDEA is one example) can do it for you and convert the code you are writing into
    the most compact form.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Using the method reference to create a new object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the method reference to express creating a new object. Let''s assume that
    we have `class A{}`. Replace the following `Supplier` function declaration with
    another one that uses the method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<A> supplier = () -> new A();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The answer is:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Supplier<A> supplier = A::new;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of functional programming. It provided an
    overview of the functional interfaces that come with JDK and demonstrated how
    to use them. It also discussed and demonstrated lambda expressions and how effectively
    they can improve code readability.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will make the reader familiar with the powerful concept of
    datastreams processing. It explains what streams are, how to create them and process
    their elements, and how to build processing pipelines. It also shows how easily
    you can organize stream processing in parallel.
  prefs: []
  type: TYPE_NORMAL

- en: Analyzing and Exploiting Firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining firmware analysis methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing file system contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating firmware for dynamic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with ARM and MIPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting MIPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered the basics of what an IoT ecosystem consists of and
    identifying threats with their respective risks via threat modeling to assist
    with our testing. Some vulnerabilities and threats may be simpler to identify
    purely through reconnaissance of the technology in use. In this chapter, we will
    focus our efforts purely on reverse engineering firmware to analyze its contents
    for manipulation during its runtime. We will roll up our sleeves, so to speak,
    and discuss how to disassemble firmware, how to analyze firmware contents, its
    architecture, using common firmware tools, and how to modify firmware for malicious
    purposes. Similar to other software reverse engineering methodologies, analyzing
    firmware is definitely an art in itself. You will learn that a number of tools
    will assist us in looking for common flaws; however, analyzing the security of
    a firmware binary image is very much a manual process.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin analyzing firmware, it is important to discuss the general methodology
    of obtaining firmware as well as frame what pieces of data are important to us.
    This step may have been completed in a light threat model exercise of the firmware
    beforehand but let us begin with discussing the goals of firmware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Defining firmware analysis methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firmware is the center of controlling IoT devices, which is why we may want
    to start analyzing its contents before other pieces of the device''s components.
    Depending on the industry your IoT device is manufactured for, obtaining a firmware
    image and disassembling its contents may be trivial. Similarly, some industry
    verticals require certain safeguards that may make reverse engineering more difficult
    and/or time-consuming. Nevertheless, there are common patterns we will look for
    when analyzing firmware. Usually, the most common goals of an assessor will be
    to locate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API endpoints (URLs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdoor accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How data is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the following recipes, we will have the same goals when analyzing
    firmware. This recipe will show you the overview methodology of firmware analysis
    and reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the basic methodologies for analyzing IoT firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining firmware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing firmware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting the filesystem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mounting filesystems
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing filesystem contents
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Emulating firmware for dynamic analysis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start reviewing firmware contents, we first have to get hold of
    a firmware binary file. This section goes through the various techniques in which
    firmware can be obtained for a given target.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For obtaining firmware, there are some tools we will need to install. We will
    be using Kali Linux which has most of the tools we need installed by default.
    Here are the tools you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kali Linux**: Kali Linux is available for download via their site at [https://www.kali.org/downloads/](https://www.kali.org/downloads/).
    It is recommended to use the Kali virtual images if you use VMware or VirtualBox,
    which can be found here [https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ettercap**: Although Kali Linux has Ettercap installed by default, it is
    also available for download via [https://ettercap.github.io/ettercap/downloads.html](https://ettercap.github.io/ettercap/downloads.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wireshark**: Wireshark is included in Kali Linux by default and is also available
    for download at [http://www.wireshark.org](http://www.wireshark.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSLstrip**: SSLstrip is included in Kali Linux by default and is also available
    for download at [https://github.com/moxie0/sslstrip](https://github.com/moxie0/sslstrip).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flashrom**: Flashrom is not included in Kali Linux by default but we can
    easily install the tool using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, flashrom is available for download via [https://www.flashrom.org/Downloads](https://www.flashrom.org/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several methods to obtain firmware from an IoT device. We will cover
    most of the methods in this recipe. Firmware images can be obtained via the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from the vendor's website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxying or mirroring traffic during device updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dumping firmware directly from the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Googling/researching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompiling associated mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading from the vendor's website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to obtain firmware is via the vendor's website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots demonstrate how to obtain a firmware image off of
    a vendor website:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the target vendor's website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the target device in the search bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8a1430a-7e62-47b7-a30b-9d64f284e2e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Support tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9b1b1f4-23c2-4e87-998e-3263c68bcdd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Drivers & Tools button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41c21cf6-3d0f-46d2-b3e7-71c04db66105.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the download link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a9845e4-2f91-4372-94a7-eec51b7943ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optionally, you can choose to copy the link address to download the file on
    your test machine via `wget` (`wget <http://URL.com>`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a7ed2cc-206e-4bc7-a1a7-a768cd7ef365.png)'
  prefs: []
  type: TYPE_IMG
- en: Proxying or mirroring traffic during device updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes acquiring firmware via a vendor's site may not be an option and you
    will have to perform step 2, proxying traffic during device updates, or step 3,
    dumping the firmware directly from the device itself. In order to proxy traffic
    during device updates, you must be **man-in-the-middle** (**MITM**) or mirror
    the device traffic during an update function. Alternatively, the web or mobile
    application can also be proxied in order to grab the URL for the firmware download.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have to adjust the user-agent header as well since vendors have been
    known to verify this value for firmware downloads. The following are the basic
    steps that can be taken to perform MITM on a device to monitor traffic using Kali
    Linux, Ettercap, Wireshark, and SSLstrip. Kali Linux has all the required tools
    needed for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods and tools that can be utilized to MITM traffic to
    and from the target device. The example below is just one way to accomplishing
    capturing device traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable IP forwarding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure `iptables` to redirect traffic from destination port `80` to port
    `1000`, which is what SSLstrip listens on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Start SSLstrip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Start up Ettercap GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows our current steps taken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a034a581-0b20-4757-9824-da8e98af6627.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Sniff menu and the Unified sniffing... option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2295f7bb-cae1-4183-9d73-3def839532ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ffb4360-b7b8-42f8-832b-2ac0de78881d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Scan for hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91334e90-83ed-4478-8014-1e2c80c38cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open up Wireshark to view traffic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/487ff5b0-8f22-4b5f-b5b4-180f64ec9a53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start capturing traffic from the target device by clicking on Start capturing
    packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52da8dfb-c021-4fc6-b4d6-4e9c40c5e0eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Filter traffic as needed; in this case, `192.168.1.137` is the target device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6338392-0cc3-45b8-a202-718f5e13ccc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Dumping firmware directly from the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we cannot obtain firmware via the vendor site or proxying its traffic, we
    can start dumping the device firmware via UART, SPI, or JTAG. Dumping firmware
    directly requires access to a device and disassembling the device to find its
    flash storage. Once the flash storage chip is located, you can either connect
    your UART pins directly or use an 8-pin SOIC chip-clip to dump the firmware using
    flashrom and an SPI-enabled hardware board such as a Shikra. The following is
    how an SOIC clip and a Shikra would be connected to a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/2da9bdbd-c7ca-41fb-85d3-399a2e8e2ecf.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image Source: [http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562](http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command used to dump firmware contents to a bin file would look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we have acquired a device's firmware using flashrom or any of the previous
    methods described, we now have to analyze the firmware binary file.
  prefs: []
  type: TYPE_NORMAL
- en: Googling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we cannot acquire a firmware image via the previous listed methods for some
    reason, our last option is turning to Google. This may not be our last option
    if we want to rely on someone else's work or check whether our device has been
    researched before. There is also a possibility that a current or ex-employee may
    have uploaded firmware files to their personal repositories or web servers. In
    any case, we can use Google dorking techniques to narrow down our search for our
    given target device. We can also leverage the Google Hacking Database to search
    for firmware or devices via the link [https://www.exploit-db.com/google-hacking-database](https://www.exploit-db.com/google-hacking-database).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we walked through obtaining a firmware image via a vendor's
    website as well as setting up an MITM testbed to capture device traffic, dumping
    firmware directly from the device and Googling as a last resort. Here, I'll break
    down why we obtain firmware via these methods.
  prefs: []
  type: TYPE_NORMAL
- en: When downloading firmware files from vendors, you can typically find what you
    need via their support website, file share, or community forums. Sometimes the
    vendor will require a password in order to download the file or have the firmware
    password protected in a ZIP file. If this is the case, we will more than likely
    skip to the next steps of obtaining firmware in the interest of time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we walked through how to set up a MITM testbed using Kali Linux, SSLstrip,
    Ettercap, and Wireshark to capture device traffic during device updates.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have the firmware with us, the main step now is to analyze the firmware.
    This involves looking inside the firmware and trying to identify as many security
    issues possible, which is what we will be doing in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how to analyze firmware once we have access
    to the firmware binary package. There exist several different techniques in which
    we can look at firmware and identify security issues in it and we will be covering
    how to get started and identifying some common security issues in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, firmware holds many interesting things for a pen tester,
    including API keys, private certificates, hardcoded credentials, backdoors, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To analyze firmware, we will have to reverse engineer it to look at its internal
    components. The internal components of firmware involve things such as bootloader,
    kernel, filesystem, and additional resources. Out of these, we are most interested
    in the filesystem as that is what will hold all the secrets for us. Obviously,
    you could play around with the bootloader and look at what it holds or modify
    it and create new firmware (which we will discuss in the upcoming sections), but
    at this point in time, we will be only concerned with how to reverse engineer
    firmware and extract the filesystem from inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firmware, as we know, is a binary file package and the filesystem is just one
    of the components which could be stored at a specific offset in the binary and
    with a specific size. However, at this point of time we don''t yet know any information
    of the file system inside the firmware, including the offset and size. To find
    these out, we would need to use a tool such as `hexdump` and `grep` for the signatures
    of the various contents we are looking for. The following is an example of the
    Squashfs filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to look for the Squashfs filesystem, we can `grep` the `hexdump`
    output for `shsq` (which is the magic byte for any Squashfs filesystem) in reverse
    order as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a691594b-1525-4a6e-8ee1-9f123fe6f293.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we are able to identify that the Squashfs filesystem begins
    from the address `0x000e20c0`. Once we have this information, we can use the `dd`
    utility to dump contents starting from this location till the end, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22a1830b-2db7-4e45-a0b2-173203883026.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the Squashfs content carved out from the firmware binary, we can
    then simply run a utility such as `unsquashfs` to look at the entire filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and run `unsquashfs` and see if we can look at the entire filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/231b08e9-cd93-4731-b035-9215369f9e13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, we are able to extract the Squashfs
    filesystem image. Ignore the warnings and errors in the above image as it''s simply
    complaining about us not running the command as a root user. Once we have extracted
    it, we can navigate to the various directories and look at individual files in
    order to identify vulnerabilities. The following is a screenshot of how the entire
    filesystem looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f5d8de3-ba20-43e7-82a6-4fe6735ac1e3.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we reverse engineer firmware and extract the filesystem from the
    firmware binary image. We can also perform all of the steps mentioned earlier
    automatically with a tool such as Binwalk. Written by *Craig Heffner*, it allows
    us to extract filesystems from a firmware binary image with just a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Binwalk, simply clone Binwalk''s GitHub repository located at [https://github.com/devttys0/binwalk.git](https://github.com/devttys0/binwalk.git)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run `./deps.sh` in order to install all the required dependencies and binaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have installed Binwalk successfully, you can confirm it by simply
    typing in `binwalk` and hitting *Enter*. This should show the Binwalk''s help
    menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3664de5c-7156-4dd7-bf4d-940aa37bf7d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and perform a filesystem extraction from the same firmware
    using Binwalk. To do this, we will use the `-e` flag, which will perform the extraction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show us the various sections present in the firmware as well as extract
    the contents for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0dd734fb-9074-4629-b4e5-1073c269d496.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `t` and `vv` flags simply allow us to print the output in a more readable
    and verbose format. After the Binwalk execution, we can go to the directory with
    the name `_[firmwarename].extracted`, which will hold the entire filesystem for
    us as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f854a40f-4dd9-49e5-a998-392ab5701b61.png)'
  prefs: []
  type: TYPE_IMG
- en: That is how we extract the filesystem from a firmware binary both manually and
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The filesystem extraction in this case uses the same approach that we performed
    earlier. It detects the filesystem and other component offsets using the magic
    bytes and the header signature characters - such as `sqsh` for Squashfs and so
    on. The number of filesystems detected by Binwalk can be found at this URL: [https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems](https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also manually add more signatures to your Binwalk instance and compile
    it to detect those additional filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also additionally use Binwalk for performing a number of other operations,
    such as detecting the entropy of a given firmware image. This can help you identify
    whether a firmware image is compressed or encrypted. In order to perform entropy
    analysis, run `binwalk` with the `-E` flag followed by the firmware name as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7932f99a-c60d-49cd-abd1-106af4aa45ef.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, this particular firmware does not
    appear to be encrypted because of a lack of large variations which you would find
    in encrypted firmware images.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For additional information on firmware analysis and reverse engineering, the
    blog by the author of Binwalk, *Craig Heffner*, is extremely useful. It will also
    help you understand how different firmware images vary and are vulnerable. The
    blog is located at [http://www.devttys0.com/](http://www.devttys0.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing filesystem contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to reverse engineer firmware and extract the filesystem
    from it, in this section, we will look at the filesystem contents and perform
    additional vulnerability analyses on it. This will help us gain a deeper understanding
    of how to find security issues in firmware images, using which, we will be able
    to compromise an IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two approaches to analyzing filesystem contents:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tools and scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this approach of hunting for vulnerabilities within the firmware filesystem
    content, we perform analysis of the various files and folders present in the filesystem.
    This could range anywhere from looking at the configuration files, web directories,
    password files, hunting for backdoors, and so on. This is an ideal way of discovering
    vulnerabilities in the given firmware, and will be our focus for this section.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tools and scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of the date of publishing of this book, apart from a couple of scripts, a
    full suite framework or a tool which could help us find vulnerabilities in firmware
    does not exist. So, if you are familiar with web application security or network
    security, there are no tools similar to Arachni, w3af, Metasploit, or similar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with analyzing firmware and seeing whether we are able to
    identify any of the sensitive information or a backdoor for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The firmware that we will use for this exercise is a D-Link DWR 932B with the
    version `DWR-932_fw_revB_2_02_eu_en_20150709`. These following vulnerabilities
    have been discovered by security researchers, namely *Gianni Carabelli* and *Pierre
    Kim*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step would be to extract the filesystem from the firmware. However,
    the firmware in this case comes as a ZIP file which is protected by a password.
    The password in this case could be cracked by a utility such as fcrackzip and
    the password was found to be UT9Z. This is also shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eef7ca24-c6fb-4a96-908b-3c5a62efd6fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the firmware image, we can use Binwalk to extract the yaffs2 filesystem
    present within the firmware ZIP file. You can use yaffs2-specific tools to unpack
    the filesystem or simply using Binwalk will also do the job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `yaffs2-root` folder, we will have the entire filesystem as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0102900b-ed0e-4f1a-8fc1-fc88c4353b05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From here on, we can start navigating inside various directories and look at
    files which look interesting from a security point of view. One of the first things
    we could do is look for all the configuration files by running a `find` query
    for all the `.conf` files, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f410244b-8d4e-4cd0-a4f0-31e9554e5a83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For instance, this is what is present inside the `wpa-supplicant.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d9c7042-7d31-438a-9767-6c98cd1cee9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at other files such as `inadyn-mt.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f68a1e86-4bc6-4f1f-9e7a-8915dcef2aa7.png)'
  prefs: []
  type: TYPE_IMG
- en: Surprisingly, this file has highly sensitive information which in no way should
    have been able to be accessed. As we can see from the preceding screenshot, this
    file stores the no-IP configuration for the router, including the username and
    password combination which is used for the [https://www.no-ip.com](https://www.no-ip.com)
    access.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we can find sensitive information hidden in firmware. You can obviously
    look around more and identify more sensitive information within the firmware's
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to perform manual analysis on firmware, we will move on
    to identifying flaws through an automated approach. For this, we will use a tool
    called Firmwalker, written by *Craig Smith*, which helps identify some of the
    common sensitive information in a firmware through static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set it up, we simply need to clone Firmwalker''s GitHub repo as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have cloned the Firmwalker GitHub repo, we just need to run the `./firmwalker.sh`
    script followed by the extracted filesystem location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Firmwalker script identifies a number of different things for us, including
    additional binary files, certificates, IP addresses, private keys, and so on.
    It also stores the output in a file called `firmwalker.txt` (unless a different
    file is specified by the user) which looks as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61028b37-9e0b-4a02-a297-525c56bd217f.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have the report generated by Firmwalker, we can look at all the different
    files individually and analyze them further. In some cases, you will also need
    to reverse engineer ARM and MIPS-based binaries to understand them more and identify
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing and understanding a filesystem and its internal contents is all about
    your manual assessment skills. This is how you will be able to identify vulnerabilities.
    Even while working with various tools, you will realize that, in the end, it comes
    down to analyzing that binary or file manually and figuring out the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To analyze firmware filesystem contents on a deeper level, you could also use
    techniques such as firmware diffing, with which you could compare one firmware
    with its previous version and look at the differences. This would enable you to
    understand the security fixes and modifications which have been made in the new
    version and identify even undisclosed security issues in the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing which we could do with firmware filesystem content is look at
    the various libraries and components which have been used and see whether those
    components are outdated versions with vulnerabilities in them.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For analyzing firmware filesystem content, it's good to also read more about
    binary analysis and reverse engineering. Get yourself familiar with Linux binary
    analysis, debugging, and disassembling on platforms such as ARM and MIPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating firmware for dynamic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, while working with IoT devices, one of the limitations is we are not
    able to perform a lot of tests and exploitation without having access to the actual
    device. However, in this section, we will discuss a way in which you can emulate
    your firmware and interact with the emulated device as if it were an actual device
    sitting on your network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to emulate firmware, we will be using a script called **Firmware Analysis
    Toolkit** (**FAT**) written by the authors of this book. FAT uses Firmadyne in
    order to perform the emulation of firmware images.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying utility used in Firmadyne is QEMU, which allows users to emulate
    the entire system architecture and run content on top of it. It also takes advantage
    of additional scripts written by the tool authors, such as the NVRAM emulator
    located at [https://github.com/firmadyne/libnvram](https://github.com/firmadyne/libnvram).
    It also uses tools such as Binwalk, which we discussed earlier, to extract a filesystem
    from firmware which is then emulated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and clone the FAT GitHub repo and set it up to make the lab ready
    for emulation. It is highly recommended to perform this on an Ubuntu-based system
    to avoid any issues during emulation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start the setup by cloning the FAT repo from the link [https://github.com/attify/firmware-analysis-toolkit/](https://github.com/attify/firmware-analysis-toolkit/)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will also set up the database used by Firmadyne to store information about
    the firmware and for management in future. The password for the database will
    be set to `firmadyne`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have everything set up, it's time for us to pick firmware and emulate
    it and see what we are able to perform with the emulated firmware.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we will use firmware DWP2360b, which is firmware by D-Link
    for its Wireless PoE Access Point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will need to do is run `./fat.py`, which will then
    ask you for the firmware name and the brand of the firmware image. This firmware
    brand image is purely meant for database purposes so that we can later look in
    the database if needed and see which brand''s firmware we have emulated. Once
    you run it, it will look as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7a7bac4-badb-42c8-9ce0-57fe89b8cf5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will ask you for the password of the database a couple of times, which we
    have set to `firmadyne`. Once it finishes the initial processing, creating an
    image, setting up networking, and getting an IP address, it will show that FAT
    shows you the IP address and mentions that the firmware is now emulated, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41b28add-4f71-4fc8-a1ae-c7f515a06b9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the IP address, we can simply open this up in our browser and
    we will be presented with the router login page as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/edb94a5b-10f3-40d8-9b2a-4206b23a881c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we could emulate firmware using the help of the FAT even without
    having access to the device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding emulation works on the basis of the QEMU and NVRAM emulator. NVRAM
    is a component which firmware accesses in order to get information from the device.
    However, since there is no physical device present, it will result in an error
    or crashing of the service making the call. This is where the NVRAM emulator comes
    into the picture. The Firmadyne toolkit also modifies the firmware for debugging
    purposes to give the user access to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what is happening in the FAT script:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracts the filesystem from the firmware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gets the architecture of the firmware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes the required image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets up the networking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Emulates the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these steps can be performed manually, but having a script such as FAT
    helps speed up things.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to perform emulation would be to manually download Debian images
    for the appropriate architecture and copy the files from the firmware to the newly
    created Debian instance, and then run the web server (or the component you are
    testing) using Chroot. You can download existing Debian images from [https://people.debian.org/~aurel32/qemu/](https://people.debian.org/~aurel32/qemu/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with ARM and MIPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to emulate firmware and perform basic analysis, you will
    often find yourself coming across various binaries which will require additional
    analysis. It is impossible for us to cover all the various architectures possible
    for an embedded device in a single book, we will focus on two popular architectures
    - ARM and MIPS.
  prefs: []
  type: TYPE_NORMAL
- en: We will, however, only look at exploitation of MIPS and look a bit into ARM
    reverse engineering. From an exploitation perspective, ARM and MIPS are quite
    similar and learning one architecture would give you a head start and basic understanding
    for the other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our binary analysis journey with a very basic analysis of a backdoor
    found in D-Link firmware. This backdoor was found by *Pierre Kim*. To identify
    this backdoor, one would require a basic reverse engineering idea of ARM-based
    binaries. Even though we won't be going in-depth into registers and the architecture
    over here (since we are going to cover those in the MIPS architecture), this section
    will help you understand the process of analyzing a binary and identifying low-hanging
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The firmware that we are going to use in this case is of the device, D-Link
    DWR 932B. Once we extract this firmware using Binwalk, we notice that there is
    a binary called appmgr, which is what we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: We can use any disassembler which you might be familiar with - Radare2, IDA,
    Hopper, and so on. In this case, we will use Hopper to reverse engineer the appmgr
    binary, which is an ARM Little Endian binary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the pseudo code generation functionality of Hopper in order
    to understand it better. The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's load up the binary in Hopper for analysis:</li>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25f7b2fd-5c59-42fb-8565-44589dba8e7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the binary loaded, we can search for the `telnet` string and we
    will be able to see `telnet` mentioned somewhere in the code sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d31c904e-953f-4f75-857c-d5f465e0a42a.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding telnet instance in the strings
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out where it is being called from, we can right-click on the string
    and select References to address, which will show us the locations and instructions
    from where it is being called. In this case, if we do References to address, we
    find that it is being called from `0x13048` as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8e566bb-1585-4bbf-9ee2-9e1a652d0e1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Double-clicking on the address will take us to the address mentioned, in this
    case, `0x13048`. Once we are at the address, we can see the entire disassembly,
    as well as generate pseudo code by clicking on the button saying Pseudo-code mode.
    This is also shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f94c593-3dbd-49ec-b969-364bdc0d2605.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing Pseudo-code from the disassembly
  prefs: []
  type: TYPE_NORMAL
- en: 'Pseudo-code functionality is extremely useful for us, as it lets us see the
    disassembly as a logical program which makes more sense to us, if we are not extremely
    familiar with the disassembly. In this case, the following is what the Pseudo-code
    says:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b60d7347-bc03-4420-9aad-952a0373edde.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, it does a `strncmp` for the string
    `HELODBG`. As you will probably already know, `strncmp` is used for string comparison,
    which in this case is checking for the string which is required by the binary
    to launch Telnet as it is evident from the highlighted boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can confidently say that the appmgr backdoor looks for the string `HELODBG`
    and as soon as receives the string, it launches Telnet with `bin/sh` shell.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we perform a very basic analysis of an ARM binary which could be
    used to find both sensitive information or vulnerabilities, and a backdoor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to perform a basic analysis of ARM binaries, we would
    also recommend you read more about ARM assembly and its architecture. The knowledge
    and understanding of assembly instructions and underlying architecture will help
    you understand the disassembly in a much better way, even in cases where Pseudo-code
    is not helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting MIPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have basic information about how to reverse engineer binaries, it's
    time we get into a bit of depth on exploitation and understanding the architecture
    of the platforms on which IoT devices are mostly based. For getting a basic understanding,
    we will only focus on MIPS now, but it is highly recommended that you use the
    same concepts and perform exploitation on ARM-based architectures as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform MIPS exploitation, we would primarily do it using the QEMU and chroot
    technique which we glossed over earlier in this chapter. We will look into things
    such as how to perform buffer overflow exploitation on MIPS binaries and subvert
    the program execution flow to what we want it to be instead of what the binary
    is supposed to perform. We won't go into concepts such as **Return Oriented Programming**
    (**ROP**) for now and keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this exercise, we will require and use the following tools and utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Damn Vulnerable Router Firmware** (**DVRF**) - downloadable from the GitHub
    URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB-Multiarch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GDB Enhanced FeaturesÂ **(**GEF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QEMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: chroot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDA Pro/Radare2 (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go through each of them one by one and see how to set them up. Let''s
    go ahead and download the DVRF firmware from the following URL: [https://github.com/praetorian-inc/DVRF/tree/master/Firmware](https://github.com/praetorian-inc/DVRF/tree/master/Firmware).'
  prefs: []
  type: TYPE_NORMAL
- en: 'DVRF is a firmware written by *b1ack0wl* with the firmware meant for the MIPS-based
    platforms. Even though the firmware is intended for Linksys E1550, it could be
    run in an emulated environment using QEMU which also includes performing of exploitation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the firmware with us, let''s go ahead and install GDB (GNU
    Debugger) and GEF for our debugging purposes during exploitation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Also make sure that you have the required QEMU packages installed on your system.
    Now that we have everything in place, let's go ahead and run one of the binaries
    using binary emulation leveraging the functionality of QEMU.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will need to first extract the filesystem from the firmware
    using Binwalk as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29ca73c7-dc1e-45d5-88c4-50307da2536a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the filesystem extracted, we can copy the QEMU binary for the
    corresponding architecture in our root folder, which in this case is the `squashfs-root`
    as shown as follows. But before doing that, let''s confirm that our target binary
    is a binary meant for the MIPS architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding screenshot, our binary is meant for the MIPS
    architecture Little Endian format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/641cb935-8cb4-4238-9eb7-a8b85b7d568d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now go ahead and copy the QEMU binary for MIPS Little Endian (mipsel)
    to our current squashfs-root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have copied the `qemu-mipsel-static` to our current directory, we can
    then use the change root (`chroot`) utility along with QEMU to both emulate the
    binary and run it, and at the same time have the binary believe that its root
    folder is the current folder from where we are running the command. This can be
    done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, we are able to run the binary
    even though it was originally meant for another architecture. This is possible
    with the emulation functionality of QEMU and with the change root functionality
    of `chroot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d12f136-9c52-49f4-bbb4-12bc7c5c6438.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the output of the command (shown in the preceding screenshot),
    this binary expects arguments to run. Additionally, if we look at the source code
    of the binary, we find that this binary is vulnerable to a stack-based buffer
    overflow vulnerability. The following is the source code of the `stack_bof1` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3967adf3-6e71-4e61-a766-aecd601750aa.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, the `buf` buffer is vulnerable
    to buffer overflow, and our goal with the overflow is to modify the program flow
    to point it to the address of `dat_shell` so that we get a shell from exploiting
    this vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start debugging this program by running it with QEMU and chroot, along
    with an additional flag of `-g` which will attach GDB to the process as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, the program execution has paused
    and it is now waiting for a debugger to connect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d1a23fe-2385-469e-ba1c-e20ae4028d12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the execution has paused, we can launch GDB and set up the target
    to remote along with the port which we have just assigned. Additionally, we will
    have to set the architecture to MIPS to be able to properly disassemble the binary
    if required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b7072b5-d229-48d0-9810-25ce3f9fa8e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have connected the target, you will find that the process has paused,
    which can be resumed by typing in `c` for continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also see the list of available functions in the binary by doing an `info
    functions` as follows, and identify the functions which could be interesting from
    our pen testing perspective:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/164ed18f-6f17-48c6-af4a-c559508756d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's also go ahead and disassemble the `main` function and see how it looks.
    For this, we can simply do a `disass main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see from the following screenshot, we are able to see the disassembly
    of the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f2ec92c-46c9-4ad0-95fe-59c198e0edd1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're familiar with some of the instructions, you will find the instructions
    useful. The disassembly is in the format of address, instruction, and operands.
  prefs: []
  type: TYPE_NORMAL
- en: MIPS has a total of 32 general-purpose registers, including `$zero`, `$at`,
    `$v0-$v1`, `c`, `$t0-$t9`, `$s0-$s7`, `$k0`, `$k1`, `$gp`, `$ra`, `$fp`, and `$ra`.
    Out of all of these, `$a0-$a3` is meant for storing arguments to functions, `$t0-$t9`
    is for temporary data storage, `$gp` is the global area pointer (we try not to
    modify GP during exploitation), `$sp` is the stack pointer, `$fp` the frame pointer,
    and `$ra` is the return address. There is an additional special-purpose register
    called the **Program Counter** (**PC**) which stores the memory address of the
    next instruction, which is the instruction following the one which is currently
    being executed.
  prefs: []
  type: TYPE_NORMAL
- en: To take control of a MIPS-based binary program execution flow, we are only concerned
    with two registers - RA and PC. As you will realize while dealing with MIPS-based
    binaries, controlling PC is often tougher compared to RA. Thus, for this exercise,
    we will focus on taking control of RA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know that the current binary we are working with, `socket_bof`, is
    vulnerable to a stack-based buffer overflow, let''s run it with an extremely large
    argument. To generate the argument, we will use the pattern create functionality
    of GEF as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82bddf25-498c-4bd3-9b7b-29cad377e0fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have generated the pattern, we can run the `stack_bof_01` with the
    preceding generated argument and see whether we are able to overflow RA. The following
    screenshot shows running the program with the custom, 300-character-long argument
    generated from GEF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b82fc17-7a22-45a0-91b0-b797953262cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, the binary execution state is paused and it is waiting for a debugger
    to attach to it because of the `-g` flag. Now open the GEF Terminal window and
    type in the `target` as shown in the following command and screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/843e9d47-e5fc-44db-85c2-9993d6ceaa22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have the `target` set, you can hit `c`, which will continue the program
    till its completion or till it hits a breakpoint or exception. As we can see in
    the following screenshot, the program hits a `SIGSEGV` fault:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf792834-36fc-4443-bfa6-41eadb08f11c.png)'
  prefs: []
  type: TYPE_IMG
- en: GEF also shows us the entire state of the stack and registers at the time when
    it caught an exception. In our case, we can see that RA is overwritten with `0x63616162`,
    which simply is the hex for `baac`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the above information, let's use the pattern search function to
    find the offset of the bytes which overwrite RA. With this, we will be able to
    find out where we should place our malicious address and control the program execution
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can use the command `pattern search RA-overflown-bytes-in-hex`
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfe00194-7601-4719-bc22-633919744bf2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, we are able to find the offset
    of the characters which overflow the register RA, which in this case is `204`.
    This means we would need `204` bytes of junk to fill up everything before RA and
    the next `4` bytes would be the values with which RA is being overwritten with.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember our goal for this exercise was to modify the program execution
    flow and call the `dat_shell` function which would not have been called in the
    normal flow of the program. In order to find the address of `dat_shell`, we can
    either do a print `dat_shell` or we can disassemble and look at the starting address.
    This can be done by using the command `disass function-name` as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28dcea40-224e-48d7-b1e2-80f606697a73.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, the `dat_shell` function starts
    from the `0x00400950` address. However, the first three instructions work with
    **Global Pointer** (**GP**) which we don't want to play around with at this moment.
    This is the reason we will jump to `0x0040095c` instead of `0x00400950`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go ahead and run the binary with `204` characters of junk followed
    by the address `0x0040095c`. This time, we have also removed the `-g` flag and
    run it directly as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ac22f79f-9b17-4b15-a3b3-d300b6c56a43.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, the binary has now executed the
    `dat_shell` function as we wanted. This is how we perform a stack-based buffer
    overflow on a MIPS-based platform.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire underlying concept of buffer overflows is being able to put more
    characters in the buffer than what is intended to be entered, and in that way,
    controlling the registers which might be present on the stack. This can also be
    used to jump to a shellcode's location or to the system's `libc` library and executing
    additional payloads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we could perform exploitation in this vulnerable binary, often in
    real-world situations, you would be presented with more complicated scenarios.
    One of them being the fact that interesting functions to jump to won't be located
    inside the binary and you would have to either jump to system to execute `bin/sh`
    or create a ROP chain to execute your shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring firmware with firmware-mod-kit (FMK)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the techniques that often come in useful during exploitation is the ability
    to modify firmware. This can be done by extracting the filesystem from the firmware,
    modifying the contents, and then repackaging it into new firmware. This new firmware
    could then be flashed to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to modify firmware, we will use a tool called FMK written by *Jeremy
    Collake* and *Craig Heffner*. FMK utilizes Binwalk and additional tools to extract
    the filesystem from the firmware and also provides us with the ability to repackage
    the modified filesystem into a new firmware binary.
  prefs: []
  type: TYPE_NORMAL
- en: FMK can be downloaded from [https://github.com/brianpow/firmware-mod-kit/](https://github.com/brianpow/firmware-mod-kit/)
    or it might already be present in your system if you cloned the FAT tool earlier.
    Once you have downloaded it, we need firmware which we can try it out on. To keep
    things simple and so that everyone who is reading this book can replicate the
    following steps without investing in purchasing hardware, we will use firmware
    which can be emulated well using FAT.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The firmware that we will use in this case is firmware by D-Link, the DIR-300
    router. In order to extract the filesystem from the firmware, instead of using
    Binwalk, we will use the `extract-firmware.sh` script located in the FMK directory,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8ce54461-9a12-4f50-81c5-5b12f5bddde9.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have extracted the firmware, it will contain a new directory for us
    including the folders `rootfs`, `image_parts`, and `logs`. For most of our backdooring
    and firmware modification purposes, we will only be concerned with the `rootfs`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `rootfs` folder contains the entire filesystem of the firmware. All we need
    to do is create a backdoor for the firmware's architecture and then find a way
    to invoke it automatically once the firmware starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first find out which architecture the firmware is meant for. We can
    find this out by doing a `readelf` on any of the firmware binaries, such as BusyBox,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0cecc090-c60e-40b6-bb9e-82196ef4834e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, it is a MIPS-based Little Endian
    architecture. This means that we will need to create and compile a backdoor for
    the MIPS Little Endian format. The following is the backdoor we are going to use,
    written originally by *Osanda Malith*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the code, we can use Buildroot for MIPSEL and compile it using
    a crosscompiler built using Buildroot. We won't go into the process of setting
    up Buildroot as the process is extremely straightforward and has been documented
    in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created our cross compiler for MIPSEL, we can compile the `bindshell.c`
    to `bindshell` binary which then could be placed in the extracted filesystem of
    the firmware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to look for places where we could place this binary in the
    filesystem, and how we can make this autostart during boot up. This could be done
    by looking at one of the scripts which would be invoked automatically during boot
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon looking at the filesystem, we can add the binary in `etc/templates/` and
    can refer it from the script called `system.sh` located at `/etc/scripts/`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e331f34-ed6f-4667-b80c-5c87907c098f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s go ahead and build new firmware based on this modification using
    the `build-firmware.sh` script as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c913fb64-af2c-4e09-8fb2-c8e2d654b37e.png)'
  prefs: []
  type: TYPE_IMG
- en: Once it finishes the building process, it will create new firmware and place
    it in the location `firmware-name/` as a file called `new-firmware.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the new firmware image, we can copy this firmware to our FAT directory
    and emulate it to verify that our added backdoor is working. This can be done
    using the same steps which we used earlier for emulation. This is also shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aac333e5-dc78-4677-adf0-ed215872c634.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, it gives us an IP address of `192.168.0.1`
    which we can now try to access. But more interestingly, let's see whether our
    backdoor bindshell which we placed in the firmware is active or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to run a Netcat to port `9999` on the preceding IP and see whether
    it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3cea80f6-a14b-4bd8-b90e-c556ff4847ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a full root shell on the device because of a backdoor which we modified
    and placed in the firmware. From here, we can modify additional device configurations
    or simply use it to access any device running our modified malicious firmware
    remotely.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to modify firmware is extremely powerful and useful for attackers.
    This enables the attackers to bypass protection mechanisms, remove security features,
    and do more. Due to tools such as FMK, it becomes extremely easy for attackers
    to add their own malware or backdoor to any IoT device firmware, which could then
    be used by a user located anywhere in the world.
  prefs: []
  type: TYPE_NORMAL
- en: This is also one of the reasons why signature and checksum verification of firmware
    is extremely important to prevent attacks arising because of malicious or modified
    firmware.
  prefs: []
  type: TYPE_NORMAL

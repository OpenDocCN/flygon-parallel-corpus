- en: Radio Hacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with SDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on with SDR tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and exploiting ZigBee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining Insight into Z-Wave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and exploiting BLE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all the **Internet of Things** (**IoT**) devices in the current day scenario
    interact with other devices to exchange information and take action. It is highly
    essential to know about the wireless protocols that are used by IoT devices and
    the security issues affecting them, in order to pen test IoT devices effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless communication or radio simply is a way of transferring data from the
    source to destination through the communication medium of air using electromagnetic
    waves. The radio signals are the same signals that are used in your common devices
    such as microwave, light, and infra-red; it's just that the signal in each case
    varies in wavelength and frequency. In case of wireless communication, the data
    that needs to be transmitted is first converted into an electric signal using
    the potential difference and the location of the antenna from which the signal
    originates, carried across by a carrier wave, and then demodulated at the other
    end to obtain the actual data that was sent by the source. We won't get into further
    detail about electromagnetic concepts and how an electric signal is generated
    from the data, as it is beyond the scope for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: IoT devices work on various wireless communication protocols ranging from cellular
    to Wi-Fi, depending on the product requirements and device manufacturer's preferences.
    It would be impossible to cover all the various wireless communication protocols
    in a single chapter or book, however, we will be focusing on the overall penetration
    testing methodology and covering the two most common protocols—ZigBee and **Bluetooth
    Low Energy** (**BLE**).
  prefs: []
  type: TYPE_NORMAL
- en: The different wireless protocols serve their own purpose and have their own
    pros and cons. Each of them operate at a specified frequency (or frequency range)
    and will require a different pen tester hardware and software setup to be able
    to analyze the packets for that communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Before going into the individual protocols, we will take an in-depth look at
    **Software Defined Radio** (**SDR**), which is one of the most important concepts
    when it comes to radio reversing and hacking for IoT devices. We will also get
    ourselves familiar with the various underlying foundational concepts that are
    required in order to understand radio hacking and SDR in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with SDR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SDR is an extremely useful technique with which we can vary the purpose of a
    given radio device. As the name suggests, the radio in this case is software defined,
    which means that the functionality, or the action that the radio performs, can
    be changed and modified based on our requirements. This is unlike traditional
    radios, where a particular device served a single purpose based on the hardware
    design present in it.
  prefs: []
  type: TYPE_NORMAL
- en: This opens up a plethora of opportunities for us, as we can get started with
    SDR and keep repurposing it to suit our various needs. Repurposing here simply
    means that let's say we are analyzing the FM spectrum, we can have the device
    do it, and, if later on we want to analyze the data coming out from an IoT device
    at 433 MHz, we can use the same device to capture the data, process it, and extract
    the text being sent in it.
  prefs: []
  type: TYPE_NORMAL
- en: By now you should have a decent understanding of what SDRs are and what purpose
    they can serve. Before going into the actual hands-on exercises with SDR and analyzing
    different things, in this section, we will get ourselves familiar with the underlying
    concepts and terminologies which you might come across as you go deeper into radio
    hacking and SDR.
  prefs: []
  type: TYPE_NORMAL
- en: Key terminologies in radio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a quick look at some of the terminologies which you will find yourself
    coming across very often in SDR.
  prefs: []
  type: TYPE_NORMAL
- en: A simple radio system would include several components such as a sender, receiver,
    carrier wave, and medium. These components are pretty much what you would expect
    them to be. The sender is the component that sends the signal, which is received
    by the receiver, via the medium of transmission.
  prefs: []
  type: TYPE_NORMAL
- en: In most practical scenarios, the data wave that needs to be sent is modulated
    with a carrier wave, which is then sent to the receiver, where the modulated wave
    is demodulated to recover the original data wave which was to be transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of modulation types such as frequency modulation, amplitude
    modulation, and phase modulation. Additionally, there are also a number of digital
    modulation techniques such as **On-off Keying** (**OOK**), **Phase-shift Keying**
    (**PSK**), **Frequency-shift Keying** (**FSK**), and **Amplitude-shift Keying**
    (**ASK**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common terminologies which you will encounter while working with
    radio systems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wavelength**: This in radio terminologies means the distance between two
    subsequent crests (high points) or two subsequent troughs (low points) in a waveform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: This, as the name suggests, refers to how frequent an event
    happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gain**: This is the signal-to-noise ratio of the new processed signal versus
    the signal-to-noise ratio of the original signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**: This removes unnecessary or unwanted components from a radio signal.
    It can be of various types such as high pass filter (allowing only signals above
    a certain threshold to pass through the filter), low pass filter (allowing only
    signals below a certain threshold to pass through the filter) and band pass filter
    (allowing only signals between a given frequency range to pass through the filter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sampling**: This involves converting a continuous signal into a discrete-time
    signal with a number of independent values. As expected, if the sampling rate
    is not correct, the signal would appear to be incomplete or distorted and might
    lead to incorrect calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nyquist''s theorem**: In this case, any signal can be represented by discrete
    samples if the sampling frequency is at least twice the bandwidth of the signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analog-to-Digital Converter** (**ADC**)/**Digital-to-Analog Converter** (**DAC**):
    This converts analog signals to digital signals and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the various radio terminologies, let's
    get into looking at some of the tools with which we can play with SDR and use
    it for security research purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with SDR tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the most common tools used for SDR and analysis
    of radio signals. We will begin by getting started with the very basic tools and
    then use that to extract more information from radio packets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform SDR-based security research, the following tools will be required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardware:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTL-SDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Software:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GQRX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Radio companion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To install the tools, the following repositories have the best build instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of installing from `apt-get`, ensure that you build GNU Radio companion
    to get a better experience of working with SDR.
  prefs: []
  type: TYPE_NORMAL
- en: SDR security research is also dependent on the performance of your system. Make
    sure that you have enough RAM allocated to the virtual machine you are performing
    these tasks in. If possible, use an Ubuntu instance as host to get the best experience.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An RTL-SDR is one of the best devices to get started with in the world of SDR.
    It's originally a TV tuner dongle with the Realtek chipset, which can be used
    for a number of radio-based activities. The frequency of these devices varies
    and is typically in the range of 22 MHz-1.7 GHz.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing FM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we will do in order to get started with SDR is look at
    the frequency spectrum using RTL-SDR. This will give us a better understanding
    of how everything works and get us started with reconnaissance of SDR-based devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, plug your RTL-SDR into your system. Ensure that the RTL-SDR is connected
    to your virtual machine if you are using one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open up GQRX and select the RTL-SDR device during the initial launch
    menu. Here, as you can see, we have different sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/027bbb50-5d18-4f1e-a62b-56449c9dced2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the top section, you will be able to set frequencies using either up and
    down arrow keys or by typing the frequency you want to tune your RTL-SDR to.
  prefs: []
  type: TYPE_NORMAL
- en: Just after the frequency section, we have the frequency spectrum. This is where
    you are able to see which frequencies are most active and also notice spikes in
    them when you use your radio-based IoT device. We will get more into this later.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we have the waterfall section, which is a plot of activity versus
    time. This means that you are able to see which frequency had communication activity
    until a few seconds back.
  prefs: []
  type: TYPE_NORMAL
- en: In the right-hand section, we have a Receiver Options, Input controls, and FFT
    Settings, which are various configurations that will help you analyze your data
    in a better way. However, we won't go into each of them in order to keep things
    simple for now. All the panes can be modified and customized as required.
  prefs: []
  type: TYPE_NORMAL
- en: In this first exercise, we will listen to one of the local FM stations by tuning
    to it and receiving the audio in GQRX.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s first change the mode to Wide FM stereo, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/570c9f3a-51c8-42b7-8890-52817095fd02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have done that, change the frequency to your local FM station frequency
    range as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6cc2a9b-2a29-4907-9ffc-f4ef01626c35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as you hit the Capture button, you will be able to see a frequency
    spectrum with spikes at multiple places. The spikes represent the activity at
    that frequency range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f5f840e8-92ac-4671-9c54-99cf71b3e28c.png)'
  prefs: []
  type: TYPE_IMG
- en: If you listen to the sound from your speakers now after tuning to one of the
    valid FM stations, which can be identified by the spike, you will be able to hear
    the FM broadcast at that frequency.
  prefs: []
  type: TYPE_NORMAL
- en: RTL-SDR for GSM analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use RTL-SDR for a number of other purposes. One such usage is performing
    cellular analysis, as shown next. We will be using the RTL-SDR to find the exact
    location details about various cellphone users. This can then be used with a unidirectional
    antenna to increase the range and collect a good amount of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, launch `grgsm_livemon`, which is downloadable from [https://github.com/ptrkrysik/gr-gsm/](https://github.com/ptrkrysik/gr-gsm/).
    Launch it as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d6531f4-0b80-45a4-bca7-9aa853fe7652.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open a screen of `grgsm_livemon` allowing you to change gain and
    frequency in order to look at the frequency spectrum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd7bd4f6-e65f-4110-99b5-8900f0a9dd66.png)'
  prefs: []
  type: TYPE_IMG
- en: So how do we get the frequency on which the activities are happening on a cellular
    network. To do this, we will use a utility called Kalibrate, which is a GSM-frequency
    identifier and is available from [https://github.com/ttsou/kalibrate](https://github.com/ttsou/kalibrate).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Kalibrate, specify the band to scan—in this case we are scanning
    for GSM900 and setting the gain to 40.0 dB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95314674-b781-4ebd-87c9-3f608d57b628.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It tells us that there is good amount of traffic at 956.4 MHz + 9.829 kHz.
    Let''s fire up GQRX and look at this frequency, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0cac46df-fff1-4ff8-a86f-d78dc0605ac5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, there is indeed a lot of activity happening at the identified
    frequency. So, now we have got the frequency which we want to look at, let''s
    go back to GRGSM, set up this frequency, and analyze it further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d79d9f0f-4333-49e0-97cc-72d7ee7022b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the same kind of traffic in Gr-gsm as well. Now, to analyze it further,
    we will need to look at the traffic in Wireshark on the loopback `lo` interface.
    As expected, we are able to see some interesting information here. Apply the `gsmtap`
    filter to filter out the messages which are relevant to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc323f6c-f768-4e7c-8568-f7bd3ef17ad5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have identified the **Mobile Country Code** (**MCC**), **Mobile
    Network Code** (**MNC**), and **Location Area Code** (**LAC**) using which we
    can now pinpoint the location of this cellphone on the map using utilities like
    CellidFinder, which will allow us to find the closest tower to the phone on the
    map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ee447dc-547c-4467-b49e-62742e780745.png)'
  prefs: []
  type: TYPE_IMG
- en: So this is how you can use RTL-SDR for a number of various purposes and to analyze
    a lot of things ranging from normal FM to flight traffic to even cellular traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GNU Radio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in the previous cases, it was all about just looking at the frequency and
    analyzing it, however, not too deeply. What if we have an IoT device which is
    transmitting raw radio traffic and we want to understand what is going on behind-the-scenes
    and find out what data is it actually transmitting.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will use a utility called GNU Radio-companion, which allows us
    to build radio blocks in order to process various radio signals. In this utility,
    you can select an input source (such as RTL-SDR source, Osmocom source, HackRF
    source, and signal generators) and apply radio blocks on it, and finally store
    the output in a raw wav file or plot it in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we are looking at a weather station for which we will capture
    the data using RTL-SDR source and then perform a demodulation and clock recovery
    to find the actual data which was being sent by the weather station.
  prefs: []
  type: TYPE_NORMAL
- en: To find out the frequency on which the device operates, we can use GQRX and
    look for the spikes whenever it transmits data. Another option would be to look
    for FCC ID—a standard required for manufacturers to sell devices in the US—which
    performs significant radioactivity. This information is typically located on one
    of the labels on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the FCC ID, we can go to `fccid.io` and enter the `FCC-ID`, which
    will show us the exact frequency being used by the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/698a2181-2933-4bbc-aa4b-c465c0f1b881.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the frequency, let's go to GNU Radio-companion and create a
    workflow to process the data coming out of the weather station. We won't go very
    in-depth into GNU Radio-companion and its various properties, but we would highly
    recommend you explore it on your own and try with various other radio captures
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the blocks that we are going to add here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Osmocom source**: This helps you to get radio packets from RTL-SDR and passes
    them to the following blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex to Mag^2**: This helps you to change the complex data type to real,
    not considering things such as the phase angle, which are not important to us
    at the moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiply Const**: This helps you to increase the strength of the output data
    that you receive as the original one might be extremely low. A value of 5 or 10
    would be good.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File sink**: This helps you to put the output into a file, which could be
    then analyzed in audacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9fe5f846-5cfe-4aec-926b-a9a3741aeb69.png)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on Osmocom source to change its properties and set the frequency,
    which we identified earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Also double-click on Wav file sink and give it an output filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to run this. Once we run this, we will have a new file called
    `monitor.wav`. Import the file in audacity as a raw file. At this step, this looks
    like an OOK; we would need to convert this data into actual data which is understandable.
    One of the ways would be to have the shorter pulse gaps represent digital zero
    and the longer ones represent the digital ones. This is also shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cef0e57-aa81-4f65-8cd4-1b3976005b29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we analyze the data further, we are now able to see the exact data that
    was sent by the weather station including the temperature and humidity data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b818cbd7-a1f9-48cc-b1a2-64c9598f7f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of other utilities built around RTL-SDR and overall SDR hacking
    which could be used for a number of purposes. For example, the ADS-B project allows
    you to track flights in real-time, RTL-433 to work with 433 MHz signals and additional
    utilities to exploit things such as Keyfobs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and exploiting ZigBee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ZigBee is one of the common wireless protocols used in IoT devices because of
    its ability to form mesh networks and perform operations with low power and resource
    consumption. It has found its use in a number of verticals, including Smart homes,
    **Industrial Control Systems** (**ICS**), smart building control, and so on. It
    operates on 2.4 GHz in most countries, 902 to 928 MHz in America and Australia,
    and 868 to 868.6 MHz in Europe.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be looking at ZigBee and seeing how we can identify
    the ZigBee devices around us and sniff and replay the traffic in order to identify
    security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with ZigBee, the following set up is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware**: Atmel RzRaven USB Stick flashed with KillerBee firmware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software**: KillerBee'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing KillerBee is extremely straightforward and can be done by following
    the instructions on the official GitHub repo available here [https://github.com/riverloopsec/killerbee](https://github.com/riverloopsec/killerbee).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the setup completed, plug your RzUSB stick into your system. You
    should be able to see the LED glow with an amber color. If you find the color
    is blue, this means that your RzUSB stick is not flashed with the KillerBee firmware.
    We won't go into the instructions to flash the firmware - as it is documented
    well in the GitHub repo, and there are a number of online stores from where you
    can get a preflashed RzRaven with KillerBee firmware.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following are the steps for how we can get started with analyzing ZigBee devices
    around us and finally sniffing the traffic over ZigBee using the RzRaven and KillerBee
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step that we will perform is to look at ZigBee devices around us.
    This can be done using the `zbid` utility, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d1f581f-6c5a-457d-a409-9b01d0e9b41a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have also flashed the following program to the Arduino. This program tells
    Arduino to interact with XBee connected over serial at pins 2 and 3, and send
    the message `5e87bb4a6cdef053fde67ea9711d51f3` via XBee. The channel that XBee
    sends this traffic on is based on how a given XBee is programmed. If you would
    like to program your own XBee and specify the channel, you can use the utility
    XCTU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we place both the Xbee and Arduino in the Xbee Shield, which looks similar
    to what is shown in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7caa28e-2466-4443-a812-afb7ea431c61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Power on the shield and run `Zbstumbler`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c4a07eb-2633-464b-a298-4aabcb6c0b24.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we are able to see devices broadcasting on channel 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to sniff the traffic on channel 12 and see if it contains
    any sensitive information. For this, we will use the `zbwireshark` utility using
    the syntax shown as follows, which will automatically open Wireshark for ZigBee
    sniffing on the channel specified in the syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we will be able to see all the traffic in Wireshark, as shown
    in the following screenshot, along with the sensitive string that we programmed
    the Arduino with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd9456e5-8143-4e84-905c-ac498bc55e9e.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also perform additional attacks such as replaying the captured traffic
    after modification using utilities such as Zbreplay in the KillerBee tool suite.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining insight into Z-Wave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Z-Wave is one of the popular protocols in wireless sensor networks and home
    automation, and operates on 908.42 MHz in US and 868.42 MHz in Europe. Z-Wave
    just like ZigBee supports mesh networking, which makes it secure against issues
    such as node failure.
  prefs: []
  type: TYPE_NORMAL
- en: It has been developed by Sigma Systems, which makes it a closed protocol compared
    to ZigBee and others. This is also one of the reasons that the security research
    initiative by the security community against Z-Wave is relatively less compared
    to other popular IoT protocols. There are also projects such as OpenZWave to provide
    an open source alternative; however, they are still in the very early stages.
  prefs: []
  type: TYPE_NORMAL
- en: Just like typical radio communication protocols, Z-Wave devices suffer from
    the same set of security issues. One of the most common vulnerabilities in Z-Wave
    devices is the lack of encryption in communication, which makes it vulnerable
    to attacks such as sensitive information transmission in clear text and replay-based
    attacks. However, another thing to note is that projects such as S2 Security in
    Z-Wave drastically increase the security of the Z-Wave implementations in the
    device, additionally protecting it from attacks against key exchange and device
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perform attacks against Z-Wave, one of the popular frameworks is EZ-Wave
    ([https://github.com/AFITWiSec/EZ-Wave](https://github.com/AFITWiSec/EZ-Wave))
    developed by *Joe Hall* and *Ben Ramsey*, which uses Hack RF hardware to perform
    attacks against the Z-Wave protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EZ-Wave toolkit comprises three tools, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Device discovery and enumeration-EZStumbler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnaissance on identified devices-EZRecon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploitation-EZFingerprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the methods of assessment of the Z-Wave protocol is to capture the packets
    in transmission and look for sensitive information being transmitted in clear
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd4a557a-930c-4fd0-bb0d-dac8983b8bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using all the preceding building blocks, here is what our final flow graph
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/576c7c52-8e9c-4887-a4ab-1a38159dc83c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: http://oldsmokingjoe.blogspot.in/2016/04/z-wave-protocol-analysis-using-ez-wave.html.'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we can choose to replay the packets or modify and then replay
    based on the target that we want to achieve. Another class of attacks against
    the Z-Wave systems would be Disjoining/Unpairing attacks of Z-Wave device nodes
    from the network, Spoofing attacks, Jamming and Denial of Service attacks, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and exploiting BLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLE or Bluetooth Low Energy is one of the most common platforms found in a number
    of smart devices ranging from smart homes to medical device utilities to even
    fitness trackers and wearables. One of the reasons for the growing popularity
    of BLE is that pretty much all smartphones that we use today support BLE, thus
    making it easier to interact with BLE-based IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: BLE is designed for devices with resource and power constraints which BLE effectively
    solves by providing short bursts of long range radio connections, thus significantly
    saving battery consumption.
  prefs: []
  type: TYPE_NORMAL
- en: BLE was initially introduced in Bluetooth 4.0 specifications focusing on the
    devices which needed a mode of communication with extreme low power consumption,
    where BLE claimed to last from a couple months to several years on a single coin
    cell battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'A BLE device can operate in four different modes based on its current connection
    and operational phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central device and peripheral device**: In this classification, the device
    which scans for advertisement packets and initiates connections is called the
    central device, whereas the device that advertises itself for connection is called
    the peripheral device. An example of this would be a smartphone as a central device
    and a fitness tracker as a peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcaster and observer**: As the name implies, a broadcaster is a device
    that broadcasts data, whereas an observer is a device which scans for advertisement
    packets. However, the major difference here compared to the previous classification
    type is that the broadcaster is nonconnectable and the observer can''t initiate
    connections. An example of this would be a weather station which emits temperature
    data continuously acting as a broadcaster, whereas a display that receives the
    broadcasts and shows it on the screen is an observer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BLE consists of 40 different channels—3 advertisement and 37 data channels,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ead3bba8-fc27-4e0e-842e-b8bd8cfdcf93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: http://www.connectblue.com/press/articles/shaping-the-wireless-future-with-low-energy-applications-and-systems/'
  prefs: []
  type: TYPE_NORMAL
- en: BLE also performs frequency hopping spread spectrum, which means that it keeps
    changing channels on every event. However, the tools that we are going to use
    in the coming sections will be able to follow a device via the hops and be able
    to sniff the data for the BLE communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get ourselves better prepared with the foundational concepts of Bluetooth
    Low Energy, here''s what BLE stack looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4496114-6634-4e2a-8166-f60a868dc25a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: http://www.embetronicx.com/'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are three main layers here: **Application**, **Host**,
    and **Controller**. Also, the **Host** and **Controller** interact through what
    is called the **Host Controller Interface** (**HCI**).'
  prefs: []
  type: TYPE_NORMAL
- en: The **Controller** contains the **Link Layer** (**LL**) and **LE Physical Layer**
    (**PHY**). The physical layer is responsible for the primary task of signal modulation
    and demodulation, and calculating the hopping pattern for the device during a
    connection. The link layer is responsible for a number of tasks such as managing
    a number of things, including the Bluetooth address of the device, encryption
    and connection initiation, and handling advertisement packets.
  prefs: []
  type: TYPE_NORMAL
- en: The **Host** layer contains some of the most important things that we will be
    directly working with during BLE exploitation. These include **Generic Access
    Profile** (**GAP**) and **Generic Attribute Profile** (**GATT**).
  prefs: []
  type: TYPE_NORMAL
- en: GAP is responsible for controlling most of the advertisements and connection
    initiations, as well as defining the roles of various devices present in a communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'GATT sits directly on top of ATT, which is the component responsible for data
    exchange between master/slave and performs a number of operations such as read,
    write, and error handling. GATT adds an overall data organizational layer on top
    of ATT making it more understandable. In GATT, the entire data is categorized
    as per the given diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f57e9d2-ac6e-4989-9cbb-203323bac8fc.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding diagram, the overall data is organized into
    the lowest elements of **Characteristic**, which hold a **Value** and **Descriptor**.
    An example of this would be heart-beats-per-minute and its value being stored
    in characteristic. The characteristics also have a unique UUID, which can be referenced
    from the Bluetooth **Special Interest Group** (**SIG**) database available here
    [https://www.bluetooth.com/specifications/gatt/characteristics](https://www.bluetooth.com/specifications/gatt/characteristics).
  prefs: []
  type: TYPE_NORMAL
- en: Next, various similar characteristics are enclosed in services. An example of
    a service would be `heart-rate-service`, which contains various characteristics
    such as heart-beats-per-minute, irregular-heart-beats, and panic-attacks. Services
    also have a 16-bit UUID using which they can be referred from to the Bluetooth
    SIG database of Services UUID available here [https://www.bluetooth.com/specifications/gatt/services](https://www.bluetooth.com/specifications/gatt/services).
  prefs: []
  type: TYPE_NORMAL
- en: Next, this entire service is enclosed within a **Profile**, which could be a
    generic profile, in this case, something like a heart health profile, which contains
    various services such as `heart-rate-service` and `heart-oxygen-service`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, our goal during sniffing is to find the value of characteristics,
    which are being read and written. These characteristics are usually referred to
    as **handles**, which is what we will see once we capture the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, the other important component of the BLE stack is L2CAP. L2CAP stands
    for logical link control and adaption protocol and is responsible for primarily
    taking data from the other layers and encapsulating the data in a proper BLE packet
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: That is all that we need to know to get started with BLE exploitation. Now,
    let's get our hands dirty.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with BLE Exploitation, we need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Software:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue Hydra or HCI Utils
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubertooth utils
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gattacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BLE adapter dongle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubertooth or similar BLE sniffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with BLE, our methodology is to first find out the target device's
    address and sniff the traffic for that specific address while performing an operation
    with the target BLE device.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow us to find specific BLE handles that are being written on the
    device to perform a certain action. To give a better insight to what BLE handles
    are, they are simply a reference to the various properties a BLE characteristic
    has.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will ensure that we have everything properly set up, as
    given next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the Bluetooth Adapter dongle is connected to your virtual machine
    and you are able to see the `hci` interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ba5963d-506f-4a75-b767-2547224d0417.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, install the following tools from their official GitHub repos:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blue Hydra (for performing initial recon on the BLE devices) : [https://github.com/pwnieexpress/blue_hydra](https://github.com/pwnieexpress/blue_hydra)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubertooth Utils (to perform sniffing and packet capture for our BLE devices)
    [https://github.com/greatscottgadgets/ubertooth](https://github.com/greatscottgadgets/ubertooth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireshark (Packet analysis tool, also compatible with BLE) [https://www.wireshark.org/download.html](https://www.wireshark.org/download.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have all of this installed and configured, we are ready to start interacting
    with BLE devices around us.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that we will do in order to interact with BLE devices around
    us is to look at all the devices around us and find their Bluetooth addresses.
    This can be done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `lescan` (Low Energy Scan) functionality of Hcitool to look for
    all the BLE advertisements in the vicinity, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0db4993d-ecc5-41b0-984c-4bfd38de884f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are able to identify a number of devices around us along
    with their addresses. Next, we can use Ubertooth to sniff the traffic for a given
    device as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Ubertooth One is a device developed by *Michael Ossman* of GreatScottGadgets
    to help assess the security of Bluetooth devices. It consists of a CC2400 2.4
    GHz RF transceiver combined with an NXP LPC1756 MicroController with a USB port.
  prefs: []
  type: TYPE_NORMAL
- en: For us as security researchers and penetration testers, it can help identify
    security issues such as clear-text data transmission and also identifying which
    handles are being written and read during a network communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Ubertooth to sniff the connections from a given device following it,
    use the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Replace `[address]` with the address of the device, which we identified in the
    previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `[capture-output]` could either be a file or a pipe, in case we want to
    do an active traffic interception.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use `/tmp/pipe` as a capture interface with one end of the pipe getting
    input data from the Ubertooth and the other end of the pipe showing the data in
    Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, open up another terminal window and type in mkfifo `/tmp/pipe`.
    Once done, go to Wireshark | Capture Interfaces | Manage Interface | New Interface
    | Pipes and add the value `/tmp/pipe` and save the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, start sniffing on the `/tmp/pipe` interface in Wireshark, which you have
    just created. Depending on the action you are performing and your target device,
    you will be able to see the BLE traffic show up in Wireshark, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/49e2fa34-64cb-409a-b61b-b99733d53d88.png)'
  prefs: []
  type: TYPE_IMG
- en: We have also applied a filter in the preceding screenshot of `btl2cap.cid==0x004`
    to ensure that we get the packets which have useful data. As you can also see
    in the image, we have got a number of read/write requests, along with details
    of the handles and the value that was written to that specific handle. In this
    case, the handle 0x0037 and the value 1 correspond to unlocking of a BLE-based
    smart lock.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what value is being written to the handle in order to perform
    a specific action, we can write that particular handle ourselves, without the
    need for Ubertooth. For this, we will use the BLE adapter dongle and a utility
    called `gatttool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, launch up `gatttool`, as shown next, along with the `-b` and `-I`
    flags providing the Bluetooth address and specifying it open in interactive mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, all we need to do here is send a write request to the target device specifying
    the value that we want to write to the handle, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c233db9-2548-42cc-b0dd-693406dd2ad4.png)'
  prefs: []
  type: TYPE_IMG
- en: This has unlocked the smart lock since the smart lock detected that the handle
    `0x0037` now has the value of `01`, which is related to the state of smart lock
    being unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: This is how you can interact with a BLE-based IoT device, figure out which handles
    are being written and then write those handles yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also look at other properties of the device by looking at all the values
    of services, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6b20658-7c73-4558-84a7-0ed9256ff595.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This can also be done for characteristics, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab8644cf-8f85-4823-8441-5cd24cf6ad3d.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sniff BLE traffic effectively, it is important to identify the device which
    could be advertising on any of the three advertising channels. For this, it is
    important to have a setup of three Ubertooths rather than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, some of the other tools you can try out are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**btlejuice**: This is a handy tool if you would like to perform MITM on BLE
    traffic with a web GUI interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gattacker**: This is similar to `btlejuice` but without a GUI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BLEah**: This is a BLE info-gathering tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: Firmware Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing memory-corruption vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing firmware updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening embedded frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing third-party code and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedded software is the core of all that is considered IoT, although embedded
    application security is often not thought of as a high priority for embedded developers
    and IoT device makers. This may be due to the lack of secure coding knowledge
    or other challenges outside of a team''s code base. Other challenges developers
    face may include, but are not limited to, the **Original Design Manufacturer**
    (**ODM**) supply chain, limited memory, a small stack, and the challenge of pushing
    firmware updates securely to an endpoint. This chapter provides practical best
    practice guidance developers can incorporate in embedded firmware applications.
    As per OWASP''s Embedded Application Security project ([https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)),
    embedded best practices consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: Buffer and stack overflow protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection attack prevention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing firmware updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity management controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded framework and C-based toolchain hardening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of debugging code and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing device communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of data collection and storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing third-party code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threat modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will address several of the preceding mentioned best practices
    mostly tailored towards a POSIX environment, however the principles are designed
    to be platform agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing memory-corruption vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While using lower level languages such as C, there is a high chance of memory
    corruption bugs arising if bounds are not properly checked and validated by developers
    programmatically. Preventing the use of known dangerous functions and APIs aids
    against memory-corruption vulnerabilities within firmware. For example, a non-exhaustive
    list of known, unsafe C functions consists of: `strcat`, `strcpy`, `sprintf`,
    `scanf`, and `gets`. Common memory-corruption vulnerabilities such as buffer overflows
    or heap overflows can consist of overflowing the stack or the heap. The impact
    of these specific memory-corruption vulnerabilities when exploited differ per
    the operating system platform. For example, commercial RTOS platforms such as
    QNX Neutrino isolates each process and its stack from the filesystem minimizing
    the attack surface. However, for common Embedded Linux distributions this may
    not be the case. Buffer overflows in Embedded Linux may result in arbitrary execution
    of malicious code and modification to the operating system by an attacker. In
    this recipe, we will show how tools can help with detecting vulnerable C functions
    and also provide security controls along with best practices for preventing memory
    corruption vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following tool will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flawfinder**: Flawfinder is a free C/C++ static code analysis tool that reports
    potential security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common Linux utilities are helpful to search through C/C++ code files. Although,
    there are commercially available source code analysis tools available that do
    a much better job than common utilities to prevent from memory corruption vulnerabilities
    with IDE plugins developers can use. For demonstration purposes, we will show
    how to search through code files for a list of predefined function vulnerable
    calls and rules with grep as well as flawfinder in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To discover unsafe C functions, there are several methods that can be used.
    The simplest form is using a `grep`expression similar to the example shown as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This expression can be tweaked to be more intelligent or wrapped in a script
    that can be executed per build or on an ad-hoc basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, free tools such as `flawfinder` can be used to search for vulnerable
    functions by calling `flawfinder` and the path to the piece of code as shown in
    the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon discovery of vulnerable C functions in use, you must incorporate safe
    alternatives. For example, the following vulnerable code uses the unsafe `gets()`
    function that does not check buffer lengths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userid` can be overrun using any number of characters over `8` such as
    the **Buffer Overflow Exploit** (**BoF**) payload with custom execution functions.
    To mitigate overrunning the buffer, the `fgets()` function can be used as a safe
    alternative. The following example code shows how to securely use `fgets()` and
    allocate memory correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same mitigations can be used with other safe alternative functions such
    as `snprintf()`, `strlcpy()`, and `strlcat()`. Depending on the operating system
    platform, some of the safe alternatives may not be available. It is important
    to perform your own research to determine safe alternatives for your specific
    architecture and platform. Intel has created an open source cross-platform library
    called `safestringlib` to prevent the use of these insecure banned functions;
    use an alternative safe replacement function. For more details on `safestringlib`,
    visit the GitHub page at: [https://github.com/01org/safestringlib](https://github.com/01org/safestringlib).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other memory security controls can be used to prevent from memory-corruption
    vulnerabilities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make use of secure compiler flags such as -fPIE, -fstack-protector-all, -Wl,-z,noexecstack,
    -Wl,-z,noexecheap and others that may depend on your specific compiler version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer system-on-chips (SoC) and microcontrollers (MCU) that contain memory
    management units (MMU). MMUs isolate threads and processes to lessen the attack
    surface if a memory bug is exploited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer **system-on-chips** (**SoC**) and **microcontrollers** (**MCU**) that
    contain **memory protection units** (**MPU**). MPUs enforce access rules for memory
    and separate processes as well as enforce privilege rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no MMU or MPU is available, monitor the stack using a known bit to monitor
    how much the stack is being consumed by determining how much of the stack no longer
    contains the known bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be mindful what is being placed in buffers and free buffer locations after-use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting memory vulnerabilities with **address space layout randomization**
    (**ASLR**) and other stack controls does take a lot of effort for attackers to
    exploit. Although, it is still possible under certain circumstances. Ensuring
    code is resilient and incorporates a defense-in-depth approach for data placed
    in memory will help the secure posture of the embedded device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further secure memory management guidelines, reference Carnegie Mellon's
    Secure CERT C Coding Standard ([https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further secure memory management guidelines, reference Carnegie Mellon's
    Secure CERT C++ Coding Standard ([https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injection attacks are one of the top vulnerabilities in any web application
    but especially in IoT systems. In fact, injection has been rated in the top 2
    of the OWASP Top 10 since 2010\. There are many types of injection attacks such
    as **operating system** (**OS**) command injection, cross-site scripting (for
    example, JavaScript injection), SQL injection, log injection, as well as others
    such as expression language injection. In IoT and embedded systems, the most common
    types of injection attacks are OS command injection; when an application accepts
    an untrusted user input and passes that value to perform a shell command without
    input validation or proper escaping and cross-site scripting (XSS). This recipe
    will show you how to mitigate command injection attacks by ensuring all untrusted
    data and user input is validated, sanitized, and alternative safe functions are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command injection vulnerabilities are not difficult to test for statics and
    dynamics when an IoT device is running. Firmware can call `system()`, `exec()` and
    similar variants to execute OS commands, or call an external script that runs
    OS calls from interpreted languages such as Lua. Command injection vulnerabilities
    can arise from buffer overflows as well. The following steps and examples show
    code vulnerable to command injection as well as how to mitigate from a command
    injection. Afterwards, we will list common security controls to prevent common
    injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet of code invokes the dangerous `system()` C function to
    remove the `.cfg` file in the `home` directory. In the event an attacker has the
    ability to control the function, subsequent shell commands may be concatenated
    to perform unauthorized actions. Additionally, an attacker can manipulate environment
    variables to delete any files ending in `.cfg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To mitigate the preceding vulnerable code, the `unlink()` function will be
    used instead of the `system()` function. The `unlink()` function is not susceptible
    to symlink and command injection attacks. The `unlink()` function removes the
    symlink and does not affect files or directories named by the contents of the
    symlink. This reduces the susceptibility of the `unlink()` function to symlink
    attacks, however it does not thwart symlink attacks in their entirety; if a named
    directory is the same, it could also be deleted. The `unlink()` function does
    thwart from command injection attacks and similar contextual functions should
    be used rather than executing operating system calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several other methods to mitigate from injection attacks. Below are
    a list of common best practices and controls for preventing injection attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid invoking OS calls directly if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If needed, whitelist accepted commands and validate the input values prior to
    execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lookup maps of numbers-to-command-strings for user driven strings that may
    be passed to the operating system such as `{1:ping -c 5}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform static code analysis on code bases and alert when languages us OS commands
    such as `os.system()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider all user input as untrusted and output encode characters for data rendered
    back to the user. (for example, `Convert & to &amp`, `Convert < to &lt`, `Convert
    > to &gt`, and so on.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For XSS, use HTTP response headers such as X-XSS-Protection and Content-Security-Policy
    with the appropriate directives configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure debug interfaces with command execution are disabled on production firmware
    builds (for example, [http://example.com/command.php](http://example.com/command.php)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding mentioned controls always require testing prior to firmware being
    used in a production environment. With injection attacks, devices and users are
    put at risk of being taken over by attackers as well as rouge devices. We are
    seeing such events happening in 2017 with IoT Reaper and Persirai botnets. This
    is only the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further injection prevention guidelines and considerations, reference OWASP's
    Embedded Application Security Project ([https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security))
    and OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet [https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing firmware updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the industry, only authorized firmware from the manufacturer, supplier,
    or enterprise should be flashed onto the device. To ensure this takes place, a
    robust update mechanism must be used upon download, of firmware and when applicable,
    for updating functions pertaining to third-party software or libraries. A cryptographic
    signature should be used for all firmware to allow for verification that files
    have not been modified or otherwise tampered with since the developer created
    and signed them. The signing and verification process uses public-key cryptography
    and it is difficult to forge a digital signature (for example, a PGP signature)
    without first gaining access to the private key. When using public-key cryptography,
    it must be stored securely and not exposed to unintended parties. In the event
    a private key is compromised, developers of the software must revoke the compromised
    key and will need to re-sign all previous firmware releases with the new key.
    This has been a problem for many IoT products already requiring users to send
    back their device or towing vehicles into service shops. The implementation for
    securing firmware updates does vary depending on the industry in which an IoT
    device is being deployed. For instance, some products may have **over the air**
    (**OTA**) updates while others may need to be updated manually via a USB or through
    an interface that loads the new firmware image. For some common consumer grade
    IoT devices, this may not be as big of an issue, however if unauthorized malicious
    firmware is loaded onto a connected vehicle or medical device, the repercussions
    can be deadly. This recipe will list features that can be used to secure firmware
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many variables and considerations to take into account when implementing
    a secure update ecosystem for embedded IoT devices. Certain architectures, SoCs,
    or bootloaders may not have the ability to perform all the required actions to
    employ a resilient firmware update system. Due to the complexity and variations
    in employing a secure update system, we will address high-level actions manufacturers
    should incorporate into their firmware update design. For simplicity, we will
    use Embedded Linux as our platform and provide the requirements needed for a secure
    update system. Again, not all the following requirements may be feasible, however
    it is important for the device manufacturer to perform their due diligence and
    understand the risks when employing a secure update system. The following list
    are security controls and requirements for securing firmware updates.
  prefs: []
  type: TYPE_NORMAL
- en: Implement secure boot or verified boot for bootloaders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Safeguard secure boot keys using a secure hardware chip (for example, TPM, HSM,
    secure element).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure robust update mechanisms utilize cryptographically signed firmware images
    for updating functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Images must be validated after download and upon flashing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure updates are downloaded over the most recent secure TLS version possible
    (at time of writing, this is TLS 1.2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure updates validate the public key and certificate the chain of the update
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Include a feature to utilize automatic firmware updates on a predefined schedule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Force updates in highly vulnerable use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled push updates should be taken into consideration for certain devices,
    such as medical devices, to prevent forced updates from creating possible issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure firmware versions are clearly displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure firmware updates include changelogs with security related vulnerabilities
    included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notify customers of new firmware when available via emails, app notifications,
    or upon login to applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure an anti-downgrade protection (anti-rollback) mechanism is employed so
    that the device cannot be reverted to a vulnerable firmware version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider implementing an **Integrity Measurement Architecture** (**IMA**) which
    allows the kernel to check that a file has not been changed by validating it against
    a stored/calculated hash (called a label). An **Extended Verification Module**
    (**EVM**) checks the file attributes (including the extended ones).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two types of labels available:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and signed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider implementing a read-only root file system with an overlay that can
    be created for directories which need local persistence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A secure update system is heavily dependent on public key cryptography for signing
    and verifying firmware images. This requires infrastructure and administration
    to maintain the lifecycle of the device's signing and verification keys. In the
    event a key is compromised or needs to be updated, it should be tested prior to
    production deployment to prevent the bricking of a device. With that being said,
    there are third-party companies that offer **firmware over the air** (**FOTA**)
    update services that shift liability to the service provider. This can be expensive
    for products such as connected vehicles with manufacturers having to foot the
    network data bill. There are frameworks that should be considered when choosing
    an update mechanism such as The Update Framework ([https://theupdateframework.github.io/](https://theupdateframework.github.io/))
    and Uptane ([https://uptane.github.io/](https://uptane.github.io/)) for connected
    vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: Securing sensitive information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With limited storage and slim margins, securing sensitive data can be a challenge
    for IoT devices. Often, sensitive data is stored on a client application or device
    so an IoT service can function without an internet connection. There are secure
    principles to be followed when securing sensitive data on a device. First, never
    hardcode secrets into firmware images such as passwords, usernames, tokens, private
    keys, or similar variants, into firmware release images. This also includes the
    storage of sensitive data that is written to a disk. This data will be accessible
    to attackers upon extracting firmware filesystems as well as when accessing the
    operating system during runtime. If hardware such as a **security element** (**SE**)
    or **Trusted Execution Environment** (**TEE**) is available, it is recommended
    to use such features for storing sensitive data during runtime. Otherwise, use
    of strong cryptography should be evaluated to protect the data using server-side
    computations to compensate for hardware limitations.
  prefs: []
  type: TYPE_NORMAL
- en: If possible, all sensitive data in clear-text should be ephemeral by nature
    and reside in a volatile memory only. This recipe will give you some scenarios
    where data is used insecurely and how you can mitigate the insecure C code within
    an IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using programmatic examples, we will show how data is stored insecurely and
    how to remediate storage vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, sensitive information is insecurely stored in the
    dynamically allocated memory referenced by `key`, which is copied to the dynamically
    allocated buffer, `new_key`, then processed and eventually deallocated by a call
    to `free()`. Because the memory is not cleared, it may be reallocated to another
    section of the program where the information stored in `new_key` may be inadvertently
    leaked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent this information leakage from occurring, dynamic memory containing
    sensitive information should be sanitized before being freed. Sanitization is
    commonly carried out by clearing the allocated space with `''\0''` characters,
    also known as zero out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be used in cases where devices do not have a hardware
    security chip available to separate OS processes and memory locations. Without
    a hardware security chip (for example, TPM or SE), or a TEE environment for ARM
    architectures, storing data securely is a challenge for embedded devices. Sometimes
    developers may store sensitive data in different storage partitions not available
    to the platform operating system however this is not a safe storage location either.
    Often, flash chips can be removed from PCB boards and taken to an offline location
    to be reviewed or data exfiltrated.
  prefs: []
  type: TYPE_NORMAL
- en: New frameworks and OS platforms are being created to help solve this problem
    to store sensitive data. If an ARM Mbed OS is used, a device security layer called
    uVisor can be leveraged to isolate code blocks by limiting access to memory via
    hardware security features. Although Mbed is in its infancy, it has strong backing
    from large semiconductor companies and contains a platform for not only its operating
    system, but also cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Details on uVisor can be found at the following site:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.mbed.com/en/technologies/security/uvisor/](https://www.mbed.com/en/technologies/security/uvisor/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example code usage for uVisor can be found in the GitHub repository via the
    following URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ARMmbed/mbed-os-example-uvisor-number-store](https://github.com/ARMmbed/mbed-os-example-uvisor-number-store)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Mbed OS, visit their site at the following URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.mbed.com](https://www.mbed.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Hardening embedded frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing and building embedded firmware can be complex, with all its dependencies
    and spaghetti makefiles that have not been touched for decades. Despite these
    common complexities, establishing a foundation to build secure software starts
    with the hardening of the platform and toolchain. Many Embedded Linux devices
    use BusyBox which contains common GNU utilities. There are certain configurations
    to be made to BusyBox and also updates for it as well. In addition to BusyBox,
    embedded frameworks, and toolchains should be modified to only those libraries
    and functions being used when configuring firmware builds. RTOS systems often
    have POSIX utilities available as well but configured by SoC, MCU, and chip vendors
    who have modified versions of common utilities. Embedded Linux build systems such
    as Buildroot, Yocto, and others perform the task of setting up and configuring
    the toolchain environment. Removal of known insecure libraries and protocols such
    as Telnet not only minimize attack entry points in firmware builds, but also provide
    a secure-by-design approach to building software an effort to thwart potential
    security threats. In this recipe, we will show how to use Buildroot to select
    and deselect network services and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, Buildroot will be used to demonstrate hardening.
  prefs: []
  type: TYPE_NORMAL
- en: '**Buildroot** is a tool used to generate Embedded Linux systems through cross-compilation.
    Buildroot can be downloaded via the following site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://buildroot.uclibc.org/download.html](https://buildroot.uclibc.org/download.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first start with using Buildroot and opening up its menu options for
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Buildroot is downloaded, run the following command in the root of the
    Buildroot folder to show Buildroot''s configuration options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Other configuration user interfaces are available depending on preference,
    such as `xconfig`, and `gconfig`. For additional details, review Buildroot''s
    user manual at: [https://buildroot.uclibc.org/downloads/manual/manual.html](https://buildroot.uclibc.org/downloads/manual/manual.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b940eca2-6c98-4eb7-bb84-81d5036264c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, configurations to a Linux firmware image can be made. For our purposes,
    we will walk you through how to choose secure daemons and secure defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, navigate to the Toolchain menu and enable stack protection support which
    uses the `-fstack-protector-all` build flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98ad6f32-da38-4355-bcc3-5bf03a4093b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to the home menu screen and enter the System configuration menu. Select
    Passwords encoding and choose sha-512:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8429a2f7-cb90-4549-b4c2-af3060a1aeaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While in the System configuration page, we can create the root password for
    the firmware image. Here, we want to use a long alphanumeric password such as
    the one shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02cc8e17-c5c0-4e6b-a11d-4f31a8229a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Exit the System configuration menu and navigate to the Target packages menu
    option. Here, we can specify tools, libraries, daemons, and third-party code to
    include in a firmware image. There are many selections available depending on
    the device, so we will only use an example. The following screenshot shows openssh
    selected rather than Telnet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only enable FTP if TLS is to be used. For Pure-FTPd, this requires custom compilation
    by passing `./configure --with-tls`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d0fd502-8aa7-42d4-9f97-4fb750e13a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate back to the Target packages menu and select the Shell and utilities
    submenu. Here, ensure only one shell interpreter is selected to decrease the attack
    surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ee86680-4a80-4eb3-9ea8-418ed861e5cb.png)'
  prefs: []
  type: TYPE_IMG
- en: After all options have been selected, you would save your configuration, and
    select exit to leave the menuconfig options. Then, enter `make` from the Buildroot
    folder to build your configuration and toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar steps can be taken when using the Yocto build system by ensuring recipes
    are updated and configured with only the required packages. There are several
    other configurations that can be made to harden the Linux build environment, that
    consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing unused language interpreters such as Perl, Python, and Lua.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing dead code from unused library functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing legacy insecure daemons, which includes but is not limited to Telnet,
    FTP, and TFTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove unused shell utilities from Busybox such as grep, awk, wget, curl and
    sed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hardening a library or service to support encryption.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensuring all packages and libraries chosen for a build are using the most up-to-date
    versions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the latest Linux kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable IPv4 Forwarding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable IP Source Routing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable ICMP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ignore all broadcast message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable IPV6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable TCP SYN Cookie Protection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Linux Security Modules (including SELinux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use free tools such as Lynis ([https://raw.githubusercontent.com/CISOfy/lynis/master/lynis](https://raw.githubusercontent.com/CISOfy/lynis/master/lynis))
    for hardening suggestions after the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding list is by no means exhaustive. Performing iterative threat model
    exercises with developers, as well as relative stakeholders, on software running
    on the embedded device ensures low hanging fruit such as vulnerable outdated software,
    and is not introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Securing third-party code and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the setup of the toolchain, it is important to ensure that the software
    packages and third-party upstream libraries remain updated to protect against
    publicly known vulnerabilities once the IoT device is in production. Black box
    third-party software such as RomPager, NetUSB, and embedded build tools such as
    Buildroot, should be checked against vulnerability databases as well as their
    changelogs to decide when and if an update is needed. using upstream BSP drivers
    is not an easy task; changes to libraries and upstream BSP drivers should be tested
    by development teams prior to release builds, as updates can cause unforeseen
    dependency issues.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded projects and applications should maintain a Bill of Materials (BOM)
    of the third-party libraries and open source software included in its firmware
    images. This is sometimes a requirement for certain regulated regions of the world
    and also for GPL but maintaining a BOM also improves management of assets as well
    as libraries. This Bill of Materials should be checked to confirm that none of
    the third-party software included has any unpatched vulnerabilities or known issues.
    Up-to-date vulnerability information may be found through the **National Vulnerability
    Database** (**NVD**), Open Hub or similar third-party sites.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to ensure all unnecessary pre-production build code, as well
    as dead and unused application code, have been removed prior to firmware release
    to all market segments. This includes, but is not limited to, potential backdoor
    code and root privilege accounts that may have been left by parties such as **Original
    Design Manufacturers** (**ODMs**), suppliers, and third-party contractors for
    testing or customer support purposes. Generally, this falls within the scope of
    **Original Equipment Manufacturers** (**OEMs**) to perform, via reverse engineering
    of binaries using the methodology described in [Chapter 3](f0b26a31-570b-4a51-9519-cdfb567cb1cb.xhtml),
    *Analyzing and Exploiting Firmware*. To prevent the extra labor overhead by OEMs,
    ODMs should agree to a **Master Service Agreements** (**MSAs**), ensuring that
    no backdoor code or user accounts are included and that all code has been reviewed
    for software security vulnerabilities holding third-party developer companies
    accountable for devices that are mass deployed to the market. Additionally, consider
    verbiage that requires ODMs to have information security personnel on staff as
    well as establishing a service level agreement (SLA) to fix critical security
    vulnerabilities. This recipe will show you the methods of securing third-party
    code and components using freely available tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tools are required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RetireJS**: RetireJS detects the use of JavaScript libraries with known vulnerabilities.
    RetireJS can be downloaded via its GitHub repository ([https://github.com/RetireJS/retire.js](https://github.com/RetireJS/retire.js))
    or via `npm` using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Node Security Platform** (**NSP**): NSP detects the use of known vulnerable
    NodeJS packages for a project. NSP can be installed via its GitHub repository
    ([https://github.com/nodesecurity/nsp](https://github.com/nodesecurity/nsp)) or
    via `npm` using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**LibScanner**: LibScanner is a free tool that parses RPM or SWID package lists
    against the NVD databases used for Yocto build environments. LibScanner can be
    downloaded from its GitHub repository at [https://github.com/DanBeard/LibScanner](https://github.com/DanBeard/LibScanner).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many IoT devices run variations of JavaScript code to help alleviate hardware
    resource consumption. Sometimes, this code is also running on the device when
    it needs to act as a server for certain use cases. There are great tools that
    scan project directories for known vulnerable JavaScript versions used in the
    project. First, we will have a look at RetireJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run RetireJS, simply run the `retire` command and specify the JavaScript
    directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The scan found two vulnerable jQuery libraries used in the project, along with
    supplemental reading as well as explanations. These findings may have opened up
    the device to an attack in the future, but it is much cheaper to discover these
    types of issues prior to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great NodeJS vulnerability scanner is NSP. Like RetireJS, NSP can be executed
    by calling `nsp` and the path to the NodeJS project directory or `packages.json`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: NSP discovered a vulnerable library that could have exposed the device to a
    commend injection, a common vulnerability in IoT.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the IoT device''s build system is using Yocto, the free LibScanner tool
    can be used to query the NVD database against known vulnerable libraries that
    are in the project''s installed packages list. To get started with LibScanner,
    update the vulnerability database by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the NVD database is updated, run LibScanner against the Yocto `installed-packages.txt`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, review the `cve_results.xml` file which contains not only the
    scan results of vulnerable files but also unit tests in xUnit format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are several tools that can perform static tasks prior to a device's build
    or dynamic checks that run after a device build and during the device's runtime.
    In previous chapters, dynamic tools have been discussed such as OWASP ZAP for
    web application testing, as well as tools such as Lynis, which can be run directly
    on the device's command-line interface. All of these tighten up the security posture
    of the device and minimize the likelihood of a successful attack on the device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed several best practices to be incorporated in building
    as well as writing firmware. It is recommended to perform your own due diligence
    according to your operating system platform (that is, Embedded Linux, RTOS, Windows
    IoT, and so on.) for specific security controls relevant to your IoT device.
  prefs: []
  type: TYPE_NORMAL

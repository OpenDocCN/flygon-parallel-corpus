- en: '*Chapter 9*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use exception-throwing libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use exception handling effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire and release resources in a way that respects exceptions without creating
    leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement best practices to incorporate exceptions in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is a powerful mechanism for handling erroneous cases that
    occur while our code is running. It enables us to focus on the main execution
    of the program and separate the error-handling code from the expected execution
    path. The Java language forces programmers to write exception-handling code for
    library methods, and IDEs such as IntelliJ, Eclipse, and so on help us generate
    the boilerplate code necessary. However, without proper guidance and understanding,
    standard exception codes may result in more harm than good. This lesson is a practical
    introduction to exceptions that will push you to contemplate various aspects of
    exception handling, and will provide a number of rules of thumb that may be helpful
    when you are dealing with exceptions in your programming life.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation behind Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are creating programs, we usually focus on expected scenarios. For
    example, we will get the data from somewhere, we will extract certain information
    from the data that we assume to be there, we will send it to somewhere else, and
    so on. We would like our code to be readable, so that members of our team can
    clearly understand the business logic and can spot mistakes that we may make.
    However, in practice, our assumptions may not hold and there can be deviations
    from expected scenarios. For example, we may not be able to get data because of
    a problem with the network or the disk. We may receive data that does not fit
    our assumptions. Or, we may not be able to send data because of similar problems.
    We have to create programs that behave gracefully in unexpected situations. For
    example: we should enable the user to retry on a broken network connection. Exceptions
    are the way we handle such situations in Java without making our code too complex.'
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we have to write code that will run well in various unexpected
    situations. However, we also want our code to be clean and understandable. These
    two goals can often compete with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to write code that reads clearly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This reflects an optimistic scenario, in which nothing unexpected occurs. However,
    it is often the case that unexpected situations occur. The user''s internet connection
    may be down, a web resource may be down, the client may run out of memory, a disk
    error may occur, and so on. Unless we write code that anticipates these problems,
    our programs may crash when such problems arise. It would be quite difficult to
    anticipate every kind of problem that may happen. Even if we simplify things and
    treat most errors the same way, we still may have to carry out many checks on
    our code. For example: we may have to write code that looks more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can come up with alternative code structures, but once you incorporate the
    extra code to handle errors at every step, your code becomes less readable, less
    understandable, and less maintainable. If you do not include such error-handling
    code, your programs may result in unwanted situations such as crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a function in C that handles errors similar to our preceding pseudo
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you code using primitive languages such as C, you inevitably feel strong
    tension between readability and completeness. Luckily, in most modern programming
    languages, we have exception handling capabilities that reduce this tension. Your
    code can both be readable and can handle errors at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The main language construct behind exception handling is the `try-catch` block.
    The code you put after the try is executed line by line. If any of the lines result
    in an error, the rest of the lines in the try block are not executed and the execution
    goes to the catch block, giving you a chance to handle the error gracefully. Here,
    you receive an exception object that contains detailed information about the problem.
    However, if no error happens in the try block, the catch block is never executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we modify our initial example to handle errors using the try-catch block
    instead of many `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, our code is placed between the try and catch keywords. Our
    code is free from error-handling code that would otherwise prevent readability.
    The default expected path of the code is quite clear: step 1, step 2, and step
    3\. However, if an error happens, the execution moves to the catch block immediately.
    There, we receive information about what the problem was in the form of an exception
    object and we are given a chance to handle the error gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, you will have code pieces that depend on one another. So,
    if an error happens in one of the steps, you usually do not want to execute the
    rest of the steps, since they depend on the success of that earlier step. You
    can use `try-catch` blocks creatively to denote code dependencies. For example:
    in the following pseudo code, there are errors in steps 2 and step 5\. The steps
    that successfully get executed are steps 1 and 4\. Since step 4 and later steps
    are independent of the success of the first three steps, we were able to denote
    their dependencies with two separate `try` - `catch` blocks. The error in step
    2 prevented the execution of step 3, but not step 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If there is an exception and you do not catch it, the error will be propagated
    to the caller. If this is your application, you should never let errors propagate
    out of your code, to prevent your app from crashing. However, if you are developing
    a library that is called by other code, letting errors propagate to the caller
    is sometimes a good idea. We will discuss this in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 36: Introducing Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s actually see exceptions in action. One of the canonical exceptions
    is to try to divide a number by zero. Here, we will use it to create exceptions
    and verify our pseudo code from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Main` class and add the main method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Write code to print the result of the division of two numbers. Add the `try`
    – `catch` block to handle the exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and verify that the output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that results 2 and 5 contain division operations in which we divide a
    number by zero, which results in an exception. This way, we are intentionally
    creating exceptions in these two lines to see how execution progresses in the
    case of exceptions. Here is a breakdown of the expected execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Result 1 should print well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During result 2's execution we should get an exception, which should prevent
    result 2 from printing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the exception, execution should jump to the catch block, which should
    prevent result 3 from printing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result 4 should print well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like result 2, during result 5's execution we should get an exception,
    which should prevent result 5 from printing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, because of the exception, the execution should jump to the catch
    block, which should prevent result 6 from printing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of the two `try-catch` blocks, we should skip results 3 and 6
    because of the exceptions on results 2 and 5\. This should leave only results
    1 and 4, which will be executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that our preceding discussion was correct. Also, to verify the execution
    order, place a breakpoint in the result 1 line and click step over to watch how
    execution progresses step by step with the `try` - `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of exceptions and the `try-catch` block, we are able to write
    code that focuses more on the expected default execution path, while ensuring
    that we handle unexpected error cases and can recover or fail gracefully, depending
    on the severity of the error.
  prefs: []
  type: TYPE_NORMAL
- en: An Inevitable Introduction to Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Practically, most newbie Java developers meet with exceptions when they call
    an exception-throwing method from a library. Such a method can specify that it
    throws an exception using the throws statement. When you call this kind of method,
    your code will not compile unless you write code that does something about the
    exception that the method may throw.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a newbie Java developer, all you wanted was to call a method and now
    you are forced to do something about an exception that it may throw. Your IDE
    can generate code that takes care of the exception. However, default generated
    code is usually not the best. A newbie with no guidance and the powers of IDE
    code generation can create code that is quite bad. In this section, you will be
    guided on how best to use IDE-generated exception-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you wrote the following code to open and read a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, your code will not compile and your IDE underlined the `FileInputStream`
    constructor in red. This is because it may throw an exception, as specified in
    its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your IDE usually tries to be helpful. When you move the caret
    on to `FileInputStream` and hit *Alt* + *Enter* in IntelliJ, for example, you
    will see two quick-fix options: **Add exception to method signature** and **Surround
    with try/catch**. These correspond to the two options you have when dealing with
    specified exceptions, which we will learn about later in more depth. Here''s what
    the first option converts your code into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now your main function also specifies that it can throw an exception. Such an
    exception causes the program to exit immediately, which may or may not be what
    you want. If this was a function that you give others as a library, this change
    would prevent their code from compiling, unless they, in turn, did something about
    the specified exception, just like you. Again, this may or may not be what you
    want to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you selected "**Surround with try/catch**", which was the second option
    that IntelliJ provided, here is what your code would become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are writing code to handle the exception ourselves. This
    feels more appropriate; we are taking responsibility and writing code to do something
    about the exception. However, the code in its current form does more harm than
    good. First of all, it does not actually do anything useful with the exception;
    it just catches it, prints information about it to `stdout`, and continues the
    execution as if nothing happened. Especially in a project that is not a console
    application (like most Java programs), printing to the logs is hardly useful.
  prefs: []
  type: TYPE_NORMAL
- en: If we cannot find this file to open, we should think cleverly about what we
    can do. Should we ask the user to look for the file? Should we download it from
    the internet? Whatever we do, taking a note in an obscure log file and sweeping
    the problem under the rug is probably one of the worst ways to handle the problem.
    If we cannot do anything useful, maybe not handling the exception and letting
    our caller deal with it would be a more honest way of dealing with the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there is no silver bullet, or one-size-fits-all suggestion here.
    Every exceptional case, every application, every context, and every user base
    is different, and we should come up with an exception handling strategy that fits
    the current situation best. However, if all you are doing is `e.printStackTrace()`,
    you are probably doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 37: Using an IDE to Generate Exception-Handling Code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will have a look at generating exception handling code
    using an IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java console project in IntelliJ. Import `File` and the `FileInputStream`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class called `Main` and add the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in four places, IntelliJ underlines our code in red. These are functions
    that specify throwing an exception. This prevents your code from executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the first issue (`FileInputStream`), press *Alt* + *Enter*, and select
    "`main` function can throw `FileNotFoundException`, but this was not enough as
    this is not the exception type that the other functions throw. Now go to the first
    remaining issue (`read`), press *Alt* + *Enter*, and select "`input.txt` in the
    meantime, this is what you should see as an output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The exception propagated out of our main function and the JVM caught it and
    logged into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things happened here. First, fixing the problem for `read()` was enough
    to eliminate all problems from the code, since both `read` and `close` throw the
    same exception: `IOException`, which is listed in the throws statement in the
    main function''s declaration. However, the `FileNotFoundException` exception that
    we had listed there disappeared. Why?'
  prefs: []
  type: TYPE_NORMAL
- en: This is because exception classes are in a hierarchy and `IOException` is an
    ancestor class of `FileNotFoundException`. Since every `FileNotFoundException`
    is also an `IOException`, specifying `IOException` was enough. If these two classes
    were not related in that way, IntelliJ would list the possible thrown exceptions
    as a comma-separated list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s provide the `input.txt` to our program. You can create the `input.txt`
    anywhere in your hard drive and provide a full path in the code; however, we will
    use a simple approach: IntelliJ runs your program inside the main project folder.
    Right-click on your project''s `input.txt` file here and write the text "`abc`"
    in it. If you run your program again, you should see an output similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the exceptions was one way to make our program work. Another would
    be to catch them. Let''s try that now. Go back to the following version of your
    file; you can use undo repeatedly to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now move the caret on to `FileInputStream`, hit *Alt* + *Enter*, and select
    "`try/catch` block, it actually separated the creation of the reference variable
    from the exception-generating constructor call. This is mainly because `fileInputStream`
    is used later in the code and moving it inside the `try/catch` block would prevent
    it from being visible to those usages. This is actually a common pattern; you
    declare the variable before the `try/catch` block, handle any issues with its
    creation, and make it available for later, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The current code has a problem: if the `FileInputStream` inside the `try/catch`
    block fails, the `fileInputStream` will continue to be null. After the `try`/`catch`
    block, it will be dereferenced and you will get a null reference exception. You
    have two options: either you place all usages of the object in the `try/catch`
    block, or you check the reference for null. Here is the first of the two options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We moved the code inside the `try`/ `catch` block to make sure we don''t dereference
    `fileInputStream` while null. However, we still have red underlines under `read()`
    and `close()`. *Alt* + *Enter* on `read()` gives you a couple of options, the
    first of which is to add a `catch` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we have fixed all of the issues with our code and we can actually run it.
    Notice that the second catch clause is placed after the first, because `IOException`
    is a parent class of `FileNotFoundException`. If their order was the other way
    around, exceptions of type `FileNotFoundException` would actually be caught by
    the `IOException` catch block instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second of the two options, not placing all the code inside the
    first try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We run the second part of the code if the `fileInputStream` is not null. This
    way, we prevent the second part from running if creating the `FileInputStream`
    was not successful. It does not make a lot of sense to write it separately like
    this, but it would make sense if there was other code in between that is unrelated.
    You cannot put everything in the same `try` block, and in a later code, you may
    have to depend on that `try` block's success. A simple null check such as this
    is useful in that sense.
  prefs: []
  type: TYPE_NORMAL
- en: Our code still has issues, though. Let's *Alt* + *Enter* on the `read()` and
    `close()`, and select `try`/`catch` blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A better way would be to place the whole block in a `try`/`catch`. In this
    case, we are giving up after the first error, which is a simpler and usually more
    correct approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To create this code, we did not rely on IntelliJ's quick fix with *Alt* + *Enter*.
    Since it's quite good usually, you may think that the code it creates is correct.
    However, you have to use your judgement, and sometimes correct the code it creates,
    as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have experienced the quick and dirty handling of exceptions using the
    help of an IDE. The skills you gained in this section should guide you when you
    are on a deadline and help you avoid pitfalls when using autogenerated exception
    code using an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions versus Error Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall the C code example that we gave earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of drawbacks to the method of handling errors used here.
    In this code, all we are trying to do is call three functions. However, for each
    function call, we are passing around values to track error states and using `if`
    statements for each function call if there was an error. Furthermore, the return
    value of the function is the error state—you are not allowed to return a value
    of your choosing. All this extra work dilutes the original code and makes it difficult
    to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of this approach is that a single integer value may not represent
    the error sufficiently. Instead, we may want to have more details about the error,
    when it happened, about which resource, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before exception handling, this was how programmers had to code to ensure the
    completeness of their programs. Exception handling brings a number of benefits.
    Consider this alternate Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the three function calls without any error-related code polluting
    them. These are placed in a `try`/`catch` block and error handling is done separately
    from the original code in the `catch` blocks. This is more desirable for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not have to have an `if` statement for each function call. We can group
    the exception handling in one place. It does not matter which function raised
    the exception; we catch all of them in one single place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is not only one kind of problem that can happen in a function. Each function
    can raise more than one kind of exception. These can be handled in separate catch
    blocks, whereas, without exception handling, this would have required multiple
    if statements per function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exception is represented by an object, not a single integer value. While
    an integer can tell us which kind of problem it was, an object can tell us much
    more: the call stack at the time of exception, the related resource, the user-readable
    explanation about the problem, and so on, can all be provided along with the exception
    object. This makes it much easier to act appropriately to exceptions compared
    to a single integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 38: Exceptions Versus Error Codes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To complete the discussion about exceptions versus error codes, let''s experience
    both and see which one is simpler to deal with. In this exercise, we have a class
    with two different kinds of functions, with two functions in each kind. The `thFunction1()`
    and `thFunction2()` are functions that can throw exceptions upon errors. `ecFunction1()`
    and `ecFunction2()` are functions that return a value that indicates whether there
    was an error. We are using random numbers to simulate that errors occur sometimes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `IOException` and `Random` classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class called `Main` with an instance of the `Random` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `thFunction1()` and `thFunction2()` functions, which throw an `IOException`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare three variables with final values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two functions, `ecFunction1()` and `ecFunction2()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `callThrowingFunctions()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method called `callErrorCodeFunctions()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In our `main` function, we are first calling the throwing functions, followed
    by the error code functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this program a couple of times to observe how errors are handled in each
    case. Here is an example of an error caught using exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that `thFunction2` was started, but not completed. The exception that it
    threw contained information about `thFunction2`. The shared `catch` block did
    not have to know where this exception was coming from; it simply caught the exception.
    This way, a single exception-catching block was able to handle multiple function
    calls. The exception object that was thrown by `thFunction2` and was caught by
    the catch block is able to transfer detailed information about the problem (for
    example, the stack trace). This leaves the default expected execution path clean,
    and the exception-catching block can deal with the problem in a meticulous way.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, take a look at this sample execution output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In `ecFunction1`, an unexpected error occurred. This was signaled simply by
    an error code value that was returned from this function. Note that this function
    could not have returned any other value; employee number, whether something is
    active, and so on, are some examples of things that a function might return. Using
    error codes returned from functions in this way prohibits passing such information
    in the return value.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since the error is represented simply by a number, we are not able
    to get detailed information in the error-handling code. We also have to have error-handling
    code for each function call, as we would not have a way of differentiating between
    error locations otherwise. This creates code that is much more complicated and
    verbose than it should be.
  prefs: []
  type: TYPE_NORMAL
- en: Play with the code further, run it many times, and observe its behavior. This
    should give you a better understanding of exceptions versus error codes and why
    exceptions are superior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 36: Handling Mistakes in Numeric User Input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we will make use of exception handling in a real-world scenario. We will
    create a console application in which we ask for three whole numbers from the
    user, add them together, and print the result. If the user does not enter non-numeric
    text or a fractional number, we will ask the user to provide a whole number instead.
    We will do this for each number separately—a mistake in the third number will
    only require us to re-enter the third number and our program will remember the
    first two numbers just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty Java console project. Place the following code in it, which
    reads input from the keyboard and prints it back after the user hits the *Enter*
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this as a starting point and convert the input to a number using the `Integer.parseInt()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the IDE did not warn us about a possible exception, unlike what
    we had in the earlier examples. This is because there are two types of exceptions,
    which we will learn about in an upcoming topic. For now, be aware that `Integer.parseInt()`
    can raise `java.lang.NumberFormatException`. Using the things we learned before
    wrap this line with a `try/catch` block that expects `NumberFormatException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now place this in a `while` loop. It should loop while we do not have a valid
    whole number (integer) input from the user. Once we have such a value, the `while`
    loop should not loop anymore. If the user does not enter a valid whole number,
    print out an appropriate message to the user. Do not print out a raw exception
    message or a stack trace. This way, we insist that we get a whole number from
    the user and will not give up until we get a whole number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this strategy, get three whole numbers in and sum them up. The program
    should ask again and again if you do not provide a valid whole number for any
    of the inputs. Print the result to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 365.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exceptional case occurs in code, an exception object is thrown by the
    source of the problem, which is in turn caught by one of the callers in the call
    stack. The exception object is an instance of one of the exception classes. There
    are many such classes, which represent various types of problems. In this topic,
    we will take a look at different types of exceptions, get to know some of the
    exception classes from Java libraries, learn how to create our own exceptions,
    and see how to throw them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous topic, we first played with `IOException`. Then, in the activity,
    we played with `NumberFormatException`. There was a difference between these two
    exceptions. The IDE would force us to handle `IOException` and would not compile
    our code otherwise. However, it did not care whether we caught `NumberFormatException`
    or not, it would still compile and run our code. The difference was in the class
    hierarchy. While both of them are descendants of the `Exception` class, `NumberFormatException`
    is a descendant of `RuntimeException`, a subclass of `Exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Hierarchy of the RuntimeException class](img/C09581_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Hierarchy of the RuntimeException class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding figure shows a simple class hierarchy. Any class that is a descendant
    of `Throwable` can be thrown and caught as an exception. However, Java provides
    a special treatment for the descendants of `Error` and `RuntimeException` classes.
    We'll explore these further in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Checked Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any descendant of `Throwable` that is not a descendant of `Error` or `RuntimeException`
    falls in the category of checked exceptions. For example: `IOException`, which
    we used in the previous topic, is a checked exception. The IDE forced us to either
    catch it or to specify that we throw it in our function.'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to throw a caught exception, your function has to specify that it
    throws the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a Checked Exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new project and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a function and wanted it to throw an `IOException`. However,
    our IDE will not let us do that because this is a checked exception. Here is the
    type hierarchy of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Hierarchy of the IOException class](img/C09581_09_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Hierarchy of the IOException class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since `IOException` is a descendant of `Exception`, it is a checked exception
    and every function that throws a checked exception has to specify it. Move the
    caret to the error line, hit *Alt* + *Enter*, and select "**Add exception to method
    signature**". Here''s how the code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our code still has a problem. We will continue dealing with it in
    the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement of checked exceptions is that if you call a method that
    specifies a checked exception, you have to either catch the exception or specify
    that you also throw that exception. This is also known as "the catch or specify
    rule."
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 39: Working with catch or Specify'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at throwing checked exceptions and calling methods that
    throw them. You should have the project already open:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have the preceding example in your IDE, create a project and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the line with `myFunction()` is underlined in red, because this
    line is calling a checked exception and we are not doing anything about that potential
    exception. We either need to specify that we also throw it, or we need to catch
    and handle it. IntelliJ can help us do either of these. Move the caret over the
    `myFunction1()` line and hit *Alt* + *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Add exception to method signature**, to successfully specify that
    we throw the exception. Here is the code that this generates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this compiles and runs just fine. Now undo (*Ctrl* + *Z*) and
    hit *Alt*+ *Enter* again to get the options back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if we select **Surround with try/catch**, we''ll successfully
    catch the exception. Here is the code that it generates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While this compiles and runs, remember that simply printing information about
    it is not the greatest way to handle an exception.
  prefs: []
  type: TYPE_NORMAL
- en: In these exercises, we saw how to throw checked exceptions and how to call methods
    that throw them.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall the top of the exception class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Hierarchy of the RuntimeException class](img/C09581_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Hierarchy of the RuntimeException class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, the exception classes that are descendants of `RuntimeException` are called
    runtime exceptions. The descendants of `Error` are called errors. Both of these
    are called unchecked exceptions. They do not need to be specified, and if they
    are specified, they do not need to be caught.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions represent things that may happen more unexpectedly compared
    to checked exceptions. The assumption is that you have the option to ensure that
    they will not be thrown; therefore, they do not have to be expected. However,
    you should do your best to handle them if you have a suspicion that they may be
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the hierarchy of NumberFormatException:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Hierarchy of the NormalFormatException class](img/C09581_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Hierarchy of the NormalFormatException class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since it is a descendant of `RuntimeException`, it is a runtime exception, therefore
    an unchecked exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 40: Using Methods That Throw Unchecked Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will write some code that throws a runtime exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project in IntelliJ and paste in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this code is trying to parse a string as an integer, but the string
    clearly does not contain an integer. As a result, a `NumberFormatException` will
    be thrown. However, since this is an unchecked exception, we do not have to catch
    or specify it. This is what we see when we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we did not catch it, the `NumberFormatException` got thrown from the
    `main` function and crashed the application. Instead, we could catch it and print
    a message about it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the code, we get an output that shows that we are aware of
    the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Although catching unchecked exceptions is optional, you should make sure you
    catch them in order to create code that is complete.
  prefs: []
  type: TYPE_NORMAL
- en: It's practically the same case for errors, which are descendants of the `Error`
    class. In the following section, we talk about the semantic differences between
    runtime exceptions and errors.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Class Hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any object that can be thrown as an exception is an instance of a class that
    is derived from the `Error` or `RuntimeException` is treated as an unchecked exception,
    while any other class that derives from `Throwable` is a checked exception. Therefore,
    which exception class you use determines the mechanics (checked versus unchecked)
    of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the mechanics of exception handling, the choice of exception class also
    carries semantic information. For example: if a library method encounters a case
    in which a file that was supposed to be in the hard drive is missing, it would
    throw an instance of `FileNotFoundException`. If there was a problem in a string
    that was supposed to contain a numeric value, the method that you give that string
    to would throw a `NumberFormatException`. The Java class library contains a number
    of exception classes that fit most unexpected situations. The following is a subset
    of classes in this hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Subset of classes in hierarchy](img/C09581_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Subset of classes in hierarchy'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you read through this list, you will notice that there are a lot of exception
    types for various occasions.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing the Exception Hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In IntelliJ, open any Java project or create a new one. Anywhere in your code,
    create a `Throwable` reference variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now move the caret over `Throwable` and press `Ctrl` + `H`. The hierarchy window
    should open with the `Throwable` class in focus. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Hierarchy of Throwable class](img/C09581_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Hierarchy of Throwable class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now expand `Error` and `Exception`, and read through the list of classes. These
    are various throwable classes defined in various libraries that your code has
    access to. As you can see, there is quite a broad list of exceptions to choose
    from. Next to each exception class, there is the package that it belongs to in
    parentheses. As a rule of thumb, if you are going to throw an exception yourself,
    you should try to use exceptions that are in the libraries that you are also using.
    For example: importing `com.sun.jmx.snmp.IPAcl` just so that you can use the `ParseException`
    defined in it is not a good thing to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a better idea about the existing exception classes that are in
    the Java Class Library and what your choice of exception class communicates to
    the users of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing Exceptions and Custom Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a programmer, you will write methods that you or others will call. Inevitably,
    there will be things that go wrong in your code in undesirable situations. You
    should throw exceptions in those cases that are instances of appropriate exception
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: To throw an exception, first, you need to create an instance of a class that
    is an ancestor of `Throwable`. Then, you populate that instance and use the `throw`
    keyword to throw it. Then, the throwable instance will travel up the call stack
    and pop entries until it meets a `try`/`catch` block with a catch statement that
    matches the type of this `Throwable` or is a subclass of it. The throwable is
    given to that catch block as the caught exception, and the execution continues
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 41: Throwing an Exception'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use existing exception classes for our exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java project and add the following code, which has a function
    that expects a string of length one that contains a single digit and prints it.
    If the string is empty, it will throw an `IllegalArgumentException`. If the string
    contains anything other than a single digit, it will throw a `NumberFormatException`.
    Since these are unchecked exceptions, we did not have to specify them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will call this function and handle the exceptions that it throws. We
    will intentionally call another function that calls this, and will have catch
    blocks in two different places to demonstrate exception propagation. The full
    code will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, from `main`, we call `runDigits`, which in turn calls `useDigitString`.
    The main function catches `IllegalArgumentException` and `runDigits` catches `NumberFormatException`.
    Although we throw all the exceptions in `useDigitString`, they are caught in different
    places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 42: Creating Custom Exception Classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, we used existing exception classes for our exceptions.
    `NumberFormatException` sounded appropriate but `IllegalArgumentException` was
    a bit of an odd choice. Also, they are both unchecked exceptions; perhaps we would
    like to have checked ones instead. Therefore, existing exception classes are not
    suitable for our needs. We can create our own exception classes in this situation.
    Let''s continue on the same course as the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we are happy with `NumberFormatException`, but we want an `EmptyInputException`
    that is a checked exception. We can extend `Exception` to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had extra information to place in this exception, we could have added
    fields and a constructor for that purpose. However, in our case, we just want
    to signal that the input was empty; no other information is necessary for the
    caller. Now let''s fix our code so that our function throws `EmptyInputException`
    instead of `IllegalArgumentException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this made our code much simpler—we did not even have to write a
    message, as the name of the exception clearly communicates the problem. Here is
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to throw exceptions and create your own exception class if
    existing exception classes are insufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 37: Writing Custom Exceptions in Java.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will write a program for an admission system for a roller coaster ride. For
    each visitor, we will get their name and age from the keyboard. Then, we will
    print out the name of the visitor and that they are riding the roller coaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since roller coasters are only for adults, we will reject visitors that are
    younger than 15 years old. We will handle the rejection using a custom exception:
    `TooYoungException`. This exception object will contain the name and the age of
    the visitor. When we catch the exception, we will print an appropriate message
    that explains why they were rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to accept visitors until the name is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and enter `RollerCoasterWithAge` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also create an exception class, `TooYoungException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `java.util.Scanner` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `main()`, create an infinite loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's name. If it is an empty string, break out of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the name as "John is riding the roller coaster".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch the exception and print an appropriate message for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the main program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 366.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous topics, we threw and caught exceptions and got a feel for how
    exceptions work. Now let's revisit the mechanics to make sure we got everything
    right.
  prefs: []
  type: TYPE_NORMAL
- en: How try/catch Works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `try`/`catch` statement has two blocks: the `try` block and the `catch`
    block, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try` block is where your main execution path code goes. You optimistically
    write your program here. If an exception happens in any of the lines in the `try`
    block, the execution stops at that line and jumps to the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `catch` block catches throwables if they can be assigned to the exception
    reference it contains (`Exception e`, in this case). So, if you have an exception
    class here that is high up in the exception hierarchy (such as `Exception`), it
    will catch all exceptions. This will not catch errors, which is usually what you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to be more specific about the types of exceptions that you catch,
    you can provide an exception class that is lower in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 43: Exception Not Caught Because It Cannot Be Assigned to a Parameter
    in the catch Block'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new project and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code will not even compile. The code throws an exception, but
    the catch clause expects an `InstantiationException`, which is a descendant of
    `Exception`, to which exception instances cannot be assigned. Therefore, the exception
    is neither caught, nor thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify an exception so that the code can compile as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we see that we are not able to catch the exception that
    we threw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you catch one type of a specific exception, but your code can throw
    other types of exceptions as well. You can provide multiple catch blocks in this
    case. The exception types being caught can be in different places in the class
    hierarchy. The first catch block of whose parameter the thrown exception can be
    assigned to is executed. So, if two exception classes have an ancestor relationship,
    the descendant's catch clause has to go before the ancestor's catch clause; otherwise,
    the ancestor would catch the descendant's exceptions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 44: Multiple catch Blocks and Their Order'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will have a look at multiple catch blocks in a program
    and their order of execution. Let''s continue with the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the initial form of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When we hit *Alt* + *Enter* on `Exception` to add a catch clause for it, it
    is added after the existing one, which is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the thrown exception is an `InstantiationException`, it will be caught by
    the first catch. Otherwise, if it is any other exception, it will be caught by
    the second. Let''s try reordering the catch blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now our code will not even compile because instances of `InstantiationException`
    can be assigned to `Exception e`, and they will be caught by the first catch block.
    The second block will never be called—ever. The IDE is smart to catch this problem
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Another property of exceptions is that they travel up the call stack. Every
    function that is called essentially returns the execution to its caller, until
    one of them is able to catch the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 45: Exception Propagation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will go through an example in which we have multiple functions
    calling one another:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We throw the exception from the deepest method, which is caught by one of the
    methods higher in the call stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that method 2 and method 3 do not run to completion, while method 1 and
    `main` do. Method 2 throws the exception; method 3 does not catch it and lets
    it propagate up. Finally, method 1 catches it. Method 2 and method 3 abruptly
    return the execution to the method higher in the call stack. Since method 1 and
    main do not let an exception propagate up, they are able to run to completion.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more feature of the catch block that we should talk about. Let's
    say we would like to catch two specific exceptions but not others, but we will
    do the exact same thing in their catch blocks. In this case, we are able to combine
    the catch blocks of these exceptions with a pipe character. This feature was introduced
    in Java 7 and will not work in Java 6 and below.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Exception Types in One Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have dealt with a single type of exception in one block of code. Now we will
    have a look at multiple exception types in one block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a catch block that can catch either an `IOException` or an `ArithmeticException`
    using the catch block with multiple exception types. When we run the code, we
    see that the `ArithmeticException` that we caused is successfully caught:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If the exception was an `IOException`, it would be caught the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know more about the mechanics of a `try`/`catch` block, exception propagation,
    multiple catch blocks, and multiple exceptions in a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 38: Dealing with Multiple Exceptions in a Block'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we wrote a program for an admission system for a roller coaster
    ride earlier? This time, we will also take the visitor's height into account.
    For each visitor, we will get their name, age, and height from the keyboard. Then,
    we will print out the name of the visitor and that they are riding the roller
    coaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since roller coasters are only for adults of a certain height, we will reject
    visitors that are younger than 15 years old or shorter than 130 cm. We will handle
    the rejection using custom exceptions: `TooYoungException` and `TooShortException`.
    These exception objects will contain the name and the relevant property of the
    person (age or height). When we catch the exception, we will print an appropriate
    message that explains why they were rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to accept visitors until the name is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and enter `RollerCoasterWithAgeAndHeight` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also create two exception classes, `TooYoungException` and `TooShortException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `java.util.Scanner` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `main()`, create an infinite loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's name. If it is an empty string, break out of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's height. If it is lower than 130, throw a `TooShortException`
    with this name and age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the name as "John is riding the roller coaster."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch the two types of exceptions separately. Print appropriate messages for
    each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the main program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 368.
  prefs: []
  type: TYPE_NORMAL
- en: What Are We Supposed to Do in a Catch Block?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you catch an exception, you are supposed to do something about it. The
    ideal case is that you can find a strategy that recovers from the error and can
    resume the execution. However, sometimes you cannot do this and may choose to
    specify in your function that you let this exception propagate using a throws
    statement. We saw these in the previous topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in some cases, you may be in a position to add more information to
    the exception that you will propagate to your caller. For example: let''s say
    that you called a method to parse the user''s age and it threw a `NumberFormatException`.
    If you simply let it propagate to your caller, your caller will not know that
    this was related to the user''s age. Perhaps adding this information to the exception
    before propagating it up would be beneficial. You can do this by catching the
    exception, wrapping it in another exception as the cause, and throwing that exception
    to your caller. This is also called "**chaining exceptions**."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 46: Chained Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will have a look at the workings of chained exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that trying to parse "fifty five" as an integer will result in a `NumberFormatException`.
    We are not catching it and letting it propagate. Here is the output we get as
    a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that the exception's output does not give any indication that this problem
    was related to the user's age.
  prefs: []
  type: TYPE_NORMAL
- en: 'Catch the exception and chain it to add this information about age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, here is the output that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that this contains information about the age. This is an exception that
    has another exception as the cause. If you want, you can get it using the `e.getCause()`
    method and act accordingly. When simply logged, it prints the exception details
    in order.
  prefs: []
  type: TYPE_NORMAL
- en: finally Block and Their Mechanics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `try`/`catch` block is very useful in catching exceptions. However, here
    is a common scenario in which it may have some shortcomings. In our code, we would
    like to acquire some resources. We are responsible for releasing the resources
    when we are done with them. However, a naive implementation may result in a file
    being left open when an exception happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 47: Leaving a File Open as a Result of an Exception'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will deal with the `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we will read the first line of a file and print it. We can code
    this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `useTheFile` function raises an exception before we had a chance
    to close the file. When we run it, we get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that we do not see a "closed the file" output because the execution could
    never get past the `useTheFile()` call. After catching the exception, even though
    we do not have access to the `BufferedReader` reference, the operating system
    is still holding the file resources. We just leaked a resource. If we do this
    many times in a loop, our application may crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may try to devise various solutions to this resource-leaking problem. For
    example: you may duplicate the file-closing code and paste it to the catch block.
    Now you have it both in the `try` and in the `catch` blocks. If you have multiple
    `catch` blocks, all of them should have it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is correct, but it has code duplication, which makes it
    hard to maintain. Instead, you may think that you can close the file after the
    `catch` block in one single place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: While this is almost correct, it is missing one possibility. Note that we are
    throwing an exception in the first `catch` block now. That will bypass the code
    after the catch blocks and the file will still be left open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, what we need to do is to ensure that the file closing code will
    run no matter what happens. The `try` / `catch`/ `finally` block is the solution
    to this problem. It is like the `try`/ `catch` block, with an extra finally block
    that executes after we are done with the block, no matter what happens. Here is
    the solution with the `finally` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This new version closes the file whether there was an exception raised or not,
    or if another exception was raised after an exception was originally caught. In
    each case, the file-closing code in the finally block is executed and the file
    resource is released by the operating system appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: There is still one problem with this code. The problem is, an exception might
    be raised while we are opening the file in the `BufferedReader` constructor, and
    the `br` variable may remain null. Then, when we try to close the file, we will
    dereference a null variable, which will create an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this problem, we need to ignore `br` if it is null. The following
    is the complete code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 39: Working with Multiple Custom Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we wrote a program for an admission system for a roller coaster
    ride that verified the visitors' age and heights. This time, we will assume that
    we have to escort every applicant outside of the roller-coaster area afterward,
    whether they ride the roller coaster or not.
  prefs: []
  type: TYPE_NORMAL
- en: We will admit visitors one by one. For each visitor, we will get their name,
    age, and height from the keyboard. Then, we will print out the name of the visitor
    and that they are riding the roller coaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since roller coasters are only for adults with a certain height, we will reject
    visitors who are younger than 15 years old or shorter than 130 cm. We will handle
    the rejection using custom exceptions: `TooYoungException` and `TooShortException`.
    These exception objects will contain the name and the relevant property of the
    person (age or height). When we catch the exception, we will print an appropriate
    message that explains why they were rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished with a visitor, whether they ride the roller coaster or
    not, we will print that we are escorting the visitor outside the roller-coaster
    area.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to accept visitors until the name is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and enter `RollerCoasterWithEscorting` as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also create two exception classes, `TooYoungException` and `TooShortException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `java.util.Scanner` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `main()`, create an infinite loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's name. If it is an empty string, break out of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's age. If it is lower than 15, throw a `TooYoungException` with
    this name and age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's height. If it is lower than 130, throw a `TooShortException`
    with this name and age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print name as "John is riding the roller coaster."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch the two types of exceptions separately. Print appropriate messages for
    each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print that you are escorting the user off the premises. You have to be careful
    about the scope of the name variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the main program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 370.
  prefs: []
  type: TYPE_NORMAL
- en: The try with resource Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `try`/ `catch`/ `finally` block is a great way to handle resources that
    you have allocated. However, you will probably agree that it feels a bit like
    boilerplate. Allocating resources and releasing them in a finally block is a very
    common pattern. Java 7 introduced a new block that simplifies this common pattern—the
    `try with resource` block. In this new block, we place the resource allocations
    between parentheses right after the try block and forget about them. The system
    will automatically call their `.close()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, all of these resources have to implement the `AutoCloseable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 48: try with resources Block'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will have a look at the try with resource block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Main` class with the `useTheFile()` method, which takes a string
    parameter as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert our earlier example to use the try with resources block as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While learning about exception handling and its statements, mechanics, and
    classes is required to use it, for most programmers this may not be enough. Usually,
    this set of theoretical information needs practical experience of various cases
    to get a better feel for exceptions. In this regard, some rules of thumb about
    the practical use of exceptions are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not suppress exceptions unless you really handled them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inform the user and let them take responsibility unless you can fix things silently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of the caller's behavior and don't leak exceptions unless it is expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap and chain with more specific exceptions when possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppressing Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your function, when you catch an exception and do no throw anything, you
    are signaling that you took care of the exceptional case and you fixed the situation
    so that it is as if that exceptional case had never happened. If you cannot make
    such a claim, then you should not have suppressed that exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 49: Suppressing Exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example: let''s assume that we have a list of strings that we expect to
    contain integer numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will parse all of them and add them to a corresponding list of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We should do something about this; at least, we should not let our code crash.
    What is the correct course of action? Should we catch the error inside the `parseIntegers`
    function, or should we catch it in main? Let''s catch it in `parseIntegers` and
    see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here is our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: It added 1 and 3 together, and ignored the "two." Is this what we wanted? We
    assumed that the "two" was the correct number and we expected it to be in the
    sum. However, at the moment, we are excluding it from the sum, and we are adding
    a note in the logs. If this was a real-life scenario, probably nobody would look
    at the logs and the result that we provide would be inaccurate. This is because
    we caught the error and did not do anything meaningful about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would be a better approach? We have two possibilities here: we either
    can assume that every element in the list should actually be a number, or we can
    assume that there will be mistakes and we should do something about them.'
  prefs: []
  type: TYPE_NORMAL
- en: The latter is a trickier approach. Perhaps we can collect the offending entries
    in another list and return it back to the caller, and then the caller would send
    it back to its origin for re-evaluation. For example, it could show them to the
    user and ask them to be corrected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The former is an easier approach: we assume that the initial list contains
    number strings. If this assumption breaks, however, we have to let the caller
    know. So, we should throw an exception, rather than providing a half-correct sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we should not do is take a third approach: hope that the list contains
    numbers, but ignore the ones that are not numbers. Note that this is a choice
    we made, but that''s not what we thought of when we enumerated our two options
    above. This was convenient to program, but it created an assumption that was not
    there in the original business logic. Be very careful about situations like this.
    Make sure you write down your assumptions and be strict in enforcing them. Do
    not let the convenience of programming force you to accept weird assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the assumption that the initial list contains number strings, here
    is how we should have coded it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output would simply be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the User in the Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous rule of thumb advised us not to provide half-correct results by
    sweeping problems under the rug. Now we'll extend it for cases when the program
    is an interactive one. Unless your program is a batch process, it usually has
    some interaction with a user. In that case, having the user be the arbiter of
    a problematic situation is usually the right approach.
  prefs: []
  type: TYPE_NORMAL
- en: In our example of a list of string numbers, obviously, one of the strings is
    not parsable as a number and there is not much the program can do. However, if
    the user saw the "two," they could replace it with a "2" to fix the situation.
    Therefore, rather than trying to silently fix things, we should find ways of involving
    the user in the decision-making process and get their help to resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 50: Asking the User for Help'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can extend our previous example so that we identify the offending entry
    in the list and ask the user to correct it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an approach for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note that we identified the offending element and asked the user to fix it.
    This is a good way to keep the user in the loop and give them a chance to fix
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Do Not Throw Unless It Is Expected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have been suggesting that throwing exceptions is a good thing and
    that we should not suppress them. However, in some cases, this may not be the
    case. This reminds us that everything about exceptions depends on the context
    and we should think about each situation rather than blindly following patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every now and then, you might use a third-party library and you might provide
    them with classes of yours so that they call your methods. For example: a game
    engine may get your object and call its `update()` method 60 times per second.
    In a case such as this, you should be careful about understanding what it may
    mean if you throw an exception. If it is the case that the exception that you
    throw exits the game, or shows a popup that an error happened, maybe you should
    not throw exceptions about things that are not showstoppers. Let''s say that you
    are not able to calculate a required value in this frame, but maybe it will work
    in the next frame. Is it worth stopping the game for this? Perhaps not.'
  prefs: []
  type: TYPE_NORMAL
- en: Especially when you are overriding classes/implementing interfaces and handing
    your object to another entity to manage, you should be mindful about what propagating
    an exception out of your methods entails. If the caller encourages exceptions,
    great. Otherwise you may have to wrap all your methods in a broad `try/catch`
    to ensure that you do not leak exceptions for things that are not showstoppers.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Chaining and Being More Specific When You Let Exceptions Propagate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you propagate an exception to your caller, you usually have a chance to
    add more information to that exception so that it will be more useful to the caller.
    For example: you may be parsing the user''s age, phone number, height, and so
    on, from strings that they provided. Simply raising a `NumberFormatException`,
    without informing the caller about which value it was for is not a very helpful
    strategy. Instead, catching the `NumberFormatException` separately for each parse
    operation gives us the chance to identify the offending value. Then, we can create
    a new Exception object, provide more information in it, give the `NumberFormatException`
    as the initial cause, and throw that instead. Then, the caller can catch it and
    be informed about which entity was the offending one.'
  prefs: []
  type: TYPE_NORMAL
- en: The earlier exercise, in which we used our custom `NonNumberInListException`
    to identify the index of the offending entry in the list, is a good example of
    this rule of thumb. Whenever possible, it is a better idea to throw a more informative
    exception that we create ourselves, rather than letting the internal exception
    propagate without much context.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, we covered exceptions in Java from a practical point of view.
    First, we discussed the motivation behind exception handling and how it provides
    advantages over other ways of trying to handle erroneous cases. Then, we took
    the point of view of a newbie Java programmer with a powerful IDE and provided
    guidance on how to best handle and specify exceptions. Later, we dived deeper
    into causes of exceptions and various exception types, followed by the mechanics
    of exception handling using the try/catch, try/catch/finally, and try with resource
    blocks. We finish this discussion with a list of best practices to guide your
    decision process in various situations that involve exceptions.
  prefs: []
  type: TYPE_NORMAL

- en: Understanding Typed Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create even modest Java programs, we're going to need a way to store and
    manipulate information. Our chief resource, when doing this, is the variable,
    and that's what we're going to take a look at in this chapter. We'll look at the
    different data types in Java and how to use them in our programs. We'll also see
    the `Math` class library and one of its functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll walk through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to variables and why they're needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Math` class library and its `pow()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `String` class and its methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s create a new project in NetBeans. I''m going to call mine
    `Variables`, and this time we''ll allow NetBeans to create the main class for
    us so that we can get to coding as quickly as possible. We need to delete all
    the comments that are created automatically by NetBeans when we create our new
    project, just to keep everything as readable as possible, then we''ll be good
    to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4dff2ef-aa16-4c77-a6a1-80fa47689ac8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first computers were little more than calculators, and Java, of course,
    retains this functionality. For example, Java can evaluate `1+1`, which will evaluate
    to `2`, of course. However, Java is pretty complicated and designed to do a lot
    of different things, so we need to provide context to our commands. Here, we tell
    Java that we''d like it to print the result of `1+1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our preceding program will run as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecbc403f-5889-4e61-945e-a3d184e24f97.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to some others, Java can perform all the basic arithmetic operations.
    It can do addition, subtraction, multiplication (for which we use `*`, not `X`
    on our keyboard), and division. If we run the following program with the input
    of `2` and `3`, we''ll see four `println()` commands, all of which will give the
    proper result of the calculations. We can, of course, change these numbers to
    be any combination of numbers we see fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46d2e0fd-de73-44c8-811a-56e8cda1c167.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing these lines manually is kind of a pain and quickly becomes infeasible
    if we're writing very complicated programs or dynamic programs that take user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The solution of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, programming gives us a way of storing and retrieving data; this
    is called the **variable**. To declare a variable in Java, we first have to specify
    what kind of variable we're going to be using. Variables come in a number of different
    types. In this instance, we're content with using whole numbers, that is, numbers
    that do not have a specified decimal place and aren't fractions. Also, in this
    case, it's appropriate to use one of Java's primitive types. These are essentially
    as base level as we can get with information in the Java programming language;
    just about everything else we work with in Java is built of the primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable of the integer primitive type, that is, whole numbers,
    we use the `int` keyword, all lowercase. Once we do this, we need to give our
    variable a name. This is a unique identifier that we''ll use to access this piece
    of information in future. Each variable in our local program should have its own
    name. Let''s call our first variable `x` and our second variable `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve just written two perfectly legitimate lines of Java code. If we run
    our program now, we''ll see the same output we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8367c0c4-8769-4f2b-a658-833cce3172b2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, behind the scenes, Java will also be setting aside memory space for
    our `x` and `y` variables. This allocation doesn't affect our `println` commands
    because the variables are not referenced in them yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s store some information in our variables. We can reference a variable
    once we''ve created it simply by the variable''s name. It''s important that we
    do not reference our variable by typing `int x` again because this is the command
    for Java to create a brand new variable `x`, not access the existing variable
    `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8249e4c-22b4-4ca3-bc16-593d40173ca6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve referenced our variable, we can change its value using the equal
    sign. So let''s set `x` to `4` and `y` to `3`. Our `println` commands currently
    operate with two explicitly declared integers: the numbers `2` and `3`. Since
    `x` and `y` are also integers, it stands to reason that we can simply replace
    the existing numbers with the variables `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1c7a2a6-9b27-4ad8-b4ba-552e07ebe6b5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When our Java code comes to the variables `x` and `y`, it will look to see what
    integer value they have currently been given. It will find the numbers `4` and
    `3`. So if we run our program, we should expect the first `println` statement,
    `x+y`, to evaluate to `4+3`, which then evaluates to `7`. This is exactly what
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: So here's something interesting. The last line of our program, in which we divide
    `x` by `y`, isn't evaluating as we might mathematically expect it to. In this
    line of code, `x` has the value `4`, and `y` has the value `3`, Now `4` divided
    by `3` equals 1.3, but our program is simply outputting `1`. That's because 1.3
    is not a valid integer value. Integers are only whole numbers and never fractions
    or decimal numbers. So, to keep us working with integers, Java simply rounds down
    any calculations that have fractional portions to their nearest whole number.
    If we want to work in an environment where we could have fractional results, we
    would need to use a primitive type other than an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, now that we''ve set up our `println` commands to take integer variable
    input instead of explicit numbers, we can modify the behavior of all four lines
    of the calculation by simply changing the values of these integer variables. For
    example, if we wanted our program to run on the input values `-10` and `5` (integers
    can be negative; they just can''t have fractional components), all we would need
    to do is change the values we give to our variables `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code quickly, we will see the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d32b5c65-880c-41a2-9863-aed25b3dce4c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! You've just learned the very basics of working with both integers and
    variables in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation for integer variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go over an edge case and learn a little bit more about how Java thinks.
    You might remember from earlier, I spoke about how Java sets aside memory when
    we declare new variables. This is one of the huge advantages of working in a high-level
    programming language, such as Java. Java abstracts away or automatically takes
    care of most of the memory management for us. Quite often, this makes writing
    programs simpler, and we can write shorter, cleaner, and more easily readable
    code. Of course, it is important that we appreciate what's happening behind the
    scenes, lest we run into issues.
  prefs: []
  type: TYPE_NORMAL
- en: For example, whenever Java sets aside memory for an integer variable, it also
    sets aside the same amount of memory for all integer variables. This means there's
    a maximum and minimum value that Java could ever conceivably store in an integer
    variable. The maximum integer value is `2147483647` and the minimum integer value
    is `2147483648`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s do an experiment. What happens if we attempt to store and print out
    an integer variable that is one larger than the maximum value? To start with,
    let''s simplify our program. We''re simply going to assign a value, one higher
    than possible, to the variable `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/504868da-232a-43e3-bd1e-81d726d29b6d.png)'
  prefs: []
  type: TYPE_IMG
- en: When we attempt to do this, NetBeans yells at us. It's got some logic built
    in that attempts to stop us from making this very basic and common mistake. If
    we were to attempt to compile this program, we would also get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we want to make this mistake in the name of science, so we''re going
    to trick NetBeans. We''re going to set the value of our variable `x` to the largest
    possible integer value, and then in the next line of our code, we''re going to
    set the value of `x` to be one higher than what `x` is currently, that is, `x=x+1`.
    Actually, there''s a nifty little shorthand we can use for this: `x=x+1` is equivalent
    to `x++`. OK, so when we run this program, which will sneak by the compiler and
    NetBeans, and do our addition at runtime, we attempt to print out an integer value
    that is one plus the highest integer value that Java can store in a memory location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding program, we get the following negative number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b95205e1-dc7d-4d43-b244-436bc92bc84c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This number happens to be the smallest number that we could ever store in an
    integer. This makes some sort of visual sense. We've gone so far positive, or
    to the right, on our integer number line, that we've arrived at the leftmost or
    the most negative point. Of course, in a mathematical sense, this could get pretty
    confusing pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s unlikely that we''re ever going to write programs that will need integer
    numbers higher than this value. However, if we do, we certainly need to be aware
    of this issue and circumvent it, using a variable type that can handle larger
    values. The `long` variable type is just like an integer but we need to allocate
    more memory for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding program, we will get a mathematically accurate result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e55622b8-4f38-451f-9dbb-4c729df8e319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Floating point variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're simply counting and manipulating whole objects, integers are fantastic.
    However, sometimes we need to deal with numbers in a more mathematical sense,
    and we need a data type that will allow us to express ideas that are not entirely
    whole numbers. Floating-point numbers, or floats, are a Java primitive type that
    allow us to express numbers that have decimal points and fractions. In this section,
    we'll modify some float and integer variables side by side to see how they are
    similar and different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Java project (you know the drill by now) and call it `FloatingPointNumbers`.
    Let''s start by declaring two variables: one integer (`iNumber`) and one float
    (`fNumber`). As we know, once we''ve declared these variables, we''re free to
    modify and assign values to them in our Java program later. This time, let me
    show you that we can also modify and assign to these variables in the same line
    that they''re declared. So where I have declared my `iNumber` integer variable,
    I''m free to immediately give it the value of `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that if we try and do something very similar with our float variable,
    NetBeans will yell at us, by displaying a light bulb and red dot on the left-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00c7ce26-7b13-43af-a214-06143904c0bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In fact, if we attempt to compile our program, we''ll get a legitimate compiler
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3765a7c-e60a-46f8-8d1d-9d7ad8e4bde1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze why this happens. When we use an explicit number in Java, that
    is, typing out the digits rather than working with a variable, that explicit number
    is still given a type by Java. So when we type out a number without any decimal
    places, the type that the number is assumed to be is an integer. So our assignment
    works just great. However, a number with decimal places is assumed to be of this
    type and is called `double`; it''s a sister type of the `float` data type, but
    it''s not quite the same. We''ll talk about `double` a little later. Right now,
    what we need to do is tell Java to treat `5.5` as a `float` type number instead
    of `double`. To do this, all we need to do is put `f` after the digits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see that the bulb and red dot have disappeared. To make sure we get
    the syntax right, let''s give our program some super basic functionality. Let''s
    use `System.out.println()` to print our integer number and then our floating-point
    number variable in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build this program, our compiler error goes away, and when we run it,
    we see the two assigned values as expected. Nothing too exciting there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c91aff6e-852d-4463-a59e-f5427c61a6d9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Behavior difference between integer and float data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, rather than assigning explicit values to our variables, let's do some basic
    arithmetic so we can see how integer and floats, when modified in Java, behave
    differently. In Java, both `float` and `int` are primitive types, the logical
    building blocks of the programming language. This means we can compare and modify
    them using mathematical operators, such as division.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that if we attempt to divide one integer by another, we''ll always
    get a whole number as a result, even if the rules of standard mathematics don''t
    make that the expected result. If we divide a floating-point number by another
    floating-point number, however, we''ll get a more mathematically accurate result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4b9190-5d11-4bbe-93c4-46769ff63be5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, Java will let us do things that might not be such a good idea. For
    example, Java lets us set the value of our floating-point variable `fNumber` to
    one integer divided by another instead of one floating-point number divided by
    another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the computation on the right-hand side of our equals sign occurs before
    the value of our floating-point variable `fNumber` changes, we''re going to see
    the same output in both the calculations of `5/4`. This is because both the 5''s
    and 4''s are integer variables. So when we run our program, even though `fNumber`
    remains a floating-point number (as we can tell because it prints out with the
    decimal place), its value is still set to the rounded down whole number of `5/4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04d86a0b-dda4-44a3-bc9f-a1be8869b39f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Solving this problem is pretty straightforward; we simply need to change one
    of our integer values to be a floating-point number by appending `f` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the computation will know how to proceed with a decimal place division:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/769f67af-a82c-4fb3-99f3-699d080c9821.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This becomes a little trickier and more important to navigate properly when
    we stop working with explicitly declared numbers and begin working with variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare two integer variables now. I''ll just call them `iNumber1` and
    `iNumber2`. Now, rather than attempting to set the value of `fNumber` to one explicitly
    declared number divided by another, we''ll set its value to `iNumber1/iNumber2`,
    and we''ll just print out the results stored in `fNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, because once again we''re dividing one integer by
    another, we''re going to see the rounding down phenomenon. The value being stored
    in our floating-point variable is `0.0`, the rounded down result of `5/6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb11f02b-69bc-4402-bf1d-2f8ea176e037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we were working with explicitly declared numbers, we would solve this problem
    by changing one of the two integer numbers to be treated as a floating-point number
    by simply putting a decimal place and `f` after it. In this context, using `iNumber2f`
    is not an option because rather than thinking that we're asking it to treat `iNumber2`
    as a floating-point number, Java now believes it's looking for a variable called
    `iNumber2f`, which certainly doesn't exist within this context.
  prefs: []
  type: TYPE_NORMAL
- en: Type casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can achieve a similar result though, using what's called a **cast**. This
    is a command in which we ask Java to treat a variable of one type like it is another
    one. Here we're circumventing Java's natural inclination to treat `iNumber1` and
    `iNumber2` as integers. We're stepping in and saying, "You know what Java, treat
    this number here as a float," and we're assuming some responsibility when we do
    this. Java will attempt to do what we ask, but if we choose poorly and attempt
    to cast one object to an object that it cannot, our program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we''re working with primitives here, and primitive types know
    how to act like another type. So, we can cast the variable `iNumber1` to temporarily
    operate like a floating-point number by prefacing it with `(float)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run our program, we''ll see the expected result of `5/6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f023a0d3-25eb-4199-a362-c8054663de1d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's a pretty solid introduction to working with floating-point numbers, which
    we're going to use just about any time we want to work with numbers in their mathematical
    sense rather than as integers for counting whole objects.
  prefs: []
  type: TYPE_NORMAL
- en: The double data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly talk about the `double` data type. It is a sister type of `float`.
    It provides a greater resolution: `double` numbers can have even more decimal
    places. But they take up a little more memory. At this point in time, using double
    or float is almost always a style or personal preference decision. Unless you''re
    working with complicated software that must run at peak memory efficiency, the
    extra memory space taken up by a double is not very significant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how `double` works, let''s change the two integer numbers in
    our `FloatingPointNumbers.java` program to a `double` data type. When we only
    change the names of the variables, the logic of our program doesn''t change at
    all. But when we change the declaration of these variables from declaring integers
    to doubles, the logic does change. Anyway, when we explicitly declare a number
    with decimal places, it defaults to being `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ffb0a4-0064-4de5-959f-eb48396bcbdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to fix the error. The error occurs because dividing a `double`
    data type by another one is going to return a `double` result. We can solve this
    issue in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we could cast `dNumber1` and `dNumber2` to floating-point numbers and
    then divide them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, dividing our two double numbers by each other is a perfectly legitimate
    operation. So why not allow this to occur naturally and then cast the resulting
    double to a floating-point number, thereby preserving a greater amount of resolution.
    Just like in algebra, we can break up conceptual blocks of our program that we
    would like to occur before another block using parentheses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run this program, we get the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0a31fb1-1568-43f3-85b4-0159b9c245b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Math class library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good portion of our time on any software development project is going to be
    spent teaching our program to solve the types of problems it would comes across
    on a regular basis. As programmers, we too will run into certain problems time
    and time again. Sometimes, we'll need to code our own solutions to these problems
    and hopefully save them for later use. However, more often than not, someone has
    run into these problems before, and if they've made their solution publicly available,
    one of our options is to leverage their solution for our own gain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll use the `Math` class library, which is bundled with
    the JDK to solve some math problems for us. To start this section, create a brand
    new NetBeans project (I''m going to name it `TheMathLib`) and enter the `main()`
    function. We''re going to write a very simple program. Let''s declare a floating-point
    number variable and give it a value (don''t forget the `f` alphabet at the end
    of our explicit number to let Java know that we''ve declared a floating-point
    number), then use `System.out.println()` to print this value to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, there we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e87c80c-cbba-4fba-9eb8-c78c235f9d2f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, with this program, we'd like to make it really easy to raise our floating-point
    number to various powers. So, if we simply want to square this number, I guess
    we could just print out the value of `number*number`. If we want to cube it, we
    could print out `number*number*number`. And, if we want to raise it to the power
    of six, we could multiply it six times by itself. Of course, this gets unwieldy
    pretty quickly, and there's certainly a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's leverage the Java `Math` class library to help us raise numbers to varying
    exponential powers. Now, I've just told you that the functionality we're looking
    for lives in the `Math` class library. This is the kind of push in the right direction
    you should expect to get from a Google search, or if you're an experienced software
    developer, you can implement a specific API. Unfortunately, that's not quite enough
    information for us to start using the functionality of this class library. We
    don't know the specifics of how it works or even exactly what functionality it
    offers us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find this out, we''re going to have to look at its documentation. Here''s
    the documentation web page managed by Oracle for the libraries found in our Java
    Development Kit: [docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/).
    Among the libraries that show up on the page is `java.lang`. When we select it,
    we''ll find the `Math` class that we''ve been looking for under Class Summary.
    Once we navigate to the `Math` class library page, we get two things. First we
    get some human-friendly text write-up about the library, its history, what its
    intended uses are, very meta-level stuff. If we scroll down, we see the functionality
    and methods implemented by the library. This is the nitty-gritty of where we''d
    like to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af38ab7-0226-45ab-9385-b23abde20824.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the pow() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of these functions should stick out for us, which is `pow()`, or the power
    function. It returns the value of the first argument (`double a`) raised to the
    power of the second argument (`double b`). In short, it will allow us to raise
    numbers to an arbitrary power:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f70ddefb-5585-416c-a21c-9f0fb95452eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get back to coding. Alright, let''s employ this `pow()` function to
    modify the value of our variable `number` after we''ve declared it. We''re going
    to do something along the lines of `number = pow`, but we need a little more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6def15f6-4682-4b40-9738-c78e12f8c2aa.png)'
  prefs: []
  type: TYPE_IMG
- en: How exactly do we employ this `pow()` function? Well, if we click on our documentation,
    we'll see that when the `pow()` function is declared, in addition to its name,
    there's also, between parentheses, two arguments specified. These arguments, `double
    a` and `double b`, are the two pieces of information the function is requesting
    before it can operate as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Our job, in order to use this function, is to replace the requests `double a`
    and `double b` with actual variables or explicit values so that the `pow()` function
    can do its thing. Our documentation tells us that `double a` should be replaced
    with the variable or value that we'd like to raise to the power of `double b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s replace the first type argument with our variable `number`, which
    is what we want to raise to an arbitrary power. On that note, `number` is `float`
    not `double`, and that''s going to give us some trouble unless we simply change
    it to `double`. So let''s do that. For the second argument, we don''t have a precreated
    variable to replace `double b` with, so let''s just use an explicit value, such
    as `4.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/811bebe1-6305-4142-9a72-d12617682d4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that I get rid of the `double` specifier when I call the `pow()` function.
    This specifier only exists to let us know what type Java is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, the `pow()` function now has all the information it needs to go
    ahead and run and raise the value of our number variable to the power of 4\. However,
    NetBeans is still giving us our red warning sign. Right now, that''s because NetBeans,
    and Java by extension, doesn''t know where to find this `pow` keyword. For the
    same reasons that we need to specify a full path to `System.out.println()`, we
    need to specify a full path in which it can find the `pow()` function for Java.
    This is the same path we followed to get to the `pow()` function in our documentation.
    So let''s specify `java.lang.Math.pow()` as it''s path in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re pretty much good to go. Let''s utilize the `number` variable once
    in our `println` statement, then we should be able to run our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ff4def5-2691-46e7-8f33-0373021881f6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can plug it into our calculator if we want, but I'm pretty confident that
    our program has outputted the value of 4.321 raised to the power of 4.
  prefs: []
  type: TYPE_NORMAL
- en: So this is great! We've just employed external code to not only make our program
    easier to write, but also to keep it very human-readable. It required much fewer
    lines of code than it would have otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Importing class libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that's not super human-readable about our program is the long paths
    to functions such as `pow()` and `println()`. Is there a way we could shorten
    them? There certainly is. If the makers of Java had wanted to, they could have
    allowed us to call this function by simply typing `Math.pow()` in all instances.
    This unfortunately would have some unintended side effects. For example, if there
    were two libraries linked up to Java and they both declared a `Math.pow()` function,
    Java would not know which one to use. Hence, by default, we're expected to link
    to libraries directly and explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we''d like to just be able to type out something like `Math.pow()`,
    we can import a library into the local space that we''re working in. We just need
    to do an `import` command above our class and the `main()` function declaration.
    All the import command takes as input is the path that we''d like Java to look
    for when it comes across a keyword, such as `pow()`, that it doesn''t immediately
    recognize. In order to allow us to employ the easier syntax `Math.pow()` in our
    program, we simply need to type `import java.lang.Math`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is some special syntax for imports. Let's say we wanted to import all
    the class libraries in `java.lang`. To do this, we could replace `.Math` with
    `.*` and make it `java.lang.*`Â which translates to "import every library from
    the `java.lang` package." I should probably inform you that for those of us working
    in NetBeans, this import is done by default. However, in this case, we're going
    to do it explicitly because you may have to do this while working in other Java
    environments as well.
  prefs: []
  type: TYPE_NORMAL
- en: Char variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs that manipulate numbers are all well and good, but quite often, we
    want to be able to work with text and words as well. To help us do this, Java
    defines the character, or `char`, the primitive type. Characters are the smallest
    entity of text that you can work with on a computer. We can think of them to start
    off with as single letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project; we''ll call it `Characters.java`. We''ll start
    our program by simply defining a single character. We''ll call it `character1`
    and we''ll assign to it the value of uppercase `H`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we have to use some extra syntax when defining a floating-point number
    explicitly, we need some extra syntax when defining a character. To tell Java
    that we''re explicitly declaring a character value here, we surround the letter
    we would like to assign to our variable with two single quotation marks. The single
    quotation marks, as opposed to double quotation marks, let Java know that we''re
    working with a character or a single letter, as opposed to trying to use an entire
    string. Characters can only have single entity values. If we attempt to assign
    the value of `Hi` to `character1`, NetBeans and Java would both let us know that
    that''s not a valid option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c94edae3-6ae6-42bf-8c8f-648c655ca1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s move on and write a somewhat convoluted program that will nonetheless
    work pretty well for our example purposes. Let''s define five characters. We''ll
    call them `character1` through `character5`. We''ll assign each one of them with
    one of the five letters of the word "Hello," in that order. When these characters
    are printed together, our output will show `Hello`. In the second portion of our
    program, let''s use `System.out.print()` to display these letters on the screen.
    The `System.out.print()` code works just the same as `System.out.println()`, except
    that it doesn''t add a carriage return at the end of our line. Let''s have the
    last command as `println` so that our output is separated from all of the additional
    text presented in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, it greets us. It says `Hello` and then there is some
    additional text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8050473-9463-4dd5-8718-97230d9a5c7c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Now let me show you something that will give us a little insight into how our
    computer thinks about characters. It turns out that we can set the value of `character1`
    not only by explicitly declaring the capital letter `H` between two single quotation
    marks, but also by giving it an integer value. Each possible character value has
    a corresponding number that we can use in lieu of it. If we replace `H` with the
    value of `72`, we're still going to print out `Hello`. If we were to use the value
    `73`, one greater than `72`, instead of the capital `H`, we'll now get the capital
    letter `I`, as I is the letter that follows H.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make sure we don't put `72` between single quotation marks. The best
    case scenario is that Java recognizes that `72` is not a valid character and that
    it looks more like two characters, then our program won't compile. If we use a
    single digit number surrounded by single quotation marks, our program would compile
    just fine, but we would get the completely unexpected output of `7ello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we figure out the numeric value of characters? Well, there''s a universal
    lookup table, the **ASCII** table, which maps characters to their numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb16142c-1f5e-44d0-8b7c-6fbb6a4444b1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we've been dealing with columns 1 (**Dec**) and columns 5 (**Chr**),
    which have the decimal number and the character that they are mapped to. You'll
    notice that while many of these characters are letters, some are keyboard symbols,
    numbers, and other things, such as tabs. As far as programming languages are concerned,
    new lines, tabs, and back spaces are all character elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let''s try replacing some of the characters in our program
    with the decimal value `9`, which should correspond to a tab character. If we
    replace the middle three letters of our word with tabs, as output, we should expect
    `H`, three tabs, and `o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f442e9c-7ff8-4d23-bc48-ad46675cc20a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about strings in Java. To begin, create a new NetBeans project,
    name it `StringsInJava`, and enter the `main()` function. Then, declare two variables:
    a character called `c` and `String` called `s`. Right away, it becomes clear to
    us that `String` is a little different. You''ll notice that NetBeans did not choose
    to color code our `String` keyword with blue, as it would have done if we were
    declaring a variable of a primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74e727d1-8ce8-4eb4-8572-e950945b1dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because `String`, unlike `char`, is not a primitive type. `String` is
    what we call a class. Classes are the backbone of object-oriented programming.
    Just as we can declare variables of a primitive type, we can also declare variables
    of a class, which are called instances. In our program, the variable `s` is an
    instance of the `String` class. Unlike variables of primitive types, instances
    of a class can contain their own special methodologies and functions declared
    by the class of which they are an instance. In this section, we'll use some of
    these string-specific methods and functions to manipulate text.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's take a look at what makes the `String` class so special. As
    we know, we can pretty much use our character variables and our character literals
    interchangeably, as we can with just about any other primitive type. The `String`
    class also maps interchangeably with the string literal, which is like a character
    literal but uses double quotation marks and can contain many or no characters
    at all. Most Java classes do not map to any sort of literal, and our ability to
    manipulate string literals through the `String` class is what makes it so valuable.
  prefs: []
  type: TYPE_NORMAL
- en: The concatenation operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another thing strings can do, which most Java classes cannot, is make use of
    the addition sign (`+`) operator. If we declare three strings (say, `s1`, `s2`,
    and `s3`), we can set the value of our third string to be one string plus another
    string. We can even add a string literal into the mix. Then, we print `s3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we''ll see these three strings added together in
    much the manner that we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15aef721-7741-489e-8297-d4ba8efa14af.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The toUpperCase() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So I promised you that strings had the functionality not seen in a simple primitive
    type. To employ this, let''s navigate to the `String` class in our Java documentation
    at [docs.oracle.com/javase/7/docs/api/](http://docs.oracle.com/javase/7/docs/api/).
    Select java.lang shown under Packages, then scroll down and select String from
    ClassSummary. As with the documentation for all Java classes, the String documentation
    contains Method Summary, which will tell us about all the functions we can call
    on an existing `String` object. If we scroll down in Method Summary, we''ll come
    to the `toUpperCase()` function that converts all the characters in a string into
    uppercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d33d6172-8e2e-45de-9e66-5c6a64690309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s employ this function now. Back in NetBeans, we now need to determine
    the best place in our program to employ our `toUpperCase()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We know we need to employ the `toUpperCase()` function on the `s3` string after
    finalizing the value of `s3` in our `StringsInJava.java` program. We could do
    either of these two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Employ the function on the line immediately after finalizing the value of `s3`
    (by simply typing `s3.toUpperCase();`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call the function as part of the line where we would print out the value of
    `s3`. Instead of printing out the value of `s3`, we could simply print out the
    value of `s3.toUpperCase()`, as shown in the following code block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember from our documentation, the `toUpperCase()` function requires
    no arguments. It knows that it''s being called by `s3`, and that''s all the knowledge
    it needs, but we still provide the double empty parentheses so that Java knows
    we are in fact making a function call. If we run this program now, we''ll get
    the uppercased version of the string, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d52037bd-bb4a-4393-8ffa-a8468da9cf59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But, it''s important we understand what''s going on behind the scenes here.
    The `System.out.println(s3.toUpperCase());` code line is not modifying the value
    of `s3` and then printing out that value. Rather, our `println` statement evaluates
    `s3.toUpperCase()` and then prints out the string returned by that function. To
    see that the actual value of `s3` is not modified by this function call, we can
    print the value of `s3` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `s3` keeps its lowercase components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6903f535-8f3a-42ae-8705-bbffc3cbdd70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to permanently modify the value of `s3`, we could do that on the
    previous line, and we could set the value of `s3` to the function''s result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a4b2e41-154f-4468-b641-df6521c301b3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The replace() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To confirm that we''re all on the same page, let''s employ one more method
    from the `String` class. If we head back to our documentation and scroll up, we
    can find the String''s `replace()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b878df4e-62f5-4c8c-ba1f-e6ba5f737f08.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlike our `toUpperCase()` method, which took no arguments, `replace()` takes
    two characters as arguments. The function will return a new string where all the
    instances of the first character (`oldChar`) we give as an argument are replaced
    with the second character (`newChar`) we gave as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s utilize this function on our first `println()` line in `StringsInJava.java`.
    We''ll type `s3.replace()` and give our function two characters as arguments.
    Let''s replace the character `g` with the character `o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our program, of course, nothing happens. This is because by the time
    we reach the print statement, there are no lowercase `g` characters, and there
    are no lowercase `g` characters left in `s3`; there are only uppercase `G` characters.
    So let''s try and replace the uppercase `G` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run our program, we see the replacement happen on the first instance
    of `println`, not on the second instance. This is because we haven''t actually
    changed the value of `s3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11075cfd-2d3f-4276-8c4f-07faeff0d964.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent! You are now well-equipped, as long as you have the Java documentation
    handy, to call all sorts of `String` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Escape sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you spend a lot of time working with strings though, I anticipate that you''re
    going to run into a common problem. Let''s take a look at it quickly. I''m just
    going to write a brand new program here. I''m going to declare a string, then
    I''m going to have our program print the string to the screen. But the value I''m
    going to assign to this string is going to be a little tricky. I''d like our program
    to print out `The program says: "Hello World"` (I''d like `Hello World` to be
    surrounded by double quotation marks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28c20394-e017-4a4d-bdac-f5a589ccd91b.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem here is that putting double quotation marks inside a string literal
    confuses Java as shown in the preceding screenshot. When it reads through our
    program, the first full string it sees is `"The program says:"` that tells Java
    that we've ended our string. This is, of course, not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there''s a system in place for us to tell Java that we''d like
    a character to be treated as a character literal instead of the special functionality
    that it might otherwise have. To do this, we put a backslash in front of the character.
    This is known as an escape sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when Java reads through this string, it will read `The program says:`
    and then see the backslash and know how to treat our double quotation marks as
    double quotation marks, the character, instead of the double quotation marks that
    surround a string. When we run our program, we will not see backslashes; they
    themselves are special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7026d00-78d1-4124-9766-63ab2c3442b7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we do want to see a backslash in our string, we need to preface it by a
    backslash of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b2312c48-76f0-4437-b73a-5315b4f764f2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's strings 101!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained what variables are and how important they are
    for creating better programs. We looked at some of the primitive data types of
    Java, namely `int`, `long`, `float`, `char`, and `double`, in detail. We also
    saw the `String` class and two of its manipulation methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at branching statements in Java.
  prefs: []
  type: TYPE_NORMAL

- en: Branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs that perform the same action every time they run are all well and good,
    but the most interesting computer programs do something a little different each
    time they run, whether it's because they have differing input or even because
    a user is actively interacting with them. With this, let's kick-start this chapter
    by understanding conditional statements, then we will further explore how Java
    handles complicated conditional statements, modify the control flow of our program,
    and study loops functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `if` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch`, `case`, and `break` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `while` and `do...while` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Today, we''re going to explore the very basic `if` and `else` conditional statements.
    To understand this further, refer to the following bullet list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Java project in NetBeans. I''m going to call mine `ConditionalStatements`,
    and I will allow NetBeans to create the `main` class for me; refer to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fed44d7e-dcac-4bcd-af4b-85b68c4bf7ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To keep things clean, we can get rid of all our comments; now we're good to
    go. To allow us to write more interesting programs, we're going to quickly learn
    how to do some basic user input in Java. At this point in time, you don't have
    the knowledge base to fully grasp the intricacies of what we're about to do, but
    you may have a basic understanding of what's going on and you can certainly repeat
    the process on your own in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing to this **InputStream**/**Console** window is kind of a simple
    fire-and-forget process, reading input in Java can be a little more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ee0bc80-e7a7-467d-be90-0f391752e393.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'User input is put into a buffer that our program accesses when it''s prompted
    to; therefore, we need to declare a variable that will allow us to access this
    buffer when we need to get some new user input. For this, we''re going to use
    the `Scanner` class. Let''s call our new instance `reader`. NetBeans yells at
    us because `Scanner` lives in the `java.util` package, which we need to access
    explicitly. We can always import the `java.util` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the part where you kind of have to take a leap of faith and jump a
    little bit ahead of what you''re really ready to completely and totally understand.
    We need to assign a value to this `reader` variable of the `Scanner` type so that
    it links with the InputStream window, where our user will be entering their input.
    To do this, we''re going to set its value to the value of a brand new `Scanner()`
    object, but this Scanner object is going to be created with a type argument, that
    is, `(System.in)`, which happens to be the link to the InputStream our users will
    be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e06f5667-f6bc-4689-a1ad-e0d229864520.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like I said, this is some heavy hitting stuff and you certainly shouldn't expect
    to understand how this works at a lower level right now. For now, know that `reader`
    is connected with our InputStream window, and our `Scanner` object has the `next()`
    function that allows us to access the input that the user has just entered into
    the stream. Like most functions, this function simply returns this input, so we're
    going to have to create a string to store this input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we''ve done this, we can use our `System.out.println()` function to print
    the `input` value back to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we run our program, nothing appears to happen, but in actuality, our console
    here is waiting for some user input. Now, when we type our input into this console
    and hit *Enter* key, it will echo right back at us:![](img/2fa36d7d-6ad2-47af-a345-6939a71bfe6d.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can make this a little nicer to use by having our program prompt the user
    for the input rather than simply waiting quietly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, I promised you''d learn about conditional
    statements, and we''re about to do that now. But first, let''s make a quick modification
    to the user input portion of our program. Rather than acquiring a string, it''s
    going to be a lot easier if we learn conditional statements working with a user-provided
    integer value. So let''s change the value or the type of our `input` variable
    to an `int` datatype; the `reader.next()` function returns a string, but there''s
    a similar function called `nextInt()` that will return an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We're certainly not going to bother putting any error-handling mechanism in
    our very simple program.
  prefs: []
  type: TYPE_NORMAL
- en: Know that if we accidentally provide this Java program with anything besides
    an integer, the program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: So what are conditional statements exactly? Well, conditional statements allow
    us to send our program down different paths, executing different lines of code
    depending on whether or not something is true or not. In this chapter, we'll use
    conditional statements to print different responses to our user depending on the
    value of the input they give us. Specifically, we'll let them know whether the
    value they've given us is less than, greater than, or equal to the number 10\.
    To start this process off, let's set up our output cases.
  prefs: []
  type: TYPE_NORMAL
- en: If our user provides us with input that is greater than 10, we print out `MORE`.
    If the user provides us with input that happens to be less than 10, we print out
    `LESS`. Of course, if we run this program right now, it will simply print out
    `MORE` or `LESS`, both the lines. What we need to do is use conditional statements
    to make sure that only one of these two lines executes in any program run, and
    that the proper line executes of course. You may have noticed that the default
    project NetBeans created for us divides our code into segments that have curly
    brackets around them.
  prefs: []
  type: TYPE_NORMAL
- en: We can further divide our code into segments using brackets of our own. Convention
    dictates that once we've created a new set of brackets, a new segment of code,
    we need to then add a tab before everything between the brackets to make our program
    more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Using if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve sectioned off our two `system.out.println` statements, we''re now
    ready to provide cases that must be true if these statements are to run. To do
    this, we preface our new sections with the Java `if` statement, where `if` is
    a Java keyword and it''s followed by two parentheses between which we put the
    statement to be evaluated. If Java determines that the statement we write between
    the parentheses is true, the code in the following brackets will execute. If Java
    determines that the statement is false, the code in the brackets will be completely
    skipped. Essentially, we''re going to give this `if` statement two pieces of input.
    We''re going to give it the variable `input`, which if you remember contains the
    integer value that we got from the user, and we''re going to give it the explicit
    value `10`, which is what we''re comparing it to. Java understands the greater
    than (`>`) and the less than (`<`) comparison operators. So, if we make this `if`
    statement `if(input > 10)`, then the `System.out.println` command (as seen in
    the following screenshot) will only run if the user has provided a value that''s
    greater than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to provide an `if` statement to make sure that our program doesn't
    always print out `LESS` anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the less than operator to ask our program to print out `LESS`
    whenever the user provides input that is less than 10\. This would be good in
    almost all cases, but if our user provides the input value 10, our program would
    print out nothing. To fix this, we can use the less than or equal to operator
    to ensure that our program always responds to the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's quickly run our program to make sure that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a prompt for input in the InputStream window. Let''s start by giving
    it a value that is greater than 10 and pressing the *Enter* key. We get the `MORE`
    response and not the `LESS` response; this is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1c5ebc2-852f-4f95-8a4f-b36932e7fcbc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our program doesn't loop, so we're going to have to run it again to test the
    `LESS` output, and this time let's give it the value `10`, which should trigger
    our less than or equal to operator. Tada!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d01689c-e4d7-48ee-bf12-29c9be84c256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using else statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that there''s a slightly easier way to write the preceding program.
    When we write a conditional statement or rather a pair of conditional statements
    in which we''re always going to execute one of the two code blocks, it''s probably
    a good time to make use of the `else` keyword. The `else` keyword must follow
    a bracketed `if` block, then it''s followed by brackets of its own. The `else`
    statement will evaluate to true and execute the code between its brackets only
    if the code between the previous `if` brackets was not executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, we will get the same results as we did before with
    one less bit of logic code to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19ce9e8f-2b8f-406a-b701-34809cabf6c7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s end this topic with a brief run-through of what other operators we can
    use in our `if` statements, then we''ll take a look at what to do if we need to
    compare items that are not primitives. In addition to the greater than and less
    than operators, we can also make use of the equality operator (`==`), which is
    true if the items on both the sides have the same value. Make sure when you use
    the equality operator, do not accidently use the assignment operator (`=`) instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In some instances, your program won''t compile, but at other times it will
    compile and you''ll get very weird results. If you''d like to use the opposite
    of the equality operator, you can use not equals (`!=`), which returns true if
    the two items do not have the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It's important that we do not attempt to use these equality operators when comparing
    instances of a class. We should only use them when we're working with primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this, let''s modify our program so that we could take `String` as user
    input. We''ll see whether `String` is equivalent to the secret password code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60cd30ee-5d55-4ffa-a99a-2b40396097bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If it is, it will print out `YES`; if not, it will print out `NO`. Now, NetBeans
    gives us a warning (as shown in the preceding screenshot); in fact, if we attempt
    to compare strings with some different operators, NetBeans would let us know that
    our program is probably not even going to compile. That''s because Java does not
    expect us to compare instances of a class with these operators. Instead, classes
    should expose functions that allow us to compare them logically. Almost every
    object in Java has a few functions for this purpose. One of the most common ones
    is the `equals()` function that takes an object of the same type and lets us know
    whether they''re equivalent. This function returns what''s called a **Boolean
    type**, which is a primitive type of its own that can have a value of either true
    or false. Our `if` statement understands how to evaluate this Boolean type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our program quickly and start by inputting a bad string, then let''s
    input `password` to see our program work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9cf84c3-0f85-40e3-8ba6-3b0c5fb8eaa0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's the basics of `if-else` statements. I would encourage you now to play
    with some of the comparison operators that we looked at and try nesting `if...else`
    statements within each other.
  prefs: []
  type: TYPE_NORMAL
- en: As a very last note, you may sometimes see `if` statements without their following
    brackets. This is a valid syntax and is basically the equivalent of putting the
    entire statement on one line.
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, let's write a very simple Java program. We'll start by importing
    `java.util` so that we can get some user input via a `Scanner` object, and we'll
    link this `Scanner` object with the `System.in` input string so we can use it
    in the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done this, we''re going to need to get some input from the user
    and store it, so let''s create a new string and assign its value to whatever the
    user gives us. To keep things interesting, let''s give ourselves two more String
    variables to work with. We''ll call them `sOne` and `sTwo`; we''ll assign the
    value of our first string variable to `abc` and the value of our second string
    variable to just `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this topic is about conditional statements, we''re probably going to
    need one of those, so let''s create an `if...else` block. This is where we''ll
    evaluate our conditional statement. We''ll set ourselves up some output so we
    can see what''s going on. If our conditional statement evaluates to true and we
    enter the following portion of the block, we''ll simply print out `TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the conditional statement evaluates to false and we skip the previous `if`
    portion of the block and instead enter the `else` portion, we''ll print out `FALSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The contains function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s probably time to write our conditional statement. Let me introduce
    you to a new string function called the `contains` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `contains` function takes as input a sequence of characters of which a string
    qualifies. As output, it gives us a Boolean value, which means it will either
    output `TRUE` or `FALSE`. So our `if` statement should understand the result of
    this function and evaluate to the same. To test our program, let's start by simply
    going through the following process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll provide our `contains` function with the value stored in the `sOne`
    string which is `abc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we run our program and provide it with `abcdefg` which contains within
    it the `abc` string, we get the `TRUE` result. This is because `input.contains`
    evaluates to true and we enter the `if` portion of our `if...else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/886ca0f1-ddab-4e6d-be46-ecb2e2c31df5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to run and provide some gibberish that does not contain the `abc`
    string, we could instead enter the `else` statement of the block and return `FALSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e77543-5023-400f-9057-cf280175bef0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nothing too crazy there. But, let's say we want to make our program a little
    more complicated. Let's look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we want to check and see whether our input string contains both the
    strings, namely `sOne` and `sTwo`? There''s a couple of ways to do this, and we''ll
    take a look at some others. But probably, the simplest way for our purposes is
    to use a **complex** conditional on the `if(input.contains(sOne))` line. Java
    allows us to evaluate multiple true or false statements, or Boolean objects, at
    once using the `&&` or the `|` conditional operator. The `&&` operator gives us
    a true result when all conditionals compared with the `&&` operator have evaluated
    to true. The `|` operator gives us a true result when any of the conditionals
    compared with the `|` operator evaluate to true. In our case, we want to know
    whether our input string contains both the contents of `sOne` and `sTwo`, so we''re
    going to use the `&&` operator. This operator works by simply providing two conditional
    statements on either side of it. So, we''re going to run our `input.contains`
    function on both `sOne` and `sTwo`. If both these functions on either side of
    the `&&` operator, which is expressed as (`if(input.contains (sOne) && input.contains
    (sTwo))`, evaluate to true, our conditional statement will be true as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our program. The `abcz` string should evaluate to true in both cases,
    and when we press *Enter* key, we see that this is in fact the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7f9e3c4-ec4b-47c7-945a-83f2a8cbdeff.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to provide only the valid string `z`, we would get a false result
    because our `&&` operator would evaluate false and true, which evaluates to false.
    If we were to use the `|` operator, this would be the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/434b956d-d20a-4387-acbb-76dfbc0aa772.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This would in fact give us a true result because we only need one of these functions
    to return true now. Boolean logic can get pretty crazy pretty quick. For example,
    we can put the `&& false` statement at the end of our Boolean condition, namely
    `if(input.contains(sOne) || input.contains(sTwo) && false)`. The `true` and `false`
    code terms in Java are keywords; in fact, they're explicit values, just like a
    number or a single character would be. The `true` keyword evaluates to true and
    the `false` keyword evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any single conditional statement that ends with `false` will always evaluate
    as a whole to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Curiously though, if we return to our previous original statement and run the
    following program providing it with the most valid possible input, we''re going
    to get the true result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07c8a447-62db-4e98-b65e-34a9c778ef5d.png)'
  prefs: []
  type: TYPE_IMG
- en: That's interesting because if Java had chosen to evaluate the `if(input.contains(sOne)
    || input.contains(sTwo))` statement first and then the `&& false` statement, we
    would have gotten a false result; instead, Java seems to have chosen to evaluate
    the `(input.contains(sTwo) && false)` statement first and then the `||` statement,
    that is, `(input.contains(sOne) ||)`. This can make things confusing pretty quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, just like in algebra, we can ask Java to do operations in a specific
    order. We do this by surrounding the blocks of our code with parentheses. Blocks
    of code within parentheses will evaluate before Java leaves the parentheses to
    evaluate against something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, after we''ve surrounded our `||` statement with parentheses, we''ll compute
    the `||` statement and then end that result with `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now see that our preceding program always evaluates to false here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7c6a449-89cb-44ed-8d2e-a56f6144f07d.png)'
  prefs: []
  type: TYPE_IMG
- en: So complex conditionals can get pretty complicated pretty quick. If we come
    across something like this `if` statement in code, especially if it's code that
    we haven't written, it can take us a good while to figure out exactly what's going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The boolean variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help us with what we discussed in the preceding section, we have the `boolean`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, `boolean` is a primitive type in Java, and a
    variable of the `boolean` type can have only one of the two values: it can be
    either `true` or `false`. We can set the value of our Boolean variables to be
    any conditional statement. So, if we wanted to simplify how our code looks in
    the actual `if` statement, we could go ahead and store these Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to do this before we actually evaluate the `if` statement, keeping
    everything much more compact and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the name of the game is keeping our code as simple and readable
    as possible. A really long conditional might feel great to write, but oftentimes,
    there's a more elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: That's the nuts and bolts of complex conditionals in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Switch, case, and break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at the `switch` statement, which
    is another way that we can modify the control flow of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s create a new project in NetBeans. At my end at least, I''m
    going to get rid of all these comments. To demonstrate the power of the `switch`
    statement, we''re going to start by writing a program using only `if` blocks,
    then we''ll convert the program to one that uses `switch` statements. The following
    are the steps for the program that uses only `if` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s simply declare a variable `x`, (`int x =1;`), and here is
    our goal: If the value of `x` is `1`, `2`, or `3`, we''d like to print out the
    responses `RED`, `BLUE`, or `GREEN`, respectively. If `x` is not one of those
    numbers, we''ll just print out a default response.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Doing this with `if` blocks is pretty straightforward, if not a little tedious:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll pretty much just copy and paste this block of code and modify
    it for the blue and green cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For our default case, we simply want to check that `x` is not equal to `1`,
    `x` is not equal to `2`, and `x` is not equal to `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give our program a very quick run-through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot of the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e3988b1-d934-4ed0-967b-bce9492aaba4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a simplified version of something we might logically find ourselves
    doing in the course of writing a bigger program. While we put together this at
    a pretty decent clip, it's easy to see how this problem would become extremely
    unwieldy if we were dealing with many possible cases of `x`. And, it's also pretty
    difficult for someone to read and figure out what's going on here. The solution,
    as you've probably guessed, is to use a `switch` statement to control our program's
    flow instead.
  prefs: []
  type: TYPE_NORMAL
- en: Program using switch, case, and break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to execute different lines or blocks of code depending on the
    value of an individual variable, the `switch` statement is extremely effective.
    Now let''s rewrite our series of `if` blocks using a `switch` statement instead.
    The syntax is explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare that we''re going to use a `switch` statement, `switch` being
    a reserved keyword in Java. Then, we provide the name of the variable that we''d
    like the `switch` statement to act on, in this case `x` because we''re going to
    execute different blocks of code depending on the value of `x`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, just like using an `if` or `else` statement, we're going to create a new
    segment of code using two brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of creating a series of unwieldy `if` blocks, we create separate
    blocks in our `switch` statements using the `case` keyword. After each `case`
    keyword, we give a prescribed value, and the following code will execute if the
    value of `x` matches with the value of the `case` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, just like when we were doing our `if` blocks, if the value of `x` is `1`,
    we'd like to print out `RED`. Writing separate cases for each of the possible
    values now becomes much cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statements also have a special case, the `default` case, which
    we pretty much always put at the end of a `switch` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This case will only execute if none of the other cases have executed, and it
    means that we don''t have to write that complicated Boolean logic for our last
    `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding program, we''re actually going to see every possible
    output execute. That''s because we''ve forgotten to do something very important:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e4403de-f278-4069-aa68-c503c2128703.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `switch` statements allow us to create complicated logic trees because once
    a case starts executing, it will continue to execute even through the next cases
    in the queue. Because we're writing a very simple program where we only want a
    single case to execute, we need to explicitly end the execution once we enter
    a case and finish the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that with the `break` keyword, which exists on a line of code all
    by itself and simply steps us up and out of the case that we''re in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run our program, we''ll see the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6836df9b-f730-468b-a41d-38a45cb27b2f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to falling through from one case to another, we can increase the
    complexity and the power of our switch statements by adding multiple cases to
    a single line. Because the cases freely fall through to each other, doing something
    like `case 1: case 5: case;` means that the following block of code will execute
    if we provide one of these numbers: `1`, `5`, or `7`. So there''s the quick and
    easy way of `switch` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1feaa12-6894-4d4d-acff-58e1fc2bb4f2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Switch statements essentially compare the variable or explicit value we're switching
    and the cases using the equality (`==`) operator. If elements cannot be compared
    with the equality operator, the switch statement will not work properly.
  prefs: []
  type: TYPE_NORMAL
- en: As of Java SE v7, you can compare strings with the equality operator so you
    can use them in `switch` statements. This was not always the case, and it's still
    a good idea to avoid using strings with the equality operator in your `switch`
    statements. This is because it destroys the backwards compatibility of the code
    you're writing.
  prefs: []
  type: TYPE_NORMAL
- en: While and do...while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the introductory lesson on loops. At the end of this section, we''ll
    have command over Java''s `while` and `do...while` loops. I''m pretty excited
    about this because loops allow us to execute a block of Java code over and over
    again as many times as we see fit. This is a pretty cool step in our learning
    process because the ability to perform small tasks many times in rapid succession
    is one of the things that makes computers better at certain tasks than humans
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin this topic, let's create a new NetBeans project, enter the `main` method,
    and simply declare an integer and give it a value. We can choose any positive
    value. We're going to ask our program to print out the phrase `Hello World` a
    number of times equal to the value of our integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we''ll employ a `while` loop. The `while` loop syntax looks a lot
    like we''re writing an `if` statement. We begin with the reserved `while` keyword
    and follow it by two parentheses; inside these, we''re eventually going to place
    a conditional statement. Just like it was an `if` statement, the following block
    of code will only execute if our program reaches our `while` loop and evaluates
    its conditional statement to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What separates `while` loops from `if` statements, however, is that when the
    end of the `while` loop's block of code is reached, our program will basically
    jump back and execute this line of code again, evaluating the conditional statement
    and reentering the while loop's block of code if the conditional statement is
    still true.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by setting up the logic for our `while` loop. We have the number
    of times we would like our loop to execute stored in the value of the integer
    i, but we're going to need a way to communicate this to our loop. Well, any loop
    that is not going to run infinite times is going to need to make some control
    flow changes within the content of the loop. In our case, let's change the state
    of our program each time the loop runs by decreasing the value of i so that when
    i reaches 0, we would have ran the loop five times.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that''s the case, it means that we only want our loop to execute when the
    value of `i` is greater than `0`. Let''s pause and quickly take a look at this
    line of code. Here `i = i -1` is a perfectly valid statement, but there''s a shortcut
    we can use that''s a little faster and easier to read. We can use `i--` to decrement
    the value of an integer variable by one. Once we''ve set this up, the only thing
    left to do is place the functional code inside of our loop; that''s simply a `println`
    statement that says `Hello world`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our program and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b53deb54-febf-49fd-b361-d2f8ac16958b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There we go, five `Hello world` instances printed to our console window, just
    as we intended.
  prefs: []
  type: TYPE_NORMAL
- en: While loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we allow small programs, such as the ones we''re writing here, to end
    when there''s simply no more code for them to execute. However, while we''re working
    with loops, we''re probably going to make the mistake of accidentally creating
    an infinite `while` loop and running a program that has no end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When this happens, we''ll need to turn our program off manually. In NetBeans,
    there''s a handy little feature called Stop at the left-hand side of the output
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7d6f44b-a371-4bc4-becf-8a58f2ef672d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we''re running a program through a Command Prompt, *Ctrl* + *C* is the common
    command to cancel the execution of a program. Now that we have a grasp of the
    basic `while` loop syntax, let''s try something a little more complicated and
    much more dynamic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program I have in mind is going to need some user input, so let''s import
    `java.util` and set up a new `Scanner` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than gathering user input right away though, we''re going to collect
    new user input every time our `while` loop successfully executes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time we gather this input, we''re going to need somewhere to store it,
    so let''s create a new string whose purpose will be to store the value of the
    newly acquired input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This `input` variable's value will change a number of times throughout the execution
    of our program because at the beginning of every `while` loop, we'll be assigning
    it a new value. If we were to simply execute this program, it wouldn't be very
    interesting for us, the user, because the old values of our input string would
    constantly be lost when we assign it a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create another string whose purpose is to store all the concatenated
    values that we''ve gotten from the user. Then, at the end of our program, we''ll
    print out the value of this string so that the user can see we''ve been storing
    their input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the value of the input to the all string on the line illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a couple of things we can do. We can add strings with the addition
    operator just fine. So the `all = all + input` statement, with `all` and `input`
    being strings, and the plus sign are perfectly valid. However, when we add something
    to itself and work with a primitive or a type that can act like a primitive as
    a string can, we can also use the `+=` operator, which performs the same function.
    Also, we cannot forget to reimplement the decrement of the integer value `i` so
    that our program doesn''t run infinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this program and provide five strings of input, we get the output
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c471b2c-2671-4516-a0f3-1eac27ec5548.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll see them all spit back out at us as expected, which is pretty cool, but
    I've got bigger plans for this program.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, if we'd only wanted to write the program we have right here, a `for`
    loop, which we'll learn later, might have been completely appropriate. But for
    what we're about to do, `while` and `do...while` loops are pretty necessary. What
    I'd like to do is get rid of our counting variable in this program. Instead, we're
    going to allow the user to tell us when to stop executing our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user sets the value of the input to the `STOP` string, in all capital
    letters, we''ll quit executing our `while` loop and print out all the strings
    they''ve given us so far. So, we only want this `while` loop to run while the
    value of the input is not the `STOP` value. You''ll notice that we''ll get a precompiled
    error as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2271039-64d5-4e5d-8032-3d104f32c4d8.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll get a full-on compiler error if we do attempt to run our program. That's
    because our program knows that when we attempt to execute this conditional statement
    for the first time, the value of the input will not have been set. Even though
    the nonexistent value of the input is not equivalent to `STOP`, it's a very bad
    form. In the case of a string here, which is not a primitive, it is not possible
    for our computer to access any of its methods before it's given any value at all.
  prefs: []
  type: TYPE_NORMAL
- en: One inelegant solution here would be to give the input a start value, like we
    did with `all`, but there's a better way. Once our loop has executed for the first
    time, we know that the input will have a proper value given by the user, which
    may or may not be `STOP`.
  prefs: []
  type: TYPE_NORMAL
- en: The do...while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if instead of checking our conditional at the beginning of our loop, we
    check it at the end? This is in fact an option. The `do...while` loops operate
    just like `while` loops, but the first time they run, they won''t check to see
    whether a conditional is true; they''ll simply run through and check their conditional
    statement at the end. We do need to put a semicolon at the end of a conditional
    statement on the back of the `do...while` loop. I just mentioned this because
    I always forget it. Now, if we run our program, we can give any number of strings
    and then type in the `STOP` string to see everything we''ve typed so far and printed
    out to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/020caa84-f084-411a-b257-0a1e9854a695.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a last little note, with just about anything followed by its own code block,
    you'll see a syntax like this, where you will have a keyword and may be a conditional
    statement and then brackets on the following lines; alternatively, you might see
    the brackets start on the same line as the keyword and the conditional statement.
    Both the methods are completely valid, and in fact, the brackets starting on the
    same line as the keyword is probably quickly becoming more common.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to play around with the program we've written. Try executing
    loops that you think will push the boundaries of how much information a string
    can hold, or play around with loops that present an enormous amount of information
    to the screen. This is stuff that computers do that we simply couldn't with pencil
    and paper, so it's pretty neat.
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a quick look at `for` loops. We use `for`
    loops to solve a common problem in Java in a very semantically elegant manner.
    These loops are appropriate when we need to iterate a variable to count how many
    times we've looped.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, I''ve written a very basic program using a `while` loop; it prints
    the values `1` through `100` to the window on our screen. Once you''ve hashed
    out in your mind how this `while` loop is working, we''ll write the same loop
    with a `for` loop so that we could see how the `for` loop is more elegant in this
    particular instance. Let''s comment out our `while` loop so that we can still
    see it as shown in the following screenshot without having it execute any of its
    code and begin writing our `for` loop instead :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4996023-cabc-4c0c-8152-afe66ac3487a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The basic syntax of a `for` loop looks very similar to that of a `while` loop.
    We have the reserved keyword, two parentheses in which we'll put some information
    that the loop needs, and the code block that we're going to loop through. Unlike
    a `while` loop, which just takes a conditional statement between these parentheses,
    we're going to provide our `for` loop with a bunch of information. Because the
    `for` loop is designed to handle a specific case, once we give it all this information,
    it will know exactly what to do with it. This alleviates the need for us to handle
    code outside of the loop and manually increment or decrement it inside of the
    loop. It keeps the functional bit of our code, our `println` statement, and in
    more complicated programs, the more complicated information that may be inside
    the `for` loop, more isolated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our typical `for` loop takes three pieces of input. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to declare the variable that we're going to be incrementing or
    decrementing to count the number of times we've looped. In this case, we'll use
    an integer `i` and give it a initial value of `1`. We follow this initial statement
    with a semicolon. This is not a function call; it's special syntax for the `for`
    loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second piece of information the special syntax requires is the conditional
    statement that we need to evaluate each time we're going to restart the loop.
    If this conditional statement is ever not true, then our `for` loop ends and we
    continue resuming our code after the `for` loop block. In this case, our conditional
    statement will be the same as it was for the `while` loop. We want our last iteration
    of the `for` loop to be when `i` is equal to `100`, that is, when we print out
    `100`. Once `i` is no longer less than or equal to 100, it's time to exit our
    `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just as the first piece of information we specially gave the `for` loop saved
    us from having to handle a variable outside the scope of our loop, the last piece
    of information we will give the `for` loop takes the place of us having to manually
    increment or decrement our counter inside the scope of the loop. This is the special
    modification code, and whatever we provide the `for` loop here will run at the
    end of every loop. In this case, we''d just like to increment the value of `i`
    at the end of each looping through. I think you''ll agree that this program is
    much cleaner than our `while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s just check that it performs the same task of printing the value
    of `1` to `100` to our screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cb8b21e-035c-4dfc-8e7b-4a57d4888cf2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this statement were to execute at the very beginning of our `for` loop, `0`
    would have been correct, but this executes at the end.
  prefs: []
  type: TYPE_NORMAL
- en: When we're working with large numbers and increments in Java or any programming
    language really, we call errors, like what we just ran into, **off-by-one error**
    (**OBOE**) errors. OBOE are those kinds of little logic mistakes that even experienced
    programmers can run into if they don't pay attention or just look the wrong way
    for an instance. Learning to recognize the symptoms of OBOE, for example, one
    more line outputted than expected, will allow us to track them down and find them
    much more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we basically saw how to work with conditional `if...else` statements
    running through the complex conditionals using functions such as `contains`, `complex`,
    and `boolean`. We went through the intricacies of `switch`, `case`, and `break`
    with the help of programs; also, we dived deep into how to use the loop functionality
    using the `while`, `do...while`, and `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at something called a **data structure**.
  prefs: []
  type: TYPE_NORMAL

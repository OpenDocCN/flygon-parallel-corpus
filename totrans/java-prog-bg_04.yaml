- en: Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn some of the most important data structures
    in Java. We'll look at what arrays are and how they are useful when we need to
    work with sequences of variables. We'll write a program in NetBeans using arrays
    to understand how they work. This chapter will also walk us through the concept
    of multidimensional arrays. We'll write a program to create a chessboard using
    a two-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, this chapter will illustrate what ArrayLists are and how they provide
    increased functionality when compared to arrays. Finally, we'll look at the `Map`
    data structure and implement it in NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and their syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array example to print the English alphabet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A program to create a chessboard using a 2D array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayList and its example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps and their implementation in NetBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we're going to learn about Java arrays. Arrays are Java's most
    basic and commonly used data structure. Data structures are tools that allow us
    to store and access sequences of information rather than using individual variables.
    Variables are great when we have one specific piece of information that we need
    in our local programming space, but data structures are used when we want to store
    large or complicated sets or series of information. We're going to start this
    section with some visual learning modes, and then we'll jump into our NetBeans
    IDE to write some actual Java code and make use of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by taking a look at the syntax behind declaring and initializing
    an array in Java. The following line of code will cause an array to come into
    being with enough space to hold seven characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To the left of our assignment operator (`=`), the syntax looks pretty familiar,
    not unlike the syntax we would use when declaring any other primitive or object.
    We begin by telling Java what type of element we're going to declare here. In
    this case, we're declaring a character array. The empty square brackets lets Java
    know that rather than creating a single character variable, we'd like to declare
    an array type variable because our array is a variable just like any other. We'll
    access the elements of the array through the array's variable name itself, not
    through the individual variable names of the elements, which we don't need to
    assign as they are being stored in an array. Once we've told Java what type of
    array we're going to create, we give our array variable a name. I've called this
    one `arrayVar`.
  prefs: []
  type: TYPE_NORMAL
- en: To the right of our equality operator, things look a little different. You may
    have seen the `new` keyword used in the past when we needed to create a new instance
    of an object, not a primitive element. When we create a primitive element in Java,
    Java knows exactly how much memory space is needed to store the primitive element,
    no matter what its value is. However, objects and arrays can have many different
    size requirements. Because a single array variable can be assigned to arrays of
    different lengths, we're going to need to tell Java how much memory to put aside
    for each of these different length arrays when we create them. When creating an
    object or an array, therefore, we use the `new` keyword to tell Java that it should
    set aside memory space to place what we're about to cause to come into being,
    and that thing is a character array of length seven.
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring and initializing our seven character array, what exists in
    our program''s local memory is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d309c8b-43d4-4a06-8e54-171a1043da0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Our array is basically a block of memory large enough to store seven individual
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The location of our array is accessed by our program when we call the `arrayVar`
    variable. This allows us to run lines of code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `arrayVar` variable gives us access, essentially, to seven different character
    variables. When we don''t want to assign a new array to our `arrayVar` variable,
    we''re probably going to be accessing these character variables as individuals.
    We do this simply using the variable name of `arrayVar`, following it with square
    brackets, which include the index of the individual character we''d like to access.
    Remember, when our computers count indexes, they almost always begin with **0**.
    So, in Java, our seven-character array has these indexes: **0**, **1**, **2**,
    **3**, **4**, **5**, and **6**. If we execute the preceding line of code while
    setting the value of index `2` in our `arrayVar` to `c`, we will take the third
    block of memory and assign its value to the character `c`, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e6c8b8-c4a9-4b21-8862-53c6b33889f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes when we declare an array, we just want to go ahead and assign values
    to all of its memory blocks right there in the code explicitly. When we want to
    do this, rather than using the `new` keyword and having our computer space out
    the new memory space by telling it how long the array is, we can explicitly declare
    an array, like we explicitly declare a primitive type. For example, we would do
    this for our `arrayVar` variable with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will create an array of length seven simply because
    seven elements are declared, and of course, it will map the values accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f96737c2-efd9-4c2f-bdb4-9c62057f3c8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's jump into some Java code and put arrays to work.
  prefs: []
  type: TYPE_NORMAL
- en: Array example in NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, I think it's time to employ our newfound knowledge and write a computer
    program. Arrays allow us to manipulate amounts of information that would be unwieldy
    to deal with at the individual element level. So, we're going to jump right into
    hard-hitting stuff and create a cool computer program. Arrays are a big logic
    step, and if you haven't worked with something like them before, it can take a
    little time to wrap your head around them. The good news is if you make it through
    arrays in Java, you're probably going to be just fine with anything else the language
    can throw at you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program I would like to write will print the English alphabet to our screen.
    We could, of course, do all of this by ourselves by just doing something along
    the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, employing this is pretty mind-numbing and it's not going to teach us
    much. Instead, the program that we're going to write is going to learn, store,
    and print out the English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we're going to need to employ our newfound knowledge of arrays,
    our existing knowledge of how characters work and mapping integer values on an
    ASCII table, and a single `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our programming by declaring and initializing a character array
    in which to store the characters of the English language. So, we tell Java that
    we''re going to need a variable to point to an array of characters. I''ll call
    this variable `alpha`. Then we''re going to ask Java to set aside memory space
    by using the `new` keyword for `26` characters, because the English language has
    26 letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you remember, character values can also map to integer values. To find
    these, we will look for an ASCII table. (You can access the ASCII table at [www.asciitable.com](http://www.asciitable.com/).)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f6be8e-6290-44ce-97ce-b9bb46a323d6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The value we''re looking for is **97**, the integer value of a lowercase **a**,
    which is the first character in the English language. So let''s create a little
    comment in our program and store the value `97` for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating a for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s begin creating our `for` loop. Our `for` loop is going to run 26
    times; each time it runs, it will take the next character in the English alphabet
    and place it in our character array: `alpha`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure our `for` loop runs exactly 26 times, we should declare a counting
    variable, say `i`, and set it to `0`, that is, (`i=0`). Next, let''s say that
    our `for` loop should continue to run as long as the value of our counting variable
    is less than `26`, that is, it should take values between `0` and `25` (`i<26`).
    Lastly, every time our `for` loop runs, we need to increase the value of our counting
    variable by one so that it goes up each time, and after 26 iterations, the `i<26`
    statement will no longer be true and our loop will stop at (`i++`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside our `for` loop, we're going to assign values to the spaces in our
    character array one by one. To access one of these spaces, we will use the name
    of the variable assigned to our array, that is, `alpha`, followed by a number
    (or index) within square brackets to tell Java which character in our array we
    would like to assign a value to.
  prefs: []
  type: TYPE_NORMAL
- en: The index of our array should be different each time we run through the loop.
    This is the beauty of `for` loops. By starting our counting variable `i` at `0`,
    we can use it to map to the index of our array. That is, we can use `alpha[i]`
    to access elements of the array one by one. Our counting variable's value, as
    our loop runs, will range from 0 to 25\. The index values of our array (because
    computers start counting at zero) also ranges from 0 to 25.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what value do we assign to each character so that our computer will learn
    the alphabet? Well, I like to think of it this way: when we run through the loop
    for the first time, the value of the first element of our array, when `i` is `0`,
    should be `97`, which is the integer value of the character **a**. Now, when we
    should assign `97+i` as the value of each character in our array. When we run
    through our loop the second time, `i` is incremented by one, and we''ll be assigning
    the value 97 + 1, or **98**, which is the integer value of the character **b**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, Java is asking us to explicitly let it know that we would
    like to cast this integer value to a character and then store it.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the alphabet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to finish off our program, all we need to do is print out our `alpha`
    array. To do this, let''s make use of a nifty function in an always accessible
    object called `Arrays`. The `Arrays.toString()` function will convert a single
    dimension array, which is the kind of array that we''ve created, that is capable
    of being converted into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our program, we''ll see Java''s representation of the English
    alphabet in array form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f64fbff0-7f63-4e4b-bc9b-42930ad80643.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have followed along with this, you should give yourself a solid pat on
    the back. That's some heavy lifting we just did.
  prefs: []
  type: TYPE_NORMAL
- en: Default initialization of arrays in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s jump back into theory for the rest of this section. I misled you
    earlier when I led you to believe that our newly created arrays were filled with
    empty memory space. In fact, when we declare a new array of a primitive type,
    that is, characters, integers, Booleans, floats, and so on, Java fills it with
    default values. For example, our new array of seven characters was filled by seven
    space characters, that is, what you''d get if you pressed the spacebar on your
    keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83398f87-f920-4c84-9b7d-3a7227bb310a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, an array of integers would be filled with seven zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2e6f3b3-fef4-445f-9385-8a0f2eb177a9.png)'
  prefs: []
  type: TYPE_IMG
- en: I recommend that you boot up a Java IDE and create some empty primitive arrays
    and print them out using `println` to see what the default values are.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create arrays of any object available to us. However, objects, unlike
    primitives, do not have default values that they set themselves to when they are
    initialized as part of an array. This is an important thing to realize.
  prefs: []
  type: TYPE_NORMAL
- en: Anything that we would need to use the `new` keyword to create will not default-initialize
    in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say for some reason we decided that we must have seven `Scanner` objects
    in an array. The following statement does not create seven `Scanner` objects for
    us; it simply sets aside memory space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc6f82a1-e7e7-4e04-a449-682ff95ee803.png)'
  prefs: []
  type: TYPE_IMG
- en: We can create `Scanner` objects and assign them to these memory spaces, but
    if we try and call one of these memory spaces and use a Scanner-specific function
    from it before we've assigned a `Scanner` object to the memory location, our program
    will crash. We'll get what's called `NullReferenceException`, which means that
    Java asked nothingness to behave like a `Scanner` object.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, our most basic data structure is the array, which allows us to store
    sequences of light-typed information and access this through a single location
    in memory. Sometimes, however, arrays are unwieldy, and we want to use more strongly
    organized data structures so that they can be easier for humans to understand
    and write programs around. Oftentimes, what's appropriate here is a multi-dimensional
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '"Multidimensional array" is a pretty scary-sounding name, but in fact the concept
    behind it is very basic. The question is what happens if we create an array of
    arrays? The following line of code shows the syntax to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code will create a two-dimensional multidimensional array. You''ll
    see it''s very much like the syntax for simply creating an array of characters
    under normal circumstances, but in every instance where we reference the array
    variable now, Java is going to need two pieces of information (or two indexes).
    The preceding line of code will tell Java to create three arrays, each of which
    has enough space to store seven characters or three arrays of length seven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb6fae9f-b50e-4a72-bd5a-41c9a46a2c66.png)'
  prefs: []
  type: TYPE_IMG
- en: To cement our understanding of this concept, let's write a Java program that
    utilizes two-dimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: A multidimensional array example in NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can use multidimensional arrays to store information in abstract manners,
    it will probably be easiest for us to learn them by representing an actual two-dimensional
    object with our two-dimensional array, in this case, a chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: The classic chessboard is divided into black and white squares; it's eight squares
    in width and eight squares in height. The program we're about to write will store
    a virtual board in Java with the squares correctly labeled black and white. Then,
    at the end, we'll have it print this board out to us so that we can check whether
    we had written to our program correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multidimensional array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by simply declaring and initializing the array we''re going to
    be using. We''ll use an array of characters for this task, giving the white squares
    the character value of `W` and the black squares the character value of `B`. Since
    a chessboard is an eight by eight grid, we''re going to want to declare a two-dimensional
    array of eight arrays, each of which should contain eight characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make things even more difficult for someone to inadvertently break in
    by storing the dimensions of our board in a separate location. To do this, simply
    create a variable called `boardDim`, for board dimensions, assign it the value
    `8`, and then reference it when we create our arrays. Arrays will be perfectly
    happy to use an integer in a variable to initialize themselves, letting us create
    dynamically linked arrays if our program calls for it. Now, if someone wants to
    go to this program and scale up our chessboard, they need to only change the value
    of `boardDim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to assign our squares their proper values, we're going to need to loop
    through this array to get to each individual node and give it the value we want
    it to have.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested loops for multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops and arrays get along great because arrays always know how long they are,
    but a single `for` loop doesn't allow us to meaningfully loop through a two-dimensional
    array. A `for` loop really just goes in one direction, and our two-dimensional
    arrays have two directions.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, we're going to make use of nested `for` loops, or a `for` loop
    within a `for` loop. Our outer `for` loop will loop through each array in turn,
    while the job of our inner `for` loop will be to loop through the nodes that those
    arrays contain.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice when creating `for` loops is to use the integer variable `i`
    for your initial `for` loop, and then `j`, `k`, and so on for subsequent `for`
    loops. However, because we're creating a chessboard, which is an actual object,
    I'm going to choose the value `y` as our outer loop's counting variable. This
    is because what our loop is doing is iterating down the *y*-axis of our chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, `for` loops and arrays get along great because arrays
    know how long they are. We could simply state that we would like this loop to
    run eight times (`y<8`), but that's not good dynamic programming because if someone
    were to go along and change the size of our chessboard, our program would now
    break. We can write this loop such that it will work for a chessboard of any size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, rather than explicitly saying our loop should run eight times,
    we should have it start by asking our array how long it is. To ask an array its
    length, we just need to write `array.length` and this will returns an integer
    value. This is a two-dimensional array, so simply calling the name of the array
    to use the `length` variable will get us the length of the array''s outermost
    segment. In this case, we''re asking our two-dimensional array, "How many arrays
    do you have?" To finish off this `for` loop, we simply need to increment `y` after
    it runs each time. Thus, our outer `for` loop will loop through each array that
    our 2D array `board` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do something similar for our inner loop. Because this loop will
    be iterating through the individual elements of our rows, `x` for the *x*-axis
    seems an appropriate variable name to use. Because our array is currently the
    same length in both its segments, an eight by eight array, simply using the `board.length`
    statement, would work for now. But once again, it''s not good dynamic programming.
    If someone was to go through and change the size of our board to be eight by ten,
    this program would no longer execute properly. Instead, at the beginning of this
    inner `for` loop''s execution, let''s ask the array that we''ve currently accessed
    through the outer loop how long it individually is. This once again makes our
    program robust and allows us to accommodate multiple sizes for our board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, the next step in our program is to assign character values to each node
    in our array: `B` for black squares and `W` for white squares. Let''s start off
    by writing the code to make all the squares white. Our double `for` loop will
    pass through each node in our two-dimensional array when it executes. So, each
    time we execute the code in our inner `for` loop, we''re executing it in terms
    of one of the single two-dimensional array nodes. To get this node, we''re going
    to need to ask our `board` array what is located at row `y` and column `x`, and
    then we''ll change the value of that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Assigning different colors to our chessboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thing is, each time this inner loop executes, we're going to want a different
    value for the nodes so that we get a chessboard that is alternating white and
    black squares. To help us do this, let's add another variable to our program.
    It'll be a Boolean variable, and we'll just call it `isWhite`. If `isWhite` is
    `true`, then the next square we add will be white; if `isWhite` is false, the
    square will be black.
  prefs: []
  type: TYPE_NORMAL
- en: To code this out, let's use some `if` statements. Firstly, the `if(isWhite)`
    code term checks whether `isWhite` is `true`. If it is, then we put a `W` in our
    square. If `isWhite` is `false`, we put a `B` in the square for black. To check
    whether something is not true, we can invert any Boolean value with an exclamation
    point beforehand. This will work for Boolean or even conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply need to flip the value of `isWhite`. Well, using our knowledge
    of the exclamation point operator, which flips the value of Boolean, we can flip
    the value of `isWhite` from `true` to `false` or `false` to `true` by simply setting
    its value to the knotted version of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this program is not quite perfect. It turns out that if we do
    this, our chessboard is going to have every single row starting off with a white
    square, while a real chessboard alternates with every other row with a different
    colored square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the outer loop runs once for each row of the chessboard. So if
    we were to simply add an extra flip to our `isWhite` Boolean value at the start
    of every row, we would get alternating row starts as well. If we do it like this,
    we need to start `isWhite` off as `false` because it''s going to be immediately
    changed to `true` when the outer loop executes for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Printing the chessboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've followed along thus far, let's go ahead and write the final bit of
    our program, a line of code to print out our chessboard to the screen. Actually,
    we're going to need a bit more than a line of code. We can use the `println()`
    function along with `arrays.toString()` to print the contents of a single array
    to the screen, but this technique won't work well with a two-dimensional or higher
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re going to need to use a `for` loop again to grab each array in turn,
    and then print them to the screen. This works pretty well because `println` will
    automatically carriage return, or give us a new line between each row we print.
    Here, let''s use the conventional syntax variable `i` to iterate through our `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9febda2-dfd7-4516-9fde-4248e4d90dcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll notice that Java does not yet understand the `Arrays` keyword as shown
    in the preceding screenshot; that''s because `Arrays` lives in the `java.lang`
    package. It can be kind of annoying when we call a function or a class and Java
    doesn''t immediately know where to find it, and we have to go online and locate
    it on Google. If we''re working in an IDE, such as NetBeans, sometimes there''s
    a shortcut to find common packages. In this case, if we right-click on the problem
    statement and go to Fix Imports, NetBeans will go through the common packages
    and check whether it can figure out what we''re doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad6ff3b4-9a65-4431-b208-6bca9a0bfe94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, NetBeans has located the `Arrays` class and added the import
    statement for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because we don''t want to attempt to print out the contents of the two-dimensional
    array each time our `for` loop executes (which wouldn''t work very well anyway),
    we''re going to tell our `println` statement to print out the contents of `board[i]`,
    or the individual array, within the two-dimensional array that we''ve accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see whether we got everything right the first time through and
    run our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e6cded2-3f5b-4752-8e51-5bd514db59e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! It looks like we did. There's an alternating white and black representation
    of a chessboard that begins with a white square and has rows starting in the proper
    manner. This might not look like much now, but its significance is pretty big.
    We've essentially taught our program how a chessboard looks. This is our first
    step toward creating something much bigger, such as a program that plays chess.
  prefs: []
  type: TYPE_NORMAL
- en: 'Were we to create a program that plays chess (which is a little out of the
    scope of this section here, but we can talk about it conceptually), we would probably
    want our individual squares to be able to store more information than just what
    color they were. For example, we would probably want them to know what piece was
    on them. To make this happen, we could utilize a three-dimensional array. We could
    create an array that looks like the following so that each square could store
    an array that holds two pieces of information, one character for its color and
    another character to represent what piece it''s on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So that's the basics of multidimensional arrays in Java.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need a Java data structure, we should start by asking ourselves whether
    a simple array is sufficient. If we can write our program easily and neatly using
    just an array, that might be our best option to keep our programs simple by extension.
    If you're writing code that must run as fast as possible and use memory as efficiently
    as possible, arrays will also have very little overhead. But, in today's development
    world, where memory efficiency and speed really aren't concerns for your average
    program, sometimes we need to employ data structures with more built-in functionality,
    or maybe which are designed for a specific purpose.
  prefs: []
  type: TYPE_NORMAL
- en: A data structure with additional functionality is called an ArrayList. One of
    the weaknesses of traditional arrays is that when we instantiate them, we have
    to give them a specific length, so we have to know how large we want our array
    to be. An ArrayList is basically an array wrapped in some additional code that
    causes the array to increase or decrease in size to always be the size of the
    number of elements it contains.
  prefs: []
  type: TYPE_NORMAL
- en: An ArrayList example in NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see this in action, let's write a program that would actually be a little
    more difficult to write if we just used a standard array instead of an ArrayList.
    I'd like to write a program that will take an input string from the user. It will
    store this input string with every other input string the user has ever given
    it, and then print them all out each time the user inputs a new string.
  prefs: []
  type: TYPE_NORMAL
- en: This would be really difficult to do with an array because if the user ever
    inputs one more string than the array was designed to hold, our array would, in
    the best-case scenario, not accept the string; in the worst-case scenario, our
    program might crash. But, our ArrayList object will simply resize to fit the number
    of strings that it's currently holding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to begin by importing `java.util`, because `java.util` is where the
    `Scanner` class, which we''ll need to get user input, and the `ArrayList` class
    itself, live. Once we''ve declared a `Scanner`, which we''ll utilize a bit more
    later, it''s time for us to declare our `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Simply declaring `ArrayList` looks a lot like declaring any other object. We
    say what type of object we'd like to create. We give it a name. We use the `new`
    keyword because Java is going to have to set aside some memory to create this
    object since it's not a primitive. Then, we tell Java to actually create the object.
    Even though we're not going to provide any arguments for our `ArrayList` creation,
    we still need to follow it with the double parentheses. This is actually valid
    code we've just written, but generally when we create an `ArrayList`, we're going
    to do a little bit more.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` memory that we've created will actually store any type of single
    entity we place within it. This might sound really, really great at first, but
    honestly, it's not a good thing to have in our program. It's really easy to get
    confused if we have ArrayLists, or any data structure, really, that's storing
    just about anything, and if we feel the need to do this, we're either doing something
    really complicated, or more likely we're not writing our code as cleanly as we
    should. More importantly, once we store anything in our ArrayList, it's possible
    for us to sneak by our compiler and create code that compiles OK. However, the
    other possibility is that it would break at runtime, causing the kind of bugs
    that are really bad to have in commercial software because they can break when
    people are actually using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can tell our ArrayList to only accept information
    of a certain type. We do this by following our `ArrayList` declaration and instantiation
    with double character brackets and placing a type within them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've declared and then caused to come into being an `ArrayList` data structure
    that will only allow strings to be stored within it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to need a loop so that our user can input more than one string
    to the program. For now, let''s just use an infinite loop. It will run forever,
    but while we''re building our program and debugging it, we can always just stop
    it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each time our loop runs, we're going to want to use the `nextLine()` function
    on our Scanner variable, that is, `reader`, to grab a new line of input from the
    user that we're going to store in our ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: When we're working with object data structures, that is, data structures that
    have code wrapped around them, and functions and methods of their own, we're generally
    not going to have to deal with the individual indices of memory, which can be
    pretty nice. Instead, we use their provided functions to add, remove, and manipulate
    the information within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, adding something to an ArrayList is pretty easy. The `add()`
    function in ArrayList will add whatever input we give it, in our case, as long
    as it''s a string, to the end of the array that the ArrayList contains. So, let''s
    add the following line of code that will request a new input string from the user
    and then put it at the end of our ArrayList inside our infinite `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Printing the ArrayList of user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can simply use `println` to print our ArrayList out to the user. Note
    that the `println` code line doesn''t know how to take an ArrayList as input.
    Actually, it might, but we should explicitly use the `toString()` function, which
    almost every object in Java implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our program, we''ll be prompted for some user input, and we''ll
    see the input echoed back out at us. If we give Java some more input, we''ll see
    our more input, and the old input will be stored in our `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e01f0a61-f15e-4542-b690-6f8bdfa5e77e.png)'
  prefs: []
  type: TYPE_IMG
- en: So that's pretty cool! We've built a really basic program that would be more
    difficult to write with a simple array.
  prefs: []
  type: TYPE_NORMAL
- en: Giving control to the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ArrayLists have a lot of power contained within them. We can turn them into
    arrays, create them from arrays, and all sorts of things. If we go to the Java
    documentation and check under `java.util` for ArrayList, we can find all of their
    methodologies. Let's add few more features to our ArrayList program so that I
    can walk you through some common ArrayList methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'ArrayLists have a function that takes no input, called `clear()`, which will
    erase our ArrayList. We can utilize this function to give our users some control
    over our program. Let''s say that if the user inputs the string `CLEAR`, we would
    like to erase all of the information in our ArrayList. Well, that''s a conditional
    statement I just made, so we use an `if` statement. We''d utilize the following
    `if` statement code inside our `while` loop to implement this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to check the item just added to our ArrayList against the string
    `CLEAR`. This item will be at the very end, that is, it will be the last item
    with the highest index value. Unfortunately, there''s no `lastItem()` function
    implemented for ArrayList, but we can essentially create one ourselves by mashing
    together two ArrayList functions: `get()` and `size()`.'
  prefs: []
  type: TYPE_NORMAL
- en: First, in order to get an item from an ArrayList, we utilize the `get()` function.
    Note that `get()` is very similar to the square brackets we would utilize if we
    were accessing an item from a traditional array. Also, the `get()` function is
    going to take an integer value and it's going to map that integer to the index
    of the array contained within our ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: So, to get the last item in our ArrayList, we need to know how many items are
    there in the ArrayList. Then, we want to subtract one from that value, because
    the last index of an array with the length of, let's say seven, would be six,
    since the array starts counting at zero. To get how many items are there in our
    ArrayList, we use the `size()` function, which takes no arguments and simply gives
    us an integer that is the size of the array, that is, how many items it contains.
    We subtract `1` from that value so that we can properly access the last index
    and not the index behind it, which could contain anything. Then, we wrap the whole
    `memory.get(memory.size()-1)` block, which accesses the last item of our `ArrayList`
    in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This block of our `if` statement we just parenthesized gets for us a string
    object. We know that we can compare strings by using the `equals()` method. We
    can actually call that method from the string object that this block of code returns,
    even though we haven''t assigned it a specific variable name yet. Objects exist
    even if we don''t have a name for them, and we can call their methods and do just
    about anything we like with them if we''ve just returned them from something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, that's a pretty crazy statement we've just written, but as long as we've
    written it right, when our user enters `CLEAR` in the program, we will erase the
    ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve written this code, we can write very similar code to give our user
    different functionality options. Let''s also allow our user to type in `END`.
    Currently, we''re in a program that will loop infinitely until we manually turn
    it off. But by using the `break` Java keyword, which will jump us out of whatever
    loop we''re in, or function if we''re in a function, we can make this an escapable
    loop. This way, we let the user essentially turn off our program because once
    we leave this loop, there''s no more code to execute and our program will end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when you're using `break` statements. Make sure it makes sense to
    do so, because they can be a little confusing if you're going through someone's
    code. They break and jump the control flow all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s run this program and see what happens. We''ll start by giving our
    program some input and build the ArrayList:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae823de0-08af-458a-a9c0-062b10bb890b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s try inputting `CLEAR` and check whether it empties our ArrayList.
    Oh no! I broke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daa354cd-4dd8-4f52-ab30-374efe042f27.png)'
  prefs: []
  type: TYPE_IMG
- en: This is actually a pretty interesting error that we made. I actually made this
    error; it wasn't preplanned. I'm going to leave it in because this is a great
    learning experience for us. It also shows you that even if you're an experienced
    programmer, you're going to make mistakes. One of the reasons why we should use
    typed ArrayLists whenever we can, for example, is so that we can easily figure
    out and fix our mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing ArrayIndexOutOfBoundsException
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our program has thrown an `ArrayIndexOutOfBoundsException`. This means that
    we tried to access memory that our `memory` array did not have access to. Specifically,
    we tried to look at what was at the index `-1` of the array. Since arrays start
    at index `0`, they don't have anything at index `-1`. Any piece of our computer's
    memory could be there, and for security reasons, programs aren't allowed to just
    go looking through a computer's memory because they want to. So, why did this
    happen? Why did we ask for index `-1` of an array, which is never going to be
    a valid array index?
  prefs: []
  type: TYPE_NORMAL
- en: Well, our first `if` statement that implemented the functionality to clear our
    ArrayList executed just fine. Our program saw our `CLEAR` command, understood
    our first look at our array index, and cleared the array.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following this, we asked our program to again check the last item
    added to our array, using the second `if` statement. When we did this, we executed
    `memory.size()-1`. First, we asked Java about the size of our ArrayList. Because
    we just cleared our ArrayList, Java told us that the size of the ArrayList was
    zero, that there was nothing in it. Then we subtracted one from that value to
    get -1\. Post this, we ran `memory.get()` on that `-1` value. Thus, we asked Java
    to take a look at what was at index `-1` of our array, at which point Java said,
    "Whoa! What are you doing? It's not cool, I'm going to crash!"
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we solve this? Well, there's a couple of things we could do. We should
    probably just check and make sure that our arrays are not empty before we run
    the functions in the second `if` statement. That option looks like a few more
    lines of code than I want to put. It's not undoable in any sense of the word,
    and I encourage you to try and implement a better solution than this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, just to get our program quickly up and running without crashing, let''s
    change the pair of `if` blocks to an `if...else` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We've embedded the second `if` statement in the `else` block. This will prevent
    us from ever running both of the `if` blocks back to back. If our first `if` statement
    evaluates to be true and our clear statement gets executed, then we will not check
    for the second `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run our program and give some gibberish input to build up our ArrayList,
    and then type in `CLEAR`, we''re going to properly get the response of an empty
    ArrayList:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7adf9ca8-08b9-4c14-9d90-873227e545ea.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll never hit the second `if` statement with an array of size `0` because
    we're always going to add a line to our array beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s cross our fingers and check that the `END` input works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4da83cb8-0be7-42ee-998b-1fb11670670b.png)'
  prefs: []
  type: TYPE_IMG
- en: It does! The break command breaks specifically out of loops and functions, so
    even though we've nested it within an if and else statement, it's still going
    to break us out of the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: I think that little trip up we had was a great learning experience. That's actually
    a pretty interesting error we ran into. Nonetheless, I hope you've seen how different
    data structures have different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at Java''s `Map` data structure.
    I wanted to start with a bunch of already formatted information, so I have created
    a little program on my own. You will find the following program in the companion
    files for the book. Take a look through it and make sure you understand how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I'm operating on the assumption that we're not yet familiar with file input
    and output, so I dropped all of the data that we'd normally want to store in a
    file, or somewhere more manageable, right in the code of our program. I have created
    a `String` array that I've called `allNames`, and what it is a list of names of
    famous people. Their individual first and last names are also divided. So `Jane`,
    `Addams` comprises the first two elements of the array. Her first name `Jane`
    is part of `allNames[0]`, and then `Addams`, her last name, is at `allNames[1]`,
    and so on, with every two elements in the array being a single person's first
    and last name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a good chance for me to show you a nifty little NetBeans feature
    that''s available in most IDEs. We can talk to our IDEs often if they support
    features such as these by putting instructions for them in the comments of our
    code. Because these instructions are commented out, they won''t in any way affect
    the way our Java code compiles and runs, but we can talk to the IDE. The following
    instruction in the program, paired with its ending instruction, tells NetBeans
    that we''d like it to section off the code included between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the little box on the left-hand side of our opening instruction
    to expand and contract the block of code as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf0f56c-f800-4b58-ac72-23308b838434.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It doesn''t make the code go away; it just hides it from us so that we can
    develop it without cluttering up our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7535308f-d7b1-46cf-8b1a-43623e9b0262.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at a very quick explanation of the program I''ve written to
    start this section off. We have an array of strings called `allNames` that contains
    the first and last names of a bunch of famous people. The program I''ve written
    simply loops through this array and determines whether it''s looking at the first
    or last name. Then it places those names in separate arrays of their own. At the
    end, when we print out these arrays, we have two separate arrays: one of first
    names and one of last names. The relationship of these arrays, because we''ve
    placed them into the two separate arrays (`firstNames` and `lastNames`) in order,
    is that the indexes of the arrays match up. So, at `firstNames[0]` and `lastNames[0]`,
    we have the first and last names of Jane Addams.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What I''d like to do now is expand this program and place all of this information
    in a single data structure: a Java `Map`. While creating such a Map, we let it
    know the relationship between one set, which we call the keys, and the other set,
    which we call the values, so that each key maps to the value. This will allow
    us to ask our program questions, such as, "Given a famous person''s last name,
    what is the first name that is associated with it?"'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, I''ve gone ahead and imported `java.util` where the `Map` interface
    lives. Next, I''ll get rid of the last two `println` statements that prints the
    `firstNames` and `lastNames` arrays. Instead, at this point in our code, when
    our `firstNames` and `lastNames` arrays have been set up, let''s start constructing
    our `Map`. For this, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We begin by using the `Map` keyword and then, as with most data structures,
    we tell Java what type of information our `Map` is going to take. Maps take two
    sets of information, so we'll have to give it two information types that are comma-separated.
    The first information type is the information type for the Map's keys, and the
    second information type is the type for the Map's values.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use `lastNames` as our keys because we don't want our `Map` to
    store multiple values in one key, and it's much less likely that we're going to
    have multiple identical last names. Additionally, it's a lot more valuable for
    us to ask for the first name of the famous person named Addams, rather than the
    last name of the famous person named Jane, of which there are probably more. Anyway,
    the data type of `lastNames` is `String`, and the data type of `firstNames` is
    `String`, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we give our new `Map` variable a name: `famousPeople`. Then, we cause
    our `Map` to come into being by instantiating it. To do this, we use the `new`
    keyword. `Map` is not an object, actually, it''s what we call an interface. For
    the most part, we interact with interfaces and objects the same way, but we cannot
    simply declare an instance of an interface. Rather, interfaces are additional
    wrappings of functionality that we place on top of objects, in the way that ArrayLists
    add additional functionality to arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: So, to create a new `Map`, we need a simpler type of object that we can wrap
    the `Map` interface around. A great candidate for this is the `HashMap`. Therefore,
    we create our `HashMap` and assign our Map variable `famousPeople` to it. We'll
    now interact with this `famousPeople` variable just as if it were an object with
    all of the `Map` functionality. Additionally, if we would like, we could call
    only the `HashMap` functionality on this object as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s a little out of the scope of this particular section, the power
    of interfaces is that we can assign them to objects of different types, giving
    common functionalities to otherwise distinct object types. But, for now, we''re
    mostly just interested in the power and function of Java Maps. You''ll notice
    that we didn''t have to explicitly tell Java what type our `HashMap` was going
    to take. This is a stylistic choice really; if we wanted to, we could explicitly
    declare the types that the `HashMap` would take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, since we're only going to interact with our `HashMap` in terms of its
    functionality as a `Map`, simply protecting us from adding anything but strings
    when we interact with our `HashMap` through the variable `famousPeople`, which
    is currently our only way to access it, should be just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to our Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we set up our `Map`, it''s time for us to go through and fill it with
    information. For this, I think a `for` loop will be appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We're going to need to add a number of pairs of information to our Map, that
    is, one key and one value, equal to the number of items in either of these arrays.
    This is because they both have the same length. So let's set up a `for` loop that
    iterates through every index from `i` to the length of (`lastNames-1`). The `i`
    values will map to the indexes of the `lastNames` array, and because the `firstNames`
    array has the same length as the `lastNames` array, they will map to the indexes
    of the `firstNames` array as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for each `i`, we're going to execute our Map's `put()` function. The `put()`
    function is similar to the `add()` function. It inserts information into our map.
    However, this function expects two pieces of information. First, it expects our
    key, which is the value we're currently looking at in `lastNames`, and then it
    expects the associated value, which is the value we're looking at in `firstNames`.
    Each time we execute the `famousPeople.put(lastNames[i], firstNames[i]);` line
    of code in our `for` loop, we'll be adding a new key value pair to our `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching information from our Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve set up the `Map`, with all our information already in our program,
    all we need to do is ask it some questions and make sure we get the right responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `get()` function to ask our `Map` the basic question that it''s
    designed to answer, "What is the value paired with a given key?" So, let''s ask
    our `Map`, "What is the value paired with `Addams`?", or in more understandable
    English terms, "What is the first name of the person in our Map whose last name
    is `Addams`?" When we run this program, we get the expected result, that is, `Jane`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df094d6-336d-4e4a-8b59-fef66961165b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s just run it one more time to make sure we haven''t made any silly mistakes.
    Let''s see whether our program answers `Frank` when we input `Sinatra`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Indeed it does!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e045ad4-f16e-4761-865b-25557362080d.png)'
  prefs: []
  type: TYPE_IMG
- en: While it's possible for us to write a program like this by simply looping through
    our arrays when we get user input (finding `lastName`, storing that index, and
    getting it from `firstNames`), our Map interface essentially does that for us.
    Perhaps, more importantly than this, when we're working with other programmers
    or looking at code that we didn't write just yesterday, and we see a `Map`, we
    understand immediately its intended purpose and what functionality it implements.
    In almost all cases, just writing code that works is equally important because
    it makes sense and will be understood by others who might come across the code
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at arrays and an example that printed the English
    alphabet by using an array. Next, we looked at multidimensional arrays and wrote
    a program that created a two-dimensional chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: We walked through what an ArrayList is and how it enhances the functionality
    of arrays. We also wrote a program using an ArrayList with functionality, which
    would have been quite difficult to implement using an array. Finally, we looked
    at Maps and implemented an example to understand this better.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at Java functions in detail.
  prefs: []
  type: TYPE_NORMAL

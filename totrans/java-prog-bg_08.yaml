- en: Useful Java Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we've achieved a level of confidence with the basics of Java, both the
    Java syntax and the basic object-oriented concepts that Java was built around,
    we can then take a look at Java's API and the class libraries that are immediately
    and easily accessible to us for writing Java programs. We want to do this because
    we're going to be using these class libraries to speed up our programming and
    to make use of the work of programmers who have written really great stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Also, taking a look at the Java class libraries, or the class libraries of any
    programming language really, is also a great way to see how the programming language
    is designed for use and what optimal coding in that language should look and feel
    like.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will look at the `Calendar` class and how it works.
    We will take an in-depth look at the `String` class and a couple of its interesting
    methods. Next, we will walk through how to detect exceptions, that is, exceptional
    cases in our program, and how to handle them. We'll look at the `Object` class,
    which is the superclass of all classes in Java. Lastly, we'll look at the primitive
    classes of Java in brief.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that this chapter will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Calendar` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `String` class and the difference between using `String` objects and literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions and how to handle them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive classes of Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Calendar class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at Java's `Calendar` class. When
    writing Java code, we generally use the `Calendar` class to refer to a specific
    moment in time.
  prefs: []
  type: TYPE_NORMAL
- en: The `Calendar` class is actually a relatively new addition to the Java API.
    Previously, we used a class called `Date` to perform the similar functionality.
    If you end up working on older Java code or are writing Java code that deals with
    a SQL or MySQL database, you'll probably end up using the Java `Date` class at
    least occasionally. If this happens, don't panic; consult the Java documentation
    and you'll discover that there are some really great functions for swapping between
    `Calendar` and `Date` objects.
  prefs: []
  type: TYPE_NORMAL
- en: To see the power of Java's `Calendar` class, let's jump into a Java program
    and instantiate it. Let's create a new program; first, import all the classes
    from the `java.util` package because that's where the `Calendar` class lives.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a new `Calendar` object; I'm going to call it `now` because
    our first goal is to set the value of this `Calendar` object as the current moment
    in time. Let's set the value of `now` as the default value of a `Calendar` object
    and see what it gives us. To do this, I suppose we're going to need to use the
    `new` keyword. While we haven't actually looked it up in the documentation, this
    seems like a reasonable starting or default date for a `Calendar` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s set up our program so that we can print out the information
    contained in our `now` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps, surprisingly, this basic program actually fails when we attempt to
    compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f158bddd-0d63-4a9d-a67e-61669fc54652.png)'
  prefs: []
  type: TYPE_IMG
- en: Our error is on `Calendar`, where we have instantiated the `Calendar` class,
    according to the error shown in the console. The error is `Calendar is abstract;
    cannot be instantiated`.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, abstract classes are those that are designed purely to be subclassed,
    and we can never declare an instance of an abstract class all by itself. So what
    good is Java's `Calendar` class if we can never instantiate one? Of course, that's
    not a fair question because we definitely can create `Calendar` objects; they
    just have to be a specific type of `Calendar` object. We're almost always going
    to make use of `GregorianCalendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses of Calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a step back and assume, perhaps rightfully so, that we didn't know
    what `Calendar` options were available to us. This is one of the times when working
    with an **IDE **(**Integrated Development Environment)**, such as NetBeans here,
    can be really amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, at this point in time, we'd have to take a trip to the Java documentation
    to see exactly what subclasses of `Calendar` are available for us to instantiate.
    But because our IDE knows some metadata about the packages that we've already
    imported, we can ask our IDE what it thinks might be a possible solution for our
    code. If you're working in NetBeans, you can get these kinds of suggestions very
    often by checking some of the Code Completion options from Tools | Options | Code
    Completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to keep code completion from popping up all the time, I''m going to
    make use of a NetBeans shortcut on this occasion. This shortcut, by default, is
    the key combination *Ctrl* + space, which will prompt a code completion pop-up
    window for the current location of our cursor, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a53f7a67-2fd6-445d-888f-2b011fd7336c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Code Completion option in NetBeans is excellent. NetBeans has given us
    three possible suggestions: the abstract `Calendar` class, `BuddhistCalendar`,
    and `GregorianCalendar`. We already know we don''t want to use the `Calendar`
    class because we can''t actually instantiate an abstract class. The `BuddhistCalendar`
    and `GregorianCalendar` certainly look like subclasses of `Calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we select `GregorianCalendar`, we''ll see that it is a subclass of `Calendar`.
    So let''s go ahead and attempt to create a brand-new `GregorianCalendar` instance
    with default settings and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this Java program, we do get some output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09bc6484-e8c0-49ca-9386-2560c3833071.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This output means two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Our syntax is correct because we compiled successfully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see what values Java puts in a brand new `Calendar` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the great things about Java is how extensive and demanding it is that
    new objects implement the `toString()` method used by `println()`. This means
    that most Java standard library objects are capable of printing themselves out
    in some sort of human-readable format when we ask them to.
  prefs: []
  type: TYPE_NORMAL
- en: Our new `Calendar` class printed out here isn't exactly easy to read, but we
    can go through it and see that values have been assigned to many of its fields,
    and we can also see what the fields, which a `Calendar` class has, actually are
    (such as `areFieldsSet`, `areAllFieldsSet`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the current day, month, and year
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to get just one piece of information from `Calendar` class.
    Let''s see whether it is actually set to the value of today. Let''s print the
    day, month, and year on three separate `println` lines to keep things simple.
    To access the current day, month, and year, we''ll need to get those fields from
    the `Calendar` object `now`. If our `Calendar` object represents a specific moment
    in time, it should have fields for day, month, and year, right? Well, if we open
    up our autocomplete option, we can take a look at all the fields and methods available
    to us, exposed by our `Calendar` object as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c178d672-c27e-45e8-ae73-5e000845e338.png)'
  prefs: []
  type: TYPE_IMG
- en: We're not going to find an easily accessible day, month, and year field, and
    this might start to disenfranchise us from `Calendar`; however, we're just not
    going enough levels deep.
  prefs: []
  type: TYPE_NORMAL
- en: The `Calendar` class exposes the `get()` method that allows us to acquire the
    fields that describe the specific `Calendar` instance or moment in time. It's
    a function that takes an integer as a parameter. To some of us, this might look
    a little confusing at first. Why would we provide `get()` with an integer to tell
    it what `Calendar` field we're looking for?
  prefs: []
  type: TYPE_NORMAL
- en: 'This integer is actually an enumerator, which we''ll think about for now as
    a static string exposed by the `Calendar` class itself. If, for the parameter
    of `get()`, we type in the `Calendar` class name like we wanted to get a static
    member variable and then go back to autocomplete, we see a list of options that
    we can utilize in this instance, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9d6c526-d232-4e65-baad-fbb4557bf1f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of these options don''t make a lot of sense. We have to remember that
    autocomplete is just telling us what `Calendar` exposes; it''s not giving us the
    solution because it has no idea what we''re trying to do. For example, we wouldn''t
    want to use our `Calendar` instance `now` to get its value of `May`; this wouldn''t
    make any sense. But, we can use our `Calendar` instance to get the current month
    (`MONTH`). Similarly, what we really want is the day of the month (`DAY_OF_MONTH`)
    and the current year (`YEAR`). Let''s run the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding program, we get the output `9`, `12`, `2017`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/951c8817-a2e8-4342-8922-8ff33f63cf5a.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm writing this book on October 12, 2017, so this is actually a little confusing
    because October is the tenth month of the year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there''s a reasonable explanation for this. Unlike the day of
    the year and year, which makes sense to store as integer variables, most implementations
    of `Calendar` and classes similar to `Calendar` in most programming languages,
    not just Java, choose to store months as an array. This is because in addition
    to a numeric value, each month also has a corresponding string: its name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since arrays are zero-indexed, our month appears, in case you forget about
    this, one month lower than it should be. Our `println()` function should probably
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I got the following output. You''ll have to trust me on this; it is today''s
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e391090-bdab-4c54-b429-2ecf1ff3da33.png)'
  prefs: []
  type: TYPE_IMG
- en: So `Calendar` has a whole lot of methods associated with it. In addition to
    just setting `Calendar` to the current point of time and reading from it with
    our `get()` function, we can set `Calendar` to points in time using the `set()`
    function. We can add or subtract using negative values to point in time, using
    the `add()` function. We can check whether points in time are before or after
    other points of time, using the `before()` and `after()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: How Calendar works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're like me though, you'd like to know a little bit about how this `Calendar`
    object is really operating. Is it storing the month, day, and seconds of time
    in separate fields, or is there one big number that contains all of this information?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we spend some time and take a look at the methods available to us in the
    `Calendar` class implementation, we''ll find these two methods: `setTimeInMillis()`
    and its sister method `getTimeInMillis()` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/594e44de-9eec-4c93-b94f-063721fc8b8a.png)'
  prefs: []
  type: TYPE_IMG
- en: The fact that these methods are specially set aside is a really great window
    of opportunity for us to see how the `Calendar` class really thinks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin our exploration by calling the `getTimeInMillis()` function and
    printing out its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a really large integer number, which is presumably the time in milliseconds
    since some particular point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8af89898-4b62-4305-b86f-5f5ddce7edbf.png)'
  prefs: []
  type: TYPE_IMG
- en: If we were to do the math on this though, we would discover that this point
    in time is not actually the year 0; rather, it's a time much closer than that.
    This point in time is referred to by the `Calendar` class as the **epoch**, and
    it's the point in time when we start counting from when we store a time in Java
    in terms of how many milliseconds it's been since the epoch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could whip out our calculator and through a pretty painstaking process figure
    out exactly what this point in time was, or we could do it in our native Java
    environment with a lot less pain. Let''s simply change the value of `now`, originally
    set to the default or current moment in time, to be the time when milliseconds
    is set to `0`. We''ll do this with `setTimeInMillis()` and provide `0` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program again, we get the same output fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e43915a-b424-4e21-ac8f-4c085a6f509f.png)'
  prefs: []
  type: TYPE_IMG
- en: The first number in our output is our confirmation that milliseconds has been
    set to `0`. Now our `Calendar` moment in time is January 1, 1970\. So once we
    start adding days to our object, we'll be counting from January 2, 1970\. This
    point in time is referred to by the Java `Calendar` as the epoch.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this a really interesting thing for us to know? It means that we can
    convert our `Calendar` classes to these millisecond values and then add, subtract,
    and I guess multiply and divide them as integer values. This allows us to use
    all sorts of operations on them in the native format of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, I'd like to show you one more thing because it's a bit of syntax that
    you may not be familiar with and may not immediately recognize when you come across
    it. If you recall at the beginning of this section, we said `Calendar` is an abstract
    class; we can only instantiate specific types of `Calendar` classes. However,
    oftentimes, we won't specify exactly what type of calendar we're looking for;
    we'll ask the `Calendar` class to decide this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw with our enums, in addition to having object-level methods, the `Calendar`
    class does provide some static methods that we can use just by referencing the
    `Calendar` type name. One of these methods is `Calendar.getInstance()`, which
    will create for us the best fit `Calendar` class that Java can figure out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it's going to be that same `GregorianCalendar` class that we have
    created already.
  prefs: []
  type: TYPE_NORMAL
- en: String functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with strings in Java can be a little confusing at first because they
    really are a special case. Strings have associated with them this concept of a
    string literal, that is, a sequence of characters between double quotation marks.
    We can just put it right into our Java programs and Java will understand it, just
    like it would understand an integer number or a single character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike integers, characters, and floats, Java doesn''t have a primitive keyword
    associated with this string literal. About the closest we could get if we wanted
    to is a character array; however, generally, Java likes us to associate string
    literals with the `String` class. To understand the `String` class better, look
    at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `String` class in Java is special. In some ways, it's just like any other
    class. It has methods, and as we can see in the code lines, where we defined the
    variables `s1` and `s2`, it has a constructor. But, we can use operators on the
    `String` class that are normally only reserved for literals and primitives. For
    example, in the preceding program, we added `s1` to the string literal `string
    1:` to get a meaningful result. This is not normally an option when dealing with
    a Java object.
  prefs: []
  type: TYPE_NORMAL
- en: String literals versus String objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java's decision to use objects of the `String` class as either string literals
    or genuine objects interchangeably is really powerful. It gives us way more options
    to manipulate text than we would otherwise have, but it does come with some trade-offs.
    While dealing with a `String` object, it's very important that we understand whether
    we're dealing with its string value or with the object itself. This is because
    we can get radically different behaviors. The preceding program we saw is designed
    to illustrate one of these instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a pretty simple program. Let''s step through it and attempt to anticipate
    its output. We start off by declaring and instantiating two `String` objects:
    `s1` and `s2`. We use the `String` constructor (we''ll talk about why that''s
    important here soon), and we simply pass in the same string literal value to each
    of these new objects. Then, we ask our program to print out these values just
    so we can compare them visually. But then, we also ask our program to carry out
    this interesting task: compare using the double equal sign comparison operators
    `s1` and `s2`. Before you run this program, take a second and ask yourself, "What
    do you think the result of this comparison is going to be?".'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run this program, I see that Java does not believe that the comparison
    of `s1` and `s2` returns `true`. I get the result `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11c57936-eaa1-47bd-975b-4fb5ae8f3d01.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on what we were thinking about `s1` and `s2` at the time, the output
    either makes sense or is confusing. If we were thinking of `s1` and `s2` as string
    literals being compared by the comparison operator, it would be very confusing
    to us. We'd wonder why we didn't get the result `true` since the string literals
    assigned to both `s1` and `s2` are the same.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we were thinking of `s1` and `s2` as the objects that they are,
    the `false` result makes a lot more sense because what we're asking Java is, "Are
    these two objects the same?" They're clearly not because they're both the result
    of creating two different new objects.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we like to use the `equals()` method when we can in Java. Almost
    every object implements an `equals()` method, and the `equals()` method should
    be written for every object so that it could logically compare the value of these
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compare our strings using the `equals()` method, we also compare the string
    literal values they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we execute our program, we get the result `true`, as opposed to the `false`
    we got when we were trying to see whether they were actually the same objects
    stored in the same location of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/786b8fe7-9ac7-4202-a59d-a06e6ce02ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: String functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what powers does this `String` implementation give us? Well, we know that
    we can add or concatenate strings together because we can manipulate them as literals.
    In addition to this literal manipulation, we can also make use of all the functionality
    provided by the `String` class itself. We can go to the Java documentation to
    see what functionality is available for us, or we can always check using the code
    completion feature of NetBeans. I should probably point out here that we can even
    use the `String` class functionalities on string literals, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/877c76fc-5a48-413e-8982-dab2908cd52e.png)'
  prefs: []
  type: TYPE_IMG
- en: The replace() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of the methods you''ll see in the methods list are pretty self-explanatory
    (`toLowerCase()`, `toUpperCase()`, and so on). But just to make sure we''re all
    on the same page, let''s make use of one of them. Let''s use `replace()`. The
    `replace()` function takes two arguments, and these arguments can either be single
    characters or a character sequence of which a string qualifies. This method simply
    replaces all the instances of the first string or character with the second string
    or character. Let''s look at the following `replace()` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program, we see that we''ve modified its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b644940e-7847-4b30-bb78-e2083f63036d.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of these methods simply modify the value being returned. We can see that
    our program still finds that `s1` equals `s2` at this last line of code, showing
    us that the value of `s1` hasn't been modified by our call to the `replace()`
    method. The `replace()` method has simply returned the modified value for our
    `println()` function to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: The format() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps, the most interesting of the `String` class''s methods is actually
    one of its static methods: `String.format()`. To show you the power of `String.format()`,
    I''d like to create a brand new functional class for our project. So right-click
    on the Project name in the filesystem, shown on the left-hand side of the screen,
    create a new class, and call it `CustomPrinter.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So that you can see what we're doing when we set the `CustomPrinter` class up,
    let's look at the prewritten code we're going to use in our `main()` method. The
    idea behind the `CustomPrinter` class is that it will have a constructor that
    takes a string as input. This input string will format, or wrap around, any strings
    that we print out to our console using the `CustomPrinter` instance. We will implement
    `System.out.println()` within `CustomPrinter`, so we can just call `printer.println()`
    when we want to utilize it for formatting our text.
  prefs: []
  type: TYPE_NORMAL
- en: When we format a string in Java, we use some special syntax. Within our format
    string, we can preface the characters `f` or `d` or `s` most commonly with a percentage
    symbol (like we used `%s` in our code). In terms of the `String.format()` function,
    Java understands these as areas in our format string where we're going to insert
    other information.
  prefs: []
  type: TYPE_NORMAL
- en: The format string that we've used in our code will wrap any string output we
    create with caret brackets. This is more complicated than simply appending and
    prepending to a string, and we could certainly create an implementation that would
    allow us to add multiple pieces to our formatted strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit our `CustomPrinter.java` file next. We know that we''re going to
    need a `CustomPrinter` constructor, which takes a format string as input. Then,
    we''re probably going to need to store this `format` string. So let''s just have
    our constructor take the provided format string and store it for later use in
    the `formatString` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We also declare a `println()` function, which presumably is going to be a `void`
    function; it's just going to utilize `system.out.println()` to print something
    to the screen. What that *something* is, is going to be a little complicated.
    We need to take our given format string and replace `%s` with the input provided
    to our `println()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this with the awesome `String.format()` static function that takes two
    parameters: a format string and the data to be formatted. If our format string
    had multiple strings to format, we could provide multiple fields in `String.format()`.
    It''s a function that can take any amount of input. But, to keep everything simple
    and moving along, we''re simply going to assume that our format string only has
    one input instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve successfully formatted this string using the `String.format()`
    function, we''ll simply print it out to the screen, as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program (we need to run the class where we have our `main()`
    method), we see that all of our output gets properly wrapped in caret brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/824bfc07-9fa2-4ba3-b869-26bd7e5abf07.png)'
  prefs: []
  type: TYPE_IMG
- en: Extending a custom printer like this, of course, to take a higher amount of
    varied input and to be much more dynamic than the quick thing we created, is the
    basis for anything, such as a logging system, or a terminal system, where you
    will be able to see the same pieces of information wrapped around messages. We
    could use a custom printer like this, for example, to place dates and times after
    any message we send to the user. However, details would need to be properly formatted
    so that they're not just tacked on at the end but have proper spacing between
    them and stuff like that.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have learned something about strings. The way Java handles them is
    really powerful, but as with most powerful things in programming, you will need
    to understand them at a basic level before you can be sure that they're not going
    to come back and bite you.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there is a possibility that our code might fail. It might be our
    fault for making a programming error, or it might be an end user using our system
    in a way we didn't anticipate. Sometimes, it might even be a hardware failure;
    a lot of errors can't really be attributed to any one single source, but they
    are going to happen. The way that our program handles the error case is often
    just as, if not more, important as how it handles ideal use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at Java exceptions. Using Java exceptions,
    we can detect and catch, and in some cases recover from, errors that occur within
    our program. As we go through exceptions, there's something really important to
    keep in mind. Exceptions are called exceptions because they exist to handle exceptional
    cases, things that we either couldn't handle or couldn't anticipate when originally
    writing our code.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions modify the control flow of our program, but we should never use them
    for anything other than catching and handling or passing exceptions. If we attempt
    to use them to implement logic, we'll make a program that will quickly become
    very confusing for us and will be immediately very confusing for any other programmer
    who attempts to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us explore Java exceptions, I''ve set up a basic program for us to
    play with; it is something that can fail. It''s an eternal loop that does two
    real things. First, it takes input from the user using the `nextFloat()` function
    of `Scanner`, then it prints that input back to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we accurately assign floating-point values as input to this program, then
    the program will theoretically run forever, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1fb966b-d867-438c-8a1d-211c5d62e9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we make a mistake and give this program a string as input, the
    `nextFloat()` function will not know what to do with it and an exception will
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c39c4dd4-5866-4c87-bc24-27f820fca166.png)'
  prefs: []
  type: TYPE_IMG
- en: When this happens, we get red text in our console. This red text is actually
    going to the `System.err` stream.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the console exception messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's walk through the output text and understand what it means. There are two
    important sections in it. The first part of the output text, the bit that's not
    tabbed in, is the identifier of this exception. It lets us know that an exception
    has been thrown and where it has occurred. Then it tells us what type of exception
    has occurred. You'll notice that this exception is found in the `java.util` path
    (this part of the output looks very similar to whether we were importing something
    into our code or directly pathing to an external library). That's because this
    exception is actually a Java object, and our output text is letting us know exactly
    what type of object it is.
  prefs: []
  type: TYPE_NORMAL
- en: The second bit of this exception test (the part that is tabbed) is what we call
    a stack trace. It's basically the pieces of our program that Java has jumped through.
    The very bottom of our stack trace is the location where the exception was originally
    thrown; in this case, it is `Scanner.java` and it is on line `909`.
  prefs: []
  type: TYPE_NORMAL
- en: That's not our code; that's the code written for `Scanner.java`, presumably
    where the `nextFloat()` method lives or code that the `nextFloat()` method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Stack traces are layers of code, so once `InputMismatchException` occurs, Java
    begins to jump through these layers of code or bracketed areas until it eventually
    reaches the top layer where the code resides, that's `Exceptions.java` in our
    case. It's the file we've created, and it's at the top of the stack trace. Line
    11 of our `Exception.java` code file is the last place where Java was able to
    handle or throw this exception.
  prefs: []
  type: TYPE_NORMAL
- en: Once line 11 was reached and the exception was still propagating upwards, there
    was nothing else to handle because it had reached the top of our program. So the
    exception ended by getting printed to our `System.err` stream and our program
    terminated with result `1`, which is a failure case.
  prefs: []
  type: TYPE_NORMAL
- en: This is great for debugging purposes; we knew where we had to go to figure out
    what went wrong in our program, line 11 of `Exceptions.java`. But, if we were
    creating a program that we were looking to release for some reasonable purpose,
    we generally don't want our program to crash whenever a minor error were to occur,
    especially an input error such as this, which is perfectly reasonable for a user
    to make from time to time. So let's explore how we can handle exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Java is told to throw an exception, it stops executing the current code
    block and begins jumping up levels until the exception is handled. That's how
    we moved from deep within the `Scanner.java` class' 909 line to line 11 of `Exceptions.java`,
    the piece in our code where, as far as we're concerned, the exception occurred.
    If our code were executed by another block of code, because we haven't handled
    this exception, instead of printing out to `System.err`, we'd simply throw the
    exception up another level. Due to this, they'd see line 11 of `Exception.java`
    in their stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes it doesn't make sense to keep throwing an exception. Sometimes,
    we want to handle the exception case because we know what to do with it or because,
    as in the case we're dealing with right now, there are nicer ways to inform the
    user of what went wrong than just providing the stack trace and exception name.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if we handle this exception here, there's no reason that we can't
    resume our `while` loop as though nothing had happened. One failed case of this
    `while` loop isn't necessarily a reason to terminate our program. If we're going
    to handle exception cases, we're going to make use of the `try...catch` code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The try and catch blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any block of code where we think an exception might be thrown and we'd like
    to handle the exception, we're going to wrap that line of code in a `try` block.
    For the most part, this doesn't affect how this code is executed unless an exception
    occurs within the `try` block. If an exception is thrown within the `try` block,
    instead of propagating that exception upward to the next level, the code within
    the following `catch` block will immediately get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `catch` blocks require a little more information before they can execute;
    they need to know what exactly they're going to catch. We can catch all exceptions
    by simply catching anything of the `Exception` class, but this may not be a fair
    thing to do. There's a lot of different schools of thought on exception handling,
    but generally, people will agree that you should only catch and handle exceptions
    that you, to some degree, expected might occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example we saw, we know that `InputMismatchException` is thrown if we
    give invalid information through user input. Because we''re going to be printing
    out a message when this exception occurs, which specifically tells the user `Please
    enter a float number.`, we certainly don''t want to be catching any exceptions
    that are not `InputMismatchException`. So, we use the following code to catch
    `InputMismatchException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, first we must quickly test that it works in a good
    use case, as it did before. Then, if we cause `InputMismatchException` to be thrown
    by providing the string input, we should see our catch block execute, and we should
    get the `Please enter a float number.` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c550cd6-7f09-4b4b-bf7b-fda46a559b08.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, as you can see, we do get that response, but unfortunately, we're getting
    that response over and over again. We've inadvertently introduced an even worse
    bug. Now, instead of throwing an exception and crashing, our program just enters
    an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s why this happens: our `Scanner` object `reader` is a stream reader,
    which means there''s a buffer of input that it picks to read from. In a normal
    use case, when our infinite `while` loop executes, our user adds floating-point
    numbers to that buffer of input. We pick these out, print them, and go back to
    the start of the loop and wait for another. However, when a string is found in
    that buffer, the line of code where we call the `nextFloat()` function throws
    an exception, which is fine because we catch it with our catch block.'
  prefs: []
  type: TYPE_NORMAL
- en: Our catch block prints out the line of text telling the user that he/she gave
    invalid input and we go back to the beginning of the while loop. But, the bad
    string in our `reader` objects buffer is still there, so when we catch our exception,
    we will need to clear out that stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this is something we can handle. Once we''ve caught and handled
    our exception, we need to clear out the stream reader by simply grabbing its next
    line and doing nothing with its information. This will flush the `Please enter
    a float number.` line from the reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our program now, we''ll see that it handles and recovers from a failed
    input where we give it a string, which is pretty cool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc6c1a2a-4cf6-4427-b9eb-0731597e7a41.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go over a couple of more things we can do with exceptions. For one, clearing
    out our reader at the end of an exception case makes a lot of sense, but it might
    make even more sense to clear out our reader at the end of any attempted case.
    After all, we're entering this `while` loop with the assumption that there's no
    new line in the reader. So, to implement this, we have the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: The finally block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we'd like to execute a case always, no matter whether we did or did not succeed
    in our `try` block, we can follow our `catch` block with the `finally` block.
    The `finally` block executes no matter what, whether an exception was or was not
    caught. This exists so that you can put cleanup code in your system. An example
    of cleanup code is clearing out our `reader` objects buffer so that there's nothing
    there to confuse ourselves later or other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are more than a simple object that gets thrown; they can contain
    a lot of really important information. As we saw earlier, exceptions can contain
    a stack trace. Let's quickly modify our program so that while it still gives user-friendly
    `Please enter a float number.` information, it also prints out the stack trace
    so that a programmer can debug our program.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, when we're writing finished code that a user is going to utilize,
    we never want a case where they would be able to see something as deep as a stack
    trace. It's confusing for most computer users and can be a security risk in some
    instances, but as a feature in a debug mode or for developers, detailed exceptions
    such as these can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Exception` class exposes a method called `printStackTrace()`, which requires
    a stream as input. We''ve been using `System.out` for all of our output so far,
    so we''ll provide the `printStackTrace()` method with `System.out` as its stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run our program and give it a bad string, we get our initial friendly
    exception text code. However, we still have the stack trace, so we can exactly
    see where the errors are coming from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d5302f8-3d50-45d1-b9af-75e200a5bb84.png)'
  prefs: []
  type: TYPE_IMG
- en: As I mentioned earlier, exception handling is an extremely deep topic in modern
    software development, but at the end of this section, you should have a firm hand
    on the basics. When you come across exceptions in code or when you're writing
    your own code and feel that you need exception handling, you should be well prepared.
  prefs: []
  type: TYPE_NORMAL
- en: The Object class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to learn some very important things about how
    Java has chosen to implement object-oriented programming. We''re going to be exploring
    the `Object` class itself. To get us started, I''ve written a really basic program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This program utilizes a custom class called `MyClass` and creates two instances
    of this class: `object1` and `object2`. We then call a void `MyMethod` method
    on each of these objects, which simply prints out the value that we''ve given
    them to contain. Then, the program compares these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: We first compare using the comparison operator (`==`) that checks whether these
    two objects are actually the same object. We know that this will not be true because
    we can see that the objects were instantiated completely independent of each other.
    They share a class, but they are two different instances of the `MyClass` class.
    We then compared these objects using the `equals()` method, which we'll be talking
    about a lot in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this program, we see that the objects are found not to be the same
    when compared by the comparison operator, which is what we would expect. But,
    we also see that when they''re compared using the `equals()` method, the objects
    are found not to be equal, even though the objects were both created under the
    same parameters and had the exact same things done to them from their creation
    to this point in time. Following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccc58e6f-859d-494a-b94a-94f4cd1be784.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what does it mean when objects are not found to be equal by the `equals()`
    method? The first question we should ask ourselves is, where does this `equals()`
    method come from or where is it implemented?
  prefs: []
  type: TYPE_NORMAL
- en: If we go by the definition of the `MyClass` class, we don't actually find an
    `equals()` method, which is pretty weird because `MyClass` is not declared to
    be inheriting from any superclass, but `equals()` is called directly on the `MyClass`
    instance. In reality, `MyClass`, as with all Java classes, does inherit from a
    superclass. At the very top of every class inheritance tree, there is the `Object`
    class, even though it's not explicitly declared in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we head to the Java documentation ([docs.oracle.com/javase/7/docs/api/java/lang/Object.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html))
    and look up the `Object` class, we will find this definition: "Class `Object`
    is the root of the class hierarchy. Every class has `Object` as a superclass.
    All objects, including arrays, implement the methods of this class." Then, if
    we scroll down the page, we get a short but very important list of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47b9097e-61a6-4de3-999d-9e2524a7dd8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Because all Java objects inherit from the `Object` class, we can safely assume
    that any Java object we're dealing with implements each of the methods here. Among
    these methods is the `equals()` method that we were just talking about and trying
    to figure out where it came from. This makes it very clear to us that `MyClass`
    is inheriting the `equals()` method from its `Object` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the `equals()` method at the object level is very vague. It
    says, "Indicates whether some other object is **equal** to this one." To some
    degree, this vagueness leaves it up to us, as programmers, to determine what equality
    really means on a class-by-class basis.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we come to the decision, the reasonable decision, that `object1` and
    `object2` should be determined to be equal to each other if the values they contain
    are identical. If we make this decision, then the current implementation of our
    program is not quite correct because it's currently telling us that `object1`
    and `object2` are not equal. In order to change this, we're going to need to override
    the `equals()` method in `MyClass`.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the equals() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overriding an `Object` class method is no more difficult than overriding the
    method for any other superclass. We simply declare an identical method, and this
    specific method will be used when appropriate, when we're dealing with a `MyClass`
    object. It's important for us to notice that the `equals()` method does not take
    a `MyClass` object as input; it takes any object as input. So, before we can go
    ahead and compare this object's value with the value of our current `MyClass`
    objects, we need to protect ourselves and make sure that the object given as input
    is actually a `MyClass` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s check some bad cases where we would want our program to
    simply go ahead and return `false` without even comparing the inner values of
    these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: If we've been given an object that hasn't actually been instantiated, a pointer,
    or a null pointer, we'd simply want to return `false` because our instantiated
    `MyClass` object is not equivalent to nothing at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The more difficult question is this: Is the object that we''ve been given to
    compare, an instance of `MyClass`? Let''s check the opposite of this; let''s confirm
    that this object is not an instance of `MyClass`. The `instanceof` keyword lets
    us see what classes an object has within its repertoire. If our `instanceof` statement
    does not evaluate to `true`, we simply want to return `false` because we''d be
    comparing a `MyClass` object with an object that is not a `MyClass` object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we''ve made it through these hoops successfully, it''s safe for us to
    assume that we can cast a given object to a `MyClass` object. Now we can simply
    compare the value fields they contain and return the appropriate value. Let''s
    write the following code to our `MyClass.java` file and jump back to our `main()`
    method to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we will see that `object1` and `object2` are found
    to be equal to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8404f7a6-5e88-4f4b-aa20-e57d5c784790.png)'
  prefs: []
  type: TYPE_IMG
- en: Other Object methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Object` class declares a number of methods. In addition to `equals()`,
    some important methods are `hashCode()` and `toString()`. We're not going to implement
    `hashCode()` in this section because it requires us to do a little more math than
    is really wieldy, but I would very much recommend that you check out how `hashCode()`
    works by going to the documentation and exploring it.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's just know that an object's `hashCode()` method should return
    an integer value that describes that particular object. In all instances, if two
    objects are found to be equal through the `equals()` method, their `hashCode()`
    functions should also return the same integer value. If two objects are not equal,
    as far as the `equals()` method is concerned, their `hashCode()` functions should
    return different values.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in time, we should be familiar with the `toString()` method. This
    is also a method in the `Object` class, meaning that we can call the `toString()`
    method on any single object. But, in our custom objects, until we've overridden
    `toString()`, it's probably not going to return meaningful, human-readable information.
  prefs: []
  type: TYPE_NORMAL
- en: As you learn Java, I highly recommend that you implement `equals()` and `toString()`,
    even on the small little test classes you write while learning. It's a great habit
    to get into, and it keeps you thinking about object-oriented programming in the
    same way that Java does. When we create finalized software projects where we have
    public classes that other programmers may someday be using, we should be very
    careful that all our classes properly implement these methods in an understandable
    manner. This is because Java programmers will expect to be able to utilize these
    methods to manipulate and understand our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I'd like to take a very quick look at the primitive classes
    available to us in Java. In Java, we often say that strings are special because
    they have a literal interpretation identified by these double quotation marks;
    however, we still interact with them primarily through the `String` class, rather
    than a `string` primitive type that is not actually available to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a standard Java primitive, however, we generally interact with
    it through its primitive typing method. For every primitive type, we do have a
    corresponding primitive class. These are the `Integer`, `Character`, and `Float`
    classes and so on. For the most part, the explicit uses of these classes where
    we create an instance of them and then call methods on that instance are not very
    useful unless we''re overriding them to create a class of our own. Let''s look
    at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods given to us by the instance `c` of the `Character` class are primarily
    conversion methods as shown in the following screenshot that would happen automatically
    or that we could simply cast to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68d33633-94fb-4a1a-a536-5e5695e2bfcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that `compareTo()` is sometimes useful, though. It returns an integer value
    `0` if the other character given is equivalent and less than `0` or greater than
    `0`, depending on which side of the integer conversion scale the two characters
    fall in relation to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, often we may find ourselves using the static methods of these primitive
    classes to manipulate or get information from instances of the primitive types.
    For example, if I want to know whether our character `C` is lowercase, I can certainly
    convert it into an integer value, check an ASCII table, and then see whether that
    integer value falls between the range of lowercase characters. But, that''s a
    whole lot of work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05e99a92-cd67-499e-bd6c-4af194773208.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Character` primitive class provides a static function for me, `isLowercase()`,
    as shown in the preceding screenshot, which will tell me whether a character is
    lowercase or not. Let''s run the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83f738f6-0dc7-4675-85cb-e0c051b8add4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s really the gist of primitive functions. We can interact with the other
    literal types and their primitive types in the same manner: interact with strings
    using a class if we so choose.'
  prefs: []
  type: TYPE_NORMAL
- en: When we don't need the functionality of a primitive class, we should continue
    using primitive types (for example, use `char` instead of `Character`). The presence
    of the syntax highlighting feature and universal look of these primitive types
    across languages makes them much more friendly for programmers to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the `Calendar` class of Java to work with dates
    and times. We saw the `String` class in detail. We also saw what exceptions are
    and how to handle them to make our programs more robust. Then, we walked through
    the `Object` class and some of its methods. Finally, we looked at the primitive
    classes of Java.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to process files using Java.
  prefs: []
  type: TYPE_NORMAL

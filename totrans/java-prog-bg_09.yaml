- en: File Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file I/O function is an extremely powerful tool that can make one of the
    most difficult and frustrating tasks of modern programming, namely transferring
    information between logically separate entities of code, much easier than it would
    otherwise be. Having said that, in this chapter, you will learn how to write and
    read data files using the `FileWriter` and `BufferedWriter` and `FileReader` and
    `BufferedReader` classes. We''ll also look at the usage of the `close ()` method
    and the `Scanner` class. Then you''ll learn about exception handling. Finally,
    we will see one more aspect of I/O: the `Serializable` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Serializable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be an exciting chapter. First we''ll take a look at how to write
    to files using Java. To do this, we''ll declare a mathematical sequence for the
    first 50 numbers of the mathematical sequence in which each number will be the
    sum of the previous two numbers. When we run the following program we will see
    these 50 numbers printed out to our `System.out` stream, and we will be able to
    view them in our console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we close the console for good, these numbers will be lost. To
    help us with this task, we''re going to make use of the `java.io` library; here,
    `io` stands for **input and output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll utilize a class that lives in this library: `FileWriter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The FileWriter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FileWriter` class and its usage could be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare a new `FileWriter` class, and for reasons that will become apparent
    a little later on, let''s explicitly set this `FileWriter` class to null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do this, we can go ahead and instantiate it. In order to write to a
    file, we''re going to need to know two important things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, of course, we'll need to know what to write to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, our `FileWriter` class will need to know what file it should write to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we use a `FileWriter` class, we associate it with a specific file, so
    we pass into its constructor the name of the file we would like it to write to.
    Our `FileWriter` class is capable of creating a file if none exists, so we should
    just pick a name that ends with `.txt` so that our operating system will know
    we''re creating a text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Even though we've called the `FileWriter` constructor with valid arguments,
    NetBeans will still let us know that we'll get a compiler error in this code.
    It'll tell us there's an unreported exception, an `IOException` error that can
    be thrown here. Many exceptions in Java are marked as handled exceptions. These
    are exceptions that a function explicitly states it may throw. `FileWriter` is
    a function that explicitly states that it can throw an `IOException` error. So,
    as far as Java is concerned, it is an error for our code not to explicitly handle
    this possible exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this, of course, we''re simply going to wrap the portions of our
    code where we use our `FileWriter` class with a `try...catch` block that catches
    `IOException` errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we do catch an `IOException` error, it''s probably a good time to print
    out a helpful message to the **error stream**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, our program will finish running and will terminate because it would have
    reached the end of the `main` method. With this exception caught, the instantiation
    of `FileWriter` is now valid and legal, so let's put it to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We no longer need our program to print out numbers to our console, so let''s
    comment out our `println` statement, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to do the same logical thing with our `FileWriter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `FileWriter` class doesn't have a `println` statement, but it does have
    the `write` method. Each time our `foreach` loop executes, we'd like to write
    the number to our file using the `out.write(number);` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the `write` method doesn''t know how to take a `long number`
    as input; it can take a string and it can also take an integer. So let''s use
    the static `String` class method `valueOf` to acquire the value of our `long number`
    to print out the number to our file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we should now have all the pieces of a successful program here:'
  prefs: []
  type: TYPE_NORMAL
- en: First we declared and instantiated our `FileWriter` class, giving it a filename
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we looped through our Fibonacci sequence of numbers, and told our `FileWriter`
    class to write each of these numbers to `out.txt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, the question is where is `out.txt`? We haven't given the `FileWriter`
    class a full system path, just the name of a file. We know that the `FileWriter`
    class is capable of creating this file if it does not exist, but where in our
    system's directories will this `FileWriter` class choose to create the file?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, we need to know where NetBeans will create the `.jar`
    file for our compiled program. To find this out, we can open the console window
    and build our program. Here, NetBeans will tell us where it''s creating all its
    files. For example, in my case, it''s a folder called `WritingToFiles`; if we
    navigate to this folder, we''ll see our project files. One of these files is `dist`,
    short for **distributable**, and this is where our JAR file will be compiled to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b4712a9-692f-47dc-bac8-085a3768f239.png)'
  prefs: []
  type: TYPE_IMG
- en: 'JAR files are as close as we''re going to get to an executable with raw Java
    code. Because Java code must be interpreted by the Java virtual machine, we can''t
    actually create Java executables; however, in most operating systems where Java
    is installed, we can run a JAR file by simply double-clicking on it, like how
    we would run an executable. We can also tell the Java virtual machine to boot
    up and run a JAR file using the Java command line `-jar` command, followed by
    the name of the file we would like it to execute, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df1bcb5-9a5d-4ff4-9675-e3e73121a04d.png)'
  prefs: []
  type: TYPE_IMG
- en: When we submitted this command, the Java virtual machine interpreted and executed
    our `WritingToFiles.jar` program. It looks like it worked because a new file was
    created in the directory, as shown in the preceding screenshot. This is the working
    directory, and until we move it, this is where the command that executed the JAR
    file will execute from. So that's where our `FileWriter` class chose to create
    `out.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Relieving resources using the close() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfortunately, when we open up `out.txt`, there''s nothing for us to see. This
    leads us to believe that our file writing probably didn''t work. So what went
    wrong? Well, there''s an important piece to using a `FileWriter` that we failed
    to take into account. When our `FileWriter` is created, it opens a file, and whenever
    we open a file, we should make sure that we close it in the end. This is pretty
    easy to do from a code standpoint; we simply call the `close` method on our `FileWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a familiar error message that appears, as shown in the following screenshot;
    `out.close` can also report an `IOException` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d911cd7-9921-4e02-87e7-44af424facee.png)'
  prefs: []
  type: TYPE_IMG
- en: We could put `out.close` within another `try...catch` block and handle this
    `IOException` error, but if our file cannot be closed, that's a sign that something
    is very seriously wrong. In this case, it might be appropriate for that exception
    to keep propagating upwards and that we pass it on to a more robust piece of code
    rather than our fairly contained `WritingToFiles` program. This will happen by
    default if we don't handle this exception, but we do need to let Java know that
    this exception propagating upwards from our current code is a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare our `main` method, we can also let Java know what exception
    types might be thrown by this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we tell Java that under some circumstances, our `main` method may not
    execute perfectly and will instead throw an `IOException` error. Now, anyone who
    calls the `main` method of `WritingToFiles` will need to handle this exception
    themselves. If we build our Java program and then execute it again, we''ll see
    that `out.txt` has been properly printed. Unfortunately, we forgot to put new
    lines in our output, so there''s no distinguishable spacing between the numbers.
    When we write, we will need to append `\r\n` to each number. This is a new line
    escape character syntax that''s going to be visible to just about every operating
    system and environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it''s time to build, run, and take a look at `out.txt`, which is now
    starting to look pretty useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2524382-1cf8-49fa-8b30-73d4e1caacba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So this was our initial stated goal: print this Fibonacci sequence out to a
    file. A few quick things before we''re finished here, though. Let''s take a look
    at what happens if we run our program again, and then take a look at our output
    text file. The text file looks the same as it does before, which may or may not
    be expected. It seems like it''s a kind of a toss-up whether `FileWriter` would
    clear this file and write brand new text, which is what it appears to have done,
    or whether it would put the appended text after the existing text in the file.
    By default, our `FileWriter` will clear the file before it writes to it anew,
    but we can toggle this behavior through a parameter in the `FileWriter` constructor.
    Say, we set its append behavior to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now build the project, run it, and take a look at `out.txt`; we'll see twice
    as much information as there was before. Our text is now appended at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The BufferedWriter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, there's a lot of different writers available to us in Java, and `FileWriter`
    is just one of them. I decided to show it to you here because it's pretty simple.
    It takes some text and prints it to a file. Very often, however, you'll see `FileWriter`
    wrapped around by the `BufferedWriter` class. Now the declaration of the `BufferedWriter`
    class will look like the one given in the following code block, where `BufferedWriter`
    is created and given `FileWriter` as its input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BufferedWriter` class is pretty cool because what it does is it intelligently
    takes all the commands you give it and attempts to write the content to a file
    in the most efficient way possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The program we''ve just written is from our point of view, doing the same thing
    as our existing program has been doing. However, in instances where we make many
    small writes, `BufferedWriter` can be significantly faster because where appropriate,
    it will intelligently collect the write commands we give it and perform them in
    proper blocks to maximize efficiency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, very often you'll see Java code that looks like the preceding
    code block, instead of the `FileWriter` being used in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task we'll need to perform as programmers is reading input from a file.
    In this section, we're going to take a quick look at how to acquire text input
    from files.
  prefs: []
  type: TYPE_NORMAL
- en: We've gone ahead and told Java that sometimes our `main` method will simply
    throw `IOException` errors. Both the `FileWriter` and `FileReader` objects in
    the following code block can create a number of `IOException` errors for a number
    of reasons, for example, if they can't connect to the files they're supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When writing actual programs for actual applications, we should always make
    sure that we catch and handle our exceptions in a reasonable manner, throwing
    them upward if it's truly necessary. But we're going to throw everything here
    because we're doing this to learn and we don't want to be bogged down right now
    by wrapping all of our code in `try...catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The FileReader and BufferedReader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, you will learn about the `FileReader` class with the help of the code
    we already have (see the preceding code). Firstly, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: I've declared `FileWriter` and `FileReader` objects for us. `FileReader` is
    a sister class of `FileWriter`. It's capable of, believe it or not, reading text
    input from files, and it's constructed in a very similar manner. It expects to
    be given a file to be associated with throughout its life when it's constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rather than simply giving the `FileReader` and `FileWriter` paths to these
    files, I''ve chosen to create `File` objects. The Java file object is simply a
    reference to an existing file, and we tell that file what file it will reference
    when it''s created as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we're going to use `InputFile.txt`, which contains some information.
    Also, we're going to use `OutputFile.txt`, which currently contains no information.
    Our goal is to move the information from `InputFile` to `OutputFile`. Both `FileWriter`
    and `FileReader` have methods that are going to be useful here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `FileWriter` class has the `write` method, which we know can be used to
    put information into a file. Similarly, `FileReader` has the `read` method, which
    will allow us to acquire information from a file. If we simply call these methods
    in sequence and run our program, we''ll see that information will be taken from
    `InputFile` and put into `OutputFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf4cf512-f991-429b-b835-a717aeea1821.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, only one character appears in `OutputFile`: the first character
    of the `InputFile` text. It would appear that our `FileReader` class''s `read`
    method only acquires the smallest acquirable piece of text information. This is
    not a problem for us though because we are programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply loop through the file using the `in.read` method to acquire all
    of the information available to us in that `InputFile` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can make life a little easier by wrapping `FileReader` with a `BufferedReader`
    class. Similar to the way we wrap `FileWriter` with `BufferedWriter`, wrapping
    `FileReader` with `BufferedReader` will allow us to collect varying lengths of
    input at any given time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even more so than wrapping our `FileWriter` class, it's almost always a good
    idea to wrap our `FileReader` class The `BufferedReader` class also serves to
    protect the `FileReader` class from files that are too large for the `FileReader`
    class to hold in memory at one time. This doesn't happen very often, but when
    it does happen, it can be a pretty confusing bug. This is because `BufferedReader`
    looks at the portions of the file only at one time; it's protected from that instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `BufferedReader` class is also going to let us use the `nextLine` method
    so that we can collect information from `InputFile` on a line-by-line basis instead
    of a character-by-character basis. Either way though, our `while` loop is going
    to look pretty similar. The only real challenge here is that we need to know when
    to stop looking for information in our `InputFile` file. To figure this out, we're
    actually going to put some functional code in the conditional portion of our `while`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to assign a value to this `newInput` string variable and that
    value is going to be `in.readLine`. The reason we want to do this assignment in
    the conditional portion of our `while` loop is so that we can then check what
    value was assigned to `newInput` string. This is because if `newInput` string
    were assigned no value at all, it would mean that we''d reach the end of our file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If `newInput` does have a value, if the variable is not null, then we would
    know that we've read in legitimate text from our file, an entire line of legitimate
    text actually, because we're using the `readLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a case, we should add a new line of text, which is `input += newInput;` to
    our input string. When we''re finished executing our `while` loop, when `newInput`
    string is assigned the value `null` because there''s nothing else for our reader
    to read, we should print out the string we''ve been building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because our `BufferedReader` class''s `readLine` method specifically reads
    lines of text, it doesn''t append the end line character at the end of these lines,
    so we''ll have to do this on our own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''ve executed this program. Let''s go to our directory and see what''s
    been copied over to `OutputFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f074b43-77be-47bf-955d-653d75b19acf.png)'
  prefs: []
  type: TYPE_IMG
- en: There we go; `InputFile` and `OutputFile` now have identical content. That's
    really all there is to basic file reading in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of other things to note, though. Just as we can wrap `FileReader`
    with `BufferedReader`, we can wrap `BufferedReader` with `Scanner` if we import
    `java.util`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This would allow us to use the `Scanner` class's methodologies to acquire only
    those portions of the text we were reading that match certain patterns. It's also
    important to note that the `FileReader` class and it's wrapping classes are only
    appropriate when we're reading text from a Java file. If we want to read binary
    information, we're going to use different classes; you'll see more on this when
    you learn about serializing objects in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The Serializable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when we're dealing with information outside of our actual code, we're
    dealing with human-readable text that we've gotten from a file or are writing
    to a file or from an input or output stream. However, sometimes, human-readable
    text is just not convenient, and we'd like to use information that's more computer
    friendly. Through a process called **serialization**, we can take some Java objects
    and convert them into a binary stream that we could transfer across programs.
    This is not a human-friendly approach, as we'll see in this section. A serialized
    object looks like complete gibberish to us, but another Java program that knows
    about that object's class can recreate an object from that serialized information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all Java objects can be serialized, though. In order for us to serialize
    an object, it needs to be marked as an object that can be serialized, and it needs
    to only contain members that themselves can be serialized. For some objects, those
    that depend on external references or those that simply haven''t had all their
    members marked as serializable, serialization is just not appropriate. Refer to
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The class in the given program (in the preceding code block) is a prime candidate
    for serialization. Its members are a number of strings and integers, both of which
    are classes that Java has marked as serializable. However, in order for us to
    transform a `Car` object into a binary representation, we will need to let Java
    know that the `Car` object is serializable as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to need the `io` library for this, then we''re going to let Java
    know that our `Car` object implements `Serializable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is telling Java that all the elements of the `Car` object can be converted
    into binary representations. We should never tell Java that an object implements
    `Serializable` unless we've looked at the object and thought it out and determined
    that this is a safe assumption to make.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've now marked `Car` as a `Serializable` class, but that is, of course,
    the easy part of this section. Our next goal is to make use of this new functionality
    to create a `Car` object, serialize it, print it out to a file, and then read
    it back.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''re going to create two new Java classes: one to serialize our
    object and print it to a file and another class to deserialize our object and
    read it from a file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both these classes, we're going to create `main` methods so that we can run
    our classes as separate Java programs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serializing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with the `Serialize` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''re going to need is an object for us to serialize. So let''s
    go ahead and instantiate a new `Car` object. The `Car` class takes four strings
    and an integer for its variables. It takes a vehicle identification number, make,
    model, color, and a year. So we''ll give it all of that, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we've created our `Car` object, it's time to open up a file and serialize
    this `Car` for output. When we open up a file in Java, we'll use some different
    managers, depending on whether we'd like to write formatted text output to this
    file or whether we're just planning on writing raw binary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialized objects are binary information, so we''re going to use `FileOutputStream`
    to write this information. The `FileOutputStream` class is created with a filename
    to associate itself with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because we're writing raw binary information, it's not that important that we
    specify it as a text file. We can specify it to be really whatever we would like.
    Our operating system really isn't going to know what to do with this file if it
    tries to open it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to want to surround all of this information in a `try...catch`
    block because whenever we''re dealing with external files, exceptions can definitely
    be thrown. If we do catch an exception, let''s just simply print an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are required to add a lot of input here; let's just import the
    entirety of the `java.io` library, that is, lets import the `java.io.*;` package.
  prefs: []
  type: TYPE_NORMAL
- en: Now I think we're good to move along. We've created our `FileOutputStream` class,
    and this stream is pretty good. However, we can wrap it with another string that's
    more specialized for the act of serializing a Java object.
  prefs: []
  type: TYPE_NORMAL
- en: This is `ObjectOutputStream` class, and we can construct `ObjectOutputStream`
    object by simply wrapping it around an existing `FileOutputStream` object. Once
    we've created this `ObjectOutputStream` object and associated a file with it,
    serializing our object and writing it to this file becomes extremely easy. We
    simply need to use the `writeObject` method and provide our `Car` class as the
    object to be written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we write this object to our file, we should be responsible and close our
    output string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I think we''re good to run our following program. Let''s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have multiple `main` methods in this Java project. So as far as NetBeans
    is concerned, when we run our program, we should make sure to right-click on the
    class whose `main` method we want to enter with and run that file specifically.
    When we run this program, we don''t really get any meaningful output because we
    didn''t ask for any, at least an error wasn''t thrown. But, when we head to our
    directory in which this project lives, we''ll see a new file: `serialize.dat`.
    If we edit this file with Notepad, it looks pretty ridiculous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f4ce67-e72d-41fa-a47a-4844defd3871.png)'
  prefs: []
  type: TYPE_IMG
- en: This is certainly not a human-readable format, but there are some words, or
    fragments of words, that we recognize. It certainly looks like the correct object
    was serialized.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by heading to our other class, that is, the `DeSerialize` class,
    and attempt to write a method that will pull the `Car` object out from that file
    that we''ve written its serialized information to. The steps for doing this are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we're going to need a `Car` object, but this time, we're not going
    to initialize it with a constructor value; rather, we're going to set its value
    to be the object we read back from our file. The syntax we're going to use in
    our deserializer is going to look very similar to the syntax that we used in our
    `Serialize` class `main` method. Let's just copy the code of the `Serialize` class
    so that we can see mirrored similarities as we build our `main` method of `DeSerialize`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previously discussed `Serialize` class, we made kind of an irresponsible
    error in the `Serialize` class's method. We closed `ObjectOutputStream` but we
    did not close `FileOutputStream`. This isn't really a big deal because our program
    immediately opened these files, performed its functionality, and upon terminating
    Java, it destroyed these objects and the files knew that nothing else was pointing
    to them. So, our operating system is aware that these files are closed and can
    now be freely written. But, in a program that continues for a long time, or even
    indefinitely, not closing a file can have some very weird consequences.
  prefs: []
  type: TYPE_NORMAL
- en: When we're nesting `FileInput` or `Output` classes like we've done in this program,
    we're generally going to close our files in reverse order in which we accessed
    them. In this program, it wouldn't make sense for us to call `outFile.close` before
    `out.close` because for a brief moment, our `ObjectOutputStream` object would
    be referencing a file that it could no longer access because the inner `FileOutputStream`
    class would have been closed. Now delete `Car c = new Car("FDAJFD54254", " Nisan",
    "Altima", "Green", 2000);` in the current `DeSerialize.java` class.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, we've copied our code over and now we're going to
    make some modifications to it. So instead of serializing our object to a file,
    we are now reading the serialized object from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, instead of a `FileOutputStream` class, we''re going to use its sister
    class, namely `FileInputStream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's import `java.io` again. We want to be referencing the same filename as
    given in the preceding code; also, let's intelligently name our variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a similar manner, we''re going to wrap `FileInputStream` with `ObjectInputStream`
    instead of `ObjectOutputStream`, which is still referencing the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this time we have no interest in writing an object to this file,
    and that's good because our `InputStream` class does not have the permissions
    or the know-how to write to this file; what it can do, however, is read an object
    from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadObject` doesn''t take any parameters; it''s simply going to read whatever
    object happens to be in that file. When it reads that object, assign it to our
    `Car` object. Of course, `ReadObject` only knows it''s going to acquire an object
    from the file; it has no idea what type of object that will be. One of the weaknesses
    of serialization is that we really are forced to take a leap of faith and cast
    this object to the expected type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, it''s simply time to close our file readers in reverse
    order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's another type of handled exception being thrown now, namely `ClassNotFoundException`:![](img/f1a66c24-7b73-458f-a70f-b7e7bfb59c3c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is thrown if our `readObject` method fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s catch `ClassNotFoundException`, and to keep things simple and moving,
    we''ll just throw or print out an error message like we did with the previous
    I/O exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a way to tell whether our program worked or not. So, at the very
    end, let''s attempt to print out our car''s information using its custom `toString`
    function, that is, `System.out.println(c.toString());` statement. NetBeans is
    letting us know that the variable `c` might not be initialized at this point in
    time as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/209ae27d-b146-44b4-99d6-623c1f270534.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some programming languages will let us make this mistake, and our `Car` object
    might not have been initialized because this `try` block could have failed. To
    let NetBeans know that we''re aware of this case, or rather, to let Java know
    that we''re aware of this case, we should initialize our `Car` object. We can
    simply initialize it to the value `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time for our moment of truth. Let''s execute the main method. When
    we run our file in our console, we get the output as a pin number: `2000 Green
    Nisan Altima with vin: FDAJFD54254`. This is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff4aebb5-e973-413e-98e8-99e163e4e226.png)'
  prefs: []
  type: TYPE_IMG
- en: That's the same car we declared in the `main` method of the `Serialize.java`
    class and serialized to the file. Clearly, we have been successful. Serialization
    of objects is one of the things that Java does really elegantly and really well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went through the process of writing and reading data files,
    where we saw the usage of `FileWriter` and `FileReader` classes and how to relieve
    resources that use the `close()` method. We also saw how to catch an exception
    and handle it. Then, you learned how to use the `BufferedWriter` and `BufferedReader`
    classes to wrap the `FileWriter` and `FileReader` classes, respectively. Finally,
    we saw one more aspect of I/O: the `Serializable` class. We analyzed what serialization
    is and its usage with respect to serializing and deserializing objects.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about basic GUI development.
  prefs: []
  type: TYPE_NORMAL

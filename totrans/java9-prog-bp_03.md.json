["```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> \n    <project  \n\n      xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0  \n      http://maven.apache.org/xsd/maven-4.0.0.xsd\"> \n      <modelVersion>4.0.0</modelVersion> \n\n     <groupId>com.steeplesoft.dupefind</groupId> \n     <artifactId>dupefind-master</artifactId> \n     <version>1.0-SNAPSHOT</version> \n     <packaging>pom</packaging> \n\n     <modules> \n       <module>lib</module> \n       <module>cli</module> \n       <module>gui</module> \n     </modules> \n\n     <name>Duplicate Finder - Master</name> \n    </project> \n\n```", "```java\n    module com.steeplesoft.dupefind.lib { \n      exports com.steeplesoft.dupefind.lib; \n    } \n\n```", "```java\n    private final Set<Path> sourcePaths = new HashSet<>(); \n    private final Set<String> patterns = new HashSet<>(); \n\n```", "```java\n    private final ExecutorService es = \n      Executors.newFixedThreadPool(5); \n\n```", "```java\n    private final Map<String, List<FileInfo>> duplicates =  \n      new HashMap<>(); \n\n```", "```java\n    module dupefind.lib { \n      exports com.steeplesoft.dupefind.lib; \n      requires java.logging; \n      requires javax.persistence; \n    } \n\n```", "```java\n    public FileFinder() { \n      Map<String, String> props = new HashMap<>(); \n      props.put(\"javax.persistence.jdbc.url\",  \n       \"jdbc:sqlite:\" +  \n       System.getProperty(\"user.home\") +  \n       File.separator +  \n       \".dupfinder.db\"); \n      factory = Persistence.createEntityManagerFactory \n       (\"dupefinder\", props); \n      purgeExistingFileInfo(); \n    } \n\n```", "```java\n    public void find() { \n      List<PathMatcher> matchers = patterns.stream() \n       .map(s -> !s.startsWith(\"**\") ? \"**/\" + s : s) \n       .map(p -> FileSystems.getDefault() \n       .getPathMatcher(\"glob:\" + p)) \n       .collect(Collectors.toList()); \n\n```", "```java\n    sourcePaths.stream() \n     .map(p -> new FindFileTask(p)) \n     .forEach(fft -> es.execute(fft)); \n\n```", "```java\n    @Override \n    public void run() { \n      final EntityTransaction transaction = em.getTransaction(); \n      try { \n        transaction.begin(); \n        Files.walkFileTree(startDir, this); \n        transaction.commit(); \n      } catch (IOException ex) { \n        transaction.rollback(); \n      } \n    } \n\n```", "```java\n    @Override \n    public FileVisitResult preVisitDirectory(final Path dir,  \n    final BasicFileAttributes attrs) throws IOException { \n      return Files.isReadable(dir) ?  \n       FileVisitResult.CONTINUE : FileVisitResult.SKIP_SUBTREE; \n    } \n\n```", "```java\n    @Override \n    public FileVisitResult visitFileFailed(final Path file,  \n     final IOException exc) throws IOException { \n       return FileVisitResult.SKIP_SUBTREE; \n    } \n\n```", "```java\n    @Override \n    public FileVisitResult postVisitDirectory(final Path dir,  \n     final IOException exc) throws IOException { \n       return FileVisitResult.CONTINUE; \n    } \n\n```", "```java\n    @Override \n    public FileVisitResult visitFile(final Path file, final\n     BasicFileAttributes attrs) throws IOException { \n       if (Files.isReadable(file) && isMatch(file)) { \n         addFile(file); \n       } \n       return FileVisitResult.CONTINUE; \n    } \n\n```", "```java\n    private boolean isMatch(final Path file) { \n      return matchers.isEmpty() ? true :  \n       matchers.stream().anyMatch((m) -> m.matches(file)); \n    } \n\n```", "```java\n    private void addFile(Path file) throws IOException { \n      FileInfo info = new FileInfo(); \n      info.setFileName(file.getFileName().toString()); \n      info.setPath(file.toRealPath().toString()); \n      info.setSize(file.toFile().length()); \n      em.persist(info); \n    } \n\n```", "```java\n    es.shutdown(); \n    es.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); \n\n```", "```java\n    private void postProcessFiles() { \n      EntityManager em = factory.createEntityManager(); \n      List<FileInfo> files = getDuplicates(em, \"fileName\"); \n\n```", "```java\n    private List<FileInfo> getDuplicates(EntityManager em,  \n     String fieldName) { \n       List<FileInfo> files = em.createQuery( \n         DUPLICATE_SQL.replace(\"%FIELD%\", fieldName), \n          FileInfo.class).getResultList(); \n       return files; \n    } \n\n```", "```java\n    @Entity \n    public class FileInfo implements Serializable { \n      @GeneratedValue \n      @Id \n      private int id; \n      private String fileName; \n      private String path; \n      private long size; \n      private String hash; \n    } \n\n```", "```java\n    module dupefind.lib { \n      exports com.steeplesoft.dupefind.lib; \n      exports com.steeplesoft.dupefind.lib.model; \n      requires java.logging; \n      requires javax.persistence; \n    } \n\n```", "```java\n SELECT f FROM FileInfo f \n\n```", "```java\n SELECT f from FileInfo f WHERE f.fileName = :name \n\n```", "```java\n Query query = em.createQuery( \n      \"SELECT f from FileInfo f WHERE f.fileName = :name\"); \n    query.setParameter(\"name\", \"test3.txt\"); \n    query.getResultList().stream() //... \n\n```", "```java\n SELECT f  \n    FROM FileInfo f,  \n      (SELECT s.%FIELD%  \n        FROM FileInfo s  \n        GROUP BY s.%FIELD%  \n        HAVING (COUNT(s.%FIELD%) > 1)) g \n    WHERE f.%FIELD% = g.%FIELD%  \n    AND f.%FIELD% IS NOT NULL  \n    ORDER BY f.fileName, f.path \n\n```", "```java\n    List<FileInfo> files = getDuplicates(em, \"fileName\"); \n    files.addAll(getDuplicates(em, \"size\")); \n\n```", "```java\n    em.getTransaction().begin(); \n    files.forEach(f -> calculateHash(f)); \n    em.getTransaction().commit(); \n\n```", "```java\n    private void calculateHash(FileInfo file) { \n      try { \n        MessageDigest messageDigest =  \n          MessageDigest.getInstance(\"SHA3-256\"); \n        messageDigest.update(Files.readAllBytes( \n          Paths.get(file.getPath()))); \n        ByteArrayInputStream inputStream =  \n          new ByteArrayInputStream(messageDigest.digest()); \n        String hash = IntStream.generate(inputStream::read) \n         .limit(inputStream.available()) \n         .mapToObj(i -> Integer.toHexString(i)) \n         .map(s -> (\"00\" + s).substring(s.length())) \n         .collect(Collectors.joining()); \n        file.setHash(hash); \n      } catch (NoSuchAlgorithmException | IOException ex) { \n        throw new RuntimeException(ex); \n      } \n    }  \n\n```", "```java\n    getDuplicates(em, \"hash\").forEach(f -> coalesceDuplicates(f)); \n    em.close(); \n\n```", "```java\n    private void coalesceDuplicates(FileInfo f) { \n      String name = f.getFileName(); \n      List<FileInfo> dupes = duplicates.get(name); \n      if (dupes == null) { \n        dupes = new ArrayList<>(); \n        duplicates.put(name, dupes); \n      } \n      dupes.add(f); \n    } \n\n```", "```java\n    public static void main(String[] args) \n\n```", "```java\n    int i = 0; \n    while (i < args.length) { \n      if (\"--source\".equals(args[i])) { \n         System.out.println(\"--source = \" + args[++i]); \n      } else if (\"--target\".equals(args[i])) { \n         System.out.println(\"--target = \" + args[++i]); \n      } else if (\"--force\".equals(args[i])) { \n        System.out.println(\"--force set to true\"); \n      } \n      i++; \n    } \n\n```", "```java\n    public static void main(String[] args) throws ParseException { \n      Options options = new Options(); \n      options.addOption(\"s\", \"source\", true, \"The source\"); \n      options.addOption(\"t\", \"target\", true, \"The target\"); \n      options.addOption(\"f\", \"force\", false, \"Force\"); \n      CommandLineParser parser = new DefaultParser(); \n      CommandLine cmd = parser.parse(options, args); \n      if (cmd.hasOption(\"source\")) { \n        System.out.println(\"--source = \" +  \n          cmd.getOptionValue(\"source\")); \n      } \n      if (cmd.hasOption(\"target\")) { \n        System.out.println(\"--target = \" +  \n          cmd.getOptionValue(\"target\")); \n      } \n      if (cmd.hasOption(\"force\")) { \n         System.out.println(\"--force set to true\"); \n      } \n    } \n\n```", "```java\n    @Command(name = \"copy\", description = \"Copy a file\") \n    public class CopyCommand { \n      @Option(name = {\"-s\", \"--source\"}, description = \"The source\") \n      private String source; \n      @Option(name = {\"-t\", \"--target\"}, description = \"The target\") \n      private String target; \n      @Option(name = {\"-f\", \"--force\"}, description = \"Force\") \n      private boolean force = false; \n      public static void main(String[] args) { \n        SingleCommand<CopyCommand> parser =  \n          SingleCommand.singleCommand(CopyCommand.class); \n        CopyCommand cmd = parser.parse(args); \n        cmd.run(); \n      } \n\n      private void run() { \n        System.out.println(\"--source = \" + source); \n        System.out.println(\"--target = \" + target); \n        if (force) { \n          System.out.println(\"--force set to true\"); \n        } \n      } \n    } \n\n```", "```java\n    public class Commands { \n      @Command \n      public void copy(@Option(\"source\") String source, \n        @Option(\"target\") String target, \n        @Option(\"force\") @Default(\"false\") boolean force) { \n          System.out.println(\"--source = \" + source); \n          System.out.println(\"--target = \" + target); \n          if (force) { \n            System.out.println(\"--force set to true\"); \n          } \n       } \n    } \n\n```", "```java\n    public class DupeFinderCommands { \n      @Command \n      public void findDupes( \n        @Option(\"pattern\") List<String> patterns, \n        @Option(\"path\") List<String> paths, \n        @Option(\"verbose\") @Default(\"false\") boolean verbose, \n        @Option(\"show-timings\")  \n        @Default(\"false\") boolean showTimings) { \n\n```", "```java\n    module dupefind.cli { \n      requires tomitribe.crest; \n      requires tomitribe.crest.api; \n    } \n\n```", "```java\n    if (verbose) { \n      System.out.println(\"Scanning for duplicate files.\"); \n      System.out.println(\"Search paths:\"); \n      paths.forEach(p -> System.out.println(\"\\t\" + p)); \n      System.out.println(\"Search patterns:\"); \n      patterns.forEach(p -> System.out.println(\"\\t\" + p)); \n      System.out.println(); \n    } \n\n```", "```java\n    final Instant startTime = Instant.now(); \n    FileFinder ff = new FileFinder(); \n    patterns.forEach(p -> ff.addPattern(p)); \n    paths.forEach(p -> ff.addPath(p)); \n\n    ff.find(); \n\n    System.out.println(\"The following duplicates have been found:\"); \n    final AtomicInteger group = new AtomicInteger(1); \n    ff.getDuplicates().forEach((name, list) -> { \n      System.out.printf(\"Group #%d:%n\", group.getAndIncrement()); \n      list.forEach(fileInfo -> System.out.println(\"\\t\"  \n        + fileInfo.getPath())); \n    }); \n    final Instant endTime = Instant.now(); \n\n```", "```java\n    module dupefind.cli { \n      requires dupefind.lib; \n      requires tomitribe.crest; \n      requires tomitribe.crest.api; \n    } \n\n```", "```java\n    import com.steeplesoft.dupefind.lib.model.FileInfo; \n    import com.steeplesoft.dupefind.lib.util.FindFileTask; \n    public class VisibilityTest { \n      public static void main(String[] args) { \n        FileInfo fi; \n        FindFileTask fft; \n      } \n    } \n\n```", "```java\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project cli: Compilation failure: Compilation failure:\n[ERROR] /C:/Users/jason/src/steeplesoft/DupeFinder/cli/src/main/java/com/\nsteeplesoft/dupefind/cli/VisibilityTest.java:[9,54] \ncom.steeplesoft.dupefind.lib.util.FindFileTask is not visible because \npackage com.steeplesoft.dupefind.lib.util is not visible \n[ERROR] /C:/Users/jason/src/steeplesoft/DupeFinder/cli/src/main/java/com/\nsteeplesoft/dupefind/cli/VisibilityTest.java:[13,9] cannot find symbol \n[ERROR] symbol:   class FindFileTask \n[ERROR] location: class com.steeplesoft.dupefind.cli.VisibilityTest \n\n```", "```java\nThe following duplicates have been found: \nGroup #1: \n     C:\\some\\path\\test\\set1\\file5.txt \n     C:\\some\\path\\test\\set2\\file5.txt \nGroup #2: \n     C:\\some\\path\\test\\set1\\file11.txt \n     C:\\some\\path\\test\\set1\\file11-1.txt \n     C:\\some\\path\\test\\set2\\file11.txt \n\n```", "```java\n    if (showTimings) { \n      Duration duration = Duration.between(startTime, endTime); \n      long hours = duration.toHours(); \n      long minutes = duration.minusHours(hours).toMinutes(); \n      long seconds = duration.minusHours(hours) \n         .minusMinutes(minutes).toMillis() / 1000; \n      System.out.println(String.format( \n        \"%nThe scan took %d hours, %d minutes, and %d seconds.%n\",  \n         hours, minutes, seconds)); \n    } \n\n```", "```java\n path = Adds a path to be searched. Can be specified multiple times. \n    pattern = Adds a pattern to match against the file names (e.g.,\n    \"*.png\").\n    Can be specified multiple times. \n    show-timings= Show how long the scan took \n    verbose = Show summary of duplicate scan configuration \n\n```", "```java\n $ java -jar cli-1.0-SNAPSHOT.jar help findDupes \n    Usage: findDupes [options] \n    Options: \n      --path=<String[]>    Adds a path to be searched. Can be\n                            specified multiple times. \n      --pattern=<String[]> Adds a pattern to match against\n                            the file names\n                           (e.g., \"*.png\"). Can be specified\n                             multiple times. \n      --show-timings       Show how long the scan took \n      --verbose            Show summary of duplicate scan configuration \n\n```", "```java\n    <dependency> \n      <groupId>org.tomitribe</groupId> \n      <artifactId>tomitribe-crest</artifactId> \n      <version>${crest.version}</version> \n    </dependency> \n\n```", "```java\n    <dependency> \n      <groupId>${project.groupId}</groupId> \n      <artifactId>lib</artifactId> \n      <version>${project.version}</version> \n    </dependency> \n\n```", "```java\n    <plugin> \n      <groupId>org.apache.maven.plugins</groupId> \n      <artifactId>maven-compiler-plugin</artifactId> \n      <configuration> \n         <source>1.8</source> \n         <target>1.8</target> \n      </configuration> \n    </plugin> \n\n```", "```java\n    <plugin> \n      <groupId>org.tomitribe</groupId> \n      <artifactId>crest-maven-plugin</artifactId> \n      <version>${crest.version}</version> \n      <executions> \n         <execution> \n            <goals> \n              <goal>descriptor</goal> \n            </goals> \n         </execution> \n      </executions> \n    </plugin> \n\n```", "```java\n    <plugin> \n      <artifactId>maven-shade-plugin</artifactId> \n      <version>2.1</version> \n      <executions> \n         <execution> \n             <phase>package</phase> \n             <goals> \n                <goal>shade</goal> \n              </goals> \n              <configuration> \n                 <transformers> \n                   <transformer implementation= \n                     \"org.apache.maven.plugins.shade.resource\n                      .ManifestResourceTransformer\"> \n                     <mainClass> \n                       org.tomitribe.crest.Main \n                     </mainClass> \n                   </transformer> \n                 </transformers> \n              </configuration> \n         </execution> \n      </executions> \n    </plugin> \n\n```", "```java\n java -jar target\\cli-1.0-SNAPSHOT.jar findDupes \\\n      --path=../test/set1 --path=../test/set2 -pattern=*.txt \n\n```", "```java\n    module dupefind.gui { \n      requires dupefind.lib; \n      requires java.logging; \n      requires javafx.controls; \n      requires javafx.fxml; \n      requires java.desktop; \n    } \n\n```", "```java\n    <top> \n      <MenuBar BorderPane.alignment=\"CENTER\"> \n        <menus> \n          <Menu mnemonicParsing=\"false\"  \n            onAction=\"#closeApplication\" text=\"File\"> \n            <items> \n              <MenuItem mnemonicParsing=\"false\" text=\"Close\" /> \n            </items> \n          </Menu> \n          <Menu mnemonicParsing=\"false\" text=\"Help\"> \n            <items> \n              <MenuItem mnemonicParsing=\"false\"  \n                onAction=\"#showAbout\" text=\"About\" /> \n            </items> \n          </Menu> \n        </menus> \n      </MenuBar> \n    </top> \n\n```", "```java\n    <VBox BorderPane.alignment=\"TOP_CENTER\"> \n      <children> \n         <HBox... /> \n         <Separator ... /> \n         <Label .../> \n         <ListView ... /> \n         <HBox ... /> \n         <Label ... /> \n         <ListView... /> \n         <HBox ... /> \n      </children> \n      <padding> \n         <Insets bottom=\"10.0\" left=\"10.0\" right=\"10.0\" \n           top=\"10.0\" /> \n      </padding> \n    </VBox> \n\n```", "```java\n    <ListView fx:id=\"searchPatternsListView\" VBox.vgrow=\"ALWAYS\" /> \n    ... \n    <ListView fx:id=\"sourceDirsListView\" VBox.vgrow=\"ALWAYS\" /> \n\n```", "```java\n    <HBox> \n      <children> \n         <Separator orientation=\"VERTICAL\"/> \n         <VBox HBox.hgrow=\"ALWAYS\"> \n           <children> \n             <VBox VBox.vgrow=\"ALWAYS\"> \n                <children> \n                  <Label ... /> \n                  <ListView ... VBox.vgrow=\"ALWAYS\" /> \n                </children> \n             </VBox> \n           </children> \n         </VBox> \n         <VBox HBox.hgrow=\"ALWAYS\"> \n           <children> \n             <Label ... /> \n             <ListView ... VBox.vgrow=\"ALWAYS\" /> \n           </children> \n         </VBox> \n      </children> \n    </HBox> \n\n```", "```java\n    <ListView fx:id=\"matchingFilesListView\" VBox.vgrow=\"ALWAYS\"> \n      <contextMenu> \n        <ContextMenu> \n          <items> \n            <MenuItem onAction=\"#openFiles\" text=\"Open File(s)...\" /> \n            <MenuItem onAction=\"#deleteSelectedFiles\"  \n              text=\"Delete File(s)...\" /> \n           </items> \n         </ContextMenu> \n      </contextMenu> \n    </ListView> \n\n```", "```java\n    @FXML \n    private ListView<String> dupeFileGroupListView; \n    @FXML \n    private ListView<FileInfo> matchingFilesListView; \n    @FXML \n    private Button addPattern; \n    @FXML \n    private Button removePattern; \n\n```", "```java\n    final private ObservableList<String> paths =  \n      FXCollections.observableArrayList(); \n    final private ObservableList<String> patterns =  \n      FXCollections.observableArrayList(); \n\n```", "```java\n    public void initialize(URL url, ResourceBundle rb) { \n      searchPatternsListView.setItems(patterns); \n      sourceDirsListView.setItems(paths); \n\n```", "```java\n    dupeFileGroupListView.setCellFactory( \n      (ListView<String> p) -> new ListCell<String>() { \n        @Override \n        public void updateItem(String string, boolean empty) { \n          super.updateItem(string, empty); \n          final int index = p.getItems().indexOf(string); \n          if (index > -1) { \n            setText(\"Group #\" + (index + 1)); \n          } else { \n            setText(null); \n          } \n       } \n    }); \n\n```", "```java\n    dupeFileGroupListView.setCellFactory(new  \n      Callback<ListView<String>, ListCell<String>>() { \n        @Override \n        public ListCell<String> call(ListView<String> p) { \n          return new ListCell<String>() { \n            @Override \n            protected void updateItem(String t, boolean bln) { \n             super.updateItem(string, empty); \n              final int index = p.getItems().indexOf(string); \n              if (index > -1) { \n                setText(\"Group #\" + (index + 1)); \n              } else { \n                setText(null); \n              } \n            } \n          }; \n        } \n    }); \n\n```", "```java\n    matchingFilesListView.getSelectionModel() \n      .setSelectionMode(SelectionMode.MULTIPLE); \n    matchingFilesListView.setCellFactory( \n      (ListView<FileInfo> p) -> new ListCell<FileInfo>() { \n        @Override \n        protected void updateItem(FileInfo fileInfo, boolean bln) { \n          super.updateItem(fileInfo, bln); \n          if (fileInfo != null) { \n             setText(fileInfo.getPath()); \n          } else { \n             setText(null); \n          } \n        } \n    }); \n\n```", "```java\n    findFiles.prefWidthProperty().bind(findBox.widthProperty()); \n\n```", "```java\n    @FXML \n    private void handleButtonAction(ActionEvent event) { \n      if (event.getSource() instanceof Button) { \n        Button button = (Button) event.getSource(); \n        if (button.equals(addPattern)) { \n          addPattern(); \n        } else if (button.equals(removePattern)) { \n        // ... \n\n```", "```java\n    private void addPattern() { \n      TextInputDialog dialog = new TextInputDialog(\"*.*\"); \n      dialog.setTitle(\"Add a pattern\"); \n      dialog.setHeaderText(null); \n      dialog.setContentText(\"Enter the pattern you wish to add:\"); \n\n      dialog.showAndWait() \n      .filter(n -> n != null && !n.trim().isEmpty()) \n      .ifPresent(name -> patterns.add(name)); \n    } \n\n```", "```java\n    private void removePattern() { \n      if (searchPatternsListView.getSelectionModel() \n      .getSelectedIndex() > -1) { \n        showConfirmationDialog( \n          \"Are you sure you want to remove this pattern?\", \n          (() -> patterns.remove(searchPatternsListView \n          .getSelectionModel().getSelectedItem()))); \n      } \n    } \n\n```", "```java\n    protected void showConfirmationDialog(String message, \n     Runnable action) { \n      Alert alert = new Alert(Alert.AlertType.CONFIRMATION); \n      alert.setTitle(\"Confirmation\"); \n      alert.setHeaderText(null); \n      alert.setContentText(message); \n      alert.showAndWait() \n      .filter(b -> b == ButtonType.OK) \n      .ifPresent(b -> action.run()); \n    } \n\n```", "```java\n    private void addPath() { \n        DirectoryChooser dc = new DirectoryChooser(); \n        dc.setTitle(\"Add Search Path\"); \n        dc.setInitialDirectory(new File(lastDir)); \n        File dir = dc.showDialog(null); \n        if (dir != null) { \n            try { \n                lastDir = dir.getParent(); \n                paths.add(dir.getCanonicalPath()); \n            } catch (IOException ex) { \n                Logger.getLogger(FXMLController.class.getName()).log(\n                  Level.SEVERE, null, ex); \n            } \n        } \n    } \n\n```", "```java\n    private void removePath() { \n      showConfirmationDialog( \n        \"Are you sure you want to remove this path?\", \n        (() -> paths.remove(sourceDirsListView.getSelectionModel() \n        .getSelectedItem()))); \n    } \n\n```", "```java\n    private void findFiles() { \n       FileFinder ff = new FileFinder(); \n       patterns.forEach(p -> ff.addPattern(p)); \n       paths.forEach(p -> ff.addPath(p)); \n\n       ff.find(); \n       dupes = ff.getDuplicates(); \n       ObservableList<String> groups =  \n         FXCollections.observableArrayList(dupes.keySet()); \n\n       dupeFileGroupListView.setItems(groups); \n    } \n\n```", "```java\n    @FXML \n    public void dupeGroupClicked(MouseEvent event) { \n      int index = dupeFileGroupListView.getSelectionModel() \n       .getSelectedIndex(); \n      if (index > -1) { \n        String hash = dupeFileGroupListView.getSelectionModel() \n        .getSelectedItem(); \n        matchingFilesListView.getItems().clear(); \n        matchingFilesListView.getItems().addAll(dupes.get(hash)); \n      } \n    } \n\n```", "```java\n    @FXML \n    public void keyPressed(KeyEvent event) { \n      dupeGroupClicked(null); \n    } \n\n```", "```java\n    @FXML \n    public void openFiles(ActionEvent event) { \n      matchingFilesListView.getSelectionModel().getSelectedItems() \n      .forEach(f -> { \n        try { \n          Desktop.getDesktop().open(new File(f.getPath())); \n        } catch (IOException ex) { \n          // ... \n        } \n      }); \n    } \n\n```", "```java\n    @FXML \n    public void deleteSelectedFiles(ActionEvent event) { \n      final ObservableList<FileInfo> selectedFiles =  \n        matchingFilesListView.getSelectionModel() \n        .getSelectedItems(); \n      if (selectedFiles.size() > 0) { \n        showConfirmationDialog( \n          \"Are you sure you want to delete the selected files\", \n           () -> selectedFiles.forEach(f -> { \n            if (Desktop.getDesktop() \n            .moveToTrash(new File(f.getPath()))) {                         \n              matchingFilesListView.getItems() \n              .remove(f); \n              dupes.get(dupeFileGroupListView \n               .getSelectionModel() \n               .getSelectedItem()).remove(f); \n            } \n        })); \n      } \n    } \n\n```"]
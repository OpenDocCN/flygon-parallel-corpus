- en: Duplicate File Finder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复文件查找器
- en: Any system that's been running for a while starts to suffer from hard drive
    clutter. This is especially true, for example, with large music and photo collections.
    Except for the most fastidious files getting copied and moved, we end up with
    a copy here and a copy there. The question is, though, which of these are duplicates
    and which are not? In this chapter, we'll build a file-walking utility that will
    scan a set of directories looking for duplicate files. We'll be able to specify
    whether the duplicates should be deleted, **quarantined**, or simply reported.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运行了一段时间的系统都会开始受到硬盘杂乱的影响。例如，大型音乐和照片收藏品尤其如此。除了最一丝不苟地复制和移动文件之外，我们最终会在这里复制一份，在那里复制一份。问题是，这些中哪些是重复的，哪些不是？在本章中，我们将构建一个文件遍历实用程序，它将扫描一组目录，寻找重复的文件。我们将能够指定是否应删除重复项，将其隔离，或者只是报告。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Java Platform Module System
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统
- en: The Java NIO (New I/O) File APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java NIO（New I/O）文件API
- en: File hashing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件哈希
- en: '**Java Persistence API** (**JPA**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java持久性API（JPA）
- en: The new Java Date/Time API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Java日期/时间API
- en: Writing command-line utilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写命令行实用程序
- en: More JavaFX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的JavaFX
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This application, while conceptually fairly simple, is a bit more complex than
    what we looked at in the last chapter, in that we will have both, a command line
    and a graphical interface. The experienced programmer is likely to immediately
    see the need to share the code between these two interfaces, as **DRY** (**Don''t
    Repeat Yourself**) is one of the many hallmarks of a well-designed system. To
    facilitate this sharing of code, then, we will want to introduce a third module,
    which provides a library that can be consumed by the other two projects. We will
    call these modules `lib`, `cli`, and `gui`. Our first step in setting up the project
    is to create the various Maven POM files to describe the project''s structure.
    The parent POM will look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序在概念上相当简单，但比我们在上一章中看到的要复杂一些，因为我们将同时拥有命令行和图形界面。有经验的程序员很可能会立即意识到需要在这两个界面之间共享代码，因为“不要重复自己”是一个良好设计系统的许多标志之一。为了促进代码的共享，我们将引入第三个模块，提供一个可以被其他两个项目使用的库。我们将称这些模块为`lib`，`cli`和`gui`。设置项目的第一步是创建各种Maven
    POM文件来描述项目的结构。父POM将类似于这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fairly typical POM file. We will start by identifying the project's
    parent that lets us inherit a number of settings, dependencies, and so on, and
    avoid having to repeat them in this project. Next, we will define the Maven coordinates
    for the project. Note that we don't define a version for this project, allowing
    the parent's version to cascade down. This will allow us to increase the version
    as needed in one place, and update all of the subprojects implicitly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当典型的POM文件。我们将首先确定项目的父级，让我们继承一些设置、依赖关系等，避免在此项目中重复它们。接下来，我们将为项目定义Maven坐标。请注意，我们没有为这个项目定义版本，允许父版本级联下来。这将允许我们在一个地方根据需要增加版本，并隐式更新所有子项目。
- en: The last interesting part of this POM, for those who haven't seen a multi-module
    project before, is the `modules` section. The only thing to note here, for those
    who are new to this, is that each `module` element refers to a directory name,
    which is a direct child of the current directory, and should be declared in the
    order in which they are needed. In our case, the CLI and GUI both depend on the
    library, so `lib` goes first. Next, we'll need to create the POM files for each
    module. Each of these are typical POMs of type jar, so there's no need to include
    them here. There will be varying dependencies in each, but we'll cover those as
    the need arises.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些以前没有见过多模块项目的人来说，这个POM的最后一个有趣的部分是“模块”部分。对于那些对此不熟悉的人来说，唯一需要注意的是，每个“模块”元素都指的是一个目录名称，它是当前目录的直接子目录，并且应该按照需要声明的顺序进行声明。在我们的情况下，CLI和GUI都依赖于库，所以`lib`首先出现。接下来，我们需要为每个模块创建POM文件。这些都是典型的jar类型的POM，所以这里不需要包含它们。每个模块中会有不同的依赖关系，但我们将根据需要进行覆盖。
- en: Building the library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建库
- en: The foundational piece of this project is the library which both the CLI and
    the GUI will consume, so it makes sense to start here. When designing the library--its
    inputs, outputs, and general behavior--it helps to understand what exactly do
    we want this system to do, so let's take some time to discuss the functional requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的基础部分是库，CLI和GUI都将使用它，所以从这里开始是有道理的。在设计库时——它的输入、输出和一般行为——了解我们希望这个系统做什么是有帮助的，所以让我们花点时间讨论功能需求。
- en: As stated in the introduction, we'd like to be able to search for duplicate
    files in an arbitrary number of directories. We'd also like to be able to restrict
    the search and comparison to only certain files. If we don't specify a pattern
    to match, then we want to check every file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，我们希望能够在任意数量的目录中搜索重复文件。我们还希望能够将搜索和比较限制在特定文件中。如果我们没有指定要匹配的模式，那么我们希望检查每个文件。
- en: 'The most important part is how to identify a match. There are, of course, a
    myriad of ways in which this can be done, but the approach we will use is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的部分是如何识别匹配项。当然，有许多方法可以做到这一点，但我们将使用的方法如下：
- en: Identify files that have the same filename. Think of those situations where
    you might have downloaded images from your camera to your computer for safekeeping,
    then, later, perhaps you forgot that you had already downloaded the images, so
    you copied them again somewhere else. Obviously, you only want one copy, but is
    the file, for example, `IMG_9615.JPG`, in the temp directory the same as the one
    in your picture backup directory? By identifying files with matching names, we
    can test them to be sure.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有相同文件名的文件。想象一下那些情况，你可能已经将照片从相机下载到计算机进行安全保管，然后，后来，也许你忘记了已经下载了这些照片，所以你又将它们复制到其他地方。显然，你只想要一份拷贝，但是例如`IMG_9615.JPG`这个文件，在临时目录中和你的图片备份目录中是一样的吗？通过识别具有相同名称的文件，我们可以测试它们以确保。
- en: Identify files that have the same size. The likelihood of a match here is smaller,
    but there is still a chance. For example, some photo management software, when
    importing images from a device, if it finds a file with the same name, will modify
    the filename of the second file and store both, rather than stopping the import
    and requiring immediate user intervention. This can result in a large number of
    files such as `IMG_9615.JPG` and `IMG_9615-1.JPG`. This check will help identify
    these situations.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有相同大小的文件。这里匹配的可能性较小，但仍然存在机会。例如，一些照片管理软件在从设备导入图像时，如果发现具有相同名称的文件，将修改第二个文件的文件名并存储两个文件，而不是停止导入并要求立即用户干预。这可能导致大量文件，如`IMG_9615.JPG`和`IMG_9615-1.JPG`。这个检查将有助于识别这些情况。
- en: For each match above, to determine whether the files are actually a match, we'll
    generate a hash based on the file contents. If more than one file generates the
    same hash, the likelihood of those files being identical is extremely high. These
    files we will flag as potential duplicates.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于上面的每个匹配，为了确定这些文件是否真的匹配，我们将基于文件内容生成一个哈希。如果多个文件生成相同的哈希，那么这些文件是相同的可能性极高。我们将标记这些文件为潜在的重复文件。
- en: 'It''s a pretty simple algorithm and should be pretty effective, but we do have
    a problem, albeit one that''s likely not immediately apparent. If you have a large
    number of files, especially a set with a large number of potential duplicates,
    processing all of these files could be a very lengthy process, which we would
    like to mitigate as much as possible, which leads us to some non-functional requirements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的算法，应该非常有效，但我们确实有一个问题，尽管这个问题可能并不立即显现。如果你有大量文件，特别是一个潜在重复文件较多的集合，处理所有这些文件可能是一个非常耗时的过程，我们希望尽量减轻这种情况，这就引出了一些非功能性要求：
- en: The program should process files in a concurrent manner so as to minimize, as
    much as possible, the amount of time it takes to process a large file set
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序应以并发方式处理文件，以尽量减少处理大文件集所需的时间
- en: This concurrency should be bounded so that the system is not overwhelmed by
    processing the request
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性应该受到限制，以免系统被处理请求所压倒
- en: Given the potential for a large amount of data, the system must be designed
    in such a way so as to avoid using up all available RAM and causing system instability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到可能有大量数据，系统必须设计成避免使用所有可用的RAM并导致系统不稳定
- en: 'With that fairly modest list of functional and non-functional requirements,
    we should be ready to begin. Like the last application, let''s start by defining
    our module. In `src/main/java`, we will create this `module-info.java`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个相当简单的功能和非功能性要求清单，我们应该准备开始了。和上一个应用一样，让我们从定义我们的模块开始。在`src/main/java`中，我们将创建`module-info.java`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initially, the compiler--and the IDE--will complain that the `com.steeplesoft.dupefind.lib`
    package does not exist and won't compile the project. That's fine for now, as
    we'll be creating that package now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，编译器和IDE会抱怨`com.steeplesoft.dupefind.lib`包不存在，并且不会编译项目。现在没关系，因为我们将立即创建该包。
- en: The use of the word **concurrency** in the functional requirements, most likely,
    immediately brings to mind the idea of threads. We introduced the idea of threads
    in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml), *Managing
    Java Processes*, so if you are not familiar with them, review that section in
    the previous chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能要求中使用**并发**这个词，很可能会立即让人想到线程。我们在[第2章](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml)中介绍了线程的概念，所以如果你对它们不熟悉，请回顾一下上一章的内容。
- en: Our use of threading in this project is different from that in the last, in
    that we will have a body of work that needs to be done, and, once it's finished,
    we want the threads to exit. We also need to wait for these threads to finish
    their work so that we can analyze it. In the `java.util.concurrent` package, the
    JDK provides several options to accomplish this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个项目中使用的线程与上一个项目中的线程不同，因为我们有一些需要完成的工作，一旦完成，我们希望线程退出。我们还需要等待这些线程完成工作，以便我们可以分析它。在`java.util.concurrent`包中，JDK提供了几种选项来实现这一点。
- en: Concurrent Java with a Future interface
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Future接口的并发Java
- en: One of the more common and popular APIs is the `Future<V>` interface. `Future`
    is a means to encapsulate an asynchronous calculation. Typically, the `Future`
    instance is returned by `ExecutorService`, which we'll discuss later. The calling
    code, once it has the reference to `Future`, can continue to work on other tasks
    while `Future` runs in the background in another thread. When the caller is ready
    for the results of `Future`, it calls `Future.get()`. If `Future` has finished
    its work, the call returns immediately with the results. If, however, `Future`
    is still working, calls to `get()` will block until `Future` completes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更常见和受欢迎的API是`Future<V>`接口。`Future`是封装异步计算的一种方式。通常，`Future`实例是由`ExecutorService`返回的，我们稍后会讨论。一旦调用代码获得了对`Future`的引用，它就可以在`Future`在后台的另一个线程中运行时继续处理其他任务。当调用者准备好获取`Future`的结果时，它调用`Future.get()`。如果`Future`已经完成了它的工作，调用将立即返回结果。然而，如果`Future`仍在工作，对`get()`的调用将阻塞直到`Future`完成。
- en: For our uses, though, `Future` isn't the most appropriate choice. Looking over
    the non-functional requirements, we see the desire to avoid crashing the system
    by exhausting the available memory explicitly listed out. As we'll see later,
    the way this will be implemented is by storing the data in a lightweight on-disk
    database, and we will implement that--again, as we'll see later-by storing the
    file information as it is retrieved rather than by gathering the data, then saving
    it in a post-process method. Given that, our `Future` won't be returning anything.
    While there is a way to make that work (defining `Future` as `Future<?>` and returning
    `null`), it's not the most natural approach.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的用途，`Future`并不是最合适的选择。在审查非功能性需求时，我们看到了避免通过明确列出的可用内存耗尽来使系统崩溃的愿望。正如我们将在后面看到的那样，这将通过将数据存储在轻量级的磁盘数据库中来实现，我们将通过存储检索到的文件信息而不是通过收集数据，然后在后处理方法中保存它来实现。鉴于此，我们的`Future`将不会返回任何东西。虽然有一种方法可以使其工作（将`Future`定义为`Future<?>`并返回`null`），但这并不是最自然的方法。
- en: Perhaps the most appropriate approach is `ExecutorService`, which is `Executor`
    that provides additional functionality, such as the ability to create a `Future`,
    as discussed earlier, and manage termination of the queue. What, then, is `Executor`?
    `Executor` is a mechanism to execute `Runnable` that is more robust than simply
    calling `new Thread(runnable).start()`. The interface itself is very basic, consisting
    only of the `execute(Runnable)` method, so its value is not immediately apparent
    just from looking at the Javadoc. If, however, you look at `ExecutorService`,
    which is the interface that all `Executor` provided by the JDK implement, as well
    as the various `Executor` implementations, their value easily becomes more apparent.
    Let's take a quick survey now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最合适的方法是`ExecutorService`，它是提供额外功能的`Executor`，例如创建`Future`（如前所述）和管理队列的终止。那么，`Executor`是什么？`Executor`是一个执行`Runnable`的机制，比简单调用`new
    Thread(runnable).start()`更健壮。接口本身非常基本，只包括`execute(Runnable)`方法，因此从Javadoc中无法立即看出其价值。然而，如果您查看`ExecutorService`，它是JDK提供的所有`Executor`实现的接口，以及各种`Executor`实现，它们的价值很容易变得更加明显。现在让我们快速调查一下。
- en: 'Looking at the `Executors` class, we can see five different types of `Executor`
    implementations: a cached thread pool, a fixed-size thread pool, a scheduled thread
    pool, a single thread executor, and a work-stealing thread pool. With the single
    thread `Executor` being the only exception, each of these can be instantiated
    directly (`ThreadPoolExecutor`, `ScheduledThreadPoolExecutor`, and `ForkJoinPool`),
    but users are urged by the JDK authors to use the convenience methods on the `Executors`
    class. That said, what are each of these options and why might you choose one?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Executors`类，我们可以看到五种不同类型的`Executor`实现：缓存线程池、固定大小线程池、定时线程池、单线程执行器和工作窃取线程池。除了单线程`Executor`之外，每个都可以直接实例化（`ThreadPoolExecutor`、`ScheduledThreadPoolExecutor`和`ForkJoinPool`），但JDK的作者建议用户使用`Executors`类上的便利方法。也就是说，每个选项是什么，为什么选择其中之一？
- en: '`Executors.newCachedThreadPool()`: This returns `Executor` that provides a
    pool of cached threads. As tasks come in, `Executor` will attempt to find an unused
    thread to execute the task with. If one cannot be found, a new `Thread` is created
    and the work begins. When a task is complete, `Thread` is returned to the pool
    to await reuse. After approximately 60 seconds, unused threads are destroyed and
    removed from the pool, which prevents resources from being allocated and never
    released. Care must be taken with this `Executor`, though, as the thread pool
    is unbounded, which means that under heavy use, the system could be overwhelmed
    by active threads.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newCachedThreadPool()`: 这将返回一个提供缓存线程池的`Executor`。当任务到来时，`Executor`会尝试找到一个未使用的线程来执行任务。如果找不到，就会创建一个新的`Thread`并开始工作。任务完成后，`Thread`会返回到池中等待重用。大约60秒后，未使用的线程将被销毁并从池中移除，以防止资源被分配而永远不释放。但是，必须小心使用这个`Executor`，因为线程池是无限的，这意味着在大量使用时，系统可能会被活跃的线程压倒。'
- en: '`Executors.newFixedThreadPool(int nThreads)`: This method returns an `Executor`
    similar to the one previously mentioned, with the exception that the thread pool
    is bounded to at most `nThreads`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newFixedThreadPool(int nThreads)`: 这个方法返回一个类似于前面提到的`Executor`，唯一的区别是线程池被限制为最多`nThreads`。'
- en: '`Executors.newScheduledThreadPool(int corePoolSize)`: This `Executor` is able
    to schedule tasks to run after an optional initial delay and then periodically,
    based on the delay and `TimeUnit` value. See, for example, the `schedule(Runnable
    command, long delay, TimeUnit unit)` method.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newScheduledThreadPool(int corePoolSize)`: 这个`Executor`能够安排任务在可选的初始延迟后定期运行，基于延迟和`TimeUnit`值。例如，参见`schedule(Runnable
    command, long delay, TimeUnit unit)`方法。'
- en: '`Executors.newSingleThreadExecutor()`: This method will return an `Executor`
    that will use a single thread to execute the tasks submitted to it. Tasks are
    guaranteed to be executed in the order in which they were submitted.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newSingleThreadExecutor()`: 这个方法将返回一个`Executor`，它将使用单个线程来执行提交给它的任务。任务保证按照它们被提交的顺序执行。'
- en: '`Executors.newWorkStealingExecutor()`: This method will return a so-called
    **work stealing** `Executor`, which is of type `ForkJoinPool`. The tasks submitted
    to this `Executor` are written in such a way as to be able to divide up the work
    to additional worker threads until the size of the work is under a user-defined
    threshold.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newWorkStealingExecutor()`: 这个方法将返回一个所谓的**工作窃取**`Executor`，它是`ForkJoinPool`类型。提交给这个`Executor`的任务被编写成能够将工作分配给额外的工作线程，直到工作量低于用户定义的阈值。'
- en: Given our non-functional requirements, the fixed-size `ThreadPoolExecutor` seems
    to be the most appropriate. One configuration option we'll need to support, though,
    is the option to force the generation of hashes for every file found. Based on
    the preceding algorithm, only files that have duplicate names or sizes will be
    hashed. However, users may want a more thorough analysis of their file specification
    and would like to force a hash on every file. We'll implement this using the work-stealing
    (or fork/join) pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的非功能性需求，固定大小的`ThreadPoolExecutor`似乎是最合适的。然而，我们需要支持的一个配置选项是强制为找到的每个文件生成哈希值。根据前面的算法，只有具有重复名称或大小的文件才会被哈希。然而，用户可能希望对他们的文件规范进行更彻底的分析，并希望强制对每个文件进行哈希。我们将使用工作窃取（或分叉/加入）池来实现这一点。
- en: 'With our threading approach selected, let''s take a look at the entry point
    for the library, a class we''ll call `FileFinder`. Since this is our entry point,
    it will need to know where we want to search and what we want to search for. That
    will give us the instance variables, `sourcePaths` and `patterns`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们选择的线程方法，让我们来看看库的入口点，一个我们将称之为`FileFinder`的类。由于这是我们的入口点，它需要知道我们想要搜索的位置和我们想要搜索的内容。这将给我们实例变量`sourcePaths`和`patterns`：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We're declaring the variables as `private`, as that is a good object-oriented
    practice. We're also declaring them `final`, to help avoid subtle bugs where these
    variables are assigned new values, resulting in the unexpected loss of data. Generally
    speaking, I find it to be a good practice to mark variables as `final` by default
    to prevent such subtle bugs. In the case of instance variables in a class like
    this, a variable can only be declared `final` if it is either immediately assigned
    a value, as we are doing here, or if it is given a value in the class' constructors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量声明为`private`，因为这是一个良好的面向对象的实践。我们还将它们声明为`final`，以帮助避免这些变量被分配新值而导致意外数据丢失的微妙错误。一般来说，我发现将变量默认标记为`final`是一个很好的实践，可以防止这种微妙的错误。在这样一个类的实例变量的情况下，只有在它被立即赋值，就像我们在这里做的那样，或者如果它在类的构造函数中被赋值，它才能被声明为`final`。
- en: 'We also want to define our `ExecutorService` now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也想定义我们的`ExecutorService`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have somewhat arbitrarily chosen to limit our thread pool to five threads,
    as it seems to be a fair balance between providing a sufficient number of worker
    threads for heavy requests, while not allocating a large number of threads that
    may not be used in most cases. In our case, it is probably a minor issue overblown,
    but it's certainly something to keep in mind.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经相当随意地选择将我们的线程池限制为五个线程，因为这似乎是在为繁重的请求提供足够数量的工作线程的同时，不分配大量可能在大多数情况下不会使用的线程之间取得一个公平的平衡。在我们的情况下，这可能是一个被夸大的小问题，但这绝对是需要牢记的事情。
- en: 'Next, we need to provide a means to store any duplicates found. Consider the
    following lines of code as an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一种方法来存储找到的任何重复项。考虑以下代码行作为示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll see more details later, but, for now, all that we need to note is that
    this is a `Map` of `List<FileInfo>` objects, keyed by the file hash.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们会看到更多细节，但现在我们需要注意的是这是一个`Map`，其中包含由文件哈希键入的`List<FileInfo>`对象。
- en: The final variable to make note of is something that might be a bit unexpected--an
    `EntityManagerFactory`. You might be asking yourself, what is that? The `EntityManagerFactory`
    is an interface to interact with a persistence unit as defined by the **Java Persistence
    API** (**JPA**), which is part of the Java Enterprise Edition Specification. Fortunately,
    though, the specification was written in such a way to mandate that it be usable
    in a **Standard Edition** (**SE**) context like ours.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的变量是一些可能有点意外的东西——一个`EntityManagerFactory`。你可能会问自己，那是什么？`EntityManagerFactory`是一个与**Java持久化API**（**JPA**）定义的持久化单元进行交互的接口，它是Java企业版规范的一部分。幸运的是，规范是以这样一种方式编写的，以强制它在像我们这样的**标准版**（**SE**）上下文中可用。
- en: So, what are we doing with such an API? If you'll look back at the non-functional
    requirements, we've specified that we want to make sure that the search for duplicate
    files doesn't exhaust the available memory on the system. For very large searches,
    it is quite possible that the list of files and their hashes can grow to a problematic
    size. Couple that with the memory it will take to generate the hashes, which we'll
    discuss later, and we can very likely run into out-of-memory situations. We will,
    therefore, be using JPA to save our search information in a simple, light database
    (SQLite) that will allow us to save our data to the disk. It will also allow us
    to query and filter the results more efficiently than iterating over in-memory
    structures repeatedly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们使用这样的API做什么呢？如果你回顾一下非功能性需求，我们已经指定了我们要确保查找重复文件不会耗尽系统上可用的内存。对于非常大的搜索，文件列表及其哈希值可能会增长到一个有问题的大小。再加上生成哈希值所需的内存，我们稍后会讨论，很可能会遇到内存不足的情况。因此，我们将使用JPA将我们的搜索信息保存在一个简单的轻量级数据库（SQLite）中，这将允许我们将数据保存到磁盘。它还将允许我们比重复地在内存结构上进行迭代更有效地查询和过滤结果。
- en: 'Before we can make use of those APIs, we need to update our module descriptor
    to let the system know that we now require the persistence modules. Consider the
    following code snippet as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用这些API之前，我们需要更新我们的模块描述符，让系统知道我们现在需要持久化模块。考虑以下代码片段作为示例：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've declared to the system that we require both `javax.persistence` and `java.logging`,
    which we'll be using later. As we discussed in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, if any one of these modules are not present, the
    JVM instance will fail to start.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明系统需要`javax.persistence`和`java.logging`，我们稍后会使用它们。正如我们在[第2章](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml)中讨论的那样，*在Java中管理进程*，如果这些模块中的任何一个不存在，JVM实例将无法启动。
- en: Perhaps the more important part of the module definition is the `exports` clause.
    With this line (there can be 0 or more of them), we're telling the system that
    we are exporting all of the types in the specified package. This line will allow
    our CLI module, which we'll get into later, to use the classes (as well as interfaces,
    enums, and so on, if we were to add any) in that module. If a type's package does
    not `export`, consuming modules will be unable to see the type, which we'll also
    demonstrate later.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义中可能更重要的部分是`exports`子句。通过这一行（可以有0个或多个），我们告诉系统我们正在导出指定包中的所有类型。此行将允许我们的CLI模块（稍后我们将介绍）使用该模块中的类（以及接口、枚举等，如果我们要添加的话）。如果类型的包没有`export`，消费模块将无法看到该类型，稍后我们也将演示。
- en: 'With that understanding, let''s take a look at our constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，让我们来看一下我们的构造函数：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To configure the persistence unit, JPA typically uses a `persistence.xml` file.
    In our case, though, we'd like a bit more control over where the database file
    is stored. As you can see in the preceding code, we are constructing the JDBC
    URL using the `user.home` environment variable. We then store that in a `Map`
    using the JPA-defined key to specify the URL. This `Map` is then passed to the
    `createEntityManagerFactory` method, which overrides anything set in `persistence.xml`.
    This allows us to put the database in the home directory appropriate for the user's
    operating system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置持久性单元，JPA通常使用`persistence.xml`文件。但在我们的情况下，我们希望更多地控制数据库文件的存储位置。正如您在前面的代码中所看到的，我们正在使用`user.home`环境变量构建JDBC
    URL。然后我们将其存储在`Map`中，使用JPA定义的键来指定URL。然后将此`Map`传递给`createEntityManagerFactory`方法，该方法覆盖了`persistence.xml`中设置的任何内容。这允许我们将数据库放在适合用户操作系统的主目录中。
- en: 'With our class constructed and configured, it''s time to take a look at how
    we''ll find duplicate files:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构造和配置好我们的类后，现在是时候看看我们将如何找到重复的文件了：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our first step is to create a list of the `PathMatcher` instances based on the
    patterns specified by the user. A `PathMatcher` instance is a functional interface
    that is implemented by objects that attempt to match files and paths. Our instances
    are retrieved from the `FileSystems` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是根据用户指定的模式创建`PathMatcher`实例的列表。`PathMatcher`实例是一个功能接口，由试图匹配文件和路径的对象实现。我们的实例是从`FileSystems`类中检索的。
- en: When requesting `PathMatcher`, we have to specify the globbing pattern. As can
    be seen in the first call to `map()`, we have to make an adjustment to what the
    user specified. Typically, a pattern mask is specified simply as something like
    `*.jpg`. However, a pattern mask like this won't work in a way that the user expects,
    in that it will only look in the current directory and not walk down into any
    subdirectories. To do that, the pattern must be prefixed with `**/`, which we
    do in the call to `map()`. With our adjusted pattern, we request the `PathMatcher`
    instance from the system's default `FileSystem`. Note that we specify the matcher
    pattern as `"glob:" + p` because we need to indicate that we are, indeed, specifying
    a `glob` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求`PathMatcher`时，我们必须指定globbing模式。正如在第一个调用`map()`中所看到的，我们必须对用户指定的内容进行调整。通常，模式掩码被简单地指定为`*.jpg`之类的东西。然而，这样的模式掩码不会按照用户的期望工作，因为它只会在当前目录中查找，而不会遍历任何子目录。为了做到这一点，模式必须以`**/`为前缀，我们在调用`map()`时这样做。有了我们调整后的模式，我们从系统的默认`FileSystem`中请求`PathMatcher`实例。请注意，我们将匹配模式指定为`"glob:"
    + p`，因为我们需要指示我们确实正在指定`glob`文件。
- en: 'With our matchers prepared, we''re ready to start the search. We do that with
    this code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好我们的匹配器后，我们准备开始搜索。我们用这段代码来做到这一点：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `Stream` API, we map each source path to a lambda that creates an
    instance of `FindFileTask`, providing it the source path it will search. Each
    of these `FileFindTask` instances will then be passed to our `ExecutorService`
    via the `execute()` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream` API，我们将每个源路径映射到一个lambda，该lambda创建`FindFileTask`的实例，为其提供它将搜索的源路径。然后，这些`FileFindTask`实例将通过`execute()`方法传递给我们的`ExecutorService`。
- en: 'The `FileFindTask` method is the workhorse for this part of the process. It
    is a `Runnable` as we''ll be submitting this to the `ExecutorService`, but it
    is also a `FileVisitor<Path>` as it will be used in walking the file tree, which
    we do from the `run()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileFindTask`方法是该过程的工作马。它是一个`Runnable`，因为我们将把它提交给`ExecutorService`，但它也是一个`FileVisitor<Path>`，因为它将用于遍历文件树，我们将从`run()`方法中执行：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we will be inserting data into the database via JPA, we'll need to start
    a transaction as our first step. Since this is an application-managed `EntityManager`,
    we have to manage the transaction manually. We acquire a reference to the `EntityTransaction`
    instance outside the `try/catch` block to simplify referencing it. Inside the
    `try` block, we start the transaction, start the file walking via `Files.walkFileTree()`,
    then commit the transaction if the process succeeds. If it fails--if an `Exception`
    was thrown--we roll back the transaction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过JPA向数据库插入数据，我们需要将事务作为第一步启动。由于这是一个应用程序管理的`EntityManager`，我们必须手动管理事务。我们在`try/catch`块外获取对`EntityTransaction`实例的引用，以简化引用。在`try`块内，我们启动事务，通过`Files.walkFileTree()`开始文件遍历，然后如果进程成功，提交事务。如果失败-如果抛出了`Exception`-我们回滚事务。
- en: 'The `FileVisitor` API requires a number of methods, most of which are not too
    terribly interesting, but we''ll show them for clarity''s sake:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileVisitor` API需要许多方法，其中大多数都不是太有趣，但出于清晰起见，我们将它们显示出来：'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we tell the system that if the directory is readable, then we continue
    with walking down that directory. Otherwise, we skip it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉系统，如果目录是可读的，那么我们就继续遍历该目录。否则，我们跳过它：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The API requires this method to be implemented, but we''re not very interested
    in file read failures, so we simply return a skip result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: API要求实现此方法，但我们对文件读取失败不太感兴趣，因此我们只是返回一个跳过的结果：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Much like the preceding method, this method is required, but we''re not interested
    in this particular event, so we signal the system to continue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的方法类似，这个方法是必需的，但我们对这个特定事件不感兴趣，所以我们通知系统继续：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we''ve come to a method we''re interested in. We will check to make sure
    that the file is readable, then check to see if it''s a match. If it is, we add
    the file. Regardless, we continue walking the tree. How do we test if the file''s
    a match? Consider the following code snippet as an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了一个我们感兴趣的方法。我们将检查文件是否可读，然后检查是否匹配。如果是，我们就添加文件。无论如何，我们都会继续遍历树。我们如何测试文件是否匹配？考虑以下代码片段作为示例：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We iterate over the list of `PathMatcher` instances we passed in to the class
    earlier. If the `List` is empty, which means the user didn't specify any patterns,
    the method's result will always be `true`. However, if there are items in the
    `List`, we use the `anyMatch()` method on the `List`, passing a lambda that checks
    the `Path` against the `PathMatcher` instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历我们之前传递给类的`PathMatcher`实例的列表。如果`List`为空，这意味着用户没有指定任何模式，方法的结果将始终为`true`。但是，如果`List`中有项目，我们就在`List`上使用`anyMatch()`方法，传递一个检查`Path`与`PathMatcher`实例匹配的lambda。
- en: 'Adding the file is very straightforward:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文件非常简单：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a `FileInfo` instance, set the properties, then persist it to the
    database via `em.persist()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`FileInfo`实例，设置属性，然后通过`em.persist()`将其持久化到数据库中。
- en: 'With our tasks defined and submitted to `ExecutorService`, we need to sit back
    and wait. We do that with the following two method calls:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 定义并提交给`ExecutorService`的任务后，我们需要坐下来等待。我们通过以下两个方法调用来做到这一点：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first step is to ask `ExecutorService` to shut down. The `shutdown()` method
    will return immediately, but it will instruct `ExecutorService` to refuse any
    new tasks, as well as shut down its threads as soon as they are idle. Without
    this step, the threads will continue to run indefinitely. Next, we will wait for
    the service to shut down. We specify the maximum wait time to make sure we give
    our tasks time to complete. Once this method returns, we''re ready to process
    the results, which is done in the following `postProcessFiles()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是要求`ExecutorService`关闭。`shutdown()`方法会立即返回，但它会指示`ExecutorService`拒绝任何新任务，并在空闲时关闭其线程。如果没有这一步，线程将会无限期地继续运行。接下来，我们将等待服务关闭。我们指定最大等待时间，以确保我们给予任务完成的时间。一旦这个方法返回，我们就准备好处理结果了，这是在接下来的`postProcessFiles()`方法中完成的：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Modern database access with JPA
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPA进行现代数据库访问
- en: Let's stop here for a moment. Remember our discussion of the **Java Persistence
    API** (**JPA**) and database? Here is where we see that coming in. With the JPA,
    interactions with the database are done via the `EntityManager` interface, which
    we retrieve from the cleverly named `EntityManagerFactory`. It is important to
    note that the `EntityManager` instances are not thread-safe, so they should not
    be shared between threads. That's why we didn't create one in the constructor
    and pass it around. This is, of course, a local variable, so we need not worry
    about that too much until, and if, we decide to pass it as a parameter to another
    method, which we are doing here. As we will see in a moment, everything happens
    in the same thread, so we will not have to worry about thread-safety issues as
    the code stands now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停顿一下。还记得我们对**Java Persistence API**（**JPA**）和数据库的讨论吗？这就是我们看到它的地方。通过JPA，与数据库的交互是通过`EntityManager`接口完成的，我们从名为`EntityManagerFactory`的接口中检索到它。重要的是要注意，`EntityManager`实例不是线程安全的，因此它们不应该在线程之间共享。这就是为什么我们没有在构造函数中创建一个并传递它的原因。当然，这是一个局部变量，所以在这一点上我们不需要太担心，直到我们决定将它作为参数传递给另一个方法时。正如我们将在一会儿看到的，一切都发生在同一个线程中，所以在目前的代码中我们不必担心线程安全问题。
- en: 'With our `EntityManager`, we call the `getDuplicates()` method and pass the
    manager and field name, `fileName`. This is what that method looks like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的`EntityManager`，我们调用`getDuplicates()`方法并传递管理器和字段名`fileName`。这就是那个方法的样子：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a fairly straightforward use of the Java Persistence API--we're creating
    a query and telling it that we want, and getting a `List` of `FileInfo` references
    back. The `createQuery()` method creates a `TypedQuery` object, on which we will
    call `getResultList()` to retrieve the results, which gives us `List<FileInfo>`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Java Persistence API的相当简单的使用--我们正在创建一个查询，并告诉它我们想要，并获得一个`List`的`FileInfo`引用。`createQuery()`方法创建一个`TypedQuery`对象，我们将调用`getResultList()`来检索结果，这给我们`List<FileInfo>`。
- en: Before we go any further, we need to have a short primer on the Java Persistence
    API. JPA is what is known as an **object-relational mapping** (**ORM**) tool.
    It provides an object-oriented, type-safe, and database-independent way of storing
    data in, typically, a relational database. The specification/library allows application
    authors to define their data models using concrete Java classes, then persist
    and/or read them with little thought about the mechanics specific to the database
    currently being used. (The developer isn't completely shielded from database concerns--and
    it's arguable as to whether or not he or she should be--but those concerns are
    greatly lessened as they are abstracted away behind the JPA interfaces). The process
    of acquiring a connection, creating the SQL, issuing it to the server, processing
    results, and more are all handled by the library, allowing a greater focus on
    the business of the application rather than the plumbing. It also allows a high
    degree of portability between databases, so applications (or libraries) can be
    easily moved from one system to another with minimal change (usually restricted
    to configuration changes).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，我们需要对Java持久化API进行简要介绍。JPA是一种被称为**对象关系映射**（**ORM**）工具的东西。它提供了一种面向对象、类型安全和与数据库无关的方式来存储数据，通常是在关系数据库中。该规范/库允许应用程序作者使用具体的Java类来定义他们的数据模型，然后以很少考虑当前使用的数据库的具体机制来持久化和/或读取它们。（开发人员并没有完全屏蔽数据库问题——是否应该这样做还有争议——但这些问题被抽象到JPA接口的后面，大大减少了这些问题）。获取连接、创建SQL、将其发送到服务器、处理结果等过程都由库处理，使得更多的精力集中在应用程序的业务上，而不是在底层实现上。它还允许在数据库之间具有很高的可移植性，因此应用程序（或库）可以很容易地在不同系统之间进行最小的更改（通常限于配置更改）。
- en: At the heart of JPA is `Entity`, the business object (or domain model, if you
    prefer) that models the data for the application. This is expressed in the Java
    code as a **plain old Java object** (**POJO**), which is marked up with a variety
    of annotations. A complete discussion of all of those annotations (or the API
    as a whole) is outside the scope of this book, but we'll use enough of them to
    get you started.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JPA的核心是`Entity`，即应用程序的业务对象（或领域模型，如果您愿意），它对应用程序的数据进行建模。这在Java代码中表示为**普通的Java对象**（**POJO**），并用各种注释进行标记。对所有这些注释（或整个API）的完整讨论超出了本书的范围，但我们将使用足够多的注释来让您入门。
- en: 'With that basic explanation given, let''s take a look at our one and only entity--the
    `FileInfo` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本的解释，让我们来看看我们唯一的实体——`FileInfo`类：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class has five properties. The only one that needs special attention is
    `id`. This property holds the primary key value for each row, so we annotate it
    with `@Id`. We also annotate this field with `@GeneratedValue` to indicate that
    we have a simple primary key for which we''d like the system to generate a value.
    This annotation has two properties: `strategy` and `generator`. The default value
    for strategy is `GenerationType.AUTO`, which we happily accept here. Other options
    include `IDENTITY`, `SEQUENCE`, and `TABLE`. In more complex uses, you may want
    to specify a strategy explicitly, which allows you to fine-tune how the key is
    generated (for example, the starting number, the allocation size, the name of
    the sequence or table, and so on). By choosing `AUTO`, we''re telling JPA to choose
    the appropriate generation strategy for our target database. If you specify a
    strategy other than `AUTO`, you will also need to specify the details for the
    generator, using `@SequenceGenerator` for `SEQUENCE` and `@TableGenerator` for
    `TABLE`. You will also need to give the ID of the generator to the `@GeneratedValue`
    annotation using the generator attribute. We''re using the default, so we need
    not specify a value for this attribute.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有五个属性。唯一需要特别关注的是`id`。这个属性保存每一行的主键值，因此我们用`@Id`对其进行注释。我们还用`@GeneratedValue`对这个字段进行注释，以指示我们有一个简单的主键，我们希望系统生成一个值。这个注释有两个属性：`strategy`和`generator`。策略的默认值是`GenerationType.AUTO`，我们在这里很高兴地接受。其他选项包括`IDENTITY`、`SEQUENCE`和`TABLE`。在更复杂的用法中，您可能希望显式地指定一个策略，这允许您对生成键的方式进行微调（例如，起始数字、分配大小、序列或表的名称等）。通过选择`AUTO`，我们告诉JPA选择适当的生成策略来适应我们的目标数据库。如果您指定的策略不是`AUTO`，您还需要使用`@SequenceGenerator`来为`SEQUENCE`指定细节，使用`@TableGenerator`来为`TABLE`指定细节。您还需要使用生成器属性将生成器的ID传递给`@GeneratedValue`注释。我们使用默认值，因此不需要为此属性指定值。
- en: The next four fields are the pieces of data we have identified that we need
    to capture. Note that if we do not need to specify anything special about the
    mapping of these fields to the database columns, no annotations are necessary.
    However, if we would like to change the defaults, we can apply the `@Column` annotation
    and set the appropriate attribute, which can be one or more of `columnDefinition`
    (used to help generate the DDL for the column), `insertable`, `length`, `name`,
    `nullable`, `precision`, `scale`, `table`, `unique`, and `updatable`. Again, we're
    happy with the defaults.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个字段是我们确定需要捕获的数据。请注意，如果我们不需要指定这些字段与数据库列的映射的任何特殊内容，那么不需要注释。但是，如果我们想要更改默认值，我们可以应用`@Column`注释并设置适当的属性，可以是`columnDefinition`（用于帮助生成列的DDL）、`insertable`、`length`、`name`、`nullable`、`precision`、`scale`、`table`、`unique`和`updatable`中的一个或多个。同样，我们对默认值感到满意。
- en: JPA also requires each property to have a getter and a setter; the specification
    seems to be worded oddly, which has led to some ambiguity as to whether or not
    this is a hard requirement, and different JPA implementations handle this differently,
    but it's certainly safer to provide both as a matter of practice. If you need
    a read-only property, you can experiment with either no setter, or simply a no-op
    method. We haven't shown the getters and setters here, as there is nothing interesting
    about them. We have also omitted the IDE-generated `equals()` and `hashCode()`
    methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JPA还要求每个属性都有一个getter和一个setter；规范似乎措辞奇怪，这导致了一些模棱两可，不确定是否这是一个硬性要求，不同的JPA实现处理方式也不同，但作为一种实践，提供两者肯定更安全。如果你需要一个只读属性，你可以尝试使用没有setter的方法，或者简单地使用一个空操作方法。我们没有在这里展示getter和setter，因为它们没有什么有趣的地方。我们还省略了IDE生成的`equals()`和`hashCode()`方法。
- en: 'To help demonstrate the module system, we''ve put our entity in a `com.steeplesoft.dupefind.lib.model`
    subpackage. We''ll tip our hand a bit and go ahead and announce that this class
    will be used by both our CLI and GUI modules, so we''ll need to update our module
    definition as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助演示模块系统，我们将我们的实体放在`com.steeplesoft.dupefind.lib.model`子包中。我们会透露一点底牌，提前宣布这个类将被我们的CLI和GUI模块使用，所以我们需要更新我们的模块定义如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s all there is to our entity, so let''s turn our attention back to our
    application logic. The `createQuery()` call deserves a bit of discussion. Typically,
    when using JPA, queries are written in what is called **JPAQL** (**Java Persistence
    API Query Language**). It looks very much like SQL, but has a more object-oriented
    feel to it. For example, if we wanted to query for every `FileInfo` record in
    the database, we would do so with this query:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的实体，现在让我们把注意力转回到我们的应用逻辑上。`createQuery()`调用值得讨论一下。通常情况下，使用JPA时，查询是用所谓的**JPAQL**（**Java持久化API查询语言**）编写的。它看起来很像SQL，但更具面向对象的感觉。例如，如果我们想查询数据库中的每个`FileInfo`记录，我们可以使用以下查询：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I have put the keywords in all caps, with variable names in lower and the entity
    name in camel case. This is mostly a matter of style, but while most identifiers
    are case-insensitive, JPA does require that the case on the entity name matches
    that of the Java class it represents. You must also specify an alias, or identification
    variable, for the entity, which we simply call `f`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将关键字都大写了，变量名都小写了，实体名都是驼峰式写法。这主要是一种风格问题，但大多数标识符是不区分大小写的，JPA确实要求实体名的大小写与它所代表的Java类的大小写匹配。你还必须为实体指定一个别名或标识变量，我们简单地称之为`f`。
- en: 'To get a specific `FileInfo` record, you can specify a `WHERE` clause as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定的`FileInfo`记录，可以指定一个`WHERE`子句，如下所示：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this query, we can filter the query just as SQL does, and, just like SQL,
    we specify a positional parameter. The parameter can either be a name, like we''ve
    done here, or simply a `?`. If you use a name, you set the parameter value on
    the query using that name. If you use the question mark, you must set the parameter
    using its index in the query. For small queries, this is usually fine, but for
    larger, more complex queries, I would suggest using names so that you don''t have
    to manage index values, as that''s almost guaranteed to cause a bug at some point.
    Setting the parameter can look something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个查询，我们可以像SQL一样过滤查询，并且，就像SQL一样，我们指定了一个位置参数。参数可以是一个名称，就像我们在这里做的一样，或者简单地是一个`?`。如果你使用一个名称，你可以使用该名称在查询中设置参数值。如果你使用问号，你必须使用其在查询中的索引设置参数。对于小型查询，这通常是可以的，但对于更大、更复杂的查询，我建议使用名称，这样你就不必管理索引值，因为这几乎肯定会在某个时候导致错误。设置参数可能看起来像这样：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With that said, let''s take a look at our query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，让我们来看看我们的查询：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This query is moderately complicated, so let's break it down and see what's
    going on. First, in our `SELECT` query, we will specify only `f`, which is the
    identification variable of the entity for which we are querying. Next, we are
    selecting from a regular table and a temporary table, which is defined by the
    subselect in the `FROM` clause. Why are we doing it this way? We need to identify
    all of the rows that have a duplicate value (`fileName`, `size`, or `hash`). To
    do that, we use a `HAVING` clause with the `COUNT` aggregation function, `HAVING
    (COUNT(fieldName > 1))` which says, in effect, give me all of the rows where this
    field occurs more than one time. The `HAVING` clause requires a `GROUP BY` clause,
    and once that's done, all of the rows with duplicate values are aggregated down
    to a single row. Once we have that list of rows, we will then join the real (or
    physical) table to those results to filter our physical table. Finally, we filter
    out the null fields in the `WHERE` clause, then order by `fileName` and `path`
    so that we don't have to do that in our Java code, which is likely to be less
    efficient than it would be if done by the database--a system designed for such
    operations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询有一定的复杂性，让我们来分解一下看看发生了什么。首先，在我们的`SELECT`查询中，我们只会指定`f`，这是我们要查询的实体的标识变量。接下来，我们从一个常规表和一个临时表中进行选择，这由`FROM`子句中的子选择定义。为什么我们要这样做呢？我们需要识别所有具有重复值（`fileName`、`size`或`hash`）的行。为了做到这一点，我们使用了一个带有`COUNT`聚合函数的`HAVING`子句，`HAVING
    (COUNT(fieldName > 1))`，这实际上是说，给我所有这个字段出现超过一次的行。`HAVING`子句需要一个`GROUP BY`子句，一旦完成，所有具有重复值的行都会被聚合成一行。一旦我们有了那些行的列表，我们将把真实（或物理）表与这些结果连接起来，以过滤我们的物理表。最后，在`WHERE`子句中过滤掉空字段，然后按`fileName`和`path`排序，这样我们就不必在我们的Java代码中这样做了，这可能比在数据库中进行的效率要低--数据库是为这样的操作而设计的系统。
- en: You should also note the `%FIELD%` attribute in the SQL. We'll run the same
    query for multiple fields, so we've written the query once, and placed a marker
    in the text that we will replace with the desired field, which is sort of a *poor
    man's* template. There are, of course, a variety of ways to do this (and you may
    have one you find superior), but this is simple and easy to use, so it's perfectly
    acceptable in this environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意SQL中的`%FIELD%`属性。我们将为多个字段运行相同的查询，因此我们只编写了一次查询，并在文本中放置了一个我们将用所需字段替换的标记，这有点像*穷人的*模板。当然，有各种各样的方法可以做到这一点（你可能有更好的方法），但这种方法简单易用，所以在这种环境中是完全可以接受的。
- en: We should also note that it is, generally speaking, a very bad idea to either
    concatenate SQL with values or do string replacements like we're doing, but our
    scenario is a bit different. If we were accepting user input and inserting that
    into the SQL this way, then we would certainly have a target for an SQL injection
    attack. In our use here, though, we aren't taking input from users, so this approach
    should be perfectly safe. In terms of database performance, this shouldn't have
    any adverse effects either. While we will require three different hard parses
    (one for each field by which we will filter), this is no different than if we
    were hardcoding the queries in our source file. Both of those issues, as well
    as many more, are always good to consider as you write your queries (and why I
    said the developer is mostly shielded from database concerns).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，一般来说，要么将SQL与值连接起来，要么像我们现在这样做字符串替换，都是一个非常糟糕的主意，但我们的情况有点不同。如果我们接受用户输入并以这种方式将其插入SQL，那么我们肯定会成为SQL注入攻击的目标。然而，在我们这里的用法中，我们并没有从用户那里获取输入，所以这种方法应该是完全安全的。在数据库性能方面，这也不应该有任何不利影响。虽然我们将需要三个不同的硬解析（每个字段一个），但这与我们在源文件中硬编码查询没有什么不同。这些问题以及许多其他问题在编写查询时总是值得考虑的（这也是我说开发人员在很大程度上不用担心数据库问题的原因）。
- en: 'All of that gets us through the first step, which is identifying all of the
    files that have the same name. We now need to identify the files that have the
    same size, which can be done using the following piece of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都让我们完成了第一步，即识别所有具有相同名称的文件。现在我们需要识别具有相同大小的文件，可以使用以下代码来完成：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our call to find duplicate filenames, we declared a local variable, `files`,
    to store those results. In finding files with duplicate sizes, we call the same
    `getDuplicates()` method, but with the correct field name, and simply add that
    to `files` via the `List.addAll()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用查找重复文件名的方法时，我们声明了一个局部变量`files`来存储这些结果。在查找具有重复大小的文件时，我们调用相同的`getDuplicates()`方法，但使用正确的字段名称，并通过`List.addAll()`方法简单地将其添加到`files`中。
- en: 'We now have a complete list of all of the possible duplicates, so we need to
    generate the hashes for each of these to see if they are truly duplicates. We
    will do that with this loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了所有可能的重复文件的完整列表，所以我们需要为每个文件生成哈希值，以查看它们是否真的是重复的。我们将使用以下循环来完成这个任务：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a nutshell, we start a transaction (since we'll be inserting data into the
    database), then loop over each possible duplicate via `List.forEach()` and a lambda
    that calls `calculateHash(f)`, and then pass the `FileInfo` instance. Once the
    loop terminates, we commit the transaction to save our changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们开始一个事务（因为我们将向数据库插入数据），然后通过`List.forEach()`和一个调用`calculateHash(f)`的lambda循环遍历每个可能的重复文件，然后传递`FileInfo`实例。一旦循环终止，我们就提交事务以保存我们的更改。
- en: 'What does `calculateHash()` do? Let''s a take a look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateHash()`方法是做什么的？让我们来看一下：'
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simple method encapsulates the work required to read the contents of a
    file and generate a hash. It requests an instance of `MessageDigest` using the
    `SHA3-256` hash, which is one of the four new hashes supported by Java 9 (the
    other three being `SHA3-224`, `SHA3-384`, and `SHA3-512`). Many developers' first
    thought is to reach for MD-5 or SHA-1, but those are no longer considered reliable.
    Using the new SHA-3 should guarantee we avoid any false positives.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法封装了读取文件内容和生成哈希所需的工作。它使用`SHA3-256`哈希请求`MessageDigest`的一个实例，这是Java 9支持的四种新哈希算法之一（另外三种是`SHA3-224`、`SHA3-384`和`SHA3-512`）。许多开发人员的第一个想法是使用MD-5或SHA-1，但这些已不再被认为是可靠的。使用新的SHA-3应该保证我们避免任何错误的结果。
- en: The rest of the method is pretty interesting in terms of how it does its work.
    First, it reads all of the bytes of the specified file and passes them to `MessageDigest.update()`,
    which updates the internal state of the `MessageDigest` object to give us the
    hash we want. Next, we create a `ByteArrayInputStream` that wraps the results
    of `messageDigest.digest()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的其余部分在其工作方式方面非常有趣。首先，它读取指定文件的所有字节，并将它们传递给`MessageDigest.update()`，这将更新`MessageDigest`对象的内部状态，以给我们想要的哈希值。接下来，我们创建一个包装`messageDigest.digest()`结果的`ByteArrayInputStream`。
- en: With our hash ready, we generate a string based on those bytes. We will do that
    by generating a stream via the `IntStream.generate()` method using the `InputStream`
    we just created as a source. We will limit the stream generation to the bytes
    available in the `inputStream`. For each byte, we will convert it to a string
    via `Integer.toHexString()`; then pad it with zero to two spaces, which prevents,
    for example, the single-digit hex characters `E` and `F` from being interpreted
    as `EF`; then collect them all into a string using `Collections.joining()`. Finally,
    we take that string value and update the `FileInfo` object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的哈希值准备好了，我们将基于这些字节生成一个字符串。我们将通过使用`IntStream.generate()`方法生成一个流，使用我们刚刚创建的`InputStream`作为源。我们将限制流生成到`inputStream`中可用的字节。对于每个字节，我们将通过`Integer.toHexString()`将其转换为字符串；然后用零填充到两个空格，这样可以防止例如单个十六进制字符`E`和`F`被解释为`EF`；然后使用`Collections.joining()`将它们全部收集到一个字符串中。最后，我们将该字符串值更新到`FileInfo`对象中。
- en: 'The eagle-eyed might notice something interesting: we call `FileInfo.setHash()`
    to change the value of the object, but we never tell the system to persist those
    changes. This is because our `FileInfo` instance is a managed instance, meaning
    that we got it from JPA, which is keeping an eye on it, so to speak. Since we
    retrieved it via JPA, when we make any changes to its state, JPA knows it needs
    to persist those changes. When we call `em.getTransaction().commit()` in the calling
    method, JPA automatically saves those changes to the database.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的人可能会注意到一些有趣的事情：我们调用`FileInfo.setHash()`来更改对象的值，但我们从未告诉系统要持久化这些更改。这是因为我们的`FileInfo`实例是一个受管理的实例，这意味着我们从JPA那里得到了它，JPA在关注它，可以这么说。由于我们通过JPA检索了它，当我们对其状态进行任何更改时，JPA知道需要持久化这些更改。当我们在调用方法中调用`em.getTransaction().commit()`时，JPA会自动将这些更改保存到数据库中。
- en: 'There''s a catch to this automatic persistence: if you retrieve an object via
    JPA, then pass it across some sort of barrier that serializes the object, for
    example, across a remote EJB interface, then the JPA entity is said to be "detached".
    To reattach it to the persistence context, you will need to call `entityManager.
    merge()`, after which this behavior will resume. There is no need to call `entityManager.flush()`
    unless you have some need to synchronize the in-memory state of the persistence
    context with the underlying database.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动持久化有一个陷阱：如果您通过JPA检索对象，然后将其传递到某种序列化对象的障碍之后，例如通过远程EJB接口，那么JPA实体就被称为“分离”。要重新将其附加到持久性上下文中，您需要调用`entityManager.merge()`，之后这种行为将恢复。除非您有必要将持久性上下文的内存状态与底层数据库同步，否则无需调用`entityManager.flush()`。
- en: 'Once we''ve calculated the hashes for the potential duplicates (at this point,
    given that they have duplicate SHA-3 hashes, they are almost certainly actual
    duplicates), we''re ready to gather and report them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算出潜在重复文件的哈希值（在这一点上，鉴于它们具有重复的SHA-3哈希值，它们几乎肯定是实际的重复文件），我们就可以准备收集并报告它们：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We call the same `getDuplicates()` method to find duplicate hashes, and pass
    each record to the `coalesceDuplicates()` method, which will group these in a
    manner appropriate to report upstream to our CLI or GUI layers, or, perhaps, to
    any other program consuming this functionality:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用相同的`getDuplicates()`方法来查找重复的哈希值，并将每个记录传递给`coalesceDuplicates()`方法，该方法将以适合向上报告到我们的CLI或GUI层的方式对其进行分组，或者，也许是向任何其他使用此功能的程序：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This simple method follows what is likely a very familiar pattern:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法遵循了一个可能非常熟悉的模式：
- en: Get a `List` from a `Map` based on the key, the filename.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基于键的`Map`中获取`List`，文件名。
- en: If the map doesn't exist, create it and add it to the map.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果地图不存在，则创建它并将其添加到地图中。
- en: Add the `FileInfo` object to the list.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FileInfo`对象添加到列表中。
- en: This completes the duplicate file detection. Back in `find()`, we will call
    `factory.close()` to be a good JPA citizen, then return to the calling code. With
    that, we're ready to build our CLI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了重复文件检测。回到`find()`，我们将调用`factory.close()`来成为一个良好的JPA公民，然后返回到调用代码。有了这个，我们就可以构建我们的CLI了。
- en: Building the command-line interface
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令行界面
- en: 'The primary means to interact with our new library will be the command-line
    interface we will now develop. Unfortunately, the Java SDK has nothing built in
    to help make sophisticated command-line utilities. If you''ve been using Java
    for any time, you''ve seen the following method signature:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的新库进行交互的主要方式将是我们现在要开发的命令行界面。不幸的是，Java SDK没有内置的功能来帮助创建复杂的命令行实用程序。如果您已经使用Java一段时间，您可能已经看到以下方法签名：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clearly, there is *a* mechanism to process command-line arguments. The `public
    static void main` method is passed string arrays that represent arguments provided
    by the user on the command line, but that''s about as far as it goes. To parse
    the options, the developer is required to iterate over the array, analyzing each
    entry. It might look something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有一种机制来处理命令行参数。`public static void main`方法会传递表示用户在命令行上提供的参数的字符串数组，但这就是它的全部了。为了解析选项，开发人员需要迭代数组，分析每个条目。可能看起来像这样：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is an effective solution, if very naive and error-prone. It assumes that
    whatever follows `--source` and `--target` is that argument's value. If the user
    types `--source --target /foo`, then our processor breaks. Clearly, something
    better is needed. Fortunately, we have options.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的解决方案，但非常天真和容易出错。它假设跟在`--source`和`--target`后面的是该参数的值。如果用户输入`--source --target
    /foo`，那么我们的处理器就会出错。显然，需要更好的解决方案。幸运的是，我们有选择。
- en: 'If you were to search for Java command-line libraries, you''ll find an abundance
    of them (at least 10 at last count). Our space (and time) is limited here, so
    we obviously can''t discuss all of them, so I''ll mention the first three that
    I''m familiar with: Apache Commons CLI, Airline, and Crest. Each of these has
    some fairly significant differences from its competitors.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您搜索Java命令行库，您会发现有大量的库（至少在最后一次统计时有10个）。我们在这里的空间（和时间）有限，所以显然无法讨论所有这些库，所以我将提到我熟悉的前三个：Apache
    Commons CLI，Airline和Crest。这些库中的每一个都与其竞争对手有一些相当重要的区别。
- en: 'Commons CLI takes a more procedural approach; the list of available options,
    its name, description, whether or not it has arguments, and so forth, are all
    defined using Java method calls. Once the list of `Options` has been created,
    the command-line arguments are then manually parsed. The preceding example could
    be rewritten as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Commons CLI采用更加程序化的方法；可用选项的列表、名称、描述、是否有参数等都是使用Java方法调用来定义的。创建了`Options`列表后，命令行参数就会被手动解析。前面的示例可以重写如下：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's certainly more verbose, but it's also clearly, I think, more robust. We
    can specify long and short names for the option (`--source` versus `-s`), we can
    give it a description, and, best of all, we get built-in validation that an option
    has its required value. As much of an improvement as this is, I've learned from
    experience that the procedural approach here gets tedious in practice. Let's take
    a look at our next candidate to see how it fares.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然更加详细，但我认为它也更加健壮。我们可以为选项指定长名称和短名称（`--source`与`-s`），我们可以给它一个描述，并且最重要的是，我们获得了内置验证，以确保选项具有其所需的值。尽管这是一个改进，但我从经验中学到，这里的程序化方法在实践中变得乏味。让我们看看我们的下一个候选者如何表现。
- en: 'Airline is a command-line library originally written as part of the airlift
    organization on GitHub. After languishing for some time, it was forked by Rob
    Vesse and given a new life ([http://rvesse.github.io/airline](http://rvesse.github.io/airline)).
    Airline''s approach to command-line definition is more class-based--to define
    a command utility, you declare a new class, and mark it up appropriately with
    a number of annotations. Let''s implement our preceding simple command line with
    Airline:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 航空公司是一个命令行库，最初作为GitHub上airlift组织的一部分编写。在经过一段时间的停滞后，Rob Vesse对其进行了分叉，并赋予了新的生命（http://rvesse.github.io/airline）。航空公司对命令行定义的方法更加基于类--要定义一个命令实用程序，您需要声明一个新类，并适当地使用一些注释进行标记。让我们使用航空公司来实现我们之前的简单命令行：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The options handling continues to grow in terms of code size, but we're also
    gaining more and more clarity as to what options are supported, and what they
    each mean. Our command is clearly defined via `@Command` on the class declaration.
    The possible options are delineated as `@Option`--annotated instance variables,
    and the business logic in `run()` is completely devoid of command-line parsing
    code. By the time this method is called, all the data has been extracted and we're
    ready to do our work. That looks very nice, but let's see what our last contender
    has to offer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 选项处理在代码大小方面不断增长，但我们对支持的选项以及它们各自的含义也越来越清晰。通过类声明上的`@Command`清晰地定义了我们的命令。可能的选项通过`@Option`--注释的实例变量来界定，而`run()`中的业务逻辑完全不包含命令行解析代码。在调用此方法时，所有数据都已被提取，我们准备好开始工作。这看起来非常不错，但让我们看看我们的最后一个竞争者有什么提供。
- en: 'Crest is a library from Tomitribe, the company behind TomEE, the "all-Apache
    Java EE Web Profile certified stack" based on the venerable Tomcat Servlet container.
    Crest''s approach to command definition is method based, where you define a method
    per command. It also uses annotations, and offers Bean Validation out of the box,
    as well as optional command discovery. Reimplementing our simple command, then,
    may look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Crest是Tomitribe的一个库，该公司是TomEE的背后公司，TomEE是基于备受尊敬的Tomcat Servlet容器的“全Apache Java
    EE Web Profile认证堆栈”。Crest对命令定义的方法是基于方法的，您需要为每个命令定义一个方法。它还使用注释，并且提供了开箱即用的Bean验证，以及可选的命令发现。重新实现我们的简单命令可能看起来像这样：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That seems to be the best of both worlds: it''s nice and concise, and will
    still keep the actual logic of the command free from any CLI-parsing concerns,
    unless you''re bothered by the annotations on the method. Although the actual
    logic-implementing code is free from such concerns. While Airline and Crest both
    offer things the other does not, Crest wins for me, so that''s what we''ll use
    to implement our command-line interface.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是两全其美的最佳选择：它既简洁又能保持命令的实际逻辑不受任何CLI解析的影响，除非您对方法上的注释感到困扰。尽管实际的逻辑实现代码不受这些影响。虽然航空公司和Crest都提供了对方没有的功能，但对我来说，Crest更胜一筹，所以我们将使用它来实现我们的命令行界面。
- en: With a library chosen, then, let's take a look at what our CLI might look like.
    Most importantly, we need to be able to specify the path (or paths) we want to
    search. Likely, most files in those paths will have the same extension, but that
    certainly won't always be the case, so we want to allow the user to specify only
    the file patterns to match (for example, `.jpg`). Some users might also be curious
    about how long it takes to run the scan, so let's throw in a switch to turn on
    that output. And finally, let's add a switch to make the process a bit more verbose.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了选择的库，让我们看看我们的CLI可能是什么样子。最重要的是，我们需要能够指定要搜索的路径（或路径）。很可能，这些路径中的大多数文件将具有相同的扩展名，但这肯定不会总是这种情况，因此我们希望允许用户仅指定要匹配的文件模式（例如`.jpg`）。一些用户可能还对运行扫描需要多长时间感到好奇，因此让我们加入一个开关来打开该输出。最后，让我们添加一个开关，使该过程更加详细。
- en: With our functional requirements set, let's start writing our command. Crest
    is method-based in its command declarations, but we'll still need a class to put
    our method in. If this CLI were more complicated (or, for example, if you were
    writing a CLI for an application server), you could easily put several CLI commands
    in the same class, or group similar commands in several different classes. How
    you structure them is completely your concern, as Crest is happy with whatever
    you choose.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的功能要求，让我们开始编写我们的命令。Crest在其命令声明中是基于方法的，但我们仍然需要一个类来放置我们的方法。如果这个CLI更复杂（或者，例如，如果您正在为应用服务器编写CLI），您可以轻松地将几个CLI命令放在同一个类中，或者将类似的命令分组在几个不同的类中。您如何结构它们完全取决于您，因为Crest对您选择的任何方式都很满意。
- en: 'We''ll start with our CLI interface declaration as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下方式声明我们的CLI界面开始：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before we can discuss the preceding code, we need to declare our Java module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论上述代码之前，我们需要声明我们的Java模块：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've defined a new module, which is named similarly to our library's module
    name. We also declared that we `require` two Crest modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新模块，其名称与我们的库模块名称类似。我们还声明了我们需要两个Crest模块。
- en: Back to our source code, we have the four parameters that we discussed in our
    functional requirements. Note that `patterns` and `paths` are defined as `List<String>`.
    When Crest is parsing the command line, if it finds multiple instances of one
    of these (for example, `--path=/path/one--path=/path/two`), it will collect all
    of these values and store them as a `List` for you. Also, note that `verbose`
    and `showTimings` are defined as `boolean`, so we see a nice example of the type
    coercion that Crest will do on our behalf. We also have default values for both
    of these, so we're sure to have sane, predictable values when our method executes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的源代码，我们有我们在功能需求中讨论过的四个参数。请注意，`patterns`和`paths`被定义为`List<String>`。当Crest解析命令行时，如果它找到其中一个的多个实例（例如，`--path=/path/one--path=/path/two`），它将收集所有这些值并将它们存储为`List`。另外，请注意，`verbose`和`showTimings`被定义为`boolean`，所以我们看到了Crest将代表我们执行的类型强制转换的一个很好的例子。我们还为这两个参数设置了默认值，所以当我们的方法执行时，我们肯定会得到明智、可预测的值。
- en: 'The business logic of the method is pretty straightforward. We will handle
    the verbose flag upfront, printing a summary of the operation requested as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的业务逻辑非常简单。我们将处理verbose标志，打印所请求操作的摘要如下：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we will perform the actual work. Thanks to the work we did building the
    library, all of the logic for the duplicate search is hidden away behind our API:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将执行实际工作。由于我们构建了库，所有重复搜索的逻辑都隐藏在我们的API后面：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code won''t compile at first, as we''ve not told the system we need it.
    We can do that now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码一开始不会编译，因为我们还没有告诉系统我们需要它。我们现在可以这样做：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now import the `FileFinder` class. First, to demonstrate that the modules
    are, in fact, doing what they''re supposed to do, let''s try to import something
    that wasn''t exported: `FindFileTask`. Let''s create a simple class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导入`FileFinder`类。首先，为了证明模块实际上正在按预期工作，让我们尝试导入一个未被导出的东西：`FindFileTask`。让我们创建一个简单的类：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we try to compile this, Maven/javac will complain loudly with an error message
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这个，Maven/javac会大声抱怨，错误消息如下：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have successfully hidden our utility classes while exposing our public API.
    It may take some time for this practice to become widespread, but it should work
    wonders in preventing the crystallization of private APIs as pseudo-public.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地隐藏了我们的实用程序类，同时暴露了我们的公共API。这种做法可能需要一些时间才能变得普遍，但它应该能够在防止私有API结晶为伪公共方面发挥奇迹。
- en: Back on task, we create an instance of our `FileFinder` class, use `String.forEach`
    to pass our `paths` and `patterns` to the finder, then start the work with a call
    to `find()`. The work itself is threaded, but we've exposed a synchronous API,
    so our call here will block until the work has been completed. Once it returns,
    we start printing details to the screen. Since `FindFiles.getDuplicates()` returns
    `Map<String, List<FileInfo>>`, we call `forEach()` on the `Map` to iterate over
    each key, then we call `forEach()` on the `List` to print information about each
    file. We also use an `AtomicInteger` as the index, as the variable must be final
    or effectively final, so we just use a `final` instance of `AtomicInteger`. `BigInteger`
    may come to mind to more experienced developers, but it's immutable, so that makes
    it a poor choice for our use here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到任务上，我们创建了`FileFinder`类的一个实例，使用`String.forEach`将我们的`paths`和`patterns`传递给查找器，然后通过调用`find()`开始工作。工作本身是多线程的，但我们暴露了一个同步API，所以我们的调用会阻塞，直到工作完成。一旦返回，我们开始在屏幕上打印细节。由于`FindFiles.getDuplicates()`返回`Map<String,
    List<FileInfo>>`，我们在`Map`上调用`forEach()`来遍历每个键，然后在`List`上调用`forEach()`来打印有关每个文件的信息。我们还使用`AtomicInteger`作为索引，因为变量必须是final或有效final，所以我们只使用了`AtomicInteger`的`final`实例。对于更有经验的开发人员来说，可能会想到`BigInteger`，但它是不可变的，所以在这里使用它是一个不好的选择。
- en: 'The output of running the command will look something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令的输出将类似于这样：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we handle `showTimings`. I didn''t call it out in the preceding code,
    though I will now, but we get an `Instant` instance (from the Java 8 date/time
    library in `java.time`) before and after processing. Only when `showTimings` is
    true do we actually do anything with them. The code that does that looks like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理`showTimings`。我在前面的代码中没有提到它，但现在我会提到，我们在处理之前和之后得到了一个`Instant`实例（来自Java
    8的日期/时间库`java.time`）。只有当`showTimings`为true时，我们才会真正对它们做任何事情。处理它的代码看起来像这样：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With our two `Instant`, we get a `Duration`, then start calculating hours, minutes,
    and seconds. Hopefully, this never runs more than an hour, but it can't hurt to
    be ready for it. And that's all there is to the CLI, in terms of code. Crest did
    the heavy lifting for our command-line parameter parsing, leaving us with a straightforward
    and clean implementation of our logic.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的两个`Instant`，我们得到了一个`Duration`，然后开始计算小时、分钟和秒。希望这永远不会超过一个小时，但做好准备也无妨。这就是CLI的全部代码。Crest为我们的命令行参数解析做了大部分工作，留下了一个简单而干净的逻辑实现。
- en: 'There''s one last thing we need to add, and that''s the CLI help. It would
    be very helpful for the end user to be able to find out how to use our command.
    Fortunately, Crest has support built in to provide that information. To add the
    help information, we need to create a file called `OptionDescriptions.properties`
    in the same package as our command class (remember that since we''re using Maven,
    this file should be under `src/main/resource`), as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加最后一件事，那就是CLI帮助。对于最终用户来说，能够找出如何使用我们的命令将非常有帮助。幸运的是，Crest内置了支持来提供这些信息。要添加帮助信息，我们需要在与我们的命令类相同的包中创建一个名为`OptionDescriptions.properties`的文件（请记住，由于我们使用的是Maven，这个文件应该在`src/main/resource`下），如下所示：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Doing so will produce an output like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将产生以下输出：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can be as verbose as you need to be without making your source code an unreadable
    mess.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尽可能详细，而不会使您的源代码变得难以阅读。
- en: 'With that, our CLI is feature-complete. Before we move on, we need to take
    a look at some build concerns for our CLI and see how Crest fits in. Obviously,
    we need to tell Maven where to find our Crest dependency, which is shown in the
    following piece of code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的CLI就功能齐全了。在继续之前，我们需要查看一下我们的CLI的一些构建问题，并看看Crest如何适应。显然，我们需要告诉Maven在哪里找到我们的Crest依赖项，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also need to tell it where to find our duplicate finder library as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉它在哪里找到我们的重复查找器库，如下所示：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note `groupId` and `version`: since our CLI and library modules are part of
    the same parent multi-module build, we set `groupId` and `version` to that of
    the parent module, allowing us to manage that from a single location, which makes
    changing groups or bumping versions much simpler.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`groupId`和`version`：由于我们的CLI和库模块是同一个父多模块构建的一部分，我们将`groupId`和`version`设置为父模块的`groupId`和`version`，允许我们从单个位置管理它，这样更改组或升级版本就简单得多。
- en: 'The more interesting part is the `build` section of our POM. First, let''s
    start with `maven-compiler-plugin`. While we are targeting Java 9, `crest-maven-plugin`,
    which we''ll look at in a moment, does not currently seem to like the classes
    generated for Java 9, so we instruct the compiler plugin to emit Java 1.8 bytecode:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: POM的`build`部分是更有趣的部分。首先，让我们从`maven-compiler-plugin`开始。虽然我们的目标是Java 9，但`crest-maven-plugin`（我们稍后将看到）似乎目前不喜欢为Java
    9生成的类，因此我们指示编译器插件发出Java 1.8字节码：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we need to set up `crest-maven-plugin`. To expose our command classes
    to Crest, we have two options: we can use runtime scanning for the classes, or
    we can have Crest scan for commands at build time. In order to make this utility
    as small as possible, as well as reducing the startup time as much as possible,
    we will opt for the latter approach, so we will need to add another plugin to
    the build, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`crest-maven-plugin`。为了将我们的命令类暴露给Crest，我们有两个选项：我们可以使用运行时扫描类，或者我们可以让Crest在构建时扫描命令。为了使此实用程序尽可能小，以及尽可能减少启动时间，我们将选择后一种方法，因此我们需要向构建中添加另一个插件，如下所示：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this plugin runs, it will generate a file called `crest-commands.txt` that
    Crest will process to find classes when it starts. It may not save much time here,
    but it's definitely something to keep in mind for larger projects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当此插件运行时，它将生成一个名为`crest-commands.txt`的文件，Crest将处理该文件以在启动时查找类。这里可能不会节省太多时间，但对于更大的项目来说，这绝对是需要牢记的事情。
- en: 'Finally, we don''t want the user to have to worry about setting up the classpath
    (or module path!) each time, so we''ll introduce the Maven Shade plugin, which
    will create a single, fat jar with all of our dependencies, transitive and otherwise:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不希望用户每次都要担心设置类路径（或模块路径！），因此我们将引入Maven Shade插件，它将创建一个包含所有依赖项的单个大型jar文件：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After the build, we can then run a search with the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构建后，我们可以使用以下命令运行搜索：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Clearly, it can still be improved, so we would want to ship that, say, with
    script wrappers (shell, batch, and so on), but the number of jars is cut down
    from 18 or so to 1, so that's a big improvement.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它仍然可以改进，所以我们希望在脚本包装器（shell、批处理等）中发布它，但jar的数量从18个左右减少到1个，这是一个很大的改进。
- en: With our CLI done, let's make a simple GUI that consumes our library as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的CLI后，让我们制作一个简单的GUI来使用我们的库。
- en: Building the graphical user interface
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建图形用户界面
- en: 'For our GUI, we''d like to expose the same type of functionality as the command
    line, but, obviously, with a nice graphical interface. For this, we''ll again
    reach for JavaFX. We''ll give the user a means to select, using a chooser dialog,
    the directories to be searched, and a field by which to add the search patterns.
    Once the duplicates have been identified, we will display them in a list for the
    user to peruse. All of the duplicate groups will be listed and, when clicked,
    the files in that group will be displayed in another list. The user can right-click
    on the list and choose to either view the file (or files) or delete it (or them).
    When we are finished, the application will look like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的GUI，我们希望暴露与命令行相同类型的功能，但显然，使用一个漂亮的图形界面。为此，我们将再次使用JavaFX。我们将为用户提供一种选择对话框，用于选择要搜索的目录，并添加搜索模式的字段。一旦重复项被识别出来，我们将在列表中显示它们供用户查看。所有重复组将被列出，并且当点击时，该组中的文件将在另一个列表中显示。用户可以右键单击列表，选择查看文件或删除文件。完成后，应用程序将如下所示：
- en: '![](img/b580b9aa-0fad-43ba-a9c4-0ec8cdaa3e90.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b580b9aa-0fad-43ba-a9c4-0ec8cdaa3e90.png)'
- en: Let's start by creating our project. In NetBeans, go to File | New Project and
    select Maven | JavaFX Application. You can name it whatever you'd like, but we've
    used the name `Duplicate Finder - GUI`, `groupId` as `com.steeplesoft.dupefind`,
    and `artifactId` as `gui`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的项目开始。在NetBeans中，转到文件 | 新建项目，选择Maven | JavaFX应用程序。您可以随意命名，但我们使用了名称`Duplicate
    Finder - GUI`，`groupId`为`com.steeplesoft.dupefind`，`artifactId`为`gui`。
- en: 'Once you have your project, you should have two classes, `Main` and `FXMLController`,
    as well as the `fxml/Scene.fxml` resource. This may sound repetitive, but before
    we go any further, we need to set up our Java module as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，您应该有两个类，`Main`和`FXMLController`，以及`fxml/Scene.fxml`资源。这可能听起来有些重复，但在继续之前，我们需要按照以下方式设置我们的Java模块：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, to create the interface we saw, we will use `BorderPane`, to which we''ll
    add `MenuBar` to the `top` section, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了创建我们看到的界面，我们将使用`BorderPane`，并将`MenuBar`添加到`top`部分，如下所示：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you add `MenuBar` with Scene Builder, it automatically adds several sample
    `Menu` entries for you. We've removed the unwanted entries, and tied the remaining
    to Java methods in the controller class. Specifically, the `Close` menu will call
    `closeApplication()` and `About` will call `showAbout()`. This looks just like
    the menu markup seen previously in the book, so there's not much to talk about.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Scene Builder添加`MenuBar`时，它会自动为您添加几个示例`Menu`条目。我们已经删除了不需要的条目，并将剩下的条目与控制器类中的Java方法绑定起来。具体来说，`Close`菜单将调用`closeApplication()`，`About`将调用`showAbout()`。这看起来就像之前在书中看到的菜单标记，所以没有太多可谈论的。
- en: 'The rest of the layout is a bit more complex. In the `left` section, we have
    a number of controls stacked vertically. JavaFX has a built-in container that
    makes that easy to do: `VBox`. We''ll get to its contents in a moment, but its
    usage looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 布局的其余部分稍微复杂一些。在`left`部分，我们有一些垂直堆叠的控件。JavaFX有一个内置的容器，使这个操作变得很容易：`VBox`。我们将马上看到它的内容，但它的使用看起来像这样：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's not valid FXML, so don't try to copy and paste that. I've omitted the
    details of the children for clarity. As you can see, `VBox` has a number of children,
    each of which will be stacked vertically, but, as we can see from the preceding
    screenshot, there are some we want to be lined up horizontally. To achieve that,
    we nest an `HBox` instance where needed. Its markup looks just like `VBox`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是有效的FXML，所以不要尝试复制粘贴。为了清晰起见，我省略了子元素的细节。正如您所看到的，`VBox`有许多子元素，每个子元素都将垂直堆叠，但正如我们从前面的屏幕截图中看到的那样，有一些我们希望水平排列。为了实现这一点，我们在需要的地方嵌套一个`HBox`实例。它的标记看起来就像`VBox`。
- en: 'There''s not much of interest in this part of the FXML, but there are a couple
    of things to note. We want certain parts of the user interface to shrink and grow
    as the window is resized, namely `ListView`. By default, each component''s various
    height and width properties--minimum, maximum, and preferred--will use the computed
    size, which means, roughly, that they''ll be as big as they need to be to render
    themselves, and, in most cases, that''s fine. In our situation, we want the two
    `ListView` instances to grow as much as possible inside their respective containers,
    which, in this case, is `VBox` we discussed earlier. To make that happen, we need
    to modify our two `ListView` instances like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分FXML中没有太多有趣的内容，但有一些需要注意的地方。我们希望用户界面的某些部分在窗口调整大小时收缩和增长，即`ListView`。默认情况下，每个组件的各种高度和宽度属性（最小、最大和首选）将使用计算出的大小，这意味着它们将尽可能大地渲染自己，而在大多数情况下，这是可以的。在我们的情况下，我们希望两个`ListView`实例尽可能多地增长在它们各自的容器内，这种情况下是我们之前讨论的`VBox`。为了实现这一点，我们需要修改我们的两个`ListView`实例，就像这样：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With both the `ListView` instances set to `ALWAYS` grow, they will compete with
    each other for the available space, and end up sharing it. The available space,
    of course, is dependent on the height of the `VBox` instance, as well as the computed
    height of the other components in the container. With that property set, we can
    increase or decrease the size of the window, and watch the two `ListView` instances
    grow and shrink, while everything else remains the same.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个`ListView`实例都设置为`ALWAYS`增长时，它们将争夺可用空间，并最终共享它。当然，可用空间取决于`VBox`实例的高度，以及容器中其他组件的计算高度。有了这个属性设置，我们可以增加或减小窗口的大小，观察两个`ListView`实例的增长和收缩，而其他一切保持不变。
- en: 'For the rest of the user interface, we''ll apply the same tactic to arrange
    components, but, this time, we''ll start with an `HBox` instance, and divide that
    up as necessary. We have two `ListView` instances that we also want to fill all
    the available space with, so we mark those up in the same way we did the last
    two. Each `ListView` instance also has a `Label`, so we wrap each `Label`/`ListView`
    pair in a `VBox` instance to get our vertical distribution. In pseudo-FXML, this
    would look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面的其余部分，我们将应用相同的策略来安排组件，但是这一次，我们将从一个`HBox`实例开始，并根据需要进行划分。我们有两个`ListView`实例，我们也希望用所有可用的空间来填充它们，所以我们以与前两个相同的方式标记它们。每个`ListView`实例还有一个`Label`，所以我们将每个`Label`/`ListView`对包装在一个`VBox`实例中，以获得垂直分布。在伪FXML中，这看起来像这样：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There is one item of interest in this part of the user interface, and that
    is the context menu we discussed earlier. To add a context to a control, you nest
    a `contextMenu` element in the target control''s FXML like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面的这一部分中有一个值得注意的项目，那就是我们之前讨论过的上下文菜单。要向控件添加上下文，您需要在目标控件的FXML中嵌套一个`contextMenu`元素，就像这样：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''ve defined a content menu with two `MenuItem`: `"Open File(s)..."` and
    `"Deleted File(s)..."`. We''ve also specified the action for the two `MenuItem`
    using the `onAction` attribute. We''ll look at these following methods.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个包含两个`MenuItem`的内容菜单：`“打开文件…”`和`“删除文件…”`。我们还使用`onAction`属性指定了这两个`MenuItem`的操作。我们将在接下来看这些方法。
- en: This marks the end of our user interface definition, so now we turn our attention
    to the Java code, in which we will finish preparing the user interface for use,
    as well as implement our application's logic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们用户界面定义的结束，现在我们将注意力转向Java代码，我们将完成用户界面的准备工作，并实现我们应用程序的逻辑。
- en: 'While we didn''t show the FXML that accomplishes this, our FXML file is tied
    to our controller class: `FXMLController`. This class can be called anything,
    of course, but we''ve opted to use the name generated by the IDE. In a larger
    application, more care will need to be given in the naming of this class. To allow
    the injection of our user interface components into our code, we need to declare
    instance variables on our class, and mark them up with the `@FXML` annotation.
    Some examples include the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有展示实现这一点的FXML，但我们的FXML文件与我们的控制器类`FXMLController`相关联。当然，这个类可以被任何名称调用，但我们选择使用IDE生成的名称。在一个更大的应用程序中，需要更多地关注这个类的命名。为了允许我们将用户界面组件注入到我们的代码中，我们需要在我们的类上声明实例变量，并用`@FXML`注解标记它们。一些示例包括以下内容：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are several others, but this should be sufficient to demonstrate the concept.
    Note that rather than declaring a plain `ListView`, we've parameterized our instances
    as `ListView<String>` and `ListView<FileInfo>`. We know this is what we're putting
    into the control, so specifying that the type parameter gets us a measure of type
    safety at compile time, but also allows us to avoid having to cast the contents
    every time we interact with them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个，但这应该足以演示这个概念。请注意，我们没有声明一个普通的`ListView`，而是将我们的实例参数化为`ListView<String>`和`ListView<FileInfo>`。我们知道这是我们放入控件的内容，因此在编译时指定类型参数可以让我们在编译时获得一定程度的类型安全性，但也可以避免在每次与它们交互时都必须转换内容。
- en: 'Next, we need to set up the collections that will hold the search paths and
    patterns that the user will enter. We''ll use the `ObservableList` instances for
    that. Remember that with an `ObservableList` instance, the container can automatically
    rerender itself as needed when the `Observable` instance is updated:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置将保存用户输入的搜索路径和模式的集合。我们将使用`ObservableList`实例。请记住，使用`ObservableList`实例时，容器可以在需要时自动重新呈现自身，当`Observable`实例被更新时：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `initialize()` method, we can start tying things together. Consider
    the following code snippet as an example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，我们可以开始将事物联系在一起。考虑以下代码片段作为示例：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we associate our `ListView` instances with our `ObservableList` instances.
    Now, at any point that these lists are updated, the user interface will immediately
    reflect the change.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`ListView`实例与我们的`ObservableList`实例关联起来。现在，每当这些列表被更新时，用户界面将立即反映出变化。
- en: 'Next, we need to configure the duplicate file group `ListView`. The data coming
    back from our library is a `Map` of a `List<FileInfo>` object, keyed by the duplicate
    hashes. Clearly, we don''t want to show the user a list of hashes, so, like the
    CLI, we want to denote each group of files with a more friendly label. To do that,
    we need to create a `CellFactory`, which will, in turn, create a `ListCell` that
    is responsible for rendering the cell. We will do that as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置重复文件组`ListView`。从我们的库返回的数据是一个由重复哈希键控的`List<FileInfo>`对象的`Map`。显然，我们不想向用户显示哈希列表，因此，就像CLI一样，我们希望用更友好的标签表示每个文件组。为此，我们需要创建一个`CellFactory`，它将创建一个负责呈现单元格的`ListCell`。我们将这样做：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'While lambdas can be great, in that they tend to make code more concise, they
    can also obscure some details. In a non-lambda code, the lambda above might look
    like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda可能很棒，因为它们倾向于使代码更简洁，但它们也可能隐藏一些细节。在非lambda代码中，上面的lambda可能看起来像这样：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You certainly get more detail, but it''s also much harder to read. The main
    point in including both here is twofold: to show why lambdas are often so much
    better, and to show the actual types involved, which helps the lambdas make sense.
    With that understanding of the lambdas under our belts, what is the method doing?'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定会得到更多的细节，但阅读起来也更困难。在这里包括两者的主要目的是：展示为什么lambda通常更好，并展示涉及的实际类型，这有助于lambda变得更有意义。有了对lambda的理解，我们接下来的方法是做什么？
- en: 'First, we call `super.updateItem()`, as that''s simply good practice. Next,
    we find the index of the string being rendered. The API gives us the string (since
    it''s a `ListView<String>`), so we find its index in our `ObservableList<String>`.
    If it''s found, we set the text of the cell to `Group #` plus the index plus one
    (since indexes in Java are typically zero-based). If the string isn''t found (`ListView`
    is rendering an empty cell), we set the text to null to ensure that the field
    is blank.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们调用`super.updateItem()`，因为这只是一个良好的实践。接下来，我们找到正在呈现的字符串的索引。API给了我们字符串（因为它是一个`ListView<String>`），所以我们在我们的`ObservableList<String>`中找到它的索引。如果找到了，我们将单元格的文本设置为`Group
    #`加上索引加一（因为Java中的索引通常是从零开始的）。如果找不到字符串（`ListView`正在呈现空单元格），我们将文本设置为null，以确保该字段为空白。'
- en: 'Next, we need to perform a similar procedure on `matchingFilesListView`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`matchingFilesListView`上执行类似的过程：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is almost identical, but with a couple of exceptions. First, we're setting
    the selection mode of `ListView` to `MULTIPLE`. This will allow the user to control-click
    on items of interest, or shift-click on a range of rows. Next, we set up `CellFactory`
    in an identical fashion. Note that since the `ListView` instance's parameterized
    type is `FileInfo`, the types in the method signature of `ListCell.updateItem()`
    are different.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是相同的，但有几个例外。首先，我们将`ListView`的选择模式设置为`MULTIPLE`。这将允许用户在感兴趣的项目上进行控制点击，或者在一系列行上进行shift-click。接下来，我们以相同的方式设置`CellFactory`。请注意，由于`ListView`实例的参数化类型是`FileInfo`，因此`ListCell.updateItem()`方法签名中的类型是不同的。
- en: 'We have one last user interface setup step. If you look back at the screenshot,
    you will notice that the Find Duplicates button is the same width as `ListView`,
    unlike the other buttons, which are just wide enough to render their content.
    We do that by binding the width of the `Button` element to that of its container,
    which is an `HBox` instance:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一个用户界面设置步骤。如果您回顾一下屏幕截图，您会注意到“查找重复”按钮与`ListView`的宽度相同，而其他按钮的宽度仅足以呈现其内容。我们通过将`Button`元素的宽度绑定到其容器的宽度（即`HBox`实例）来实现这一点：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are getting the preferred width property, which is a `DoubleProperty`, and
    binding that to the width property (also a `DoubleProperty`) of `findBox`, the
    control's container. `DoubleProperty` is an `Observable` instance, just as `ObservableListView`
    is, so we're telling the `findFiles` control to observe its container's width
    property, and set its own value accordingly when the other changes. This lets
    us set the property, after a fashion, and then forget about it. Unless we want
    to break the binding between these two properties, we never again have to think
    about it, and we certainly don't need to manually watch one property to update
    the author. The framework does that for us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在获取首选宽度属性，这是一个`DoubleProperty`，并将其绑定到`findBox`的宽度属性（也是一个`DoubleProperty`），这是控件的容器。`DoubleProperty`是一个`Observable`实例，就像`ObservableListView`一样，所以我们告诉`findFiles`控件观察其容器的宽度属性，并在其他属性更改时相应地设置自己的值。这样我们可以设置属性，然后忘记它。除非我们想要打破这两个属性之间的绑定，否则我们再也不必考虑它，当然也不需要手动观察一个属性来更新作者。框架会为我们做这些。
- en: 'Now, how about those buttons? How do we make them do something? We do that
    by setting the `onAction` property of the `Button` element to a method in our
    controller: `#someMethod` translates to `Controller.someMethod(ActionEvent event)`.
    We can handle this in one of at least two ways: we can create a separate handler
    method for each button, or, as we''ve done here, we can create one, then delegate
    to another method as appropriate; either is fine:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些按钮怎么样？我们如何让它们做一些事情？我们通过将`Button`元素的`onAction`属性设置为控制器中的一个方法来实现：`#someMethod`转换为`Controller.someMethod(ActionEvent
    event)`。我们至少有两种方法来处理这个问题：我们可以为每个按钮创建一个单独的处理程序方法，或者，就像我们在这里做的那样，我们可以创建一个方法，然后根据需要委托给另一个方法；两种方法都可以：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We have to make sure we''re actually getting a `Button` element, then we cast
    it and compare it to the instances that were injected. The actual handlers for
    each button are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保我们实际上获取了一个`Button`元素，然后将其转换并将其与被注入的实例进行比较。每个按钮的实际处理程序如下：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To add a pattern, we create a `TextInputDialog` instance with the appropriate
    text, then call `showAndWait()`. The beauty of this method in JavaFX 8 is that
    it returns `Optional<String>`. If the user enters text in the dialog, and if the
    user clicks on OK, the `Optional` will have content. We identify that with the
    call to `ifPresent()`, passing it a lambda that adds the new pattern to `ObservableList<String>`,
    which automatically updates the user interface. If the user doesn't click on OK,
    the `Optional` will be empty. If the user didn't enter any text (or entered a
    bunch of spaces), the call to `filter()` will prevent the lambda from ever running.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加模式，我们创建一个带有适当文本的`TextInputDialog`实例，然后调用`showAndWait()`。JavaFX 8中这种方法的美妙之处在于它返回`Optional<String>`。如果用户在对话框中输入文本，并且用户点击确定，`Optional`将包含内容。我们通过调用`ifPresent()`来识别，传递一个lambda，将新模式添加到`ObservableList<String>`中，这将自动更新用户界面。如果用户没有点击确定，`Optional`将为空。如果用户没有输入任何文本（或输入了一堆空格），则调用`filter()`将阻止lambda运行。
- en: 'Removing an item is similar, though we get to hide some of the details in a
    utility method, since we have two needs for the functionality. We make sure something
    is selected, then show a confirmation dialog, removing the pattern from the `ObservableList<String>`
    if the user clicks on OK:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 删除项目类似，尽管我们需要隐藏一些细节在一个实用方法中，因为我们对功能有两个需求。我们确保已选择某些内容，然后显示确认对话框，如果用户点击确定，则从`ObservableList<String>`中删除模式：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s take a look at the `showConfirmationDialog` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`showConfirmationDialog`方法：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Again, this is much like the dialogs earlier, and should be self-explanatory.
    The interesting part here is the use of a lambda as a method parameter that makes
    this, by the way, a higher order function--meaning it takes in a function as a
    parameter, returns a function as its result, or both. We pass in `Runnable`, as
    we want a lambda that takes in nothing and returns nothing, and `Runnable` is
    a `FunctionalInterface` that matches that description. After we show the dialog
    and get the user's response, we will filter for only responses where the button
    clicked on was `OK`, and, if present, we execute `Runnable` via `action.run()`.
    We have to specify `b -> action.run()` as `ifPresent()` takes a `Consumer<? super
    ButtonType>`, so we create one and ignore the value passed in, allowing us to
    shield our calling code from that detail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的对话框非常相似，应该是不言自明的。这里有趣的部分是使用lambda作为方法参数，这使得它成为一个高阶函数--意味着它接受一个函数作为参数，返回一个函数作为结果，或者两者都有。我们传递`Runnable`，因为我们想要一个不带参数并且不返回任何内容的lambda，而`Runnable`是一个`FunctionalInterface`，符合这个描述。在显示对话框并获取用户的响应后，我们将仅过滤出按钮点击为`OK`的响应，并且如果存在，我们通过`action.run()`执行`Runnable`。我们必须指定`b
    -> action.run()`作为`ifPresent()`接受一个`Consumer<? super ButtonType>`，所以我们创建一个并忽略传入的值，从而使我们的调用代码免受该细节的影响。
- en: 'Adding a path requires a `DirectoryChooser` instance:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路径需要一个`DirectoryChooser`实例：
- en: '[PRE69]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When creating the `DirectoryChooser` instance, we set the initial directory
    to the last directory used as a convenience for the user. When the application
    starts, this defaults to the user's home directory, but once a directory is successfully
    chosen, we set `lastDir` to the added directory's parent, allowing the user to
    start where he or she left off should there be a need to enter multiple paths.
    `DirectoryChooser.showDialog()` returns a file, so we get its canonical path and
    store that in paths, which, again, causes our user interface to be updated automatically.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`DirectoryChooser`实例时，我们将初始目录设置为上次使用的目录，以方便用户。当应用程序启动时，这默认为用户的主目录，但一旦成功选择了目录，我们将`lastDir`设置为添加的目录的父目录，允许用户从上次离开的地方开始，如果需要输入多个路径。`DirectoryChooser.showDialog()`返回一个文件，所以我们获取其规范路径并将其存储在路径中，这将再次自动更新我们的用户界面。
- en: 'Removing a path looks very similar to removing a pattern, as you can see in
    the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 删除路径看起来与删除模式非常相似，如下面的代码片段所示：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Same basic code, just a different lambda. Aren't lambdas just the coolest?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的基本代码，只是不同的lambda。lambda不是很酷吗？
- en: 'The handler for the `findFiles()` button is a bit different, but looks a lot
    like our CLI code, as you can see here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`findFiles()`按钮的处理程序有点不同，但看起来很像我们的CLI代码，如下所示：'
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We create our `FileFinder` instance, set the paths and patterns using streams
    and lambdas, then start the search process. When it completes, we get the list
    duplicate file information via `getDuplicates()`, then create a new `ObservableList<String>`
    instance using the keys of the map, which we then set on `dupeFileGroupListView`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`FileFinder`实例，使用流和lambda设置路径和模式，然后开始搜索过程。当搜索完成时，我们通过`getDuplicates()`获取重复文件信息列表，然后使用映射的键创建一个新的`ObservableList<String>`实例，然后将其设置在`dupeFileGroupListView`上。
- en: 'Now we need to add the logic to handle mouse clicks on the group list, so we
    will set the `onMouseClicked` property on `ListView` in the FXML file to `#dupeGroupClicked`,
    as you can see in the following code block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加处理组列表上鼠标点击的逻辑，所以我们将在FXML文件中将`ListView`的`onMouseClicked`属性设置为`#dupeGroupClicked`，如下面的代码块所示：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When the control is clicked on, we get the index and make sure it is non-negative,
    so as to ensure that the user actually clicked on something. We then get the hash
    of the group by getting the selected item from `ListView`. Remember that while
    `ListView` may show something like `Group #2`, the actual content of that row
    is the hash. We just used a custom `CellFactory` to give it a prettier label.
    With the hash, we clear the list of items in `matchingFilesListView`, then get
    the control''s `ObservableList` and add all of the `FileInfo` objects in the `List`
    keyed by the hash. And, again, we get an automatic user interface update, thanks
    to the power of `Observable`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '当单击控件时，我们获取索引并确保它是非负的，以确保用户实际上点击了某些内容。然后我们通过从`ListView`中获取所选项目来获取组的哈希值。请记住，虽然`ListView`可能显示类似于“Group
    #2”的内容，但该行的实际内容是哈希值。我们只是使用自定义的`CellFactory`来给它一个更漂亮的标签。有了哈希值，我们清除`matchingFilesListView`中的项目列表，然后获取控件的`ObservableList`并添加由哈希键控的`List`中的所有`FileInfo`对象。再次，由于`Observable`的强大功能，我们获得了自动用户界面更新。'
- en: 'We also want the user to be able to navigate the list of duplicate groups using
    the keyboard to update the matching file list. We do that by setting the `onKeyPressed`
    attribute on our `ListView` to point to this rather simple method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望用户能够使用键盘浏览重复组列表以更新匹配文件列表。我们通过将`ListView`的`onKeyPressed`属性设置为指向这个相当简单的方法来实现：
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It just so happens that we're not too terribly interested in the actual `Event`
    in either of these methods (they're never actually used), so we can naively delegate
    to the mouse-click method discussed earlier.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好我们对这两种方法中的实际“事件”并不是特别感兴趣（它们实际上从未被使用），所以我们可以天真地委托给之前讨论过的鼠标点击方法。
- en: 'There are two more minor pieces of functionality we need to implement: viewing
    the matching files and deleting matching files.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现两个较小的功能：查看匹配文件和删除匹配文件。
- en: 'We''ve already created the context menu and menu entries, so all we need to
    do is implement the handler methods as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了上下文菜单和菜单条目，所以我们需要做的就是实现以下处理程序方法：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The matching file list allows multiple selections, so we need to get `List<FileInfo>`
    from the selection model instead of the single object we''ve already seen. We
    then call `forEach()` to process the entry. We want to open the file in whatever
    application the user has configured in the operating system to handle that file
    type. To do this, we use an AWT class introduced in Java 6: `Desktop`. We get
    the instance via `getDesktop()`, then call `open()`, passing it `File` that points
    to our `FileInfo` target.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配文件列表允许多个选择，所以我们需要从选择模型中获取`List<FileInfo>`，而不是我们已经看到的单个对象。然后我们调用`forEach()`来处理条目。我们希望在操作系统中使用用户配置的任何应用程序中打开文件。为此，我们使用了Java
    6中引入的AWT类：`Desktop`。我们通过`getDesktop()`获取实例，然后调用`open()`，传递指向我们的`FileInfo`目标的`File`。
- en: 'Deleting a file is similar:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件类似：
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Similarly to open files, we get all of the selected files. If there's at least
    one, we confirm the user's intent via `showConfirmationDialog()`, and pass in
    a lambda that handles the deleting. We do the actual file deletion using the `Desktop`
    class again to move the file to the trash can provided by the filesystem to provide
    the user with a safe delete option. If the file is successfully deleted, we remove
    its entry from `ObservableList`, as well as our cache duplicate file `Map`, so
    that it isn't shown should the user click on this file group again.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于打开文件，我们获取所有选定的文件。如果至少有一个文件，我们通过`showConfirmationDialog()`确认用户的意图，并传入一个处理删除的lambda。我们使用`Desktop`类再次执行实际的文件删除，将文件移动到文件系统提供的垃圾桶中，以提供用户安全的删除选项。如果文件成功删除，我们从`ObservableList`中删除其条目，以及我们的缓存重复文件`Map`，这样如果用户再次点击此文件组，它就不会显示出来。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With that, our application is done. So, what have we covered? From the project
    description, this seemed like a pretty simple application, but as we started breaking
    down the requirements and delving into the implementation, we ended up covering
    a lot of territory--a scenario that is not at all uncommon. We built another multi-module
    Maven project. We introduced Java concurrency, including basic `Thread` management
    and `ExecutorService` usage, as well as the Java Persistence API, showing basic
    `@Entity` definition, `EntityManagerFactory/EntityManager` usage, and JPAQL query
    authoring. We discussed creating file hashes using the `MessageDigest` classes,
    and demonstrated the new file I/O APIs, including the directory tree walking APIs.
    We also built a more complex user interface in JavaFX using nested containers,
    "linked" `ListView` instances, and bound properties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们的应用程序就完成了。那么，我们覆盖了什么内容呢？从项目描述来看，这似乎是一个非常简单的应用程序，但当我们开始分解需求并深入实施时，我们最终涵盖了很多领域——这种情况并不罕见。我们构建了另一个多模块Maven项目。我们介绍了Java并发，包括基本的`Thread`管理和`ExecutorService`的使用，以及Java持久化API，展示了基本的`@Entity`定义，`EntityManagerFactory/EntityManager`的使用和JPAQL查询的编写。我们讨论了使用`MessageDigest`类创建文件哈希，并演示了新的文件I/O
    API，包括目录树遍历API。我们还使用JavaFX构建了一个更复杂的用户界面，使用了嵌套容器，“链接”了`ListView`实例，并绑定了属性。
- en: That's quite a bit for such a "simple" project. Our next project will also be
    relatively simple, as we build a command-line date calculator that will allow
    us to explore the `java.time` package and see some of what this new date/time
    API offers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一个“简单”的项目来说已经相当多了。我们的下一个项目也将相对简单，因为我们将构建一个命令行日期计算器，它将允许我们探索`java.time`包，并了解这个新的日期/时间API提供了一些什么。

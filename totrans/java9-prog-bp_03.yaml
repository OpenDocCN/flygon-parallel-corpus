- en: Duplicate File Finder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any system that's been running for a while starts to suffer from hard drive
    clutter. This is especially true, for example, with large music and photo collections.
    Except for the most fastidious files getting copied and moved, we end up with
    a copy here and a copy there. The question is, though, which of these are duplicates
    and which are not? In this chapter, we'll build a file-walking utility that will
    scan a set of directories looking for duplicate files. We'll be able to specify
    whether the duplicates should be deleted, **quarantined**, or simply reported.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java Platform Module System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java NIO (New I/O) File APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Persistence API** (**JPA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new Java Date/Time API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing command-line utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This application, while conceptually fairly simple, is a bit more complex than
    what we looked at in the last chapter, in that we will have both, a command line
    and a graphical interface. The experienced programmer is likely to immediately
    see the need to share the code between these two interfaces, as **DRY** (**Don''t
    Repeat Yourself**) is one of the many hallmarks of a well-designed system. To
    facilitate this sharing of code, then, we will want to introduce a third module,
    which provides a library that can be consumed by the other two projects. We will
    call these modules `lib`, `cli`, and `gui`. Our first step in setting up the project
    is to create the various Maven POM files to describe the project''s structure.
    The parent POM will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly typical POM file. We will start by identifying the project's
    parent that lets us inherit a number of settings, dependencies, and so on, and
    avoid having to repeat them in this project. Next, we will define the Maven coordinates
    for the project. Note that we don't define a version for this project, allowing
    the parent's version to cascade down. This will allow us to increase the version
    as needed in one place, and update all of the subprojects implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The last interesting part of this POM, for those who haven't seen a multi-module
    project before, is the `modules` section. The only thing to note here, for those
    who are new to this, is that each `module` element refers to a directory name,
    which is a direct child of the current directory, and should be declared in the
    order in which they are needed. In our case, the CLI and GUI both depend on the
    library, so `lib` goes first. Next, we'll need to create the POM files for each
    module. Each of these are typical POMs of type jar, so there's no need to include
    them here. There will be varying dependencies in each, but we'll cover those as
    the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Building the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundational piece of this project is the library which both the CLI and
    the GUI will consume, so it makes sense to start here. When designing the library--its
    inputs, outputs, and general behavior--it helps to understand what exactly do
    we want this system to do, so let's take some time to discuss the functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the introduction, we'd like to be able to search for duplicate
    files in an arbitrary number of directories. We'd also like to be able to restrict
    the search and comparison to only certain files. If we don't specify a pattern
    to match, then we want to check every file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part is how to identify a match. There are, of course, a
    myriad of ways in which this can be done, but the approach we will use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify files that have the same filename. Think of those situations where
    you might have downloaded images from your camera to your computer for safekeeping,
    then, later, perhaps you forgot that you had already downloaded the images, so
    you copied them again somewhere else. Obviously, you only want one copy, but is
    the file, for example, `IMG_9615.JPG`, in the temp directory the same as the one
    in your picture backup directory? By identifying files with matching names, we
    can test them to be sure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify files that have the same size. The likelihood of a match here is smaller,
    but there is still a chance. For example, some photo management software, when
    importing images from a device, if it finds a file with the same name, will modify
    the filename of the second file and store both, rather than stopping the import
    and requiring immediate user intervention. This can result in a large number of
    files such as `IMG_9615.JPG` and `IMG_9615-1.JPG`. This check will help identify
    these situations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each match above, to determine whether the files are actually a match, we'll
    generate a hash based on the file contents. If more than one file generates the
    same hash, the likelihood of those files being identical is extremely high. These
    files we will flag as potential duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s a pretty simple algorithm and should be pretty effective, but we do have
    a problem, albeit one that''s likely not immediately apparent. If you have a large
    number of files, especially a set with a large number of potential duplicates,
    processing all of these files could be a very lengthy process, which we would
    like to mitigate as much as possible, which leads us to some non-functional requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The program should process files in a concurrent manner so as to minimize, as
    much as possible, the amount of time it takes to process a large file set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concurrency should be bounded so that the system is not overwhelmed by
    processing the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the potential for a large amount of data, the system must be designed
    in such a way so as to avoid using up all available RAM and causing system instability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that fairly modest list of functional and non-functional requirements,
    we should be ready to begin. Like the last application, let''s start by defining
    our module. In `src/main/java`, we will create this `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the compiler--and the IDE--will complain that the `com.steeplesoft.dupefind.lib`
    package does not exist and won't compile the project. That's fine for now, as
    we'll be creating that package now.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the word **concurrency** in the functional requirements, most likely,
    immediately brings to mind the idea of threads. We introduced the idea of threads
    in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml), *Managing
    Java Processes*, so if you are not familiar with them, review that section in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our use of threading in this project is different from that in the last, in
    that we will have a body of work that needs to be done, and, once it's finished,
    we want the threads to exit. We also need to wait for these threads to finish
    their work so that we can analyze it. In the `java.util.concurrent` package, the
    JDK provides several options to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent Java with a Future interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more common and popular APIs is the `Future<V>` interface. `Future`
    is a means to encapsulate an asynchronous calculation. Typically, the `Future`
    instance is returned by `ExecutorService`, which we'll discuss later. The calling
    code, once it has the reference to `Future`, can continue to work on other tasks
    while `Future` runs in the background in another thread. When the caller is ready
    for the results of `Future`, it calls `Future.get()`. If `Future` has finished
    its work, the call returns immediately with the results. If, however, `Future`
    is still working, calls to `get()` will block until `Future` completes.
  prefs: []
  type: TYPE_NORMAL
- en: For our uses, though, `Future` isn't the most appropriate choice. Looking over
    the non-functional requirements, we see the desire to avoid crashing the system
    by exhausting the available memory explicitly listed out. As we'll see later,
    the way this will be implemented is by storing the data in a lightweight on-disk
    database, and we will implement that--again, as we'll see later-by storing the
    file information as it is retrieved rather than by gathering the data, then saving
    it in a post-process method. Given that, our `Future` won't be returning anything.
    While there is a way to make that work (defining `Future` as `Future<?>` and returning
    `null`), it's not the most natural approach.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most appropriate approach is `ExecutorService`, which is `Executor`
    that provides additional functionality, such as the ability to create a `Future`,
    as discussed earlier, and manage termination of the queue. What, then, is `Executor`?
    `Executor` is a mechanism to execute `Runnable` that is more robust than simply
    calling `new Thread(runnable).start()`. The interface itself is very basic, consisting
    only of the `execute(Runnable)` method, so its value is not immediately apparent
    just from looking at the Javadoc. If, however, you look at `ExecutorService`,
    which is the interface that all `Executor` provided by the JDK implement, as well
    as the various `Executor` implementations, their value easily becomes more apparent.
    Let's take a quick survey now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `Executors` class, we can see five different types of `Executor`
    implementations: a cached thread pool, a fixed-size thread pool, a scheduled thread
    pool, a single thread executor, and a work-stealing thread pool. With the single
    thread `Executor` being the only exception, each of these can be instantiated
    directly (`ThreadPoolExecutor`, `ScheduledThreadPoolExecutor`, and `ForkJoinPool`),
    but users are urged by the JDK authors to use the convenience methods on the `Executors`
    class. That said, what are each of these options and why might you choose one?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Executors.newCachedThreadPool()`: This returns `Executor` that provides a
    pool of cached threads. As tasks come in, `Executor` will attempt to find an unused
    thread to execute the task with. If one cannot be found, a new `Thread` is created
    and the work begins. When a task is complete, `Thread` is returned to the pool
    to await reuse. After approximately 60 seconds, unused threads are destroyed and
    removed from the pool, which prevents resources from being allocated and never
    released. Care must be taken with this `Executor`, though, as the thread pool
    is unbounded, which means that under heavy use, the system could be overwhelmed
    by active threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newFixedThreadPool(int nThreads)`: This method returns an `Executor`
    similar to the one previously mentioned, with the exception that the thread pool
    is bounded to at most `nThreads`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newScheduledThreadPool(int corePoolSize)`: This `Executor` is able
    to schedule tasks to run after an optional initial delay and then periodically,
    based on the delay and `TimeUnit` value. See, for example, the `schedule(Runnable
    command, long delay, TimeUnit unit)` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newSingleThreadExecutor()`: This method will return an `Executor`
    that will use a single thread to execute the tasks submitted to it. Tasks are
    guaranteed to be executed in the order in which they were submitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newWorkStealingExecutor()`: This method will return a so-called
    **work stealing** `Executor`, which is of type `ForkJoinPool`. The tasks submitted
    to this `Executor` are written in such a way as to be able to divide up the work
    to additional worker threads until the size of the work is under a user-defined
    threshold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given our non-functional requirements, the fixed-size `ThreadPoolExecutor` seems
    to be the most appropriate. One configuration option we'll need to support, though,
    is the option to force the generation of hashes for every file found. Based on
    the preceding algorithm, only files that have duplicate names or sizes will be
    hashed. However, users may want a more thorough analysis of their file specification
    and would like to force a hash on every file. We'll implement this using the work-stealing
    (or fork/join) pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our threading approach selected, let''s take a look at the entry point
    for the library, a class we''ll call `FileFinder`. Since this is our entry point,
    it will need to know where we want to search and what we want to search for. That
    will give us the instance variables, `sourcePaths` and `patterns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We're declaring the variables as `private`, as that is a good object-oriented
    practice. We're also declaring them `final`, to help avoid subtle bugs where these
    variables are assigned new values, resulting in the unexpected loss of data. Generally
    speaking, I find it to be a good practice to mark variables as `final` by default
    to prevent such subtle bugs. In the case of instance variables in a class like
    this, a variable can only be declared `final` if it is either immediately assigned
    a value, as we are doing here, or if it is given a value in the class' constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to define our `ExecutorService` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have somewhat arbitrarily chosen to limit our thread pool to five threads,
    as it seems to be a fair balance between providing a sufficient number of worker
    threads for heavy requests, while not allocating a large number of threads that
    may not be used in most cases. In our case, it is probably a minor issue overblown,
    but it's certainly something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to provide a means to store any duplicates found. Consider the
    following lines of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We'll see more details later, but, for now, all that we need to note is that
    this is a `Map` of `List<FileInfo>` objects, keyed by the file hash.
  prefs: []
  type: TYPE_NORMAL
- en: The final variable to make note of is something that might be a bit unexpected--an
    `EntityManagerFactory`. You might be asking yourself, what is that? The `EntityManagerFactory`
    is an interface to interact with a persistence unit as defined by the **Java Persistence
    API** (**JPA**), which is part of the Java Enterprise Edition Specification. Fortunately,
    though, the specification was written in such a way to mandate that it be usable
    in a **Standard Edition** (**SE**) context like ours.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are we doing with such an API? If you'll look back at the non-functional
    requirements, we've specified that we want to make sure that the search for duplicate
    files doesn't exhaust the available memory on the system. For very large searches,
    it is quite possible that the list of files and their hashes can grow to a problematic
    size. Couple that with the memory it will take to generate the hashes, which we'll
    discuss later, and we can very likely run into out-of-memory situations. We will,
    therefore, be using JPA to save our search information in a simple, light database
    (SQLite) that will allow us to save our data to the disk. It will also allow us
    to query and filter the results more efficiently than iterating over in-memory
    structures repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can make use of those APIs, we need to update our module descriptor
    to let the system know that we now require the persistence modules. Consider the
    following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We've declared to the system that we require both `javax.persistence` and `java.logging`,
    which we'll be using later. As we discussed in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, if any one of these modules are not present, the
    JVM instance will fail to start.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the more important part of the module definition is the `exports` clause.
    With this line (there can be 0 or more of them), we're telling the system that
    we are exporting all of the types in the specified package. This line will allow
    our CLI module, which we'll get into later, to use the classes (as well as interfaces,
    enums, and so on, if we were to add any) in that module. If a type's package does
    not `export`, consuming modules will be unable to see the type, which we'll also
    demonstrate later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that understanding, let''s take a look at our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To configure the persistence unit, JPA typically uses a `persistence.xml` file.
    In our case, though, we'd like a bit more control over where the database file
    is stored. As you can see in the preceding code, we are constructing the JDBC
    URL using the `user.home` environment variable. We then store that in a `Map`
    using the JPA-defined key to specify the URL. This `Map` is then passed to the
    `createEntityManagerFactory` method, which overrides anything set in `persistence.xml`.
    This allows us to put the database in the home directory appropriate for the user's
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our class constructed and configured, it''s time to take a look at how
    we''ll find duplicate files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our first step is to create a list of the `PathMatcher` instances based on the
    patterns specified by the user. A `PathMatcher` instance is a functional interface
    that is implemented by objects that attempt to match files and paths. Our instances
    are retrieved from the `FileSystems` class.
  prefs: []
  type: TYPE_NORMAL
- en: When requesting `PathMatcher`, we have to specify the globbing pattern. As can
    be seen in the first call to `map()`, we have to make an adjustment to what the
    user specified. Typically, a pattern mask is specified simply as something like
    `*.jpg`. However, a pattern mask like this won't work in a way that the user expects,
    in that it will only look in the current directory and not walk down into any
    subdirectories. To do that, the pattern must be prefixed with `**/`, which we
    do in the call to `map()`. With our adjusted pattern, we request the `PathMatcher`
    instance from the system's default `FileSystem`. Note that we specify the matcher
    pattern as `"glob:" + p` because we need to indicate that we are, indeed, specifying
    a `glob` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our matchers prepared, we''re ready to start the search. We do that with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Stream` API, we map each source path to a lambda that creates an
    instance of `FindFileTask`, providing it the source path it will search. Each
    of these `FileFindTask` instances will then be passed to our `ExecutorService`
    via the `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileFindTask` method is the workhorse for this part of the process. It
    is a `Runnable` as we''ll be submitting this to the `ExecutorService`, but it
    is also a `FileVisitor<Path>` as it will be used in walking the file tree, which
    we do from the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we will be inserting data into the database via JPA, we'll need to start
    a transaction as our first step. Since this is an application-managed `EntityManager`,
    we have to manage the transaction manually. We acquire a reference to the `EntityTransaction`
    instance outside the `try/catch` block to simplify referencing it. Inside the
    `try` block, we start the transaction, start the file walking via `Files.walkFileTree()`,
    then commit the transaction if the process succeeds. If it fails--if an `Exception`
    was thrown--we roll back the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileVisitor` API requires a number of methods, most of which are not too
    terribly interesting, but we''ll show them for clarity''s sake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we tell the system that if the directory is readable, then we continue
    with walking down that directory. Otherwise, we skip it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The API requires this method to be implemented, but we''re not very interested
    in file read failures, so we simply return a skip result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like the preceding method, this method is required, but we''re not interested
    in this particular event, so we signal the system to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ve come to a method we''re interested in. We will check to make sure
    that the file is readable, then check to see if it''s a match. If it is, we add
    the file. Regardless, we continue walking the tree. How do we test if the file''s
    a match? Consider the following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We iterate over the list of `PathMatcher` instances we passed in to the class
    earlier. If the `List` is empty, which means the user didn't specify any patterns,
    the method's result will always be `true`. However, if there are items in the
    `List`, we use the `anyMatch()` method on the `List`, passing a lambda that checks
    the `Path` against the `PathMatcher` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the file is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We create a `FileInfo` instance, set the properties, then persist it to the
    database via `em.persist()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our tasks defined and submitted to `ExecutorService`, we need to sit back
    and wait. We do that with the following two method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to ask `ExecutorService` to shut down. The `shutdown()` method
    will return immediately, but it will instruct `ExecutorService` to refuse any
    new tasks, as well as shut down its threads as soon as they are idle. Without
    this step, the threads will continue to run indefinitely. Next, we will wait for
    the service to shut down. We specify the maximum wait time to make sure we give
    our tasks time to complete. Once this method returns, we''re ready to process
    the results, which is done in the following `postProcessFiles()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Modern database access with JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's stop here for a moment. Remember our discussion of the **Java Persistence
    API** (**JPA**) and database? Here is where we see that coming in. With the JPA,
    interactions with the database are done via the `EntityManager` interface, which
    we retrieve from the cleverly named `EntityManagerFactory`. It is important to
    note that the `EntityManager` instances are not thread-safe, so they should not
    be shared between threads. That's why we didn't create one in the constructor
    and pass it around. This is, of course, a local variable, so we need not worry
    about that too much until, and if, we decide to pass it as a parameter to another
    method, which we are doing here. As we will see in a moment, everything happens
    in the same thread, so we will not have to worry about thread-safety issues as
    the code stands now.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `EntityManager`, we call the `getDuplicates()` method and pass the
    manager and field name, `fileName`. This is what that method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly straightforward use of the Java Persistence API--we're creating
    a query and telling it that we want, and getting a `List` of `FileInfo` references
    back. The `createQuery()` method creates a `TypedQuery` object, on which we will
    call `getResultList()` to retrieve the results, which gives us `List<FileInfo>`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, we need to have a short primer on the Java Persistence
    API. JPA is what is known as an **object-relational mapping** (**ORM**) tool.
    It provides an object-oriented, type-safe, and database-independent way of storing
    data in, typically, a relational database. The specification/library allows application
    authors to define their data models using concrete Java classes, then persist
    and/or read them with little thought about the mechanics specific to the database
    currently being used. (The developer isn't completely shielded from database concerns--and
    it's arguable as to whether or not he or she should be--but those concerns are
    greatly lessened as they are abstracted away behind the JPA interfaces). The process
    of acquiring a connection, creating the SQL, issuing it to the server, processing
    results, and more are all handled by the library, allowing a greater focus on
    the business of the application rather than the plumbing. It also allows a high
    degree of portability between databases, so applications (or libraries) can be
    easily moved from one system to another with minimal change (usually restricted
    to configuration changes).
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of JPA is `Entity`, the business object (or domain model, if you
    prefer) that models the data for the application. This is expressed in the Java
    code as a **plain old Java object** (**POJO**), which is marked up with a variety
    of annotations. A complete discussion of all of those annotations (or the API
    as a whole) is outside the scope of this book, but we'll use enough of them to
    get you started.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that basic explanation given, let''s take a look at our one and only entity--the
    `FileInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has five properties. The only one that needs special attention is
    `id`. This property holds the primary key value for each row, so we annotate it
    with `@Id`. We also annotate this field with `@GeneratedValue` to indicate that
    we have a simple primary key for which we''d like the system to generate a value.
    This annotation has two properties: `strategy` and `generator`. The default value
    for strategy is `GenerationType.AUTO`, which we happily accept here. Other options
    include `IDENTITY`, `SEQUENCE`, and `TABLE`. In more complex uses, you may want
    to specify a strategy explicitly, which allows you to fine-tune how the key is
    generated (for example, the starting number, the allocation size, the name of
    the sequence or table, and so on). By choosing `AUTO`, we''re telling JPA to choose
    the appropriate generation strategy for our target database. If you specify a
    strategy other than `AUTO`, you will also need to specify the details for the
    generator, using `@SequenceGenerator` for `SEQUENCE` and `@TableGenerator` for
    `TABLE`. You will also need to give the ID of the generator to the `@GeneratedValue`
    annotation using the generator attribute. We''re using the default, so we need
    not specify a value for this attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The next four fields are the pieces of data we have identified that we need
    to capture. Note that if we do not need to specify anything special about the
    mapping of these fields to the database columns, no annotations are necessary.
    However, if we would like to change the defaults, we can apply the `@Column` annotation
    and set the appropriate attribute, which can be one or more of `columnDefinition`
    (used to help generate the DDL for the column), `insertable`, `length`, `name`,
    `nullable`, `precision`, `scale`, `table`, `unique`, and `updatable`. Again, we're
    happy with the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: JPA also requires each property to have a getter and a setter; the specification
    seems to be worded oddly, which has led to some ambiguity as to whether or not
    this is a hard requirement, and different JPA implementations handle this differently,
    but it's certainly safer to provide both as a matter of practice. If you need
    a read-only property, you can experiment with either no setter, or simply a no-op
    method. We haven't shown the getters and setters here, as there is nothing interesting
    about them. We have also omitted the IDE-generated `equals()` and `hashCode()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help demonstrate the module system, we''ve put our entity in a `com.steeplesoft.dupefind.lib.model`
    subpackage. We''ll tip our hand a bit and go ahead and announce that this class
    will be used by both our CLI and GUI modules, so we''ll need to update our module
    definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all there is to our entity, so let''s turn our attention back to our
    application logic. The `createQuery()` call deserves a bit of discussion. Typically,
    when using JPA, queries are written in what is called **JPAQL** (**Java Persistence
    API Query Language**). It looks very much like SQL, but has a more object-oriented
    feel to it. For example, if we wanted to query for every `FileInfo` record in
    the database, we would do so with this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I have put the keywords in all caps, with variable names in lower and the entity
    name in camel case. This is mostly a matter of style, but while most identifiers
    are case-insensitive, JPA does require that the case on the entity name matches
    that of the Java class it represents. You must also specify an alias, or identification
    variable, for the entity, which we simply call `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a specific `FileInfo` record, you can specify a `WHERE` clause as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this query, we can filter the query just as SQL does, and, just like SQL,
    we specify a positional parameter. The parameter can either be a name, like we''ve
    done here, or simply a `?`. If you use a name, you set the parameter value on
    the query using that name. If you use the question mark, you must set the parameter
    using its index in the query. For small queries, this is usually fine, but for
    larger, more complex queries, I would suggest using names so that you don''t have
    to manage index values, as that''s almost guaranteed to cause a bug at some point.
    Setting the parameter can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With that said, let''s take a look at our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This query is moderately complicated, so let's break it down and see what's
    going on. First, in our `SELECT` query, we will specify only `f`, which is the
    identification variable of the entity for which we are querying. Next, we are
    selecting from a regular table and a temporary table, which is defined by the
    subselect in the `FROM` clause. Why are we doing it this way? We need to identify
    all of the rows that have a duplicate value (`fileName`, `size`, or `hash`). To
    do that, we use a `HAVING` clause with the `COUNT` aggregation function, `HAVING
    (COUNT(fieldName > 1))` which says, in effect, give me all of the rows where this
    field occurs more than one time. The `HAVING` clause requires a `GROUP BY` clause,
    and once that's done, all of the rows with duplicate values are aggregated down
    to a single row. Once we have that list of rows, we will then join the real (or
    physical) table to those results to filter our physical table. Finally, we filter
    out the null fields in the `WHERE` clause, then order by `fileName` and `path`
    so that we don't have to do that in our Java code, which is likely to be less
    efficient than it would be if done by the database--a system designed for such
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: You should also note the `%FIELD%` attribute in the SQL. We'll run the same
    query for multiple fields, so we've written the query once, and placed a marker
    in the text that we will replace with the desired field, which is sort of a *poor
    man's* template. There are, of course, a variety of ways to do this (and you may
    have one you find superior), but this is simple and easy to use, so it's perfectly
    acceptable in this environment.
  prefs: []
  type: TYPE_NORMAL
- en: We should also note that it is, generally speaking, a very bad idea to either
    concatenate SQL with values or do string replacements like we're doing, but our
    scenario is a bit different. If we were accepting user input and inserting that
    into the SQL this way, then we would certainly have a target for an SQL injection
    attack. In our use here, though, we aren't taking input from users, so this approach
    should be perfectly safe. In terms of database performance, this shouldn't have
    any adverse effects either. While we will require three different hard parses
    (one for each field by which we will filter), this is no different than if we
    were hardcoding the queries in our source file. Both of those issues, as well
    as many more, are always good to consider as you write your queries (and why I
    said the developer is mostly shielded from database concerns).
  prefs: []
  type: TYPE_NORMAL
- en: 'All of that gets us through the first step, which is identifying all of the
    files that have the same name. We now need to identify the files that have the
    same size, which can be done using the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In our call to find duplicate filenames, we declared a local variable, `files`,
    to store those results. In finding files with duplicate sizes, we call the same
    `getDuplicates()` method, but with the correct field name, and simply add that
    to `files` via the `List.addAll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a complete list of all of the possible duplicates, so we need to
    generate the hashes for each of these to see if they are truly duplicates. We
    will do that with this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, we start a transaction (since we'll be inserting data into the
    database), then loop over each possible duplicate via `List.forEach()` and a lambda
    that calls `calculateHash(f)`, and then pass the `FileInfo` instance. Once the
    loop terminates, we commit the transaction to save our changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does `calculateHash()` do? Let''s a take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simple method encapsulates the work required to read the contents of a
    file and generate a hash. It requests an instance of `MessageDigest` using the
    `SHA3-256` hash, which is one of the four new hashes supported by Java 9 (the
    other three being `SHA3-224`, `SHA3-384`, and `SHA3-512`). Many developers' first
    thought is to reach for MD-5 or SHA-1, but those are no longer considered reliable.
    Using the new SHA-3 should guarantee we avoid any false positives.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the method is pretty interesting in terms of how it does its work.
    First, it reads all of the bytes of the specified file and passes them to `MessageDigest.update()`,
    which updates the internal state of the `MessageDigest` object to give us the
    hash we want. Next, we create a `ByteArrayInputStream` that wraps the results
    of `messageDigest.digest()`.
  prefs: []
  type: TYPE_NORMAL
- en: With our hash ready, we generate a string based on those bytes. We will do that
    by generating a stream via the `IntStream.generate()` method using the `InputStream`
    we just created as a source. We will limit the stream generation to the bytes
    available in the `inputStream`. For each byte, we will convert it to a string
    via `Integer.toHexString()`; then pad it with zero to two spaces, which prevents,
    for example, the single-digit hex characters `E` and `F` from being interpreted
    as `EF`; then collect them all into a string using `Collections.joining()`. Finally,
    we take that string value and update the `FileInfo` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The eagle-eyed might notice something interesting: we call `FileInfo.setHash()`
    to change the value of the object, but we never tell the system to persist those
    changes. This is because our `FileInfo` instance is a managed instance, meaning
    that we got it from JPA, which is keeping an eye on it, so to speak. Since we
    retrieved it via JPA, when we make any changes to its state, JPA knows it needs
    to persist those changes. When we call `em.getTransaction().commit()` in the calling
    method, JPA automatically saves those changes to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a catch to this automatic persistence: if you retrieve an object via
    JPA, then pass it across some sort of barrier that serializes the object, for
    example, across a remote EJB interface, then the JPA entity is said to be "detached".
    To reattach it to the persistence context, you will need to call `entityManager.
    merge()`, after which this behavior will resume. There is no need to call `entityManager.flush()`
    unless you have some need to synchronize the in-memory state of the persistence
    context with the underlying database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve calculated the hashes for the potential duplicates (at this point,
    given that they have duplicate SHA-3 hashes, they are almost certainly actual
    duplicates), we''re ready to gather and report them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the same `getDuplicates()` method to find duplicate hashes, and pass
    each record to the `coalesceDuplicates()` method, which will group these in a
    manner appropriate to report upstream to our CLI or GUI layers, or, perhaps, to
    any other program consuming this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple method follows what is likely a very familiar pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a `List` from a `Map` based on the key, the filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the map doesn't exist, create it and add it to the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `FileInfo` object to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This completes the duplicate file detection. Back in `find()`, we will call
    `factory.close()` to be a good JPA citizen, then return to the calling code. With
    that, we're ready to build our CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Building the command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary means to interact with our new library will be the command-line
    interface we will now develop. Unfortunately, the Java SDK has nothing built in
    to help make sophisticated command-line utilities. If you''ve been using Java
    for any time, you''ve seen the following method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, there is *a* mechanism to process command-line arguments. The `public
    static void main` method is passed string arrays that represent arguments provided
    by the user on the command line, but that''s about as far as it goes. To parse
    the options, the developer is required to iterate over the array, analyzing each
    entry. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is an effective solution, if very naive and error-prone. It assumes that
    whatever follows `--source` and `--target` is that argument's value. If the user
    types `--source --target /foo`, then our processor breaks. Clearly, something
    better is needed. Fortunately, we have options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to search for Java command-line libraries, you''ll find an abundance
    of them (at least 10 at last count). Our space (and time) is limited here, so
    we obviously can''t discuss all of them, so I''ll mention the first three that
    I''m familiar with: Apache Commons CLI, Airline, and Crest. Each of these has
    some fairly significant differences from its competitors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commons CLI takes a more procedural approach; the list of available options,
    its name, description, whether or not it has arguments, and so forth, are all
    defined using Java method calls. Once the list of `Options` has been created,
    the command-line arguments are then manually parsed. The preceding example could
    be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It's certainly more verbose, but it's also clearly, I think, more robust. We
    can specify long and short names for the option (`--source` versus `-s`), we can
    give it a description, and, best of all, we get built-in validation that an option
    has its required value. As much of an improvement as this is, I've learned from
    experience that the procedural approach here gets tedious in practice. Let's take
    a look at our next candidate to see how it fares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Airline is a command-line library originally written as part of the airlift
    organization on GitHub. After languishing for some time, it was forked by Rob
    Vesse and given a new life ([http://rvesse.github.io/airline](http://rvesse.github.io/airline)).
    Airline''s approach to command-line definition is more class-based--to define
    a command utility, you declare a new class, and mark it up appropriately with
    a number of annotations. Let''s implement our preceding simple command line with
    Airline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The options handling continues to grow in terms of code size, but we're also
    gaining more and more clarity as to what options are supported, and what they
    each mean. Our command is clearly defined via `@Command` on the class declaration.
    The possible options are delineated as `@Option`--annotated instance variables,
    and the business logic in `run()` is completely devoid of command-line parsing
    code. By the time this method is called, all the data has been extracted and we're
    ready to do our work. That looks very nice, but let's see what our last contender
    has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Crest is a library from Tomitribe, the company behind TomEE, the "all-Apache
    Java EE Web Profile certified stack" based on the venerable Tomcat Servlet container.
    Crest''s approach to command definition is method based, where you define a method
    per command. It also uses annotations, and offers Bean Validation out of the box,
    as well as optional command discovery. Reimplementing our simple command, then,
    may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems to be the best of both worlds: it''s nice and concise, and will
    still keep the actual logic of the command free from any CLI-parsing concerns,
    unless you''re bothered by the annotations on the method. Although the actual
    logic-implementing code is free from such concerns. While Airline and Crest both
    offer things the other does not, Crest wins for me, so that''s what we''ll use
    to implement our command-line interface.'
  prefs: []
  type: TYPE_NORMAL
- en: With a library chosen, then, let's take a look at what our CLI might look like.
    Most importantly, we need to be able to specify the path (or paths) we want to
    search. Likely, most files in those paths will have the same extension, but that
    certainly won't always be the case, so we want to allow the user to specify only
    the file patterns to match (for example, `.jpg`). Some users might also be curious
    about how long it takes to run the scan, so let's throw in a switch to turn on
    that output. And finally, let's add a switch to make the process a bit more verbose.
  prefs: []
  type: TYPE_NORMAL
- en: With our functional requirements set, let's start writing our command. Crest
    is method-based in its command declarations, but we'll still need a class to put
    our method in. If this CLI were more complicated (or, for example, if you were
    writing a CLI for an application server), you could easily put several CLI commands
    in the same class, or group similar commands in several different classes. How
    you structure them is completely your concern, as Crest is happy with whatever
    you choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with our CLI interface declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can discuss the preceding code, we need to declare our Java module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a new module, which is named similarly to our library's module
    name. We also declared that we `require` two Crest modules.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our source code, we have the four parameters that we discussed in our
    functional requirements. Note that `patterns` and `paths` are defined as `List<String>`.
    When Crest is parsing the command line, if it finds multiple instances of one
    of these (for example, `--path=/path/one--path=/path/two`), it will collect all
    of these values and store them as a `List` for you. Also, note that `verbose`
    and `showTimings` are defined as `boolean`, so we see a nice example of the type
    coercion that Crest will do on our behalf. We also have default values for both
    of these, so we're sure to have sane, predictable values when our method executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business logic of the method is pretty straightforward. We will handle
    the verbose flag upfront, printing a summary of the operation requested as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will perform the actual work. Thanks to the work we did building the
    library, all of the logic for the duplicate search is hidden away behind our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code won''t compile at first, as we''ve not told the system we need it.
    We can do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import the `FileFinder` class. First, to demonstrate that the modules
    are, in fact, doing what they''re supposed to do, let''s try to import something
    that wasn''t exported: `FindFileTask`. Let''s create a simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to compile this, Maven/javac will complain loudly with an error message
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully hidden our utility classes while exposing our public API.
    It may take some time for this practice to become widespread, but it should work
    wonders in preventing the crystallization of private APIs as pseudo-public.
  prefs: []
  type: TYPE_NORMAL
- en: Back on task, we create an instance of our `FileFinder` class, use `String.forEach`
    to pass our `paths` and `patterns` to the finder, then start the work with a call
    to `find()`. The work itself is threaded, but we've exposed a synchronous API,
    so our call here will block until the work has been completed. Once it returns,
    we start printing details to the screen. Since `FindFiles.getDuplicates()` returns
    `Map<String, List<FileInfo>>`, we call `forEach()` on the `Map` to iterate over
    each key, then we call `forEach()` on the `List` to print information about each
    file. We also use an `AtomicInteger` as the index, as the variable must be final
    or effectively final, so we just use a `final` instance of `AtomicInteger`. `BigInteger`
    may come to mind to more experienced developers, but it's immutable, so that makes
    it a poor choice for our use here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of running the command will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we handle `showTimings`. I didn''t call it out in the preceding code,
    though I will now, but we get an `Instant` instance (from the Java 8 date/time
    library in `java.time`) before and after processing. Only when `showTimings` is
    true do we actually do anything with them. The code that does that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With our two `Instant`, we get a `Duration`, then start calculating hours, minutes,
    and seconds. Hopefully, this never runs more than an hour, but it can't hurt to
    be ready for it. And that's all there is to the CLI, in terms of code. Crest did
    the heavy lifting for our command-line parameter parsing, leaving us with a straightforward
    and clean implementation of our logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one last thing we need to add, and that''s the CLI help. It would
    be very helpful for the end user to be able to find out how to use our command.
    Fortunately, Crest has support built in to provide that information. To add the
    help information, we need to create a file called `OptionDescriptions.properties`
    in the same package as our command class (remember that since we''re using Maven,
    this file should be under `src/main/resource`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so will produce an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can be as verbose as you need to be without making your source code an unreadable
    mess.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, our CLI is feature-complete. Before we move on, we need to take
    a look at some build concerns for our CLI and see how Crest fits in. Obviously,
    we need to tell Maven where to find our Crest dependency, which is shown in the
    following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell it where to find our duplicate finder library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note `groupId` and `version`: since our CLI and library modules are part of
    the same parent multi-module build, we set `groupId` and `version` to that of
    the parent module, allowing us to manage that from a single location, which makes
    changing groups or bumping versions much simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting part is the `build` section of our POM. First, let''s
    start with `maven-compiler-plugin`. While we are targeting Java 9, `crest-maven-plugin`,
    which we''ll look at in a moment, does not currently seem to like the classes
    generated for Java 9, so we instruct the compiler plugin to emit Java 1.8 bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set up `crest-maven-plugin`. To expose our command classes
    to Crest, we have two options: we can use runtime scanning for the classes, or
    we can have Crest scan for commands at build time. In order to make this utility
    as small as possible, as well as reducing the startup time as much as possible,
    we will opt for the latter approach, so we will need to add another plugin to
    the build, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When this plugin runs, it will generate a file called `crest-commands.txt` that
    Crest will process to find classes when it starts. It may not save much time here,
    but it's definitely something to keep in mind for larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we don''t want the user to have to worry about setting up the classpath
    (or module path!) each time, so we''ll introduce the Maven Shade plugin, which
    will create a single, fat jar with all of our dependencies, transitive and otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After the build, we can then run a search with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, it can still be improved, so we would want to ship that, say, with
    script wrappers (shell, batch, and so on), but the number of jars is cut down
    from 18 or so to 1, so that's a big improvement.
  prefs: []
  type: TYPE_NORMAL
- en: With our CLI done, let's make a simple GUI that consumes our library as well.
  prefs: []
  type: TYPE_NORMAL
- en: Building the graphical user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our GUI, we''d like to expose the same type of functionality as the command
    line, but, obviously, with a nice graphical interface. For this, we''ll again
    reach for JavaFX. We''ll give the user a means to select, using a chooser dialog,
    the directories to be searched, and a field by which to add the search patterns.
    Once the duplicates have been identified, we will display them in a list for the
    user to peruse. All of the duplicate groups will be listed and, when clicked,
    the files in that group will be displayed in another list. The user can right-click
    on the list and choose to either view the file (or files) or delete it (or them).
    When we are finished, the application will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b580b9aa-0fad-43ba-a9c4-0ec8cdaa3e90.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start by creating our project. In NetBeans, go to File | New Project and
    select Maven | JavaFX Application. You can name it whatever you'd like, but we've
    used the name `Duplicate Finder - GUI`, `groupId` as `com.steeplesoft.dupefind`,
    and `artifactId` as `gui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your project, you should have two classes, `Main` and `FXMLController`,
    as well as the `fxml/Scene.fxml` resource. This may sound repetitive, but before
    we go any further, we need to set up our Java module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to create the interface we saw, we will use `BorderPane`, to which we''ll
    add `MenuBar` to the `top` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When you add `MenuBar` with Scene Builder, it automatically adds several sample
    `Menu` entries for you. We've removed the unwanted entries, and tied the remaining
    to Java methods in the controller class. Specifically, the `Close` menu will call
    `closeApplication()` and `About` will call `showAbout()`. This looks just like
    the menu markup seen previously in the book, so there's not much to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the layout is a bit more complex. In the `left` section, we have
    a number of controls stacked vertically. JavaFX has a built-in container that
    makes that easy to do: `VBox`. We''ll get to its contents in a moment, but its
    usage looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That's not valid FXML, so don't try to copy and paste that. I've omitted the
    details of the children for clarity. As you can see, `VBox` has a number of children,
    each of which will be stacked vertically, but, as we can see from the preceding
    screenshot, there are some we want to be lined up horizontally. To achieve that,
    we nest an `HBox` instance where needed. Its markup looks just like `VBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s not much of interest in this part of the FXML, but there are a couple
    of things to note. We want certain parts of the user interface to shrink and grow
    as the window is resized, namely `ListView`. By default, each component''s various
    height and width properties--minimum, maximum, and preferred--will use the computed
    size, which means, roughly, that they''ll be as big as they need to be to render
    themselves, and, in most cases, that''s fine. In our situation, we want the two
    `ListView` instances to grow as much as possible inside their respective containers,
    which, in this case, is `VBox` we discussed earlier. To make that happen, we need
    to modify our two `ListView` instances like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With both the `ListView` instances set to `ALWAYS` grow, they will compete with
    each other for the available space, and end up sharing it. The available space,
    of course, is dependent on the height of the `VBox` instance, as well as the computed
    height of the other components in the container. With that property set, we can
    increase or decrease the size of the window, and watch the two `ListView` instances
    grow and shrink, while everything else remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of the user interface, we''ll apply the same tactic to arrange
    components, but, this time, we''ll start with an `HBox` instance, and divide that
    up as necessary. We have two `ListView` instances that we also want to fill all
    the available space with, so we mark those up in the same way we did the last
    two. Each `ListView` instance also has a `Label`, so we wrap each `Label`/`ListView`
    pair in a `VBox` instance to get our vertical distribution. In pseudo-FXML, this
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one item of interest in this part of the user interface, and that
    is the context menu we discussed earlier. To add a context to a control, you nest
    a `contextMenu` element in the target control''s FXML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined a content menu with two `MenuItem`: `"Open File(s)..."` and
    `"Deleted File(s)..."`. We''ve also specified the action for the two `MenuItem`
    using the `onAction` attribute. We''ll look at these following methods.'
  prefs: []
  type: TYPE_NORMAL
- en: This marks the end of our user interface definition, so now we turn our attention
    to the Java code, in which we will finish preparing the user interface for use,
    as well as implement our application's logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we didn''t show the FXML that accomplishes this, our FXML file is tied
    to our controller class: `FXMLController`. This class can be called anything,
    of course, but we''ve opted to use the name generated by the IDE. In a larger
    application, more care will need to be given in the naming of this class. To allow
    the injection of our user interface components into our code, we need to declare
    instance variables on our class, and mark them up with the `@FXML` annotation.
    Some examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are several others, but this should be sufficient to demonstrate the concept.
    Note that rather than declaring a plain `ListView`, we've parameterized our instances
    as `ListView<String>` and `ListView<FileInfo>`. We know this is what we're putting
    into the control, so specifying that the type parameter gets us a measure of type
    safety at compile time, but also allows us to avoid having to cast the contents
    every time we interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the collections that will hold the search paths and
    patterns that the user will enter. We''ll use the `ObservableList` instances for
    that. Remember that with an `ObservableList` instance, the container can automatically
    rerender itself as needed when the `Observable` instance is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `initialize()` method, we can start tying things together. Consider
    the following code snippet as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we associate our `ListView` instances with our `ObservableList` instances.
    Now, at any point that these lists are updated, the user interface will immediately
    reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure the duplicate file group `ListView`. The data coming
    back from our library is a `Map` of a `List<FileInfo>` object, keyed by the duplicate
    hashes. Clearly, we don''t want to show the user a list of hashes, so, like the
    CLI, we want to denote each group of files with a more friendly label. To do that,
    we need to create a `CellFactory`, which will, in turn, create a `ListCell` that
    is responsible for rendering the cell. We will do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'While lambdas can be great, in that they tend to make code more concise, they
    can also obscure some details. In a non-lambda code, the lambda above might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You certainly get more detail, but it''s also much harder to read. The main
    point in including both here is twofold: to show why lambdas are often so much
    better, and to show the actual types involved, which helps the lambdas make sense.
    With that understanding of the lambdas under our belts, what is the method doing?'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we call `super.updateItem()`, as that''s simply good practice. Next,
    we find the index of the string being rendered. The API gives us the string (since
    it''s a `ListView<String>`), so we find its index in our `ObservableList<String>`.
    If it''s found, we set the text of the cell to `Group #` plus the index plus one
    (since indexes in Java are typically zero-based). If the string isn''t found (`ListView`
    is rendering an empty cell), we set the text to null to ensure that the field
    is blank.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to perform a similar procedure on `matchingFilesListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is almost identical, but with a couple of exceptions. First, we're setting
    the selection mode of `ListView` to `MULTIPLE`. This will allow the user to control-click
    on items of interest, or shift-click on a range of rows. Next, we set up `CellFactory`
    in an identical fashion. Note that since the `ListView` instance's parameterized
    type is `FileInfo`, the types in the method signature of `ListCell.updateItem()`
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one last user interface setup step. If you look back at the screenshot,
    you will notice that the Find Duplicates button is the same width as `ListView`,
    unlike the other buttons, which are just wide enough to render their content.
    We do that by binding the width of the `Button` element to that of its container,
    which is an `HBox` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We are getting the preferred width property, which is a `DoubleProperty`, and
    binding that to the width property (also a `DoubleProperty`) of `findBox`, the
    control's container. `DoubleProperty` is an `Observable` instance, just as `ObservableListView`
    is, so we're telling the `findFiles` control to observe its container's width
    property, and set its own value accordingly when the other changes. This lets
    us set the property, after a fashion, and then forget about it. Unless we want
    to break the binding between these two properties, we never again have to think
    about it, and we certainly don't need to manually watch one property to update
    the author. The framework does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about those buttons? How do we make them do something? We do that
    by setting the `onAction` property of the `Button` element to a method in our
    controller: `#someMethod` translates to `Controller.someMethod(ActionEvent event)`.
    We can handle this in one of at least two ways: we can create a separate handler
    method for each button, or, as we''ve done here, we can create one, then delegate
    to another method as appropriate; either is fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure we''re actually getting a `Button` element, then we cast
    it and compare it to the instances that were injected. The actual handlers for
    each button are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: To add a pattern, we create a `TextInputDialog` instance with the appropriate
    text, then call `showAndWait()`. The beauty of this method in JavaFX 8 is that
    it returns `Optional<String>`. If the user enters text in the dialog, and if the
    user clicks on OK, the `Optional` will have content. We identify that with the
    call to `ifPresent()`, passing it a lambda that adds the new pattern to `ObservableList<String>`,
    which automatically updates the user interface. If the user doesn't click on OK,
    the `Optional` will be empty. If the user didn't enter any text (or entered a
    bunch of spaces), the call to `filter()` will prevent the lambda from ever running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an item is similar, though we get to hide some of the details in a
    utility method, since we have two needs for the functionality. We make sure something
    is selected, then show a confirmation dialog, removing the pattern from the `ObservableList<String>`
    if the user clicks on OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `showConfirmationDialog` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is much like the dialogs earlier, and should be self-explanatory.
    The interesting part here is the use of a lambda as a method parameter that makes
    this, by the way, a higher order function--meaning it takes in a function as a
    parameter, returns a function as its result, or both. We pass in `Runnable`, as
    we want a lambda that takes in nothing and returns nothing, and `Runnable` is
    a `FunctionalInterface` that matches that description. After we show the dialog
    and get the user's response, we will filter for only responses where the button
    clicked on was `OK`, and, if present, we execute `Runnable` via `action.run()`.
    We have to specify `b -> action.run()` as `ifPresent()` takes a `Consumer<? super
    ButtonType>`, so we create one and ignore the value passed in, allowing us to
    shield our calling code from that detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a path requires a `DirectoryChooser` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When creating the `DirectoryChooser` instance, we set the initial directory
    to the last directory used as a convenience for the user. When the application
    starts, this defaults to the user's home directory, but once a directory is successfully
    chosen, we set `lastDir` to the added directory's parent, allowing the user to
    start where he or she left off should there be a need to enter multiple paths.
    `DirectoryChooser.showDialog()` returns a file, so we get its canonical path and
    store that in paths, which, again, causes our user interface to be updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a path looks very similar to removing a pattern, as you can see in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Same basic code, just a different lambda. Aren't lambdas just the coolest?
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler for the `findFiles()` button is a bit different, but looks a lot
    like our CLI code, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We create our `FileFinder` instance, set the paths and patterns using streams
    and lambdas, then start the search process. When it completes, we get the list
    duplicate file information via `getDuplicates()`, then create a new `ObservableList<String>`
    instance using the keys of the map, which we then set on `dupeFileGroupListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the logic to handle mouse clicks on the group list, so we
    will set the `onMouseClicked` property on `ListView` in the FXML file to `#dupeGroupClicked`,
    as you can see in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'When the control is clicked on, we get the index and make sure it is non-negative,
    so as to ensure that the user actually clicked on something. We then get the hash
    of the group by getting the selected item from `ListView`. Remember that while
    `ListView` may show something like `Group #2`, the actual content of that row
    is the hash. We just used a custom `CellFactory` to give it a prettier label.
    With the hash, we clear the list of items in `matchingFilesListView`, then get
    the control''s `ObservableList` and add all of the `FileInfo` objects in the `List`
    keyed by the hash. And, again, we get an automatic user interface update, thanks
    to the power of `Observable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want the user to be able to navigate the list of duplicate groups using
    the keyboard to update the matching file list. We do that by setting the `onKeyPressed`
    attribute on our `ListView` to point to this rather simple method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It just so happens that we're not too terribly interested in the actual `Event`
    in either of these methods (they're never actually used), so we can naively delegate
    to the mouse-click method discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more minor pieces of functionality we need to implement: viewing
    the matching files and deleting matching files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already created the context menu and menu entries, so all we need to
    do is implement the handler methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The matching file list allows multiple selections, so we need to get `List<FileInfo>`
    from the selection model instead of the single object we''ve already seen. We
    then call `forEach()` to process the entry. We want to open the file in whatever
    application the user has configured in the operating system to handle that file
    type. To do this, we use an AWT class introduced in Java 6: `Desktop`. We get
    the instance via `getDesktop()`, then call `open()`, passing it `File` that points
    to our `FileInfo` target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting a file is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to open files, we get all of the selected files. If there's at least
    one, we confirm the user's intent via `showConfirmationDialog()`, and pass in
    a lambda that handles the deleting. We do the actual file deletion using the `Desktop`
    class again to move the file to the trash can provided by the filesystem to provide
    the user with a safe delete option. If the file is successfully deleted, we remove
    its entry from `ObservableList`, as well as our cache duplicate file `Map`, so
    that it isn't shown should the user click on this file group again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our application is done. So, what have we covered? From the project
    description, this seemed like a pretty simple application, but as we started breaking
    down the requirements and delving into the implementation, we ended up covering
    a lot of territory--a scenario that is not at all uncommon. We built another multi-module
    Maven project. We introduced Java concurrency, including basic `Thread` management
    and `ExecutorService` usage, as well as the Java Persistence API, showing basic
    `@Entity` definition, `EntityManagerFactory/EntityManager` usage, and JPAQL query
    authoring. We discussed creating file hashes using the `MessageDigest` classes,
    and demonstrated the new file I/O APIs, including the directory tree walking APIs.
    We also built a more complex user interface in JavaFX using nested containers,
    "linked" `ListView` instances, and bound properties.
  prefs: []
  type: TYPE_NORMAL
- en: That's quite a bit for such a "simple" project. Our next project will also be
    relatively simple, as we build a command-line date calculator that will allow
    us to explore the `java.time` package and see some of what this new date/time
    API offers.
  prefs: []
  type: TYPE_NORMAL

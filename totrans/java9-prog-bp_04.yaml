- en: Date Calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been developing in Java for any serious length of time, you know one
    thing to be true--working with dates is awful. The `java.util.Date` class, with
    its related classes, shipped with 1.0, and `Calendar` and its related classes
    coming along in 1.1\. Even early on, problems were apparent. For example, the
    Javadoc on `Date` says this--*Unfortunately, the API for these functions was not
    amenable to internationalization*. As a result, `Calendar` was introduced in 1.1\.
    Sure, there have been other enhancements down through the years, but given Java's
    strict adherence to backwards compatibility, there's only so much the language
    architects can do. As much as they may want to fix those APIs, their hands are
    tied.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, **Java Specification Request** (**JSR 310**) was filed. Led by
    Stephen Colebourne, an effort was begun to create a new API, based on the very
    popular open source library, Joda-Time. In this chapter, we'll take an in-depth
    look at this new API, then build a simple command-line utility to perform date
    and time math, which will give us an opportunity to see some of this API in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter, then, will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java 8 Date/Time API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting command-line utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the project in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, this project is fairly simple, conceptually. The
    end goal is a command-line utility to perform various date and time calculations.
    However, while we're at it, it would be very nice if the actual date/time work
    were to be put in a reusable library, so that's what we'll do. This leaves us
    with two projects, which we'll set up, like last time, as a multi-module Maven
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent POM will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you read [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*, or have worked with multi-module Maven builds before,
    there's nothing new here. It's included simply for completeness. If this is foreign
    to you, take a moment to review the first few pages of Chapter 2 before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Building the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''d like to be able to reuse this tool in other projects, we''ll start
    by building a library that exposes its functionality. All of the functionality
    we''ll need is built into the platform, so our POM file is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are **almost** no external dependencies. The only dependency listed is
    on the testing library, TestNG. We didn't talk much about testing in the last
    chapter (rest assured, there are tests in the project). In this chapter, we'll
    introduce the topic of testing and show some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to define our module. Remember that these are Java 9 projects,
    so we want to make use of the module functionality to help protect our internal
    classes from accidental public exposure. Our module is very simple. We need to
    give it a name, then export our public API package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since everything we need is already in the JDK, we have nothing to declare beyond
    what we export.
  prefs: []
  type: TYPE_NORMAL
- en: With our project set up, let's take a quick look at the functional requirements.
    Our intent with this project is to build a system that allows the user to provide
    an arbitrary string representing a date or time calculation expression and get
    a response. The string may look something like `"today + 2 weeks"` to find out
    the date 2 weeks from today, `"now + 3 hours 15 minutes"` to find out what time
    it is in 3 hours and 15 minutes, or `"2016/07/04 - 1776/07/04"` to find out how
    many years, months, and days are between the two dates. The processing of these
    expressions will be one line at a time, so the ability to pass in, for example,
    a text document with multiple expressions and get multiple results is explicitly
    excluded from the scope. This can be implemented easily enough, of course, by
    any consuming application or library.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have a project set up and ready to go, and we have a rough sketch
    of its fairly simple functional requirements. We're ready to start coding. Before
    we do that, let's take a quick tour of the new `java.time` package to get a better
    sense of what we'll be seeing in this project, as well as some of the functionality
    we **won't** be using in this simple project.
  prefs: []
  type: TYPE_NORMAL
- en: A timely interlude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 8, two primary date-related classes were `Date` and `Calendar`
    (and, of course, `GregorianCalendar`). The new `java.time` package offers several
    new classes, such as `Duration`, `Period`, `Clock`, `Instant`, `LocalDate`, `LocalTime`,
    `LocalDateTime`, and `ZonedDateTime`. There is a plethora of supporting classes,
    but these are the primary starting points. Let's take a quick look at each.
  prefs: []
  type: TYPE_NORMAL
- en: Duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Duration` is a **time-based unit of time**. While it may sound odd to phrase
    it that way, the wording was chosen to distinguish it from a date-based unit of
    time, which we''ll look at next. In plain English, it''s a measurement of time,
    such as **10 seconds**, **1 hour**, or **100 nanoseconds**. `Duration` is measured
    in seconds, but there are a number of methods to get a representation of the duration
    in other units of measure, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getNano()`: This is `Duration` in nanosecods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSeconds()`: This is `Duration` in seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(TemporalUnit)`: This is `Duration` in a unit of measure specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a variety of arithmetic methods, which are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`/`minus (int amount, TemporalUnit unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add`/`minus (Duration)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addDays`/`minusDays(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addHours`/`minusHours(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addMillis`/`minusMillis(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addMinutes`/`minusMinutes(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addNanos`/`minusNanos(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addSeconds`/`minusSeconds(long)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dividedBy`/`multipliedBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also have a number of convenient factory and extraction methods, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ofDays(long)`/`toDays()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ofHours(long)`/``toHours()``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ofMinutes(long)`/`toMinutes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ofSeconds(long)`/`toSeconds()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `parse()` method is also supplied. Unfortunately, perhaps, for some, the
    input for this method may not be what you might expect. Since we''re dealing with
    a duration that is often, say, in hours and minutes, you might expect the method
    to accept something like "1:37" for 1 hour and 37 minutes. However, that will
    cause the system to throw `DateTimeParseException`. What the method expects to
    receive is a string in an ISO-8601 format, which looks like this--`PnDTnHnMn.nS`.
    That''s pretty fantastic, isn''t it? While it may be confusing at first, it''s
    not too bad once you understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: The first character is an optional `+` (plus) or `-` (minus) sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next character is `P` and can be either uppercase or lowercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What follows is at least one of four sections indicating days (`D`), hours (`H`),
    minutes (`M`), and seconds (`S`). Again, case doesn't matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They must be declared in this order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each section has a numeric part that includes an optional `+` or `-` sign, one
    or more ASCII digits, and the unit of measure indicator. The seconds amount may
    be fractional (expressed as a floating point number) and may use a period or a
    comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The letter `T` must come before the first instance of hours, minutes, or seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple, right? It may not be very friendly to a non-technical audience, but
    that it supports encoding a duration in a string that allows unambiguous parsing
    is a huge step forward.
  prefs: []
  type: TYPE_NORMAL
- en: Period
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Period` is a date-based unit of time. Whereas `Duration` was about time (hours,
    minutes, seconds, and so on), `Period` is about years, weeks, months, and so forth.
    Like `Duration`, it exposes several arithmetic methods to add and subtract, though
    these deal with years, months, and days. It also offers `plus(long amount, TemporalUnit
    unit)` (and the equivalent `minus`) as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, like `Duration`, `Period` has a `parse()` method, which also takes an
    ISO-8601 format that looks like this--`PnYnMnD` and `PnW`. Based on the discussion
    earlier, the structure is probably pretty obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: The string starts with an optional sign, followed by the letter `P`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, for the first form, come three sections, at least one of which must
    be present--years (`Y`), months(`M`), and days (`D`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the second form, there is only one section--weeks (`W`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount in each section can have a positive or negative sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `W` unit can't be combined with the others. Internally, the amount is multiplied
    by `7` and treated as days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Clock` is an abstract class that provides access to the current instant (which
    we will see next), date, and time using a timezone. Prior to Java 8, we would
    have to call `System.currentTimeInMillis()` and `TimeZone.getDefault()` to calculate
    these values. `Clock` provides a nice interface to get that from one object.'
  prefs: []
  type: TYPE_NORMAL
- en: The Javadoc states that the use of `Clock` is purely optional. In fact, the
    major date/time classes have a `now()` method that uses the system clock to get
    their value. If, however, you need to provide an alternate implementation (say,
    in testing, you need the `LocalTime` in another timezone), this abstract class
    can be extended to provide the functionality needed, and can then be passed to
    the appropriate `now()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Instant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `Instant` is a single, exact point in time (or **on the timeline**, you'll
    see the Javadoc say). This class offers arithmetic methods, much like `Period`
    and `Duration`. Parsing is also an option, with the string being an ISO-8601 instant
    format such as `1977-02-16T08:15:30Z`.
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LocalDate` is a date without a timezone. While the value of this class is
    a date (year, month, and day), there are accessor methods for other values, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getDayOfWeek()`: This returns the `DayOfWeek` enum for the day of the week
    represented by the date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDayOfYear()`: This returns the day of the year (1 to 365, or 366 for leap
    years) represented by the date. This is a 1-based counter from January 1 of the
    specified year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getEra()`: This returns the ISO era for the given date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local dates can be parsed from a string, of course, but, this time, the format
    seems much more reasonable--`yyyy-mm-dd`. If you need a different format, the
    `parse()` method has been overridden to allow you to specify the `DateTimeFormatter`
    that can handle the format of the string.
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LocalTime` is the time-based equivalent of `LocalDate`. It stores `HH:MM:SS`,
    but does **not** store the timezone. Parsing times requires the format above,
    but, just like `LocalDate`, does allow you to specify a `DateTimeFormatter` for
    alternate string representations.'
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LocalDateTime` is basically a combination of the last two classes. All of
    the arithmetic, factory, and extraction methods apply as expected. Parsing the
    text is also a combination of the two, except that `T` must separate the date
    and time portions of the string--`''2016-01-01T00:00:00''`. This class **does
    not** store or represent a timezone.'
  prefs: []
  type: TYPE_NORMAL
- en: ZonedDateTime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to represent a date/time **and** a timezone, then `ZonedDateTime`
    is the class you need. As you might expect, this class' interface is a combination
    of `LocalDate` and `LocalTime`, with extra methods added for handling the timezone.
  prefs: []
  type: TYPE_NORMAL
- en: As shown at length in the overview of duration's API (and hinted at, though
    not as clearly shown in the other classes), one of the strong points of this new
    API is the ability to manipulate and process various date and time artifacts mathematically.
    It is precisely this functionality that we will spend most of our time with in
    this project as we explore this new library.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of the process we need to tackle is parsing the user-provided
    string into something we can use programmatically. If you were to search for a
    parser generator, you would find a myriad of options, with tools such as Antlr
    and JavaCC showing up near the top. It''s tempting to turn to one of these tools,
    but our purposes here are pretty simple, and the grammar is not all that complex.
    Our functional requirements include:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to add/subtract time to/from a date or a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be able to subtract one date or time from another to get the difference
    between the two
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be able to convert a time from one timezone to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For something as simple as this, a parser is far too expensive, both in terms
    of complexity and binary size. We can easily write a parser using tools built
    into the JDK, which is what we'll do.
  prefs: []
  type: TYPE_NORMAL
- en: To set the stage before we get into the code, the plan is this--we will define
    a number of **tokens** to represent logical parts of a date calculation expression.
    Using regular expressions, we will break down the given string, returning a list
    of these tokens, which will then be processed **left to right** to return the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: That said, let's make a list of the types of token we'll need. We'll need one
    for a date, a time, the operator, any numeric amount, the unit of measure, and
    the timezone. Obviously, we won't need each of these for every expression, but
    that should cover all of our given use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a base class for our tokens. When defining a type hierarchy,
    it''s always good to ask whether you want a base class or an interface. Using
    an interface gives the developer extra flexibility with regard to the class hierarchy
    should the need arise to extend a different class. A base class, however, allows
    us to provide default behavior at the cost of some rigidity in the hierarchy of
    the type. To make our `Token` implementations as simple as possible, we''d like
    to put as much in the base class as possible, so we''ll use a base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Java 8 did introduce a means to provide default behavior from an interface,
    that being a **default methods**. A default method is a method on an interface
    that provides a concrete implementation, which is a significant departure from
    interfaces. Prior to this change, all interfaces could do was define the method
    signature and force the implementing class to define the body. This allows us
    to add methods to an interface and provide a default implementation so that existing
    implementations of the interface need not change. In our case, the behavior we're
    providing is the storing of a value (the instance variable `value`) and the accessor
    for it (`getValue()`), so an interface with a default method is not appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've also defined a nested interface, `Info`, which we will cover
    in more detail when we get to the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our base class defined, we can now create the tokens we will need as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the class, we define two constants. `TODAY` is a special string that
    we will allow the user to specify today''s date. The second is the regular expression
    we''ll use to identify a date string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s no secret that regular expressions are ugly, and as these things go,
    this one''s not too terribly complicated. We''re matching 4 digits (`\\d{4}`),
    either a - or / (`[-/]`), a 0 or 1 followed by any digit (`[01]\\d`), another
    - or /, then a 0, 1, 2, or 3 followed by any digit. Finally, the last segment,
    `|today`, tells the system to match on the pattern that comes before, **or** the
    text `today`. All this regular expression can do is identify a string that **looks**
    like a date. In its current form, it can''t actually ensure that it is valid.
    We can probably make a regex that can do exactly that, but the complexity that
    would introduce is just not worth it. What we can do though is let the JDK validate
    the string for us, which we''ll do in the `of` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've defined a static method to handle the creation of the `DateToken`
    instance. If the user provides the string `today`, we provide the value `LocalDate.now()`,
    which does what you think it might. Otherwise, we pass the string to `LocalDate.parse()`,
    changing any forward slashes to dashes, as that's what the method expects. If
    the user provided an invalid date, but the regular expression still matched it,
    we'll get an error here. Since we have built-in support to validate the string,
    we can content ourselves with letting the system do the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tokens look very similar. Rather than showing each class, much of
    which would be very familiar, we''ll skip most of those classes and just look
    at the regular expressions, as some are quite complex. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that one''s not too bad, is it? One or more digits will match here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another relatively simple one, which will match a +, a -, or the `to` text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The regular expression breaks down like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(?:`: This is a non-capturing group. We need to group some rules together,
    but we don''t want them to show up as separate groups when we process this in
    our Java code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[01]?`: This is a zero or a one. The `?` indicates that this should occur
    once or not at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|2[0-3]`: We either want to match the first half, **or** this section, which
    will be a 2 followed by a 0, 1, 2, or 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`)`: This ends the non-capturing group. This group will allow us to match 12
    or 24-hour times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:`: This position requires a colon. Its presence is not optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[0-5]\\d`: Next, the pattern must match a digit of `0-5` followed by another
    digit. This is the minutes portion of the time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`'' *''`: It''s hard to see, so I''ve added quotes to help indicate it, but
    we want to match 0 or more (as indicated by the asterisk) spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:`: This is another non-capturing group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[AaPp][Mm]`: These are the `A` or `P` letters (of either case) followed by
    an `M` (also of either case).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`)?`: We end the non-capturing group, but mark it with a `?` to indicate that
    it should occur once or not all. This group lets us capture any `AM`/`PM` designation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|now`: Much like today above, we allow the user to specify this string to
    indicate the current time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, this pattern may match an invalid time string, but we''ll let `LocalTime.parse()`
    handle that for us in `TimeToken.of()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit more complex than others, primarily because of the default format
    expected by `LocalTime.parse()`, which is an ISO-8601 time format. Typically,
    time is specified in a 12-hour format with an am/pm designation. Unfortunately,
    that's not how the API works, so we have to make adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: First, we pad the hour, if needed. Second, we look to see if the user specified
    `"am"` or `"pm"`. If so, we need to create a special formatter, which is done
    via `DateTimeFormatterBuilder`. We start by telling the builder to build a case-insensitve
    formatter. If we don't do that, `"AM"` will work, but `"am"` will not. Next, we
    append the pattern we want, which is hours, minutes, and am/pm, then build the
    formatter. Finally, we can parse our text, which we do by passing the string and
    the formatter to `LocalTime.parse()`. If all goes well, we'll get a `LocalTime`
    instance back. If not, we get an `Exception` instance, which we will handle. Note
    that we call `replaceAll()` on our string. We do that to strip any spaces out
    between the time and am/pm. Otherwise, the parse will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to our `UnitOfMeasureToken`. This token isn''t necessarily
    complex, but it''s certainly not simple. For our units of measure, we want to
    support the words `year`, `month`, `day`, `week`, `hour`, `minute`, and `second`,
    all of which can be plural, and most of which can be abbreviated to their initial
    character. This makes the regular expression interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's not so much complex as ugly. We have a list of possible strings, separated
    by the logical `OR` operator, the vertical pipe. It is probably possible to write
    a regular expression that searches for each word, or parts of it, but such an
    expression will likely be very difficult to write correctly, and almost certainly
    hard to debug or change. Simple and clear is almost always better than clever
    and complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one last element here that needs discussion: `VALID_UNITS`. In a static
    initializer, we build a `Map` to allow looking up the correct `ChronoUnit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to take a look at the parser, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build our parser, we register each of our `Token` classes in a `List`,
    but we see two new types: `Token.Info` and `InfoWrapper`. `Token.Info` is an interface
    nested inside the `Token` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added this interface to give us a convenient way to get the regular
    expression for a `Token` class, as well as the `Token`, without having to resort
    to reflection. `DateToken.Info`, for example, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a nested class, we get easy access to members, including statics,
    of the enclosing class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next new type, `InfoWrapper`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple, private class, so some of the normal encapsulation rules
    can be set aside (although, should this class ever be made public, this would
    certainly need to be cleaned up). What we''re doing, though, is storing a compiled
    version of the token''s regular expression. Note that we''re wrapping the regular
    expression with a couple of extra characters. The first, the caret (`^`), says
    that the match must be at the beginning of the text. We''re also wrapping the
    regular expression in parentheses. However, this time this is a capturing group.
    We''ll see why in the following parse method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start by making sure that `text` is not null, then `trim()` it, then make
    sure it's not empty. With the sanity checks done, we loop through the `List` of
    info wrappers to find a match. Remember that the pattern compiled is a capturing
    group looking at the start of the text, so we loop through each `Pattern` until
    one matches. If we don't find a match, we throw an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we find a match, we extract the matching text from `Matcher`, then, using
    `Token.Info`, we call `getToken()` to get a `Token` instance for the matching
    `Pattern`. We store that in our list, then recursively call the `parse()` method,
    passing a substring of text starting after our match. That removes the matched
    text from the original, then repeats the process until the string is empty. Once
    the recursion ends and things unwind, we return a `Queue` of tokens that represent
    the string the user provided. We use a `Queue` instead of, say, a `List`, as that
    will make processing a bit easier. We now have a parser, but our work is only
    half done. Now we need to process those tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the spirit of Separation of Concerns, we''ve encapsulated the processing
    of these tokens--the actual calculation of the expression--in a separate class,
    `DateCalculator`, which uses our parser. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each time `calculate()` is called, we create a new instance of the parser. Also,
    note that, as we look at the rest of the code, we pass the `Queue` around. While
    that does make the method signatures a bit bigger, it also makes the class thread-safe,
    as there's no state held in the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: After our `isEmpty()` check, we can see where the `Queue` API comes in handy.
    By calling `poll()`, we get a reference to the next element in the collection,
    but--and this is important--**we leave the element in the collection**. This lets
    us look at it without altering the state of the collection. Based on the type
    of the first element in the collection, we delegate to the appropriate method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For handling dates, the expression syntax is `<date> <operator> <date | number
    unit_of_measure>`. We can start our processing, then, by extracting a `DateToken`
    and an `OperatorToken`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve an element from a `Queue`, we use the `poll()` method, and we can
    safely cast that to `DateToken` since we checked that in the calling method. Next,
    we `peek()` at the next element and, via the `validateToken()` method, we verify
    that the element is not null and is of the type desired. If the token is valid,
    we can `poll()` and cast safely. Next, we `peek()` at the third token. Based on
    its type, we delegate to the correct method to finish the processing. If we find
    an unexpected `Token` type, we throw an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking at those calculation methods, let''s look at `validateToken()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing too terribly exciting here, but eagle-eyed readers might notice
    that we're returning the class name of our token, and, by doing so, we're leaking
    the name of a non-exported class to the end user. That's probably not ideal, but
    we'll leave fixing that as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to perform date math looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have our starting and operator tokens, we pass those in, as
    well as the `Queue` so that we can process the remaining tokens. Our first step
    is to determine if the operator is a plus or a minus, assigning a positive `1`
    or a `-1` to `negate` as appropriate. We do this so we can use a single method,
    `LocalDate.plus()`. If the operator is a minus, we add a negative number and get
    the same result as subtracting the original number.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we loop through the remaining tokens, verifying each one before we
    process it. We get the `IntegerToken`; grab its value; multiply it by our negative
    modifier, `negate`; then add that value to the `LocalDate` using the `UnitOfMeasureToken`
    to tell what **kind** of value we're adding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the difference between dates is pretty straightforward, as we see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We extract the `LocalDate` from our two `DateToken` variables, then call `Period.between()`,
    which returns a `Period` that indicates the elapsed amount of time between the
    two dates. We do check to see which date comes first so that we return a positive
    `Period` to the user as a convenience, since most people don't typically think
    in terms of negative periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time-based methods are largely identical. The big difference is the time
    difference method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The notable difference here is the use of `Duration.between()`. It looks identical
    to `Period.between()`, but the `Duration` class offers a method that `Period`
    does not: `abs()`. This method lets us return the absolute value of `Period`,
    so we can pass our `LocalTime` variable to `between()` in any order we want.'
  prefs: []
  type: TYPE_NORMAL
- en: One final note before we leave this--we are wrapping our results in a `DateCalculatorResult`
    instance. Since the various operations return several different, unrelated types,
    this allows us to return a single type from our `calculate()` method. It will
    be up to the calling code to extract the appropriate value. We'll do that in our
    command-line interface, which we'll look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A brief interlude on testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, we need to visit a topic we've not discussed yet, that being
    testing. Anyone who has been in the industry for a while has likely heard the
    term **Test-Driven Development** (or **TDD** for short). It's an approach to software
    development that posits that the first thing that should be written is a test,
    which will fail (since there's no code to run), then the code should be written
    that makes the test **green**, a reference to the green indicator given in IDEs
    and other tools to indicate that the test has passed. This process repeats as
    many times as necessary to build the final system, always making changes in small
    increments, and always starting with a test. A myriad of books have been written
    on the topic, which is both hotly debated and oftentimes heavily nuanced. The
    exact way the approach is implemented, if at all, almost always comes in flavors.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, in our work here, we haven't followed the TDD principle strictly, but
    that doesn't mean we haven't tested. While TDD purists are likely to quibble,
    my general approach tends to be a bit looser on the testing side until my API
    starts to solidify some. How long this takes depends on how familiar I am with
    the technologies being used. If I'm very familiar with them, I might sketch out
    a quick interface, then scaffold a test based on that as a means of testing the
    API itself, then iterate over that. For new libraries, I might write a very broad
    test to help drive the investigation of the new library, using the test framework
    as a means for bootstrapping a runtime environment in which I can experiment.
    Regardless, at the end of the development effort, the new system should be **fully**
    tested (with the exact definition of **fully** being another hotly debated concept),
    which is what I have striven for here. A full treatise on testing and test-driven
    development is beyond our scope here, though.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to testing in Java, you have a **lot** of options. However, the
    two most common ones are TestNG and JUnit, with JUnit probably being the most
    popular. Which one should you pick? That depends. If you are working with an existing
    code-base, you should probably use whatever is already in use, unless you have
    a good reason to do otherwise. For example, the library could be old and no longer
    supported, it could be demonstrably insufficient for your needs, or you've been
    given an express directive to update/replace the existing system. If any of those
    conditions, or others similar to these, are true, we circle back to the question--*Which
    should I choose?* Again, that depends. JUnit is extremely popular and common,
    so using it might make sense in order to lower the barrier of entry into a project.
    However, TestNG has what some feel to be a much better, cleaner API. For example,
    TestNG does not require the use of static methods for certain test setup methods.
    It also aims to be much more than just a unit testing framework, providing tools
    for unit, functional, end-to-end, and integration testing. For our tests here,
    we will be using TestNG.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with TestNG, we need to add it to our project. To do that, we
    will add a test dependency to the Maven POM file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Writing the tests is very simple. With the defaults of the TestNG Maven plugin,
    the class simply needs to be in `src/test/java` and end with the `Test` string.
    Each test method needs to be annotated with `@Test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of tests in the library module, so let''s start with some
    of the very basic ones that test the regular expressions used by the tokens to
    identify and extract the relevant parts of the expression. For example, consider
    the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very basic test of the `DateToken` regular expression. The test delegates
    to the `testPattern()` method, passing the regular expression to test, and a string
    to test it with. Our functionality is tested by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the `Pattern`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a `Matcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the `matcher.find()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, the logic of the system under test is exercised. What remains is
    to verify that it worked as expected. We do that with our call to `Assert.assertTrue()`.
    We assert that `matcher.find()` returns `true`. If the regex is correct, we should
    get a `true` response. If the regex is not correct, we'll get a `false` response.
    In the latter case, `assertTrue()` will throw an `Exception` and the test will
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: This test is certainly very basic. It could--should--be more robust. It should
    test a greater variety of strings. It should include some strings known to be
    bad to make sure we're not getting incorrect results in our tests. There are probably
    a myriad of other enhancements that could be made. The point here, though, is
    to show a simple test to demonstrate how to set up a TestNG-based environment.
    Before moving on, let's look at a couple more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a test to check for failure (a **negative test**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we expect the call to `parse()` to fail, with a `DateCalcException`.
    Should the call **not** fail, we have a call to `Assert.fail()` that will force
    the test to fail with the message provided. If the `Exception` is thrown, it's
    swallowed silently and the test finishes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swallowing the `Exception` is one approach, but you can also tell TestNG to
    expect an `Exception` to be thrown, as we''ve done here via the `expectedExceptions`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, we're passing a bad string to the parser. However, this time, we're telling
    TestNG to expect the exception via the annotation--`@Test(expectedExceptions =
    {DateCalcException.class})`.
  prefs: []
  type: TYPE_NORMAL
- en: Much more could be written on testing in general and TestNG in particular. A
    thorough treatment of both topics is beyond our scope, but if you are not familiar
    with either topic, you would be well served to find one of the many great resources
    available and study them thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's turn our attention to the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Building the command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built a command-line tool using the Crest library from
    Tomitribe, and it worked out pretty well, so we will return to the library in
    building this command line as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Crest in our project, we must do two things. First, we have to configure
    our POM file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also update our module definition in `src/main/java/module-info.java`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define our CLI class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in the last chapter, this command line will be extremely simple, as the
    only input we need is the expression to evaluate. With the preceding method signature,
    we tell Crest to pass all of the command-line arguments as the `args` value, which
    we then join back together via `String.join()` into `expression`. Next, we create
    our calculator and calculate the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to interrogate our `DateCalcResult` to determine the nature of
    the expression. Consider the following piece of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LocalDate` and `LocalTime` responses are pretty straightforward--we can
    simply call the `toString()` method on them, as the defaults are, for our purposes
    here, perfectly acceptable. Duration and periods are a bit more complicated. Both
    provide a number of methods to extract the details. We will hide those details
    in separate methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The method itself is pretty simple--we extract the various parts from `Duration`,
    then build the string based on whether or not the part returns values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The date-related method, `processPeriod()`, is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Each of these methods returns the result as a string, which we then write to
    standard out. And that's it. It's not a terribly complicated command-line utility,
    but the purpose of the exercise here is found mostly in the library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our date calculator is now complete. The utility itself is not too terribly
    complex, although, it did serve as expected, which has to be a vehicle for experimenting
    with Java 8's Date/Time API. In addition to the new date/time API, we scratched
    the surface of regular expressions, a very powerful and complex tool to parse
    strings. We also revisited the command-line utility library from the last chapter,
    and dipped our toes in the waters of unit testing and test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll get a bit more ambitious and step into the world
    of social media, building an app to help us aggregate some of our favorite services
    into a single application.
  prefs: []
  type: TYPE_NORMAL

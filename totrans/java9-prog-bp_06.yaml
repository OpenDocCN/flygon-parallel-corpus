- en: Sunago - An Android Port
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built Sunago, a social media aggregation application.
    In that chapter, we learned that Sunago is a JavaFX-based application that can
    pull posts, tweets, photos, and so on from a variety of social media networks
    and display them in one place. The application certainly provided a number of
    interesting architectural and technical examples, but the application itself could
    be more practical--we tend to interact with social networks from mobile devices
    such as phones and tablets, so a mobile version would be much more useful. In
    this chapter, then, we'll write an Android port, reusing as much of the code as
    possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Android applications, while built in Java, look quite a bit different than,
    say, a desktop application. While we can''t cover every aspect of Android development,
    we''ll cover enough in this chapter to get you started, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Android development environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android state management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application packaging and deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the other chapters, there will be too many small items to call out each
    of them, but we'll do our best to highlight the new ones as they're introduced.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to get the Android development environment set up. As with
    *regular* Java development, an IDE isn't strictly necessary, but it sure helps,
    so we'll install Android Studio, which is an IDE based on IntelliJ IDEA. If you
    already have IDEA installed, you can just install the Android plugin and have
    everything you need. For our purposes here, though, we'll assume you don't have
    either installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To download Android Studio, go to [https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html),
    and download the package appropriate for your operating system. When you start
    Android Studio for the first time, you should see following screen:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74eabc68-7103-49c2-935e-bca9650a22ed.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Before we start a new project, let''s configure the Android SDKs that are available.
    Click on the Configure menu in the bottom-right corner, then click on SDK Manager
    to get this screen:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/34f5a1cb-3fdf-4414-9e47-5396a67f16cf.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Which SDKs you select will vary depending on your needs. You may need to support
    older devices as far back as, say, Android 5.0, or maybe you just want to support
    the very latest with Android 7.0 or 7.1.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what need, select the appropriate SDKs (or do as I've done in
    the preceding screenshot and select everything from 5.0 and forward), then click
    on OK. You will need to read and accept the license before continuing.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done that, Android Studio will begin downloading the selected SDKs
    and any dependencies. This process can take a while, so be patient.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the SDK installation completes, click on the Finish button, which will
    take you take to the Welcome screen. Click on Start a new Android Studio project
    to get the following screen:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb7938a4-e5fb-47cd-bf09-38cf4620544d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Nothing exciting here--we need to specify the Application name, Company domain,
    and Project location of our app:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13d262cb-6a32-4e4c-862c-7d47dbc20d05.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Next, though, we need to specify the form factor for our app. Our options are
    Phone and Tablet, Wear, TV, Android Auto, and Glass. As seen in this preceding
    screenshot, all we're interested in for this application is Phone and Tablet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next window, we need to select a type for the main `Activity` for the
    application. In an Android application, what we might refer to as a *screen* (or
    maybe *page*, if you're coming from a web application background) is known as
    an `Activity`. Not every `Activity` is a screen, though.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Android developer documentation ([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html)),
    we learn the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[a]n activity is a single, focused thing that the user can do. Almost all activities
    interact with the user, so the Activity class takes care of creating a window
    for you...'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, it''s probably acceptable to equate the two, but do so loosely,
    and always with this caveat in mind. The wizard gives us many options, as seen
    in this screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0ed3ec9-b414-48c3-80b1-0d3e62781a94.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are several options: Basic, Empty, Fullscreen, Google
    AdMobs Ads, Google Maps, Login, and so on. Which to choose depends, again, on
    what your requirements are for the application. Our bare minimum requirements,
    in terms of user interface, are that it tells the user the name of the app, shows
    the list of social media items, and provides a menu for changing the application
    settings. From the preceding list, then, the Basic Activity is the closest match,
    so we select that, and click on Next:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db218934-2b49-41d2-becb-43a3e9d1914c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: The defaults in the preceding screen are mostly acceptable (notice that Activity
    Name was changed), but before we click on Finish, there are a few final words.
    When building an Android application of any size, you are going to have a lot
    of layouts, menus, activities, and so on. I have found it helpful to name these
    artifacts as you see here--the layout for an `Activity` is named `activity_` plus
    the `Activity` name; menus are `menu_` plus the activity name, or, for shared
    menus, a meaningful summary of its contents. Each artifact type is prefixed by
    its type. This general pattern will help you quickly navigate to the source file
    as the number of files grows, as the arrangement of these files is very flat and
    shallow.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, notice the Use a Fragment checkbox. *A Fragment is a piece of an application's
    user interface or behavior that can be placed in an Activity*. It is, effectively,
    a way for you, as the developer, to decompose the user interface definition into
    multiple pieces (or Fragments, thus, the name) that can be composed into a whole
    in an Activity in different ways depending on the current context of the application.
    For example, a Fragment-based user interface might have two screens for certain
    operations on a phone, but might combine those into one Activity for the larger
    screen on a tablet. It's a bit more complicated than that, of course, but I include
    that brief and incomplete description simply to give some explanation of the checkbox.
    We will not be using Fragments in our application, so we leave that unchecked,
    and click on Finish.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After processing for some time, Android Studio now creates a basic application
    for us. Before we start coding the application, let''s run it to see what that
    process looks like. We can run the app in a few ways--we can click on Run | Run
    ''app''; click on the green play button in the middle of the toolbar, or press
    *Shift* + *F10*. All three will bring up the same Select Deployment Target window,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/218d9d68-39b5-44d1-8f73-f81d0094ec27.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Since we just installed Android Studio, we don''t have any emulators created,
    so we need to do that now. To create the emulators, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the Create New Virtual Device button gets us this screen:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43e46090-343b-4f45-bbd0-4f1a8971900b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with a reasonably modern Android phone--select the Nexus 6 profile,
    and click on Next:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7361ff87-aa1a-414c-8985-781b118a8ae0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, your options will vary based on which SDKs you've installed.
    Which SDK you choose, again, depends on your target audience, application needs,
    and so on. As enjoyable as it always is to use the latest and greatest, we don't
    strictly need any APIs from, say, Nougat. Choosing Android 7.x would restrict
    the availability of Sunago to those on very new phones, and do so for no good
    reason. We will, then, target Lollipop (Android 5.0), which strikes a good balance
    between supporting as many users as possible and providing access to newer Android
    features.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，您的选项将根据您安装了哪些SDK而有所不同。再次选择哪个SDK取决于您的目标受众、应用程序需求等等。尽管始终使用最新和最好的东西很愉快，但我们并不严格需要来自Nougat的任何API。选择Android
    7.x将限制Sunago仅适用于新手机上，并且没有充分的理由这样做。因此，我们将以Lollipop（Android 5.0）为目标，这在支持尽可能多的用户和提供对新Android功能的访问之间取得了良好的平衡。
- en: Click the Download link if necessary for the x86_64 ABI, select that release,
    click on Next, and then click on Finish on the Verify Configuration screen.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要x86_64 ABI，请单击下载链接，选择该版本，然后在“验证配置”屏幕上单击“完成”。
- en: With an emulator created, we can now select it in the Select Deployment Target
    screen, and run the application by clicking on OK. If you want to skip the selection
    screen the next time you run the application, you can check the Use same selection
    for future launches checkbox before clicking on OK.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个模拟器后，我们现在可以在“选择部署目标”屏幕中选择它，并通过单击“确定”来运行应用程序。如果您想要在下次运行应用程序时跳过选择屏幕，可以在单击“确定”之前选中“将来启动使用相同的选择”复选框。
- en: 'The first time the application is run, it will take a bit longer, as the application
    is built and packaged and the emulator started. After a few moments, you should
    see the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，由于应用程序正在构建和打包，模拟器正在启动，所以会花费更长的时间。几分钟后，您应该会看到以下屏幕：
- en: '![](img/faa68398-f03d-4db0-b58b-4bcd7cb98270.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faa68398-f03d-4db0-b58b-4bcd7cb98270.png)'
- en: It's nothing special, but it shows that everything is working as expected. Now,
    we're ready to start the real work in porting Sunago.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么特别的，但它表明一切都按预期运行。现在，我们准备开始在移植Sunago中进行真正的工作。
- en: Building the user interface
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'Put simply, Android user interfaces are based on Activities, which use layout
    files to describe the structure of the user interface. There''s more to it, of
    course, but this simple definition should be sufficient for our work on Sunago.
    Let''s start, then, by looking at our `Activity`, `MainActivity`, which is as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Android用户界面是基于Activities的，它使用布局文件来描述用户界面的结构。当然，还有更多内容，但这个简单的定义对我们在Sunago上的工作应该足够了。那么，让我们开始看看我们的“Activity”，“MainActivity”，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This last bit of code is the class exactly as it was generated by Android Studio.
    It''s very basic, but it has most of what you need to create an `Activity`. Note
    that the class extends `AppCompatActivity`. While Google has been very active
    in pushing the Android platform, they have also worked tirelessly to make sure
    that older devices aren''t left behind any sooner than they have to be. To achieve
    that, Google has backported many new features in "compat" (or compatibility) packages,
    which means many of the newer APIs will actually run on older versions of Android.
    The changes, though, since they are in separate packages, won''t break any existing
    functionality--they must be explicitly opted for, which is what we''re doing here.
    While we''re not planning on supporting older versions of Android, such as KitKat,
    it is still suggested that your `Activity` classes extend the compatibility classes,
    like this one, as there is a significant number of features built in to these
    classes that we would otherwise have to implement ourselves. Let''s walk through
    this class to get a sense of what all is going on in the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分代码是由Android Studio生成的类。它非常基础，但它具有大部分创建“Activity”所需的内容。请注意，该类扩展了“AppCompatActivity”。尽管Google一直在积极推动Android平台，但他们也不遗余力地确保旧设备不会被抛弃得比必要的更早。为了实现这一点，Google已经在“compat”（或兼容性）包中将许多新功能进行了后向兼容，这意味着许多新的API实际上可以在旧版本的Android上运行。然而，由于它们在单独的包中，所以不会破坏任何现有的功能——它们必须明确选择，这就是我们在这里要做的。虽然我们不打算支持旧版本的Android，比如KitKat，但建议您的“Activity”类扩展兼容性类，就像这个类一样，因为这些类内置了大量功能，否则我们将不得不自己实现。让我们逐步了解这个类，以便在接下来的步骤中了解正在进行的所有工作：
- en: The first method is `onCreate()`, which is an `Activity` life cycle method (we'll
    talk more about Activity life cycle in a moment). When the system creates the
    `Activity` class, this method is called. It is here that we initialize the user
    interface, setting values, connection controls to data sources, and so on. Note
    that the method takes a **Bundle**. This is how Android passes in the Activity
    state so that it may be restored.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方法是“onCreate()”，这是一个“Activity”生命周期方法（我们稍后会详细讨论Activity生命周期）。当系统创建“Activity”类时，将调用此方法。在这里，我们初始化用户界面，设置值，将控件连接到数据源等。请注意，该方法需要一个**Bundle**。这是Android传递Activity状态的方式，以便可以恢复它。
- en: In the `setContentView(R.layout.activity_main)` method, we tell the system what
    layout we want to use for this `Activity`. Once we've set the content `View` for
    `Activity`, we can then start acquiring references to various elements. Notice
    that we first look for the `Toolbar` defined in the view, `findViewById(R.id.toolbar)`,
    then we tell Android to use that as our action bar via `setSupportActionBar()`.
    This is an example of a functionality that is implemented for us via the `compat`
    class. If we extended, say, `Activity` directly, we would be required to do much
    more work to make the action bar work. As it is, we call one setter and we're
    done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setContentView(R.layout.activity_main)`方法中，我们告诉系统我们要为这个“Activity”使用哪个布局。一旦我们为“Activity”设置了内容“View”，我们就可以开始获取对各种元素的引用。请注意，我们首先寻找视图中定义的“Toolbar”，`findViewById(R.id.toolbar)`，然后我们告诉Android使用它作为我们的操作栏，通过`setSupportActionBar()`。这是一个通过“compat”类为我们实现的功能的例子。如果我们直接扩展了，比如说，`Activity`，我们将需要做更多的工作来使操作栏工作。现在，我们只需调用一个setter，就完成了。
- en: Next, we look up another user interface element, the `FloatingActionButton`.
    In the preceding screenshot, this is the button in the lower-right corner with
    the email icon. We will actually be removing this, but, since Android Studio generated
    it, we can learn what we can from it before it is removed. Once we have a reference
    to it, we can attach listeners. In this case, we're adding an `on Click` listener
    by creating an anonymous inner class of type `View.OnClickListener`. This works,
    but we've just spent the last five chapters getting rid of those.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Android build system now natively supports using Java 8, so we can modify
    the `onClick` listener registration to look like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the user taps the button, the Snackbar appears. According to the Google
    documentation, *Snackbars provide brief feedback about an operation through a
    message at the bottom of the screen*. And that's exactly what we get--a message
    telling us to replace the `onClick` result with our own action. As stated earlier,
    though, we don't need the floating button, so we'll remove this method and, later,
    the view definition from the layout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The next method in the class is `onCreateOptionsMenu()`. This method is called
    when the options menu is first opened to populate the list of items. We use `MenuInflater`
    to inflate the menu definition file, and add what it defined there to `Menu` that
    the system passes in. This method is called only once, though, so if you need
    a menu that changes, you should override `onPrepareOptionsMenu(Menu)`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final method, `onOptionsItemSelected()`, is called when the user taps an
    options menu item. The specific `MenuItem` selected is passed in. We get its ID,
    and call the method appropriate for the menu item.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s a basic `Activity`, but what does a layout look like? Here are the
    contents of `activity_main.xml`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s a fair bit of XML, so let''s walk through the major items of interest
    quickly, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The root element is `CoordinatorLayout`. Its Java document describes it as a
    super-powered `FrameLayout`. One of its intended purposes is as *a top-level application
    decor or chrome layout*, which is exactly what we're using it for here. Layouts
    such as `CoordinatorLayout` are roughly analogous to JavaFX's containers. Different
    layouts (or `ViewGroup`) provide a variety of capabilities such as laying out
    elements with exact X/Y coordinates (`AbsoluteLayout`), in a grid (`GridLayout`),
    relative to each other (`RelativeLayout`), and so on.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to providing our top-level container, the element defines a number
    of required XML namespaces. It also sets the height and width for the control.
    There are three possible values for this field--`match_parent` (in earlier versions
    of the SDK, this was called `fill_parent` should you ever come across that), which
    means that the control should match the value of its parent, `wrap_content`, which
    means the control should be just big enough for its contents; or an exact number.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next element is `AppBarLayout`, which is a `ViewGroup` that implements a
    number of the material designs app bar concepts. **Material design** is the latest
    **visual language** being developed and supported by Google. It provides a modern,
    consistent look and feel across Android apps. Its usage is encouraged by Google,
    and fortunately, the new `Activity` wizard has set us up to use it out of the
    box. The layout's width is set to `match_parent` so that it fills the screen,
    and the width is set to `wrap_content` so that's it's just big enough to show
    its content, which is a single `Toolbar`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skipping the `include` element for a moment, the last element in the view is
    `FloatingActionButton`. Our only interest here is noting that the widget exists,
    should the need for one arise in other projects. As we did in the `Activity` class
    though, we need to remove this widget.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, there's the `include` element. This does what you would think it should--the
    specified file is included in the layout definition as if its contents were hard
    coded into the file. This allows us to keep our layout files small, reuse user
    interface element definitions (which is especially helpful for complex scenarios),
    and so on.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The included file, `content_main.xml`, looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This preceding view uses `RelativeLayout` to wrap its only child, a `TextView`.
    Note that we can set the padding of a control. This controls how much space is
    *inside* the control around its children. Think of it like packing a box--inside
    the box, you may have a fragile ceramic antique, so you pad the box to protect
    it. You can also set the margin of a control, which is the space *outside* the
    control, akin to the personal space around us we are so often fond of.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextView`, though, isn''t helpful, so we''ll remove that, and add what
    we really need, which is a `ListView`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ListView` is a control that shows items in a vertically scrolling list. In
    terms of user experience, this works pretty much like the `ListView` we looked
    at in JavaFX. How it works, though, is quite different. To see how, we need to
    make some adjustments to activity''s `onCreate()` method as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several things going on here, which sets us up nicely for discussing
    data access in Android. Before we get to that in detail, though, a quick overview
    is in order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We check to make sure that the device has a working network connection via `isNetworkAvailable()`,
    which we'll look at later in this chapter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the connection is available, we configure the user interface, starting with
    setting the toolbar.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an instance of `SunagoCursorAdapter`, which we'll discuss in
    detail later. For now, though, just note that an `Adapter` is how the `ListView`
    is connected to the data source, and they can be backed by things as varied as
    an SQL datasource or an `Array`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass the adapter to `ListView`, thus completing this connection via `ListView.setAdapter()`.
    Much like JavaFX's `Observable` model property, we'll be able to use this to update
    the user interface without direct interaction any time the data changes.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set up an `onClick` listener for the items in the list. We'll use this
    to display the item the user taps (or clicks) on in an external browser. In a
    nutshell, given the `position` parameter, we get the item at that position, a
    `Cursor`, extract the URL of the item, then display the page at that URL using
    the device's default browser via an `Intent` (which we'll discuss in detail later).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, completing our data binding, we initialize the `LoaderManager` that
    will handle loading and updating the `Adapter` in an asynchronous manner.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One last bit of code to look at before diving into data access--`isNetworkAvailable()`--
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we start by getting a reference to the system service,
    `ConnectivityManager`, then we loop through each `Network` known to the system.
    For each `Network`, we get a reference to its `NetworkInfo` and call `isConnected()`.
    If we find one connected network, we return true, otherwise, we return false.
    In the calling code, if our return value is `false`, we show an error dialog,
    the method for which is shown here as well. This is a standard Android dialog.
    We have, however, added an `onClick` listener to the OK button, which closes the
    application. Using this, we tell the user that a network connection is needed,
    then close the app when the user taps on OK. It is debatable, of course, if this
    behavior is desirable, but the process for determining a device's network state
    is interesting enough, so I've included it here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn our attention now to how data access is often done in Android apps--`CursorAdapters`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Android data access
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any platform, there are multiple ways to access data, from built-in facilities
    to homegrown APIs. Android is no different, so while you can write your own way
    to load data from some arbitrary data source, unless you have very particular
    requirements, there is often no need, as Android has a system built in--the `ContentProvider`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上，都有多种访问数据的方式，从内置设施到自制API。安卓也不例外，因此，虽然你可以编写自己的方式从任意数据源加载数据，但除非你有非常特殊的要求，通常是没有必要的，因为安卓内置了一个系统——`ContentProvider`。
- en: The Android documentation will tell you that a *content provider manages access
    to a central repository of data*, and that it offers a consistent, *standard interface
    to data that also handles inter-process communication and secure data access*.
    If you intend to expose your application's data to external sources (either for
    read or write), `ContentProvider` is a great way to go. However, if you don't
    intend to expose your data, you are more than welcome to write the needed CRUD
    methods yourself, manually issuing various SQL statements. In our case, we'll
    use a `ContentProvider`, as we have an interest in allowing third-party developers
    access to the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓文档会告诉你，*内容提供者管理对数据的中央存储库的访问*，并且它提供了一个一致的、*标准的数据接口，还处理进程间通信和安全数据访问*。如果你打算向外部来源（无论是读取还是写入）公开应用程序的数据，`ContentProvider`是一个很好的选择。然而，如果你不打算公开你的数据，你完全可以自己编写所需的CRUD方法，手动发出各种SQL语句。在我们的情况下，我们将使用`ContentProvider`，因为我们有兴趣允许第三方开发人员访问数据。
- en: 'To create a `ContentProvider`, we need to create a new class that extends `ContentProvider`
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`ContentProvider`，我们需要创建一个新的类，继承`ContentProvider`，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to register the provider in `AndroidManfest.xml`, which we''ll
    do like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`AndroidManfest.xml`中注册提供者，我们将这样做：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interaction with `ContentProvider` is never done directly. The client code will
    specify the URL of the data to be manipulated, and the Android system will direct
    the request to the appropriate provider. To make sure our `ContentProvider` functions
    as expected, then, we need to register the provider's authority, which we've already
    seen in the previous XML. In our provider, we'll create some static fields to
    help us manage the parts of our authority and the related URLs in a DRY manner.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ContentProvider`的交互永远不是直接进行的。客户端代码将指定要操作的数据的URL，安卓系统将把请求转发给适当的提供者。因此，为了确保我们的`ContentProvider`按预期运行，我们需要注册提供者的权限，这已经在之前的XML中看到了。在我们的提供者中，我们将创建一些静态字段来帮助我们以DRY的方式管理我们权限的部分和相关的URL。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two fields in the preceding bit of code are private, as they're not
    needed outside the class. We define them as separate fields here, though, for
    clarity's sake. The third field, `CONTENT_URI`, is public, as we'll be referencing
    that field elsewhere in our app. Third-party consumers won't have access to the
    field, obviously, but will need to know its value, `content://com.steeplesoft.sunago.SunagoProvider/items`,
    which we would document somewhere for add-on developers. The first part of the
    URL, the protocol field, tells Android that we're looking for a `ContentProvider`.
    The next section is the authority, which uniquely identifies a particular `ContentProvider`,
    and the final field specifies the type of data, or model, that we're interested
    in. For Sunago, we have a single data type, `items`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的前两个字段中，是私有的，因为在类外部不需要它们。我们在这里将它们定义为单独的字段，以便更清晰。第三个字段`CONTENT_URI`是公共的，因为我们将在应用程序的其他地方引用该字段。第三方消费者显然无法访问该字段，但需要知道它的值`content://com.steeplesoft.sunago.SunagoProvider/items`，我们会在某个地方为附加开发人员记录这个值。URL的第一部分，协议字段，告诉安卓我们正在寻找一个`ContentProvider`。接下来的部分是权限，它唯一标识特定的`ContentProvider`，最后一个字段指定我们感兴趣的数据类型或模型。对于Sunago，我们只有一个数据类型，`items`。
- en: 'Next, we need to specify the URIs we want to support. We only have two--one
    for the items collection, and one for a particular item. Please, refer to following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们想要支持的URI。我们只有两个——一个用于项目集合，一个用于特定项目。请参考以下代码片段：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the last code, we start by creating a `UriMatcher`. Note that we pass `UriMatcher.NO_MATCH`
    to the constructor. It's not immediately clear what this value is for, but this
    is the value that will be returned if the user passes in a URI that doesn't match
    any of those registered. Finally, we register each URI with a unique `int` identifier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码中，我们首先创建了一个`UriMatcher`。请注意，我们将`UriMatcher.NO_MATCH`传递给构造函数。这个值的作用并不立即清楚，但如果用户传入一个不匹配任何已注册的URI的URI，将返回这个值。最后，我们为每个URI注册一个唯一的`int`标识符。
- en: 'Next, like many Android classes, we need specify an `onCreate` lifecycle hook
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像许多安卓类一样，我们需要指定一个`onCreate`生命周期钩子，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`SunagoOpenHelper` is a child of `SQLiteOpenHelper`, which manages the creation
    and/or update of the underlying SQLite database. The class itself is pretty simple,
    and is given as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SunagoOpenHelper`是`SQLiteOpenHelper`的子类，它管理底层SQLite数据库的创建和/或更新。这个类本身非常简单，如下所示：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I've not shown the table creation DDL, as it's a pretty simple table creation,
    but this class is all you need to create and maintain your database. If you have
    multiple tables, you would issue multiple creates in `onCreate`. When the application
    updates, `onUpgrade()` is called to allow you to modify the schema if needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有展示表的创建DDL，因为它是一个非常简单的表创建，但这个类是你创建和维护数据库所需的全部。如果你有多个表，你将在`onCreate`中发出多个创建。当应用程序更新时，将调用`onUpgrade()`来允许你根据需要修改模式。
- en: 'Back in our `ContentProvider`, we need to implement two methods, one to read
    data, and one to insert (given the nature of the app, we''re not interested in
    deletes or updates right now). For reading data, we override `query()` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ContentProvider`，我们需要实现两个方法，一个用于读取数据，一个用于插入（考虑到应用程序的性质，我们现在不关心删除或更新）。对于读取数据，我们重写`query()`如下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last code is where our URIs and their `int` identifiers come in. Using
    `UriMatcher`, we check the `Uri` passed in by the caller. Given that our provider
    is simple, the only one we need to do anything special for is `#2`, which is the
    query for a specific item. In that case, we extract the ID passed in as the last
    path segment, and add it to the selection criteria specified by the caller.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一段代码是我们的URI及其`int`标识符的用处。使用`UriMatcher`，我们检查调用者传入的`Uri`。鉴于我们的提供者很简单，我们只需要为`#2`做一些特殊处理，这是针对特定项目的查询。在这种情况下，我们提取传入的ID作为最后的路径段，并将其添加到调用者指定的选择条件中。
- en: Once we have the query configured as requested, we get a readable `SQLiteDatabase`
    from our `openHelper`, and query it using the values passed by the caller. This
    is one of the areas where the `ContentProvider` contract comes in handy--we don't
    need to write any `SELECT` statements manually.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按照要求配置了查询，我们就从我们的`openHelper`中获得一个可读的`SQLiteDatabase`，并使用调用者传递的值进行查询。这是`ContentProvider`合同非常方便的地方之一--我们不需要手动编写任何`SELECT`语句。
- en: 'Before returning the cursor, we need to do something to it, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回游标之前，我们需要对它进行一些处理，如下所示：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this preceding call, we tell the system that we want the cursor notified
    when the data is updated. Since we're using a `Loader`, this will allow us to
    update the user interface automatically when data is inserted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述调用，我们告诉系统我们希望在数据更新时通知游标。由于我们使用了`Loader`，这将允许我们在插入数据时自动更新用户界面。
- en: 'For inserting data, we override `insert()` as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入数据，我们重写`insert()`如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using `openHelper`, this time, we get a writable instance of the database, on
    which we call `insert()`. The insert method returns the ID of the row just inserted.
    If we get a non-zero ID, we generate a URI for the row, which we'll eventually
    return. Before we do so, however, we notify the content resolver of the change
    in the data, which triggers our auto-reload in the user interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`openHelper`，这一次，我们获得了数据库的可写实例，在这个实例上调用`insert()`。插入方法返回刚刚插入的行的ID。如果我们得到一个非零的ID，我们会为这一行生成一个URI，最终会返回它。然而，在这之前，我们会通知内容解析器数据的变化，这会触发用户界面的自动重新加载。
- en: 'We have one more step to finish our data loading code, though. If you look
    back on `MainActivity.onCreate()`, you''ll see this line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一步要完成我们的数据加载代码。如果你回顾一下`MainActivity.onCreate()`，你会看到这一行：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This last line tells the system that we want to initialize a `Loader` and that
    the `Loader` is `this` or `MainActivity`. In our definition of `MainActivity`,
    we''ve specified that it implements the `LoaderManager.LoaderCallbacks<Cursor>`
    interface. This requires us to implement a few methods as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行告诉系统我们要初始化一个`Loader`，并且`Loader`是`this`或`MainActivity`。在我们对`MainActivity`的定义中，我们已经指定它实现了`LoaderManager.LoaderCallbacks<Cursor>`接口。这要求我们实现一些方法，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `onCreateLoader()`, we specify both what to load and where to load it. We
    pass in the URI of the `ContentProvider` we just created, we specify the fields
    we're interested in via the `ITEM_PROJECTION` variable (which is a `String[]`,
    and not shown here), and, finally, the sort order (which we've specified as the
    timestamp of the items in descending order so that we get the newest items on
    top). The method `onLoadFinished()` is where the auto-reload happens. Once a new
    `Cursor` is created for the updated data, we swap it in for the `Cursor` that
    `Adapter` is currently using. While you can write your own persistence code, this
    highlights why using the platform facilities, whenever possible, can be a wise
    choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateLoader()`中，我们指定要加载的内容和加载的位置。我们传入刚刚创建的`ContentProvider`的URI，通过`ITEM_PROJECTION`变量（这是一个`String[]`，这里没有显示）指定我们感兴趣的字段，最后是排序顺序（我们已经指定为项目的时间戳按降序排列，这样我们就可以得到最新的项目）。`onLoadFinished()`方法是自动重新加载发生的地方。一旦为更新的数据创建了新的`Cursor`，我们就将其替换为`Adapter`当前正在使用的`Cursor`。虽然你可以编写自己的持久化代码，但这突出了为什么尽可能使用平台设施可能是一个明智的选择。
- en: 'There is one large item left to look at with regard to data handling-- `SunagoCursorAdapter`.
    Looking again at the Android Javadocs, we learn that *an* `Adapter` *object acts
    as a bridge between an* `AdapterView` *and the underlying data for that view*,
    and that `CursorAdapter` *exposes data from a* `Cursor` *to a* `ListView` *widget*.
    Often--if not in the majority of cases--a particular `ListView` will require a
    custom `CursorAdapter` to allow the underlying data to be rendered correctly.
    Sunago is no exception. To create our `Adapter`, then, we create a new class as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理方面还有一个重要的内容要看--`SunagoCursorAdapter`。再次查看Android Javadocs，我们了解到*一个*`Adapter`*对象充当*`AdapterView`*和该视图的基础数据之间的桥梁*，而`CursorAdapter`*将*`Cursor`*中的数据暴露给*`ListView`*小部件*。通常--如果不是大多数情况--特定的`ListView`将需要一个自定义的`CursorAdapter`来正确渲染基础数据。Sunago也不例外。因此，为了创建我们的`Adapter`，我们创建一个新的类，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is pretty standard fare. The truly interesting parts come in the view
    creation, which is one of the reasons for being for a `CursorAdapter`. When the
    `Adapter` needs to create a new view to hold the data pointed to by the cursor,
    it calls the following method. This is where we specify what the view should look
    like with the call to `LayoutInflater.inflate()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常标准的做法。真正有趣的部分在于视图的创建，这也是`CursorAdapter`存在的原因之一。当`Adapter`需要创建一个新的视图来保存游标指向的数据时，它会调用以下方法。这是我们通过调用`LayoutInflater.inflate()`来指定视图的外观的地方。
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll look at our layout definition in a moment, but first, let''s take a
    look at `ViewHolder`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看一下我们的布局定义，但首先让我们来看一下`ViewHolder`：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finding views by ID can be an expensive operation, so a very common pattern
    is this `ViewHolder` approach. After the view is inflated, we immediately look
    up the fields we're interested in, and store those references in a `ViewHolder`
    instance, which is then stored as the tag on the `View`. Since views are recycled
    by the `ListView` class (meaning, they're reused as needed as you scroll through
    the data), this expensive `findViewById()` is called once and cached per `View`
    rather than once per item in the underlying data. For large datasets (and complex
    views), this can be a substantial performance boost.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we also set the size of the `ImageView` class. Android doesn't
    support setting the width of a view to a percentage via the XML markup (given
    next), so we do that manually here as we create the `View`. We get the `WindowManager`
    system service from which we get the default display's size. We multiply the display's
    width by 0.33, which will restrict the image, if any, to 1/3 of the display's
    width, and set the `ImageView`'s width to that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the view look like for each row?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the `ViewHolder` hinted, our view consists of an `ImageView` and a `TextView`,
    presented horizontally, thanks to the enclosing `LinearLayout`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'While `CursorAdapter` calls `newView()` to create a `View`, it calls `bindView()`
    to--if you can imagine--bind the `View` to a specific row in the `Cursor`. This
    is where `View` recycling comes into play. The `Adapter` has a number of `View`
    instances cached, and passes one to this method as needed. Our method looks like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by getting the `ViewHolder` instance. As discussed previously, we'll
    use the widget references stored here to update the user interface. Next, we pull
    the image URL from the cursor. It's up to each `SocialMediaItem` to decide how
    this field is populated, but it might be a tweeted image or a photo in an Instagram
    post. If the item has one, we need to download it so that it can be displayed.
    Since this requires a network operation, and we're running on the user interface
    thread, we hand that work off to `DownloadImageTask`. If there is no image for
    this item, we need to set the bitmap for the image to `null` (otherwise, the image
    that was there the last time this view instance was used would be displayed again).
    That frees up some memory, which is always good, but we also set the `ImageView`
    class' visibility to `GONE`, which hides it from the user interface. You might
    be tempted to use `INVISIBLE`, but that only makes it invisible **while preserving
    its space in the user interface**. The end result of that would be a big blank
    square, which is not what we want. Finally, we set the text of the `TextView`
    body to the text specified for the item.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The image downloading is handled off-thread by an `AsyncTask`, which is as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Android will create a background `Thread` on which to run this task. The main
    entry point for our logic is `doInBackground()`. Please refer the following snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not the most robust download code imaginable (for example, redirect
    status codes are happily ignored), but it's certainly usable. Using Java 7's `try-with-resources`,
    we create a `URL` instance on which we call `openStream()`. Assuming no `Exception`
    is thrown in either of those operations, we call `BitmapFactory.decodeStream()`
    to convert the incoming bytes into a `Bitmap`, which is what the method is expected
    to return.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens to the `Bitmap` once we return it? We process that in `onPostExecute()`
    like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this last method, we update `ImageView` with our now downloaded `Bitmap`,
    makes it `VISIBLE`, then request that the view update itself on the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've built an app that's capable of displaying `SocialMediaItem` instances,
    but we have nothing for it to show. We'll fix that now with a look at Android
    Services.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Android services
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the desktop version of Sunago, we defined an API that would allow third-party
    developers (or ourselves) to add support for an arbitrary social network to Sunago.
    That was a great goal for the desktop, and it''s a great goal for mobile. Fortunately,
    Android provides us with a mechanism that can be used to do just that: Services.
    *A Service is an application component representing either an application''s desire
    to perform a longer-running operation while not interacting with the user or to
    supply functionality for other applications to use*. While services were designed
    for more than extensibility, we can leverage this facility to that end.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of ways to implement and interact with services, we
    are going to bind the services to our `Activity` so that their life cycle is tied
    to that of our `Activity`, and we''ll send messages to them asynchronously. We''ll
    start by defining our class as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Technically, these are the only methods required to create a service. Clearly,
    it doesn''t do much, but we''ll fix that in just a moment. Before we do that,
    we need to declare our new `Service` to Android which is done in `AndroidManifest.xml`,
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that, in addition to the service declaration, we also specify an `IntentFilter`
    via the `intent-filter` element. We''ll use that in `MainActivity` later to find
    and bind our services. While we''re looking at our service, though, let''s look
    at this side of the binding process. We''ll need to implement these two lifecycle
    methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These preceding methods are called when the service is bound and unbound, which
    give us an opportunity to register our receiver, which may lead to the question:
    What''s that? Android provides an **Interprocess Communication** (**IPC**), but
    it is somewhat limited in that the payload size can not exceed 1 MB. Though our
    payload is only text, we can (and certainly will, based on my testing) exceed
    that. Our approach, then, will be to use asynchronous communication, via a receiver,
    and have the service persist the data via our `ContentProvider`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a receiver, we extend `android.content.BroadcastReceiver` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our message scheme is very simple--Sunago sends the message `REFRESH`, and the
    service performs its work, which we have wrapped up in `TwitterUpdatesAsyncTask`.
    In `onBind()`, we register the receiver with a specific `IntentFilter` that specifies
    the `Intent` broadcasts that we're interested in. In `onUnbind()`, we unregister
    our receiver as the service is released.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of our service is in our `AsyncTask`, which is given as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We need to make sure that the network operation isn't performed on the user
    interface thread, so we perform the work in `AsyncTask`. We don't need any parameters
    passed into the task, so we set the `Params` and `Progress` types to `Void`. We
    are, though, interested in the `Result` type, which is `List<ContentValue>`, which
    we see reflected in both the type declaration and the return type of `execute()`.
    In `onPostExecute()`, we then issue a bulk insert on `ContentProvider` to save
    the data. In this way, we can make the newly-retrieved data available to the application
    without running afoul the 1 MB limit with `IBinder`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'With our service defined, we need now to look at how to find and bind the services.
    Looking back at `MainActivity`, we''ll finally look at a method we''ve already
    seen mentioned, `findPlugins()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To find the plugins we're interested in, we create an `Intent` with a specific
    action. In this case, that action is `com.steeplesoft.sunago.intent.plugin`, which
    we've already seen in the service definition in `AndroidManifest.xml`. Using this
    `Intent`, we query `PackageManager` for all `IntentServices` matching Intent.
    Next, we iterate over the list of `ResolveInfo` instances, getting the `ServiceInfo`
    instances, and create and store a `ComponentName` representing the plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual binding of the services is done in the following `bindPlugins()`
    method, which we call from the `onStart()` method to make sure the binding occurs
    at the appropriate time in activity''s lifecycle:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For each plugin found, we create an `Intent` using the `ComponentName` we created
    earlier. Each service binding will need a `ServiceConnection` object. For that,
    we created `PluginServiceConnection`, which implements the interface. Its methods
    are empty, so we'll not look at that class here. With our `ServiceConnection`
    instance, we can now bind the service with a call to `bindService()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to clean up as the application is closing, we need to unbind our services.
    From `onStop()`, we call this method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we simply loop through our `ServiceConnection` plugins, passing each to
    `unbindService()`, which will allow Android to garbage collect any services we
    may have started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve defined a service, looked it up, and bound it. But how do we
    interact with it? We''ll go the simple route, and add an option menu item. To
    do that, we modify `res/menu/main_menu.xml` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To respond to the menu item being selected, we need to revisit `onOptionsItemSelected()`
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `switch` block of the preceding code, we add a `case` label for `R.id.action_refresh`,
    which matches the ID of our newly added menu item in which we call the method
    `sendRefreshMessage()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first method is pretty straightforward. In fact, it might not even be necessary,
    given its simplicity, but it does add semantic clarity to the consuming code,
    so I think it's a good method to add.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part, however, is the method `sendMessage()`. We start by creating
    an `Intent` that specifies our action, `sunago.service`. This is an arbitrary
    string that we define, and then document for any third-party consumers. This will
    help our services filter out messages that are of no interest, which is exactly
    what we did in `TwitterService.onBind()` with the call to `registerReceiver(receiver,
    new IntentFilter("sunago.service"))`. We then add the message that our app wants
    to send (`REFRESH`, in this case) as an extra on `Intent`, which we then broadcast
    via `sendBroadcast()`. From here, Android will handle delivering the message to
    our service, which is already running (since we've bound it to our `Activity`)
    and listening (as we registered a `BroadcastReceiver`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Android tabs and fragments
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at quite a bit, but there is still a fair bit we haven't seen,
    such as the implementation for `TwitterClient`, as well as any details on the
    integration of networks, such as Instagram, which we saw in the last chapter.
    For the most part, `TwitterClient` is identical to what we saw in [Chapter 5](../Text/ec70a9e6-836b-4b8f-af0d-2438fd50ed1d.xhtml),
    *Sunago - A Social Media Aggregator*. The only major difference is in the use
    of the stream APIs. Some APIs are only available in certain Android versions,
    specifically, version 24, also known as Nougat. Since we're targeting Lollipop
    (SDK version 21), we are unable to use them. That aside, the internal logic and
    API usage are identical. You can see the details in the source repository. Before
    we finish, though, we need to take a look at the Twitter preferences screen, as
    there are some interesting items there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a tab layout activity, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For making a tabbed interface, we need two things--`FragmentPagerAdapter` and
    `ViewPager`. The `ViewPager` is a user-interface element that actually shows the
    tabs. Think of it as `ListView` for tabs. The `FragmentPagerAdapter`, then, is
    like `CursorAdapter` for the tabs. Instead of an SQL-backed data source, though,
    `FragmentPagerAdapter` is an adapter that represents pages as Fragments. In this
    method, we create an instance of our `SectionsPagerAdapter`, and set it as the
    adapter on our `ViewPager`. We also associate the `ViewPager` element with the
    `TabLayout`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '`SectionsPagerAdapter` is a simple class, and is written as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method `getCount()` tells the system how many tabs we support, the title
    for each tab that is returned by `getPageTitle()`, and the `Fragment` representing
    the selected tab is returned from `getItem()`. In this example, we create a `Fragment`
    instance as needed. Note, we hint at Instagram support here, but its implementation
    looks strikingly similar to the Twitter implementation, so we won't go into detail
    on that here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`TwitterPreferencesFragment` looks as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Fragments have a slightly different lifecycle than an `Activity`. Here, we inflate
    the view in `onCreateView()`, then we update the user interface with the current
    state from `onStart()`. What does the view look like? That's determined by `R.layout.fragment_twitter_preferences`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In a nutshell, as you can see in the preceding code, we have a button for logging
    in and out, and a `ListView` for allowing the user to select which Twitter lists
    from which to load data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the frequent use of the network for interacting with Twitter plus Android''s
    aversion to network access on the user interface thread, the code here gets a
    little complicated. We can see the start of that in `updateUI()`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing that should stand out in the last code is that first line. Since
    we're updating the user interface, we have to make sure this code runs on the
    user interface thread. To make that happen, we wrap our logic in a `Runnable`,
    and pass that to the method `runOnUiThread()`. In `Runnable`, we check to see
    if the user is logged in or not. If not, we set the `prefsLayout` section's visibility
    to `GONE`, set the `Button`'s text to Login, and set its `onClick` listener to
    a `View.OnClickListener` method that executes `TwitterAuthenticateTask`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not logged in, we do the opposite--make `prefsLayout` visible,
    set the `Button` text to Logout, set the `onClick` to an anonymous `View.OnClickListener`
    class that removes the authentication-related preferences, and recursively call
    `updateUI()` to make sure the interface is updated to reflect the logout.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`TwitterAuthenticateTask` is another `AsyncTask` that handles authenticating
    with Twitter. To authenticate, we have to get a Twitter request token, which requires
    network access, so this must be done off of the user interface thread, thus, `AsyncTask`.
    Please refer to the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we have the `RequestToken`, we show the `WebLoginActivity` from which the
    user will enter the credentials for the service. We'll look at that in the next
    code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: When that activity returns, we need to check the results and respond appropriately.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we started `WebLoginActivity`, we specified that we wanted to get a result,
    and we specified an identifier, `LOGIN_REQUEST`, which is set to 1, to uniquely
    identify which `Activity` was returning the result. If `requestCode` is `LOGIN_REQUEST`,
    and the result code is `Activity.RESULT_OK` (see `WebLoginActivity` given next),
    then we have a successful response, and we need to finish the login process, for
    which we'll use another `AsyncTask`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `doInBackground()`, we perform the network operation. When we have a result,
    the `AccessToken`, we use that to authenticate our `TwitterClient` instance, then
    we return the token. In `onPostExecute()`, we save the `AccessToken` details to
    `SharedPreferences`. Technically, all of this could have been done in `doInBackground()`,
    but I find it helpful, especially when learning something new, not to cut corners.
    Once you're comfortable with how all of this works, you are, of course, free to
    cut corners when and where you feel comfortable doing so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We have one last piece to look over, `WebLoginActivity`. Functionally, it is
    identical to `LoginActivity`--it presents a web view which displays the login
    page for the given network. When the login succeeds, the needed information is
    returned to the calling code. This being Android rather than JavaFX, the mechanics
    are, of course, a little different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Most of this preceding code looks very much like the other `Activity` classes
    we've written. We do some basic user interface set up, then, getting a reference
    to the `Intent`, we extract the two parameters of interest--the URL of the login
    page, and the query parameter that indicates a successful login.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To participate in the page loading life cycle, we extend `WebViewClient` (which
    we then attach to `WebView` in `Activity`, as seen previously). This is done as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While `WebViewClient` offers a myriad of life cycle events, we're only concerned
    with one right now, `onPageStarted()`, which is fired, as expected, when the page
    starts to load. By hooking in here, we can look at the URL before the related
    network activity begins. We can examine the desired URL to see if the query parameter
    of interest is present. If it is, we create a new `Intent` to pass data back to
    the caller, copy all of the query parameters to it, set the `Activity` result
    to `RESULT_OK`, and finish the `Activity`. If you look back at `onActivityResult()`,
    you should see now from where `resultCode` comes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our application is complete. It's not a perfect application, but
    it is a complete Android application, which demonstrates a number of features
    you might need in your own app including `Activities`, services, database creation,
    content providers, messaging, and asynchronous processing. Clearly, there are
    parts of the application where the error handling could be more robust, or the
    design generalized a bit more to be more readily reusable. Doing so in this context,
    however, would obscure the basics of the application too much. Making these changes,
    then, will make a great exercise for the reader.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a completely different type of application.
    We'll build a small utility to handle what can be a serious problem--too much
    email. This application will allow us to describe a set of rules that will delete
    or move emails. It's a simple concept, but it will allow us to work with JSON
    APIs and the `JavaMail` package. You'll learn a bit and end up with a useful little
    utility as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL

- en: Sunago - An Android Port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built Sunago, a social media aggregation application.
    In that chapter, we learned that Sunago is a JavaFX-based application that can
    pull posts, tweets, photos, and so on from a variety of social media networks
    and display them in one place. The application certainly provided a number of
    interesting architectural and technical examples, but the application itself could
    be more practical--we tend to interact with social networks from mobile devices
    such as phones and tablets, so a mobile version would be much more useful. In
    this chapter, then, we'll write an Android port, reusing as much of the code as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android applications, while built in Java, look quite a bit different than,
    say, a desktop application. While we can''t cover every aspect of Android development,
    we''ll cover enough in this chapter to get you started, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Android development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application packaging and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the other chapters, there will be too many small items to call out each
    of them, but we'll do our best to highlight the new ones as they're introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to get the Android development environment set up. As with
    *regular* Java development, an IDE isn't strictly necessary, but it sure helps,
    so we'll install Android Studio, which is an IDE based on IntelliJ IDEA. If you
    already have IDEA installed, you can just install the Android plugin and have
    everything you need. For our purposes here, though, we'll assume you don't have
    either installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download Android Studio, go to [https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html),
    and download the package appropriate for your operating system. When you start
    Android Studio for the first time, you should see following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74eabc68-7103-49c2-935e-bca9650a22ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we start a new project, let''s configure the Android SDKs that are available.
    Click on the Configure menu in the bottom-right corner, then click on SDK Manager
    to get this screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/34f5a1cb-3fdf-4414-9e47-5396a67f16cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Which SDKs you select will vary depending on your needs. You may need to support
    older devices as far back as, say, Android 5.0, or maybe you just want to support
    the very latest with Android 7.0 or 7.1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what need, select the appropriate SDKs (or do as I've done in
    the preceding screenshot and select everything from 5.0 and forward), then click
    on OK. You will need to read and accept the license before continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've done that, Android Studio will begin downloading the selected SDKs
    and any dependencies. This process can take a while, so be patient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the SDK installation completes, click on the Finish button, which will
    take you take to the Welcome screen. Click on Start a new Android Studio project
    to get the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb7938a4-e5fb-47cd-bf09-38cf4620544d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nothing exciting here--we need to specify the Application name, Company domain,
    and Project location of our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13d262cb-6a32-4e4c-862c-7d47dbc20d05.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, though, we need to specify the form factor for our app. Our options are
    Phone and Tablet, Wear, TV, Android Auto, and Glass. As seen in this preceding
    screenshot, all we're interested in for this application is Phone and Tablet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next window, we need to select a type for the main `Activity` for the
    application. In an Android application, what we might refer to as a *screen* (or
    maybe *page*, if you're coming from a web application background) is known as
    an `Activity`. Not every `Activity` is a screen, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Android developer documentation ([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html)),
    we learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a]n activity is a single, focused thing that the user can do. Almost all activities
    interact with the user, so the Activity class takes care of creating a window
    for you...'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, it''s probably acceptable to equate the two, but do so loosely,
    and always with this caveat in mind. The wizard gives us many options, as seen
    in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0ed3ec9-b414-48c3-80b1-0d3e62781a94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are several options: Basic, Empty, Fullscreen, Google
    AdMobs Ads, Google Maps, Login, and so on. Which to choose depends, again, on
    what your requirements are for the application. Our bare minimum requirements,
    in terms of user interface, are that it tells the user the name of the app, shows
    the list of social media items, and provides a menu for changing the application
    settings. From the preceding list, then, the Basic Activity is the closest match,
    so we select that, and click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db218934-2b49-41d2-becb-43a3e9d1914c.png)'
  prefs: []
  type: TYPE_IMG
- en: The defaults in the preceding screen are mostly acceptable (notice that Activity
    Name was changed), but before we click on Finish, there are a few final words.
    When building an Android application of any size, you are going to have a lot
    of layouts, menus, activities, and so on. I have found it helpful to name these
    artifacts as you see here--the layout for an `Activity` is named `activity_` plus
    the `Activity` name; menus are `menu_` plus the activity name, or, for shared
    menus, a meaningful summary of its contents. Each artifact type is prefixed by
    its type. This general pattern will help you quickly navigate to the source file
    as the number of files grows, as the arrangement of these files is very flat and
    shallow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, notice the Use a Fragment checkbox. *A Fragment is a piece of an application's
    user interface or behavior that can be placed in an Activity*. It is, effectively,
    a way for you, as the developer, to decompose the user interface definition into
    multiple pieces (or Fragments, thus, the name) that can be composed into a whole
    in an Activity in different ways depending on the current context of the application.
    For example, a Fragment-based user interface might have two screens for certain
    operations on a phone, but might combine those into one Activity for the larger
    screen on a tablet. It's a bit more complicated than that, of course, but I include
    that brief and incomplete description simply to give some explanation of the checkbox.
    We will not be using Fragments in our application, so we leave that unchecked,
    and click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After processing for some time, Android Studio now creates a basic application
    for us. Before we start coding the application, let''s run it to see what that
    process looks like. We can run the app in a few ways--we can click on Run | Run
    ''app''; click on the green play button in the middle of the toolbar, or press
    *Shift* + *F10*. All three will bring up the same Select Deployment Target window,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/218d9d68-39b5-44d1-8f73-f81d0094ec27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we just installed Android Studio, we don''t have any emulators created,
    so we need to do that now. To create the emulators, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the Create New Virtual Device button gets us this screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43e46090-343b-4f45-bbd0-4f1a8971900b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with a reasonably modern Android phone--select the Nexus 6 profile,
    and click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7361ff87-aa1a-414c-8985-781b118a8ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, your options will vary based on which SDKs you've installed.
    Which SDK you choose, again, depends on your target audience, application needs,
    and so on. As enjoyable as it always is to use the latest and greatest, we don't
    strictly need any APIs from, say, Nougat. Choosing Android 7.x would restrict
    the availability of Sunago to those on very new phones, and do so for no good
    reason. We will, then, target Lollipop (Android 5.0), which strikes a good balance
    between supporting as many users as possible and providing access to newer Android
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Click the Download link if necessary for the x86_64 ABI, select that release,
    click on Next, and then click on Finish on the Verify Configuration screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With an emulator created, we can now select it in the Select Deployment Target
    screen, and run the application by clicking on OK. If you want to skip the selection
    screen the next time you run the application, you can check the Use same selection
    for future launches checkbox before clicking on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first time the application is run, it will take a bit longer, as the application
    is built and packaged and the emulator started. After a few moments, you should
    see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faa68398-f03d-4db0-b58b-4bcd7cb98270.png)'
  prefs: []
  type: TYPE_IMG
- en: It's nothing special, but it shows that everything is working as expected. Now,
    we're ready to start the real work in porting Sunago.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Put simply, Android user interfaces are based on Activities, which use layout
    files to describe the structure of the user interface. There''s more to it, of
    course, but this simple definition should be sufficient for our work on Sunago.
    Let''s start, then, by looking at our `Activity`, `MainActivity`, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This last bit of code is the class exactly as it was generated by Android Studio.
    It''s very basic, but it has most of what you need to create an `Activity`. Note
    that the class extends `AppCompatActivity`. While Google has been very active
    in pushing the Android platform, they have also worked tirelessly to make sure
    that older devices aren''t left behind any sooner than they have to be. To achieve
    that, Google has backported many new features in "compat" (or compatibility) packages,
    which means many of the newer APIs will actually run on older versions of Android.
    The changes, though, since they are in separate packages, won''t break any existing
    functionality--they must be explicitly opted for, which is what we''re doing here.
    While we''re not planning on supporting older versions of Android, such as KitKat,
    it is still suggested that your `Activity` classes extend the compatibility classes,
    like this one, as there is a significant number of features built in to these
    classes that we would otherwise have to implement ourselves. Let''s walk through
    this class to get a sense of what all is going on in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method is `onCreate()`, which is an `Activity` life cycle method (we'll
    talk more about Activity life cycle in a moment). When the system creates the
    `Activity` class, this method is called. It is here that we initialize the user
    interface, setting values, connection controls to data sources, and so on. Note
    that the method takes a **Bundle**. This is how Android passes in the Activity
    state so that it may be restored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `setContentView(R.layout.activity_main)` method, we tell the system what
    layout we want to use for this `Activity`. Once we've set the content `View` for
    `Activity`, we can then start acquiring references to various elements. Notice
    that we first look for the `Toolbar` defined in the view, `findViewById(R.id.toolbar)`,
    then we tell Android to use that as our action bar via `setSupportActionBar()`.
    This is an example of a functionality that is implemented for us via the `compat`
    class. If we extended, say, `Activity` directly, we would be required to do much
    more work to make the action bar work. As it is, we call one setter and we're
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look up another user interface element, the `FloatingActionButton`.
    In the preceding screenshot, this is the button in the lower-right corner with
    the email icon. We will actually be removing this, but, since Android Studio generated
    it, we can learn what we can from it before it is removed. Once we have a reference
    to it, we can attach listeners. In this case, we're adding an `on Click` listener
    by creating an anonymous inner class of type `View.OnClickListener`. This works,
    but we've just spent the last five chapters getting rid of those.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Android build system now natively supports using Java 8, so we can modify
    the `onClick` listener registration to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps the button, the Snackbar appears. According to the Google
    documentation, *Snackbars provide brief feedback about an operation through a
    message at the bottom of the screen*. And that's exactly what we get--a message
    telling us to replace the `onClick` result with our own action. As stated earlier,
    though, we don't need the floating button, so we'll remove this method and, later,
    the view definition from the layout.
  prefs: []
  type: TYPE_NORMAL
- en: The next method in the class is `onCreateOptionsMenu()`. This method is called
    when the options menu is first opened to populate the list of items. We use `MenuInflater`
    to inflate the menu definition file, and add what it defined there to `Menu` that
    the system passes in. This method is called only once, though, so if you need
    a menu that changes, you should override `onPrepareOptionsMenu(Menu)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final method, `onOptionsItemSelected()`, is called when the user taps an
    options menu item. The specific `MenuItem` selected is passed in. We get its ID,
    and call the method appropriate for the menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s a basic `Activity`, but what does a layout look like? Here are the
    contents of `activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a fair bit of XML, so let''s walk through the major items of interest
    quickly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The root element is `CoordinatorLayout`. Its Java document describes it as a
    super-powered `FrameLayout`. One of its intended purposes is as *a top-level application
    decor or chrome layout*, which is exactly what we're using it for here. Layouts
    such as `CoordinatorLayout` are roughly analogous to JavaFX's containers. Different
    layouts (or `ViewGroup`) provide a variety of capabilities such as laying out
    elements with exact X/Y coordinates (`AbsoluteLayout`), in a grid (`GridLayout`),
    relative to each other (`RelativeLayout`), and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to providing our top-level container, the element defines a number
    of required XML namespaces. It also sets the height and width for the control.
    There are three possible values for this field--`match_parent` (in earlier versions
    of the SDK, this was called `fill_parent` should you ever come across that), which
    means that the control should match the value of its parent, `wrap_content`, which
    means the control should be just big enough for its contents; or an exact number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next element is `AppBarLayout`, which is a `ViewGroup` that implements a
    number of the material designs app bar concepts. **Material design** is the latest
    **visual language** being developed and supported by Google. It provides a modern,
    consistent look and feel across Android apps. Its usage is encouraged by Google,
    and fortunately, the new `Activity` wizard has set us up to use it out of the
    box. The layout's width is set to `match_parent` so that it fills the screen,
    and the width is set to `wrap_content` so that's it's just big enough to show
    its content, which is a single `Toolbar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skipping the `include` element for a moment, the last element in the view is
    `FloatingActionButton`. Our only interest here is noting that the widget exists,
    should the need for one arise in other projects. As we did in the `Activity` class
    though, we need to remove this widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, there's the `include` element. This does what you would think it should--the
    specified file is included in the layout definition as if its contents were hard
    coded into the file. This allows us to keep our layout files small, reuse user
    interface element definitions (which is especially helpful for complex scenarios),
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The included file, `content_main.xml`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This preceding view uses `RelativeLayout` to wrap its only child, a `TextView`.
    Note that we can set the padding of a control. This controls how much space is
    *inside* the control around its children. Think of it like packing a box--inside
    the box, you may have a fragile ceramic antique, so you pad the box to protect
    it. You can also set the margin of a control, which is the space *outside* the
    control, akin to the personal space around us we are so often fond of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextView`, though, isn''t helpful, so we''ll remove that, and add what
    we really need, which is a `ListView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ListView` is a control that shows items in a vertically scrolling list. In
    terms of user experience, this works pretty much like the `ListView` we looked
    at in JavaFX. How it works, though, is quite different. To see how, we need to
    make some adjustments to activity''s `onCreate()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things going on here, which sets us up nicely for discussing
    data access in Android. Before we get to that in detail, though, a quick overview
    is in order:'
  prefs: []
  type: TYPE_NORMAL
- en: We check to make sure that the device has a working network connection via `isNetworkAvailable()`,
    which we'll look at later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the connection is available, we configure the user interface, starting with
    setting the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create an instance of `SunagoCursorAdapter`, which we'll discuss in
    detail later. For now, though, just note that an `Adapter` is how the `ListView`
    is connected to the data source, and they can be backed by things as varied as
    an SQL datasource or an `Array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass the adapter to `ListView`, thus completing this connection via `ListView.setAdapter()`.
    Much like JavaFX's `Observable` model property, we'll be able to use this to update
    the user interface without direct interaction any time the data changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set up an `onClick` listener for the items in the list. We'll use this
    to display the item the user taps (or clicks) on in an external browser. In a
    nutshell, given the `position` parameter, we get the item at that position, a
    `Cursor`, extract the URL of the item, then display the page at that URL using
    the device's default browser via an `Intent` (which we'll discuss in detail later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, completing our data binding, we initialize the `LoaderManager` that
    will handle loading and updating the `Adapter` in an asynchronous manner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One last bit of code to look at before diving into data access--`isNetworkAvailable()`--
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start by getting a reference to the system service,
    `ConnectivityManager`, then we loop through each `Network` known to the system.
    For each `Network`, we get a reference to its `NetworkInfo` and call `isConnected()`.
    If we find one connected network, we return true, otherwise, we return false.
    In the calling code, if our return value is `false`, we show an error dialog,
    the method for which is shown here as well. This is a standard Android dialog.
    We have, however, added an `onClick` listener to the OK button, which closes the
    application. Using this, we tell the user that a network connection is needed,
    then close the app when the user taps on OK. It is debatable, of course, if this
    behavior is desirable, but the process for determining a device's network state
    is interesting enough, so I've included it here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn our attention now to how data access is often done in Android apps--`CursorAdapters`.
  prefs: []
  type: TYPE_NORMAL
- en: Android data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any platform, there are multiple ways to access data, from built-in facilities
    to homegrown APIs. Android is no different, so while you can write your own way
    to load data from some arbitrary data source, unless you have very particular
    requirements, there is often no need, as Android has a system built in--the `ContentProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: The Android documentation will tell you that a *content provider manages access
    to a central repository of data*, and that it offers a consistent, *standard interface
    to data that also handles inter-process communication and secure data access*.
    If you intend to expose your application's data to external sources (either for
    read or write), `ContentProvider` is a great way to go. However, if you don't
    intend to expose your data, you are more than welcome to write the needed CRUD
    methods yourself, manually issuing various SQL statements. In our case, we'll
    use a `ContentProvider`, as we have an interest in allowing third-party developers
    access to the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `ContentProvider`, we need to create a new class that extends `ContentProvider`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to register the provider in `AndroidManfest.xml`, which we''ll
    do like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Interaction with `ContentProvider` is never done directly. The client code will
    specify the URL of the data to be manipulated, and the Android system will direct
    the request to the appropriate provider. To make sure our `ContentProvider` functions
    as expected, then, we need to register the provider's authority, which we've already
    seen in the previous XML. In our provider, we'll create some static fields to
    help us manage the parts of our authority and the related URLs in a DRY manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields in the preceding bit of code are private, as they're not
    needed outside the class. We define them as separate fields here, though, for
    clarity's sake. The third field, `CONTENT_URI`, is public, as we'll be referencing
    that field elsewhere in our app. Third-party consumers won't have access to the
    field, obviously, but will need to know its value, `content://com.steeplesoft.sunago.SunagoProvider/items`,
    which we would document somewhere for add-on developers. The first part of the
    URL, the protocol field, tells Android that we're looking for a `ContentProvider`.
    The next section is the authority, which uniquely identifies a particular `ContentProvider`,
    and the final field specifies the type of data, or model, that we're interested
    in. For Sunago, we have a single data type, `items`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to specify the URIs we want to support. We only have two--one
    for the items collection, and one for a particular item. Please, refer to following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the last code, we start by creating a `UriMatcher`. Note that we pass `UriMatcher.NO_MATCH`
    to the constructor. It's not immediately clear what this value is for, but this
    is the value that will be returned if the user passes in a URI that doesn't match
    any of those registered. Finally, we register each URI with a unique `int` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, like many Android classes, we need specify an `onCreate` lifecycle hook
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`SunagoOpenHelper` is a child of `SQLiteOpenHelper`, which manages the creation
    and/or update of the underlying SQLite database. The class itself is pretty simple,
    and is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I've not shown the table creation DDL, as it's a pretty simple table creation,
    but this class is all you need to create and maintain your database. If you have
    multiple tables, you would issue multiple creates in `onCreate`. When the application
    updates, `onUpgrade()` is called to allow you to modify the schema if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `ContentProvider`, we need to implement two methods, one to read
    data, and one to insert (given the nature of the app, we''re not interested in
    deletes or updates right now). For reading data, we override `query()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This last code is where our URIs and their `int` identifiers come in. Using
    `UriMatcher`, we check the `Uri` passed in by the caller. Given that our provider
    is simple, the only one we need to do anything special for is `#2`, which is the
    query for a specific item. In that case, we extract the ID passed in as the last
    path segment, and add it to the selection criteria specified by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the query configured as requested, we get a readable `SQLiteDatabase`
    from our `openHelper`, and query it using the values passed by the caller. This
    is one of the areas where the `ContentProvider` contract comes in handy--we don't
    need to write any `SELECT` statements manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before returning the cursor, we need to do something to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this preceding call, we tell the system that we want the cursor notified
    when the data is updated. Since we're using a `Loader`, this will allow us to
    update the user interface automatically when data is inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For inserting data, we override `insert()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using `openHelper`, this time, we get a writable instance of the database, on
    which we call `insert()`. The insert method returns the ID of the row just inserted.
    If we get a non-zero ID, we generate a URI for the row, which we'll eventually
    return. Before we do so, however, we notify the content resolver of the change
    in the data, which triggers our auto-reload in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more step to finish our data loading code, though. If you look
    back on `MainActivity.onCreate()`, you''ll see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This last line tells the system that we want to initialize a `Loader` and that
    the `Loader` is `this` or `MainActivity`. In our definition of `MainActivity`,
    we''ve specified that it implements the `LoaderManager.LoaderCallbacks<Cursor>`
    interface. This requires us to implement a few methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In `onCreateLoader()`, we specify both what to load and where to load it. We
    pass in the URI of the `ContentProvider` we just created, we specify the fields
    we're interested in via the `ITEM_PROJECTION` variable (which is a `String[]`,
    and not shown here), and, finally, the sort order (which we've specified as the
    timestamp of the items in descending order so that we get the newest items on
    top). The method `onLoadFinished()` is where the auto-reload happens. Once a new
    `Cursor` is created for the updated data, we swap it in for the `Cursor` that
    `Adapter` is currently using. While you can write your own persistence code, this
    highlights why using the platform facilities, whenever possible, can be a wise
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one large item left to look at with regard to data handling-- `SunagoCursorAdapter`.
    Looking again at the Android Javadocs, we learn that *an* `Adapter` *object acts
    as a bridge between an* `AdapterView` *and the underlying data for that view*,
    and that `CursorAdapter` *exposes data from a* `Cursor` *to a* `ListView` *widget*.
    Often--if not in the majority of cases--a particular `ListView` will require a
    custom `CursorAdapter` to allow the underlying data to be rendered correctly.
    Sunago is no exception. To create our `Adapter`, then, we create a new class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty standard fare. The truly interesting parts come in the view
    creation, which is one of the reasons for being for a `CursorAdapter`. When the
    `Adapter` needs to create a new view to hold the data pointed to by the cursor,
    it calls the following method. This is where we specify what the view should look
    like with the call to `LayoutInflater.inflate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll look at our layout definition in a moment, but first, let''s take a
    look at `ViewHolder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finding views by ID can be an expensive operation, so a very common pattern
    is this `ViewHolder` approach. After the view is inflated, we immediately look
    up the fields we're interested in, and store those references in a `ViewHolder`
    instance, which is then stored as the tag on the `View`. Since views are recycled
    by the `ListView` class (meaning, they're reused as needed as you scroll through
    the data), this expensive `findViewById()` is called once and cached per `View`
    rather than once per item in the underlying data. For large datasets (and complex
    views), this can be a substantial performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we also set the size of the `ImageView` class. Android doesn't
    support setting the width of a view to a percentage via the XML markup (given
    next), so we do that manually here as we create the `View`. We get the `WindowManager`
    system service from which we get the default display's size. We multiply the display's
    width by 0.33, which will restrict the image, if any, to 1/3 of the display's
    width, and set the `ImageView`'s width to that.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the view look like for each row?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the `ViewHolder` hinted, our view consists of an `ImageView` and a `TextView`,
    presented horizontally, thanks to the enclosing `LinearLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `CursorAdapter` calls `newView()` to create a `View`, it calls `bindView()`
    to--if you can imagine--bind the `View` to a specific row in the `Cursor`. This
    is where `View` recycling comes into play. The `Adapter` has a number of `View`
    instances cached, and passes one to this method as needed. Our method looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start by getting the `ViewHolder` instance. As discussed previously, we'll
    use the widget references stored here to update the user interface. Next, we pull
    the image URL from the cursor. It's up to each `SocialMediaItem` to decide how
    this field is populated, but it might be a tweeted image or a photo in an Instagram
    post. If the item has one, we need to download it so that it can be displayed.
    Since this requires a network operation, and we're running on the user interface
    thread, we hand that work off to `DownloadImageTask`. If there is no image for
    this item, we need to set the bitmap for the image to `null` (otherwise, the image
    that was there the last time this view instance was used would be displayed again).
    That frees up some memory, which is always good, but we also set the `ImageView`
    class' visibility to `GONE`, which hides it from the user interface. You might
    be tempted to use `INVISIBLE`, but that only makes it invisible **while preserving
    its space in the user interface**. The end result of that would be a big blank
    square, which is not what we want. Finally, we set the text of the `TextView`
    body to the text specified for the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image downloading is handled off-thread by an `AsyncTask`, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Android will create a background `Thread` on which to run this task. The main
    entry point for our logic is `doInBackground()`. Please refer the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is not the most robust download code imaginable (for example, redirect
    status codes are happily ignored), but it's certainly usable. Using Java 7's `try-with-resources`,
    we create a `URL` instance on which we call `openStream()`. Assuming no `Exception`
    is thrown in either of those operations, we call `BitmapFactory.decodeStream()`
    to convert the incoming bytes into a `Bitmap`, which is what the method is expected
    to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens to the `Bitmap` once we return it? We process that in `onPostExecute()`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this last method, we update `ImageView` with our now downloaded `Bitmap`,
    makes it `VISIBLE`, then request that the view update itself on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've built an app that's capable of displaying `SocialMediaItem` instances,
    but we have nothing for it to show. We'll fix that now with a look at Android
    Services.
  prefs: []
  type: TYPE_NORMAL
- en: Android services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the desktop version of Sunago, we defined an API that would allow third-party
    developers (or ourselves) to add support for an arbitrary social network to Sunago.
    That was a great goal for the desktop, and it''s a great goal for mobile. Fortunately,
    Android provides us with a mechanism that can be used to do just that: Services.
    *A Service is an application component representing either an application''s desire
    to perform a longer-running operation while not interacting with the user or to
    supply functionality for other applications to use*. While services were designed
    for more than extensibility, we can leverage this facility to that end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of ways to implement and interact with services, we
    are going to bind the services to our `Activity` so that their life cycle is tied
    to that of our `Activity`, and we''ll send messages to them asynchronously. We''ll
    start by defining our class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, these are the only methods required to create a service. Clearly,
    it doesn''t do much, but we''ll fix that in just a moment. Before we do that,
    we need to declare our new `Service` to Android which is done in `AndroidManifest.xml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, in addition to the service declaration, we also specify an `IntentFilter`
    via the `intent-filter` element. We''ll use that in `MainActivity` later to find
    and bind our services. While we''re looking at our service, though, let''s look
    at this side of the binding process. We''ll need to implement these two lifecycle
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These preceding methods are called when the service is bound and unbound, which
    give us an opportunity to register our receiver, which may lead to the question:
    What''s that? Android provides an **Interprocess Communication** (**IPC**), but
    it is somewhat limited in that the payload size can not exceed 1 MB. Though our
    payload is only text, we can (and certainly will, based on my testing) exceed
    that. Our approach, then, will be to use asynchronous communication, via a receiver,
    and have the service persist the data via our `ContentProvider`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a receiver, we extend `android.content.BroadcastReceiver` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our message scheme is very simple--Sunago sends the message `REFRESH`, and the
    service performs its work, which we have wrapped up in `TwitterUpdatesAsyncTask`.
    In `onBind()`, we register the receiver with a specific `IntentFilter` that specifies
    the `Intent` broadcasts that we're interested in. In `onUnbind()`, we unregister
    our receiver as the service is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of our service is in our `AsyncTask`, which is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We need to make sure that the network operation isn't performed on the user
    interface thread, so we perform the work in `AsyncTask`. We don't need any parameters
    passed into the task, so we set the `Params` and `Progress` types to `Void`. We
    are, though, interested in the `Result` type, which is `List<ContentValue>`, which
    we see reflected in both the type declaration and the return type of `execute()`.
    In `onPostExecute()`, we then issue a bulk insert on `ContentProvider` to save
    the data. In this way, we can make the newly-retrieved data available to the application
    without running afoul the 1 MB limit with `IBinder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our service defined, we need now to look at how to find and bind the services.
    Looking back at `MainActivity`, we''ll finally look at a method we''ve already
    seen mentioned, `findPlugins()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To find the plugins we're interested in, we create an `Intent` with a specific
    action. In this case, that action is `com.steeplesoft.sunago.intent.plugin`, which
    we've already seen in the service definition in `AndroidManifest.xml`. Using this
    `Intent`, we query `PackageManager` for all `IntentServices` matching Intent.
    Next, we iterate over the list of `ResolveInfo` instances, getting the `ServiceInfo`
    instances, and create and store a `ComponentName` representing the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual binding of the services is done in the following `bindPlugins()`
    method, which we call from the `onStart()` method to make sure the binding occurs
    at the appropriate time in activity''s lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For each plugin found, we create an `Intent` using the `ComponentName` we created
    earlier. Each service binding will need a `ServiceConnection` object. For that,
    we created `PluginServiceConnection`, which implements the interface. Its methods
    are empty, so we'll not look at that class here. With our `ServiceConnection`
    instance, we can now bind the service with a call to `bindService()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to clean up as the application is closing, we need to unbind our services.
    From `onStop()`, we call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply loop through our `ServiceConnection` plugins, passing each to
    `unbindService()`, which will allow Android to garbage collect any services we
    may have started.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve defined a service, looked it up, and bound it. But how do we
    interact with it? We''ll go the simple route, and add an option menu item. To
    do that, we modify `res/menu/main_menu.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To respond to the menu item being selected, we need to revisit `onOptionsItemSelected()`
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `switch` block of the preceding code, we add a `case` label for `R.id.action_refresh`,
    which matches the ID of our newly added menu item in which we call the method
    `sendRefreshMessage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first method is pretty straightforward. In fact, it might not even be necessary,
    given its simplicity, but it does add semantic clarity to the consuming code,
    so I think it's a good method to add.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part, however, is the method `sendMessage()`. We start by creating
    an `Intent` that specifies our action, `sunago.service`. This is an arbitrary
    string that we define, and then document for any third-party consumers. This will
    help our services filter out messages that are of no interest, which is exactly
    what we did in `TwitterService.onBind()` with the call to `registerReceiver(receiver,
    new IntentFilter("sunago.service"))`. We then add the message that our app wants
    to send (`REFRESH`, in this case) as an extra on `Intent`, which we then broadcast
    via `sendBroadcast()`. From here, Android will handle delivering the message to
    our service, which is already running (since we've bound it to our `Activity`)
    and listening (as we registered a `BroadcastReceiver`).
  prefs: []
  type: TYPE_NORMAL
- en: Android tabs and fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at quite a bit, but there is still a fair bit we haven't seen,
    such as the implementation for `TwitterClient`, as well as any details on the
    integration of networks, such as Instagram, which we saw in the last chapter.
    For the most part, `TwitterClient` is identical to what we saw in [Chapter 5](../Text/ec70a9e6-836b-4b8f-af0d-2438fd50ed1d.xhtml),
    *Sunago - A Social Media Aggregator*. The only major difference is in the use
    of the stream APIs. Some APIs are only available in certain Android versions,
    specifically, version 24, also known as Nougat. Since we're targeting Lollipop
    (SDK version 21), we are unable to use them. That aside, the internal logic and
    API usage are identical. You can see the details in the source repository. Before
    we finish, though, we need to take a look at the Twitter preferences screen, as
    there are some interesting items there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a tab layout activity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For making a tabbed interface, we need two things--`FragmentPagerAdapter` and
    `ViewPager`. The `ViewPager` is a user-interface element that actually shows the
    tabs. Think of it as `ListView` for tabs. The `FragmentPagerAdapter`, then, is
    like `CursorAdapter` for the tabs. Instead of an SQL-backed data source, though,
    `FragmentPagerAdapter` is an adapter that represents pages as Fragments. In this
    method, we create an instance of our `SectionsPagerAdapter`, and set it as the
    adapter on our `ViewPager`. We also associate the `ViewPager` element with the
    `TabLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: '`SectionsPagerAdapter` is a simple class, and is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The method `getCount()` tells the system how many tabs we support, the title
    for each tab that is returned by `getPageTitle()`, and the `Fragment` representing
    the selected tab is returned from `getItem()`. In this example, we create a `Fragment`
    instance as needed. Note, we hint at Instagram support here, but its implementation
    looks strikingly similar to the Twitter implementation, so we won't go into detail
    on that here.
  prefs: []
  type: TYPE_NORMAL
- en: '`TwitterPreferencesFragment` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Fragments have a slightly different lifecycle than an `Activity`. Here, we inflate
    the view in `onCreateView()`, then we update the user interface with the current
    state from `onStart()`. What does the view look like? That's determined by `R.layout.fragment_twitter_preferences`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, as you can see in the preceding code, we have a button for logging
    in and out, and a `ListView` for allowing the user to select which Twitter lists
    from which to load data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the frequent use of the network for interacting with Twitter plus Android''s
    aversion to network access on the user interface thread, the code here gets a
    little complicated. We can see the start of that in `updateUI()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that should stand out in the last code is that first line. Since
    we're updating the user interface, we have to make sure this code runs on the
    user interface thread. To make that happen, we wrap our logic in a `Runnable`,
    and pass that to the method `runOnUiThread()`. In `Runnable`, we check to see
    if the user is logged in or not. If not, we set the `prefsLayout` section's visibility
    to `GONE`, set the `Button`'s text to Login, and set its `onClick` listener to
    a `View.OnClickListener` method that executes `TwitterAuthenticateTask`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not logged in, we do the opposite--make `prefsLayout` visible,
    set the `Button` text to Logout, set the `onClick` to an anonymous `View.OnClickListener`
    class that removes the authentication-related preferences, and recursively call
    `updateUI()` to make sure the interface is updated to reflect the logout.
  prefs: []
  type: TYPE_NORMAL
- en: '`TwitterAuthenticateTask` is another `AsyncTask` that handles authenticating
    with Twitter. To authenticate, we have to get a Twitter request token, which requires
    network access, so this must be done off of the user interface thread, thus, `AsyncTask`.
    Please refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the `RequestToken`, we show the `WebLoginActivity` from which the
    user will enter the credentials for the service. We'll look at that in the next
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When that activity returns, we need to check the results and respond appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When we started `WebLoginActivity`, we specified that we wanted to get a result,
    and we specified an identifier, `LOGIN_REQUEST`, which is set to 1, to uniquely
    identify which `Activity` was returning the result. If `requestCode` is `LOGIN_REQUEST`,
    and the result code is `Activity.RESULT_OK` (see `WebLoginActivity` given next),
    then we have a successful response, and we need to finish the login process, for
    which we'll use another `AsyncTask`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In `doInBackground()`, we perform the network operation. When we have a result,
    the `AccessToken`, we use that to authenticate our `TwitterClient` instance, then
    we return the token. In `onPostExecute()`, we save the `AccessToken` details to
    `SharedPreferences`. Technically, all of this could have been done in `doInBackground()`,
    but I find it helpful, especially when learning something new, not to cut corners.
    Once you're comfortable with how all of this works, you are, of course, free to
    cut corners when and where you feel comfortable doing so.
  prefs: []
  type: TYPE_NORMAL
- en: We have one last piece to look over, `WebLoginActivity`. Functionally, it is
    identical to `LoginActivity`--it presents a web view which displays the login
    page for the given network. When the login succeeds, the needed information is
    returned to the calling code. This being Android rather than JavaFX, the mechanics
    are, of course, a little different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Most of this preceding code looks very much like the other `Activity` classes
    we've written. We do some basic user interface set up, then, getting a reference
    to the `Intent`, we extract the two parameters of interest--the URL of the login
    page, and the query parameter that indicates a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'To participate in the page loading life cycle, we extend `WebViewClient` (which
    we then attach to `WebView` in `Activity`, as seen previously). This is done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: While `WebViewClient` offers a myriad of life cycle events, we're only concerned
    with one right now, `onPageStarted()`, which is fired, as expected, when the page
    starts to load. By hooking in here, we can look at the URL before the related
    network activity begins. We can examine the desired URL to see if the query parameter
    of interest is present. If it is, we create a new `Intent` to pass data back to
    the caller, copy all of the query parameters to it, set the `Activity` result
    to `RESULT_OK`, and finish the `Activity`. If you look back at `onActivityResult()`,
    you should see now from where `resultCode` comes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our application is complete. It's not a perfect application, but
    it is a complete Android application, which demonstrates a number of features
    you might need in your own app including `Activities`, services, database creation,
    content providers, messaging, and asynchronous processing. Clearly, there are
    parts of the application where the error handling could be more robust, or the
    design generalized a bit more to be more readily reusable. Doing so in this context,
    however, would obscure the basics of the application too much. Making these changes,
    then, will make a great exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a completely different type of application.
    We'll build a small utility to handle what can be a serious problem--too much
    email. This application will allow us to describe a set of rules that will delete
    or move emails. It's a simple concept, but it will allow us to work with JSON
    APIs and the `JavaMail` package. You'll learn a bit and end up with a useful little
    utility as well.
  prefs: []
  type: TYPE_NORMAL

- en: Email and Spam Management with MailFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, we have a number of **laws**, the most famous of which
    is, perhaps, Moore's Law, which addresses the rate at which the computer processing
    power increases. Another law, although not as well known, and certainly not as
    serious, is one known as **Zawinski's Law**. Jamie Zawinski, best known for his
    role at Netscape and Mozilla, once noted that "Every program attempts to expand
    until it can read mail. Those programs which cannot so expand are replaced by
    ones which can." While Zawinski's Law hasn't been quite as accurate as Moore's
    Law, there does seem to be a ring of truth to it, doesn't there?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the spirit of Zawinski''s Law, even if not quite the letter, we will turn
    our attention to email in this chapter and see if we can address something that
    plagues us all: email clutter. Ranging from spam to mailing list postings, those
    messages just keep coming, and they keep piling up.'
  prefs: []
  type: TYPE_NORMAL
- en: I have several email accounts. As the head--and head geek--of my household,
    I'm often tasked with managing, whether they realize it or not, our digital assets,
    and while one little piece of spam might seem like nothing, over time, it can
    become a real problem. At a certain point, it almost seems too daunting to handle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take this very real, if perhaps somewhat overstated problem,
    and try to address it. That will give us the perfect excuse to use the standard
    Java email API, appropriately called JavaMail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaMail API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some more JavaFX work (of course)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating job schedules in Java with Quartz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing OS-specific services written in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be that you have your email inboxes well under control, in which case,
    congratulations! However, despite how tidy or overwhelming your mail client may
    be, we should have fun in this chapter while exploring the small but capable JavaMail
    API and the wonderful world of electronic mail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get too far into the application, let's stop and take a quick look
    at what is involved in email. For being such a ubiquitous tool, it seems that
    it's a fairly opaque topic for most people, even the technically minded who might
    be inclined to read a book such as this. If we're going to work with it, it will
    be extremely helpful to understand it, even if just a bit. If you are not interested
    in the details of the protocols themselves, then feel free to skip ahead to the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: A brief look at the history of email protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many great computing concepts, **email**--**electronic mail**--was first
    introduced in the 1960s, though it looked much different then. A thorough history
    of email, while certainly a great technical curiosity, is beyond the scope of
    our purposes here, but I think it would be helpful to take a look at a few of
    the email protocols still relevant today, those being SMTP for sending mail, and
    POP3 and IMAP for (from your email client's perspective) receiving mail. (Technically,
    the email is received by the server via SMTP as that is the on-the-wire protocol
    used by **Mail Transfer Agents** (**MTAs**), to transfer mail from one server
    to another. We non-MTA authors never think of it in those terms, so we need not
    be overly concerned by that distinction).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with sending an email, as our focus in this chapter will be more
    on folder management. **SMTP** (**Simple Mail Transport Protocol**), created in
    1982 and last updated in 1998, is the dominant protocol to send an email. Typically,
    in the days of SSL and TLS-secured connections, clients connected to the SMTP
    server via port 587\. The conversation between the server and a client, often
    referred to as a dialog, may look like this (as taken from the SMTP RFC at [https://tools.ietf.org/html/rfc5321](https://tools.ietf.org/html/rfc5321)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, the client shakes hands with the server, then says who
    the email is from and who it's going to. Note that the email addresses are listed
    twice, but it is only these first instances (`MAIL FROM` and `RCPT TO`, the latter
    of which is repeated for each recipient) that matter. The second set is simply
    for the formatting and display of the email. That peculiarity noted, the actual
    email comes after the `DATA` line, which should be fairly self-explanatory. The
    lone period on a line marks the end of the message, at which point, the server
    confirms receipt of the message, and we sign off by saying `QUIT`. This example
    looks very simple, and it is, but things get much more complicated when the message
    has an attachment, such as an image or office document, or if the email is formatted
    in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: While SMTP is used to send mail, the POP3 protocol is used to retrieve it. POP,
    or Post Office Protocol, was first introduced in 1984\. The bulk of the current
    standard, POP3, was introduced in 1988 with an update released in 1996\. POP3
    servers are meant to receive or download mail by a client such as Mozilla Thunderbird.
    If the server allows, the client can make an unsecured connection on port 110,
    with secure connections typically being made on port 995.
  prefs: []
  type: TYPE_NORMAL
- en: 'POP3 at one point was the dominant protocol by which users downloaded their
    mail. It was quick and efficient, and, for a while, our only option. Folder management
    was something that had to be done on the client side, as POP3 sees the mailbox
    as one big store, with no notion of folders (POP4 was intended to add some notion
    of folders, among other things, but there has not been any progress on the proposed
    RFC for several years). The POP3 (RC 1939, found at [https://tools.ietf.org/html/rfc1939](https://tools.ietf.org/html/rfc1939))
    gives this example dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the client sends a `RETR` command to retrieve the message, followed
    by a `DELE` command to remove it from the server. This seems to be the standard/default
    configuration for most POP3 clients.
  prefs: []
  type: TYPE_NORMAL
- en: Although, many clients can be configured to leave the mail on the server either
    for a certain number of days, or forever, possibly deleting the message from the
    server when it is deleted locally. If you've ever managed your mail this way,
    you've seen firsthand how this can complicate email management.
  prefs: []
  type: TYPE_NORMAL
- en: For example, back in the days before laptops, imagine you have one desktop computer
    at the office and one at the house. You'd like to be able to read your email in
    both locations, so you set up your POP3 client on both machines. You spend your
    work day reading, deleting, and maybe sorting email. When you get home, those,
    say, 40 messages you managed at work are now sitting in your inbox, in big bold
    letters to indicate an unread message. You now have to repeat your email management
    tasks at home if you have any hope of keeping the two clients in similar states.
    It was tedious and error prone, and that led us to the creation of IMAP.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMAP** or **Internet Access Message Protocol**, was created in 1986, with
    one of its design goals being permitting the complete management of a mailbox,
    folders, and all, by multiple clients. It has seen several revisions over the
    years, with IMAP 4 revision 1 being the current standard. Clients connect to an
    IMAP server on port 143 for unsecured connections, and 993 for SSL to TLS-based
    connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'IMAP, since it offers much more robust functionality than POP, is a more complicated
    protocol. From the RFC ([https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501)),
    we can look at the following sample dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's much more detail there than in our example POP3 dialog.
    This should also highlight why we're using an API like JavaMail rather than opening
    a socket and talking directly to the server ourselves. Speaking of JavaMail, let's
    turn our attention to this standard API and see what it can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: JavaMail, the Standard Java API for Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaMail API is a set of abstractions that provide a protocol and platform-independent
    way of working with email. While it is a required part of **Java Enterprise Edition**
    (**Java EE**), it is an add-on library for Java SE, meaning you'll have to download
    it separately, which we'll handle via our POM file.
  prefs: []
  type: TYPE_NORMAL
- en: Our primary interest with this chapter's application is message management,
    but we'll take a bit of time to look at sending email using the API, so you'll
    have something to work with should you ever find yourself needing to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start sending mails, we need to get a JavaMail `Session`. To do that, we''ll
    need to set up some properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll send email through Gmail''s server, and we''ll use SMTP over SSL. With
    this `Properties` instance, we can create our `Session` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To log in to the server, we need to specify credentials, which we do via the
    anonymous `PasswordAuthentication` instance. Once we have our `Session` instance,
    we need to create a `Transport` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for the protocol parameter, we specify `smtps`, which tells the JavaMail
    implementation that we want SMTP over SSL/TLS. We''re now ready to build our message
    using the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An email message is modeled using the `MimeMessage` class, so we create an
    instance of that using our `Session` instance. We set the from and to addresses,
    as well as the subject. To make things more interesting, we''ll attach a file
    using a `MimeBodyPart`, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our message will have two parts, modeled using `MimeBodyPart`, one is the body
    of the message, which is simple text, and the other is an attachment. In this
    case, we''re simply attaching a data file from our tests, which we''ll see later.
    Once we''ve defined the parts, we combine them using `MimeMultipart`, then set
    it as the content on our message, which we can now using the `transport.sendMessage()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Within just a few seconds, you should see the following email show up in your
    inbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dd554f8-c9ec-4b1a-8d9f-b0c28215ea48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to send an HTML email with a text alternative, you can do this
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we set the content on each `MimeBodyPart`, specifying the mime type,
    and when we create the `Multipart`, we pass alternative as the `subtype` parameter.
    Failure to do so will result in an email that shows both parts, one after the
    other, which is certainly not what we want. If we''ve written our application
    correctly, we should see something like the following in our email client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6a7a1c4-d024-48ea-8a82-d24e1dbfb7b7.png)'
  prefs: []
  type: TYPE_IMG
- en: You can't see the red text, of course, in black and white print, but you can
    see the bold and italicized text, which means the HTML version was shown, rather
    than the text version. Mission accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails is pretty fun, but we're here to learn about folder and message
    management, so let's turn our attention to that, and we'll start by setting up
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project, like the others, will be a multi-module Maven project. We'll have
    one module for all of the core code, and we'll have another for the GUI we'll
    write to help manage the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, we''ll do something a little different this time. Rather
    than creating the project using NetBeans, we''ll create it from the command line
    using Maven archetypes, which can be thought of roughly as project templates,
    so you can see how it''s done that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Maven has finished processing, change directory into the new project''s
    directory, `mailfilter-master`. From here, we can create the first of our projects,
    the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new project under `mailfilter-master` called `mailfilter-cli`.
    We can now open `mailfilter-cli` in NetBeans and get to work.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is spec out how we want this tool to work. At
    a high level, we want to be able to specify an arbitrary number of rules for an
    account. These rules will allow us to move or delete emails based on certain criteria,
    such as the sender or the email's age. To keep things simple, we'll scope all
    of the rules to a specific account, and limit the operations to move and delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at what the account may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is basically a very simple **POJO** (**Plain Old Java Object**) with six
    properties: `serverName`, `serverPort`, `useSsl`, `userName`, `password`, and
    `rules`. What are those annotations, though? Those come from a library called
    Bean Validation that provides some annotations and supporting code that allows
    us to express, declaratively, constraints on the values , which the variable can
    hold. Here are the annotations we''re using, and what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NotBlank`: This tells the system that the value can''t be null, nor can it
    be an empty string (effectively, `string != null && !string.trim() .equals("")`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotNull`: This tells the system that the value can''t be null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Min`: This describes a minimum valid value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, of course, many, many others, and the system defines a means for
    you to define your own, so it''s a very simple, yet very powerful framework to
    validate input, which brings up an important point: these constraints are only
    validated when the Bean Validation framework is asked to do so. We could easily
    build up a large collection of these `Account` instances with every field holding
    invalid data, and the JVM would be perfectly happy with that. The only way to
    apply the Bean Validation constraints is to ask it to check the instances we provide
    it with. In a nutshell, it''s the API and not the JVM that enforces these constraints.
    That may seem obvious, but, sometimes, it pays to be explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further, we need to add Bean Validation to our project. We''ll
    use the reference implementation: `Hibernate Validator`. We''ll also need the
    Expression Language API and an implementation in our project. We get all of those
    by adding the following dependencies to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting back to our model, there are some getters and setters, of course, but
    those are not very interesting. What is interesting, though, is the implementation
    of `equals()` and `hashCode()`. Josh Bloch, in his seminal work, Effective Java,
    says this:'
  prefs: []
  type: TYPE_NORMAL
- en: Always override `hashCode` when you override `equals`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main point of his assertion is that failure to do so violates the `equals()`
    contract, which states that equals objects must have equals hashes, which can
    result in incorrect and/or unpredictable behavior if your class is used in any
    hash-based collection, such as `HashMap`. Bloch then lists some rules to create
    a good `hashCode` implementation, as well as a good `equals` implementation, but
    here''s my advice: let the IDE do the work for you, which is what we''ve done
    in the following code block for `equals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done the same for `hashCode()` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that every method tested in `equals()` is also used in `hashCode()`. It's
    absolutely vital that your implementations follow this rule, or you'll end up
    with methods that don't really work as they should. It's possible that your IDE
    can help with this as you are generating the methods, but you must make sure that
    you are indeed using the same list of fields, and certainly, should you ever modify
    one of the methods, the other method must be updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have `Account`, so what does `Rule` look like? Let''s take a look at
    the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation on this class is two-fold. First, we can see the same field-level
    constraints we saw on `Account`: `type` cannot be null, `sourceFolder` cannot
    be blank, and `olderThan` must be at least 1\. While you may not recognize it
    for what it is, we also have a class-level constraint in `@ValidRule`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Field-level constraints can see only the field to which they have been applied.
    This means that if the valid values for a field are dependent on the value of
    some other field, these types of constraints are not appropriate. Class-level
    rules, though, allow us to look at the whole object when doing validation, so
    we can look to see what the value of one field is when validating another. This
    also means a bit more code for us, so we''ll start with the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In case you've never seen the source for an annotation before, this is a fairly
    typical example. Rather than declaring the type of the object to be `class` or
    `interface`, we used `@interface`, a subtle but important difference. The fields
    of the annotation are also a bit different, as there are no visibility modifiers,
    and the types cannot be primitives. Note the use of the `default` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The annotation itself also has annotations, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Target`: This restricts the types of elements this annotation can be applied
    to; in this case, types and other annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Retention`: This instructs the compiler whether or not it should write the
    annotation to the class file, and making it available at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Constraint`: This is a Bean Validation annotation that identifies our annotation
    as a new constraint type. The value of this annotation tells the system what `ConstraintValidator`
    processes the validation logic for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Documented`: This indicates that the presence of this annotation on any type
    should be considered a part of that type''s public API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `ConstraintValidator` implementation to handle this new constraint is a
    bit more complicated. We declared the class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Bean Validation provides a parameterized interface for constraint validation
    that takes the type of the constraint and the object type to which the logic in
    the validator applies. This allows you to write different validators of a given
    constraint for different object types. In our case, we could specify `Rule` rather
    than `Object`. If we were to do that, any time something other than `Rule` is
    annotated with `@ValidRule` and the instance is validated, the calling code will
    see an exception thrown. What we've done instead, as you will see, is validate
    the annotated type, specifically adding a constraint violation if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface requires that we implement this method as well, but we have no
    work to be done here, so it has an empty method body, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting method is called `isValid()`. It''s a bit long, so let''s step
    through it piece by piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to make sure `value` is not null. We have two choices: return
    `true` if it''s null, indicating there''s no problem, or return `false`, indicating
    that there is a problem. Our choice depends on how we want the application to
    behave. Reasonable arguments can be made for either approach, but it seems that
    it would make sense for a null `Rule` to be considered invalid, so let''s change
    the body of that for it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We build `ConstraintViolation` using the specified message, add that to `ConstraintValidatorContext`,
    `ctx`, and return false to indicate a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to make sure we''re dealing with an instance of `Rule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''re sure we have a non-null instance of `Rule`, we can get to the heart
    of our validation logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like to be able to gather all of the violations, so we create a `boolean`
    variable to hold the current state, then we cast the value as `Rule` to make dealing
    with the instance a bit more natural. In our first test, we make sure that, if
    the type of `Rule` is `RuleType. MOVE`, it has a destination folder specified.
    We do so using this private method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `value` is blank, we add `ConstraintViolation`, as we've already seen, using
    the specified message, and return `false`. If it is not blank, we return `true`.
    This value is then ANDed with `valid` to update the current state of the `Rule`
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isBlank()` method is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a very common check, and is actually logically identical to the validator
    behind Bean Validation's `@NotBlank`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next two tests are related. The logic is this: the rule must specify either
    text to match, or a maximum age in days. The test for that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Rule` specifies `matchingText`, then we validate that `fields` has been
    set properly. If neither `matchingText` nor `olderThan` were set, then we add
    `ConstraintViolation` with a message to that effect and set `valid` to false.
    Our `fields` validation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We make sure that `fields` is neither null nor empty. We do not do any validation
    here on the actual contents of the field `Set`, though we certainly could.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now written, possibly, our very first custom validation. Your reaction
    is likely something like, "Wow! That''s a lot of code for a ''simple'' validation",
    and you''re right. Before you throw the baby out with the bath water, think about
    this: the value of Bean Validation is that you can take potentially complex validation
    logic and hide it behind a very small annotation. You can then reuse this logic
    wherever you want simply by placing your constraint annotation in the appropriate
    places. The logic is expressed in one place, maintained in one place, but used
    in many, all very neatly and concisely.'
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, that's a good deal of code, but you only have to write it once, and
    the consumers of the constraints never need to see it. There's not really much
    extra work over and above what you'd normally write, but it's up to you to decide
    if this extra bit of work is worth the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve taken a quick look at custom Bean Validation constraints, let''s
    return to our data model. The final piece to show is the `RuleType` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic Java `enum` with two possible values, `DELETE` and `MOVE`, but
    we've also added a helper method to return the appropriate `RuleType` instance
    for a given String representation. This will help us when we're unmarshaling a
    `Rule` from JSON, for example.
  prefs: []
  type: TYPE_NORMAL
- en: With our data model defined, we're ready to start writing the code for the utility
    itself. While the Maven module is called `mailfilter-cli`, we will not concern
    ourselves here with a robust command-line interface, like we saw in previous chapters.
    Instead, we'll provide a very basic interaction with the command line, leaving
    an OS service, which we'll look at later, as the preferred means of usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is at this point that we will begin using the JavaMail API, so we need to
    make sure we have our project set up correctly, so we add the following lines
    of code to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our IDE, we create a new class, `MailFilter`, and create the familiar `public
    static void main` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: NetBeans supports a number of code templates. The template of interest here
    is `psvm`, which will create a `public static void main` method. To use it, make
    sure you are on an empty line inside the class definition (to avoid odd formatting
    issues), then type `psvm` and press tab. NetBeans creates the method for you and
    places the cursor on the first line of the empty method, ready for you to start
    coding. You can find dozens of other helpful code templates by navigating to Tools
    | Options | Editor | Code Templates. You can even define your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` method, we create an instance of `MainFilter`, passing in any
    rule definition file that may have been specified on the command line, and calling
    `run()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating an instance of `AccountService`, which wraps up the details
    of reading and writing the `Rules` file. For each account in the specified file,
    we create `AccountProcessor`, which encapsulates the rule processing logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AccountService` instance may not sound very exciting, but there are some
    pretty interesting technical bits hidden away behind that public interface. We
    see where the Bean Validation constraints are actually checked, and we also see
    the use of the Jackson JSON library to read and write the `Rules` file. Before
    we can start using Jackson, we need to add it to our project, which we do by adding
    this `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You should, as always, make sure that you are on the latest version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a big class to start with, but only three methods are of any interest
    here. We''ll start with the most basic one, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The only reason I include this here is that reading a file from the user's home
    directory is something I find myself doing fairly frequently, and you might too.
    This example shows you how to do just that, attempting to find the rule file at
    `~/.mailfilter/rules.json` if the user does not specify a file explicitly. Generated
    or specified, if the rule file can't be found, we throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most interesting method is the `getAccounts()` method. We''ll step
    through this one slowly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These three statements are setting up some objects required to process the accounts.
    The first is `Validator`, which is the Bean Validation class that is our entry
    point to apply and check the constraints we've described on our data models. The
    next, `ObjectMapper`, is a Jackson class that will map a JSON data structure onto
    our Java data model. We need to specify `ACCEPT_SINGLE_VALUE_AS_ARRAY` to make
    sure that Jackson properly handles any lists in our model. Finally, we create
    `List` to hold our `Account` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the rules file into memory and getting that as instances of our data
    model is extremely easy with Jackson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since the property names in our Java classes match the keys used in our JSON
    file, `ObjectMapper` can easily read the data from the JSON file and build our
    in-memory model with just this one line. Note the `TypeReference` instance. We
    want Jackson to return a `List<Account>` instance, but due to some design decisions
    in the JVM, direct access to parameterized types at runtime is not possible. The
    `TypeReference` class, however, helps capture this information, which Jackson
    then uses in creating the data model. If we passed `List.class`, we would get
    a type cast failure at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `Account` instances, we''re ready to start validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using `List.forEach()`, we iterate over each account in `List` (the null check
    was not shown here). For each `Account`, we call `validator.validate()`, which
    is when the constraints are actually validated. Up to this point, they were just
    annotations stored in the class, with the JVM happily carrying them along, but
    not doing anything else with them. Bean Validation, as we discussed earlier, is
    the enforcer of the constraints described by the annotations, and here we see
    that manual API call.
  prefs: []
  type: TYPE_NORMAL
- en: When the call to the `validator` returns, we need to see if there were any `ConstraintViolations`.
    If there were, we fairly naively print a message to standard out detailing each
    of the failures. If the rule has multiple violations, thanks to how we wrote our
    validator, we'll see them all at once, so the user can fix them without having
    to attempt to process the rules multiple times. Printing these to the console
    is not necessarily the best approach, as we can't process them programmatically,
    but it is sufficient for our needs at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where Bean Validation really shines is in frameworks that integrate it on your
    behalf. For example, JAX-RS, the standard Java API to build REST resources, offers
    this type of integration. We see a usage of the functionality in this sample REST
    resource method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GET`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public Response getSomething (`'
  prefs: []
  type: TYPE_NORMAL
- en: '`@QueryParam("foo") @NotNull Integer bar) {`'
  prefs: []
  type: TYPE_NORMAL
- en: When a request is routed to this method, JAX-RS ensures that the query parameter
    `foo` is converted, if possible, to an `Integer`, and that it is not `null`, so
    in your code, you can assume that you have a valid `Integer` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method we want to look at in this class is `saveAccounts()`, which,
    as crazy as it may sound, saves the `Account` instances to the rules file specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Much like reading the file, writing to it is extremely simple, so long as your
    Java classes and your JSON structures match. If you do have differing names (for
    example, the Java class may have the `accountName` property, while the JSON file
    uses `account_name`), Jackson offers some annotations that can be applied to the
    POJO to explain how to map the fields correctly. You can find complete details
    for those on Jackson's website ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)).
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `Account` instances loaded into memory and validated for correctness,
    we now need to process them. The entry point is the `process()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The three lines to pay attention to are the calls to `getImapSession()`, `getRulesByFolder()`,
    and `processFolder()`, which we''ll look at in detail now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an IMAP `Session`, as we saw earlier in this chapter, we create a `Properties`
    instance and set a few important properties. We get a `Store` reference using
    the protocol specified by the user in the rule file: `imap` for non-SSL-based
    connections and `imaps` for SSL-based connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our session, we then iterate over our rules, grouping them by
    source folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now process the folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using `Stream`, we iterate over each message in the source folder, filtering
    for only those that match `SearchTerm`, but what is that, and where did it come
    from?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of extra items on the `Rule` class that we haven''t looked
    at yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We add a private field to cache `SearchTerm` so we don't have to create it more
    than once. It's a minor optimization, but we want to avoid unnecessary performance
    hits from recreating `SearchTerm` for every message on a large folder. If the
    rule has a `matchingText` set, we create a `List<SearchTerm>` based on the fields
    specified. Once we have that list, we wrap it in `OrTerm`, which will instruct
    JavaMail to match the message if *any* of the specified fields match the text.
  prefs: []
  type: TYPE_NORMAL
- en: If `olderThan` is set, then we create `SentDateTerm` to match any messages that
    were sent at least `olderThan` days ago. We save the `SearchTerm` reference in
    our private instance variable then return it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the method has the `@JsonIgnore` annotation. We use this to make
    sure that Jackson doesn't try to marshall the value returned by this getter to
    the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, `createFieldSearchTerm()` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how are the messages actually moved or deleted? There is, of course, a
    JavaMail API for that, whose usage might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We do a quick null check, then we get a reference to the messages `Folder`.
    With that, we instruct JavaMail to set a flag, `FLAGS_DELETED`, on the messages
    in the folder. The JavaMail API more often than not works on arrays of `Message`
    (`Message[]`), so we need to wrap `Message` in an array as we pass it to `setFlags()`.
    As we finish up, we increment our deleted message counter so we can print our
    report when we're finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving a `Message` is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The bulk of this method looks just like `deleteMessage()`, but there is a subtle
    difference. JavaMail doesn't have a `moveMessages()` API. What we have to do instead
    is call `copyMessages()` to create a copy of the message in the destination folder,
    then delete the message from the source folder. We increment the moved counter
    and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final two methods of interest deal with folders. First, we need to get
    the folder, which we do here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For performance reasons, we cache each `Folder` instance in `Map`, keyed by
    the folder name. If we find `Folder` in `Map`, we use that. If we do not, then
    we ask the IMAP `Store` for a reference to the desired `Folder`, and cache it
    in `Map`. Finally, we make sure `Folder` is open, or our move and delete commands
    will throw `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make sure we close the `Folder` when we''re finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We filter our stream of `Folder` for only those that are open, then call `folder.close()`,
    swallowing any failure that might occur. At this point in the processing, there's
    not much that can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Our mail filter is now technically complete, but it's not as usable as it could
    be. We need some way to run this on a schedule, and being able to view and edit
    the rules in a GUI would be really nice, so we'll build both of those. Since it
    doesn't make sense to schedule something if we have nothing to run, we'll start
    with the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we want to make this as easy to use as possible, we''ll now build a GUI
    to help manage these rules. To create the project, we''ll use the same Maven archetype
    we used in creating the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the POM has been created, we need to edit it a bit. We need to set the
    parent by adding this element to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a dependency on the CLI module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re not depending on NetBeans to generate the JavaFX project for us,
    we''ll also need to create a few basic artifacts by hand. Let''s start with the
    application''s entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very typical JavaFX main class, so we''ll skip right to the FXML
    file. For now, we''ll just create a stub using the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a working JavaFX application that starts and runs, but doesn't
    do much else. In previous chapters, we've walked through building a JavaFX application
    in painstaking detail, so we won't do that again here, but there are some interesting
    challenges in this one that are worth taking a look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a sense of what we''re working toward, here''s a screenshot of
    the final user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6217bcf-fb27-4bc2-b84c-dbba3296e5d9.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left, we have `ListView` to display the `Account` configured in our rules
    file. Below `ListView`, we have a few controls to edit the currently selected
    `Account`. On the right, we have `TableView` to display the `Rule`, and a similar
    area below it for editing a `Rule`.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on `Account` or `Rule`, we want the form area below to
    be populated with the relevant information. As the user modifies the data, `Account`/`Rule`
    as well as `ListView`/`TableView` should be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinarily, this is one of the areas in which JavaFX really shines, that of
    property binding. We''ve already seen a small part of that with `ObservableList`:
    we can add an item to `List`, and it is automatically added to the UI component
    to which it has been bound. The situation we find ourselves in now is a little
    different though, in that our model is a POJO, one that doesn''t use any JavaFX
    APIs, so we don''t get that functionality quite so easily. Let''s look at what
    it will take to wire these things together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the `Account` list. We have `ObservableList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We add our accounts to this `ObservableList` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we bind `List` and `ListView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where things change a little bit. To encapsulate our POJO binding setup,
    we''ll create a new class called `AccountProperty`, which we''ll look at shortly.
    Although, let''s first add the following code snippet to handle the `ListView`
    clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks on `ListView`, we set `Account` on the `AccountProperty`
    instance. Before we leave this method and look at `AccountProperty`, we need to
    set up one last item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We define `ChangeListener`, which simply calls `accountsListView.refresh()`,
    which instructs `ListView` to redraw itself. We'll want it to do this when the
    model itself is updated, a change that `ObservableList` doesn't bubble up to `ListView`.
    The next two lines add `Listener` to `serverName` and `userName``TextField`. These
    two controls edit the properties by the same name on `Account`, and are the only
    two used to generate the display String for `ListView`, which we don't show here.
  prefs: []
  type: TYPE_NORMAL
- en: '`AccountProperty` is a custom JavaFX property, so we extend `ObjectPropertyBase`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This offers part of the binding solution, but the heavy lifting is handled
    by a class from the excellent JFXtras project, `BeanPathAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The JFXtras library is not, as of the writing of this book, Java 9 compatible.
    All we need from the library is this one class, so I have copied the source of
    class from the JFXtras repository into this project for the time being. Once JFXtras
    runs under Java 9, we can remove this copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation describes this class as an "adapter that takes a POJO bean
    and internally and recursively binds/unbinds its fields to other `Property` components".
    This is an extremely powerful class that we can''t cover in its entirety here,
    so we''ll just jump to our particular usage, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`BeanPathAdapter` allows us to bind a JavaFX `Property` to a property on a
    POJO, which could be nested to an arbitrary depth and referenced using a dot-separated
    path notation. In our case, the properties are top-level properties on the `Account`
    object, so the path is short and simple. After we''ve bound our controls to the
    properties, we add a `Listener` to update the `ObservableList` rules with `Rule`
    for the current account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set()` method that is called in the preceding code when the `Account`
    selection changes in `ListView` is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With these pieces in place, the `Account` object is updated as we type in the
    various controls, and the `ListView` label is updated as the `serverName` and/or
    `userName` fields are edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to do the same for the `TableView` that will display each `Rule`
    the user has configured. The setup is almost identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the same basic structure: instantiate `RuleProperty`, create `ChangeListener`
    to request that `TableView` refresh itself, and add that listener to the relevant
    form fields.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RuleProperty` is also similar to `AccountProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The biggest difference here is `Listener` that is created. Given the use of
    `CheckListView`, a custom control from the great ControlsFX project, it''s worth
    noting the logic: we get `IndexedCheckModel`, which we clear, then we iterate
    over each field, finding its index in `CheckModel` and checking it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We control updating the value of the fields set on `Rule` via `RuleFieldChangeListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`ListChangeListener` tells us what was removed and what was added, so we processed
    those accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other moving parts to the GUI, but we''ve seen them in one
    for another in previous chapters, so we''ll not cover them here. If you''re curious
    about these details, you can find them in this book''s source code repository.
    Let''s turn our attention to the final part of our project: the OS-specific service.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the stated goals of this project is to be able to define rules to manage
    and filter email, and to have it run more or less all the time, not just when
    the email client is running. (There is, of course, not much we can do about the
    machine running this being turned off, so we can't promise constant coverage).
    To fulfill this part of the promise, we'll need a few extra parts. We already
    have the part of the system that does the actual work, but we also need a way
    to run that part on a schedule, and we also need a part that will start the scheduled
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the scheduling aspect, we have many options, but we''ll use a library called
    Quartz. The Quartz Job Scheduling Library is an open source library that can be
    used in Java SE as well as Java EE applications. It provides a clean and simple
    API that is perfect for use here. To add Quartz to our project, we need to do
    this to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'How simple is the API? Here''s our `Job` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We extend `org.quartz.Job` overriding `execute()`, in which we simply instantiate
    `MailFilter` and call `run()`. That''s really all there is to it. With our job
    defined, we just need to schedule it, which we''ll do in `MailFilterService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We begin by getting a reference to the default `Scheduler` and starting it.
    Next, we create a new job using `JobBuilder`, then build `Trigger` using `TriggerBuilder`.
    We tell `Trigger` to start executing now, but note that it won't start until it
    is actually built and assigned to `Scheduler`. Once that happens, `Job` will execute
    immediately. Finally, we define `Schedule` for `Trigger` using the `SimpleScheduleBuilder`
    helper class, specifying a fifteen minute interval, which will run forever. We
    want this to run until the computer is shut down or the service is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: If we run/debug `MailFilterService` now, we can watch `MailFilter` run. If you
    do this, and you're not extremely patient, I would suggest that you lower the
    interval to something more reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with one final piece: the OS integration. In a nutshell, what
    we want to be able to do is run `MailFilterService` when the operating system
    boots up. Ideally, we''d prefer not to have ad hoc scripts cobble together to
    make this happen. Fortunately, we are again presented with a number of options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the excellent Java Service Wrapper library from Tanuki Software
    (details of which can be found at [https://wrapper.tanukisoftware.com](https://wrapper.tanukisoftware.com/)).
    While we can manually build the service artifacts, we''d much rather let our build
    do the work for us, and, of course, there''s a Maven plugin, called `appassembler-maven-plugin`,
    to do just that. To integrate them both into our project, we need to modify the
    `build` section of our POM by adding the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The transitive dependencies of this plugin will pull in everything we need
    for the Java Service Wrapper, so all we need to do is configure our usage .We
    start by adding an execution, telling Maven to run the `generate-daemons` goal
    when packaging the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to configure the plugin, which we do with the `configuration`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `repositoryLayout` option tells the plugin to build a **lib** style repository,
    as opposed to the Maven 2 style layout, which is a number of nested directories.
    This is largely a style concern, at least for our purposes here, but I find it
    helpful to be able to scan the generated directory and see what is included at
    a glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define the **daemons** (another term for OS service that comes
    from the Unix world and which stands for **Disk And Execution Monitor**) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The Java Service Wrapper is a very flexible system, providing a number of ways
    to wrap your Java project. Our needs are simple, so we instruct it to use `WrapperSimpleApp`
    and point it to the main class, `MailFilterService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin supports a couple of other service wrapper methods, but we''re interested
    in the Java Service Wrapper, so we specify that here, with the `platform` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to configure the generator, telling it which OS to support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Each of those OS definitions offers a 32-bit option that you can add if needed,
    but, for the sake of brevity, I've omitted them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we build the app now, either via `mvn package` or `mvn install`, this
    plugin will generate a wrapper for our service, complete with binaries appropriate
    for the configured operating systems. The nice thing is that it will build wrappers
    for each OS, regardless of what OS the build is actually run under. For example,
    here''s the output of building this on a Windows machine (note the Linux and Mac
    binaries):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa36d256-0b22-4cf4-bf7f-7356b2448c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: The wrapper is capable of much, much more, so if you're interested, you can
    read all the details on Tanuki Software's website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like that, once again, our application is **finished**. We've covered quite
    a bit in this chapter. We started by learning a little bit about the history and
    technical details of several email protocols (SMTP, POP3, and IMAP4), then learned
    how to interact with services based on those using the JavaMail API. In the process
    of doing so, we discovered the Jackson JSON Parser and used it to marshal and
    unmarshal POJOs to and from the disk. We used the ControlsFX class, `BeanPathAdapter`,
    to bind non-JavaFX-aware POJOs to JavaFX controls, and the Quartz Job Scheduling
    Library to execute code on a schedule. Finally, we wrapped up our application
    using the Java Service Wrapper to create installation artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: We're left with what I hope is an application that is both interesting and helpful.
    There are several ways to improve on it, of course, if you feel so motivated.
    The account/rule data structure could be extended to allow defining global rules
    that are shared across accounts. The GUI could support viewing email in the folders
    on the account and generating rules based on live data. The build could be extended
    to create an installer for the application. You can probably think of many more.
    Always feel free to check out the code and hack away. If you come up with something
    interesting, be sure to share it, as I'd love to see what you've done.
  prefs: []
  type: TYPE_NORMAL
- en: With another project wrapped up (no pun intended), we're ready to turn our attention
    to another. In the next chapter, we'll spend our entire time in a GUI and build
    a photo management system. This will give us the opportunity to look at some of
    JDK's imaging handling capabilities, including the newly added TIFF support, a
    feature that should make image aficionados quite happy. Turn the page and let's
    get started!
  prefs: []
  type: TYPE_NORMAL

- en: Photo Management with PhotoBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've written libraries. We've written command-line utilities. We've
    also written GUIs using JavaFX. In this chapter, we're going to try something
    completely different. We're going to build a photo management system, which, of
    course, needs to be a graphical application, but we're going to take a different
    approach. Rather than using pure JavaFX and building everything from the ground
    up, we'll use an existing application framework. That framework is the NetBeans
    **Rich Client Platform** (**RCP**), a mature, stable, and powerful framework,
    that powers not just the NetBeans IDE we've been using, but countless applications
    in a myriad of industries from oil and gas to air and space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to bootstrap a NetBeans RCP project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate JavaFX with the NetBeans RCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of an RCP application such as Nodes, Actions, Lookups, Services,
    and TopComponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado then, let's jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the question at or near the top of your list is, **Why would I want
    to use NetBeans RCP?**. Before we get into the details of the application, let's
    address this very fair question, and try to understand why we're building it the
    way we are.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things you'll notice when you start looking into the NetBeans
    platform is the strong notion of modularity. With the Java Module System being
    such a prominent feature of Java 9, this may seem like a minor detail, but NetBeans
    exposes this concept to us at the application level, making plugins incredibly
    simple, as well as allowing us to update the application on a piecemeal basis.
  prefs: []
  type: TYPE_NORMAL
- en: The RCP also provides a robust, well-tested framework for handling windows,
    menus, actions, nodes, services, and so on. If we were to build this application
    from scratch, as we've done in the previous chapters using **plain** JavaFX, we
    would have to manually define areas on the screen, then handle window placement
    by hand. With the RCP, we have a rich windowing specification already defined,
    which we can easily use. It offers features such as maximizing/minimizing windows,
    sliding, detaching, and docking windows, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The RCP also provides a strong notion of **nodes**, an encapsulation of domain-specific
    data in a user interface concept, which is most often seen as entries in a tree
    view on the left side of an application, as well as actions that can be associated
    with these nodes (or menu items) to act on the data they represent. Again, all
    of this can be done in JavaFX (or Swing), but you would have to code all of these
    features yourself. In fact, there are a number of open source frameworks that
    offer to do just that, such as Canoo's Dolphin Platform ([http://www.dolphin-platform.io](http://www.dolphin-platform.io/)),
    though none have had the years of production hardening and testing that the NetBeans
    RCP has had, so we'll keep our focus here.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How you create a NetBeans RCP project will have a very fundamental impact on
    how the rest of the project will be approached. By default, NetBeans uses Ant
    as the build system for all RCP apps. Almost all of the online documentation from
    the NetBeans project, and blog entries from the NetBeans evangelists, often reflect
    this preference as well. We've been using Maven for every other project, and we're
    not going to change that here. Fortunately, NetBeans does allow us to create an
    RCP project with Maven, which is what we'll do.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba9bc9dd-b737-4aa3-a707-a312c86746f0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the New Project window, we select Maven, then NetBeans Application. On the
    next screen, we configure the project as usual, specifying the project name, photobeans,
    project location, package, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click on Next, we''ll be presented with the Module Options step of
    the New Project wizard. In this step, we configure some basic aspects of the RCP
    application. Specifically, we need to specify the version of the NetBeans APIs
    we''ll use, and whether or not we want to use OSGi bundles as dependencies, as
    seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/431c03b2-1ada-42a4-b11a-f9dc98c1bad4.png)'
  prefs: []
  type: TYPE_IMG
- en: At the time of writing, the latest platform version is RELEASE82\. By the time
    Java 9 ships, it is reasonable to expect that NetBeans 9.0, and, therefore RELEASE90,
    will be available. We want the latest version available, but note that, depending
    on the release schedule of the NetBeans project, it may very well *not* be 9.0\.
    For the Allow OSGi bundles as dependencies option we can safely accept the default,
    though changing it won't cause us any issues, and we can easily change the value
    later should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is created, we should see three new entries in the projects
    window: `PhotoBeans-parent`, `PhotoBeans-app`, and `PhotoBeans-branding`. The
    `-parent` project has no real deliverables. Like the `master` projects from other
    chapters, this serves merely to organize related modules, coordinate dependencies,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Branding your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-branding` module is where we can define, as you may have already guessed,
    the details of the application''s branding. You can access these branding properties
    by right-clicking on the branding module, and selecting `Branding...` near the
    bottom of the content menu. Upon doing so, you will be prompted with a screen
    like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02d5bdd7-9ad3-49b3-9c52-c3ce3f628ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this preceding tab, you can set or change the name of the application, as
    well as specify the application icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Splash Screen tab, you can configure, most importantly, the image that
    is displayed on the splash screen as the application loads. You can also enable
    or disable the progress bar, and set the colors, font sizes, and positions of
    the progress bar and startup messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/685b88d8-5aea-485d-a7a8-9b61469cee2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only other tab that is of interest to us at the moment is the Window System
    tab. In this tab, we can configure a number of features such as window drag and
    drop, window sliding, closing, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55bc7aca-986d-41de-9ac5-2c7a101ee28b.png)'
  prefs: []
  type: TYPE_IMG
- en: More likely than not, the defaults are acceptable for our purposes here. However,
    in your own NetBeans RCP application, this screen may be much more important.
  prefs: []
  type: TYPE_NORMAL
- en: Our main interest is the `-app` module. This module is the one that will define
    all of the application's dependencies, and will be its entry point. Unlike the
    JavaFX applications we've seen in previous chapters, though, we don't need to
    define a `public static void main` method, as NetBeans handles that for us. In
    fact, the `-app` module doesn't have any Java classes in it at all, yet the app
    can run right out-of-the-box, though it doesn't do much. We'll fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the strengths of the NetBeans platform is its modularity. If you''ve
    ever used the NetBeans IDE itself (before, say, reading this book), you''ve seen
    this modularity in action when working with plugins: every NetBeans plugin is
    made up of one or more modules. In fact, NetBeans itself is composed of numerous
    modules. That''s how RCP applications are designed to work. It promotes decoupling,
    and makes extending and upgrading the application much simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generally accepted pattern is to, say, put the API classes in one module
    and the implementations in another. This makes the API classes reusable by other
    implementers, can help enforce low coupling by hiding private classes, and so
    on. To keep things simple as we learn the platform, though, we are going to create
    just one module that will provide all of the core functionality. To do that, we
    right-click on the Modules node under the parent project, and select Create New
    Module...: as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51979733-3823-4037-a5ff-4fdf71d46acf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once selected, you will be shown the New Project window. Here, you will need
    to select the Maven category, and the NetBeans Module project type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6813f74b-a46d-4b75-a214-f617bf0e6825.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on Next will get you the Name and Location step we've seen several
    times already in this book. On this pane, we'll name the module `main`, set the
    package to `com.steeplesoft.photobeans.main`, and accept the defaults for the
    other fields. On the next pane, Module Options, we will make sure that the NetBeans
    Version is the same as was selected earlier, and click on Finish.
  prefs: []
  type: TYPE_NORMAL
- en: TopComponent - the class for tabs and windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a module that is mostly empty. NetBeans created a few artifacts
    for us, but we need not concern ourselves with those, as the build will manage
    those for us. What we do need to do, though, is create our first GUI element,
    which will be something that NetBeans calls a TopComponent. From the NetBeans
    Javadoc, found at [http://bits.netbeans.org/8.2/javadoc/](http://bits.netbeans.org/8.2/javadoc/),
    we find this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Embeddable visual component to be displayed in NetBeans. This is the basic unit
    of display--windows should not be created directly, but rather use this class.
    A top component may correspond to a single window, but may also be a tab (e.g.)
    in a window. It may be docked or undocked, have selected nodes, supply actions,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see, this class is the main component of a NetBeans RCP application.
    It will hold and control various related user interface elements. It is, to put
    it another way, at the top of a component hierarchy in the user interface. To
    create TopComponent, we can use the NetBeans wizard by right-clicking on our now
    empty package in the Project Explorer tree, and selecting New | Window. If Window
    is not an option, select Other | Module Development | Window.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the following Basic Settings window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23214245-cb24-48c2-825b-887194834139.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a number of options in the preceding window. What we''re creating is
    a window that will show a list of photos, so some reasonable settings would be
    to select the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open on Application Start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximization not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These options seem pretty straightforward, but what is Window Position? Another
    of the benefits of using the NetBeans RCP as opposed to writing everything from
    scratch is that the platform provides a number of predefined concepts and facilities
    so that we don''t need to worry about them. One such concern is window positioning
    and placement. The NetBeans user interface specification (which can be found on
    the NetBeans site at [https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html](https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html))
    defines the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explorer:** This is used for all windows that provide access to user objects,
    usually in tree browsers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output:** This is used for the Output window and VCS Output window by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger:** This is used for all the debugger windows and other supporting
    windows that require a horizontal layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Palette:** This is used for the component palette window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspector:** This is used for the component inspector window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties:** This is used for the properties window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documents:** This is used for all the document windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation also provides this helpful illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0909beeb-225d-4bf0-a7c2-a9d42b9c1232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The specification page has a great deal of additional information, but this
    should be enough for now to get you going. We would like our photo list to be
    on the left side of the application window, so we select editor for the window
    position. Clicking on Next, we configure the name and icon for the component.
    Strictly speaking, we don''t need to specify an icon for TopComponent, so we can
    just enter `PhotoList` for Class Name Prefix:, and click on Finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05b3b56-34c1-447e-8e11-678bc22f827f.png)'
  prefs: []
  type: TYPE_IMG
- en: When you click on Finish here, NetBeans will create a couple of files for you,
    though only one will show up in the Project Explorer tree, that being `PhotoListTopComponent.java`.
    There is also a file called `PhotoListTopComponent.form` that you need to know
    about, though you will never edit it directly. NetBeans provides a very nice **WYSIWYG**
    (what you see is what you get) editor for building your user interface. The user
    interface definition is stored in the `.form` file, which is simply an XML file.
    As you make changes, NetBeans modifies this file for you, and generates the equivalent
    Java code in a method called `initComponents()`. You'll also notice that NetBeans
    will not allow you to modify the method. You can, of course, use another editor
    to do so, but any changes you make that way will be lost if you make changes in
    the GUI editor, so it's best just to leave the method alone. What does the rest
    of TopComponent look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of annotations, but is also a good reminder of how much the NetBeans
    platform is doing for you. During the build process, these annotations are processed
    to create the metadata that the platform will use at runtime to configure and
    wire together your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the highlights are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This registers our `TopComponent`, and reflects our choices of where to put
    it and when to open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have some internationalization and localization work being done for
    us, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Without getting too far into the details and risking confusing things, the
    first three annotations register an open Action, and expose an item in the `Window`
    menu of our application. The last annotation, `@Messages`, is used to define the
    localization keys and strings. When this class is compiled, a class called `Bundle`
    is created in the same package, which defines methods using the specified keys
    to return the localized string. For example, for `CTL_PhotoListAction`, we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code looks up the key in the standard Java `.properties` file
    for a localized message. These key/value pairs are merged with any entries found
    in the `Bundle.properties` file that the NetBeans wizard generated for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following constructor of our `TopComponent` is also of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding constructor, we can see how the component's name and tool tip
    are set, as well as where our window-related options are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our application now, we won''t see any changes. What we need to do,
    then, is add a dependency on the `main` module to the application. We do that
    by right-clicking on the Dependencies node of the app module, as shown in this
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aa28e23-b962-4fad-8f55-67e404fea645.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now see the Add Dependency window. Select the Open Projects tab,
    then select `main` as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/914375f3-13e0-441f-aa45-afb38ecada31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''ve added the dependency, we need to build both modules, first `main`
    and then `app`, and then we''ll be ready to run PhotoBeans for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22f3de03-4365-44a0-b88d-271ea1359073.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the odd date in the window title in the preceding screen? That's the
    build date of the NetBeans platform, and it's not very pretty in our app, so,
    let's fix that. We have two options. The first is to use the Branding user interface
    we looked at earlier. The other is to edit the file directly. To keep things interesting,
    and to help understand where things are on the disk, we'll use this second approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the branding module, under Other Sources | nbm-branding, you should find
    the `modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/ view/ui/Bundle.properties`
    file. In this file, you should see these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is remove the `{0}` portions, rebuild this module and the
    app, and our title bar is much prettier. While that looks better, what about our
    TopComponent? To fix that, we need to learn a few new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes, a NetBeans presentation object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've already heard the term Node. I've used it several times to describe what
    and where to click. Officially, a Node represents one element in a hierarchy of
    objects (beans). It provides all the methods that are needed for communication
    between an explorer view and the bean. In the explorer section of our application,
    we want to represent a list of photos to the user. We'll represent each photo,
    as well as the year and month in which it was taken, as a Node. To display these
    Nodes, we'll use a NetBeans class called the `BeanTreeView`, which will display
    this node hierarchy as a tree. There are a few more concepts to learn, but let's
    start with what we have first.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by defining our Nodes, which will serve as a sort of wrapper or
    bridge between our application's business domain model and the NetBeans APIs.
    We have not, of course, defined such a model, so we need to settle on that now.
    Our basic data item is a photograph, a file on disk that holds an image. In the
    application, we're going to display these photos in a nested tree structure, grouping
    the photos by year, then month. If you expand a year node, you'll see a list of
    month Nodes, and if you expand a month Node, you'll see a list of photo Nodes.
    It's a very basic, somewhat naive data model, but it's both, effective enough
    to demonstrate the concepts, and simple enough that we don't obscure the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all hierarchies, we need a root node, so we''ll start with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The base class of all nodes is, technically, Node, but extending that class
    puts much more of a burden on us, so we use the NetBeans-provided `AbstractNode`,
    which implements a fair amount of the basic behavior of the node for us with reasonable
    defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define some constructors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have two constructors, one `public` and one `protected`. The reason
    for that is that we want to create and capture an instance of `InstanceContent`,
    which can be used by us, the creators of this class' Lookup, to control what is
    actually in the lookup. Since we need to pass `Lookup` to our class' parent constructor,
    we have this two-step approach to object instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup, a NetBeans fundamental
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's a Lookup? It is a **general registry permitting clients to find instances
    of services (implementation of a given interface)**. To put it another way, it
    is a mechanism by which we can publish various artifacts, and other parts of the
    system can look up these artifacts by a key (either a `Class` or a `Lookup.Template`,
    which we'll not discuss here), with no coupling between the modules.
  prefs: []
  type: TYPE_NORMAL
- en: This is often used, as we'll see, to look up the implementations of a service
    interface. Do you recall earlier when I mentioned that often we see APIs defined
    in one module and implementations in another? This is where that comes in especially
    handy. Suppose you're developing an API to retrieve photos from an online service
    (which would be a great feature for this application!). You plan to deliver an
    implementation for one service, say Google Photos, but want to enable a third-party
    developer to provide an implementation for, say, Flickr. If you put the required
    API interfaces, classes, and so on in one module, and your Google Photos implementation
    in another, the third-party developer can depend on your API module alone, and
    avoid the weight of your implementation module. The Flickr module would declare
    an implementation of the photo service API, and we could load both that and our
    own Google Photos implementation via a request to the Lookup. In a nutshell, the
    system allows for decoupling the API definition, implementation, and instance
    acquisition in a very clean, simple API.
  prefs: []
  type: TYPE_NORMAL
- en: That's Lookup, but what is `InstanceContent`? The Lookup API only exposes methods
    for getting items. There is no mechanism for adding items to the Lookup, which
    makes sense as the Lookup instance is used by unknown third parties, and we don't
    want them changing the contents of our Lookup randomly. We, however, may actually
    want to change those contents, and we do that via `InstanceContent`, which exposes
    the methods we need to add or remove items. We'll see a demonstration of this
    concept later in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding section covered those two classes, but what is `YearChildFactory`?
    The class `RootNode` defines for the system the root node of what will become
    our tree. Each node, though, if it has children, is responsible for loading and
    building those child Nodes, which is done through this `ChildFactory` class. Our
    instance looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a `ChildFactory` interface that will return nodes that operate
    on Strings. If you have a more complex data model, one that uses, for example,
    POJOs, you would specify that class as the parameterized type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our constructor, we see an example of finding a service implementation via
    the Lookup, which is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at defining services later, but, for now, all you need to understand
    is that we're asking the global Lookup (which is, unlike the Lookup we created
    previously, not tied to a particular class) for an instance of the `PhotoManager`
    interface. Perhaps naively, we assume there is only one instance of this interface,
    but since we're not exporting the interface, we are safe in our assumption. We
    do, though, check to make sure there is at least one, exiting the application
    if there is not.
  prefs: []
  type: TYPE_NORMAL
- en: The next two methods are how the factory is used to create the child Nodes.
    The first method, `createKeys(List<String> list)`, is called by the system to
    generate a list of keys for the child nodes. In our implementation, we ask the
    `PhotoManager` interface for a list of years (which, as we'll see, is a simple
    query of the database to get a list of the years for which we have photos in the
    system). The platform then takes these keys, and passes them, one at a time, to
    `createNodeForKey(String key)` to create the actual node. Here, we create an instance
    of `YearNode` to represent the year.
  prefs: []
  type: TYPE_NORMAL
- en: '`YearNode`, like `RootNode`, extends `AbstractNode`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is clearly a simpler node, but the basics are the same--we create
    `ChildFactory` to create our children, and we create a Lookup, which, in this
    case, holds a single value, the year that the Node represents.
  prefs: []
  type: TYPE_NORMAL
- en: '`MonthNodeFactory` looks almost exactly like `YearNodeFactory` with the exception
    that it loads months for the given year, so we''ll not show the source here. It
    also creates `MonthNode` instances for each month in the list. Like `YearNode`,
    `MonthNode` is pretty simple, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We do a bit more work to give the Node a meaningful name and display name,
    but it''s pretty much the same. Note also that we have yet another `ChildFactory`
    that will generate, as the name implies, the PhotoNodes we''ll need as children.
    The factory itself has nothing new of interest, but `PhotoNode` does, so let''s
    take a look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we again see the dual constructor approach, though, in this case, we do
    make use of `InstanceContent`. Note that the first parameter to `super()` is `Children.LEAF`,
    indicating that this Node does not have any children. We also pass the now familiar
    `new AbstractLookup(ic)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the name and display name, we add a lambda to our `InstanceContent`
    object. The non-lambda version of this would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What is `OpenCookie`? It's a child of the marker interface `Node.Cookie`, and
    a cookie is **a design pattern used to add behaviors to existing data objects
    and nodes, or to separate implementation from the main object**. Using this cookie,
    we can neatly abstract away the signaling that something can be opened as well
    as how to open it.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, when the system tries to open the photo represented by the node,
    it will call our definition of `OpenCookie.open()`, which will attempt to find
    an open instance of the photo. Whether it finds an existing one or needs to create
    a new one, it instructs the system to make it active (or give it focus).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the open photo is represented by another TopComponent. To find it,
    we have this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We ask the Lookup of `WindowManager` for all the opened TopComponents, then
    iterate through each, comparing `String photo`, which is the full path of the
    image, with any `String` stored in the Lookup of TopComponent. If there's a match,
    we return that TopComponent. This lookup by `String` is somewhat naive though,
    and could, in more complex applications, result in unexpected matches. We're likely
    safe enough in this application, but you'll need to make sure in your own application
    that the matching criteria are strict and unique enough to avoid false hits.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll look at `PhotoViewerTopComponent` in a moment, but there are a few more
    items we need to look at before moving on to that.
  prefs: []
  type: TYPE_NORMAL
- en: '`PhotoNode` overrides two additional methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, the `getActions()` method returns an array of Actions for this
    Node. Actions are an abstraction (from Swing, not NetBeans) that allow us to add
    items to menus, and provide a means for a user to interact with the system. Each
    entry you see in the main menu or a context menu is backed by an Action. In our
    case, we're associating the NetBeans-defined `OpenAction` with our node, which
    will, when clicked, look for an `OpenCookie` instance in the Node's lookup and
    call `OpenCookie.open()`, which we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: We also override `getPreferredAction()`, which lets us define the behavior for
    when a Node is double-clicked. The combination of these two methods makes it possible
    for the user to right-click a Node and select `Open`, or double-click a Node,
    with the end result being that the TopComponent for that Node is opened.
  prefs: []
  type: TYPE_NORMAL
- en: Services - exposing decoupled functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before looking at the definition of our `TopComponent`, let''s look at `PhotoManager`,
    and learn a bit about its services. The `PhotoManager` interface itself is pretty
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is little of interest in the preceding code beyond the `extends Lookup.Provider`
    portion. Adding this here, we can force implementations to implement the lone
    method on that interface, as we''ll need that later. The interesting part comes
    from the implementation, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all it takes to register a service with the platform. The annotation
    specifies the metadata needed, and the build takes care of the rest. Let''s take
    a look at the rest of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding, very simple, implementation, we're going to use SQLite to
    store information about the photos we find. The service will provide the code
    to scan the configured source directories, store information about the photos
    found, and expose methods for retrieving those pieces of that information that
    vary in specificity.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we need to make sure that the database is properly set up if
    this is the first time the application is run. We could include a prebuilt database,
    but creating it on the user's machine adds a bit of resilience for those situations
    where the database is accidentally deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we ask for a reference to the NetBeans preferences for the module `PhotoManager`.
    We'll look at managing preferences later in the chapter where we'll delve into
    this API in more detail, but, for now, we'll say only that we are going to ask
    the system for the `sourceDirs` preference, which we'll then use to configure
    our scanning code.
  prefs: []
  type: TYPE_NORMAL
- en: We also create `PreferenceChangeListener` to capture when the user changes the
    preferences. In this listener, we verify that the preference we care about, `sourceDirs`,
    was changed, and, if it was, we store the new value in our `PhotoManager` instance,
    and initiate a directory scan.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create `InstanceContent`, create and store a Lookup, and start a
    directory scan to make sure the application is up-to-date with the state of the
    photos on disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getYears()`, `getMonths()`, and `getPhotos()` methods are largely the
    same, differing only, of course, in the type of data they''re working with, so
    we''ll let `getYears()` serve as an explanation of all three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with JDBC, this should not be surprising. We use Java 7's
    `try-with-resources` syntax to declare and instantiate both our `Statement` and
    our `ResultSet` objects. For those not familiar with this construct, it allows
    us to declare certain types of resource, and not have to worry about closing them
    as the system automatically closes them for us once the scope of the `try` terminates.
    The major restriction to be aware of with this, however, is that the class must
    implement `AutoCloseable`; a `Closeable` will not work. The other two `get*` methods
    are logically similar, so they are not shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last major piece of functionality here is the scanning of source directories,
    which is coordinated by the `scanSourceDirs()` method, given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To speed the process up a bit, we create Future for each configured source directory,
    which we pass to our `ExecutorService`. We have it configured at a maximum of
    five threads in the pool, which is largely arbitrary. A more sophisticated approach
    might make this configurable, or perhaps, auto-tuned, but this should be sufficient
    for our purposes here.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Futures are created, we iterate over the list, requesting each result.
    If the number of source directories exceeds the size of our thread pool, the excess
    Futures will wait until a Thread becomes available, at which point the `ExecutorService`
    will pick one to run. Once they're all done, the calls to `.get()` will no longer
    block, and the application can continue. Note that we're not blocking the user
    interface to allow this to work, as we pass the bulk of this method as a lambda
    to `RequestProcessor.getDefault().execute()` to request that this run off the
    user interface thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the list of photos has been built and returned, we process those photos
    with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isImageRecorded()` method checks to see if the image path is already in
    the database, returning true if it is. We `filter()` the stream based on the result
    of this test, so `forEach()` only operates on previously unknown images, which
    are then inserted into the database via `insertImage()`. Those two methods look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are using `PreparedStatement`, as it is, generally, unwise to create SQL
    statements via concatenation, which can, and often does, lead to SQL injection
    attacks, so we can't use `try-with-resources` fully in the first method, requiring
    us to close the `ResultSet` manually.
  prefs: []
  type: TYPE_NORMAL
- en: PhotoViewerTopComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now find images, but we still can't tell the system where to look. Before
    turning our attention to handling preferences with the NetBeans platform, though,
    we have one more TopComponent to look at--`PhotoViewerTopComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think back to our discussion of the areas provided by the NetBeans window
    system, when we view an image, we want the image to be loaded in the `Editor`
    area. To create a TopComponent for that, we instruct NetBeans to create a new
    `Window` by right-clicking on the desired package, and selecting New | Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae06490b-677c-4e4c-957f-8f075658b0b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next pane, we specify a class name prefix for our new TopComponent--`PhotoViewer`
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e21806-8be6-417b-b315-27f30b73c35a.png)'
  prefs: []
  type: TYPE_IMG
- en: NetBeans will now create the files `PhotoViewerTopComponent.java` and `PhotoViewerTopComponent.form`
    just as was discussed earlier. For this TopComponent, though, we need to make
    a couple of changes. When we open the `Window`, we need to specify an image for
    it to load, so we need to provide a constructor that takes the path to the image.
    However, TopComponents must have a no-argument constructor, so we leave it but
    have it call our new constructor with an empty image path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While it may seem like a lot, the steps here are simple: we save the photo
    path in an instance variable, we create a `File` instance from it to get the file
    name more easily, add the photo path to TopComponent''s Lookup (which is how we
    find the TopComponent for a given photo), change the layout, and then initialize
    the window.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JavaFX with the NetBeans RCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `init()` method is interesting, though, in that we're going to do something
    slightly different; we're going to use JavaFX to view the image. There's no reason
    we couldn't use Swing like we are in our other TopComponent, but this gives us
    a good opportunity to demonstrate both how to integrate JavaFX and Swing, as well
    as JavaFX and the NetBeans platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`JFXPanel` is a Swing component that is used to embed JavaFX into Swing. Our
    Window''s layout is `BorderLayout`, so we add our `JFXPanel` to it in the `CENTER`
    area, and let it expand to fill the `Window`. Any complex layout of the JavaFX
    components will be handled by yet another container inside our `JFXPanel`. Our
    user interface, though, is fairly simple. As with our earlier JavaFX systems,
    we define our user interface via FXML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since FXML needs a root element, we specify a `BorderLayout`, which, as discussed,
    gives us a `BorderLayout` in a `JFXPanel` in a `BorderLayout`. That may sound
    really odd, but that''s how embedding JavaFX works. Note also that we still specify
    a controller. In that controller, our `initialize()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this last method, all we're doing is binding the width and height properties
    to those of the border pane. We've also set `preserveRatio` to `True` in the FXML,
    so the image won't be distorted. This will be important as we rotate the image
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t seen the code for rotation, so let''s look at that now. We''ll
    start by adding a button as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To the `top` section of `BorderPane`, we add `ButtonBar`, to which we add a
    single `SplitMenuButton`. That gives us a button like the one to the right. In
    its non-focused state, it looks like a normal button. When the user clicks on
    the arrow, the menu, as seen here, is presented to the user, offering the ability
    to rotate the image in the directions listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50c9cc1-2b53-4144-b3dd-e2065ed1c24f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve tied those MenuItems to the appropriate methods in the controller in
    our FXML definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using the APIs provided by the JavaFX `ImageView`, we set the image rotation.
  prefs: []
  type: TYPE_NORMAL
- en: We can find images, view them, and rotate them, but we still can't tell the
    system where to look for those images. It's time to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans preferences and the Options panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key to managing preferences is two-fold: `NbPreferences` and the Options
    panel. `NbPreferences` is the means by which preferences are stored and loaded,
    and the options panel is the means by which the user is presented with a user
    interface for editing those preferences. We''ll start by looking at how to add
    an Options panel, which will lead naturally to the `NbPreferences` discussion.
    Next is the NetBeans Options window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/303583cd-79b6-4894-b79b-82822cd57d77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding window, we can see the two types of Options panel--primary
    and secondary. A primary Options panel is represented by icons across the top:
    General, Editor, Fonts & Colors, and so on. A secondary Options panel is a tab
    like we see in the middle section: Diff, Files, Output, and Terminal. When adding
    an Options panel, you must choose either primary or secondary. We''d like to add
    a new primary panel, as it will separate our preferences from the rest of the
    panels visually as well as giving us an opportunity to create both types of panel.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a primary panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a primary Options panel, right-click on the desired package or the
    project node, and click on New | Options Panel. If Options Panel is not visible,
    select New | Other | Module Development | Options Panel. Next, select Create Primary
    Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd62cb4c-24c6-4353-b665-7c86e6bd862f.png)'
  prefs: []
  type: TYPE_IMG
- en: We must specify a label, which is the text we'll see under the icon. We must
    also select an icon. The system will let you select something other than a 32x32
    image, but if it's not the right size, it will look strange in the user interface;
    so, choose carefully. The system will also require you to enter keywords, which
    will be used if the user applies a filter to the Options window. Finally, select
    Allow Secondary Panels. The primary panel doesn't have any real content and serves
    only to display secondary panels, which we'll create shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on Next, you will be asked for the class prefix and package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58423d52-bfb4-46b1-a482-499a076a6a7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on Finish, NetBeans will create this single file, `package-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Adding a secondary panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the primary panel defined, we''re ready to create the secondary panel,
    which will do our work. We right-click on the package again, and select New |
    Options Panel, this time selecting Create Secondary Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/497a878f-fe1c-4d38-9094-71b6db76400f.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we've defined our own primary panel, we can select that as our parent,
    and we set the title and keywords as we did before. Click on Next, select and/or
    verify the class prefix and package, then click on Finish. This will create three
    artifacts--`SourceDirectoriesOptionPanelController.java`, `SourceDirectoriesPanel.java`,
    and `SourceDirectoriesPanel.form`, and NetBeans will present you with the GUI
    editor for your panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add four elements to our panel--a label, a list view, and two buttons.
    We add those by dragging them from the palette on the right, and arranging them
    in the form as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14b4277f-1eec-44c7-99a2-9873ee3f58aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make working with these user interface elements more meaningful, we need
    to set the variable names. We also need to set the text of the user interface
    so that each element is meaningful for the user. We can do both by right-clicking
    on each element, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7a16fc5-c806-43c4-956e-c0101b9a51f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screen, we can see the three items of interest--Edit Text,
    Change Variable Name..., and Events | Action | actionPeformed [buttonAddActionPerformed].
    For our buttons, we need to use all three, so we set the text to `Add` (or `Remove`),
    change the variable name to `buttonAdd`/`buttonRemove`, and select `actionPerformed`.
    Back in our Java source, we see a method created for us, which we need to fill
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have quite a bit going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by retrieving the `lastDir` preference value. If set, we'll use this
    as the starting point for selecting the directories to add. Typically, at least
    in my experience, the directories of interest are, usually, pretty close to one
    another in the filesystem, so we use this preference to save the user some clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we create `JFileChooser`, which is the Swing class that will allow us to
    choose the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `lastDir` is not null, we pass it to `setCurrentDirectory()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the title of the dialog to something meaningful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We specify that the dialog should only let us choose directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we disable the Select All file filter option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call `chooser.showOpenDialog()` to present the dialog to the user, and wait
    for it close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the return code from the dialog is `APPROVE_OPTION`, we need to add the chosen
    directory to our model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the canonical path for the selected file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call `ensureModel()`, which we'll look at in a moment, to get the model for
    our `ListView`, then add this new path to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we store the chosen path as `lastDir` in our preferences to set the
    starting directory as discussed earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The action for the Remove button is much simpler, and is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we are removing items from the model, we remove them by the item index.
    However, when we remove an item, the index numbers for anything after that change.
    What we do here, then, is create a List of the selected indices, sort it to make
    sure it's in the right order (which is possibly excessive here, but it's a relatively
    inexpensive operation, and makes the next operation safer), then we reverse the
    order of the List. With our indices now in descending order, we can iterate over
    the List, removing each index from our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used `ensureModel()` a couple of times now, so let''s see what that
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It's important that we treat the model as `DefaultListModel` rather than the
    `ListModel` type that `ListView` expects, as the latter does not expose any methods
    for mutating the contents of the model, whereas the former does. By dealing with
    `DefaultListModel`, we can add and remove items as needed, as we've done here.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and saving preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two more methods we need to look at in this class, the ones that
    load and store the options represented in the panel. We''ll start with `load()`,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`NbPreferences` does not support storing a list of strings, so, as we''ll see
    below, we store the list of source directories as a semicolon-delimited list of
    strings. Here, we load the value of `sourceDirs`, and, if not null, we split on
    the semicolon, and add each entry to our `DefaultListModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the source directories is also fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We iterate over `ListModel`, adding each directory to a local `HashSet` instance,
    which helps us remove any duplicate directories. If `Set` is not empty, we use
    `String.join()` to create our delimited list, and `put()` it into our preferences
    store. If it is empty, we remove the preference entry from the store to clear
    out any old data that may have been persisted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to changes in preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can persist changes, we need to make the application react to the
    changes. Fortunately, the NetBeans RCP provides a neat, decoupled way to handle
    that. We need not explicitly call a method from our code here. We can attach a
    listener at the point in the system where we''re interested in the change. We''ve
    already seen this code back in `PhotoManagerImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we save any preference for the `PhotoManager` module, this listener is
    called. We simply check to make sure it's for a key that we're interested in,
    and act accordingly, which, as we've seen, involves restarting the source directory
    scanning process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once new data has been loaded, how do we make the user interface reflect that
    change? Do we have to update the user interface manually? Again, thanks to the
    RCP, the answer is no. We''ve seen the first half at the end of `scanSourceDirs()`,
    which is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'NetBeans has a number of cookie classes for indicating that certain actions
    should take place. While we don''t share the class hierarchy (due to the unfortunate
    dependency on the Nodes API), we do share the same nomenclature with the hope
    of stealing, so to speak, a bit of the familiarity. So what does `ReloadCookie`
    look like? There''s not much to it; it is given like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we just have an empty class. We don''t intend for this to be used
    elsewhere, so we don''t need to encode any functionality in the class. We will
    just be using this as an indicator, as we see in the constructor of `RootNode`,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Lookup.Template` is used to define the pattern by which the system can filter
    our `Lookup` requests. Using our template, we create a `Lookup.Result` object,
    `reloadResult`, and add a listener to it via a lambda. The lambda creates a new
    set of children using `Children.create()` and the `YearChildFactory` we looked
    at earlier, and passes those to `setChildren()` to update the user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: That may seem like a fair bit of code just to update the user interface when
    a preference is changed, but the decoupling is certainly worth it. Imagine a more
    complicated application or a dependent module tree. Using this listener approach,
    we need not expose methods, or even classes, to the outside world, allowing our
    internal code to be modified without breaking client code. That is, in short,
    one of the primary reasons for decoupled code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we've come to the end of another application. You learned how to
    bootstrap a Maven-based NetBeans Rich Client Platform application. You learned
    about RCP modules, and how to include those modules in our application build.
    You also learned the basics of the NetBeans RCP Node API, how to create our own
    nodes, and how to nest child nodes. We explained how to use the NetBeans Preferences
    API, including creating new Options panels for editing preferences, how to load
    and store them, and how to react to changes in preferences.
  prefs: []
  type: TYPE_NORMAL
- en: One final word on the NetBeans RCP--While we have built a respectable application
    here, we have in no way pushed the limits of the RCP. I have attempted to cover
    just enough of the platform to get you going, but you will almost certainly need
    to learn more if you are to continue using the platform. While the official documentation
    is helpful, the go-to source for comprehensive coverage is *NetBeans Platform
    for Beginners* by Jason Wexbridge and Walter Nyland ([https://leanpub.com/nbp4beginners](https://leanpub.com/nbp4beginners)).
    It's a great book, and I highly recommend it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to dip our toes into the waters of client/server
    programming, and implement our own note-taking application. It won't be as robust
    and full-featured as the competitors already in the market, but we'll make good
    headway in that direction and, hopefully, learn a lot along the way.
  prefs: []
  type: TYPE_NORMAL

- en: Serverless Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the concept of microservices, which we've already looked at,
    has swept across the industry, quickly displacing the battle-tested application
    server with something smaller and leaner. Right on the heels of microservices
    comes a new concept--Functions as a Service, more commonly called **serverless**.
    In this chapter, you'll learn more about this new deployment model and build an
    application to demonstrate how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will be a simple notification system using the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Identity and Access Management** (**IAM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Notification System** (**SNS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Email System** (**SES**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options offered by cloud providers can be quite vast, and Amazon Web Services
    is no exception. In this chapter, we will attempt to use just enough of what AWS
    has to offer to help us build a compelling application as we wade into cloud-native
    application development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get to our application, we should spend some time getting a better
    understanding of the term **Function as a Service** (**FaaS**). The term itself
    is a continuation of the **blank** as a service trend we''ve seen for a few years
    now. There is a host of such terms and offerings, but the big three are **Infrastructure
    as a Service** (**IaaS**), **Platform as a Service** (**PaaS**), and **Software
    as a Service** (**SaaS**). Oftentimes, these three build on each other as seen
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d275ceea-af69-4cb5-92c3-ec49407acaca.png)'
  prefs: []
  type: TYPE_IMG
- en: The lowest level of the cloud computing offerings, Infrastructure as a Service
    providers, offers infrastructure-related assets **in the cloud**. Typically, this
    can be as simple as file storage, but usually means virtual machines. By using
    an Infrastructure as a Service provider, clients need not worry about buying,
    maintaining, or replacing hardware, as that is handled by the provider. Clients
    are billed, instead, only on resources used.
  prefs: []
  type: TYPE_NORMAL
- en: Moving up the stack, Platform as a Service providers offer cloud-hosted application
    execution environments. This may include things such as an application server,
    a database server, a web server, and so on. The details of the physical environment
    are abstracted away, with customers specifying storage and RAM requirements. Some
    providers also allow the customer to choose the operating system, as this can
    have implications on the application stack, support tools, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Software as a Service is a higher-level abstraction that doesn't focus on the
    hardware at all but, instead, offers hosted software that customers subscribe
    to, typically per user, and typically on a monthly or yearly basis. This is often
    seen in complicated business software, such as financial systems or human resource
    applications, but it is also seen with simpler systems, such as blogging software.
    The user simply subscribes and uses the software, leaving the installation and
    maintenance, including upgrades, to the provider. While this can reduce flexibility
    for the user (for example, it is often not possible to customize the software),
    it also reduces operational costs by pushing maintenance costs to the provider
    as well as guaranteeing, in most cases, access to the latest version of the software.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other variations on this type of service, such as **Mobile
    Backend as a Service** (**MBaas**) and **Database as a Service** (**DBaaS**).
    As the market continues to gain confidence in cloud computing, and as the internet
    speeds up while the prices go down, we are likely to see more and more of these
    types of systems developed, which brings us to our topic in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function as a Service, or **serverless** computing, is the deployment of a small
    piece of code, very literally a function, that can be called from other applications,
    usually via some sort of trigger. Use cases include things such as image conversion,
    log analysis, and, as we will build in this chapter, notification systems.
  prefs: []
  type: TYPE_NORMAL
- en: Despite what the name **serverless** implies, there is actually a server involved,
    which only stands to reason; however, you, as an application developer, need not
    think about the server too deeply. In fact, as we'll see in this chapter, the
    only thing we need to worry about is how much memory our function will need. Everything
    else about the server is completely handled by the Function as a Service provider--the
    operating system, storage, networking, even starting and stopping the virtual
    machine are all handled for us by the provider.
  prefs: []
  type: TYPE_NORMAL
- en: With that basic understanding of serverless, we need to pick a provider. As
    can be expected, there are a number of options--Amazon, Oracle, IBM, Red Hat,
    and more. Unfortunately, currently, there is no standardized means by which we
    can write a serverless system and deploy it to an arbitrary provider, so that
    means our solution will be necessarily tied to a specific provider, which will
    be **Amazon Web Services** (**AWS**), the dominant provider of cloud computing
    services. As mentioned in the introduction to this chapter, we use a number of
    AWS offerings, but the centerpiece will be AWS Lambda, Amazon's serverless computing
    offering.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump in.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application we will build is a very simple **cloud notification** service.
    In a nutshell, our function will **listen** for messages, then forward those messages
    to email addresses and phone numbers registered in the system. While our system
    will be somewhat contrived and certainly very simple, hopefully the more practical
    use cases are clear:'
  prefs: []
  type: TYPE_NORMAL
- en: Our system reminds students and/or parents about upcoming events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parents are notified when children enter or leave certain geographic boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems administrators are notified of certain events as they occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possibilities are quite vast. For our purposes here, we''ll develop not
    only the cloud-based system, but also a simple desktop application to simulate
    these types of scenarios. We''ll start where the fun is: in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Building your first function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of Functions as a Service is, of course, the function. In Amazon Web
    Services, these are deployed using the service AWS Lambda. That's not the only
    AWS feature we'll use, as we've already mentioned. Once we have a function, we
    need a way to execute it. This is done via one or more triggers, and the function
    itself has tasks it needs to perform, so we'll demonstrate more service usage
    via API calls when we finally write the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be helpful at this point, given that our application is structured
    significantly differently than anything else we''ve looked at, to look at a system
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef4a0f18-7a3b-4f35-9524-5b140ff96666.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the rough flow:'
  prefs: []
  type: TYPE_NORMAL
- en: A message is published to a topic in the Simple Notification System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the permissions of the caller have been verified, the message is delivered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon message delivery, a trigger is fired, delivering the message from the topic
    to our function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, we'll query Amazon's **DynamoDB** to get the list of recipients
    that have signed up, providing either an email address, cell phone number, or
    both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the cell phone numbers will be sent a text message via **Simple Notification
    System**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the email addresses will be sent an email via **Simple Email Service**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start building the function, we need to create a Java project. Like many
    of our other projects, this will be a multi-module Maven project. In NetBeans,
    click on File | New Project | Maven | POM Project. We'll call the `CloudNotice`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The project will have three modules--one for the function, one for a test/demo
    client, and one for a shared API. To create the function module, right-click on
    the `Modules` node in the project explorer and select Create new module. In the
    window, select Maven | Java Application, click on Next, and set the project name
    to `function`. Repeat those steps and create a module called `api`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further, we have to address the fact that, at the time of
    writing, AWS does not support Java 9\. We must, therefore, target Java 8 (or earlier)
    for anything we will ship to Lambda. To do that, we need to modify our `pom.xml`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Modify the POM for both `api` and `function`. Hopefully, AWS will support Java
    9 as quickly as possible after its release. Until then, we'll just have to target
    JDK 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our project configured, we''re ready to write our function. AWS Lambdas
    are implemented as `RequestHandler` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ultimately, we want our function to be triggered when a message is delivered
    to an SNS topic, so we specify `SNSEvent` as the input type. We also specify `Context`.
    There are several things we can get from the `Context`, such as the request ID,
    memory limit, and others, but all we're interested in is getting a `LambdaLogger`
    instance. We could just write to standard out and standard error, and those messages
    would be saved in Amazon CloudWatch, but `LambdaLogger` allows us to respect system
    permissions and the container configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this compile, we need to add some dependencies to our application,
    so we add the following lines to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start implementing the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have a couple of new classes to look at, but to recap this code first, we
    will get a list of `Recipient` instances, which represents the numbers and email
    addresses that have been subscribed to our service. We then create a stream from
    the list, filtering for each recipient type, `SMS` or `Email`, extracting the
    value via `map()`, then collecting them in a `List`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get to `CloudNoticeDAO` and `Recipient` in a moment, but let''s finish
    up with our function first. Once we have our lists, we can then send the messages
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have encapsulated two more AWS APIs behind our own client classes, `SesClient`
    and `SnsClient`. This may seem a bit excessive, but these types of things tend
    to grow, and this approach puts us in a good position to manage that.
  prefs: []
  type: TYPE_NORMAL
- en: 'That leaves us with three APIs to look at: DynamoDB, Simple Email Service,
    and Simple Notification Service. We''ll take them in order.'
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon DynamoDB is a NoSQL database, very much like MongoDB, which we looked
    at in [Chapter 9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml), *Taking
    Notes with Monumentum*, though DynamDB supports both document and key-value store
    models. A thorough comparison of the two, as well as a recommendation as to which
    to choose, is well outside the scope of our work here. We chose DynamoDB here,
    since it is already provisioned in the Amazon Web Service, and, thus, easily configured
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the DynamoDB API, we need to add some dependencies to our
    application. In the `api` module, add this to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start writing our DAO class, let''s define our simple model. The
    DynamoDB API provides an object-relational mapping facility, much like the Java
    Persistence API or Hibernate, which will require a POJO and just a few annotations
    as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our POJO, we declared three properties, `id`, `type`, and `address`, then
    annotated the getters with `@DyanoDBAttribute` to help the library understand
    how to map the object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, while most of the property names match the field names in the table,
    you can override the property-to-field name mapping as we did with `id`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do anything with our data, we need to declare our table. Remember
    that DynamoDB is a NoSQL database, and we will use it as a document store just
    as we did with MongoDB. However, before we can store any data, we have to define
    **where** to put it. In MongoDB, we would create a collection. DynamoDB, though,
    still refers to this as a table, and, while it is technically schemaless, we do
    need to define a primary key, which is made up of a partition key and an optional
    sort key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the table through the console. Once you''ve logged on to the AWS
    DynamoDB console, you will click on the Create Table button, which will bring
    you to a screen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7632622-3d2a-490d-b1e1-bfba3ee7c75b.png)'
  prefs: []
  type: TYPE_IMG
- en: We will name our table `recipients`, and specify `_id` as the partition key.
    Click on the Create Table button and give AWS time to create the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to start writing our DAO. In the API module, create a class
    called `CloudNoticeDAO`, to which we''ll add this constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The local property is used to determine whether or not to use a local DynamoDB
    instance. This is here to support testing (as is the call to `verifyTables`),
    which we will explore in a moment. In production, our code will call `AmazonDynamoDBClientBuilder.defaultClient()`
    to acquire an instance of `AmazonDynamoDB`, which talks to the Amazon-hosted instance.
    Finally, we create an instance of `DynamoDBMapper`, which we'll use for our object
    mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate creating a new `Recipient`, we will add this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method will either create a new entry in the database, or update an existing
    one if the primary key already exists. In some scenarios, it might make sense
    to have separate save and update methods, but our use case is so simple that we
    don't need to worry about that. All we need to do is create the key value if it's
    missing. We do so by creating a random UUID, which helps us avoid key collisions
    should there be more than one process or application writing to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting a `Recipient` instance or getting a list of all of the `Recipient`
    instances in the database is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before we leave our DAO, let's take a quick look at how we can test it. Earlier,
    we noted the `local` parameter and the `verifyTables()` method, which exist for
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, most people will frown, and rightfully so, on adding methods
    to production classes just for testing. There's a difference between writing a
    class that is testable, and adding test methods to a class. I would agree that
    adding methods to a class just for testing is something that should be avoided,
    but I am violating that principle a little here for the sake of simplicity and
    brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `verifyTables()` method checks to see if the table exists; if the table
    doesn''t, we call another method that will create it for us. While we manually
    created the production table using the preceding console, we could also let this
    method create that table for us. What approach you use is completely up to you.
    Be aware that there will be performance and permissions issues that will need
    to be addressed. That said, that method looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the call to the `describeTable()` method, we can check to see if the table
    exists. In our test, this will fail every time, which will cause the table to
    be created. In production, should you use this method to create the table, this
    call will fail only on the first invocation. In `createRecipientTable()`, we can
    see how a table is created programmatically. We also wait until the table is active
    to make sure our reads and writes won't fail while the table is being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tests, then, are very simple. For example, consider the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This test helps us verify that our model mapping is correct, and that our DAO
    methods function as expected. You can see additional testing in the `CloudNoticeDaoTest`
    class, in the source bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Email Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send emails, we will use the Amazon Simple Email Service, or SES, which we
    will wrap in the `SesClient` class in the `api` module.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT**: Before you can send an email, you have to verify either your
    sending/from address or domain. The verification process is fairly simple, but
    how to do that is probably best left to Amazon''s documentation, which you can
    read here: [http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html](http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Simple Email Service API is quite simple. We need to create a `Destination`,
    which tells the system to whom to send the emails; a `Message` that describes
    the message itself, including subject, body, and recipients; and a `SendEmailRequest`
    that ties everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an important caveat though, which is in the preceding bolded code.
    SES limits the number of recipients per message to 50, so we need to take our
    list of email addresses and process them 50 at a time. We will do that using the
    `getChunkedEmailList()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To find the number of groups, we divide the number of addresses by 50 and round
    up (for example, 254 addresses would get us 6 groups--5 of 50 and 1 of 4). Then,
    using an `IntStream` to count from 0 to the number of groups (exclusive), we extract
    sublists from the original list. Each of these lists is then collected into yet
    another `List`, giving us the nested `Collection` instances we see in the method
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design note**: Many developers will avoid using nested `Collection` instances
    like this, as it can quickly become difficult to understand what exactly the variable
    represents. It is considered by many to be a best practice in situations like
    this to create a new type to hold the nested data. For example, if we were to
    follow that advice here, we could create, perhaps, a new `Group` class that had
    a `List<String>` property to hold the group''s email addresses. We have not done
    so for the sake of brevity, but that would definitely be a good enhancement to
    this code.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we've **chunked** our list, we can send the same `Message` to each group,
    and thus fulfill the API contract.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Notification Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen the Simple Notification System at work, at least in theory,
    as that is what delivers the outbound message to our function: a client of some
    sort publishes a message in a specific SNS topic. We have a subscription to that
    topic (I''ll show you how to create that later) that calls our method with the
    message for us to deliver. We will use the SNS API now to send text (or SMS) messages
    to the users who have subscribed a phone number to the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With SNS, to send a message to more than one phone number you must do so through
    a topic to which each number is subscribed. What we''ll do then is follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe all of the phone numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the message to the topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we use a persistent topic, we will likely get unpredictable results if we
    have more than one instance of the function running simultaneously. The method
    that orchestrates all of this work looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a topic, we have the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To subscribe the numbers to the topic, we have this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Publishing a message is equally simple, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, you can delete the topic with this simple method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All of these methods are clearly very simple, so the calls to the SNS API could
    be made directly inline in the calling code, but this wrapper does provide us
    with a way to hide the details of the API from our business code. This is more
    important, for example, in `createTopic()`, where extra classes are needed, but,
    to be consistent, we'll encapsulate everything behind our own facade.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now completed our function and we''re almost ready to deploy it. To
    do that, we need to package it. AWS allows us to upload either a ZIP or a JAR
    file. We''ll use the latter. However, we have some external dependencies, so we''ll
    use the **Maven Shade** plugin to build a fat jar with our function and all of
    its dependencies. In the `function` module, add the following piece of code to
    the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we build the project, we'll get a large file (about 9MB) in the target
    directory. It is this file that we will upload.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can upload the function, we need to prepare our AWS environment by
    creating the appropriate role. Log on to AWS and navigate to the Identity and
    Access Management Console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
    In the navigation pane on the left, click on Roles, then click on Create new role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/902f3791-0390-4254-9898-b8c656dde857.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When prompted to select a role, we want to select AWS Lambda. On the next page,
    we will attach the policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22029503-fc48-4f3a-878c-1f7ecb97284b.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Next, set the name to `j9bp`, and click on Create role.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make creating the function and the associated trigger simpler, we will create
    our topic first. Navigate to the SNS console. Given that not all AWS functionality
    is always available in every region, we need to choose a specific region. We can
    do that in the upper-left corner of the web page. If the region does not say N.
    Virginia, select it--US East (N. Virginia)--from the drop-down menu before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the region is set correctly, click on Topics in the left navigation bar,
    then click on Create new topic and specify the name as `cloud-notice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5ad91e2-4387-498f-b031-94b3d2f67433.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now navigate to the Lambda console and deploy our function. We will
    start by clicking on the Create a lambda function button. We''ll be asked to select
    a blueprint. The only option suitable for a Java-based function is Blank Function.
    Once we click on that option, we are presented with the Configure Triggers screen.
    When you click on the empty square, you will be presented with a drop-down menu,
    as seen in this screenshot from the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1d99251-e9a1-4944-bed6-a1a6ae1b4d7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can either scroll down to find SNS, or enter `SNS` in the filter box as
    in the preceding screenshot. Either way, when you click on SNS in the list, you
    will be asked to select the topic to which you want to subscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac237c0d-a24c-431e-95c6-787008c68f90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next. We now need to specify the details of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90f63289-4ee5-4ba1-995b-2aa8bbc775c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scrolling down the page, we also need to specify the Lambda function handler
    and role. The Handler is the fully-qualified class name, followed by two colons,
    and the method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b62cb07-215c-485f-8750-b8a0ac9a5240.png)'
  prefs: []
  type: TYPE_IMG
- en: We now need to select the function archive by clicking on the upload button
    and selecting the jar file created by our Maven build. Click on Next, verify the
    details of the function, and then click on Create function.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a usable AWS Lambda function. We can test it using the Lambda Console,
    but instead we'll build a small JavaFX application to do that, which will simultaneously
    test all of the service integrations, as well as demonstrate how a production
    application would interact with the function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help test and demonstrate the system, we'll create a new module, called `manager`,
    in the `CloudNotice` project. To do that, click on the modules node in the NetBeans
    project explorer, then click on Create New Module... | Maven | JavaFX Application.
    Call the project `Manager` and click on Finish.
  prefs: []
  type: TYPE_NORMAL
- en: I have renamed `MainApp` to `CloudNoticeManager`, `FXMLController` to `CloudNoticeManagerController`,
    and `Scene.fxml` to `manager.fxml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Application` class will look a little different than in previous JavaFX
    applications. Some of the AWS client APIs require that they be shut down explicitly
    when you are finished with them. Failure to do so means that our application won''t
    fully quit, leaving behind **zombie** processes that must be killed. To make sure
    we properly shut down our AWS clients, we need to add a cleanup method to our
    controller, which we''ll call from the `stop()` method in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, regardless of whether the user clicks on File | Exit or clicks on the Close
    button on the window, our AWS clients can be cleaned up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of layout, there''s nothing new to discuss, so we''ll not dwell on
    that aspect here. This is what our manager app will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6a2fe65-aebb-4ccf-a83b-d30bec8c4ef8.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a list of the subscribed recipients on the left, an area for adding
    and editing a recipient at the top right, and an area for sending a test message
    at the bottom right. We do have some interesting bindings, so let's take a look
    at this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in `CloudNoticeManagerController`, we need to declare some containers
    for our data, so we declare a number of `ObservableList` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These three `ObservableList` instances will back the UI controls matching their
    names. We will populate two of those lists (`type` is hardcoded) in `initalize()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using our DAO and SES client, we fetch any already subscribed recipients, as
    well as any topics configured in the account. This will get *every* topic, so
    if you have a lot, this may be a problem, but this is just a demonstration application,
    so that should be fine here. Once we have these two lists, we add them to the
    `ObservableList` instances we created earlier, then associate the `List` with
    the appropriate UI controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the `Recipient` list displays correctly, we need to create a `CellFactory`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, if the cell is empty, we need to set the text to null to clear
    out any previous value. Failure to do that will result, at some point, in a `ListView`
    with **phantom** entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the edit controls when the user clicks on a `Recipient`
    in the list. We do this by adding a listener to the `selectedItemProperty`, which
    is run every time the selected item changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `newRecipient` is not null, we set the value of the controls to the appropriate
    value. Otherwise, we clear the values.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to add handlers for the various buttons--the Add and Remove buttons
    above the `Recipient` list, and the `Save` and `Cancel` buttons in the two **form**
    areas on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI control''s `onAction` property can be bound to the method in the class
    by editing the FXML directly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be bound to the method by editing the property in Scene Builder,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba0fd788-85bb-46f1-9eef-c5a71cb3ea43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Either way, the method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We're adding a `Recipient`, so we create a new one, add it to our `ObservableList`,
    then tell the `ListView` to select this entry. Finally, we ask the `type` control
    to request focus so the user can easily change the value with the keyboard, if
    so desired. The new Recipient isn't saved to DynamoDB until the user clicks on
    Save, which we will look at in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we delete a `Recipient`, we need to remove it from the UI as well as from
    DynamoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving is a bit more complicated, but not much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we're not binding the values of the edit controls to the selected item
    in the list, we need to get the reference to the item, then copy the values from
    the controls to the model. Once that's done, we save it to the database via our
    DAO, then ask `ListView` to refresh itself so that any model changes are reflected
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't binding the controls to the item in the list as that leads to a slightly
    confusing user experience. If we did bind, as the user made changes to the model
    `ListView` would reflect those changes. It is conceivable that the user would
    then assume that the changes are being saved to the database when, in fact, they
    are not. That doesn't happen until the user clicks on Save. To avoid this confusion,
    and the loss of data, we have *not* bound the controls and manage the data manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cancel the change, all we need to do is get a reference to the unchanged
    model from `ListView`, and copy its values over those in the edit controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That leaves us with the **send a message** section of the UI. Thanks to our
    SNS wrapper API, these methods are very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From our desktop application, we can now add, edit, and remove recipients, as
    well as send test messages.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your AWS credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those paying very close attention may be asking a very important question--How
    do the AWS client libraries know how to log on to our account? Clearly, we need
    to tell them, and we have a few options.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS SDK, when run locally, will check three places for the credentials--environment
    variables (`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`), system properties
    (`aws.accessKeyId` and `aws.secretKey`), and the default credentials profiles
    file (`$HOME/.aws/credentials`). What credentials you use is up to you, but I
    will show you here how to configure the profiles file.
  prefs: []
  type: TYPE_NORMAL
- en: Just like a Unix or Windows system, your AWS account has a `root` user that
    has complete access to your system. It would be extremely imprudent to run any
    client code connected as this user. To avoid that, we need to create a user, which
    we can do on the Identity and Access Management console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve logged on, click on Users on the left, then Add user at the top,
    the result of which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cea72534-8eff-4149-bd1d-d768aaaeafa8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next: Permissions and check the entry in the Group list for our role,
    `j9bp`. Click on Next: Review, then Create User. This will take you to the Add
    user screen, which should have a success message box. The important part is the
    user information listed toward the bottom of the screen. On the right side of
    this table, you should see the columns Access key ID and Secret access key. Click
    on Show on the access key to reveal the value. Make a note of both of these, as
    there is no way to retrieve the access key once you leave this page. If you lose
    it, you will have to generate a new set of keys, which will break any other application
    using the old credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2231a001-356f-41da-8b39-bedeed92c4b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a text editor, we need to create the `~/.aws/credentials` file. On a Unix
    system, that may be `/home/jdlee/.aws`, and on a Windows machine that will be
    something like `C:\Users\jdlee\aws`. The credentials file should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same directory, we need to create another file called `config`. We''ll
    use this file to tell the SDK which region we want to work in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the AWS clients start up now, they will default to connecting as the `j9bp`
    user in the `us-east-1` region. Should you need to override that, you can either
    edit this file or set the environment variables or system properties noted above
    in the section, *Configuring your AWS Credentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've done it! We've created, many of us, our very first AWS Lambda function,
    and it really wasn't all that difficult. It is a simple application, of course,
    but I hope you can see how this type of application could be very useful. Using
    this as a starting point, you can write systems, with the help of a mobile application,
    to help keep track of your family's location. Using embedded devices such as Raspberry
    PI, for example, you can build devices to track inventory as it is shipped across
    the country, reporting location, speed, environmental conditions, sudden drops
    or impacts, and so on. A piece of software running on a server could constantly
    report various metrics about the system, such as CPU temperature, free disk space,
    memory allocated, system load, and so on. Your options are limited only by your
    imagination.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up, let's take a quick look back at what we've learned. We learned about
    some of the various **... as a service** systems that are being offered today,
    and what **serverless** really means and why it may appeal to us as application
    developers. We learned how to configure various Amazon Web Services offerings,
    including Identity and Access Management, Simple Notification System, Simple Email
    Service, and, of course Lambda, and we learned how to write an AWS Lambda function
    in Java and how to deploy it to the service. And finally, we learned how to configure
    triggers that would tie an SNS publish/subscribe topic to our Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: There's no denying that our application is somewhat simple, and there's no way
    in the space of a single chapter to make you an expert in all that Amazon Web
    Services or any other cloud provider has to offer. Hopefully, you have enough
    to get you going--and get you excited--about writing cloud-based applications
    using Java. For those wanting to go deeper, there are a number of great books,
    web pages, and so on to help you delve deeper into this rapidly changing and expanding
    area. In our next chapter, we'll return from the cloud and turn our attention
    to another great space for Java developers--your mobile phone.
  prefs: []
  type: TYPE_NORMAL

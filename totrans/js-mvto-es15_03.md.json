["```js\nfunction add(a,b){\n  return a+b;\n}\nc = add(1,2);\nconsole.log(c);  //prints 3\n```", "```js\nvar add = function(a,b){\n  return a+b;\n}\nc = add(1,2);\nconsole.log(c);  //prints 3\n```", "```js\nvar facto = function factorial(n) {\n  if (n <= 1)\n    return 1;\n  return n * factorial(n - 1);\n};\nconsole.log(facto(3));  //prints 6\n```", "```js\n(function sayHello() {\n  console.log(\"hello!\");\n})();\n```", "```js\nfunction changeCase(val) {\n  return val.toUpperCase();\n}\nfunction demofunc(a, passfunction) {\n  console.log(passfunction(a));\n}\ndemofunc(\"smallcase\", changeCase);\n```", "```js\nvar looper = function(x){\n  if (x%5===0) {\n    return;\n  }\n  console.log(x)\n}\nfor(var i=1;i<10;i++){\n  looper(i);\n}\n```", "```js\n1, 2, 3, 4, 6, 7, 8, and 9, and not 5\\. When the if (x%5===0) condition is evaluated to true, the code simply returns from the function and the rest of the code is not executed.\n```", "```js\nvar say = console.log;\nsay(\"I can also say things\");\n```", "```js\nvar validateDataForAge = function(data) {\n person = data();\n  console.log(person);\n  if (person.age <1 || person.age > 99){\n    return true;\n  }else{\n    return false;\n  }\n};\n\nvar errorHandlerForAge = function(error) {\n  console.log(\"Error while processing age\");\n};\n\nfunction parseRequest(data,validateData,errorHandler) {\n  var error = validateData(data);\n  if (!error) {\n    console.log(\"no errors\");\n  } else {\n    errorHandler();\n  }\n}\n\nvar generateDataForScientist = function() {\n  return {\n    name: \"Albert Einstein\",\n    age : Math.floor(Math.random() * (100 - 1)) + 1,\n  };\n};\nvar generateDataForComposer = function() {\n  return {\n    name: \"J S Bach\",\n    age : Math.floor(Math.random() * (100 - 1)) + 1,\n  };\n};\n\n//parse request\nparseRequest(generateDataForScientist, validateDataForAge, errorHandlerForAge);\nparseRequest(generateDataForComposer, validateDataForAge, errorHandlerForAge);\n```", "```js\n    //Global Scope\n    var a = 1;\n    function scopeTest() {\n      console.log(a);\n    }\n    scopeTest();  //prints 1\n    ```", "```js\n//Global Scope\nvar a = 1;\nfunction scopeTest() {\n  a = 2; //Overwrites global variable 2, you omit 'var'\n  console.log(a);\n}\nconsole.log(a); //prints 1\nscopeTest();  //prints 2\nconsole.log(a); //prints 2 (global value is overwritten)\n```", "```js\nvar scope_name = \"Global\";\nfunction showScopeName () {\n  // local variable; only accessible in this function\n  var scope_name = \"Local\";\n  console.log (scope_name); // Local\n}\nconsole.log (scope_name);     //prints - Global\nshowScopeName();             //prints \u2013 Local\n```", "```js\n-GLOBAL SCOPE---------------------------------------------|\nvar g =0;                                                 |\nfunction foo(a) { -----------------------|                |\n    var b = 1;                           |                |\n    //code                               |                |\n    function bar() { ------|             |                |\n        // ...             |ScopeBar     | ScopeFoo       |\n    }                ------|             |                |\n    // code                              |                |\n    var c = 2;                           |                |\n}----------------------------------------|                |\nfoo();   //WORKS                                          |\nbar();   //FAILS                                          |\n----------------------------------------------------------|\n```", "```js\nfunction foo() {\n  function bar(a) {\n    i = 2; // changing the 'i' in the enclosing scope's for-loop\n    console.log(a+i);\n  }\n  for (var i=0; i<10; i++) {\n    bar(i); // infinite loop\n  }\n}\nfoo();\n```", "```js\nvar a = 1;\n//Lets introduce a function -scope\n//1\\. Add a named function foo() into the global scope\nfunction foo() { \n var a = 2;\n console.log( a ); // 2\n} \n//2\\. Now call the named function foo()\nfoo();\nconsole.log( a ); // 1\n```", "```js\nvar a = 1;\n//Lets introduce a function -scope\n//1\\. Add a named function foo() into the global scope\n(function foo() { \n var a = 2;\n console.log( a ); // 2\n})(); //<---this function executes immediately\nconsole.log( a ); // 1\n```", "```js\n(function foo(){ /* code */ })();\n\n```", "```js\nvar a = 1;\n(function() { \n var a = 2;\n console.log( a ); // 2\n})(); \nconsole.log( a ); // 1\n```", "```js\n(function(){ /* code */ }());\n```", "```js\n(function foo(b) { \n    var a = 2;\n    console.log( a + b ); \n})(3); //prints 5\n```", "```js\nfunction setActiveTab(activeTabHandler, tab){\n  //set active tab\n  //call handler\n  activeTabHandler();\n}\nsetActiveTab( function (){ \n console.log( \"Setting active tab\" );\n}, 1 );\n//prints \"Setting active tab\"\n```", "```js\nvar foo = true;\nif (foo) {\n  let bar = 42; //variable bar is local in this block { }\n  console.log( bar );\n}\nconsole.log( bar ); // ReferenceError\n```", "```js\nconsole.log( a );\nvar a = 1;\n```", "```js\na = 1;\nvar a;\nconsole.log( a );\n```", "```js\nvar a;   //----Compilation phase\n\na = 1;    //------execution phase\nconsole.log( a );\n```", "```js\nvar a;     //-----Compilation phase\n\nconsole.log( a );   \na = 1;     //------execution phase  \n```", "```js\nfoo();\nfunction foo() {\n  console.log(a); // undefined\n  var a = 1;\n}\n```", "```js\nfunction foo() {\n  var a;\n  console.log(a); // undefined\n  a = 1;\n}\n```", "```js\n//Function expression\nfunctionOne();\n//Error\n//\"TypeError: functionOne is not a function\n\nvar functionOne = function() {\n  console.log(\"functionOne\");\n};\n//Function declaration\nfunctionTwo();\n//No error\n//Prints - functionTwo\n\nfunction functionTwo() {\n  console.log(\"functionTwo\");\n}\n```", "```js\nsayMoo() but such a conditional code is not guaranteed to work across all browsers and can result in unpredictable results:\n```", "```js\n// Never do this - different browsers will behave differently\nif (true) {\n  function sayMoo() {\n    return 'trueMoo';\n  }\n}\nelse {\n  function sayMoo() {\n    return 'falseMoo';\n  }\n}\nfoo();\n```", "```js\nvar sayMoo;\nif (true) {\n  sayMoo = function() {\n    return 'trueMoo';\n  };\n}\nelse {\n  sayMoo = function() {\n    return 'falseMoo';\n  };\n}\nfoo();\n```", "```js\nvar sum = function () { \n  var i, total = 0;\n  for (i = 0; i < arguments.length; i += 1) {\n    total += arguments[i];\n  }\n  return total;\n};\nconsole.log(sum(1,2,3,4,5,6,7,8,9)); // prints 45\nconsole.log(sum(1,2,3,4,5)); // prints 15\n```", "```js\nvar args = Array.prototype.slice.call(arguments);\n```", "```js\nfunction add() {}\nadd();\nvar substract = function() {\n\n};\nsubstract();\n```", "```js\nvar person = {\n  name: 'Albert Einstein',\n  age: 66,\n  greet: function () {\n    console.log(this.name);\n  }\n};\nperson.greet();\n```", "```js\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>This test</title>\n  <script type=\"text/javascript\">\n function testF(){ return this; }\n console.log(testF()); \n var testFCopy = testF;\n console.log(testFCopy()); \n var testObj = {\n testObjFunc: testF\n };\n console.log(testObj.testObjFunc ());\n  </script>\n</head>\n<body>\n</body>\n</html>\n```", "```js\nvar Person = function (name) {\n  this.name = name;\n};\nPerson.prototype.greet = function () {\n  return this.name;\n};\nvar albert = new Person('Albert Einstein');\nconsole.log(albert.greet());\n```", "```js\nvar santa = {\n  say :function(){ \n    console.log(\"ho ho ho\"); \n  }\n}\nsanta.say();\n```", "```js\n<script type=\"text/javascript\">\nvar things = [\n  function() { alert(\"ThingOne\") },\n  function() { alert(\"ThingTwo\") },\n];\nfor(var x=0; x<things.length; x++) {\n  things[x]();\n}\n</script>\n```", "```js\n// function statement\nfunction eventHandler(event){\n  event();\n}\n\neventHandler(function(){\n  //do a lot of event related things\n  console.log(\"Event fired\");\n});\n```", "```js\nvar shape;\nif(shape_name === \"SQUARE\") {\n  shape = function() {\n    return \"drawing square\";\n  }\n}\nelse {\n  shape = function() {\n    return \"drawing square\";\n  }\n}\nalert(shape());\n```", "```js\nvar outer = 'I am outer'; //Define a value in global scope\nfunction outerFn() { //Declare a a function in global scope\n  console.log(outer);\n}\nouterFn(); //prints - I am outer\n```", "```js\nvar outer = 'Outer'; //Variable declared in global scope\nvar copy;\nfunction outerFn(){  //Function declared in global scope\n\n  var inner = 'Inner'; //Variable has function scope only, can not be\n  //accessed from outside \n\n  function innerFn(){     //Inner function within Outer function, \n    //both global context and outer\n    //context are available hence can access \n    //'outer' and 'inner'\n    console.log(outer);\n    console.log(inner);\n  }\n  copy=innerFn;          //Store reference to inner function, \n  //because 'copy' itself is declared\n  //in global context, it will be available \n  //outside also\n}\nouterFn();\ncopy();  //Cant invoke innerFn() directly but can invoke via a \n//variable declared in global scope\n```", "```js\nvar outer='outer';\nvar copy;\nfunction outerFn() {\n  var inner='inner';\n  function innerFn(param){\n    console.log(outer);\n    console.log(inner);\n console.log(param);\n console.log(magic);\n  }\n  copy=innerFn;\n}\nconsole.log(magic); //ERROR: magic not defined\nvar magic=\"Magic\";\nouterFn();\ncopy(\"copy\");\n```", "```js\nfunction delay(message) {\n  setTimeout( function timerFn(){\n    console.log( message );\n  }, 1000 );\n}\ndelay( \"Hello World\" );\n```", "```js\nfunction privateTest(){\n var points=0;\n  this.getPoints=function(){\n    return points;\n  };\n  this.score=function(){\n    points++;\n  };\n}\n\nvar private = new privateTest();\nprivate.score();\nconsole.log(private.points); // undefined\nconsole.log(private.getPoints());\n```", "```js\nfor (var i=1; i<=5; i++) {\n  setTimeout( function delay(){\n    console.log( i );\n  }, i*100);\n}\n```", "```js\nprint 1, 2, 3, 4, and 5 on the console at an interval of 100 ms, right? Instead, it prints 6, 6, 6, 6, and 6 at an interval of 100 ms. Why is this happening? Here, we encounter a common issue with closures and looping. The i variable is being updated after the function is bound. This means that every bound function handler will always print the last value stored in i. In fact, the timeout function callbacks are running after the completion of the loop. This is such a common problem that JSLint will warn you if you try to use functions this way inside a loop.\n```", "```js\nfor (var i=1; i<=5; i++) {\n  (function(j){\n    setTimeout( function delay(){\n      console.log( j );\n    }, j*100);\n  })( i );\n}\n```", "```js\nVar moduleName=function() {\n  //private state\n  //private functions\n  return {\n     //public state\n     //public variables\n  }\n}\n```", "```js\nvar superModule = (function (){\n  var secret = 'supersecretkey';\n  var passcode = 'nuke';\n\n  function getSecret() {\n    console.log( secret );\n  }\n\n  function getPassCode() {\n    console.log( passcode );\n  }\n\n  return {\n    getSecret: getSecret,\n    getPassCode: getPassCode\n  };\n})();\nsuperModule.getSecret();\nsuperModule.getPassCode();\n```", "```js\n    // bad\n    const foo = function () {\n    };\n\n    // good\n    function foo() {\n    }\n    ```"]
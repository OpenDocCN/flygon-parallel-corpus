- en: Chapter 2. Functions, Closures, and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。函数、闭包和模块
- en: In the previous chapter, we deliberately did not discuss certain aspects of
    JavaScript. These are some of the features of the language that give JavaScript
    its power and elegance. If you are an intermediate- or advanced-level JavaScript
    programmer, you may be actively using objects and functions. In many cases, however,
    developers stumble at these fundamental levels and develop a half-baked or sometimes
    wrong understanding of the core JavaScript constructs. There is generally a very
    poor understanding of the concept of closures in JavaScript, due to which many
    programmers cannot use the functional aspects of JavaScript very well. In JavaScript,
    there is a strong interconnection between objects, functions, and closures. Understanding
    the strong relationship between these three concepts can vastly improve our JavaScript
    programming ability, giving us a strong foundation for any type of application
    development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们故意没有讨论JavaScript的某些方面。这些是语言的一些特性，赋予了JavaScript其强大和优雅的特性。如果你是中级或高级水平的JavaScript程序员，你可能正在积极使用对象和函数。然而，在许多情况下，开发人员在这些基本层面上遇到困难，开发出了一个半成品或有时错误的对核心JavaScript结构的理解。由于对JavaScript中闭包概念的理解通常非常差，许多程序员无法很好地使用JavaScript的功能方面。在JavaScript中，对象、函数和闭包之间有着紧密的联系。理解这三个概念之间的强关系可以极大地提高我们的JavaScript编程能力，为任何类型的应用程序开发奠定坚实的基础。
- en: Functions are fundamental to JavaScript. Understanding functions in JavaScript
    is the single most important weapon in your arsenal. The most important fact about
    functions is that in JavaScript, functions are first-class objects. They are treated
    like any other JavaScript object. Just like other JavaScript data types, they
    can be referenced by variables, declared with literals, and even passed as function
    parameters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对JavaScript至关重要。理解JavaScript中的函数是你武器库中最重要的武器。关于函数最重要的事实是，在JavaScript中，函数是一等对象。它们像任何其他JavaScript对象一样对待。就像其他JavaScript数据类型一样，它们可以被变量引用，用文字声明，甚至作为函数参数传递。
- en: 'As with any other object in JavaScript, functions have the following capabilities:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript中的任何其他对象一样，函数具有以下功能：
- en: They can be created via literals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过文字创建
- en: They can be assigned to variables, array entries, and properties of other objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被分配给变量、数组条目和其他对象的属性
- en: They can be passed as arguments to functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为参数传递给函数
- en: They can be returned as values from functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以作为函数的返回值
- en: They can possess properties that can be dynamically created and assigned
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以拥有可以动态创建和分配的属性
- en: We will talk about each of these unique abilities of a JavaScript function in
    this chapter and the rest of the module.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章和本模块的其余部分讨论JavaScript函数的每个独特能力。
- en: A function literal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数文字
- en: One of the most important concepts in JavaScript is that the functions are the
    primary unit of execution. Functions are the pieces where you will wrap all your
    code, hence they will give your programs a structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中最重要的概念之一是函数是执行的主要单位。函数是你将包装所有代码的地方，因此它们将为你的程序提供结构。
- en: JavaScript functions are declared using a function literal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数是使用函数文字声明的。
- en: 'Function literals are composed of the following four parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数文字由以下四部分组成：
- en: The function keyword.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数关键字。
- en: An optional name that, if specified, must be a valid JavaScript identifier.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的名称，如果指定了，必须是有效的JavaScript标识符。
- en: A list of parameter names enclosed in parentheses. If there are no parameters
    to the function, you need to provide empty parentheses.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用括号括起来的参数名列表。如果函数没有参数，你需要提供空括号。
- en: The body of the function as a series of JavaScript statements enclosed in braces.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体作为一系列用大括号括起来的JavaScript语句。
- en: A function declaration
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'The following is a very trivial example to demonstrate all the components of
    a function declaration:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常简单的示例，演示了函数声明的所有组件：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The declaration begins with a `function` keyword followed by the function name.
    The function name is optional. If a function is not given a name, it is said to
    be anonymous. We will see how anonymous functions are used. The third part is
    the set of parameters of the function, wrapped in parentheses. Within the parentheses
    is a set of zero or more parameter names separated by commas. These names will
    be defined as variables in the function, and instead of being initialized to undefined,
    they will be initialized to the arguments supplied when the function is invoked.
    The fourth part is a set of statements wrapped in curly braces. These statements
    are the body of the function. They are executed when the function is invoked.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 声明以`function`关键字开头，后面跟着函数名。函数名是可选的。如果函数没有给定名称，则称为匿名函数。我们将看到匿名函数是如何使用的。第三部分是函数的参数集，用括号括起来。括号内是一组由逗号分隔的零个或多个参数名。这些名称将在函数中定义为变量，并且不会被初始化为undefined，而是在函数调用时初始化为提供的参数。第四部分是用大括号括起来的一组语句。这些语句是函数的主体。在调用函数时执行它们。
- en: This method of function declaration is also known as **function statement**.
    When you declare functions like this, the content of the function is compiled
    and an object with the same name as the function is created.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数声明方法也被称为**函数语句**。当你像这样声明函数时，函数的内容被编译，创建了一个与函数同名的对象。
- en: 'Another way of function declaration is via **function expressions**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种函数声明的方式是通过**函数表达式**：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we are creating an anonymous function and assigning it to an `add` variable;
    this variable is used to invoke the function as in the earlier example. One problem
    with this style of function declaration is that we cannot have recursive calls
    to this kind of function. Recursion is an elegant style of coding where the function
    calls itself. You can use named function expressions to solve this limitation.
    As an example, refer to the following function to compute the factorial of a given
    number, `n`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个匿名函数，并将其赋值给一个`add`变量；这个变量用于调用函数，就像前面的例子一样。这种函数声明风格的一个问题是，我们不能对这种函数进行递归调用。递归是一种优雅的编码风格，函数调用自身。你可以使用命名函数表达式来解决这个限制。例如，参考下面的函数来计算给定数字`n`的阶乘：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, instead of creating an anonymous function, you are creating a named function.
    Now, because the function has a name, it can call itself recursively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你不是创建一个匿名函数，而是创建了一个有名字的函数。现在，因为函数有一个名字，它可以递归地调用自己。
- en: 'Finally, you can create self-invoking function expressions (we will discuss
    them later):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以创建自调用函数表达式（我们稍后会讨论）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once defined, a function can be called in other JavaScript functions. After
    the function body is executed, the caller code (that executed the function) continues
    to execute. You can also pass a function as a parameter to another function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，函数就可以在其他JavaScript函数中调用。在函数体执行完毕后，调用函数的代码（执行函数的代码）继续执行。你也可以将一个函数作为参数传递给另一个函数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we are calling the `demofunc()` function with two
    parameters. The first parameter is the string that we want to convert to uppercase
    and the second one is the function reference to the `changeCase()` function. In
    `demofunc()`, we call the `changeCase()` function via its reference passed to
    the `passfunction` argument. Here we are passing a function reference as an argument
    to another function. This powerful concept will be discussed in detail later in
    the module when we discuss callbacks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们用两个参数调用了`demofunc()`函数。第一个参数是我们想要转换为大写的字符串，第二个是`changeCase()`函数的函数引用。在`demofunc()`中，我们通过传递给`passfunction`参数的引用调用了`changeCase()`函数。这里我们将一个函数引用作为参数传递给另一个函数。这个强大的概念将在模块后面详细讨论，当我们讨论回调时。
- en: 'A function may or may not return a value. In the previous examples, we saw
    that the `add` function returned a value to the calling code. Apart from returning
    a value at the end of the function, calling `return` explicitly allows you to
    conditionally return from a function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可能有也可能没有返回值。在前面的例子中，我们看到`add`函数将一个值返回给调用代码。除了在函数末尾返回一个值之外，显式调用`return`允许你有条件地从函数中返回：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functions as data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为数据
- en: 'In JavaScript, functions can be assigned to variables, and variables are data.
    You will shortly see that this is a powerful concept. Let''s see the following
    example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数可以赋值给变量，而变量是数据。你很快就会发现这是一个强大的概念。让我们看下面的例子：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we assigned the familiar `console.log()` function
    to the say variable. Any function can be assigned to a variable as shown in the
    preceding example. Adding parentheses to the variable will invoke it. Moreover,
    you can pass functions in other functions as parameters. Study the following example
    carefully and type it in JS Bin:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将熟悉的`console.log()`函数赋值给了say变量。任何函数都可以像前面的例子中那样赋值给一个变量。给变量加上括号将会调用它。此外，你也可以将函数作为参数传递给其他函数。仔细研究下面的例子，并在JS
    Bin中输入：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are passing functions as parameters to a `parseRequest()`
    function. We are passing different functions for two different calls, `generateDataForScientist`
    and `generateDataForComposers`, while the other two functions remain the same.
    You can observe that we defined a generic `parseRequest()`. It takes three functions
    as arguments, which are responsible for stitching together the specifics: the
    data, validator, and error handler. The `parseRequest()` function is fully extensible
    and customizable, and because it will be invoked by every request, there is a
    single, clean debugging point. I am sure that you have started to appreciate the
    incredible power that JavaScript functions provide.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将函数作为参数传递给`parseRequest()`函数。我们为两次不同的调用传递了不同的函数，`generateDataForScientist`和`generateDataForComposers`，而另外两个函数保持不变。你可以观察到我们定义了一个通用的`parseRequest()`。它接受三个函数作为参数，负责将具体的数据、验证器和错误处理程序组合在一起。`parseRequest()`函数是完全可扩展和可定制的，因为它将被每个请求调用，所以有一个单一的、清晰的调试点。我相信你已经开始欣赏JavaScript函数提供的令人难以置信的力量。
- en: Scoping
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: For beginners, JavaScript scoping is slightly confusing. These concepts may
    seem straightforward; however, they are not. Some important subtleties exist that
    must be understood in order to master the concept. So what is Scope? In JavaScript,
    scope refers to the current context of code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，JavaScript的作用域有点令人困惑。这些概念可能看起来很简单，但实际上并非如此。存在一些重要的微妙之处，必须理解才能掌握这个概念。那么什么是作用域？在JavaScript中，作用域指的是代码的当前上下文。
- en: A variable's scope is the context in which the variable exists. The scope specifies
    from where you can access a variable and whether you have access to the variable
    in that context. Scopes can be globally or locally defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域是变量存在的上下文。作用域指定了你可以从哪里访问变量，以及你是否可以在该上下文中访问变量。作用域可以是全局的或局部的。
- en: Global scope
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局作用域
- en: Any variable that you declare is by default defined in global scope. This is
    one of the most annoying language design decisions taken in JavaScript. As a global
    variable is visible in all other scopes, a global variable can be modified by
    any scope. Global variables make it harder to run loosely coupled subprograms
    in the same program/module. If the subprograms happen to have global variables
    that share the same names, then they will interfere with each other and likely
    fail, usually in difficult-to-diagnose ways. This is sometimes known as namespace
    clash. We discussed global scope in the previous chapter but let's revisit it
    briefly to understand how best to avoid this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明的任何变量默认都是在全局作用域中定义的。这是JavaScript中最令人讨厌的语言设计决定之一。由于全局变量在所有其他作用域中可见，任何作用域都可以修改全局变量。全局变量使得在同一程序/模块中运行松散耦合的子程序变得更加困难。如果子程序恰好具有共享相同名称的全局变量，那么它们将相互干扰并可能失败，通常是以难以诊断的方式。这有时被称为命名空间冲突。我们在上一章中讨论了全局作用域，但让我们简要地重新访问一下，以了解如何最好地避免这种情况。
- en: 'You can create a global variable in two ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式创建全局变量：
- en: The first way is to place a var statement outside any function. Essentially,
    any variable declared outside a function is defined in the global scope.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是在任何函数外部放置一个var语句。实质上，任何在函数外部声明的变量都在全局作用域中定义。
- en: 'The second way is to omit the var statement while declaring a variable (also
    called implied globals). I think this was designed as a convenience for new programmers
    but turned out to be a nightmare. Even within a function scope, if you omit the
    var statement while declaring a variable, it''s created by default in the global
    scope. This is nasty. You should always run your program against **ESLint** or
    **JSHint** to let them flag such violations. The following example shows how global
    scope behaves:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是在声明变量时省略var语句（也称为隐式全局变量）。我认为这是为新程序员设计的一种便利，但结果却是一场噩梦。即使在函数作用域内，如果在声明变量时省略var语句，它会默认在全局作用域中创建。这很糟糕。你应该始终使用**ESLint**或**JSHint**来检查此类违规行为。以下示例显示了全局作用域的行为：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we are declaring a variable outside the function and in the global scope.
    This variable is available in the `scopeTest()` function. If you assign a new
    value to a global scope variable within a function scope (local), the original
    value in the global scope is overwritten:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在函数外部和全局作用域中声明了一个变量。这个变量在`scopeTest()`函数中是可用的。如果在函数作用域（局部）内给全局作用域变量赋新值，全局作用域中的原始值将被覆盖：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Local scope
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部作用域
- en: 'Unlike most programming languages, JavaScript does not have block-level scope
    (variables scoped to surrounding curly brackets); instead, JavaScript has function-level
    scope. Variables declared within a function are local variables and are only accessible
    within that function or by functions inside that function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言不同，JavaScript没有块级作用域（变量作用域限定在周围的花括号内）；相反，JavaScript具有函数级作用域。在函数内声明的变量是局部变量，只能在该函数内部或该函数内部的函数中访问：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Function-level scope versus block-level scope
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数级作用域与块级作用域
- en: 'JavaScript variables are scoped at the function level. You can think of this
    as a small bubble getting created that prevents the variable to be visible from
    outside this bubble. A function creates such a bubble for variables declared inside
    the function. You can visualize the bubbles as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript变量的作用域是在函数级别的。你可以把它想象成创建了一个小泡泡，防止变量从这个泡泡外部可见。函数为在函数内部声明的变量创建了这样的泡泡。你可以将这些泡泡可视化如下：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: JavaScript uses scope chains to establish the scope for a given function. There
    is typically one global scope, and each function defined has its own nested scope.
    Any function defined within another function has a local scope that is linked
    to the outer function. *It's always the position in the source that defines the
    scope*. When resolving a variable, JavaScript starts at the innermost scope and
    searches outwards. With this, let's look at various scoping rules in JavaScript.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用作用域链来建立给定函数的作用域。通常有一个全局作用域，每个定义的函数都有自己的嵌套作用域。在另一个函数内定义的任何函数都有一个与外部函数相关联的局部作用域。*总是源代码中的位置定义了作用域*。在解析变量时，JavaScript从最内部的作用域开始向外搜索。有了这个，让我们来看看JavaScript中的各种作用域规则。
- en: In the preceding crudely drawn visual, you can see that the `foo()` function
    is defined in the global scope. The `foo()` function has its local scope and access
    to the `g` variable because it's in the global scope. The `a`, `b`, and `c` variables
    are available in the local scope because they are defined within the function
    scope. The `bar()` function is also declared within the function scope and is
    available within the `foo()` function. However, once the function scope is over,
    the `bar()` function is not available. You cannot see or call the `bar()` function
    from outside the `foo()` function—a scope bubble.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面粗略绘制的可视化中，你可以看到`foo()`函数是在全局作用域中定义的。`foo()`函数有它自己的局部作用域，并且可以访问`g`变量，因为它在全局作用域中。`a`、`b`和`c`变量在局部作用域中可用，因为它们在函数作用域内定义。`bar()`函数也在函数作用域内声明，并且在`foo()`函数内可用。然而，一旦函数作用域结束，`bar()`函数就不可用了。你不能从`foo()`函数外部看到或调用`bar()`函数——作用域泡泡。
- en: Now that the `bar()` function also has its own function scope (bubble), what
    is available in here? The `bar()` function has access to the `foo()` function
    and all the variables created in the parent scope of the `foo()` function—`a`,
    `b`, and `c`. The `bar()` function also has access to the global scoped variable,
    `g`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`bar()`函数也有它自己的函数作用域（泡泡），这里有什么可用的？`bar()`函数可以访问`foo()`函数和在`foo()`函数的父作用域中创建的所有变量——`a`、`b`和`c`。`bar()`函数还可以访问全局作用域变量`g`。
- en: This is a powerful idea. Take a moment to think about it. We just discussed
    how rampant and uncontrolled global scope can get in JavaScript. How about we
    take an arbitrary piece of code and wrap it around with a function? We will be
    able to hide and create a scope bubble around this piece of code. Creating the
    correct scope using function wrapping will help us create correct code and prevent
    difficult-to-detect bugs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的想法。花点时间思考一下。我们刚刚讨论了JavaScript中全局作用域可能变得随意和不受控制。如果我们将任意一段代码包裹在一个函数中，我们将能够隐藏并创建一个作用域范围在这段代码周围。使用函数包装创建正确的作用域将帮助我们创建正确的代码并防止难以检测的错误。
- en: 'Another advantage of the function scope and hiding variables and functions
    within this scope is that you can avoid collisions between two identifiers. The
    following example shows such a bad case:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作用域和在此作用域内隐藏变量和函数的另一个优点是，你可以避免两个标识符之间的冲突。下面的例子展示了这样一个糟糕的情况：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `bar()` function, we are inadvertently modifying the value of `i=2`.
    When we call `bar()` from within the `for` loop, the value of the `i` variable
    is set to `2` and we never come out of an infinite loop. This is a bad case of
    namespace collision.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bar()`函数中，我们无意中修改了`i=2`的值。当我们在`for`循环中调用`bar()`时，`i`变量的值被设置为`2`，我们永远无法跳出无限循环。这是一个命名空间冲突的糟糕情况。
- en: 'So far, using functions as a scope sounds like a great way to achieve modularity
    and correctness in JavaScript. Well, though this technique works, it''s not really
    ideal. The first problem is that we must create a named function. If we keep creating
    such functions just to introduce the function scope, we pollute the global scope
    or parent scope. Additionally, we have to keep calling such functions. This introduces
    a lot of boilerplate, which makes the code unreadable over time:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用函数作为作用域听起来是在JavaScript中实现模块化和正确性的好方法。尽管这种技术有效，但并不是理想的。第一个问题是我们必须创建一个命名函数。如果我们不断创建这样的函数来引入函数作用域，就会污染全局作用域或父作用域。此外，我们必须不断调用这样的函数。这会引入大量样板代码，使得代码难以阅读：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We introduced the function scope by creating a new function `foo()` to the global
    scope and called this function later to execute the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个新的函数`foo()`来引入函数作用域到全局作用域，并稍后调用这个函数来执行代码。
- en: 'In JavaScript, you can solve both these problems by creating functions that
    immediately get executed. Carefully study and type the following example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以通过创建立即执行的函数来解决这两个问题。仔细研究并输入以下示例：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the wrapping function statement starts with `function`. This means
    that instead of treating the function as a standard declaration, the function
    is treated as a function expression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包装函数语句以`function`开头。这意味着，函数不是作为标准声明对待，而是作为函数表达式对待。
- en: 'The `(function foo(){ })` statement as an expression means that the identifier
    `foo` is found only in the scope of the `foo()` function, not in the outer scope.
    Hiding the name `foo` in itself means that it does not pollute the enclosing scope
    unnecessarily. This is so useful and far better. We add `()` after the function
    expression to execute it immediately. So the complete pattern looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`(function foo(){ })`语句作为一个表达式意味着标识符`foo`只在`foo()`函数的作用域中找到，而不在外部作用域中。隐藏名称`foo`本身意味着它不会不必要地污染封闭作用域。这非常有用，而且更好。我们在函数表达式后面加上`()`来立即执行它。因此，完整的模式如下所示：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This pattern is so common that it has a name: **IIFE**, which stands for **Immediately
    Invoked** **Function Expression**. Several programmers omit the function name
    when they use IIFE. As the primary use of IIFE is to introduce function-level
    scope, naming the function is not really required. We can write the earlier example
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常常见，有一个名字：**IIFE**，代表**立即调用函数表达式**。许多程序员在使用IIFE时省略函数名称。因为IIFE的主要用途是引入函数级作用域，所以实际上并不需要给函数命名。我们可以将之前的例子写成如下形式：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here we are creating an anonymous function as IIFE. While this is identical
    to the earlier named IIFE, there are a few drawbacks of using anonymous IIFEs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个匿名函数作为IIFE。虽然这与之前的命名IIFE相同，但使用匿名IIFE有一些缺点：
- en: As you can't see the function name in the stack traces, debugging such code
    is very difficult
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在堆栈跟踪中看不到函数名称，调试这样的代码非常困难
- en: You cannot use recursion on anonymous functions (as we discussed earlier)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在匿名函数上使用递归（正如我们之前讨论的）
- en: Overusing anonymous IIFEs sometimes results in unreadable code
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用匿名IIFE有时会导致代码难以阅读
- en: 'Douglas Crockford and a few other experts recommend a slight variation of IIFE:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Douglas Crockford和其他一些专家推荐IIFE的一个略微变体：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both these IIFE forms are popular and you will see a lot of code using both
    these variations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种IIFE形式都很受欢迎，你会看到很多代码使用这两种变体。
- en: 'You can pass parameters to IIFEs. The following example shows you how to pass
    parameters to IIFEs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向IIFE传递参数。下面的例子展示了如何向IIFE传递参数：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inline function expressions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数表达式
- en: 'There is another popular usage of inline function expressions where the functions
    are passed as parameters to other functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数表达式的另一个常见用法是将函数作为参数传递给其他函数：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, you can name this inline function expression to make sure that you get
    a correct stack trace while you are debugging the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以给这个内联函数表达式命名，以确保在调试代码时获得正确的堆栈跟踪。
- en: Block scopes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块作用域
- en: 'As we discussed earlier, JavaScript does not have the concept of block scopes.
    Programmers familiar with other languages such as Java or C find this very uncomfortable.
    **ECMAScript 6** (**ES6**) introduces the **let** keyword to introduce traditional
    block scope. This is so incredibly convenient that if you are sure your environment
    is going to support ES6, you should always use the `let` keyword. See the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，JavaScript没有块作用域的概念。熟悉其他语言如Java或C的程序员会觉得这非常不舒服。**ECMAScript 6**（**ES6**）引入了**let**关键字来引入传统的块作用域。这非常方便，如果你确定你的环境将支持ES6，你应该始终使用`let`关键字。参见下面的代码：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, as things stand today, ES6 is not supported by default in most popular
    browsers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就目前而言，大多数流行的浏览器默认不支持ES6。
- en: This chapter so far should have given you a fair understanding of how scoping
    works in JavaScript. If you are still unclear, I would suggest that you stop here
    and revisit the earlier sections of this chapter. Research your doubts on the
    Internet or put your questions on Stack Overflow. In short, make sure that you
    have no doubts related to the scoping rules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章应该让您对JavaScript中作用域是如何工作有一个公平的理解。如果您仍然不清楚，我建议您停在这里，重新阅读本章的前几节。在互联网上研究您的疑问，或者在Stack
    Overflow上提出您的问题。简而言之，请确保您对作用域规则没有疑问。
- en: It is very natural for us to think of code execution happening from top to bottom,
    line by line. This is how most of JavaScript code is executed but with some exceptions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很自然地认为代码执行是从上到下，逐行进行的。这是大多数JavaScript代码执行的方式，但也有一些例外。
- en: 'Consider the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you said this is an invalid code and will result in `undefined` when we call
    `console.log()`, you are absolutely correct. However, what about this?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您说这是无效的代码，并且在我们调用`console.log()`时将导致`undefined`，那么您是完全正确的。但是，这个呢？
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What should be the output of the preceding code? It is natural to expect `undefined`
    as the `var a` statement comes after `a = 1`, and it would seem natural to assume
    that the variable is redefined and thus assigned the default `undefined`. However,
    the output will be `1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该输出什么？自然会期望`undefined`，因为`var a`语句在`a = 1`之后，似乎自然地假设变量被重新定义，因此被赋予默认的`undefined`。然而，输出将是`1`。
- en: 'When you see `var a = 1`, JavaScript splits it into two statements: `var a`
    and `a = 1`. The first statement, the declaration, is processed during the compilation
    phase. The second statement, the assignment, is left in place for the execution
    phase.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到`var a = 1`时，JavaScript将其分成两个语句：`var a`和`a = 1`。第一条语句，声明，将在编译阶段处理。第二条语句，赋值，将保留在执行阶段。
- en: 'So the preceding snippet would actually be executed as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的代码片段实际上将执行如下：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first snippet is actually executed as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段实际上将执行如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, as we can see, variable and function declarations are moved up to the top
    of the code during compilation phase—this is also popularly known as **hoisting**.
    It is very important to remember that only the declarations themselves are hoisted,
    while any assignments or other executable logic are left in place. The following
    snippet shows you how function declarations are hoisted:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，在编译阶段，变量和函数声明被移动到代码的顶部——这也被称为**提升**。非常重要的是要记住，只有声明本身被提升，而任何赋值或其他可执行逻辑都保持原样。以下片段向您展示了函数声明是如何提升的：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The declaration of the `foo()` function is hoisted such that we are able to
    execute the function before defining it. One important aspect of hoisting is that
    it works per scope. Within the `foo()` function, declaration of the a variable
    will be hoisted to the top of the `foo()` function, and not to the top of the
    program. The actual execution of the `foo()` function with hoisting will be something
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo()`函数的声明被提升，以便我们能够在定义之前执行该函数。提升的一个重要方面是它按作用域工作。在`foo()`函数内部，变量a的声明将被提升到`foo()`函数的顶部，而不是程序的顶部。带有提升的`foo()`函数的实际执行将如下所示：'
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We saw that function declarations are hoisted but function expressions are not.
    The next section explains this case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到函数声明被提升，但函数表达式不会。下一节将解释这种情况。
- en: Function declarations versus function expressions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明与函数表达式
- en: 'We saw two ways by which functions are defined. Though they both serve identical
    purposes, there is a difference between these two types of declarations. Check
    the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了两种函数定义的方式。虽然它们都有相同的目的，但这两种声明类型之间有所不同。检查以下示例：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, it''s perfectly safe and, in fact, smart to do the same with function
    expressions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用函数表达式做同样的事情是完全安全的，事实上也是明智的：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you are curious to know why you should not use function declarations in conditional
    blocks, read on; otherwise, you can skip the following paragraph.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么不应该在条件块中使用函数声明，请继续阅读；否则，您可以跳过以下段落。
- en: Function declarations are allowed to appear only in the program or function
    body. They cannot appear in a block (`{ ... }`). Blocks can only contain statements
    and not function declarations. Due to this, almost all implementations of JavaScript
    have behavior different from this. It is always advisable to *never* use function
    declarations in a conditional block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明只允许出现在程序或函数体中。它们不能出现在块（`{ ... }`）中。块只能包含语句，而不能包含函数声明。由于这个原因，几乎所有JavaScript的实现都有不同的行为。*永远*不要在条件块中使用函数声明是一个明智的建议。
- en: Function expressions, on the other hand, are very popular. A very common pattern
    among JavaScript programmers is to fork function definitions based on some kind
    of a condition. As such forks usually happen in the same scope, it is almost always
    necessary to use function expressions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数表达式非常受欢迎。JavaScript程序员中非常常见的一种模式是根据某种条件分叉函数定义。由于这些分叉通常发生在同一作用域中，几乎总是需要使用函数表达式。
- en: The arguments parameter
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数参数
- en: 'The arguments parameter is a collection of all the arguments passed to the
    function. The collection has a property named `length` that contains the count
    of arguments, and the individual argument values can be obtained using an array
    indexing notation. Okay, we lied a bit. The arguments parameter is not a JavaScript
    array, and if you try to use array methods on arguments, you''ll fail miserably.
    You can think of arguments as an array-like structure. This makes it possible
    to write functions that take an unspecified number of parameters. The following
    snippet shows you how you can pass a variable number of arguments to the function
    and iterate through them using an arguments array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 参数参数是传递给函数的所有参数的集合。该集合具有一个名为`length`的属性，其中包含参数的计数，可以使用数组索引表示法获取各个参数值。好吧，我们有点撒谎。参数参数不是JavaScript数组，如果您尝试在参数上使用数组方法，您将遭遇惨败。您可以将参数视为类似数组的结构。这使得可以编写接受未指定数量参数的函数成为可能。以下代码片段向您展示了如何将可变数量的参数传递给函数，并使用参数数组对它们进行迭代：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we discussed, the arguments parameter is not really an array; it is possible
    to convert it to an array as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的那样，参数参数并不是真正的数组；可以按照以下方式将其转换为数组：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once converted to an array, you can manipulate the list as you wish.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦转换为数组，您可以随心所欲地操作列表。
- en: The this parameter
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this参数
- en: Whenever a function is invoked, in addition to the parameters that represent
    the explicit arguments that were provided on the function call, an implicit parameter
    named `this` is also passed to the function. It refers to an object that's implicitly
    associated with the function invocation, termed as a **function context**. If
    you have coded in Java, the `this` keyword will be familiar to you; like Java,
    `this` points to an instance of the class in which the method is defined.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用函数时，除了代表函数调用时提供的显式参数之外，还会传递一个名为`this`的隐式参数给函数。它指的是与函数调用隐式关联的对象，称为**函数上下文**。如果您在Java中编码过，`this`关键字对您来说将是熟悉的；与Java一样，`this`指向定义方法的类的实例。
- en: Equipped with this knowledge, let's talk about various invocation methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，让我们来谈谈各种调用方法。
- en: Invocation as a function
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为函数调用
- en: 'If a function is not invoked as a method, constructor, or via `apply()` or
    `call()`, it''s simply invoked *as a function*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数不是作为方法、构造函数或通过`apply()`或`call()`调用的，它就是简单地作为一个函数调用：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When a function is invoked with this pattern, `this` is bound to the global
    object. Many experts believe this to be a bad design choice. It is natural to
    assume that `this` would be bound to the parent context. When you are in a situation
    such as this, you can capture the value of `this` in another variable. We will
    focus on this pattern later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种模式调用函数时，`this`绑定到全局对象。许多专家认为这是一个糟糕的设计选择。自然而然地会认为`this`将绑定到父上下文。当您处于这种情况时，您可以将`this`的值捕获到另一个变量中。我们稍后将重点讨论这种模式。
- en: Invocation as a method
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为方法调用
- en: 'A method is a function tied to a property on an object. For methods, `this`
    is bound to the object on invocation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是绑定到对象属性的函数。对于方法，`this`在调用时绑定到对象：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, `this` is bound to the person object on invoking `greet` because
    `greet` is a method of person. Let's see how this behaves in both these invocation
    patterns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当调用`greet`时，`this`绑定到person对象，因为`greet`是person的一个方法。让我们看看这两种调用模式中`this`的行为。
- en: 'Let''s prepare this HTML and JavaScript harness:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备一下这个HTML和JavaScript的测试环境：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the **Firebug** console, you can see the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Firebug**控制台中，您可以看到以下输出：
- en: '![Invocation as a method](img/00006.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![作为方法调用](img/00006.jpeg)'
- en: The first two method invocations were invocation as a function; hence, the `this`
    parameter pointed to the global context (`Window`, in this case).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法调用都是作为函数调用的；因此，`this`参数指向全局上下文（在这种情况下是`Window`）。
- en: Next, we define an object with a `testObj` variable with a property named `testObjFunc`
    that receives a reference to `testF()`—don't fret if you are not really aware
    of object creation yet. By doing this, we created a `testObjMethod()` method.
    Now, when we invoke this method, we expect the function context to be displayed
    when we display the value of `this`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个带有`testObj`变量的对象，该对象具有一个名为`testObjFunc`的属性，该属性接收对`testF()`的引用——如果您还不太了解对象创建，不要担心。通过这样做，我们创建了一个`testObjMethod()`方法。现在，当我们调用这个方法时，我们期望在显示`this`的值时显示函数上下文。
- en: Invocation as a constructor
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为构造函数调用
- en: '**Constructor** functions are declared just like any other functions and there''s
    nothing special about a function that''s going to be used as a constructor. However,
    the way in which they are invoked is very different.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数**函数的声明方式与任何其他函数一样，并且要用作构造函数的函数没有任何特殊之处。但是，它们被调用的方式非常不同。'
- en: To invoke the function as a constructor, we precede the function invocation
    with the **new** keyword. When this happens, `this` is bound to the new object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数作为构造函数调用，我们在函数调用之前加上**new**关键字。当这种情况发生时，`this`绑定到新对象。
- en: 'Before we discuss more, let''s take a quick introduction to object orientation
    in JavaScript. We will, of course, discuss the topic in great detail in the next
    chapter. JavaScript is a prototypal inheritance language. This means that objects
    can inherit properties directly from other objects. The language is class-free.
    Functions that are designed to be called with the `new` prefix are called constructors.
    Usually, they are named using **PascalCase** as opposed to **CamelCase** for easier
    distinction. In the following example, notice that the `greet` function uses this
    to access the `name` property. The `this` parameter is bound to `Person`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论更多内容之前，让我们快速介绍一下JavaScript中的面向对象。当然，我们将在下一章节中详细讨论这个主题。JavaScript是一种原型继承语言。这意味着对象可以直接从其他对象继承属性。该语言是无类的。设计为使用`new`前缀调用的函数称为构造函数。通常，它们使用**PascalCase**而不是**CamelCase**命名以便更容易区分。在下面的例子中，请注意`greet`函数使用`this`来访问`name`属性。`this`参数绑定到`Person`：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will discuss this particular invocation method when we study objects in the
    next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论这种特定的调用方法，当我们学习对象时。
- en: Invocation using apply() and call() methods
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用apply()和call()方法进行调用
- en: 'We said earlier that JavaScript functions are objects. Like other objects,
    they also have certain methods. To invoke a function using its `apply()` method,
    we pass two parameters to `apply()`: the object to be used as the function context
    and an array of values to be used as the invocation arguments. The `call()` method
    is used in a similar manner, except that the arguments are passed directly in
    the argument list rather than as an array.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过JavaScript函数是对象。像其他对象一样，它们也有某些方法。要使用`apply()`方法调用函数，我们向`apply()`传递两个参数：要用作函数上下文的对象和要用作调用参数的值数组。`call()`方法的使用方式类似，只是参数直接在参数列表中传递，而不是作为数组。
- en: Anonymous functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: We introduced you to anonymous functions a bit earlier in this chapter, and
    as they're a crucial concept, we will take a detailed look at them. For a language
    inspired by Scheme, anonymous functions are an important logical and structural
    construct.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章稍早介绍了匿名函数，因为它们是一个重要的概念，我们将对它们进行详细讨论。对于受Scheme启发的语言来说，匿名函数是一个重要的逻辑和结构构造。
- en: Anonymous functions are typically used in cases where the function doesn't need
    to have a name for later reference. Let's look at some of the most popular usages
    of anonymous functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数通常用于函数不需要名称以供以后引用的情况。让我们看一些匿名函数最流行的用法。
- en: Anonymous functions while creating an object
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象时的匿名函数
- en: 'An anonymous function can be assigned to an object property. When we do that,
    we can call that function with a dot (`.`) operator. If you are coming from a
    Java or other OO language background, you will find this very familiar. In such
    languages, a function, which is part of a class is generally called with a notation—`Class.function()`.
    Let''s consider the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将匿名函数分配给对象属性。当我们这样做时，我们可以使用点(`.`)运算符调用该函数。如果你来自Java或其他面向对象的语言背景，你会觉得这非常熟悉。在这样的语言中，一个类的一部分通常使用符号`Class.function()`来调用函数。让我们考虑以下例子：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we are creating an object with a `say` property, which is an
    anonymous function. In this particular case, this property is known as a method
    and not a function. We don't need to name this function because we are going to
    invoke it as the object property. This is a popular pattern and should come in
    handy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个带有`say`属性的对象，这是一个匿名函数。在这种情况下，这个属性被称为方法而不是函数。我们不需要给这个函数命名，因为我们将它作为对象属性来调用。这是一个流行的模式，应该会派上用场。
- en: Anonymous functions while creating a list
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数创建列表
- en: 'Here, we are creating two anonymous functions and adding them to an array.
    (We will take a detailed look at arrays later.) Then, you loop through this array
    and execute the functions in a loop:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个匿名函数并将它们添加到一个数组中。（我们稍后会详细讨论数组。）然后，你循环遍历这个数组并在循环中执行这些函数：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Anonymous functions as a parameter to another function
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数作为另一个函数的参数
- en: 'This is one of the most popular patterns and you will find such code in most
    professional libraries:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最流行的模式之一，你会在大多数专业库中找到这样的代码：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You are passing the anonymous function to another function. In the receiving
    function, you are executing the function passed as a parameter. This can be very
    convenient if you are creating single-use functions such as object methods or
    event handlers. The anonymous function syntax is more concise than declaring a
    function and then doing something with it as two separate steps.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在将匿名函数传递给另一个函数。在接收函数中，你正在执行作为参数传递的函数。如果你正在创建单次使用的函数，比如对象方法或事件处理程序，这可能非常方便。匿名函数的语法比声明函数然后对其进行操作的两个步骤更加简洁。
- en: Anonymous functions in conditional logic
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件逻辑中的匿名函数
- en: 'You can use anonymous function expressions to conditionally change behavior.
    The following example shows this pattern:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用匿名函数表达式有条件地改变行为。以下示例展示了这种模式：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, based on a condition, we are assigning a different implementation to the
    `shape` variable. This pattern can be very useful if used with care. Overusing
    this can result in unreadable and difficult-to-debug code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，基于一个条件，我们为`shape`变量分配了不同的实现。如果小心使用，这种模式可以非常有用。过度使用会导致代码难以阅读和调试。
- en: Later in this module, we will look at several functional tricks such as **memoization**
    and caching function calls. If you have reached here by quickly reading through
    the entire chapter, I would suggest that you stop for a while and contemplate
    on what we have discussed so far. The last few pages contain a ton of information
    and it will take some time for all this information to sink in. I would suggest
    that you reread this chapter before proceeding further. The next section will
    focus on closures and the module pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块的后面，我们将看一些函数技巧，比如**记忆化**和缓存函数调用。如果你通过快速阅读整章来到这里，我建议你停下来思考一下我们到目前为止讨论过的内容。最后几页包含了大量信息，需要一些时间来消化。我建议你在继续之前重新阅读本章。下一节将重点讨论闭包和模块模式。
- en: Closures
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: Traditionally, closures have been a feature of purely functional programming
    languages. JavaScript shows its affinity with such functional programming languages
    by considering closures integral to the core language constructs. Closures are
    gaining popularity in mainstream JavaScript libraries and advanced production
    code because they let you simplify complex operations. You will hear experienced
    JavaScript programmers talking almost reverently about closures—as if they are
    some magical construct far beyond the reach of the intellect that common men possess.
    However, this is not so. When you study this concept, you will find closures to
    be very obvious, almost matter-of-fact. Till you reach closure enlightenment,
    I suggest you read and reread this chapter, research on the Internet, write code,
    and read JavaScript libraries to understand how closures behave—but do not give
    up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，闭包一直是纯函数式编程语言的一个特性。JavaScript通过将闭包视为核心语言结构的一部分，表现出与这种函数式编程语言的亲和性。闭包因其能够简化复杂操作而在主流JavaScript库和高级生产代码中变得流行起来。你会听到有经验的JavaScript程序员几乎虔诚地谈论闭包，好像它们是一种超出普通人智慧范围的神奇构造。然而，事实并非如此。当你学习这个概念时，你会发现闭包是非常明显的，几乎是理所当然的。在你达到闭包的启示之前，我建议你阅读并反复阅读本章，在互联网上进行研究，编写代码，并阅读JavaScript库以了解闭包的行为，但不要放弃。
- en: The first realization that you must have is that closure is everywhere in JavaScript.
    It is not a hidden special part of the language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须意识到的第一个事实是，闭包在JavaScript中无处不在。它不是语言中隐藏的特殊部分。
- en: Before we jump into the nitty-gritty, let's quickly refresh the lexical scope
    in JavaScript. We discussed in great detail how lexical scope is determined at
    the function level in JavaScript. Lexical scope essentially determines where and
    how all identifiers are declared and predicts how they will be looked up during
    execution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论之前，让我们快速回顾一下JavaScript中的词法作用域。我们详细讨论了词法作用域是如何在JavaScript中的函数级别确定的。词法作用域基本上决定了所有标识符的声明位置和方式，并预测了它们在执行期间的查找方式。
- en: In a nutshell, closure is the scope created when a function is declared that
    allows the function to access and manipulate variables that are external to this
    function. In other words, closures allow a function to access all the variables,
    as well as other functions, that are in scope when the function itself is declared.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，闭包是在函数声明时创建的作用域，允许函数访问和操作外部于该函数的变量。换句话说，闭包允许函数访问所有在函数自身声明时的作用域中的变量，以及其他函数。
- en: 'Let''s look at some example code to understand this definition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些示例代码来理解这个定义：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Were you expecting something shiny? No, this is really the most ordinary case
    of a closure. We are declaring a variable in the global scope and declaring a
    function in the global scope. In the function, we are able to access the variable
    declared in the global scope—`outer`. So essentially, the outer scope for the
    `outerFn()` function is a closure and always available to `outerFn()`. This is
    a good start but perhaps then you are not sure why this is such a great thing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你是不是期待着看到一些闪亮的东西？不，这真的是闭包的最普通的情况。我们在全局作用域中声明了一个变量，并在全局作用域中声明了一个函数。在函数中，我们能够访问在全局作用域中声明的变量`outer`。因此，`outerFn()`函数的外部作用域实际上是一个闭包，并且始终对`outerFn()`可用。这是一个很好的开始，但也许你不确定为什么这是一件了不起的事情。
- en: 'Let''s make things a bit more complex:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让事情变得更加复杂一些：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What phenomenon allows the `inner` variable to still be available when we execute
    the inner function, long after the scope in which it was created has gone away?
    When we declared `innerFn()` in `outerFn()`, not only was the function declaration
    defined, but a closure was also created that encompasses not only the function
    declaration, but also all the variables that are in scope at the point of the
    declaration. When `innerFn()` executes, even if it's executed after the scope
    in which it was declared goes away, it has access to the original scope in which
    it was declared through its closure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是什么现象使得`inner`变量在我们执行内部函数时仍然可用，即使它被创建的作用域早已消失？当我们在`outerFn()`中声明`innerFn()`时，不仅仅是函数声明被定义了，还创建了一个包含函数声明以及声明点处所有变量的闭包。当`innerFn()`执行时，即使它是在声明它的作用域消失后执行的，它也通过闭包可以访问到它最初声明的作用域。
- en: 'Let''s continue to expand this example to understand how far you can go with
    closures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续扩展这个例子，以了解闭包可以走多远：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, we have added a few more things. First, we added a
    parameter to `innerFn()`—just to illustrate that parameters are also part of the
    closure. There are two important points that we want to highlight.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了一些东西。首先，我们向`innerFn()`添加了一个参数，只是为了说明参数也是闭包的一部分。有两个重要的观点我们想要强调。
- en: All variables in an outer scope are included even if they are declared after
    the function is declared. This makes it possible for the line, `console.log(magic)`,
    in `innerFn()`, to work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所有外部作用域中的变量都包括在内，即使它们是在函数声明之后声明的。这使得在`innerFn()`中的`console.log(magic)`行可以工作。
- en: However, the same line, `console.log(magic)`, in the global scope will fail
    because even within the same scope, variables not yet defined cannot be referenced.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在全局作用域中，同一行`console.log(magic)`将会失败，因为即使在同一作用域内，尚未定义的变量也不能被引用。
- en: All these examples were intended to convey a few concepts that govern how closures
    work. Closures are a prominent feature in the JavaScript language and you can
    see them in most libraries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都旨在传达一些控制闭包工作方式的概念。闭包是JavaScript语言中的一个突出特性，你可以在大多数库中看到它们。
- en: Let's look at some popular patterns around closures.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些围绕闭包的流行模式。
- en: Timers and callbacks
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器和回调
- en: 'In implementing timers or callbacks, you need to call the handler asynchronously,
    mostly at a later point in time. Due to the asynchronous calls, we need to access
    variables from outside the scope in such functions. Consider the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We pass the inner `timerFn()` function to the built-in library function, `setTimeout()`.
    However, `timerFn()` has a scope closure over the scope of `delay()`, and hence
    it can reference the variable message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Private variables
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are frequently used to encapsulate some information as private variables.
    JavaScript does not allow such encapsulation found in programming languages such
    as Java or C++, but by using closures, we can achieve similar encapsulation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, we are creating a function that we intend to call
    as a constructor. In this `privateTest()` function, we are creating a `var points=0`
    variable as a function-scoped variable. This variable is available only in `privateTest()`.
    Additionally, we create an accessor function (also called a getter)—`getPoints()`—this
    method allows us to read the value of only the points variable from outside `privateTest()`,
    making this variable private to the function. However, another method, `score()`,
    allows us to modify the value of the private point variable without directly accessing
    it from outside. This makes it possible for us to write code where a private variable
    is updated in a controlled fashion. This pattern can be very useful when you are
    writing libraries where you want to control how variables are accessed based on
    a contract and pre-established interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Loops and closures
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following example of using functions inside loops:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'How can we fix this behavior? We can introduce a function scope and local copy
    of the `i` variable in that scope. The following snippet shows you how we can
    do this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We pass the `i` variable and copy it to the `j` variable local to the IIFE.
    The introduction of an IIFE inside each iteration creates a new scope for each
    iteration and hence updates the local copy with the correct value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules are used to mimic classes and focus on public and private access to
    variables and functions. Modules help in reducing the global scope pollution.
    Effective use of modules can reduce name collisions across a large code base.
    A typical format that this pattern takes is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are two requirements to implement this pattern in the preceding format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: There must be an outer enclosing function that needs to be executed at least
    once.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enclosing function must return at least one inner function. This is necessary
    to create a closure over the private state—without this, you can't access the
    private state at all.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the following example of a module:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example satisfies both the conditions. Firstly, we create an IIFE or a
    named function to act as an outer enclosure. The variables defined will remain
    private because they are scoped in the function. We return the public functions
    to make sure that we have a closure over the private scope. Using IIFE in the
    module pattern will actually result in a singleton instance of this function.
    If you want to create multiple instances, you can create named function expressions
    as part of the module as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We will keep exploring various facets of functional aspects of JavaScript and
    closures in particular. There can be a lot of imaginative uses of such elegant
    constructs. An effective way to understand various patterns is to study the code
    of popular libraries and practice writing these patterns in your code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Stylistic considerations
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the previous chapter, we will conclude this discussion with certain stylistic
    considerations. Again, these are generally accepted guidelines and not rules—feel
    free to deviate from them if you have reason to believe otherwise:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Use function declarations instead of function expressions:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Never declare a function in a non-function block (if, while, and so on). Assign
    the function to a variable instead. Browsers allow you to do it, but they all
    interpret it differently.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在非函数块（if、while等）中声明函数。而是将函数赋值给一个变量。浏览器允许你这样做，但它们都会以不同的方式解释它。
- en: Never name a parameter `arguments`. This will take precedence over the `arguments`
    object that is given to every function scope.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将参数命名为`arguments`。这将优先于每个函数作用域中给定的`arguments`对象。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied JavaScript functions. In JavaScript, functions play
    a critical role. We discussed how functions are created and used. We also discussed
    important ideas of closures and the scope of variables in terms of functions.
    We discussed functions as a way to create visibility classes and encapsulation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript函数。在JavaScript中，函数起着关键作用。我们讨论了如何创建和使用函数。我们还讨论了闭包的重要概念以及函数中变量的作用域。我们讨论了函数作为创建可见性类和封装的一种方式。
- en: In the next chapter, we will look at various data structures and data manipulation
    techniques in JavaScript.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下JavaScript中各种数据结构和数据操作技术。

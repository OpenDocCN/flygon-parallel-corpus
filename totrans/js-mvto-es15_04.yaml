- en: Chapter 3. Data Structures and Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time that you spend in programming, you do something to manipulate
    data. You process properties of data, derive conclusions based on the data, and
    change the nature of the data. In this chapter, we will take an exhaustive look
    at various data structures and data manipulation techniques in JavaScript. With
    the correct usage of these expressive constructs, your programs will be correct,
    concise, easy to read, and most probably faster. This will be explained with the
    help of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exact match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match from a class of characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeated occurrences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning and end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backreferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greedy and lazy quantifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matter of style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not familiar with regular expressions, I request you to spend time
    learning them. Learning and using regular expressions effectively is one of the
    most rewarding skills that you will gain. During most of the code review sessions,
    the first thing that I comment on is how a piece of code can be converted to a
    single line of **regular expression** (or **RegEx**). If you study popular JavaScript
    libraries, you will be surprised to see how ubiquitous RegEx are. Most seasoned
    engineers rely on RegEx primarily because once you know how to use them, they
    are concise and easy to test. However, learning RegEx will take a significant
    amount of effort and time. A regular expression is a way to express a pattern
    to match strings of text. The expression itself consists of terms and operators
    that allow us to define these patterns. We'll see what these terms and operators
    consist of shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, there are two ways to create a regular expression: via a regular
    expression literal and constructing an instance of a `RegExp` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to create a RegEx that matches the string test exactly,
    we could use the following RegEx literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'RegEx literals are delimited using forward slashes. Alternatively, we could
    construct a `RegExp` instance, passing the RegEx as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these formats result in the same RegEx being created in the variable
    pattern. In addition to the expression itself, there are three flags that can
    be associated with a RegEx:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`: This makes the RegEx case-insensitive, so `/test/i` matches not only `test`,
    but also `Test`, `TEST`, `tEsT`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: This matches all the instances of the pattern as opposed to the default
    of local, which matches the first occurrence only. More on this later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: This allows matches across multiple lines that might be obtained from
    the value of a `textarea` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These flags are appended to the end of the literal (for example, `/test/ig`)
    or passed in a string as the second parameter to the `RegExp` constructor (`new
    RegExp("test", "ig")`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the various flags and how they affect the
    pattern match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It isn't very exciting if we can just test whether the pattern matches a string.
    Let's see how we can express more complex patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exact match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any sequence of characters that''s not a special RegEx character or operator
    represents a character literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We mean `o` followed by `r` followed by `a` followed by `n` followed by …—you
    get the point. We rarely use exact match when using RegEx because that is the
    same as comparing two strings. Exact match patterns are sometimes called simple
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Match from a class of characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to match against a set of characters, you can place the set inside
    `[]`. For example, `[abc]` would mean any character `a`, `b`, or `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify that you want to match anything but the pattern by adding a
    `^` (caret sign) at the beginning of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One critical variation of this pattern is a range of values. If we want to
    match against a sequential range of characters or numbers, we can use the following
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Special characters such as `$` and period (`.`) characters either represent
    matches to something other than themselves or operators that qualify the preceding
    term. In fact, we've already seen how `[`, `]`, `-`, and `^` characters are used
    to represent something other than their literal values.
  prefs: []
  type: TYPE_NORMAL
- en: How do we specify that we want to match a literal `[` or `$` or `^` or some
    other special character? Within a RegEx, the backslash character escapes whatever
    character follows it, making it a literal match term. So `\[` specifies a literal
    match to the `[` character rather than the opening of a character class expression.
    A double backslash (`\\`) matches a single backslash.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, we saw the `test()` method that returns **true**
    or **false** based on the pattern matched. There are times when you want to access
    occurrences of a particular pattern. The `exec()` method comes in handy in such
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exec()` method takes a string as an argument and returns an array containing
    all matches. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return all the occurrences of the word `oyo` from the original text.
    The String object contains the `match()` method that has similar functionality
    of the `exec()` method. The `match()` method is called on a String object and
    the RegEx is passed to it as a parameter. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are calling the `match()` method on the String object. We
    pass the RegEx as a parameter to the `match()` method. The results are the same
    in both these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other String object method is `replace()`. It replaces all the occurrences
    of a substring with a different string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to pass a function as a second parameter of the `replace()`
    method. The `replace()` function takes the matching text as a parameter and returns
    the text that is used as a replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The String object''s `split()` method also takes a RegEx parameter and returns
    an array containing all the substrings generated after splitting the original
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We need to add a backslash before the comma because a comma is treated specially
    in RegEx and we need to escape it if we want to use it literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using simple character classes, you can match multiple patterns. For example,
    if you want to match `cat`, `bat`, and `fat`, the following snippet shows you
    how to use simple character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this variation opens up possibilities to write concise RegEx
    patterns. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are matching the numeric part of the matching string with
    a range `[0-5]`, hence we get a match from `i0` to `i5`. You can also use the
    negation class `^` to filter the rest of the matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Observe how we are negating only the range clause and not the entire expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several character groups have shortcut notations. For example, the shortcut
    `\d` means the same thing as `[0-9]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Notation | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Any digit character |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | An alphanumeric character (word character) |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Any whitespace character (space, tab, newline, and similar) |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | A character that is not a digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | A non-alphanumeric character |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A non-whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any character except for newline |'
  prefs: []
  type: TYPE_TB
- en: 'These shortcuts are valuable in writing concise RegEx. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression definitely looks a bit strange. We can replace `[0-9]` with
    `\d` and make this a bit more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, you will soon see that there are even better ways to do something like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated occurrences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we saw how we can match fixed characters or numeric patterns. Most often,
    you want to handle certain repetitive natures of patterns also. For example, if
    I want to match 4 `a`s, I can write `/aaaa/`, but what if I want to specify a
    pattern that can match any number of `a`s?
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions provide you with a wide variety of repetition quantifiers.
    Repetition quantifiers let us specify how many times a particular pattern can
    occur. We can specify fixed values (characters should appear *n* times) and variable
    values (characters can appear at least *n* times till they appear *m* times).
    The following table lists the various repetition quantifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?`: Either 0 or 1 occurrence (marks the occurrence as optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: 0 or more occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: 1 or more occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n}`: Exactly `n` occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,m}`: Occurrences between `n` and `m`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,}`: At least an `n` occurrence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{,n}`: 0 to `n` occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we create a pattern where the character `u` is optional
    (has 0 or 1 occurrence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It helps to read the `/behaviou?r/` expression as 0 or 1 occurrences of character
    `u`. The repetition quantifier succeeds the character that we want to repeat.
    Let''s try out some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should read and interpret the `\d+` expression as `'` is a literal character
    match, `\d` matches characters `[0-9]`, the `+` quantifier will allow one or more
    occurrences, and `'` is a literal character match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also group character expressions using `()`. Observe the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the preceding expression into smaller chunks to understand what
    is going on in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`H`: literal character match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`: 1 or more occurrences of character `a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(`: start of the expression group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: literal character match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`: 1 or more occurrences of character `a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`)`: end of expression group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: 1 or more occurrences of expression group (`Ha+`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it is easier to see how the grouping is done. If we have to interpret the
    expression, it is sometimes helpful to read out the expression, as shown in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you want to match a sequence of letters or numbers on their own and not
    just as a substring. This is a fairly common use case when you are matching words
    that are not just part of any other words. We can specify the word boundaries
    by using the `\b` pattern. The word boundary with `\b` matches the position where
    one side is a word character (letter, digit, or underscore) and the other side
    is not. Consider the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple literal match. This match will also be successful
    if `cat` is part of a substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the following example, we define a word boundary by indicating
    `\b` before the word `cat`—this means that we want to match only if `cat` is a
    word and not a substring. The boundary is established before `cat`, and hence
    a match is found on the text, `a black cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the same boundary with the word `tomcat`, we get a failed match
    because there is no word boundary before `cat` in the word `tomcat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a word boundary after the string `cat` in the word `tomcat`, hence
    the following is a successful match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we define the word boundary before and after the
    word `cat` to indicate that we want `cat` to be a standalone word with boundaries
    before and after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the same logic, the following match fails because there are no boundaries
    before and after `cat` in the word `concatenate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec()` method is useful in getting information about the match found
    because it returns an object with information about the match. The object returned
    from `exec()` has an `index` property that tells us where the successful match
    begins in the string. This is useful in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives – OR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternatives can be expressed using the `|` (pipe) character. For example, `/a|b/`
    matches either the `a` or `b` character, and `/(ab)+|(cd)+/` matches one or more
    occurrences of either `ab` or `cd`.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning and end
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frequently, we may wish to ensure that a pattern matches at the beginning of
    a string or perhaps at the end of a string. The caret character, when used as
    the first character of the RegEx, anchors the match at the beginning of the string
    such that `/^test/` matches only if the test substring appears at the beginning
    of the string being matched. Similarly, the dollar sign (`$`) signifies that the
    pattern must appear at the end of the string: `/test$/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using both `^` and `$` indicates that the specified pattern must encompass
    the entire candidate string: `/^test$/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Backreferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After an expression is evaluated, each group is stored for later use. These
    values are known as backreferences. Backreferences are created and numbered by
    the order in which opening parenthesis characters are encountered going from left
    to right. You can think of backreferences as the portions of a string that are
    successfully matched against terms in the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: The notation for a backreference is a backslash followed by the number of the
    capture to be referenced, beginning with 1, such as `\1`, `\2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example could be `/^([XYZ])a\1/`, which matches a string that starts with
    any of the `X`, `Y`, or `Z` characters followed by an `a` and followed by whatever
    character matched the first capture. This is very different from `/[XYZ] a[XYZ]/`.
    The character following `a` can''t be any of `X`, or `Y`, or `Z`, but must be
    whichever one of those that triggered the match for the first character. Backreferences
    are used with String''s `replace()` method using the special character sequences,
    `$1`, `$2`, and so on. Suppose that you want to change the `1234 5678` string
    to `5678 1234`. The following code accomplishes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the regular expression has two groups each with four digits.
    In the second argument of the `replace()` method, `$2` is equal to `5678` and
    `$1` is equal to `1234`, corresponding to the order in which they appear in the
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy and lazy quantifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the quantifiers that we discussed so far are greedy. A greedy quantifier
    starts looking at the entire string for a match. If there are no matches, it removes
    the last character in the string and reattempts the match. If a match is not found
    again, the last character is again removed and the process is repeated until a
    match is found or the string is left with no characters.
  prefs: []
  type: TYPE_NORMAL
- en: The `\d+` pattern, for example, will match one or more digits. For example,
    if your string is `123`, a greedy match would match `1`, `12`, and `123`. Greedy
    pattern `h`.`+l` would match `hell` in a string `hello`—which is the longest possible
    string match. As `\d+` is greedy, it will match as many digits as possible and
    hence the match would be `123`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to greedy quantifiers, a lazy quantifier matches as few of the quantified
    tokens as possible. You can add a question mark (`?`) to the regular expression
    to make it lazy. A lazy pattern `h.?l` would match `hel` in the string `hello`—which
    is the shortest possible string.
  prefs: []
  type: TYPE_NORMAL
- en: The `\w*?X` pattern will match zero or more words and then match an `X`. However,
    a question mark after `*` indicates that as few characters as possible should
    be matched. For an `abcXXX` string, the match can be `abcX`, `abcXX`, or `abcXXX`.
    Which one should be matched? As `*?` is lazy, as few characters as possible are
    matched and hence the match is `abcX`.
  prefs: []
  type: TYPE_NORMAL
- en: With this necessary information, let's try to solve some common problems using
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing extra white space from the beginning and end of a string is a very
    common use case. As a String object did not have the `trim()` method until recently,
    several JavaScript libraries provide and use an implementation of string trimming
    for older browsers that don''t have the `String.trim()` method. The most commonly
    used approach looks something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to replace repeated whitespaces with a single whitespace?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array is an ordered set of values. You can refer to the array elements with
    a name and index. These are the three ways to create arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When these values are specified, the array is initialized with them as the array's
    elements. An array's `length` property is equal to the number of arguments. The
    bracket syntax is called an array literal. It's a shorter and preferred way to
    initialize arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to use the array literal syntax if you want to initialize an array
    with a single element and the element happens to be a number. If you pass a single
    number value to the `Array()` constructor or function, JavaScript considers this
    parameter as the length of the array, not as a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript does not have an explicit array data type. However, you can use the
    predefined `Array` object and its methods to work with arrays in your applications.
    The `Array` object has methods to manipulate arrays in various ways, such as joining,
    reversing, and sorting them. It has a property to determine the array length and
    other properties for use with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can populate an array by assigning values to its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also populate an array when you create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In most languages, the elements of an array are all required to be of the same
    type. JavaScript allows an array to contain any type of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to elements of an `Array` using the element''s index number.
    For example, suppose you define the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You then refer to the first element of the array as `colors[0]` and the second
    element of the array as `colors[1]`. The index of the elements starts with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript internally stores array elements as standard object properties,
    using the array index as the property name. The `length` property is different.
    The `length` property always returns the index of the last element plus one. As
    we discussed, JavaScript array indexes are 0-based: they start at `0`, not `1`.
    This means that the `length` property will be one more than the highest index
    stored in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign to the `length` property. Writing a value that is shorter
    than the number of stored items truncates the array; writing `0` empties it entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you query a non-existent array index, you get `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common operation is to iterate over the values of an array, processing each
    one in some way. The simplest way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forEach()` method provides another way of iterating over an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The function passed to `forEach()` is executed once for every item in the array,
    with the array item passed as the argument to the function. Unassigned values
    are not iterated in a `forEach()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `Array` object has a bunch of useful methods. These methods allow the manipulation
    of the data stored in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `concat()` method joins two arrays and returns a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `join()` method joins all the elements of an array into a string. This
    can be useful while processing a list. The default delimiter is a comma (`,`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pop()` method removes the last element from an array and returns that
    element. This is analogous to the `pop()` method of a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push()` method adds one or more elements to the end of an array and returns
    the resulting length of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shift()` method removes the first element from an array and returns that
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unshift()` method adds one or more elements to the front of an array and
    returns the new length of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reverse()` method reverses or transposes the elements of an array—the
    first array element becomes the last and the last becomes the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method sorts the elements of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method can optionally take a callback function to define how the
    elements are compared. The function compares two values and returns one of three
    values. Let us study the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`indexOf(searchElement[, fromIndex])`: This searches the array for `searchElement`
    and returns the index of the first match:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`lastIndexOf(searchElement[, fromIndex])`: This works like `indexOf()`, but
    only searches backwards:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered JavaScript arrays in depth, let me introduce you to
    a fantastic library called **Underscore.js** ([http://underscorejs.org/](http://underscorejs.org/)).
    Underscore.js provides a bunch of exceptionally useful functional programming
    helpers to make your code even more clear and functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume that you are familiar with **Node.js**; in this case, install
    Underscore.js via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we are installing Underscore as a Node module, we will test all the examples
    by typing them in a `.js` file and running the file on Node.js. You can install
    Underscore using **Bower** also.
  prefs: []
  type: TYPE_NORMAL
- en: Like jQuery's `$` module, Underscore comes with a `_` module defined. You will
    call all functions using this module reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code in a text file and name it `test_.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be written as follows, without using `each()` function from underscore
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: What you see here is a powerful functional construct that makes the code much
    more elegant and concise. You can clearly see that the traditional approach is
    verbose. Many languages such as Java suffer from this verbosity. They are slowly
    embracing functional paradigms. As JavaScript programmers, it is important for
    us to incorporate these ideas into our code as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The `each()` function we saw in the preceding example iterates over a list of
    elements, yielding each to an iteratee function in turn. Each invocation of iteratee
    is called with three arguments (element, index, and list). In the preceding example,
    the `each()` function iterates over the array `[1,2,3]`, and for each element
    in the array, the `print` function is called with the array element as the parameter.
    This is a convenient alternative to the traditional looping mechanism to access
    all the elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range()` function creates lists of integers. The start value, if omitted,
    defaults to `0` and step defaults to `1`. If you''d like a negative range, use
    a negative step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `range()` populates the array with integers, but with a little
    trick, you can populate other data types also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is a fast and convenient way to create and initialize an array with values.
    We frequently do this by traditional loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map()` function produces a new array of values by mapping each value in
    the list through a transformation function. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reduce()` function reduces a list of values to a single value. The initial
    state is passed by the iteratee function and each successive step is returned
    by the iteratee. The following example shows the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the line, `console.log(memo,num);`, is just to make the idea
    clear. The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The final output is a sum of *1+2+3=6*. As you can see, two values are passed
    to the iteratee function. On the first iteration, we call the iteratee function
    with two values `(0,1)`—the value of the `memo` is defaulted in the call to the
    `reduce()` function and `1` is the first element of the list. In the function,
    we sum `memo` and `num` and return the intermediate `sum`, which will be used
    by the `iterate()` function as a `memo` parameter—eventually, the `memo` will
    have the accumulated `sum`. This concept is important to understand how the intermediate
    states are used to calculate eventual results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter()` function iterates through the entire list and returns an array
    of all the elements that pass the condition. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `filter()` function's iteratee function should return a truth value. The
    resulting `evens` array contains all the elements that satisfy the truth test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of the `filter()` function is `reject()`. As the name suggests,
    it iterates through the list and ignores elements that satisfy the truth test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We are using the same code as the previous example but using the `reject()`
    method instead of `filter()`—the result is exactly the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contains()` function is a useful little function that returns `true` if
    the value is present in the list; otherwise, returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'One very useful function that I have grown fond of is `invoke()`. It calls
    a specific function on each element in the list. I can''t tell you how many times
    I have used it since I stumbled upon it. Let us study the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `sort()` method of the `Array` object is called for each
    element in the array. Note that this would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the `sort` method is not part of the String object. This, however,
    would work perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is because `toUpperCase()` is a String object method and all elements of
    the list are of the String type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uniq()` function returns the array after removing all duplicates from
    the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `partition()` function splits the array into two; one whose elements satisfy
    the predicate and the other whose elements don''t satisfy the predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `without()` function returns a copy of the array with all instances of
    the specific values removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 6 introduces sets. Sets are collections of values and can be iterated
    in the order of the insertion of their elements. An important characteristic about
    sets is that a value can occur only once in a set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows some basic operations on sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We discussed briefly that JavaScript arrays are not really arrays in a traditional
    sense. In JavaScript, arrays are objects that have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `length` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions that inherit from `Array.prototype` (we will discuss this in the
    next chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special handling for keys that are numeric keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we write an array index as numbers, they get converted to strings—`arr[0]`
    internally becomes `arr["0"]`. Due to this, there are a few things that we need
    to be aware of when we use JavaScript arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements by an index is not a constant time operation as it
    is in, say, C. As arrays are actually key-value maps, the access will depend on
    the layout of the map and other factors (collisions and others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript arrays are sparse (most of the elements have the default value),
    which means that the array can have gaps in it. To understand this, look at the
    following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You will see the output as `[undefined, undefined, undefined]`—`undefined` is
    the default value stored on the array element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that there are gaps in this array. Only two elements have elements
    and the rest are gaps with the default value. Knowing this helps you in a couple
    of things. Using the `for...in` loop to iterate an array can result in unexpected
    results. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A matter of style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the previous chapters, we will spend some time discussing the style considerations
    while creating arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the literal syntax for array creation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `Array#push` instead of a direct assignment to add items to an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As JavaScript matures as a language, its tool chain also becomes more robust
    and effective. It is rare to see seasoned programmers staying away from libraries
    such as Underscore.js. As we see more advanced topics, we will continue to explore
    more such versatile libraries that can make your code compact, more readable,
    and performant. We looked at regular expressions—they are first-class objects
    in JavaScript. Once you start understanding `RegExp`, you will soon find yourself
    using more of them to make your code concise. In the next chapter, we will look
    at JavaScript Object notation and how JavaScript prototypal inheritance is a new
    way of looking at object-oriented programming.
  prefs: []
  type: TYPE_NORMAL

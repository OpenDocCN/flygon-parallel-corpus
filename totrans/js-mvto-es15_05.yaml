- en: Chapter 4. Object-Oriented JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。面向对象的JavaScript
- en: 'JavaScript''s most fundamental data type is the Object data type. JavaScript
    objects can be seen as mutable key-value-based collections. In JavaScript, arrays,
    functions, and RegExp are objects while numbers, strings, and Booleans are object-like
    constructs that are immutable but have methods. In this chapter, you will learn
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最基本的数据类型是对象数据类型。JavaScript对象可以被视为可变的基于键值的集合。在JavaScript中，数组、函数和RegExp都是对象，而数字、字符串和布尔值是类似对象的构造，它们是不可变的但具有方法。在本章中，你将学习以下主题：
- en: Understanding objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象
- en: Instance properties versus prototype properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例属性与原型属性
- en: Inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Getters and setters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Understanding objects
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: Before we start looking at how JavaScript treats objects, we should spend some
    time on an object-oriented paradigm. Like most programming paradigms, **object-oriented
    programming** (**OOP**) also emerged from the need to manage complexity. The main
    idea is to divide the entire system into smaller pieces that are isolated from
    each other. If these small pieces can hide as many implementation details as possible,
    they become easy to use. A classic car analogy will help you understand this very
    important point about OOP.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始研究JavaScript如何处理对象之前，我们应该花一些时间来了解面向对象的范式。像大多数编程范式一样，**面向对象编程**（**OOP**）也是出于管理复杂性的需要而出现的。其主要思想是将整个系统分成相互隔离的小块。如果这些小块能够尽可能隐藏实现细节，那么它们就变得容易使用。一个经典的汽车类比将帮助你理解关于OOP的这一非常重要的观点。
- en: When you drive a car, you operate on the interface—the steering, clutch, brake,
    and accelerator. Your view of using the car is limited by this interface, which
    makes it possible for us to drive the car. This interface is essentially hiding
    all the complex systems that really drive the car, such as the internal functioning
    of its engine, its electronic system, and so on. As a driver, you don't bother
    about these complexities. A similar idea is the primary driver of OOP. An object
    hides the complexities of how to implement a particular functionality and exposes
    a limited interface to the outside world. All other systems can use this interface
    without really bothering about the internal complexity that is hidden from view.
    Additionally, an object usually hides its internal state from other objects and
    prevents its direct modification. This is an important aspect of OOP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你驾驶一辆汽车时，你操作的是接口——方向盘、离合器、刹车和油门。你对使用汽车的看法受到这个接口的限制，这使得我们能够驾驶汽车。这个接口本质上隐藏了真正驾驶汽车的所有复杂系统，比如它的发动机的内部功能、它的电子系统等等。作为驾驶员，你不会去理会这些复杂性。类似的思想是OOP的主要驱动因素。一个对象隐藏了如何实现特定功能的复杂性，并向外界暴露了有限的接口。所有其他系统都可以使用这个接口，而不会真正理会从视图中隐藏的内部复杂性。此外，一个对象通常会隐藏其内部状态，防止其他对象直接修改。这是OOP的一个重要方面。
- en: In a large system where a lot of objects call other objects' interfaces, things
    can go really bad if you allow them to modify the internal state of such objects.
    OOP operates on the idea that the state of an object is inherently hidden from
    the outside world and it can be changed only via controlled interface operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型系统中，许多对象调用其他对象的接口，如果允许它们修改这些对象的内部状态，情况可能会变得非常糟糕。OOP的操作基于这样一个思想，即对象的状态从外界本质上是隐藏的，只能通过受控的接口操作来改变。
- en: 'OOP was an important idea and a definite step forward from the traditional
    structured programming. However, many feel that OOP is overdone. Most OOP systems
    define complex and unnecessary class and type hierarchies. Another big drawback
    was that in the pursuit of hiding the state, OOP considered the object state almost
    immaterial. Though hugely popular, OOP was clearly flawed in many areas. Still,
    OOP did have some very good ideas, especially hiding the complexity and exposing
    only the interface to the outside world. JavaScript picked up a few good ideas
    and built its object model around them. Luckily, this makes JavaScript objects
    very versatile. In their seminal work, *Design Patterns: Elements of Reusable
    Object-Oriented Software*, the *Gang of Four* gave two fundamental principles
    of a better object-oriented design:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一个重要的思想，也是传统结构化编程的一个明显进步。然而，许多人认为OOP过度了。大多数OOP系统定义了复杂和不必要的类和类型层次结构。另一个很大的缺点是，在隐藏状态的追求中，OOP认为对象状态几乎是无关紧要的。尽管广受欢迎，OOP在许多方面显然存在缺陷。不过，OOP确实有一些非常好的想法，尤其是隐藏复杂性，只向外界暴露接口。JavaScript吸收了一些好的想法，并围绕它们构建了自己的对象模型。幸运的是，这使得JavaScript对象非常灵活。在他们的开创性作品《设计模式：可复用面向对象软件的元素》中，*四人帮*提出了更好的面向对象设计的两个基本原则：
- en: Program to an interface and not to an implementation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按接口编程，而不是按实现编程
- en: Object composition over class inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象组合优于类继承
- en: 'These two ideas are really against how classical OOP operates. The classical
    style of inheritance operates on inheritance that exposes parent classes to all
    child classes. Classical inheritance tightly couples children to its parents.
    There are mechanisms in classical inheritance to solve this problem to a certain
    extent. If you are using classical inheritance in a language such as Java, it
    is generally advisable to *program to an interface, not an implementation*. In
    Java, you can write a decoupled code using interfaces:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个思想与经典OOP的运作方式真的相悖。经典继承的运作方式是通过继承将父类暴露给所有子类。经典继承将子类与父类紧密耦合。经典继承中有机制来在一定程度上解决这个问题。如果你在像Java这样的语言中使用经典继承，通常建议*按接口编程，而不是按实现编程*。在Java中，你可以使用接口编写解耦的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead of programming to an implementation, you can perform the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是按照实现编程，你可以执行以下操作：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'How does programming to an interface help? When you program to the `List` interface,
    you can call methods only available to the `List` interface and nothing specific
    to `ArrayList` can be called. Programming to an interface gives you the liberty
    to change your code and use any other specific child of the `List` interface.
    For example, I can change my implementation and use `LinkedList` instead of `ArrayList`.
    You can change your variable to use `LinkedList` instead:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编程到接口有何帮助？当您编程到`List`接口时，您只能调用`List`接口可用的方法，不能调用任何特定于`ArrayList`的方法。编程到接口使您有自由更改代码并使用`List`接口的任何其他特定子类。例如，我可以更改我的实现并使用`LinkedList`而不是`ArrayList`。您可以更改您的变量以使用`LinkedList`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The beauty of this approach is that if you are using the `List` at 100 places
    in your program, you don't have to worry about changing the implementation at
    all these places. As you were programming to the interface and not to the implementation,
    you were able to write a loosely coupled code. This is an important principle
    when you are using classical inheritance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的美妙之处在于，如果您在程序中的100个地方使用`List`，您根本不必担心在所有这些地方更改实现。因为您是按接口而不是按实现编程，所以您能够编写松散耦合的代码。这是在使用经典继承时的一个重要原则。
- en: 'Classical inheritance also has a limitation where you can only enhance the
    child class within the limit of the parent classes. You can''t fundamentally differ
    from what you have got from the ancestors. This inhibits reuse. Classical inheritance
    has several other problems as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经典继承还存在一个限制，即您只能在父类的限制内增强子类。您不能从祖先那里根本上有所不同。这限制了重用。经典继承还有其他一些问题，如下所示：
- en: Inheritance introduces tight coupling. Child classes have knowledge about their
    ancestors. This tightly couples a child class with its parent.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承引入了紧密耦合。子类对其祖先有所了解。这使得子类与其父类紧密耦合。
- en: 'When you subclass from a parent, you don''t have a choice to select what you
    want to inherit and what you don''t. *Joe Armstrong* (the inventor of **Erlang**)
    explains this situation very well—his now famous quote:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您从父类继承时，您无法选择要继承和不继承的内容。**Joe Armstrong**（**Erlang**的发明者）非常好地解释了这种情况——他现在著名的引用：
- en: '*"The problem with object-oriented languages is they''ve got all this implicit
    environment that they carry around with them. You wanted a banana but what you
    got was a gorilla holding the banana and the entire jungle."*'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “面向对象语言的问题在于它们携带了所有这些隐含的环境。你想要一个香蕉，但你得到的是一个拿着香蕉和整个丛林的大猩猩。”
- en: Behavior of JavaScript objects
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript对象的行为
- en: 'With this background, let''s explore how JavaScript objects behave. In broad
    terms, an object contains properties, defined as a key-value pair. A property
    key (name) can be a string and the value can be any valid JavaScript value. You
    can create objects using object literals. The following snippet shows you how
    object literals are created:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个背景，让我们探讨一下JavaScript对象的行为。广义上讲，一个对象包含属性，定义为键值对。属性键（名称）可以是一个字符串，值可以是任何有效的JavaScript值。您可以使用对象字面量来创建对象。以下片段向您展示了如何创建对象字面量：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A property''s name can be any string or an empty string. You can omit quotes
    around the property name if the name is a legal JavaScript name. So quotes are
    required around `first-name` but are optional around `firstname`. Commas are used
    to separate the pairs. You can nest objects as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的名称可以是任何字符串或空字符串。如果名称是一个合法的JavaScript名称，您可以省略属性名称周围的引号。因此，在`first-name`周围需要引号，但在`firstname`周围是可选的。逗号用于分隔这些对。您可以嵌套对象如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Properties of an object can be accessed by using two notations: the array-like
    notation and dot notation. According to the array-like notation, you can retrieve
    the value from an object by wrapping a string expression in `[]`. If the expression
    is a valid JavaScript name, you can use the dot notation using `.` instead. Using
    `.` is a preferred method of retrieving values from an object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的属性可以通过两种表示法来访问：类似数组的表示法和点表示法。根据类似数组的表示法，您可以通过在`[]`中包装一个字符串表达式来从对象中检索值。如果表达式是有效的JavaScript名称，您可以使用`.`代替。使用`.`是从对象中检索值的首选方法：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get an `undefined` error if you attempt to retrieve a non-existent
    value. The following would return `undefined`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试检索一个不存在的值，您将会得到一个`undefined`错误。以下将返回`undefined`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A useful trick is to use the `||` operator to fill in default values in this
    case:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的技巧是使用`||`运算符来填充默认值：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can update values of an object by assigning a new value to the property:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为属性分配新值来更新对象的值：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you observe closely, you will realize that the object literal syntax that
    you see is very similar to the JSON format.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会意识到您看到的对象字面量语法与JSON格式非常相似。
- en: 'Methods are properties of an object that can hold function values as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是对象的属性，可以保存函数值，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Prototypes
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: Apart from the properties that we add to an object, there is one default property
    for almost all objects, called a **prototype**. When an object does not have a
    requested property, JavaScript goes to its prototype to look for it. The `Object.getPrototypeOf()`
    function returns the prototype of an object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们添加到对象的属性之外，几乎所有对象都有一个默认属性，称为**原型**。当一个对象没有所请求的属性时，JavaScript会去它的原型中寻找。`Object.getPrototypeOf()`函数返回一个对象的原型。
- en: Many programmers consider prototypes closely related to objects' inheritance—they
    are indeed a way of defining object types—but fundamentally, they are closely
    associated with functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员认为原型与对象的继承密切相关——它们确实是定义对象类型的一种方式——但从根本上讲，它们与函数密切相关。
- en: 'Prototypes are used as a way to define properties and functions that will be
    applied to instances of objects. The prototype''s properties eventually become
    properties of the instantiated objects. Prototypes can be seen as blueprints for
    object creation. They can be seen as analogous to classes in object-oriented languages.
    Prototypes in JavaScript are used to write a classical style object-oriented code
    and mimic classical inheritance. Let''s revisit our earlier example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 原型被用作定义将应用于对象实例的属性和函数的一种方式。原型的属性最终成为实例化对象的属性。原型可以被视为对象创建的蓝图。它们可以被视为面向对象语言中的类的类似物。JavaScript中的原型用于编写经典风格的面向对象代码和模拟经典继承。让我们重新访问我们之前的例子：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we have a `player()` function that does nothing. We
    invoke it in two different ways. The first call of the function is as a normal
    function and second call is as a constructor—note the use of the `new()` operator
    in this call. Once the function is defined, we add a `usesBat()` method to it.
    When this function is called as a normal function, the object is not instantiated
    and we see `undefined` assigned to `crazyBob`. However, when we call this function
    with the `new` operator, we get a fully instantiated object, `swingJay`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有一个不做任何事情的`player()`函数。我们以两种不同的方式调用它。函数的第一次调用是作为普通函数，第二次调用是作为构造函数——请注意在此调用中使用了`new()`运算符。一旦函数被定义，我们向其添加了一个`usesBat()`方法。当这个函数作为普通函数调用时，对象没有被实例化，我们看到`crazyBob`被赋值为`undefined`。然而，当我们使用`new`运算符调用这个函数时，我们得到一个完全实例化的对象`swingJay`。
- en: Instance properties versus prototype properties
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例属性与原型属性
- en: 'Instance properties are the properties that are part of the object instance
    itself, as shown in the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是对象实例本身的属性，如下例所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run this example, you will see that **Instance method says - he is
    hired** is printed. The `isAvailable()` function defined in the `Player()` function
    is called an instance of `Player`. This means that apart from attaching properties
    via the prototype, you can use the this keyword to initialize properties in a
    constructor. When we have the same functions defined as an instance property and
    also as a prototype, the instance property takes precedence. The rules governing
    the precedence of the initialization are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此示例时，您将看到打印出**实例方法说-他被雇佣**。在`Player()`函数中定义的`isAvailable()`函数被称为`Player`的一个实例。这意味着除了通过原型附加属性之外，您还可以使用`this`关键字在构造函数中初始化属性。当我们将相同的函数定义为实例属性和原型时，实例属性优先。初始化优先级的规则如下：
- en: Properties are tied to the object instance from the prototype
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性与原型中的对象实例绑定
- en: Properties are tied to the object instance in the constructor function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性与构造函数中的对象实例绑定在一起
- en: 'This example brings us to the use of the `this` keyword. It is easy to get
    confused by the `this` keyword because it behaves differently in JavaScript. In
    other OO languages such as Java, the `this` keyword refers to the current instance
    of the class. In JavaScript, the value of `this` is determined by the invocation
    context of a function and where it is called. Let''s see how this behavior needs
    to be carefully understood:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子引出了`this`关键字的使用。`this`关键字很容易让人困惑，因为它在JavaScript中的行为不同。在其他面向对象的语言中，比如Java，`this`关键字指的是类的当前实例。在JavaScript中，`this`的值由函数的调用上下文和调用位置决定。让我们看看这种行为需要仔细理解：
- en: 'When `this` is used in a global context: When `this` is called in a global
    context, it is bound to the global context. For example, in the case of a browser,
    the global context is usually `window`. This is true for functions also. If you
    use `this` in a function that is defined in the global context, it is still bound
    to the global context because the function is part of the global context:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`this`在全局上下文中使用时：当在全局上下文中调用`this`时，它绑定到全局上下文。例如，在浏览器的情况下，全局上下文通常是`window`。对于函数也是如此。如果你在全局上下文中定义的函数中使用`this`，它仍然绑定到全局上下文，因为函数是全局上下文的一部分：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When `this` is used in an object method: In this case, `this` is assigned or
    bound to the enclosing object. Note that the enclosing object is the immediate
    parent if you are nesting the objects:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`this`在对象方法中使用时：在这种情况下，`this`被分配或绑定到封闭对象。请注意，如果您嵌套对象，则封闭对象是直接父对象：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When there is no context: A function, when invoked without any object, does
    not get any context. By default, it is bound to the global context. When you use
    `this` in such a function, it is also bound to the global context.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有上下文时：函数在没有任何对象的情况下被调用时，不会得到任何上下文。默认情况下，它绑定到全局上下文。当你在这样的函数中使用`this`时，它也绑定到全局上下文。
- en: 'When `this` is used in a constructor function: As we saw earlier, when a function
    is called with a `new` keyword, it acts as a constructor. In the case of a constructor,
    `this` points to the object being constructed. In the following example, `f()`
    is used as a constructor (because it''s invoked with a `new` keyword) and hence,
    `this` is pointing to the new object being created. So when we say `this.member
    = "f"`, the new member is added to the object being created, in this case, that
    object happens to be `o`:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`this`在构造函数中使用时：正如我们之前所看到的，当一个函数使用`new`关键字调用时，它充当构造函数。在构造函数的情况下，`this`指向正在构造的对象。在下面的例子中，`f()`被用作构造函数（因为它是用`new`关键字调用的），因此`this`指向正在创建的新对象。因此，当我们说`this.member
    = "f"`时，新成员被添加到正在创建的对象中，在这种情况下，该对象恰好是`o`：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We saw that instance properties take precedence when the same property is defined
    both as an instance property and prototype property. It is easy to visualize that
    when a new object is created, the properties of the constructor''s prototype are
    copied over. However, this is not a correct assumption. What actually happens
    is that the prototype is attached to the object and referred when any property
    of this object is referred. Essentially, when a property is referenced on an object,
    either of the following occur:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到当实例属性和原型属性都定义了相同的属性时，实例属性优先。很容易想象，当创建一个新对象时，构造函数的原型属性会被复制过来。然而，这是一个不正确的假设。实际发生的是原型附加到对象上，并在引用该对象的任何属性时引用。基本上，当在对象上引用属性时，以下情况之一发生：
- en: The object is checked for the existence of the property. If it's found, the
    property is returned.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否存在该属性。如果找到，返回该属性。
- en: The associated prototype is checked. If the property is found, it is returned;
    otherwise, an `undefined` error is returned.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联的原型被检查。如果找到属性，则返回；否则，返回`undefined`错误。
- en: 'This is an important understanding because, in JavaScript, the following code
    actually works perfectly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的理解，因为在JavaScript中，以下代码实际上可以完美地工作：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code is a slight variation of the earlier example. We are creating the
    object first and then attaching the function to its prototype. When you eventually
    call the `isAvailable()` method on the object, JavaScript goes to its prototype
    to search for it if it's not found in the particular object (`crazyBob`, in this
    case). Think of this as *hot code loading*—when used properly, this ability can
    give you incredible power to extend the basic object framework even after the
    object is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是前面例子的一个小变化。我们首先创建对象，然后将函数附加到它的原型上。当您最终在对象上调用`isAvailable()`方法时，如果在特定对象（在本例中为`crazyBob`）中找不到它，JavaScript会去它的原型中搜索。把这看作是*热代码加载*——当正确使用时，这种能力可以在对象创建后甚至扩展基本对象框架时给您无比的力量。
- en: 'If you are familiar with OOP already, you must be wondering whether we can
    control the visibility and access of the members of an object. As we discussed
    earlier, JavaScript does not have classes. In programming languages such as Java,
    you have access modifiers such as `private` and `public` that let you control
    the visibility of the class members. In JavaScript, we can achieve something similar
    using the function scope as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉面向对象编程，您一定会想知道我们是否可以控制对象成员的可见性和访问。正如我们之前讨论的，JavaScript没有类。在诸如Java之类的编程语言中，您可以使用`private`和`public`等访问修饰符来控制类成员的可见性。在JavaScript中，我们可以使用函数作用域来实现类似的功能，如下所示：
- en: You can declare private variables using the `var` keyword in a function. They
    can be accessed by private functions or privileged methods.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用函数中的`var`关键字声明私有变量。它们可以被私有函数或特权方法访问。
- en: Private functions may be declared in an object's constructor and can be called
    by privileged methods.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数可以在对象的构造函数中声明，并可以被特权方法调用。
- en: Privileged methods can be declared with `this.method=function() {}`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权方法可以使用`this.method=function() {}`声明。
- en: Public methods are declared with `Class.prototype.method=function(){}`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共方法使用`Class.prototype.method=function(){}`声明。
- en: Public properties can be declared with `this.property` and accessed from outside
    the object.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共属性可以用`this.property`声明，并且可以从对象外部访问。
- en: 'The following example shows several ways of doing this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了几种实现这一点的方法：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s understand a few important concepts from this example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个例子中理解一些重要的概念：
- en: The `retirementAge` variable is a private variable that has no privileged method
    to get or set its value.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retirementAge`变量是一个私有变量，没有特权方法来获取或设置它的值。'
- en: The `country` variable is a private variable created as a constructor argument.
    Constructor arguments are available as private variables to the object.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country`变量是一个作为构造函数参数创建的私有变量。构造函数参数作为对象的私有变量可用。'
- en: When we called `cricketer.switchHands()`, it was only applied to the `cricketer`
    and not to both the players, although it's a prototype function of the `Player`
    itself.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用`cricketer.switchHands()`时，它只应用于`cricketer`，而不是两个玩家，尽管它是`Player`的原型函数。
- en: Private functions and privileged methods are instantiated with each new object
    created. In our example, new copies of `isAvailable()` and `book()` would be created
    for each new player instance that we create. On the other hand, only one copy
    of public methods is created and shared between all instances. This can mean a
    bit of performance gain. If you don't *really* need to make something private,
    think about keeping it public.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数和特权方法在每个新创建的对象中实例化。在我们的例子中，我们为每个新的玩家实例创建`isAvailable()`和`book()`的新副本。另一方面，公共方法只创建并在所有实例之间共享一个副本。这可能意味着一点性能上的提升。如果你不*真的*需要将某些东西私有化，考虑保持它公共。
- en: Inheritance
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is an important concept of OOP. It is common to have a bunch of
    objects implementing the same methods. It is also common to have an almost similar
    object definition with differences in a few methods. Inheritance is very useful
    in promoting code reuse. We can look at the following classic example of inheritance
    relation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的一个重要概念。通常有一堆对象实现相同的方法。几乎相似的对象定义中有一些方法的差异也很常见。继承在促进代码重用方面非常有用。我们可以看以下经典的继承关系示例：
- en: '![Inheritance](img/00007.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00007.jpeg)'
- en: Here, you can see that from the generic **Animal** class, we derive more specific
    classes such as **Mammal** and **Bird** based on specific characteristics. Both
    the Mammal and Bird classes do have the same template of an Animal; however, they
    also define behaviors and attributes specific to them. Eventually, we derive a
    very specific mammal, **Dog**. A Dog has common attributes and behaviors from
    an Animal class and Mammal class, while it adds specific attributes and behaviors
    of a Dog. This can go on to add complex inheritance relationships.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到从通用的 **Animal** 类派生出更具体的类，比如基于特定特征的 **Mammal** 和 **Bird**。Mammal 和
    Bird 类都有 Animal 的相同模板；然而，它们也定义了特定于它们自己的行为和属性。最终，我们派生出一个非常具体的哺乳动物，**Dog**。一只狗具有来自
    Animal 类和 Mammal 类的共同属性和行为，同时它还添加了狗的特定属性和行为。这可以继续添加复杂的继承关系。
- en: Traditionally, inheritance is used to establish or describe an **IS-A** relationship.
    For example, a dog IS-A mammal. This is what we know as **classical inheritance**.
    You would have seen such relationships in object-oriented languages such as C++
    and Java. JavaScript has a completely different mechanism to handle inheritance.
    JavaScript is classless language and uses prototypes for inheritance. Prototypal
    inheritance is very different in nature and needs thorough understanding. Classical
    and prototypal inheritance are very different in nature and need careful study.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，继承用于建立或描述 **IS-A** 关系。例如，一只狗 IS-A 哺乳动物。这就是我们所知的 **经典继承**。你可能在 C++ 和 Java
    等面向对象语言中看到这样的关系。JavaScript 有一个完全不同的机制来处理继承。JavaScript 是无类语言，使用原型进行继承。原型继承在本质上非常不同，需要深入理解。经典继承和原型继承在本质上非常不同，需要仔细研究。
- en: In classical inheritance, instances inherit from a class blueprint and create
    subclass relationships. You can't invoke instance methods on a class definition
    itself. You need to create an instance and then invoke methods on this instance.
    In prototypal inheritance, on the other hand, instances inherit from other instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典继承中，实例从类蓝图继承并创建子类关系。你不能在类定义本身上调用实例方法。你需要创建一个实例，然后在这个实例上调用方法。另一方面，在原型继承中，实例从其他实例继承。
- en: As far as inheritance is concerned, JavaScript uses only objects. As we discussed
    earlier, each object has a link to another object called its prototype. This prototype
    object, in turn, has a prototype of its own, and so on until an object is reached
    with `null` as its prototype; `null`, by definition, has no prototype, and acts
    as the final link in this prototype chain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就继承而言，JavaScript 只使用对象。正如我们之前讨论的那样，每个对象都有一个指向另一个对象的链接，称为它的原型。这个原型对象又有自己的原型，依此类推，直到找到一个以
    `null` 作为原型的对象；根据定义，`null` 没有原型，并且充当原型链中的最终链接。
- en: 'To understand prototype chains better, let''s consider the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解原型链，让我们考虑以下例子：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we define a `Person` and then `Child`—a child IS-A person. We also copy
    the `cry` property of a `Person` to the `cry` property of `Child`. When we try
    to see this relationship using `instanceof`, we soon realize that just by copying
    a behavior, we could not really make `Child` an instance of `Person`; `aChild
    instanceof Person` fails. This is just copying or masquerading, not inheritance.
    Even if we copy all the properties of `Person` to `Child`, we won''t be inheriting
    from `Person`. This is usually a bad idea and is shown here only for illustrative
    purposes. We want to derive a prototype chain—an IS-A relationship, a real inheritance
    where we can say that child IS-A person. We want to create a chain: a child IS-A
    person IS-A mammal IS-A animal IS-A object. In JavaScript, this is done using
    an instance of an object as a prototype as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个 `Person`，然后是 `Child`——一个 child IS-A person。我们还将 `Person` 的 `cry`
    属性复制到 `Child` 的 `cry` 属性。当我们尝试使用 `instanceof` 查看这种关系时，我们很快意识到，仅仅通过复制一个行为，我们无法真正使
    `Child` 成为 `Person` 的一个实例；`aChild instanceof Person` 失败。这只是复制或伪装，并非继承。即使我们将 `Person`
    的所有属性复制到 `Child`，我们也不会从 `Person` 继承。这通常是一个坏主意，这里只是为了说明目的而展示。我们想要派生一个原型链——一个 IS-A
    关系，一个真正的继承，我们可以说 child IS-A person。我们想要创建一个链：一个 child IS-A person IS-A mammal
    IS-A animal IS-A object。在 JavaScript 中，这是通过使用对象的一个实例作为原型来完成的，如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s modify the earlier example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的例子：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The changed line uses an instance of `Person` as the prototype of `Child`. This
    is an important distinction from the earlier method. Here we are declaring that
    child IS-A person.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的行使用 `Person` 的一个实例作为 `Child` 的原型。这与之前的方法有重要区别。在这里，我们声明 child IS-A person。
- en: 'We discussed about how JavaScript looks for a property up the prototype chain
    till it reaches `Object.prototype`. Let''s discuss the concept of prototype chains
    in detail and try to design the following employee hierarchy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了 JavaScript 如何沿着原型链查找属性，直到达到 `Object.prototype`。让我们详细讨论原型链的概念，并尝试设计以下员工层次结构：
- en: '![Inheritance](img/00008.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Inheritance](img/00008.jpeg)'
- en: This is a typical pattern of inheritance. A manager IS-A(n) employee. **Manager**
    has common properties inherited from an **Employee**. It can have an array of
    reportees. An **Individual Contributor** is also based on an employee but he does
    not have any reportees. A **Team Lead** is derived from a Manager with a few functions
    that are different from a Manager. What we are doing essentially is that each
    child is deriving properties from its parent (Manager being the parent and Team
    Lead being the child).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的继承模式。一个 manager IS-A(n) employee。**Manager** 从 **Employee** 继承共同属性。它可以有一个报告人数组。**Individual
    Contributor** 也是基于一个 employee，但他没有任何报告人。**Team Lead** 是从 Manager 派生出来的，具有一些与 Manager
    不同的函数。我们所做的本质上是，每个子类都从其父类派生属性（Manager 是父类，Team Lead 是子类）。
- en: 'Let''s see how we can create this hierarchy in JavaScript. Let''s define our
    `Employee` type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 JavaScript 中创建这种层次结构。让我们定义我们的 `Employee` 类型：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is nothing special about these definitions. The `Employee` object contains
    three properties—name, salary, and department. Next, we define `Manager`. This
    definition shows you how to specify the next object in the inheritance chain:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义没有什么特别之处。`Employee`对象包含三个属性——name、salary和department。接下来，我们定义`Manager`。这个定义向你展示了如何指定继承链中的下一个对象：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In JavaScript, you can add a prototypical instance as the value of the prototype
    property of the constructor function. You can do so at any time after you define
    the constructor. In this example, there are two ideas that we have not explored
    earlier. First, we are calling `Employee.call(this)`. If you come from a Java
    background, this is analogous to the `super()` method call in the constructor.
    The `call()` method calls a function with a specific object as its context (in
    this case, it is the given the `this` value), in other words, call allows to specify
    which object will be referenced by the `this` keyword when the function will be
    executed. Like `super()` in Java, calling `parentObject.call(this)` is necessary
    to correctly initialize the object being created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以将一个原型实例添加为构造函数的prototype属性的值。你可以在定义构造函数之后的任何时候这样做。在这个例子中，有两个我们之前没有探讨过的想法。首先，我们调用了`Employee.call(this)`。如果你来自Java背景，这类似于构造函数中的`super()`方法调用。`call()`方法调用一个具有特定对象作为上下文的函数（在这种情况下，给定了`this`的值），换句话说，call允许指定在执行函数时`this`关键字将引用哪个对象。像Java中的`super()`一样，调用`parentObject.call(this)`是必要的，以正确初始化正在创建的对象。
- en: The other thing we see is `Object.create()` instead of calling `new`. `Object.create()`
    creates an object with a specified prototype. When we do `new Parent()`, the constructor
    logic of the parent is called. In most cases, what we want is for `Child.prototype`
    to be an object that is linked via its prototype to `Parent.prototype`. If the
    parent constructor contains additional logic specific to the parent, we don't
    want to run this while creating the child object. This can cause very difficult-to-find
    bugs. `Object.create()` creates the same prototypal link between the child and
    parent as the `new` operator without calling the parent constructor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一件事是使用`Object.create()`而不是调用`new`。`Object.create()`创建一个具有指定原型的对象。当我们使用`new
    Parent()`时，父类的构造逻辑被调用。在大多数情况下，我们希望`Child.prototype`是一个通过其原型链接到`Parent.prototype`的对象。如果父构造函数包含特定于父类的附加逻辑，我们不希望在创建子对象时运行这些逻辑。这可能导致非常难以找到的错误。`Object.create()`创建了与`new`操作符相同的子类和父类之间的原型链接，而不调用父类构造函数。
- en: 'To have a side effect-free and accurate inheritance mechanism, we have to make
    sure that we perform the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现无副作用和准确的继承机制，我们必须确保执行以下操作：
- en: Setting the prototype to an instance of the parent initializes the prototype
    chain (inheritance); this is done only once (as the prototype object is shared)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原型设置为父类的一个实例初始化原型链（继承）；这只会执行一次（因为原型对象是共享的）
- en: Calling the parent's constructor initializes the object itself; this is done
    with every instantiation (you can pass different parameters each time you construct
    it)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用父类的构造函数初始化对象本身；这是在每次实例化时都会做的（你可以每次构造时传递不同的参数）
- en: 'With this understanding in place, let''s define the rest of the objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，让我们定义其余的对象：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Based on this hierarchy, we can instantiate these objects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个层次结构，我们可以实例化这些对象：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see the following output for the preceding code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到前面代码片段的输出：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A generic `Employee` has a department assigned to `None` (as specified in the
    default value) and the rest of the properties are also assigned as the default
    ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的`Employee`有一个分配给`None`的部门（如默认值中指定的），其余的属性也被分配为默认值。
- en: 'Next, we instantiate a manager; we can provide specific values as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化一个经理；我们可以提供特定的值如下：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For `TeamLead`, the `reports` property is derived from the base class (Manager
    in this case):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TeamLead`，`reports`属性是从基类（在这种情况下是Manager）派生的：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When JavaScript processes the new operator, it creates a new object and passes
    this object as the value of `this` to the parent—the `TeamLead` constructor. The
    constructor function sets the value of the `projects` property and implicitly
    sets the value of the internal `__proto__` property to the value of `TeamLead.prototype`.
    The `__proto__` property determines the prototype chain used to return property
    values. This process does not set values for properties inherited from the prototype
    chain in the `jason` object. When the value of a property is read, JavaScript
    first checks to see whether the value exists in that object. If the value does
    exist, this value is returned. If the value is not there, JavaScript checks the
    prototype chain using the `__proto__` property. Having said this, what happens
    when you do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript处理new操作符时，它会创建一个新对象，并将这个对象作为`this`的值传递给父级——`TeamLead`构造函数。构造函数设置`projects`属性的值，并隐式地将内部的`__proto__`属性的值设置为`TeamLead.prototype`的值。`__proto__`属性确定用于返回属性值的原型链。这个过程不会为`jason`对象中从原型链继承的属性设置值。当读取属性的值时，JavaScript首先检查该对象中是否存在该值。如果存在该值，则返回该值。如果该值不存在，JavaScript使用`__proto__`属性检查原型链。说到这里，当你做以下操作时会发生什么：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It does not propagate to all the instances of `Employee`. This is because when
    you create an instance of the `Employee` object, this instance gets a local value
    for the name. When you set the `TeamLead` prototype by creating a new `Employee`
    object, `TeamLead.prototype` has a local value for the `name` property. Therefore,
    when JavaScript looks up the `name` property of the `jason` object, which is an
    instance of `TeamLead`), it finds the local value for this property in `TeamLead.prototype`.
    It does not try to do further lookups up the chain to `Employee.prototype`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会传播到所有`Employee`的实例。这是因为当你创建`Employee`对象的一个实例时，这个实例会得到`name`的本地值。当你通过创建一个新的`Employee`对象来设置`TeamLead`原型时，`TeamLead.prototype`会有`name`属性的本地值。因此，当JavaScript查找`jason`对象（`TeamLead`的一个实例）的`name`属性时，它会在`TeamLead.prototype`中找到这个属性的本地值。它不会进一步查找`Employee.prototype`。
- en: 'If you want the value of a property changed at runtime and have the new value
    be inherited by all the descendants of the object, you cannot define the property
    in the object''s constructor function. To achieve this, you need to add it to
    the constructor''s prototype. For example, let''s revisit the earlier example
    but with a slight change:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在运行时改变属性的值，并且希望新值被对象的所有后代继承，你不能在对象的构造函数中定义属性。为了实现这一点，你需要将它添加到构造函数的原型中。例如，让我们重新访问之前的例子，但稍作修改：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Though this is a very powerful technique, care should be taken not to overuse
    it. Refer to [http://perfectionkills.com/extending-native-builtins/](http://perfectionkills.com/extending-native-builtins/)
    to understand the pitfalls of extending native built-ins and what care should
    be taken if you intend to do so.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一种非常强大的技术，但应该注意不要过度使用它。参考[http://perfectionkills.com/extending-native-builtins/](http://perfectionkills.com/extending-native-builtins/)了解扩展原生内置的潜在问题，以及如果你打算这样做应该注意什么。
- en: Getters and setters
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: '**Getters** are convenient methods to get the value of specific properties;
    as the name suggests, **setters** are methods that set the value of a property.
    Often, you may want to derive a value based on some other values. Traditionally,
    getters and setters used to be functions such as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Getters**是获取特定属性值的便利方法；正如其名称所示，**setters**是设置属性值的方法。通常，你可能想根据其他值派生一个值。传统上，getter和setter通常是以下这样的函数：'
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, `setLastName()`, `setFirstName()`, and `getFullName()` are functions
    used to do *get* and *set* of properties. `Fullname` is a derived property by
    concatenating the `firstname` and `lastname` properties. This is a very common
    use case and ECMAScript 5 now provides you with a default syntax for getters and
    setters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`setLastName()`、`setFirstName()`和`getFullName()`是用于*获取*和*设置*属性的函数。`Fullname`是通过连接`firstname`和`lastname`属性派生出来的属性。这是一个非常常见的用例，ECMAScript
    5现在为getter和setter提供了默认语法。
- en: 'The following example shows you how getters and setters are created using the
    object literal syntax in ECMAScript 5:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在ECMAScript 5中使用对象字面量语法创建getter和setter：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another way of declaring getters and setters is using the `Object.defineProperty()`
    method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明getter和setter的方法是使用`Object.defineProperty()`方法：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this method, you can call `Object.defineProperty()` even after the object
    is created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，你可以在对象创建后调用`Object.defineProperty()`。
- en: 'Now that you have tasted the object-oriented flavor of JavaScript, we will
    go through a bunch of very useful utility methods provided by **Underscore.js**.
    We discussed the installation and basic usage of Underscore.js in the previous
    chapter. These methods will make common operations on objects very easy:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经尝试了JavaScript的面向对象的味道，我们将介绍**Underscore.js**提供的一系列非常有用的实用方法。我们在上一章中讨论了Underscore.js的安装和基本用法。这些方法将使对象上的常见操作变得非常容易：
- en: '`keys()`: This method retrieves the names of an object''s own enumerable properties.
    Note that this function does not traverse up the prototype chain:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()`: 这个方法检索对象自身可枚举属性的名称。请注意，这个函数不会遍历原型链：'
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`allKeys()`: This method retrieves the names of an object''s own and inherited
    properties:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allKeys()`: 这个方法检索对象自身和继承的属性的名称：'
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`values()`: This method retrieves the values of an object''s own properties:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()`: 这个方法检索对象自身属性的值：'
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`mapObject()`: This method transforms the value of each property in the object:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapObject()`: 这个方法转换对象中每个属性的值：'
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`functions()`: This returns a sorted list of the names of every method in an
    object—the name of every function property of the object.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions()`: 这个方法返回对象中每个方法的名称的排序列表——对象的每个函数属性的名称。'
- en: '`pick()`: This function returns a copy of the object, filtered to just the
    values of the keys provided:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick()`: 这个函数返回对象的副本，只过滤提供的键的值：'
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`omit()`: This function is an invert of `pick()`—it returns a copy of the object,
    filtered to omit the values for the specified keys.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`omit()`: 这个函数是`pick()`的反向操作——它返回对象的副本，过滤掉指定键的值。'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript applications can improve in clarity and quality by allowing for the
    greater degree of control and structure that object-orientation can bring to the
    code. JavaScript object-orientation is based on the function prototypes and prototypal
    inheritance. These two ideas can provide an incredible amount of wealth to developers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许对象导向给代码带来更大程度的控制和结构，JavaScript应用程序可以在清晰度和质量上得到改善。JavaScript的对象导向是基于函数原型和原型继承的。这两个概念可以为开发人员提供难以置信的丰富性。
- en: In this chapter, we saw basic object creation and manipulation. We looked at
    how constructor functions are used to create objects. We dived into prototype
    chains and how inheritance operates on the idea of prototype chains. These foundations
    will be used to build your knowledge of JavaScript patterns that we will explore
    in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了基本的对象创建和操作。我们看了构造函数如何用来创建对象。我们深入研究了原型链以及继承是如何在原型链的概念上操作的。这些基础将被用来构建你对JavaScript模式的知识，我们将在下一章中探讨。

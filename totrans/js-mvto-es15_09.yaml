- en: Chapter 8. DOM Manipulation and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important reason for JavaScript's existence is the web. JavaScript
    is the language for the web and the browser is the raison d'être for JavaScript.
    JavaScript gives dynamism to otherwise static web pages. In this chapter, we will
    dive deep into this relationship between the browser and language. We will understand
    the way in which JavaScript interacts with the components of the web page. We
    will look at the **Document Object Model** (**DOM**) and JavaScript event model.
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at various aspects of JavaScript with regard to
    the browser and HTML. HTML, as I am sure you are aware, is the markup language
    used to define web pages. Various forms of markups exist for different uses. The
    popular marks are **Extensible Markup Language** (**XML**) and **Standard Generalized
    Markup Language** (**SGML**). Apart from these generic markup languages, there
    are very specific markup languages for specific purposes such as text processing
    and image meta information. **HyperText Markup Language** (**HTML**) is the standard
    markup language that defines the presentation semantics of a web page. A web page
    is essentially a document. The DOM provides you with a representation of this
    document. The DOM also provides you with a means of storing and manipulating this
    document. The DOM is the programming interface of HTML and allows structural manipulation
    using scripting languages such as JavaScript. The DOM provides a structural representation
    of the document. The structure consists of nodes and objects. Nodes have properties
    and methods on which you can operate in order to manipulate the nodes themselves.
    The DOM is just a representation and not a programming construct. DOM acts as
    a model for DOM processing languages such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DOM elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, you will be interested in accessing DOM elements to inspect
    their values or processing these values for some business logic. We will take
    a detailed look at this particular use case. Let''s create a sample HTML file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can save this file as `sample_dom.html`; when you open this in the Google
    Chrome browser, you will see the web page displayed with the **Hello World** text
    displayed. Now, open Google Chrome Developer Tools by navigating to options |
    **More Tools** | **Developer Tools** (this route may differ on your operating
    system and browser version). In the **Developer Tools** window, you will see the
    DOM structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing DOM elements](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will insert some JavaScript into this HTML page. We will invoke the
    JavaScript function when the web page is loaded. To do this, we will call a function
    on `window.onload`. You can place your script in the `<script>` tag located under
    the `<head>` tag. Your page should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous function is executed when the browser loads the page. In the function,
    we are getting the nodes of the DOM programmatically. The entire HTML document
    can be accessed using the `document.documentElement` function. We store the document
    in a variable. Once the document is accessed, we can traverse the nodes using
    several helper properties of the document. We are accessing the `<body>` element
    using `doc.body`. You can traverse through the children of an element using the
    `childNodes` array. The first and last children of a node can be accessed using
    additional properties—`firstChild` and `lastChild`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not recommended to use render-blocking JavaScript in the `<head>` tag.
    This slows down the page render dramatically. Modern browsers support the `async`
    and `defer` attributes to indicate to the browsers that the rendering can go on
    while the script is being downloaded. You can use these tags in the `<head>` tag
    without worrying about performance degradation. You can get more information at
    [http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup](http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing specific nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core DOM defines the `getElementsByTagName()` method to return `NodeList`
    of all the element objects whose `tagName` property is equal to a specific value.
    The following line of code returns a list of all the `<p/>` elements in a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML DOM defines `getElementsByName()` to retrieve all the elements that
    have their name attribute set to a specific value. Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are creating a group of radio buttons with the `name` attribute
    defined as `feeling`. In the `showFeelings` function, we get all the elements
    with the `name` attribute set to `feeling` and we iterate through all these elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method defined by the HTML DOM is `getElementById()`. This is a very
    useful method in accessing a specific element. This method does the lookup based
    on the `id` associated with an element. The `id` attribute is unique for every
    element and, hence, this kind of lookup is very fast and should be preferred over
    `getElementsByName()`. -However, you should be aware that the browser does not
    guarantee the uniqueness of the `id` attribute. In the following example, we are
    accessing a specific element using the ID. Element IDs are unique as opposed to
    tags or name attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What we discussed so far was the basics of DOM traversal in JavaScript. When
    the DOM gets complex and you want sophisticated operations on the DOM, these traversal
    and access functions seem limiting. With this basic knowledge with us, it's time
    to get introduced to a fantastic library for DOM traversal (among other things)
    called jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery is a lightweight library designed to make common browser operations easier.
    Common operations such as DOM traversal and manipulation, event handling, animation,
    and Ajax can be tedious if done using pure JavaScript. jQuery provides you with
    easy-to-use and shorter helper mechanisms to help you develop these common operations
    very easily and quickly. jQuery is a feature-rich library, but as far as this
    chapter goes, we will focus primarily on DOM manipulation and events.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add jQuery to your HTML by adding the script directly from a **content
    delivery network** (**CDN**) or manually downloading the file and adding it to
    the script tag. The following example shows you how to download jQuery from Google''s
    CDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of a CDN download is that Google''s CDN automatically finds the
    nearest download server for you and keeps an updated stable copy of the jQuery
    library. If you wish to download and manually host jQuery along with your website,
    you can add the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the jQuery library is manually downloaded in the `lib` directory.
    With the jQuery setup in the HTML page, let''s explore the methods of manipulating
    the DOM elements. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding jQuery to the HTML page, we write the custom JavaScript that selects
    the element with a `greeting` ID and changes its value. The strange-looking code
    within `$()` is the jQuery in action. If you read the jQuery source code (and
    you should, it''s brilliant) you will see the final line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `$` is just a function. It is an alias for the function called jQuery. The
    `$` is a syntactic sugar that makes the code concise. In fact, you can use both
    `$` and `jQuery` interchangeably. For example, both `$('#greeting').html('Hello
    World Martian');` and `jQuery('#greeting').html('Hello World Martian');` are the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t use jQuery before the page is completely loaded. As jQuery will
    need to know all the nodes of the DOM structure, the entire DOM has to be in-memory.
    To ensure that the page is completely loaded and in a state where it''s ready
    to be manipulated, we can use the `$(document).ready()` function. Here, the IIFE
    is executed only after the entire documented is *ready*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very common thing to do when using jQuery—so much so that it has
    its own shortcut. You can replace the entire `ready()` call with a short `$()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important function in jQuery is `$()`. This function typically accepts
    a CSS selector as its sole parameter and returns a new jQuery object pointing
    to the corresponding elements on the page. The three primary selectors are the
    tag name, ID, and class. They can be used either on their own or in combination
    with others. The following simple examples illustrate how these three selectors
    appear in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Selector** | CSS Selector | jQuery Selector | Output from the selector
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Tag** | `p{}` | `$(''p'')` | This selects all the `p` tags from the document.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Id** | `#div_1` | `$(''#div_1'')` | This selects single elements that have
    a `div_1` ID. The symbol used to identify the ID is `#`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Class** | `.bold_fonts` | `$(''.bold_fonts'')` | This selects all the elements
    in the document that have the CSS class `bold_fonts`. The symbol used to identify
    the class match is "`.`". |'
  prefs: []
  type: TYPE_TB
- en: jQuery works on CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As CSS selectors are not in the scope of this module, I would suggest that you
    go to [http://www.w3.org/TR/CSS2/selector.html](http://www.w3.org/TR/CSS2/selector.html)
    to get a fair idea of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also assume that you are familiar with HTML tags and syntax. The following
    example covers the fundamental idea of how jQuery selectors work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are selecting several DOM elements in the HTML page using
    selectors. We have an H1 header with the text, `Are we there yet ?`; when the
    page loads, our jQuery script accesses all H1 headers and appends the text `Finally?`
    to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `$.html()` function sets the HTML for the target element—an H1 header in
    this case. Additionally, we select all H1 headers and apply a specific CSS style
    class, `highlight-blue`, to all of them. The `$('h1').addClass('highlight-blue')`
    statement selects all the H1 headers and uses the `$.addClass(<CSS class>)` method
    to apply a CSS class to all the elements selected using the selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the child combinator (`>`) to custom CSS styles using the `$.css()`
    function. In effect, the selector in the `$()` function is saying, "Find each
    header (`h1`) that is a child (`>`) of the element with an ID of header (`#header`)."
    For each such element, we apply a custom CSS. The next usage is interesting. Consider
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are selecting "For all list elements (`li`) that do not have the class `highlight-blue`
    applied to them, apply CSS class `highlight-green`. The final line—`$(''tr:nth-child(odd)'').addClass(''zebra'')`—can
    be interpreted as: From all table rows (`tr`), for every odd row, apply CSS style
    `zebra`. The *n*th-child selector is a custom selector provided by jQuery. The
    final output looks something similar to the following (Though it shows several
    jQuery selector types, it is very clear that knowledge of jQuery is not a substitute
    for bad design taste.):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing specific nodes](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have made a selection, there are two broad categories of methods that
    you can call on the selected element. These methods are **getters** and **setters**.
    Getters retrieve a piece of information from the selection, and setters alter
    the selection in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Getters usually operate only on the first element in a selection while setters
    operate on all the elements in a selection. Setters use implicit iteration to
    automatically iterate over all the elements in the selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to apply a CSS class to all list items on the page. When
    we call the `addClass` method on the selector, it is automatically applied to
    all elements of this particular selection. This is implicit iteration in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes you just don''t want to go through all the elements via
    implicit iteration. You may want to selectively modify only a few of the elements.
    You can explicitly iterate over the elements using the `.each()` method. In the
    following code, we are processing elements selectively and using the `index` property
    of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chaining jQuery methods allows you to call a series of methods on a selection
    without temporarily storing the intermediate values. This is possible because
    every setter method that we call returns the selection on which it was called.
    This is a very powerful feature and you will see it being used by many professional
    libraries. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Traversal and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed various methods of element selection using jQuery. We will discuss
    several DOM traversal and manipulation methods using jQuery in this section. These
    tasks would be rather tedious to achieve using native DOM manipulation. jQuery
    makes them intuitive and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve into these methods, let''s familiarize ourselves with a bit
    of HTML terminology that we will be using from now on. Consider the following
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using jQuery traversal methods, we select the first element and traverse through
    the DOM in relation to this element. As we traverse the DOM, we alter the original
    selection and we are either replacing the original selection with the new one
    or we are modifying the original selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can filter an existing selection to include only elements
    that match a certain criterion. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'jQuery allows you to add and remove classes to elements. If you want to toggle
    class values for elements, you can use the `toggleClass()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Most often, you may want to alter the value of elements. You can use the `val()`
    method to alter the form of element values. For example, the following line alters
    the value of all the `text` type inputs in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify element attributes, you can use the `attr()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: jQuery has an incredible depth of functionality when it comes to DOM manipulation—the
    scope of this module restricts a detailed discussion of all the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Working with browser events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When are you developing for browsers, you will have to deal with user interactions
    and events associated to them, for example, text typed in the textbox, scrolling
    of the page, mouse button press, and others. When the user does something on the
    page, an event takes place. Some events are not triggered by user interaction,
    for example, `load` event does not require a user input.
  prefs: []
  type: TYPE_NORMAL
- en: When you are dealing with mouse or keyboard events in the browser, you can't
    predict when and in which order these events will occur. You will have to constantly
    look for a key press or mouse move to happen. It's like running an endless background
    loop listening to some key or mouse event to happen. In traditional programming,
    this was known as polling. There were many variations of these where the waiting
    thread used to be optimized using queues; however, polling is still not a great
    idea in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsers provide a much better alternative to polling. Browsers provide you
    with programmatic means to react when an event occurs. These hooks are generally
    called listeners. You can register a listener that reacts to a particular event
    and executes an associated callback function when the event is triggered. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `addEventListener` function registers its second argument as a callback
    function. This callback is executed when the event specified in the first argument
    is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we saw just now was a generic listener for the `click` event. Similarly,
    every DOM element has its own `addEventListener` method, which allows you to listen
    specifically on this element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the reference to a specific element—a button with
    a `Bigbutton` ID—by calling `getElementById()`. On the reference of the button
    element, we are calling `addEventListener()` to assign a handler function for
    the click event. This is perfectly legitimate code that works fine in modern browsers
    such as Mozilla Firefox or Google Chrome. On Internet Explorer prior to IE9, however,
    this is not a valid code. This is because Microsoft implements its own custom
    `attachEvent()` method as opposed to the W3C standard `addEventListener()` prior
    to Internet Explorer 9\. This is very unfortunate because you will have to write
    very bad hacks to handle browser-specific quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we should ask an important question—if an element and one of
    its ancestors have a handler on the same event, which handler will be fired first?
    Consider the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Propagation](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For example, we have **Element2** as a child of **Element1** and both have the
    `onClick` handler. When a user clicks on Element2, `onClick` on both Element2
    and Element1 is triggered but the question is which one is triggered first. What
    should the event order be? Well, the answer, unfortunately, is that it depends
    entirely on the browser. When browsers first arrived, two opinions emerged, naturally,
    from Netscape and Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Netscape decided that the first event triggered should be Element1's `onClick`.
    This event ordering is known as event capturing.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft decided that the first event triggered should be Element2's `onClick`.
    This event ordering is known as event bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: These are two completely opposite views and implementations of how browsers
    handled events. To end this madness, **World Wide Web Consortium** (**W3C**) decided
    a wise middle path. In this model, an event is first captured until it reaches
    the target element and then bubbles up again. In this standard behavior, you can
    choose in which phase you want to register your event handler—either in the capturing
    or bubbling phase. If the last argument is true in `addEventListener()`, the event
    handler is set for the capturing phase, if it is false, the event handler is set
    for the bubbling phase.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you don't want the event to be raised by the parents if
    it was already raised by the child. You can call the `stopPropagation()` method
    on the event object to prevent handlers further up from receiving the event. Several
    events have a default action associated with them. For example, if you click on
    a URL link, you will be taken to the link's target. The JavaScript event handlers
    are called before the default behavior is performed. You can call the `preventDefault()`
    method on the event object to stop the default behavior from being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: These are event basics when you are using plain JavaScript on a browser. There
    is a problem here. Browsers are notorious when it comes to defining event-handling
    behavior. We will look at jQuery's event handling. To make things easier to manage,
    jQuery always registers event handlers for the bubbling phase of the model. This
    means that the most specific elements will get the first opportunity to respond
    to any event.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery event handling and propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jQuery event handling takes care of many of these browser quirks. You can focus
    on writing code that runs on most supported browsers. jQuery''s support for browser
    events is simple and intuitive. For example, this code listens for a user to click
    on any button element on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `click()` method, there are several other helper methods to cover
    almost all kinds of browser event. The following helpers exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`change`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dblclick`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`focus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keydown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keypress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mousedown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mousemove`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseover`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouseup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scroll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use the `.on()` method. There are a few advantages of
    using the `on()` method as it gives you a lot more flexibility. The `on()` method
    allows you to bind a handler to multiple events. Using the `on()` method, you
    can work on custom events as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event name is passed as the first parameter to the `on()` method just like
    the other methods that we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve registered an event handler to an element, you can trigger this
    event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This event can also be triggered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can unbind an event using jQuery''s `.off()` method. This will remove any
    event handlers that were bound to the specified event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add more than one handler to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the event is fired, both the handlers will be invoked. If you want to
    remove only the first handler, you can use the `off()` method with the second
    parameter indicating the handler that you want to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possible if you have the reference to the handler. If you are using
    anonymous functions as handlers, you can''t get reference to them. In this case,
    you can use namespaced events. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a namespaced event handler registered with the element, you
    can remove it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A major advantage of using `.on()` is that you can bind to multiple events
    at once. The `.on()` method allows you to pass multiple events in a space-separated
    string. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add multiple event handlers for multiple events as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As of jQuery 1.7, all events are bound via the `on()` method, even if you call
    helper methods such as `click()`. Internally, jQuery maps these calls to the `on()`
    method. Due to this, it's generally recommended to use the `on()` method for consistency
    and faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event delegation allows us to attach a single event listener to a parent element.
    This event will fire for all the descendants matching a selector even if these
    descendants will be created in the future (after the listener was bound to the
    element).
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed *event bubbling* earlier. Event delegation in jQuery works primarily
    due to event bubbling. Whenever an event occurs on a page, the event bubbles up
    from the element that it originated from, up to its parent, then up to the parent''s
    parent, and so on, until it reaches the root element (`window`). Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s say that we want to perform some common action on any of the URL
    clicks. We can add an event handler to all the `a` elements in the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This works perfectly fine, but this code has a minor bug. What will happen
    if there is an additional URL added to the list as a result of some dynamic action?
    Let''s say that we have an **Add** button that adds new URLs to this list. So,
    if the new list item is added with a new URL, the earlier event handler will not
    be attached to it. For example, if the following link is added to the list dynamically,
    clicking on it will not trigger the handler that we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because such events are registered only when the `on()` method is called.
    In this case, as this new element did not exist when `.on()` was called, it does
    not get the event handler. With our understanding of event bubbling, we can visualize
    how the event will travel up the DOM tree. When any of the URLs are clicked on,
    the travel will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a delegated event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We moved `a` from the original selector to the second parameter in the `on()`
    method. This second parameter of the `on()` method tells the handler to listen
    to this specific event and check whether the triggering element was the second
    parameter (the `a` in our case). As the second parameter matches, the handler
    function is executed. With this delegate event, we are attaching a single handler
    to the entire `ul#list`. This handler will listen to the click event triggered
    by any descendent of the `ul` element.
  prefs: []
  type: TYPE_NORMAL
- en: The event object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we attached anonymous functions as event handlers. To make our event
    handlers more generic and useful, we can create named functions and assign them
    to the events. Consider the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are passing a named function instead of an anonymous function to the
    `on()` method. Let''s shift our focus now to the `event` parameter that we pass
    to the function. jQuery passes an event object with all the event callbacks. An
    event object contains very useful information about the event being triggered.
    In cases where we don''t want the default behavior of the element to kick in,
    we can use the `preventDefault()` method of the event object. For example, we
    want to fire an AJAX request instead of a complete form submission or we want
    to prevent the default location to be opened when a URL anchor is clicked on.
    In these cases, you may also want to prevent the event from bubbling up the DOM.
    You can stop the event propagation by calling the `stopPropagation()` method of
    the event object. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the event object, you also get a reference to the DOM object on
    which the event was fired. This element can be referred by `$(this)`. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about understanding JavaScript in its most important role—that
    of browser language. JavaScript plays the role of introducing dynamism on the
    web by facilitating DOM manipulation and event management on the browser. We discussed
    both of these concepts with and without jQuery. As the demands of the modern web
    are increasing, using libraries such as jQuery is essential. These libraries significantly
    improve the code quality and efficiency and, at the same time, give you the freedom
    to focus on important things.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on another incarnation of JavaScript—mainly on the server side.
    Node.js has become a popular JavaScript framework to write scalable server-side
    applications. We will take a detailed look at how we can best utilize Node.js
    for server applications.
  prefs: []
  type: TYPE_NORMAL

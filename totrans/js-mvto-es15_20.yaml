- en: Chapter 7. Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I once read a book that suggested that Newton came up with the idea for calculus
    when he was observing the flow of a river around a reed. I've never been able
    to find any other source which supports that assertion. It is, however, a nice
    picture to hold in your mind. Calculus deals with understanding how the state
    of a system changes over time. Most developers will rarely have to deal with calculus
    in their day to day work. They will, however, have to deal with systems changing.
    After all, having a system which doesn't change at all is pretty boring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years a number of different ideas have arisen in the area
    of treating change as a stream of events – just like the stream that Newton supposedly
    observed. Given a starting position and a stream of events it should be possible
    to figure out the state of the system. Indeed, this is the idea behind using an
    event store. Instead of keeping the final state of an aggregate in a database
    we instead keep track of all the events which have been applied to that aggregate.
    By replaying this series of events we can recreate the current state of the aggregate.
    This seems like a roundabout way of storing the state of an object but it is actually
    very useful for a number of situations. For example, a disconnected system, like
    a cell phone application when the phone isn't connected to the network, which
    uses an event store can be merged with other events much more easily than simply
    keeping the end state. It is also stunningly useful for audit scenarios as it
    is possible to pull the system back to the state it was in at any point in time
    by simply halting the replay at a time index. How frequently have you been asked,
    "why is the system in this state?", and you've been unable to reply? With an event
    store the answer should be easy to ascertain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Application state changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams for multiplexing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state changes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within an application we can think of all the events happening as a similar
    stream of events. The user clicks on a button? Event. The user''s mouse enters
    some region? Event. A clock ticks? Event. In both front and backend applications,
    events are the things which trigger changes in state. You''re likely already using
    events for event listeners. Consider attaching a click handler to a button:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code we have attached a handler to the `click` event. This is fairly
    simple code but think about how rapidly the complexity of this code increases
    when we add conditions like "ignore additional click for 500ms once a click is
    fired to prevent people double-clicking" and "Fire a different event if the *Ctrl*
    key is being held when the button is clicked". Reactive programming or functional
    reactive programming provides a simple solution to these complex interaction scenarios
    through use of streams. Let's explore how your code can benefit from leveraging
    reactive programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to think of an event stream is not to think of the streams
    you''ve probably used before in programming, input reader streams, but to think
    of arrays. Let''s say that you have an array with a series of numbers in it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you want to filter this array to only show you even numbers. In modern
    JavaScript this is easily done through the use of the `filter` function on the
    array:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A graphical representation can be seen here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams](img/00066.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: The filtering function here remains the same should we have ten items in the
    array or ten thousand items in the array. Now, what if the source array had new
    items being appended to it all the time? We would like to keep our dependent array
    up-to-date by inserting any new items which are even, into it. To do this we could
    hook into the `add` function on the array using a pattern-like decorator. Using
    a decorator we could call the filter method and, if a match was found, we would
    add it to the filtered array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Streams are, in effect, an observable on a collection of future events. There
    are a number of interesting problems which can be solved using operations on streams.
    Let''s start with a simple problem: handling clicks. This problem is so simple
    that, on the surface, it doesn''t seem like there is any advantage to using streams.
    Don''t worry we''ll make it more difficult as we go along.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 流实际上是对未来事件集合的可观察。有许多有趣的问题可以通过对流进行操作来解决。让我们从一个简单的问题开始：处理点击。这个问题非常简单，以至于乍看之下似乎没有使用流的优势。别担心，随着我们的深入，我们会让它变得更加困难。
- en: For the most part this module avoids making use of any specific JavaScript libraries.
    The idea is that patterns should be able to be implemented with ease without a
    great deal of ceremony. However, in this case we're actually going to make use
    of a library because streams have a few nuances to their implementation for which
    we'd like some syntactic niceties. If you're looking to see how to implement a
    basic stream, then you can base it on the observer pattern outlined in [Chapter
    5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435 "Chapter 5. Behavioral
    Patterns"), *Behavioral Patterns*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大部分情况下，这个模块避免使用任何特定的JavaScript库。其想法是，模式应该能够在没有太多仪式的情况下轻松实现。然而，在这种情况下，我们实际上要使用一个库，因为流的实现有一些细微之处，我们希望有一些语法上的美感。如果你想看看如何实现一个基本的流，那么你可以基于[第5章](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "第5章 行为模式")中概述的观察者模式来实现它，*行为模式*。
- en: There are a number of stream libraries in JavaScript Reactive.js, Bacon.js,
    and RxJS to name a few. Each one has various advantages and disadvantages but
    the specifics are outside the purview of this module. In this module we'll make
    use of Reactive Extensions for JavaScript, the source code for which can be found
    on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有许多流库，如Reactive.js、Bacon.js和RxJS等。每个库都有各种优缺点，但具体细节超出了本模块的范围。在本模块中，我们将使用JavaScript的Reactive
    Extensions，其源代码可以在GitHub上找到：[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。
- en: 'Let''s start with a brief piece of HTML:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简短的HTML代码开始：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To this, let''s add a quick click counter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个快速的点击计数器：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here you can see we''re creating a new stream of events from the `click` event
    on the button. The newly created stream is commonly referred to as a metastream.
    Whenever an event is emitted from the source stream it is automatically manipulated
    and published, as needed, to the metastream. We subscribe to this stream and increment
    a counter. If we wanted to react to only the even numbered events, we could do
    so by subscribing a second function to the stream:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在从按钮的`click`事件创建一个新的事件流。新创建的流通常被称为元流。每当源流发出一个事件时，它会自动被处理和发布到元流中。我们订阅了这个流并增加了一个计数器。如果我们只想对偶数事件做出反应，我们可以通过订阅第二个函数到流中来实现：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here you can see that we're applying a filter to the stream such that the counter
    is distinct from the function which updates the screen. Keeping a counter outside
    of the streams like this feels dirty, though, doesn't it? Chances are that incrementing
    every other click isn't the goal of this function anyway. It is much more likely
    that we would like to run a function only on double click.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们对流应用了一个过滤器，使得计数器与更新屏幕的函数分离。然而，将计数器放在流之外感觉有些不好，不是吗？很可能，每隔一个点击增加计数并不是这个函数的目标。更有可能的是，我们只想在双击时运行一个函数。
- en: 'This is difficult to do with traditional methods, however these sorts of complex
    interactions are easy to achieve using streams. You can see how we might approach
    the problem in this code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很难用传统的方法做到的，然而这些复杂的交互可以很容易地通过流来实现。你可以看到我们如何在这段代码中解决这个问题：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here we take the click stream and buffer the stream using a debounce to generate
    the boundaries of the buffer. Debouncing is a term from the hardware world which
    means that we clean up a noisy signal into a single event. When a physical button
    is pushed, there are often a couple of additional high or low signals instead
    of the single point signal we would like. In effect we eliminate repeated signals
    which occur within a window. In this case we wait `250`ms before firing an event
    to move to a new buffer. The buffer contains all the events fired during the debouncing
    and passes on a list of them to the next function in the chain. The map function
    generates a new stream with the list length as the contents. Next, we filter the
    stream to show only events with a value of 2 or more, that''s two clicks or more.
    The stream of events look like the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将点击流进行缓冲，并使用防抖动来生成缓冲区的边界。防抖动是硬件世界的一个术语，意思是将嘈杂的信号清理成一个单一的事件。当物理按钮被按下时，通常会有一些额外的高或低信号，而不是我们想要的单一点信号。实际上，我们消除了在一个时间窗口内重复的信号。在这种情况下，我们等待`250`毫秒，然后触发一个事件来移动到一个新的缓冲区。缓冲区包含在防抖期间触发的所有事件，并将它们的列表传递给链中的下一个函数。map函数生成一个以列表长度为内容的新流。接下来，我们过滤流，只显示值为2或更多的事件，也就是两次点击或更多。事件流看起来像下面的图表：
- en: '![Streams](img/00067.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![流](img/00067.jpeg)'
- en: Performing the same logic as this using traditional event listeners and call-backs
    would be quite difficult. One could easily imagine a far more complex workflow
    that would spiral out of control. FRP allows for a more streamlined approach to
    handling events.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的事件监听器和回调执行与此相同逻辑将会非常困难。人们很容易想象出一个更加复杂的工作流程，而这将会失控。FRP允许更加简化的方式来处理事件。
- en: Filtering streams
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤流
- en: As we saw in the preceding section, it is possible to filter a stream of events
    and, from it produce a new stream of events. You might be familiar with being
    able to filter items in an array. ES5 introduced a number of new operators for
    arrays such as **filter** and **some**. The first of these produces a new array
    containing only elements which match the rule in the filter. `Some` is a similar
    function which simply returns `true` if any element of the array matches. These
    same sorts of functions are also supported on streams as well as functions you
    might be familiar with from functional languages such as First and Last. In addition
    to the functions which would make sense for arrays, there are a number of time
    series based functions which make much more sense when you consider that streams
    exist in time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen debounce which is an example of a time based filter. Another
    very simple application of debounce is to prevent the annoying bug of users double-clicking
    a submit button. Consider how much simpler the code for that is using a stream:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might also find it that functions like Sample – which generates a set of
    events from a time window. This is a very handy function when we're dealing with
    observables which may produce a large number of events. Consider an example from
    our example world of Westeros.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Westeros is quite a violent place where people seem to die in
    unpleasant ways. So many people die that we can't possibly keep an eye on each
    one so we'd like to just sample the data and gather a few causes of death.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate this incoming stream, we will start with an array, something like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see we're using an array to simulate a stream of events. This can be
    done with any stream and is a remarkably easy way to perform testing on complex
    code. You can build a stream of events in an array and then publish them with
    appropriate delays giving an accurate representation of anything from a stream
    of events from the filesystem to user interactions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make our array into a stream of events. Fortunately, there are
    some shortcuts for doing that using the `from` method. This will simply return
    a stream which is immediately executed. What we''d like is to pretend we have
    a regularly distributed stream of events or, in our rather morbid case, deaths.
    This can be done by using two methods from RxJS: `interval` and `zip`. `interval`
    creates a stream of events at a regular interval. `zip` matches up pairs of events
    from two streams. Together these two methods will emit a new stream of events
    at a regular interval:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code we zip together the deaths array with an interval stream which
    fires every `500`ms. Because we're not super interested in the interval event
    we simply discard it and project the item from the array onwards.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can sample this stream by simply taking a sample and then subscribing
    to it. Here we''re sampling every `1500`ms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can have as many subscribers to a stream as you like so if you wanted to
    perform some sampling, as well as perhaps some aggregate functions like simply
    counting the events, you could do so by having several subscribers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Merging streams
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen the `zip` function that merges events one-to-one to create
    a new stream but there are numerous other ways of combining streams. A very simple
    example might be a page which has several code paths which all want to perform
    a similar action. Perhaps we have several actions all of which result in a status
    message being updated:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here you can see how the various streams are passed into the merge function
    and the resulting merged stream:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging streams](img/00068.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: While useful, this code doesn't seem to be particularly better than simply calling
    the event handler directly, in fact it is longer than necessary. However, consider
    that there are more sources of status messages than just button pushes. We might
    want to have asynchronous events also write out information. For instance, sending
    a request to the server might also want to add status information. Another fantastic
    application may be with web workers which run in the background and communicate
    with the main thread using messaging. For web based JavaScript applications this
    is how we implement multithreaded applications. Let's see how that would look.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有用，但这段代码似乎并不比直接调用事件处理程序更好，实际上它比必要的还要长。但是，请考虑，状态消息的来源不仅仅是按钮推动。我们可能还希望异步事件也写出信息。例如，向服务器发送请求可能还想添加状态信息。另一个很棒的应用可能是使用在后台运行并使用消息与主线程通信的Web
    Workers。对于基于Web的JavaScript应用程序，这是我们实现多线程应用程序的方法。让我们看看它会是什么样子。
- en: 'First we can create a stream from a worker role. In our example the worker
    simply calculates the fibonacci sequence. We''ve added a fourth button to our
    page and have it trigger the worker process:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以从一个工作角色创建一个流。在我们的示例中，工作人员只是计算斐波那契数列。我们在页面上添加了第四个按钮，并让它触发工作进程：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can subscribe to the merged stream and combine it with all the previous
    streams:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以订阅合并流，并将其与所有先前的流结合起来：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This all looks really nice but we don''t want to clobber the users with dozens
    of notifications at a time. We can throttle the stream of events so that only
    a single toast shows up at a time by using the same interval zip pattern we saw
    earlier. In this code we''ve replaced our `appendToOutput` method with a call
    to a toast display library:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来非常好，但我们不希望一次向用户发送大量通知。我们可以通过使用与之前看到的相同的间隔zip模式来限制事件流，以便一次只显示一个提示。在这段代码中，我们用调用一个提示显示库来替换了我们的“appendToOutput”方法：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see the code for this functionality is short and easy to understand
    yet it contains a great deal of functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个功能的代码很简短，易于理解，但包含了大量的功能。
- en: Streams for multiplexing
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用的流
- en: 'One does not rise to a position of power on the King''s council in Westeros
    without being a master at building networks of spies. Often the best spy is one
    who can respond the quickest. Similarly, we may have some code which has the option
    of calling one of many different services which can fulfill the same task. A great
    example would be a credit card processor: it doesn''t really matter which processor
    we use as they''re pretty much all the same.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛国王的议会上，没有人能够升到权力地位，而不是间谍网络的大师。通常，最好的间谍是那些能够最快做出反应的人。同样，我们可能有一些代码，可以选择调用许多不同的服务来完成相同的任务。一个很好的例子是信用卡处理器：我们使用哪个处理器并不重要，因为它们几乎都是一样的。
- en: To achieve this, we can kick off a number of HTTP requests to each of the services.
    If we take each of the requests and put them into a stream, we can use it to select
    the fastest to respond processor and then perform the rest of the actions using
    that processor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以启动多个HTTP请求到每个服务。如果我们将每个请求放入一个流中，我们可以使用它来选择最快响应的处理器，然后使用该处理器执行其余的操作。
- en: 'With RxJS this looks like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJS，这看起来像下面这样：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You could even include a timeout in the `amb` call which would be called to
    handle the eventuality that none of the processors responded in time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在“amb”调用中包含一个超时，以处理处理器没有及时响应的情况。
- en: Hints and tips
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: There are a large number of different functions that can be applied to streams.
    If you happen to decide on the RxJS library for your FRP needs in JavaScript,
    many of the most common functions have been implemented for you. More complex
    functions can often be written as a chain of the included functions so try to
    think of a way to create the functionality you want by chaining before writing
    your own functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的函数可以应用于流。如果您决定在JavaScript中使用RxJS库进行FRP需求，许多最常见的函数已经为您实现。更复杂的函数通常可以编写为包含函数链，因此在编写自己的函数之前，请尝试想出一种通过链接创建所需功能的方法。
- en: Frequently, asynchronous calls across the network in JavaScript fail. Networks
    are unreliable, mobile networks doubly so. For the most part when the network
    fails, our application fails. Streams provide an easy fix to this by allowing
    you to easily retry failed subscriptions. In RxJS this method is called `Retry`.
    Slotting it into any observable chain makes it more resilient to network failures.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，跨网络的异步调用经常失败。网络不可靠，移动网络尤其如此。大多数情况下，当网络失败时，我们的应用程序也会失败。流通过允许您轻松重试失败的订阅来提供一个简单的解决方案。在RxJS中，这种方法被称为“重试”。将它插入到任何可观察链中，使其更具抗网络故障的能力。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Functional reactive programming has many uses in different applications both
    on the server and on the client. On the client side it can be used to wrangle
    a large number of events together into a data flow enabling complex interactions.
    It can also be used for the simplest of things such as preventing a user from
    double-clicking a button. There is no huge cost to simply using streams for all
    of your data changes. They are highly testable and have a minimal impact on performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程在服务器端和客户端的不同应用中有许多用途。在客户端，它可以用于将大量事件整合成数据流，实现复杂的交互。它也可以用于最简单的事情，比如防止用户双击按钮。只需使用流来处理所有数据更改并没有太大的成本。它们非常易于测试，并且对性能影响很小。
- en: Perhaps the nicest thing about FRP is that it raises the level of abstraction.
    You have to deal with less finicky process flow code and can, instead, focus on
    the logical flow of the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也许FRP最好的一点是它提高了抽象级别。您不必处理那么多琐碎的流程代码，而是可以专注于应用程序的逻辑流程。

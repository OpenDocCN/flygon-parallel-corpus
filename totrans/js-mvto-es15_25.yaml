- en: Chapter 12. Patterns for Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this module we've been pushing the idea that JavaScript is no longer
    a toy language with which we can't do useful things. Real world software is being
    written in JavaScript right now and the percentage of applications using JavaScript
    is only likely to grow over the next decade.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: With real software comes concerns about correctness. Manually testing software
    is painful and, weirdly, error-prone. It is far cheaper and easier to produce
    unit and integration tests that run automatically and test various aspects of
    the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: There are countless tools available for testing JavaScript, from test runners
    to testing frameworks; the ecosystem is a rich one. We'll try to maintain a more
    or less tool-agnostic approach to testing in this chapter. This module does not
    concern itself with which framework is the best or friendliest. There are overarching
    patterns that are common to testing as a whole. It is those that we'll examine.
    We will touch on some specific tools but only as a shortcut to having to write
    all our own testing tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monkey patching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the user interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We computer programmers are, as a rule, highly analytical people. This means
    that we're always striving to categorize and understand concepts. This has led
    to our developing some very interesting global techniques that can be applied
    outside computer programming. For instance, agile development has applications
    in general society but can trace its roots back to computing. One might even argue
    that the idea of patterns owes much of its popularity to it being used by computer
    programmers in other walks of life.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'This desire to categorize has led to the concept of testing code being divided
    up into a number of different types of tests. I''ve seen as many as eight different
    categories of tests from unit tests, right the way up to workflow tests and GUI
    tests. This is, perhaps, an overkill. It is much more common to think about having
    three different categories of test: unit, integration, and user interface:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![The testing pyramid](img/00095.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'Unit tests form the foundation of the pyramid. They are the most numerous,
    the easiest to write, and the most granular in the errors they give. An error
    in a unit test will allow you to find the individual method that has an error
    in it. As we move up the pyramid, the number of tests falls along with the granularity
    while the complexity of each test increases. At a higher level, when a test fails
    we might only be able to say: "There is an issue with adding an order to the system".'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Testing in the small with unit tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To many, unit testing is a foreign concept. This is understandable as it is
    a topic which is poorly taught in many schools. I know that I've done six years
    of higher education in computing science without it being mentioned. It is unfortunate
    because delivering a quality product is a pretty important part of any project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: For those who know about unit testing, there is a big barrier to adoption. Managers,
    and even developers, frequently see unit testing, and automated testing as a whole,
    as a waste of time. After all you cannot ship a unit test to your customer nor
    do most customers care whether their product has been properly unit tested.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is notoriously difficult to define. It is close enough to integration
    testing that people slip back and forth between the two easily. In the seminal
    book; *The Art of Unit Testing*, *Roy Osherove*, the author defines a unit test
    as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*A unit test is an automated piece of code that invokes a unit of work in the
    system and then checks a single assumption about the behavior of that unit of
    work.*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exact size of a unit of work is up for some debate. Some people restrict
    it to a single function or a single class, while others allow a unit of work to
    span multiple classes. I tend to think that a unit of work that spans multiple
    classes can actually be broken into smaller, testable units.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元的确切大小存在一些争议。有些人将其限制在单个函数或单个类，而其他人允许工作单元跨越多个类。我倾向于认为跨越多个类的工作单元实际上可以分解为更小、可测试的单元。
- en: The key to unit testing is that it tests a small piece of functionality and
    it quickly tests the functionality in a repeatable, automated fashion. Unit tests
    written by one person should be easily runnable by any other member of the team.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的关键在于测试小的功能片段，并以可重复、自动化的方式快速测试功能。一个人编写的单元测试应该很容易地由团队的任何其他成员运行。
- en: For unit testing we want to test small pieces of functionality because we believe
    that if all the components of a system work correctly then the system as a whole
    will work. This is not the whole truth. The communication between modules is just
    as likely to fail as a function within the unit. This is why we want to write
    tests on several levels. Unit tests check that the code we're writing right now
    is correct. Integration testing tests entire workflows through the application
    and will uncover problems in the interaction of units.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们希望测试小的功能片段，因为我们相信如果系统的所有组件都正确工作，那么整个系统也会工作。这并不是全部真相。模块之间的通信与单元内的功能一样容易失败。这就是为什么我们希望在几个层面上编写测试。单元测试检查我们正在编写的代码是否正确。集成测试测试应用程序中的整个工作流程，并将发现单元之间交互的问题。
- en: The test-driven development approach suggests writing tests at the same time
    as we write code. While this gives us great confidence that the code we're writing
    is correct, the real advantage is that it helps drive good architecture. When
    code has too many interdependencies it is far harder to test than well-separated
    modular code. A lot of the code that developers write goes unread by anybody ever
    again. Unit tests provide a useful way of keeping developers on the right path
    even in cases where they know that nobody will ever see their code. There is no
    better way to produce a quality product than to tell people they are going to
    be checked on it, even if the checker happens to be an automated test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发方法建议在编写代码的同时编写测试。虽然这让我们对自己编写的代码是否正确有很大的信心，但真正的优势在于它有助于推动良好的架构。当代码之间存在太多相互依赖时，要比良好分离的模块化代码难得多。开发人员编写的大部分代码永远不会被任何人阅读。单元测试为开发人员提供了一种有用的方式，即使在他们知道没有人会看到他们的代码的情况下，也可以让他们走上正确的道路。没有比告诉人们他们将受到检查更好的方法来生产优质产品，即使检查者可能是自动化测试。
- en: Tests can be run both while developing new code and in an automatic fashion
    on the build machines. If every time a developer checks in a change, the entire
    project is built and tested, then some reassurance can be provided that the newly
    checked-in code is correct. From time to time the build will break and that will
    be a flag that something that was just added was in error. Often the code that
    is broken may not even be proximal to the code changed. An altered return value
    may percolate through the system and manifest itself somewhere wholly unexpected.
    Nobody can keep anything more than the most trivial system in their mind at any
    one time. Testing acts as a sort of second memory, checking and rechecking assumptions
    made previously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以在开发新代码时运行，也可以在构建机器上以自动方式运行。如果每次开发人员提交更改，整个项目都会被构建和测试，那么可以提供一些保证，即新提交的代码是正确的。有时构建会中断，这将是一个标志，表明刚刚添加的内容是错误的。通常，出现错误的代码甚至可能与更改的代码不相邻。修改后的返回值可能会在系统中传播，并在完全意想不到的地方表现出来。没有人可以一次记住比最琐碎的系统更多的东西。测试充当了第二记忆的作用，检查和重新检查先前做出的假设。
- en: Failing the build as soon as an error occurs shortens the time it takes between
    an error being made in the code and it being found and fixed. Ideally the problem
    will still be fresh in the developer's mind so the fix can easily be found. If
    the errors were not discovered until months down the road, the developer will
    certainly have forgotten what s/he was working on at the time. The developer may
    not even be around to help solve the problem, throwing somebody who has never
    seen the code in to fix it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生错误，立即中断构建缩短了代码中出现错误和发现并修复错误之间的时间。理想情况下，问题仍然会在开发人员的脑海中，因此修复可以很容易地找到。如果错误直到几个月后才被发现，开发人员肯定会忘记当时在做什么。开发人员甚至可能不在现场帮助解决问题，而是让从未见过代码的人来解决问题。
- en: Arrange-Act-Assert
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排-执行-断言
- en: When building tests for any piece of code, a very common approach to follow
    is that of Arrange-Act-Assert. This describes the different steps that take place
    inside a single unit test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何代码构建测试时，一个非常常见的方法是遵循安排-执行-断言。这描述了单元测试中发生的不同步骤。
- en: The first thing we do is set up a test scenario (arrange). This step can consist
    of a number of actions and may involve putting in place fake objects to simulate
    real objects as well as creating new instances of the subject under test. If you
    find that your test setup code is long or involved, it is likely a smell and you
    should consider refactoring your code. As mentioned in the previous section, testing
    is helpful for driving not just correctness but also architecture. Difficult-to-write
    tests are indicative that the architecture is not sufficiently modular.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置一个测试场景（安排）。这一步可以包括许多动作，可能涉及放置虚假对象来模拟真实对象，以及创建被测试主体的新实例。如果你发现你的测试设置代码很长或很复杂，那很可能是一种坏味道，你应该考虑重构你的代码。如前一节所述，测试有助于驱动正确性和架构。难以编写的测试表明架构不够模块化。
- en: Once the test is set up then the next step is to actually execute the function
    we would like to test (act). The act step is usually very short, in many cases
    no more than a single line of code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好测试后，下一步是实际执行我们想要测试的功能（执行）。执行步骤通常非常简短，在许多情况下不超过一行代码。
- en: The final part is to check to make sure that the result of the function or the
    state of the world is as you would expect (assert).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是检查确保函数的结果或世界的状态符合预期（断言）。
- en: 'A very simple example of this might be a castle builder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个非常简单的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This class simply builds a new castle of a specific size. We want to make sure
    that no shenanigans are going on and that when we build a castle of size `10`
    we get a castle of size `10`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是建造一个特定大小的新城堡。我们想确保没有诡计，当我们建造一个大小为`10`的城堡时，我们得到一个大小为`10`的城堡：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assert
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: You may have noticed that in the last example we made use of a function called
    `assertEquals`. Anassert is a test that, when it fails, throws an exception. There
    is currently no built-in assert functionality in JavaScript, although there is
    a proposal in the works to add it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在上一个例子中，我们使用了一个名为`assertEquals`的函数。断言是一种测试，当它失败时会抛出异常。目前在JavaScript中没有内置的断言功能，尽管正在进行提案以添加它。
- en: 'Fortunately, building an assert is pretty simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，构建一个断言非常简单：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is helpful to mention, in the error, the actual value as well as the expected
    value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误中提到实际值以及期望值是有帮助的。
- en: There is a great number of assertion libraries in existence. Node.js ships with
    one, creatively called `assert.js`. If you end up using a testing framework for
    JavaScript it is likely that it will also contain an assertion library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 存在大量的断言库。Node.js附带一个，创造性地称为`assert.js`。如果你最终使用JavaScript的测试框架，很可能它也包含一个断言库。
- en: Fake objects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假对象
- en: If we think of the interdependencies between objects in an application as a
    graph it becomes quickly apparent that there are a number of nodes that have dependencies
    on, not just one, but many other objects. Attempting to place an object with a
    lot of dependencies under test is challenging. Each of the dependent objects must
    be constructed and included in the test. When these dependencies interact with
    external resources such as the network or file system, the problem becomes intractable.
    Pretty soon we're testing the entire system at a time. This is a legitimate testing
    strategy, known as **integration testing**, but we're really just interested in
    ensuring that the functionality of a single class is correct.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将应用程序中对象之间的相互依赖关系视为图形，很快就会发现有许多节点依赖于不止一个，而是许多其他对象。试图测试具有许多依赖关系的对象是具有挑战性的。每个依赖对象都必须被构建并包含在测试中。当这些依赖关系与网络或文件系统等外部资源交互时，问题变得棘手。很快我们就会一次测试整个系统。这是一种合法的测试策略，称为**集成测试**，但我们真正感兴趣的是确保单个类的功能是正确的。
- en: Integration testing tends to be slower to execute than unit tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的执行速度往往比单元测试慢。
- en: 'The subject of a test can have a large dependency graph that makes testing
    it difficult. You can see an example here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的主题可能具有一个庞大的依赖图，这使得测试变得困难。你可以在这里看到一个例子：
- en: '![Fake objects](img/00096.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![虚假对象](img/00096.jpeg)'
- en: 'We need to find a way to isolate the class under test so that we don''t have
    to recreate all the dependencies, including the network. We can think of this
    approach as adding bulkheads to our code. We will insert bulkheads to stop tests
    from flowing over from one class to many. These bulkheads are similar to how oil
    tankers maintain separation to limit the impact of spills and maintain weight
    distribution as can be seen here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来隔离测试中的类，这样我们就不必重新创建所有的依赖关系，包括网络。我们可以将这种方法看作是向我们的代码添加防水舱。我们将插入防水舱，以阻止测试从一个类流向多个类。这些防水舱类似于油轮维持分离以限制泄漏的影响并保持重量分布，如下所示：
- en: '![Fake objects](img/00097.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![虚假对象](img/00097.jpeg)'
- en: '*Image courtesy of [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图片由[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)提供。'
- en: To this end we can use fake objects that have a limited set of functionalities
    in place of the real objects. We'll look at three different methods of creating
    fake objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用虚假对象来代替真实对象，这些虚假对象具有有限的功能集。我们将看一下创建虚假对象的三种不同方法。
- en: The first is the, rather niftily named, test spy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是名为测试间谍的方法。
- en: Test spies
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试间谍
- en: A spy is an approach that wraps all the methods of an object and records the
    inputs and outputs from that method as well as the number of calls. By wrapping
    the calls, it is possible to examine exactly what was passed in and what came
    out of the function. Test spies can be used when the exact inputs into a function
    are not known beforehand.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一种包装对象的所有方法并记录该方法的输入和输出以及调用次数的方法。通过包装调用，可以准确地检查传入和传出函数的内容。当不事先知道函数的确切输入时，可以使用测试间谍。
- en: In other languages, building test spies requires reflection and can be quite
    complicated. We can actually get away with making a basic test spy in no more
    than a couple of lines of code. Let's experiment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，构建测试间谍需要反射，可能会相当复杂。实际上，我们可以用不超过几行代码来制作一个基本的测试间谍。让我们试一试。
- en: 'To start we''ll need a class to intercept:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个拦截的类：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we would like to spy on this function. Because functions are first class
    objects in JavaScript we can simply rejigger the `SpyUpon` object:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要监视这个函数。因为在JavaScript中，函数是一等对象，我们可以简单地重新调整`SpyUpon`对象：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we take the existing function and give it a new name. Then we create a
    new function that calls the renamed function and also records some things. After
    the function has been called we can examine the various properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接受现有的函数并给它一个新的名称。然后我们创建一个新的函数，调用重命名的函数并记录一些东西。在函数被调用之后，我们可以检查各种属性：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code in node gets us the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在node中运行此代码会得到以下结果：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this technique, it is possible to get all sorts of insight into how a
    function is used. There are a number of libraries that support creating test spies
    in a more robust way than our simple version here. Some provide tools for recording
    exceptions, the number of times called, and the arguments for each call.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，可以获得有关如何使用函数的各种见解。有许多库支持以比我们这里的简单版本更强大的方式创建测试间谍。有些提供记录异常、调用次数和每次调用的参数的工具。
- en: Stubs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根
- en: A **stub** is another example of a fake object. We can use stubs when we have
    some dependencies in the subject under test that need to be satisfied with an
    object that returns a value. They can also be used to provide a bulkhead to stop
    computationally expensive or I/O reliant functions from being run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**是假对象的另一个例子。当我们在测试主题中有一些依赖项需要满足返回值的对象时，我们可以使用存根。它们也可以用来提供防护，以阻止运行计算昂贵或依赖I/O的函数。'
- en: Stubs can be implemented in much the same way that we implemented spies. We
    just need to intercept the call to the method and replace it with a version that
    we wrote. However, with stubs we actually don't call the replaced function. It
    can be useful to keep the replaced function around just in case we need to restore
    the functionality of the stubbed out class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 存根可以以与我们实现间谍相同的方式实现。我们只需要拦截对方法的调用，并用我们编写的版本替换它。但是，对于存根，我们实际上不调用替换的函数。保留替换的函数可能是有用的，以防我们需要恢复存根类的功能。
- en: 'Let''s start with an object that depends on another object for part of its
    functionality:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个对象开始，该对象依赖于另一个对象的部分功能：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This knight object takes a `credentialFactory` argument as part of its constructor.
    By passing in the object we exteriorize the dependency and remove the responsibility
    for creating `credentialFactory` from the knight. We've seen this sort of inversion
    of control previously and we'll look at it in more detail in the next chapter.
    This makes our code more modular and testing far easier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个骑士对象在其构造函数中接受一个`credentialFactory`参数。通过传入对象，我们外部化了依赖关系，并从骑士中删除了创建`credentialFactory`的责任。我们之前已经看到了这种控制反转，并且我们将在下一章中更详细地讨论它。这使得我们的代码更模块化，测试更容易。
- en: 'Now when we want to test the knight without worrying about how a credential
    factory works, we can use a fake object, in this case a stub:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要测试骑士而不用担心凭据工厂的工作方式时，我们可以使用一个假对象，这里是一个存根：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This stub is a very simple one that simply returns a standard new credential.
    Stubs can be made quite complicated if there need to be multiple calls to it.
    For instance, we could rewrite our simple stub as the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根非常简单，只是简单地返回一个标准的新凭据。如果需要多次调用，存根可以变得非常复杂。例如，我们可以将我们的简单存根重写为以下内容：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This version of the stub returns a different sort of credential every time
    it is called. On the third call it returns null. As we set up the class using
    an inversion of control, writing a test is as simple as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根的版本在每次调用时返回不同类型的凭据。第三次调用时返回null。由于我们使用了控制反转来设置类，编写测试就像下面这样简单：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now execute the test:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行测试：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because there is no hard typing system in JavaScript, we can build stubs without
    worrying about implementing interfaces. There is also no need to stub an entire
    object but only the function in which we're interested.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中没有硬类型系统，我们可以构建存根而不必担心实现接口。也不需要存根整个对象，只需要我们感兴趣的函数。
- en: Mock
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'The final type of fake object is a **mock**. The difference between a mock
    and a stub is where the verification is done. With a stub, our test must check
    if the state is correct after the act. With a mock object, the responsibility
    for testing the asserts falls to the mock itself. Mocks are another place where
    it is useful to leverage a mocking library. We can, however, build the same sort
    of thing, simply, ourselves:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种假对象是**模拟**。存根和模拟之间的区别在于验证的位置。使用存根，我们的测试必须检查行为之后状态是否正确。对于模拟对象，测试断言的责任落到模拟对象本身。模拟是另一个有用的地方，可以利用模拟库。然而，我们也可以简单地自己构建相同类型的东西：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This `mockCredentialsFactory` class takes on the responsibility of verifying
    the correct functions were called. This is a very simple sort of approach to mocking
    and can be used as such:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mockCredentialsFactory`类承担了验证正确函数是否被调用的责任。这是一种非常简单的模拟方法，可以直接使用：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a static mock that keeps the same behavior every time it is used. It
    is possible to build mocks that act as recording devices. You can instruct the
    mock object to expect certain behaviors and then have it automatically play them
    back.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态模拟，每次使用时都保持相同的行为。可以构建作为记录设备的模拟。您可以指示模拟对象期望某些行为，然后让它自动播放它们。
- en: 'The syntax for this is taken from the documentation for the mocking library;
    Sinon. It looks like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法取自模拟库Sinon的文档。看起来像这样：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Monkey patching
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monkey patching
- en: We've seen a number of methods for creating fake objects in JavaScript. When
    creating the spy, we made use of a method called **monkey patching**. Monkey patching
    allows you to dynamically change the behavior of an object by replacing its functions.
    We can use this sort of approach without having to revert to full fake objects.
    Any existing object can have its behavior changed in isolation using this approach.
    This includes built-in objects such as strings and arrays.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在JavaScript中创建假对象的许多方法。在创建间谍时，我们使用了一种称为**monkey patching**的方法。Monkey
    patching允许您通过替换其函数来动态更改对象的行为。我们可以使用这种方法，而不必回到完全的假对象。使用这种方法，可以在隔离中更改任何现有对象的行为。这包括字符串和数组等内置对象。
- en: Interacting with the user interface
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户界面交互
- en: A great deal of the JavaScript in use today is used on the client and is used
    to interact with elements that are visible on the screen. Interacting with the
    page flows through a model of the page known as **Document Object Model** (**DOM**).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Every element on the page is represented in the DOM. Whenever a change is made
    to the page, the DOM is updated. If we add a paragraph to the page, then a paragraph
    is added to the DOM. Thus if our JavaScript code adds a paragraph, checking that
    it does so is simply a function of checking the DOM.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this requires that a DOM actually exists and that it is formed
    in the same way that it is on the actual page. There are a number of approaches
    to testing against a page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most naïve approach is to simply automate the browser. There are a few projects
    out there that can help with this task. One can either automate a fully-fledged
    browser such as Firefox, Internet Explorer, or Chrome, or one can pick a browser
    that is headless. The fully-fledged browser approach requires that a browser be
    installed on the test machine and that the machine be running in a mode that has
    a desktop available.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Many Unix-based build servers will not have been set up to show a desktop as
    it isn't needed for most build tasks. Even if your build machine is a Windows
    one, the build account frequently runs in a mode that has no ability to open a
    window. Tests using full browsers also have a tendency to break, to my mind. Subtle
    timing issues crop up and tests are easily interrupted by unexpected changes to
    the browser. It is a frequent occurrence that manual intervention will be required
    to unstick a browser that has ended up in an incorrect state.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, efforts have been made to decouple the graphical portions of a
    web browser from the DOM and JavaScript. For Chrome this initiative has resulted
    in PhantomJS and for Firefox SlimerJS.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the sorts of test that require a full browser require some navigation
    of the browser across several pages. This is provided for in the headless browsers
    through an API. I tend to think of tests at this scale as integration tests rather
    than unit tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical test using PhantomJS and the CasperJS library that sits on top of
    the browser might look like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This would test that entering a value into the search box on Google changes
    the `aria-haspopup` property from `false` to `true`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Testing things this way puts a great deal of reliance on the DOM not changing
    too radically. Depending on the selectors used to find elements on the page, a
    simple change to the style of the page could break every test. I like to keep
    tests of this sort away from the look of that page by never using CSS properties
    to select elements. Instead make use of IDs or, better yet, data-* attributes.
    We don't necessarily have the luxury of that when it comes to testing existing
    pages but certainly for new pages it is a good plan.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Faking the DOM
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much of the time, we don't need a full page DOM to perform our tests. The page
    elements we need to test are part of a section on the page instead of the entire
    page. A number of initiatives exist that allow for the creation of a chunk of
    the document in pure JavaScript. `jsdom` for instance is a method for injecting
    a string of HTML and receiving back a fake window.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, modified slightly from their README, they create some HTML
    elements, load JavaScript, and test that it returns correctly:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If your JavaScript is focused on a small section of the page, perhaps you're
    building custom controls or web components, then this is an ideal approach.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the manipulation
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final approach to dealing with graphical JavaScript is to stop interacting
    directly with elements on the page. This is the approach that many of the more
    popular JavaScript frameworks of today use. One simply updates a JavaScript model
    and this model then updates the page through the use of some sort of MV* pattern.
    We looked at this approach in some detail some chapters ago.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Testing in this case becomes quite easy. Our complicated JavaScript can simply
    be tested by building a model state prior to running the code and then testing
    to see if the model state after running the code is as we expect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example we could have a model that looks like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The test code for it might look as simple as the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As everything on the page is manipulated, through the bindings to the model,
    we can be confident that changes in the model are correctly updating the page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Some would argue that we've simply shifted the problem. Now the only place for
    errors is if the binding between the HTML and the model is incorrect. So we also
    need to test if we have bindings correctly applied to the HTML. This falls to
    higher-level testing that can be done more simply. We can cover far more with
    a higher-level test than with a lower-level one, although at the cost of knowing
    exactly where the error occurred.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: You're never going to be able to test everything about an application but the
    smaller you can make the untested surface, the better.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have seen tests where people split up the Arrange-Act-Assert by putting in
    place comments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You're going to wear your fingers to the bone typing those comments for every
    single test. Instead I just split them up with a blank line. The separation is
    clear and anybody who knows Arrange-Act-Assert will instantly recognize what it
    is that you're doing. You'll have seen the example code in this chapter split
    up in this fashion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: There are countless JavaScript testing libraries available to make your life
    easier. Choosing one may depend on your preferred style. If you like a gherkin-style
    syntax then cuumber.js might be for you. Otherwise try mocha, either on its own,
    or with the chai BDD style assertion library , which is is fairly nice. There
    are also testing frameworks such as Protractor which are specific to Angular apps
    (although you can use it to test other frameworks with a bit of work). I'd suggest
    taking a day and playing with a few to find your sweet spot.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests, I tend to name them in a way that makes it obvious that
    they are tests and not production code. For most JavaScript I follow camel case
    naming conventions such as `testMapping`. However, for test methods I follow an
    underscored naming pattern `When_building_a_castle_size_should_be_correctly_set`.
    In this way the test reads more like a specification. Others have different approaches
    to naming and there is no "right" answer, so feel free to experiment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing a quality product is always going to require extensive and repeated
    testing; this is exactly the sort of thing computers are really good at. Automate
    as much as possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Testing JavaScript code is an up-and-coming thing. The tooling around, mocking
    out objects, and even the tools for running tests are undergoing constant changes.
    Being able to use tools such as Node.js to run tests quickly and without having
    to boot up an entire browser is stunningly helpful. This is an area that is only
    going to improve over the next few years. I am enthused to see what changes come
    from it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll take a look at some advanced patterns in JavaScript
    that you might not want to use every day but are very handy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 3. Communication between Browsers in Real Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement features such as audio/video chat or some other features in websites
    that require real-time peer-to-peer (browser-to-browser) data transfer, or need
    to retrieve audio/video stream from a microphone, webcam, or any other device,
    we had to use browser plugins such as Java and Flash. There are various issues
    with making websites depend on browser plugins, such as mobile browsers not supporting
    plugins and plugins requiring to be kept up to date. Therefore, WebRTC was introduced
    to solve these problems, that is, browsers that support WebRTC provide APIs to
    exchange data in real time directly between browsers and also retrieve stream
    from physical media sources without the use of plugins. In this chapter, we will
    discuss WebRTC and also the PeerJS library that wraps the WebRTC APIs to provide
    an easy to use API to work with WebRTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Discussing various APIs provided by WebRTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving stream from physical media input devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a media stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing protocols used by WebRTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging media stream and arbitrary data between peers using PeerJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing topics related to the fundamentals of WebRTC and PeerJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into WebRTC and PeerJS, you need to know the meaning of some terms
    that we are going to use. These terms are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **stream** is a sequence of any kind of data that is made available over time.
    A stream object represents a stream. Usually, an event handler or callback is
    attached to the stream object, which is invoked whenever new data is available.
  prefs: []
  type: TYPE_NORMAL
- en: A **media stream** is a stream whose data is either audio or video. Similarly,
    a **media source** is a physical device, file, or something that provides data
    that is audio or video. A **media consumer** is also a physical device, API, or
    something that uses media stream.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebRTC allows us to retrieve a media stream of physical media sources, such
    as microphones, webcams, screens, and so on. We will discuss more about it later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer network model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Peer-to-peer model is the opposite of the client-server model. In the client-server
    model, the server provides resources to the clients, whereas in peer-to-peer model,
    every node in the network acts as a server and client, that is, every node provides
    and consumes resources. Peers in the peer-to-peer model communicate with each
    other directly.
  prefs: []
  type: TYPE_NORMAL
- en: To establish a peer-to-peer connection, we need a signaling server, which is
    used for signaling. **Signaling** refers to the exchange of data by peers that
    is required to establish a peer-to-peer connection. Data such as session control
    messages, network configuration, and so on is required to establish a peer-to-peer
    connection. A signaling server implements a signaling protocol such as SIP, Jingle,
    or some other protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model is selected depending on the requirements and resource availability
    for the application. Let''s consider some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: To build a video chat app, we should use the peer-to-peer model instead of the
    client-server model. As each node, in this case, is going to produce a lot data
    (or frames), and send the data to other node in real time, the server requires
    a lot of networks and other resources, increasing the server running cost. So,
    the peer-to-peer model is the best option for a video chat app. For example, Skype
    video chat is based on the peer-to-peer model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build a text chat app that stores messages in a centralized database, we
    should use the client-server model as the amount of data that a client produces
    is not very high and you would also want to store the messages in a centralized
    database. For example, the Facebook messenger is based on the client-server model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To establish a peer-to-peer connection using WebRTC, you will need a signaling
    server, STUN server, and optional TURN server. We will discuss more about it later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Real-time data** is the data that needs to be processed and transferred without
    much delay. For example, video chatting, live analytics, live stock price, live
    streaming, text chat, live score, online multiplayer game data, and so on are
    all real-time data.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time data transfer is a difficult task to achieve. The techniques and technologies
    used for real-time data transfer depend on the amount of data and whether the
    loss of data during data transfer is tolerable or not. If the real-time data is
    large, and the loss of data is intolerable, then it requires a lot of resources
    to achieve real-time data transfer, making it practically impossible to achieve
    real-time data transfer. For example, while video chatting, every user generates
    a lot of frames. If some frames are lost, then it is tolerable, therefore in this
    case, we can use the UDP protocol as a transport layer protocol that is unreliable
    and also has less overhead than TCP, making UDP very suitable for video chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebRTC allows us to transfer real-time media stream produced by it using the
    SRTP protocol. To transfer arbitrary data, it uses the SCTP protocol. We will
    discuss more about what these protocols are later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebRTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Real-Time Communications (WebRTC)** is a browser technology that enables
    retrieval of media stream of physical media sources and exchange media stream
    or any other data in real time. It comprises of three APIs: the `MediaStream`
    constructor, `RTCPeerConnection` constructor, and `RTCDataChannel` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, `MediaStream` is used to retrieve the stream of physical media source,
    `RTCPeerConnection` is used to exchange `MediaStream` among peers in real time,
    and finally, `RTCDataChannel` is used to exchange arbitrary data among peers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how these APIs work.
  prefs: []
  type: TYPE_NORMAL
- en: MediaStream API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two main components of MediaStream API are the `MediaStream` constructor and
    `MediaStreamTrack` interface.
  prefs: []
  type: TYPE_NORMAL
- en: A track represents the stream of a media source. A track implements the `MediaStreamTrack`
    interface. A track can either be an audio track or be a video track. That is,
    a track attached to an audio source is an audio track, and a track attached to
    a video source is a video track. There can be multiple tracks attached to a particular
    media source. We can also attach constraints to a track. For example, a track
    attached to a webcam can have constraints such as the minimum video resolution
    and FPS. Each track has its own constraints.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the constraints of a track after it's created using the `applyConstraints()`
    method of the `MediaStreamTrack` interface. You can retrieve the constraints applied
    to a track anytime using the `getSettings()` method of the `MediaStreamTrack`
    interface. To detach a track from a media source, that is, to stop the track permanently,
    we can use the `stop()` method of the `MediaStreamTrack` interface. To pause a
    track, that is, to stop the track temporarily, we can assign `false` to the `enabled`
    property of the `MediaStreamTrack` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Find out more about the `MediaStreamTrack` interface at [https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack).
  prefs: []
  type: TYPE_NORMAL
- en: A track can either be a local or remote track. A local track represents the
    stream of a local media source; whereas, a remote track represents the stream
    of a remote media source. You cannot apply constraints to the remote track. To
    find whether a track is local or remote, we can use the `remote` property of the
    `MediaStreamTrack` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will come across the remote track while exchanging tracks between peers.
    When we send a local track to a peer, the other peer receives the remote version
    of the track.
  prefs: []
  type: TYPE_NORMAL
- en: A `MediaStream` holds multiple tracks together. Technically, it doesn't do anything.
    It just represents a group of tracks that should be played, stored, or transferred
    together in a synchronized manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Find out more about the `MediaStream` constructor at [https://developer.mozilla.org/en/docs/Web/API/MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getSources()` method of the `MediaStreamTrack` object allows us to retrieve
    the ID of all the media devices, such as speakers, microphones, webcams, and so
    on. We can use the ID to create a track if the ID represents a media input device.
    The following is an example that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will vary for everyone. Here is the output I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: navigator.getUserMedia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various APIs that return `MediaStream` with tracks in it. One such
    method is `navigator.getUserMedia()`. Using `navigator.getUserMedia()`, we can
    retrieve a stream from media input sources, such as microphones, webcams, and
    so on. The following is an example to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding code, the browser will display a popup seeking permission
    from the user. The user has to give the permission to the code to access the media
    input devices.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the media input devices to which the tracks are attached while using
    `getUserMedia()` depends on the browser. Some browsers let the user choose the
    audio and video device that they want to use, while other browsers use the default
    audio and video devices listed in the operating system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We can also provide the `sourceId` property assigned to the ID of the media
    input device in the constraint object's `audio` or `video` property's `mandatory`
    property to make `getUserMedia()` attach tracks to these devices. So, if there
    are multiple webcams and microphones, then you can use `MediaStreamTrack.getSources()`
    to let the user choose a media input device and provide this media input device
    ID to `getUserMedia()` instead of relying on the browser, which doesn't guarantee
    whether it will let the user choose a media input device.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter that it takes is a constraint object with audio and video
    track constraints. Mandatory constraints are those constraints that must be applied.
    Optional indicates that they are not very important, so they can be omitted if
    it's not possible to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Some important constraints of an audio track are `volume`, `sampleRate`, `sampleSize`,
    and `echoCancellation`. Some important constraints of a video track are `aspectRatio`,
    `facingMode`, `frameRate`, `height`, and `width`. If a constraint is not provided,
    then its default value is used.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply set the `audio` or `video` property to `false` if you don't want
    to create the audio or video tracks respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the tracks of `MediaStream` using the `getTracks()` method of
    `MediaStream`. Similarly, we can add or remove a track using the `addTrack()`
    and `removeTrack()` methods, respectively. Whenever a track is added, the `onaddtrack`
    event is triggered. Similarly, whenever a track is removed, the `onendtrack` is
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: If we already have some tracks, then we can directly use the `MediaStream` constructor
    to create `MediaStream` with the tracks. The `MediaStream` constructor takes an
    array of tracks and returns `MediaStream` with the reference of the tracks added
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: An API that reads data from tracks of `MediaStream` is called a `MediaStream`
    consumer. Some of the `MediaStream` consumers are the `<audio>` tag, `<video>`
    tag, `RTCPeerConnection`, `Media Recorder` API, `Image Capture` API, `Web Audio`
    API, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how to display data of tracks of `MediaStream`
    in the video tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a `<video>` tag and a button to pause it. A video tag takes a URL
    and displays the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before HTML5, HTML tags and CSS attributes could only read data from `http://`
    and `file://` URLs. However, in HTML5, they can read `blob://`, `data://`, `mediastream://`,
    and other such URLs.
  prefs: []
  type: TYPE_NORMAL
- en: To display the output of `MediaStream` in the `<video>` tag, we need to use
    the `URL.createObjectURL()` method, which takes a blob, file object, or `MediaStream`
    and provides a URL to read its data. `URL.createObjectURL()` takes extra memory
    and CPU time to provide access to the value passed on to it via a URL, therefore,
    it is wise to release the URL using `URL.revokeObjectURL()` when we don't need
    the URL anymore.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple audio and video tracks in `MediaStream`, then `<video>`
    reads the first audio and video tracks.
  prefs: []
  type: TYPE_NORMAL
- en: RTCPeerConnection API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RTCPeerConnection` allows two browsers to exchange `MediaStream` in real time.
    `RTCPeerConnection` is an instance of the `RTCPeerConnection` constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing peer-to-peer connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a peer-to-peer connection to be established, a signaling server is needed.
    Through the signaling server, the peers exchange data required to establish a
    peer-to-peer connection. Actual data transfer takes place directly between peer-to-peer.
    The signaling server is just used to exchange pre-requirements to establish a
    peer-to-peer connection. Both the peers can disconnect from the signaling server
    once the peer-to-peer connection has been established. The signaling server doesn't
    need to be a highly configured server as the actual data is not transferred through
    it. Data transfer for a single peer-to-peer connection will be in some KB, so
    a decent server can be used for signaling.
  prefs: []
  type: TYPE_NORMAL
- en: A signaling server usually uses a signaling protocol, but it is also okay if
    it's an HTTP server as long as it can pass messages between two peers. WebRTC
    doesn't force us to use any particular signaling protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that there are two users, Alice and Bob, on two different
    browsers. If Alice wants to establish a peer-to-peer connection with Bob for chatting,
    then this is how a peer-to-peer connection would be established between them:'
  prefs: []
  type: TYPE_NORMAL
- en: They both will connect to a signaling server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice will then send a request to Bob via the signaling server, requesting to
    chat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signaling server can optionally check whether Alice is allowed to chat with
    Bob, and also if Alice and Bob are logged in. If yes, then the signaling server
    passes the message to Bob.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob receives the request and sends a message to Alice via the signaling server,
    confirming to establish a peer-to-peer connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now both of them need to exchange messages related to session control, network
    configuration, and media capabilities. All these messages are exchanged between
    them by the `RTCPeerConnection`. So, they both need to create an `RTCPeerConnection`,
    initiate it, and attach an event handler to `RTCPeerConnection` that will be triggered
    by `RTCPeerConnection` when it wants to send a message via the signaling server.
    `RTCPeerConnection` passes the message to the event handler in the **Session Description
    Protocol** (**SDP**) format, and the messages for the `RTCPeerConnection` received
    from the signaling server must be fed to `RTCPeerConnection` in the SDP format,
    that is, `RTCPeerConnection` only understands the SDP format. You need to use
    your own programming logic to split custom messages and messages for `RTCPeerConnection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps seem to have no problem; however, there are some major problems.
    The peers may be behind a NAT device or firewall, so finding their public IP address
    is a challenging task, sometimes it is practically impossible to find their IP
    address. So, how does `RTCPeerConnection` find an IP address of the peers when
    they may be behind a NAT device or firewall?
  prefs: []
  type: TYPE_NORMAL
- en: '`RTCPeerConnection` uses a technique called **Interactive Connectivity Establishment**
    (**ICE**) to resolve all these issues.'
  prefs: []
  type: TYPE_NORMAL
- en: ICE involves **Session Traversal Utilities for NAT** (**STUN**) and **Traversal
    Using Relays around NAT** (**TURN**) server to solve the problems. A STUN server
    is used to find the public IP address of a peer. In case the IP address of a peer
    cannot be found, or due to some other reason a peer-to-peer cannot be established,
    then a TURN server is used to redirect the traffic, that is, both the peers communicate
    via the TURN server.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to provide the addresses of the STUN and TURN servers and `RTCPeerConnection`
    handles the rest. Google provides a public STUN server, which is used by everyone.
    Building a TURN server requires a lot of resources as the actual data flows throw
    it. Therefore, WebRTC makes it optional to use a TURN server. If `RTCPeerConnection`
    fails to establish a direct communication between two peers and a TURN server
    is not provided, there is no other way for the peers to communicate and a peer-to-peer
    connection establishment fails.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebRTC doesn't provide any way to make signaling secure. It's your job to make
    the signaling secure.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring MediaStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw how `RTCPeerConnection` establishes a peer-to-peer connection. Now, to
    transfer `MediaStream`, we just need to pass the reference of `MediaStream` to
    `RTCPeerConnection` and it will transfer `MediaStream` to the connected peer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we say that `MediaStream` is transferred, we mean the stream of individual
    tracks is transferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the things you need to know regarding the transfer
    of `MediaStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTCPeerConnection` uses SRTP as an application layer protocol and UDP as a
    transport layer protocol to transfer `MediaStream`. SRTP is designed for media
    stream transfer in real time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP doesn't guarantee the order of packets, but SRTP takes care of the order
    of the frames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Datagram Transport Layer Security** (**DTLS**) protocol is used to secure
    the `MediaStream` transfer. So, you don't have to worry about the security while
    transferring `MediaStream`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints of the tracks that the remote peer receives may be different from
    the constraints of the local tracks, as `RTCPeerConnection` modifies the stream
    automatically, depending on the bandwidth and other network factors to speed up
    the transfer, achieving real-time data transfer. For example, `RTCPeerConnection`
    may decrease the resolution and frame rate of video stream while transferring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you add or remove a track from `MediaStream` that is already being sent,
    then `RTCPeerConnection` updates `MediaStream` of the other peer by communicating
    to the other peer via the signaling server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you pause a track that is being sent, then `RTCPeerConnection` pauses transfer
    of the track.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you stop a track that is being sent, `RTCPeerConnection` stops the transfer
    of the track.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can send and receive multiple `MediaStream` instances via single `RTCPeerConnection`,
    that is, you don't have to create multiple `RTCPeerConnection` instances to send
    and receive multiple `MediaStream` instances to and from a peer. Whenever you
    add or remove a new `MediaStream` to or from `RTCPeerConnection`, the peers exchange
    information related to this via the signaling server.
  prefs: []
  type: TYPE_NORMAL
- en: RTCDataChannel API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RTCDataChannel` is used to transfer data other than `MediaStream` between
    peers to transfer arbitrary data. The mechanism to establish a peer–to-peer connection
    to transfer arbitrary data is similar to the mechanism explained in the earlier
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTCDataChannel` is an object that implements the `RTCDataChannel` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the things you need to know regarding `RTCDataChannel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTCDataChannel` uses SCTP over UDP as a transport layer protocol to transfer
    data. It doesn''t use unlayered SCTP protocol as the SCPT protocol is not supported
    by many operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCTP can be configured for reliability and delivery order, unlike UDP, which
    is unreliable and unordered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTCDataChannel` also uses DTLS to secure data transfer. So, you don''t have
    to worry about the security at all while transferring data via `RTCDataChannel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can have multiple peer-to-peer connections open between browsers. For example,
    we can have three peer-to-peer connections, that is, first one for webcam stream
    transfer, second one for text message transfer, and third one for file transfer.
  prefs: []
  type: TYPE_NORMAL
- en: WebRTC applications using PeerJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PeerJS** is a client-side JavaScript library that provides an easy-to-use
    API to work with WebRTC. It only provides an API to exchange `MediaStream` and
    arbitrary data between peers. It doesn''t provide an API to work with `MediaStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: PeerServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PeerServer** is an open source signaling server used by PeerJS to establish
    a peer-to-peer connection. PeerServer is written in Node.js. If you don''t want
    to run your own PeerServer instance, then you can use PeerServer cloud, which
    hosts PeerServer for public use. PeerServer cloud allows you to establish a maximum
    of 50 concurrent connections for free.'
  prefs: []
  type: TYPE_NORMAL
- en: A unique ID identifies every peer connected to PeerServer. PeerServer itself
    can generate the ID, or else the peers can provide their own ID. For a peer to
    establish a peer-to-peer connection with another peer, it just needs to know the
    other peer's ID.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to run your own PeerServer instance when you want to add more
    functionality to PeerServer or you want to support more than 50 concurrent connections.
    For example, if you want to check whether the user is logged in to PeerServer,
    then you need to add this feature and host your own customized PeerServer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use PeerServer cloud, but in the next chapter, we will
    create our own instance of PeerServer. Therefore, to continue further with this
    chapter, create an account on the PeerServer cloud and retrieve the API key. Every
    application gets an API key to access the PeerServer cloud. If you are hosting
    your own PeerServer, then you won't need an API key. The API key is used by PeerServer
    cloud to track the total connections established by an application. To create
    an account and retrieve an API key, visit [http://peerjs.com/peerserver](http://peerjs.com/peerserver).
  prefs: []
  type: TYPE_NORMAL
- en: PeerJS API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's discuss the PeerJS API by creating a simple app that allows the users
    to exchange video and text messages with any user whose ID they have.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `peerjs-demo` directory in your web server and place a file named `index.html`
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `index.html` file, we need to first enqueue the `PeerJS` library. Download
    `PeerJS` from [http://peerjs.com/](http://peerjs.com/). At the time of writing,
    the latest version of PeerJS was 0.3.14\. I would recommend that you stick to
    this version for the following examples. Place this starting code in the `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, I enqueued the minified version of PeerJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'PeerJS API comprises of three main constructors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Peer`: An instance of `Peer` represents a peer in the network. A peer is connected
    to the signaling server and STUN, and optionally, to a TURN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataConnection`: DataConnection (that is, the instance of `DataConnection`)
    represents a peer-to-peer connection, which is used to exchange the arbitrary
    data. Technically, it wraps `RTCDataChannel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaConnection`: MediaConnection (that is, the instance of `MediaConnection`)
    represents a peer-to-peer connection that is used to exchange `MediaStream`. Technically,
    it wraps `RTCPeerConnection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a peer wants to establish `DataConnection` or `MediaConnection` with another
    peer, then it simply needs to know the other peer's ID. PeerJS doesn't give the
    other peer an option to accept or reject `DataConnection`. Also, in the case of
    `MediaConnection`, PeerJS doesn't give the other peer an option to accept or reject
    `MediaConnection`, but `MediaConnection` will be inactive until it is activated
    programmatically by the other peer so that `MediaStream` can be transferred, otherwise
    `MediaStream` will not be transferred. So, we can write our own logic to let the
    other user accept or reject `DataConnection` or `MediaConnecton`, that is, as
    soon as `DataConnection` or `MediaConnection` is established, we can cancel it
    by asking the user for their opinion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At present, one `MediaConnection` can transfer only one `MediaStream`. In future
    releases of PeerJS, a single `MediaConnection` will support the transfer of multiple
    MediaStreams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a `<video>` tag where the video will be displayed, a
    button to connect to a peer, and also a text box to send message. Here is the
    HTML code to display all these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now as soon as the page loads, we need to connect to `PeerServer` and ICE servers
    so that other peers can talk to us, and also when a user clicks on the connect
    button, we can establish `DataConnection` and `MediaConnection`. The following
    is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First we displayed a prompt box to take the ID as an input so that every peer
    can decide their own ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we created an instance of `Peer` with ID and PeerServer cloud key. Here
    we didn't provide signaling and ICE server's URLs, therefore, PeerJS will use
    PeerServer cloud as the signaling server and Google's public STUN server. It will
    not use any TURN server. As soon as a `Peer` instance is created, the instance
    connects to the signaling server and registers the given ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we attached five event handlers to the `peer` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `open` event is triggered when the connection to `PeerServer` was successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `error` event is triggered for errors on the `peer` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `disconnected` event is triggered when the connection with the signaling
    server is disconnected. The connection with the signaling server may get disconnected
    due to network problem or if you manually call the `peer.disconnect()` method.
    Once you are disconnected, your ID can be taken by someone else. You can try to
    reconnect with the same ID using the `peer.reconnect()` method. You can check
    whether `peer` is connected to the signaling server using the `peer.disconnect`
    Boolean property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `close` event is triggered when `peer` is destroyed, that is, it cannot
    be used anymore, all `MediaConnections` and `DataConnections` are killed, connection
    with the signaling server is killed, the ID is taken away, and so on. You may
    want to manually destroy `peer` when you don't need it anymore. You can destroy
    a peer using the `peer.destroy()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `connection` event is triggered when some other peer establishes `DataConnection`
    with you. As I said earlier, `DataConnection` is established without further permission,
    but you can close it as soon as it's established if you want. Here we let the
    user decide if they want to continue or close `DataConnection` established by
    another peer. The event handler attached to the event receives an instance of
    `DataConnection` via the parameter that represents the currently established `DataConnection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `call` event is triggered when some other peer establishes `MediaConnection`
    with you. Here, we also let the user decide if they want to continue or close
    `MediaConnection` established by another peer. The event handler attached to the
    event receives an instance of `MediaConnection` via the parameter that represents
    the currently established `MediaConnection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, in the `call` and `connection` event handlers, we asynchronously displayed
    the confirm popup boxes to prevent blocking the execution of the event handler
    that causes issues in some browsers, that is, blocking it fails to establish `DataConnection`
    and `MediaConnection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `acceptDataConnection()` and `acceptMediaConnection()`
    functions so that we can display the text messages and remote `MediaStream` when
    other peer establishes `DataConnection` or `MediaConnection` with us. Here''s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the preceding code works:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `acceptDataConnection()` function, we attached three event handlers to
    `DataConnection`. The `data` event is triggered when the other peer sends us data.
    The `close` event is triggered when `DataConnection` is closed. Finally, the `error`
    event is triggered when an error occurs on `DataConnection`. We can manually close
    `DataConnection` using the `dataConnection.close()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `acceptMediaConnection()` function, we attached three event handlers
    and transferred our `MediaStream` to the other peer. The `stream` event is triggered
    when other peer sends us `MediaStream`. The `close` event is triggered when `MediaConnection`
    is closed. Finally, we activated `MediaConnection` using the `mediaConnection.answer()`
    method by passing our `MediaStream`. After `MediaConnection` is activated, the
    `stream` event will be triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We finished writing the code to handle `MediaConnection` or `DataConnection`
    established by another peer with us. Now we need to write a code to create `MediaConnection`
    and `DataConnection` that a user clicks on the **connect** button. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First we asked the user to input another user's ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we established `DataConnection`. To establish a `DataConnection` with another
    user, we need to invoke the `connect()` method of the `Peer` instance with other
    peer's ID. We also made `DataConnection` reliable and ordered. Then, we attached
    the event handlers. We also saw how `data`, `close`, and `error` events work.
    The `open` event is triggered when `DataConnection` is established.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After establishing the `DataConnection`, we established `MediaConnection`. To
    establish `MediaConnection`, we need to call the `call()` method of the `Peer`
    instance. We need to pass `MediaStream` to the `call()` method. Finally, we attached
    the event handlers. The `stream` event will be triggered when the other user calls
    the `answer()` method of the `MediaConnection` instance, that is, when the MediaConnection
    is activated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now the last thing we need to do is write the code to send the message when
    a user clicks on the send message button. Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To send data via `MediaConnection`, we need to call the `send()` method of the
    `MediaConnection` instance. Here, we are sending a string, but you can pass any
    type of data including blobs and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to test the application, open the `index.html` page URL in two different
    browsers, devices, or tabs. I am assuming that you have opened the URL in two
    different devices. In each device, provide a different ID to identify the user.
    Then click on the connect button in any one device and enter the other peer's
    ID. Now accept the request on the other device. Once this is done, both the devices
    will be able to display each other's webcam video and microphone audio. You can
    also send messages between them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the official documentation of PeerJS API at [http://peerjs.com/docs/#api](http://peerjs.com/docs/#api).
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, the WebRTC specifications were still not finalized.
    The overall idea of what WebRTC does and how WebRTC works has been finalized.
    It's just that the APIs are still under development.
  prefs: []
  type: TYPE_NORMAL
- en: For example, WebRTC has introduced an alternative to the `navigator.getUserMedia()`
    method, that is, the `navigator.mediaDevices.getUserMedia()` method. At the time
    of writing, `navigator.mediaDevices.getUserMedia()` is not supported in any browsers.
    The difference between them is that the `navigator.mediaDevices.getUserMedia()`
    method is based on the promise pattern, whereas `navigator.getUserMedia()` is
    based on the callback pattern. At present, there is no plan to get rid of `navigator.getUserMedia()`
    due to the backward compatibility reason, but in future, `navigator.getUserMedia()`
    may be removed as WebRTC wants to implement all APIs using the promise pattern,
    therefore, it's difficult to maintain multiple APIs that do the same thing. Similarly,
    `navigator.mediaDevices.enumerateDevice()` is an alternative to `MediaStreamTrack.getSources()`,
    that is, `navigator.mediaDevices.enumerateDevice()` is based on the promise pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the official specification of WebRTC at [http://www.w3.org/TR/#tr_Web_Real_Time_Communication](http://www.w3.org/TR/#tr_Web_Real_Time_Communication).
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that there are multiple APIs for the same feature, each with
    a different browser support, WebRTC provides a script called `adapter.js`, which
    is a shim to insulate websites from specification changes and prefix differences.
    You can find the shim at [https://github.com/webrtc/adapter](https://github.com/webrtc/adapter).
  prefs: []
  type: TYPE_NORMAL
- en: WebRTC has a GitHub repository where it puts a lot of example projects showing
    some of the things that can be built using WebRTC. You can find the repository
    at [https://github.com/webrtc/samples](https://github.com/webrtc/samples). Just
    by looking at the examples and their source code, you can learn a lot more about
    WebRTC.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the fundamentals of WebRTC and PeerJS by creating
    a simple app. We discussed the various protocols, techniques, and other technologies
    that WebRTC uses to enable real-time peer-to-peer communication and read streams
    of physical media sources. We also saw an overview of PeerServer. Now you must
    be comfortable with building any type of WebRTC app using PeerServer cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build an advanced WebRTC app using a custom PeerServer.
  prefs: []
  type: TYPE_NORMAL

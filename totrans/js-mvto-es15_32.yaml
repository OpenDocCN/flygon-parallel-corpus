- en: Chapter 4. Building a Chatroulette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to master MediaStream and PeerJS is by building real-world applications,
    which is what we will do in this chapter. A chatroulette is a website that pairs
    random site visitors together for webcam and text-based conversation. Discussing
    how to build a chatroulette will help us to study PeerJS and PeerServer in depth,
    as it requires us to integrate PeerServer with Express. We will also add media
    controls to our site in order to pause/resume local MediaStream and allow the
    user to choose their desired microphone/webcam, which will help us to study MediaStream
    even more in depth. We will be actually creating a chatroulette that only allows
    the users of a particular country to chat, which would require an extra step of
    verification before connecting to the PeerServer; therefore, taking us even deeper
    into the integration of PeerServer into Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running your own instance of PeerServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom PeerServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating PeerServer with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify users for connecting to PeerServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the IP address and country of a user connected to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the user to use a microphone and webcam directly on the webpage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the requirements for building a completely working chatroulette
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own PeerServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building a chatroulette, let's see how to run our own instance
    of PeerServer.
  prefs: []
  type: TYPE_NORMAL
- en: PeerServer is available as an npm package on npm cloud. Let's create a custom
    PeerServer and use it with the PeerJS application that we built in our previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First create a directory named `Custom-PeerServer` and place `app.js` and `package.json`
    files in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `package.json` file, place the following code and run the `npm install`
    command to download the PeerServer package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the latest version of PeerServer is 0.2.8\. Here, we
    will also download the `express` package, as we will need to demonstrate how to
    integrate PeerServer with Express.
  prefs: []
  type: TYPE_NORMAL
- en: PeerServer package provides a library to create a custom PeerServer or integrate
    PeerServer with Express and also an executable file to directly create our own
    instance of PeerServer without any customization.
  prefs: []
  type: TYPE_NORMAL
- en: Run PeerServer from shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to directly run your own instance of PeerServer from shell without
    any customization, then run the following command in the `Custom-PeerServer/node_modules/peer/bin`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It should now print the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This confirms that `PeerServer` is running. To test whether the `PeerServer`
    instance is working or not, go to the `index.html` file of the application that
    we created in our previous chapter and replace the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be replaced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application and it should work as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Using PeerServer library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PeerServer library is used to create a custom PeerServer. The PeerServer library
    also allows us to integrate PeerServer with the Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom PeerServer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example code that demonstrates how to create your own custom PeerServer.
    Place the following code in the `app.js` file and run the `node app.js` command
    to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first two lines of the code create the custom PeerServer. We then
    attached event handlers that will be triggered when a user connects or disconnects
    from PeerServer. A custom PeerServer doesn't provide an API to check whether a
    peer is allowed to connect to PeerServer or not. It just allows us to do something
    after the peer is connected or when the peer disconnects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the custom PeerServer is working or not, go to the `index.html`
    file of the application that we created in the previous chapter and replace the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be replaced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application and it should work as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating PeerServer with the Express server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also integrate PeerServer with the Express server, that is, a particular
    path of the Express server will provide the signaling service. The main advantage
    of integrating PeerServer with the Express server is that we can check whether
    a peer is allowed to connect to PeerServer or not, and if it is not allowed, then
    we can stop the peer from using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code that demonstrates how to integrate PeerServer with
    the Express server. Place the following code in the `app.js` file and run the
    `node app.js` command to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using a middleware provided by the `PeerServer` library to integrate
    PeerServer with Express. Here, PeerServer is made available on the `/signaling`
    path. You can use any path you want to.
  prefs: []
  type: TYPE_NORMAL
- en: The `PeerServer` library doesn't provide any way to check whether the peer is
    allowed to connect to PeerServer or not, so we are using our own technique, that
    is, we are attaching another middleware on top of the `ExpressPeerServer` middleware,
    which performs this check. Although this technique may seem fine, if our custom
    middleware stops the request from proceeding further, then PeerServer fires the
    `connection` and `disconnect` events and destroys the `Peer` instance on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about PeerServer at [https://www.npmjs.com/package/peer](https://www.npmjs.com/package/peer).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chatroulette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chatroulette that we will build is only for people residing in India, that
    is, a peer cannot connect to the PeerServer if the IP address of the peer doesn't
    resolve to India. We added this filter to make the website a little more complex
    to code so that you can learn how to check whether a user is allowed to connect
    to PeerServer or not.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a single server that will serve webpages and also act as a PeerServer,
    that is, we will integrate PeerServer with the Express server.
  prefs: []
  type: TYPE_NORMAL
- en: We won't get into designing the frontend of our chatroulette. We will only be
    concentrating on building the architecture and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise files for this chapter contain two directories: `Chatroulette`
    and `Custom-PeerServer`. In the `Chatroulette` directory, there are two directories:
    `Initial` and `Final`. In the `Final` directory, you will find the complete chatroulette
    source code. In the `Initial` directory, you will only find the HTML code for
    our chatroulette. The `Initial` directory is to help you quickly get started with
    building the chatroulette.'
  prefs: []
  type: TYPE_NORMAL
- en: You will place the code related to the frontend functionality of the site in
    the `Initial/public/js/main.js` file and you will place the code related to the
    server side functionality in the `Initial/app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Building the backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our site will basically contain three URL end points: a root path for serving
    the home page, the `/find` path to find the ID of a free user for chatting, and
    finally the `/signaling` path that serves as the end point for PeerServer.'
  prefs: []
  type: TYPE_NORMAL
- en: Every user will have a unique ID that is generated by PeerServer. For a user
    to retrieve the ID of another free user using the `/find` URL, they must be first
    be connected to PeerServer.
  prefs: []
  type: TYPE_NORMAL
- en: The server will maintain two different arrays, that is, the first array contains
    IDs of the users connected to PeerServer and the second array contains IDs of
    the users that need a partner to chat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with building our backend. Place the following code in the
    `app.js` file to create our web server and serve the home page of our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are serving the `index.html` file as our home page. Run the `node app.js`
    command to start the server. I am assuming that you are running `node.js` on the
    localhost, so open the `http://localhost:8080/` URL on the browser to see the
    home page. The home page should look similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the backend](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the different elements of the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the home page, we will display the status of the `PeerServer`
    connection, `DataConnection`, and `MediaConnection`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we will display a video element and message box. `MediaStream` of the remote
    peer will be rendered on the video element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we have drop-down boxes for the user to select a microphone and webcam
    that they want to use if they have multiple microphones or webcams connected to
    their computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we have checkboxes that allow the users to pause or resume their audio
    and video.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have a button that allows the user to disconnect from the current
    user and chat with another user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every interactive element in the HTML page has an ID associated with it. While
    coding the frontend of the website, we will be using their IDs to get their reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create our signaling server. Here is the code for this. Place it
    in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the user can connect to PeerServer, we will find the country to which
    the IP address of the user belongs. We will find the IP address using the `request-ip`
    module and resolve the IP address to the country using the `geoip-lite` module.
    If the country is `IN` or the country name couldn't be resolved, then we will
    allow the user to connect to PeerServer by triggering the next middleware, otherwise
    we will stop them by sending an empty response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user connects to PeerServer, we will add the ID of the user in the `connected_users`
    array that maintains a list IDs if the users that are connected to PeerServer.
    Similarly, when the user disconnects from the PeerServer, we will remove the ID
    of the user from the `connected_users` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s define route for the `/find` path using which a user can find another
    user who is free to chat. The following is the code for this. Place this code
    in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `waiting_users` array holds the IDs of the users who are free and looking
    for a partner to chat to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user makes a request to the `/find` path, the route handler first checks
    whether the user is connected to PeerServer or not by checking whether the user
    ID is present in the `connected_users` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is not connected to PeerServer, then it sends an HTTP 404 error.
    If the user is connected to PeerServer, then it checks whether the user's ID is
    present in the `waiting_list` array. If not, it adds in the array and proceeds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it checks whether any other user ID is also present in the `waiting_list`
    array, and if yes, then it sends the first user ID in the list and then removes
    all user IDs from the `waiting_list` array. If it doesn't find any other user
    ID in the `waiting_list` array, then it simply sends `404 error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are done building the backend of our website. Before we get into building
    the frontend of our site, make sure that you restart the server with the latest
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, as soon as the home page loads, we need to find the microphones
    and webcams connected to the user computer and list them so that the user can
    choose the desired device. The following is the code to do this. Place this code
    in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we are retrieving the audio and video input devices using `MediaStream.getSources`
    and populating the `<select>` tags so that the user can choose an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the home page loads, we also need to create a `Peer` instance. Here
    is the code to do this. Place this code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First we declared five global variables. `peer` will hold reference for the
    `Peer` instance, `dc` will hold reference for `DataConnection`, `mc` will hold
    reference for `MediaConnection`, `ms` will hold reference for the local `MediaStream`,
    and `rms` will hold reference for the remote `MediaStream`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, as soon as the page finished loading, we connected to PeerServer, creating
    a `Peer` instance and attaching event handlers for the `disconnected`, `connection`,
    and `call` event handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we made sure that in case a peer gets disconnected from PeerServer due
    to some reason, then it automatically tries to connect to PeerServer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If another peer tries to establish `DataConnection` with us, then we will only
    accept it if there is no other `DataConnection` currently established, otherwise
    we will reject it. After accepting `DataConnection`, we attached the event handlers
    for the `data` and `close` events to print the incoming messages in the chat box,
    and clear all messages in the chat box if `DataConnection` is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, if another peer tries to establish `MediaConnection` with us, we
    will only accept it if there is no other `MediaConnection` currently established,
    otherwise we will reject it. After accepting the `MediaConnection`, we will attach
    the event handler for the `stream` event so that when remote `MediaStream` arrives,
    we can display it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding code, we are waiting for another peer to establish `DataConnection`
    and `MediaConnection` with us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write a code to find a free peer and establish `DataConnection`
    and `MediaConnection` with it. The following is the code for this. Place this
    code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is long but easy to understand. Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First we defined a `ajaxRequestObject()` function that just returns an AJAX
    object and hides browser differences by creating an AJAX object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we defined the `connectToNextPeer()` method that makes requests for a free
    ID from the `/next` path, and if found, it establishes `DataConnection` and `MediaConnection`
    with this peer. It also attaches the necessary event handlers that are same as
    the previous code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While retrieving `MediaStream`, it uses the device selected by the user in the
    dropdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before calling the other peer, it sets the `enabled` property to `true` or `false`,
    depending on whether the checkbox is checked or not respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set a timer that calls the `connectToNext()` peer once in every
    four second if the peer is connected to PeerServer, and `MediaConnection` or `DataConnection`
    is currently not established with another peer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need to write code to send the message to a connected peer when the
    user presses the *Enter* key on the text input fields of the message box. Here
    is the code to do this. Place this code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, at first, we are checking whether `DataConnection` is established or not.
    If `DataConnection` is currently established, then we will send a message to the
    connected peer and also display the message in the message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to write the code to pause or resume audio and video when the user
    toggles the checkboxes. The following is the code to do this. Place this code
    in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we are achieving this functionality by assigning `true` or `false` to the
    enabled property of the tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to close `MediaConnection` and `DataConnection` and find another user
    for chatting when the user clicks on the **Next User** button. The following is
    the code to do this. Place this code in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If there is any `MediaConnection` or `DataConnection` currently established,
    then we are closing it. Then we will call the `connectToNextPeer()` method to
    establish `MediaConnection` and `DataConnection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we finally need to display the status of the peer-to-peer connection and
    PeerServer connection. Here is the code to do this. Place this code in the `main.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we are checking and updating the status every `4` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the website
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the chatroulette website we just created, first make sure that the server
    is running and then open the `http://localhost:8080/` URL in two different tabs,
    browsers, or devices.
  prefs: []
  type: TYPE_NORMAL
- en: Now you will see that both of them automatically get connected and are able
    to chat with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to build a chatroulette using our own instance of
    PeerServer that is integrated with Express. The website we build had almost all
    the features that a chatroulette should have. You can now add features such as
    screen sharing, connecting users of particular a gender with each other, connecting
    users of a particular age, integrating captcha to prevent spam, and other features
    of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the WebRTC team is working on an API that allows you
    to retrieve a stream from a screen for screen sharing. As this API is still under
    development, you can use browser plugins to retrieve a stream from a screen. You
    can find more about retrieving a stream from a screen using the plugins at [https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/](https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss bidirectional communication between the
    client and the server in real time using WebSockets.
  prefs: []
  type: TYPE_NORMAL

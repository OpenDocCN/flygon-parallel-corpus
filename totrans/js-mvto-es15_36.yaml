- en: Chapter 8. Building an Advanced Profile Search Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to master FRP using Bacon.js is by building a real world application,
    which is what we will do in this chapter. We will build an advanced profile search
    widget, just like the ones you would usually find on social networking or dating
    sites. To keep the chapter short and to the point, we will work with some sample
    data instead of building registration functionality. We will also learn some more
    advanced concepts of functional programming and Bacon.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Error events in Bacon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in FRP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buses in Bacon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will build an advanced profile search widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors in Bacon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bacon provides the `Bacon.Error` constructor to explicitly mark events or values
    of EventStreams or properties respectively as errors so that Bacon can identify
    them and open up a wide variety of other APIs to work with those errors specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how we create a stream, Bacon.js can sometimes identify whether
    an event is a success or error event, and if it's an error event, then it can
    convert it to `Bacon.Error`. For example, if we use `Bacon.fromPromise` to create
    an EventStream, then Bacon can identify an error easily, since when an error occurs
    in a promise pattern, the second callback of the `then()` method or the callback
    passed to the `catch()` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: In case Bacon cannot identify whether an event is an error or success event
    while creating a stream, then we need to explicitly create instances of `Bacon.Error`
    and replace the error events with them. For example, when using `Bacon.fromCallback`,
    there is no way for Bacon.js to know whether an event is a success or error event,
    so we need to explicitly convert error events to instances of `Bacon.Error`.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A callback passed to `onValue` is not invoked for `Bacon.Error` events or values;
    instead, we need to use `onError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, open the `index.js` file that we created in our previous
    chapter, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you enter an URL that cannot be fetched, a custom error message is displayed
    on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `map()` function doesn't map `Bacon.Error` instances; therefore, Bacon provides
    us with `mapError ()`, which works the same way as `map` but maps only `Bacon.Error`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `flapMap()` doesn't map `Bacon.Error` instances. Therefore, Bacon
    provides us with `flatMapError()`, which works the same way as `flatMap` but maps
    only `Bacon.Error` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from `flatMap` and `map`, `Bacon.Error` instances can pass through everything.
  prefs: []
  type: TYPE_NORMAL
- en: Retrying a function call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we might want to retry an operation if it fails. For example, if
    we fail to retrieve a web page using AJAX due to a server timeout error, then
    we might want to try retrieving it again after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Bacon provides the `Bacon.retry` function, using which we can make a function
    call again and again as long as we want to.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bacon.retry` returns an EventStream, and it takes an object with four properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: This is a function that is to be reinvoked. This function must return
    a property or EventStream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retries`: This is a number representing the total number of times to retry
    the source function for in addition to the initial attempt. When a `Bacon.Error`
    instance is pushed to the property or stream returned by the source function,
    then an attempt to retry is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRetryable`: This is an optional property. It needs to be assigned to a function.
    The function should return either `true` or `false`. When something is pushed
    into the property or EventStream returned by the source function, then `isRetryable`
    is invoked to find our whether an attempt to retry should be made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: This is an optional property. It''s assigned to a function that returns
    the time in milliseconds to wait for before retrying. The default value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EventStream returned by `Bacon.retry` has the event or value that was present
    in the last EventStream or property returned by the last call to the source function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `Bacon.retry` function in action. Find this code in the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are retrying the AJAX request `5` times after every `2` seconds for
    any error other than `404`.
  prefs: []
  type: TYPE_NORMAL
- en: Ending an EventStream or property on error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An EventStream or property is said to have ended when you cannot push anything
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to end an EventStream or property when a `Bacon.Error` instance
    is pushed, then you need to call the `endOnError` method of the EventStream or
    property. The `endOnError` method returns a new EventStream or property, which
    is ended when a `Bacon.Error` instance is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an exception is encountered inside a callback passed to a Bacon helper function,
    then it's not caught automatically; rather, we have to use a `try…catch` statement
    to handle it. A common practice is to return a `Bacon.Error` instance after catching
    an exception so that we can handle it just like an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to handle exceptions. In the `index.js` file, find
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are catching exceptions and creating a new `Bacon.Error` instance with
    the exception as the details of the error, that is, we are passing the exception
    as an argument to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Constant properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bacon also provides us ways to create constant properties. Constant properties
    are initialized at the time of creation and cannot be reinitialized, that is,
    new values cannot be pushed.
  prefs: []
  type: TYPE_NORMAL
- en: A constant property is created using the `Bacon.constant()` constructer. We
    need to pass the value of the property to the constructor. A constant property
    can be merged, concatenated, combined, zipped, sampled, filtered, and transformed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a constant property. Place this code in
    the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `constant` property stores the time at which the script was started
    and prints the time.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of buses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **bus** is just like an EventStream, but it lets us push values into the stream
    manually instead of attaching it to a source, and it also allows plugging other
    EventStreams and properties into the bus on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how to create a bus and various methods
    provided by a `Bacon.Bus` instance. Place this code in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is self explanatory. The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to the end of EventStreams and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bacon provides the `onEnd` method to subscribe to callbacks that will be executed
    when an EventStream or property ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some example code, which shows you how to use the `onEnd` callback.
    Place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are attaching an `onEnd` callback to the constant property, which we
    created previously. After initialization, the property is ended; therefore, the
    `onEnd` callback is invoked. We can register multiple subscribers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, to end an EventStream or property, Bacon internally pushes an instance
    of the `Bacon.End` constructor. So, we can also use the `Bacon.End` constructor
    to end an EventStream or property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to use `Bacon.End`. Place this code in the
    `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A `Bacon.End` instance doesn't pass through helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Unplugging subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to subscribe to an EventStream and property using `onValue`, `onError`,
    and `onEnd`. We can also unsubscribe the subscribers if we don't need them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: These functions return a function for unsubscribing. To unsubscribe, we need
    to call the function returned by the subscriber function.
  prefs: []
  type: TYPE_NORMAL
- en: Combining and zipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bacon provides certain methods to combine and zip properties and EventStreams.
    There is a significant difference between combining and zipping.
  prefs: []
  type: TYPE_NORMAL
- en: When we combine properties, we always get a property, which will have an array
    of all source properties as its value. If we try to combine EventStreams, then
    they are first converted to properties before combining takes place. When there
    is a push in any one of the source properties, a new value is pushed into the
    resultant property. **Combining** starts after each of the source properties has
    a value pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example to demonstrate combining. Place this code in the `index.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Zipping is different from combining. **Zipping** means that events from each
    source are combined pairwise so that the first event from each source is published
    first, then the second event, and so on. The results will be published as soon
    as there is a value from each source. When we zip properties and EventStreams,
    we always get an EventStream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate zipping. Place this code in the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, **lazy evaluation** is a strategy that delays the evaluation
    of values until they're needed. There are two means by which lazy evaluation is
    implemented by Bacon.js.
  prefs: []
  type: TYPE_NORMAL
- en: Type 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stream or property will not be attached to its data source until it has subscribers.
    Let''s look at an example to understand this. Place this code in the `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, when you click on the `myButton` button, nothing will be logged. Now,
    place this code in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now when you click on the button, the event will be logged.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` method is also considered as a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Type 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods such as `map` and `combine*` use lazy evaluation to avoid evaluating
    events and values that aren't actually needed. Lazy evaluation results in huge
    performance benefits in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: But how do `map` and `combine*` know whether an event or value is not needed?
    Well, there are a few methods that give a hint about this to `map` and `combine*`,
    for example, `sampledBy`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the `sampledBy` method?
  prefs: []
  type: TYPE_NORMAL
- en: The`sampledBy` method is used for sampling a property based on a property or
    EventStream. It returns a property or EventStream, respectively, by sampling the
    property value at each event from the given property or EventStream. The returned
    property or EventStream will contain the property value at each push in the source
    property or EventStream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how `map` implements lazy evaluation. Place this
    code in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what we are doing in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create two buses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we map events in the first bus using the `map` method, and it is then
    transformed into a property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create an EventStream by sampling the property value at each event in
    the second bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add a subscriber to the EventStream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we push a value to the first bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The previous code looks like it should log the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it doesn''t log anything. That''s because lazy evaluation is
    taking place here. The `sampledBy` function takes the current value of the property,
    not the ones that were generated from previous events. Therefore, `map` decides
    to generate the property value when an event occurs in the second bus, therefore
    preventing unnecessary calls to the callback passed to the `map` function. In
    short, here, `map` simply prevents calculating property values until it''s actually
    needed. Now, add this code to the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the code, you will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that `map` prevented calculating for the first event pushed
    inside the first bus. It calculated the property value for second event because
    sampling was done after that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to prevent lazy evaluation when using the `map()` method, then use
    `flatMap` instead of `map`. The `flatMap` method doesn't use lazy evaluation.
    There is no way to prevent lazy evaluation when using `combine*` methods, but
    if you need it badly, then you can try to rewrite the code using other methods,
    which may or may not be possible depending on what you are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Building the profile search widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered almost all the important APIs and concepts of Bacon.js. Now, it's
    time to build the profile search widget. We will also learn some more APIs and
    concepts in the process.
  prefs: []
  type: TYPE_NORMAL
- en: We will build the profile search widget to learn how to write reactive code
    using Bacon for both the frontend and backend in real-world projects. Let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding project directories and files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the exercise files of this chapter, you will find a directory named `profile-search`-`widget`.
    Inside that directory, you will find two other directories named `final` and `initial`.
    The `final` directory contains the final code for the profile search widget whereas
    the `initial` directory contains the files and code for you to quickly get started
    with building the profile search widget. You will now work with the `initial`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: You are supposed to put the server-side code inside the `app.js` file and the
    frontend code inside the `public/js/index.js` file. Currently, the `app.js` file
    imports Bacon, Express, and filesystem modules and also has basic code to run
    the web server and serve static files.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `public/html/index.html` file, you will find HTML code. We will not
    be writing any HTML or CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first build the backend and then the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Express.js routes to a functional reactive pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Express.js** routes are written using a callback pattern. We need a wrapper
    to convert the callback pattern to a functional reactive pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bacon doesn''t provide any direct method for doing this—there are various other
    custom methods. The easiest and shortest way to do this is by creating a bus for
    every route, and whenever a request to a route is made, pushing an event into
    its respective bus. Let''s create a route this way for serving the `index.html`
    file for requests to the root URL. Place this code in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we define a function named `route_eventstream`, which acts as a wrapper
    to convert callback patterns to EventStream patterns. It takes a path and returns
    a bus. Whenever a request is made to the route, an event is pushed into the bus.
    The event is a connection object, that is, it holds the request and response objects
    for that client request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create an EventStream for root path requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we register a subscriber that returns the `index.html` file whenever
    an event is pushed into the root EventStream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the `node app.js` command and visit `localhost:8080` in your browser.
    This is the output you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting Express.js routes to a functional reactive pattern](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Making the user experience better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see that there are eight fields based on
    which a user can perform a search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of a user just filling some of the fields and clicking on the **Search**
    button to get the result, we can add some more features to make the user experience
    better. Here are the extra things we are going to add:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user uses the *Enter* key in any of the fields, we need fetch the
    search result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a user types the company name, we will show a drop-down menu with suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one of the fields except the gender field should have some value in
    order for us to fetch a search result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the entered e-mail is of invalid format, then we should display an error
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features will make the frontend code more complex, which will give us
    a chance to explore how to write complex logic using Bacon.
  prefs: []
  type: TYPE_NORMAL
- en: The company suggestions route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a route that responds with an array of company name suggestions
    based on a given value. Later on, to populate the company name text field drop-down
    menu, we will make a request to this route.
  prefs: []
  type: TYPE_NORMAL
- en: We will not build functionality to add profiles; instead, we will simply retrieve
    profiles from a JSON file that has some random profiles. In the `initial` directory,
    you will find a file named `data.json`, which has some profiles in it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first read the data from the `data.json` file. Here is the code for this.
    Place it in the `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are reading the data in functional reactive style and then converting
    the EventStream to a property, which represents the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the company suggestion route. Place it in the `app.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we define a method that takes an array of profiles and a company name.
    It checks for the profiles that have the same company and returns the filtered
    list. We are using the ES6 filter method, as Bacon doesn't provide any filter
    method for arrays. If the company name string is empty, then it returns an empty
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create an EventStream for `/company/dropdown` path requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we combine `company_dropdown_list_stream` and the `data` property. The
    resultant property is then mapped, and the filtered result is the transformed
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot simply use a subscriber here for `company_dropdown_list_stream` to
    respond to, as we have lost the reference to the connection object. Therefore,
    we zip `company_dropdown_list_stream` and `company_dropdown_list_data_stream`
    so that we get the reference to the connection object as well as the final result.
    We then attach a subscriber to the zipped EventStream, which sends the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One more thing to notice here is that we are using `onValues` instead of `onValue`.
    The difference between them is that `onValues` splits the value (assuming it's
    an array) as function arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The search result route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a route that responds with an array of profiles based on a given
    parameter. This will be used to find the search result. Later on, from the frontend,
    we will make a request to this route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this route. Place it in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we define two methods, which take a list of profiles and search data
    and filter based on the data. The first one only filters based on e-mail whereas
    the second one filters based on other search data. We have done it this way because
    e-mail is unique for every profile, and if a user provides an e-mail ID, then
    we don't need to use other data and waste computation. When there is a lot of
    data, you will get a big performance advantage this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create an EventStream for the `/search` path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we create two streams, namely, `profile_search_data_stream_form_email`
    and `profile_search_data_stream_form_others`. The `profile_search_data_stream_form_email`
    stream is the final result if an e-mail is provided, and `profile_search_data_stream_form_others`
    is the final result if an e-mail is not provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we merge `profile_search_data_stream_form_email` and `profile_search_data_stream_form_others`,
    zip that with `profile_search_stream`, and return the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are done building the backend part of our profile search widget. Now, we
    need to write the frontend part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into it, it''s worth looking at the code in the `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the code is self-explanatory. Here are a few things you need to pay
    special attention to:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, every input element has an `id` value attached to it. We will use the
    `id` value to create an EventStream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have displayed an error message below the e-mail field. It has a class `hide`,
    which hides it. Removing the class will unhide it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have a `datalist` element, which is the drop-down menu for the `company`
    field. We just need to add `option` tags to the `datalist` element to show the
    drop-down menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have a section to display the search result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create EventStreams for `keyup` events on the input fields and
    store the current value of the fields in properties. Here is the code for this.
    Place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Most of the above code is self-explanatory. The only thing that you need to
    understand is that instead of directly assign the e-mail field value to the e-mail
    property, we first validate whether the e-mail is valid. If the e-mail is invalid,
    then we display the error message and don't assign anything to the e-mail property.
    If the e-mail is valid, then we hide the error message and assign the current
    value of the e-mail field to the e-mail property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write code to display the suggestions drop-down menu for the company
    field. Here is the code for this. Place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, whenever the value of company property changes, we make a request to the
    `/company/dropdown` path, retrieve the suggestions, and append them to the `datalist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to make a `search` request whenever a user clicks on the **Search**
    button or hits *Enter* while in any of the input fields. Here is the code for
    this. Place it in the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we create a click stream for the **Search** button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create the `search_result_request_stream` stream, in which an event
    is pushed whenever we click on the **Search** button or press the *Enter* key
    inside any of the fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we make a request to the `/search` path if any of the fields along with
    the gender field has a value; otherwise, we display an alert message asking the
    user to enter some data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then, if the we get an AJAX error, then we display an alert with the error
    message; if the AJAX response isn't empty, then we display the result; and finally,
    if the AJAX request is empty, we displaying an alert with a message stating that
    nothing was found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the widget, rerun the `node app.js` command. Now, refresh the `localhost:8080`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the search widget is working, enter `Robert` in the **First**
    **Name** field and press *Enter*. You will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the widget](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test the company suggestions drop-down menu, enter `a` in the **Company**
    field, and you will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the widget](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So now, we have finished building and testing our advanced profile search widget.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the advanced APIs and concepts of Bacon.js and
    built a real-world project using them. You should now be comfortable with writing
    reactive code in a functional manner using Bacon.js and should try integrating
    Bacon.js into your existing and future projects.
  prefs: []
  type: TYPE_NORMAL
- en: You can also learn more about Bacon.js APIs at [https://baconjs.github.io/api.html](https://baconjs.github.io/api.html).
  prefs: []
  type: TYPE_NORMAL

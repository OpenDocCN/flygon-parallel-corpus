- en: Chapter 10. Building User Interfaces Using React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code for reactive UI is a difficult task, as writing code to manipulate
    the DOM using JavaScript whenever the application state changes is difficult and
    it makes understanding the application difficult. Therefore, the MVC architecture
    was introduced, where we define the UI and application state separately, and the
    UI is updated automatically as the application state changes. MVC framework views
    have been concentrating on making the writing of code for reactive UIs easier
    but not increasing rendering performance, reusability, and ease of debugging.
    This is what React aims to solve. It not only makes writing code for reactive
    UI easier but also takes care of rendering performance, reusability, and ease
    of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What React is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual DOM technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component-based UI development using React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-way dataflow programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSX to write React code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React on the server side to build isomorphic apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other topics to help us get a good hold on React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a JavaScript library for building reactive UIs. We usually use jQuery
    or pure JavaScript to manipulate a reactive UI whenever the application state
    changes, which makes it difficult to reuse and understand the code. Instead, we
    can use React, which lets us declare how the UI behaves based on the application
    state, and it automatically updates the UI whenever the application state changes.
    There are lots of libraries and technologies, such as web components and templating
    engines, that aim to make the building of UIs easier, but React stands out from
    the crowd as it makes it easy to build reusable and high-performance reactive
    UIs.
  prefs: []
  type: TYPE_NORMAL
- en: React is also used as a view library because it is exactly what a view library
    is supposed to be. A view holds the UI of the application and defines how the
    UI changes based on the application state, that is, how the application state
    is displayed. As it's just a view library, it doesn't tell us how to manage, access,
    and mutate the application state. It can be used as the view layer in any kind
    of architecture and framework.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that React is a library and not a framework such as Angular or Ember.
    Thus, React can be used with Angular to make Angular views better in terms of
    performance and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is an AngularJS module named ngReact that lets React be used
    as a view in AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Even the Flux architecture uses React as its view. We will learn more about
    Flux in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: React is always used with a framework as it only defines the UI but doesn't
    tell us how to manage the application logic and state, just like a template library
    or web component is always used with a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Is React a templating engine?**'
  prefs: []
  type: TYPE_NORMAL
- en: React is not a templating engine. The views of most of the popular MVC frameworks
    are of a template system. In a templating system, we write HTML with a template
    language for the UI, and it is processed in order to generate the final HTML.
    For example, an AngularJS view is a template system that's composed of directives,
    expressions, and so on. React is not a templating engine because we don't write
    HTML. Instead, we define the structure of the DOM using JavaScript. React can
    also do much more than what a templating engine can do. It can also capture user
    events in the UI. This is how it differs from traditional views. It's just that
    React works in a different way than a template system.
  prefs: []
  type: TYPE_NORMAL
- en: When building user interfaces using React, we don't write any HTML to build
    the UI like when using other frameworks and libraries; instead, we declare the
    DOM structure using JavaScript only. This programming style is what makes React
    able to implement various algorithms and technologies to achieve high rendering
    performance and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get further into learning React, let's first set up a project to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic React project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the latest version of React was 0.14.7\. This is the
    version this module uses. First, visit [https://facebook.github.io/react/downloads.html](https://facebook.github.io/react/downloads.html)
    to download React. Here, you will find two types of React builds, namely, production
    and development builds. The difference between these two build is that the development
    build is uncompressed and includes extra warnings, whereas the production build
    is compressed, includes extra performance optimizations, and strips all errors.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the development build when your application is in the development
    phase. Once your application is ready for deployment, you should change to the
    production build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you will find two types of production and development build: one with
    add-ons and the other without. We will use the development version without add-ons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find CDN links as well as links to download and enqueue React manually.
    React is composed of two files: `react.js` and `react-dom.js`. Download both of
    them manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder named `react-demo` and place both the files in it. Then, create
    a file called `index.html` and put this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Later on in this chapter, we will learn more about why React is composed of
    two files and not one. For now, just ignore this.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A browser interprets HTML and creates a DOM. A DOM is a tree-like structure
    that defines the structure of the page. The browser then renders the DOM on the
    page. The DOM API is what we use to manipulate the DOM. When we manipulate it,
    the browser re-renders the manipulated parts.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not with how the DOM works, but how we programmatically alter
    it. Manipulating nodes of a DOM requires expertise; otherwise, we could often
    end up re-rendering lots of nodes unnecessarily, which would result in poor rendering
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine we have a large list of products in an e-commerce website.
    We also have a filter widget to filter the items. When we change the values in
    the filter widget, the list items are reloaded and the complete list is re-rendered,
    which requires a lot of manipulation to the DOM and can result in bad rendering
    performance. To get better performance, we can actually manipulate only specific
    parts of the list, such as product titles, image, and cost. But writing code for
    this is going to be hard.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another example. If you are using `ng-repeat` to display a list,
    then adding a new item to the list will cause the complete re-rending of the list.
    So, if Facebook or Instagram had used `ng-repeat`, then whenever we scrolled down,
    the whole set of posts would have been re-rendered. The solution to this problem
    is instead of using `ng-repeat`, which re-renders the whole list, we can append
    a new post to the end of the list using jQuery or pure JavaScript. But if you
    want to maintain the posts that are being displayed, then you will end up writing
    some more complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these kinds of problem, virtual DOM was introduced. Virtual DOM makes
    sure that anyone can write complex reactive UI code without worrying about performance.
    Virtual DOM is the secret that React implements to achieve rendering performance.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual DOM is an abstract version of the real DOM, that is, a description
    of the real DOM. Virtual DOM elements are just JavaScript objects whereas real
    DOM elements are real UI elements. Virtual DOM is much faster as it's just a JavaScript
    data structure and manipulating it doesn't automatically re-render the UI. Earlier,
    I said that in React, you don't write any HTML but instead declare the structure
    of the DOM. Actually, you declare the structure of the virtual DOM, not the real
    DOM. React keeps the real DOM in sync with virtual DOM. Whenever the application
    state changes to update the UI, React uses complex algorithms to compare the real
    DOM with the virtual DOM and finds as few mutations as possible for the real DOM
    to sync with the virtual DOM. We will later see how these algorithms actually
    find the difference and mutate the real DOM. For example, if we have a list in
    the virtual DOM and we remove the list and add a new list with just an extra item,
    then, only the new item is rendered when synced with the real DOM, not the whole
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some example code to print **Hello World** using React. Inside
    the `index.html` body tag, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the script tag of the `index.html` file to display **Hello World**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code''s output looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtual DOM](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's understand how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.createElement` is used to create an object of a `ReactElement` interface.
    A `ReactElement` object is a light, stateless, and virtual representation of a
    real DOM element, but it''s not a real DOM element. It''s a virtual DOM, basically.
    `ReactElement` and real DOM elements are of different interfaces. The first parameter
    of `React.createElement` can be an HTML tag name or an object of a `ReactClass`
    interface. We will learn more about `ReactClass` later on. The second argument
    is an object containing attributes of the HTML tag or properties of the `ReactClass`
    object. And then, we can pass an infinite number of arguments, which can be strings,
    `ReactElement` objects, or `ReactClass` objects. All the arguments after the second
    argument are treated as children of the `ReactElement` object that''s going to
    be created. If the children are dynamically decided, then you can provide an array
    as the third argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we created three `ReactElement` objects. `helloWorld` is an anchor tag
    with `helloBold` and `worldItalic` as its children. We assigned the `href` attribute
    of the anchor tag to `#`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactDOM.render` is used to render `ReactElement` objects in the real DOM.
    `ReactDOM.render` takes a `ReactElement` object as first argument, and the second
    argument is the reference to the container element in the real DOM inside which
    we want to add to the `ReactElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've rendered the anchor tag inside the container element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a `ReactElement` object is stateless, we cannot assign any UI event handlers
    to the `properties` object. Also, directly mutating the properties passed to the
    `ReactElement` object will not have any effect, as React doesn't watch the properties
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the beginning, it may feel as if `ReactElement` and real DOM elements are
    just created in different ways and their interface is the same, but this is not
    true. Here are a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the `class` attribute, you need to use `className`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of the `for` attribute, you need to use the `htmlFor` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `style` attribute cannot be a string; it has to be a object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more. We will explore them as we go deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use React using only `ReactElement` objects, but to take advantage of
    React, you have to use React components. `ReactElement` objects are stateless
    and immutable and therefore useless for building reactive UIs. Also, they don't
    provide a structured mechanism for UI reusability.
  prefs: []
  type: TYPE_NORMAL
- en: A React component is a reusable custom tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI. For example, we can have a component named `clock` that takes the current
    time as an attribute and displays a clock with the passed time. Another exchange
    could be a Bitcoin price component that displays Bitcoin prices in real time.
  prefs: []
  type: TYPE_NORMAL
- en: A component state is internal to the component. It's created and mutated inside
    the component. However, the properties of a component cannot be mutated inside
    the component; rather, they can be mutated by the code that created the component
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: You can break your complete UI into components—this is the style of coding that's
    recommended when building a UI using react. You can use components inside components
    as well. Before we get further into components, let's rewrite the previous **Hello
    World** code using components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `index.html` body tag, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to display **Hello World** inside this `div` element. Place this
    code in the `script` tag of the `index.html` file to display **Hello World**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Components](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: A component is created using the `React.createClass` function. This function
    takes an object, and the object must have a `render` property assigned to a function
    that returns a `ReactElement` object. The `ReactElement` object returned by the
    `render` method is said to be the content of the component, that is, it states
    how the tag is rendered. Whenever we try to display the tag, the contents of the
    tag are displayed in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`React.createClass` returns a component. To use the component, we need to create
    instances of it. Like `React.createElement` is used to create a `ReactElement`
    object for an HTML tag, it can also create a `ReactElement` object for a component.
    So, `React.createElement` is used to create instances of a component. `this.props`
    is used inside the component to access its properties.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created a component called `anchorWithBoldItalic`, which is an anchor
    element with some text displayed as bold and some displayed as italic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we created a `ReactElement` object for our component and finally rendered
    it using `ReactDOM.render`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that mutating properties after a component instance has been created
    will re-render the component.
  prefs: []
  type: TYPE_NORMAL
- en: One-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous subsection, I stated that a component has an enclosing nature.
    Whenever we make changes to the state, the component is rendered. Components also
    let you register UI event handlers, and you can mutate the state inside the event
    handlers too.
  prefs: []
  type: TYPE_NORMAL
- en: React lets you manage, access, and mutate UI state but not application state.
    The difference between UI state and application state is that the UI state represents
    the data that's used to manipulate the UI whereas the application state represents
    the data that's displayed in the UI. For example, let's assume that you have a
    comment box. The comments in the comment box are the application state, and the
    **View more comments** button is the UI state, which may or may not be displayed,
    depending on whether there are any more posts.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding between a UI and its state is only one-way. This means that user
    actions on the UI cannot alter the UI state directly, but the UI state can alter
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem as if this were a limitation as AngularJS and other popular frameworks
    provide two-way data binding, but this is actually a feature. This feature makes
    it easier to understand and debug applications.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers tend to use UI state as application state, but for complex and
    large apps, this will cause issues and make it difficult to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of how to use component state by building a button
    that hides/shows a box when clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code in the `<body>` tag of the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will display the component inside this container element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code inside the `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One-way data binding](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, we create a new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getInitialState` method returns the initial state of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a click handler that toggles the display state. When mutating
    the state, you must use `this.setState` and not directly mutate the state using
    `this.state`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create the `render` method, which displays a button and a small red
    box. The `render` method sets the display style of the box to the display state.
    So, whenever the state changes, React renders the component. Instead of rendering
    the complete component, React re-renders it by comparing the virtual DOM with
    the real DOM and mutating only the required DOM elements. This is how it achieves
    rendering performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we create a component instance and add it to the container element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also note that we've only specified a number for height and width without any
    unit. In such a case, the unit is pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Isomorphic UI development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Isomorphic development** is where we can use the same code in both the frontend
    and backend.'
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we've seen how to use React in the frontend to build reactive UI,
    but the same React code can also be used in the backend. When used in the backend,
    React outputs HTML and doesn't provide any kind of UI performance advantage or
    reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The isomorphic nature of React is one of the things that make it so popular
    and powerful. It has made many things easier. For example, it makes it easier
    to prevent FOUC by letting us pre-render the page in the backend, and then in
    the frontend: the same components will just add event bindings.'
  prefs: []
  type: TYPE_NORMAL
- en: React code not only executes in Node.js but can also be executed in PHP, Ruby,
    .NET, and some other major backend languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the fact that React can be used in both the frontend and backend, the
    React developer team decided to split React into two files: React core and another
    part that is specific to the executing environment. That''s why when we included
    React in our HTML file earlier, we included two files. The React core contains
    `React.createElement`, `React.createClass`, and so on whereas the React DOM contains
    `ReactDOM.render` and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of how to use React in Node.js by creating and displaying
    the previous hello world component in Node.js. Create a directory named `React-Server-Demo`.
    Inside it, create files named `app.js` and `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `package.json` file, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run `npm install` to download the Express and React modules. Now, in
    the `app.js` file, place the following code and run the `node app.js` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `http://localhost:8080/` in your browser; you''ll see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Isomorphic UI development](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the React core module, then the React server-side module, and
    then Express.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using the same code we used earlier to create the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a route for the root path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root path uses the `renderToString` method of the React server-side module
    to generate the HTML code of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we send the HTML to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that by default, React will be in development mode. To use React in production
    mode, set the environment variable `NODE_ENV` to `production`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing JavaScript to define a tree-like structure and attributes while building
    UI using React is difficult and also makes it difficult to understand the UI.
    So, the React team came up with an alternative syntax to write React code, which
    is easier to write and understand. This alternate syntax is called JSX. JSX stands
    for JavaScript syntax extension. It looks similar to XML. Files that contain JSX
    code have the`.jsx` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, browsers and server-side engines cannot understand and interpret
    JSX; therefore, we need to compile JSX into pure JavaScript before using it.
  prefs: []
  type: TYPE_NORMAL
- en: There are various open source JSX compilers. You can find the list at [https://github.com/facebook/react/wiki/Complementary-Tools#build-tools](https://github.com/facebook/react/wiki/Complementary-Tools#build-tools).
    The most popular and recommended compiler for JSX is Babel. Babel can be installed
    ([https://babeljs.io/docs/setup/](https://babeljs.io/docs/setup/)), we can use
    the Babel compiler online ([https://babeljs.io/repl/](https://babeljs.io/repl/)),
    and we can also embed the Babel compiler in our HTML page so that it compiles
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of demonstration, we will embed the Babel compiler in our HTML
    page. Compiling takes time, so in production sites, you should never embed the
    compiler in web pages; instead, you should precompile and serve JSX code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed the Babel compiler in a webpage, visit [https://cdnjs.com/libraries/babel-core](https://cdnjs.com/libraries/babel-core)
    and download the Babel core. These are CDN links, so they can be embedded directly,
    but let''s download and embed them in our webpage. Download the `browser.min.js`
    file and place it in the `react-demo` directory. And then, embed it in the `index.html`
    page by placing the following code in the `<head>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new `<script>` tag at the end of the `body` tag and set the `type`
    attribute to `text/babel` so that the Babel compiler knows which code to compile.
    Here is how the code should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From now on, all the JSX code will be placed in this script tag.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSX editors**'
  prefs: []
  type: TYPE_NORMAL
- en: There are extensions available for almost all the popular code editors to properly
    highlight JSX syntax.
  prefs: []
  type: TYPE_NORMAL
- en: JSX syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite the data-binding example code using JSX syntax. Place this code
    in the `body` tag to create a new container element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the JSX code. Place it in the `script` tag that will be compiled by
    Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSX syntax](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we see how this code works, let''s look at its compiled version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This compiled version will give you a basic idea of how JSX syntax works. Let's
    understand how the previous JSX code works.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, JSX is used to write the `React.createElement` method in XML-like
    syntax. The XML tag name is the first argument, the attributes are the second
    argument, and finally, the child elements are the other arguments of `React.createElement`.
  prefs: []
  type: TYPE_NORMAL
- en: If a JSX tag name starts with a lowercase letter, it's an HTML tag, whereas
    if it starts with a capital letter, it's a component. So here, we made the component
    name start with a capital H. Had we used a small H, it would have been treated
    as an HTML tag, and `<hideShowBoxButton></hideShowBoxButton>` would have been
    inserted into the page, which would have rendered nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In the `HideShowBoxButton` component, except the `render` method code, everything
    else is the same. We rewrote the `render` method using JSX syntax.
  prefs: []
  type: TYPE_NORMAL
- en: JSX provides `{}` braces to wrap JavaScript expressions while assigning them
    to attributes or using them as child elements. Here, we've assigned JavaScript
    expressions to `onClick` and `style` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created an instance of the component using JSX syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the compiled code, you will find a `displayName` property in the object passed
    to `React.createClass`. The `displayName` property is used for debugging. If not
    set, it's set to the component name while compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dig further into components and master them. We'll look at component composition
    and ownership. Learning this will help us build complex reactive UIs that are
    easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Component composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Composability** is a feature that lets you use a component inside another
    component''s `render` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a basic example of component composition. First, create a new
    container element. To do so, place the following code in the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the component composition example code. Place this code in the `script`
    tag that''s compiled by Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Component composition](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we've created two different components. Inside the Card component, we
    are using the `ResponsiveImage` component to display a responsive image in it.
  prefs: []
  type: TYPE_NORMAL
- en: Component ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When components are used inside other components' `render` methods, they are
    said to have an owner-ownee relationship and not a parent-child relationship.
    Component X is said to be the owner of component Y if component X created an instance
    of component Y in its `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that component X is not called the parent; rather, it's called the owner
    of component Y.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous code, the `Card` component is the owner of the
    `ResponsiveImage` component and `<div>` is the parent of `ResponsiveImage`.
  prefs: []
  type: TYPE_NORMAL
- en: If we place a component instance inside the opening and closing tags of a component
    instance, then they are said to be in a parent-child relationship. The parent
    can access its children by using the `this.props.children` object. React also
    provides utility functions to make working with children easier. You can find
    the utilities at [https://facebook.github.io/react/docs/top-level-api.html#react.children](https://facebook.github.io/react/docs/top-level-api.html#react.children).
  prefs: []
  type: TYPE_NORMAL
- en: Reconciliation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reconciliation** is the process by which React updates the DOM whenever the
    state changes. React doesn''t re-render everything from scratch when the state
    changes; instead, it first finds whether a mutation is required by comparing the
    new virtual DOM with the old one, and if there is a difference, it compares the
    new virtual DOM with the real DOM and makes the necessary mutations.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that reconciliation doesn't happen only when you change the component state;
    it also happens when you call `ReactDOM.render` on the same container element
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how exactly reconciliation happens by looking at an example. Suppose
    this is the initial render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remove `Item 1` from the state, then the render will change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: React algorithms compare DOM items one by one, and whenever they find a difference
    between two nodes, they make mutations. So here, React will remove the `Item 1`
    list item by changing the text of the first list item and removing the last one.
    This process is much faster than removing both the list items and adding a new
    list item, which is what `ng-repeat` does and what we used to do using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: If the node type is different, React will treat them as two different subtrees,
    throw away the first one, and build/insert the second one. For example, if we
    change `<ul>` to `<ol>`, the complete `<ul>` tree will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is fine until you add new items to the end of the list or modify
    them. In case you add new items to the beginning or in between the list, you will
    start facing rendering performance issues. To understand the issue, let''s take
    an example. Let''s add `Item 0` to the beginning. Now, the render will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, while reconciling, React will first change the text of the first list
    item to `Item 0`, then change the text of the second list item to `Item 1`, and
    finally will add a new list item and assign its text to `Item 2` instead of simply
    adding a new list item to the beginning of the list. This behavior makes the rendering
    actually slower.
  prefs: []
  type: TYPE_NORMAL
- en: React does provide a way to get around this kind of issue as well. It lets us
    uniquely identify each child by assigning it a unique key. When React reconciles
    the keyed children, it will ensure that any child with a key will be reordered
    (instead of being mutated) or destroyed (instead of being reused). A key is assigned
    using the `key` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to create keyed children. Here is the code
    to create a new container element. Place this code in the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the React code for creating keyed children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reconciliation](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, when the `anchor` element is clicked on, a new object is added to the
    beginning of the result array. As the state changes, the list is re-rendered.
    While rendering, React will reorder the list items and add new list items to the
    beginning instead of mutating them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that when dynamically creating component instances, the key should
    always be supplied to the components in the array, not to the container element
    of each component in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Default component property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React lets you define default values for properties in a very declarative way.
    The default value is used if the parent does not pass a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default values are returned by a method `getDefaultProps`, which is a member
    of the object passed to `React.createClass`. Here is some sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Component life cycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various methods are executed at specific points in a component's lifecycle.
    Let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillMount()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `componentWillMount()` method is invoked once immediately before the initial
    rendering occurs. If you call `setState` within this method, `render()` will see
    the updated state and will be executed only once despite the state change.
  prefs: []
  type: TYPE_NORMAL
- en: componentDidMount()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `componentDidMount()` method is invoked only on the client side. It is invoked
    only once after initial rendering has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillReceiveProps(nextProps)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Directly mutating the properties passed to a component will have no effect because
    there is no way for React to find value changes as it doesn't watch the properties
    directly. But sometimes, it is possible for React to predict property value changes,
    and in that case, it calls the `componentWillReceiveProps` method, if it exists,
    with the new property values as its parameters, and it also re-renders the component.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we change the state of the owner of a component, then that sends
    a signal that the properties of the components it owns might have changed, so
    it calls the `componentWillReceiveProps` method and re-renders the components
    it owns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to demonstrate the `componentWillReceiveProps` method.
    We will create a button whose value increments every second. Here is the code
    to create a new container element. Place it in the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for our example. Place this code in the `script` tag that
    will be compiled by Babel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![componentWillReceiveProps(nextProps)](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the code, we are changing the state of the owner every second after the initial
    rendering has occurred. Whenever the state changes, the `componentWillReceieveProps`
    object of `ButtonComponent` is called. Inside the `componentWillReceieveProps`
    object, we can use `this.props` to access the previous values of the properties.
    The button is rendered whenever its owner's state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `componentWillReceieveProps` is called before the component is
    re-rendered, so we can make any state changes we want inside it.
  prefs: []
  type: TYPE_NORMAL
- en: shouldComponentUpdate(nextProps, nextState)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shouldComponentUpdate(nextProps, nextState)` method is called before the
    `render` method is called, that is, before rendering happens. If this method returns
    `false`, then rendering is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this method is not called before forced updates or initial rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is a forced update?**'
  prefs: []
  type: TYPE_NORMAL
- en: React provides a `forceUpdate` method inside a component, which renders the
    component when called. This can be used when the `render()` method depends on
    some other data instead of just `this.props` and `this.state`, as changes to other
    data don't trigger the `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillUpdate(nextProps, nextState)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `componentWillUpdate(nextProps, nextState)` method is invoked immediately
    before rendering when new props or state are being received. This method is not
    called for the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you cannot use `this.setState` inside this method.
  prefs: []
  type: TYPE_NORMAL
- en: componentDidUpdate(prevProps, prevState)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `componentDidUpdate(prevProps, prevState)` method is invoked immediately
    after the component's updates are flushed to the real DOM. This method is not
    called for the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillUnmount()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `componentWillUnmount()` method is invoked immediately before a component
    is unmounted from the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when multiple components share the same code; in such cases,
    we can use mixins instead of writing the same code again and again.
  prefs: []
  type: TYPE_NORMAL
- en: A **mixin** is an object that holds component methods that can be easily plugged
    in to any component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to demonstrate mixins. Here is the code to create
    a new container element. Place it in the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is the code for our example. Place it in the `script` tag that will be
    compiled by Babel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the code on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixins](img/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is the output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixins](img/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we've created two mixins and added them to `HeadingComponent`. These mixins
    can be used in any number of methods. Mixins simply increase code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Using Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refs** are used inside components to return references to real DOM elements
    rendered by React. So, instead of assigning an `id` or `class` value to elements,
    we can assign refs. It''s easier to get references to real DOM elements using
    refs than `id` or `class` attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a basic example of how to use refs by creating a form. First,
    create a container element and place it inside the `body` tag. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the form, which uses refs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code on the webpage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Refs](img/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we enter `Hello World` in the text field and click on the button, then the
    output of the console is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we're assigning a `ref` attribute to the button element.
    To refer to the button in the methods of the component, we use `this.refs`.
  prefs: []
  type: TYPE_NORMAL
- en: ReactDOMServer.renderToStaticMarkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we used React on the server side to generate HTML.
    The HTML generated by React on the server and client side contains `data-reactid`
    attributes, which are used by React internally. On the client side, it makes sense
    to have `data-reactid`, as it is used during reconciliation and other processes
    and features.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering what the point of adding this attribute on the server
    side is. Actually, it is added so that if you call `ReactDOM.render()` on the
    client side on a node that already has React server-rendered markup, React will
    preserve it and only reconcile it.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want `data-reactid` attributes to be generated on the server side,
    you can use `renderToStaticMarkup` instead of `renderToString`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned React up to an intermediate level by covering in
    depth its features and components, JSX, using it for server-side rendering, reconciliation,
    and so on. We also learned miscellaneous features such as mixins and refs. Now,
    you should have a basic understanding of how and when to integrate React into
    your websites.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn React in more depth by building an application
    that uses the Flux and SPA architectures.
  prefs: []
  type: TYPE_NORMAL

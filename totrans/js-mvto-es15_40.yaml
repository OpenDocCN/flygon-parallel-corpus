- en: Chapter 12. New Features of Angular 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Angular 2的新功能
- en: Angular 1 was based on the MVC architecture whereas Angular 2 is based on a
    components-and-services architecture. Angular 1 and Angular 2 are completely different
    in terms of architecture and APIs, so previous knowledge of Angular 1 is unlikely
    to help you much in learning Angular 2\. In this chapter, we will learn Angular
    2 without comparing it with Angular 1 as doing that will create confusion and
    is unnecessary. Even if you don't have knowledge about Angular 1, you can continue
    with this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1基于MVC架构，而Angular 2基于组件和服务架构。Angular 1和Angular 2在架构和API方面完全不同，因此先前对Angular
    1的了解不太可能对学习Angular 2有所帮助。在本章中，我们将学习Angular 2，而不是将其与Angular 1进行比较，因为这样做会造成混淆并且是不必要的。即使您对Angular
    1没有了解，也可以继续学习本章。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Web components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web组件
- en: The Angular 2 architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2架构
- en: Template language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板语言
- en: Component inputs and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件输入和输出
- en: The component life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: Services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: And much more...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多...
- en: The Angular 2 architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2架构
- en: Angular 2 is a framework for building the client side of web applications, based
    on a services-and-components architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是一个基于服务和组件架构构建Web应用程序客户端的框架。
- en: An Angular 2 application is composed of a view and various services. Services
    are simple JavaScript objects that hold application logic and state. Services
    should be reusable. Views consume services, and services can also interact with
    each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2应用程序由视图和各种服务组成。服务是简单的JavaScript对象，保存应用程序逻辑和状态。服务应该是可重用的。视图使用服务，并且服务也可以相互交互。
- en: Views and services are loosely coupled so that an Angular 2 view can be used
    with any other architecture, such as Flux. Similarly, services can be used with
    any other view, such as React.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和服务松散耦合，因此Angular 2视图可以与任何其他架构一起使用，例如Flux。同样，服务可以与任何其他视图一起使用，例如React。
- en: Angular 2 views are based on component-oriented architecture. In component-oriented
    architecture, the application UI is divided into reusable components. A component
    has a UI with code to update the UI and handle user actions on the UI. A custom
    tag is associated with a component, and whenever the custom tag appears, a new
    instance of the component is created and rendered. So, we can say that component-oriented
    architecture is architecture for the view of an application. Actually, the components
    consume the services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2视图基于组件导向架构。在组件导向架构中，应用程序UI被划分为可重用组件。组件具有UI和用于更新UI和处理UI上的用户操作的代码。自定义标签与组件关联，每当自定义标签出现时，都会创建和呈现组件的新实例。因此，我们可以说组件导向架构是应用程序视图的架构。实际上，组件使用服务。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous two chapters, we studied React, which is also based on component-oriented
    architecture, since with React, we build an application as a set of components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了React，它也是基于组件导向架构，因为使用React，我们构建一个应用程序作为一组组件。
- en: 'Here is a diagram from the official Angular 2 website ([https://angular.io](https://angular.io))
    that shows the complete architecture of Angular 2:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自官方Angular 2网站（[https://angular.io](https://angular.io)）的图表，显示了Angular 2的完整架构：
- en: '![The Angular 2 architecture](img/00151.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2架构](img/00151.jpeg)'
- en: Here, you can see that the UI of a **Component** is defined using a **Template**.
    Templates are written using template HTML, that is, a combination of HTML and
    many other tokens. A component also holds the UI state and event handlers of the
    UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到**组件**的UI是使用**模板**定义的。模板使用模板HTML编写，即HTML和许多其他标记的组合。组件还保存UI状态和UI的事件处理程序。
- en: We shouldn't store application logic and state inside a component, as it will
    have an impact on code reusability and cause issues while developing large and
    complex apps. Application state and logic should be stored in services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该将应用程序逻辑和状态存储在组件内，因为这将影响代码的可重用性，并在开发大型和复杂的应用程序时引起问题。应用程序状态和逻辑应该存储在服务中。
- en: Angular 2 only implements one-way data binding. This makes large and complex
    apps easier to debug.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2只实现单向数据绑定。这使得大型和复杂的应用程序更容易调试。
- en: Services are injected into specific components that need them, and not all the
    components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务被注入到需要它们的特定组件中，而不是所有组件。
- en: Introducing web components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Web组件
- en: Before we get into web components, you need to know why we are learning about
    them. Well, we are learning about web components because Angular 2 components
    utilize shadow DOM and templates, which are a part of web components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Web组件之前，您需要知道为什么我们要学习它们。嗯，我们学习Web组件是因为Angular 2组件利用了影子DOM和模板，这是Web组件的一部分。
- en: In a nutshell, web components are a collection of four different browser specifications
    that enable the creation of reusable components in web pages. These four specifications
    are **HTML imports**, **shadow DOM**, **templates**, and **custom elements**.
    They can be used together or separately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Web组件是在网页中创建可重用组件的四种不同浏览器规范的集合。这四个规范是**HTML导入**，**影子DOM**，**模板**和**自定义元素**。它们可以一起或分开使用。
- en: Web components provide native implementation of component-oriented architecture.
    A component created using web components is called a web component as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件提供了组件导向架构的本地实现。使用Web组件创建的组件也被称为Web组件。
- en: Before we learn about web components, let's consider a project for demonstration
    purposes. Create a directory named `web-components`, and then create a file named
    `index.html` in it. Web components have pretty poor browser support, so let's
    download `webcomponents.js polyfill`. Download the `webcomponents.js` file from
    [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    and place it in the `web-components` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习Web组件之前，让我们考虑一个用于演示目的的项目。创建一个名为`web-components`的目录，然后在其中创建一个名为`index.html`的文件。Web组件的浏览器支持相当差，所以让我们下载`webcomponents.js
    polyfill`。从[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)下载`webcomponents.js`文件，并将其放在`web-components`目录中。
- en: 'Now, place this code in the `index.html` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此代码放入`index.html`文件中：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's now look at an overview of shadow DOM, templates, and custom elements
    by building a component to display a card that has an image, title, and description.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过构建一个用于显示具有图像、标题和描述的卡片的组件来概述影子DOM、模板和自定义元素。
- en: Templates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: '**Templates** are used to define reusable code. A template is defined using
    the `<template>` tag. Code for the template is placed inside this tag. We can
    place any tag, such as `<script>` and `<style>`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**用于定义可重用的代码。模板使用`<template>`标签进行定义。模板的代码放在这个标签内。我们可以放置任何标签，比如`<script>`和`<style>`。'
- en: The code inside the `<template>` tag is only parsed, not rendered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<template>`标签内的代码只被解析，而不被渲染。'
- en: 'Here is an example of how to create a template. Place this code in the `body`
    tag:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建模板的示例。将此代码放在`body`标签中：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the template holds the UI code for the card component. Now, if you open
    the `index.html` file in a browser, you won't see anything because the `<template>`
    tag is only parsed, not rendered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板保存了卡片组件的UI代码。现在，如果您在浏览器中打开`index.html`文件，您将看不到任何内容，因为`<template>`标签只被解析，而不被渲染。
- en: Custom elements
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义元素
- en: '**Custom elements** let us define new types of HTML elements (that is, new
    types of HTML tags). When we use a tag name that''s not recognized by the browser,
    the browser simply treats it like a `<span>` tag. But when we register a `custom`
    tag, it gets recognized by the browser. It can inherit other elements, lets us
    perform different operations on different stages of the element lifecycle, and
    much more.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义元素**让我们定义新类型的HTML元素（即，新类型的HTML标签）。当我们使用浏览器不认识的标签名时，浏览器会简单地将其视为`<span>`标签。但是当我们注册一个`custom`标签时，它会被浏览器识别。它可以继承其他元素，让我们在元素生命周期的不同阶段执行不同的操作，等等。'
- en: Let's create a `custom` element for our component. Wherever the tag appears,
    a new instance of the component will be displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的组件创建一个`custom`元素。无论标签出现在何处，都会显示组件的新实例。
- en: 'Here is the code to display the `custom` element. Place it in the `<body>`
    tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于显示`custom`元素的代码。将其放在`<body>`标签中：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have to use the `-` character in the custom element name. This is compulsory
    because this restriction allows the parser to distinguish custom elements from
    regular elements and ensures forward compatibility when new tags are added to
    HTML. Here, we are passing properties of the component as data attributes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在自定义元素名称中使用`-`字符。这是强制性的，因为这个限制允许解析器区分自定义元素和常规元素，并确保在向HTML添加新标签时的向前兼容性。在这里，我们正在将组件的属性作为数据属性传递。
- en: 'Now, let''s define `<custom-card>` as a custom element and place the template
    code inside the tag whenever a new instance of `<custom-card>` is created. To
    do that, place this code in the `<script>` tag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`<custom-card>`定义为自定义元素，并在创建`<custom-card>`的新实例时将模板代码放在标签内。为此，将此代码放在`<script>`标签中：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: By default, custom elements inherit methods and properties of `HTMLElement`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，自定义元素继承`HTMLElement`的方法和属性。
- en: To register a custom element, we need to use the `document.registerElement`
    method. The first argument is the custom tag name and the second argument is an
    optional object. This optional object can take a property called **prototype**.
    The `prototype` property defines the HTML element it inherits, that is, the properties
    and methods of the HTML element it inherits. By default, it's assigned to `Object.create(HTMLElement.prototype)`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注册自定义元素，我们需要使用`document.registerElement`方法。第一个参数是自定义标签名称，第二个参数是一个可选对象。这个可选对象可以有一个名为**prototype**的属性。`prototype`属性定义了它继承的HTML元素，即它继承的HTML元素的属性和方法。默认情况下，它被分配为`Object.create(HTMLElement.prototype)`。
- en: We can also add new properties and methods to our custom element by adding new
    properties and methods to the object assigned to the `prototype` property.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以通过向分配给`prototype`属性的对象添加新属性和方法来向自定义元素添加新属性和方法。
- en: Here, we've added a method called `createdCallback`, which is invoked whenever
    an instance of a custom element is created, that is, either an instance created
    using JavaScript or HTML.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`createdCallback`的方法，每当创建自定义元素的实例时调用，即使用JavaScript或HTML创建的实例。
- en: Inside `createdCallback`, we are retrieving our template and setting the image
    source, title, and description and then appending it to the custom element by
    creating a clone of it, as many custom elements will share the same template.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`createdCallback`中，我们正在检索我们的模板并设置图像源、标题和描述，然后通过创建它的克隆将其附加到自定义元素，因为许多自定义元素将共享相同的模板。
- en: 'Now, if you open `index.html` in a browser, you will see this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中打开`index.html`，您将看到这个输出：
- en: '![Custom elements](img/00152.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![自定义元素](img/00152.jpeg)'
- en: Shadow DOM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影子DOM
- en: '**Shadow DOM** allows HTML elements to get a new kind of node called a shadow
    root associated with them. An element that has a shadow root associated with it
    is called a shadow host. The content of a shadow host isn''t rendered; the content
    of the shadow root is rendered instead. A shadow root can have another shadow
    root below it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**影子DOM**允许HTML元素获得一种称为影子根的新节点。具有与之关联的影子根的元素称为影子宿主。影子宿主的内容不会被渲染；相反，会渲染影子根的内容。影子根可以有另一个影子根在其下面。'
- en: The benefit of shadow DOM is that CSS styles defined inside a shadow root won't
    affect its parent document, and CSS styles defined outside the shadow root will
    not affect the elements inside the shadow root. This is useful to define styles
    specific to the components. In short, we can say that shadow DOM provides style
    encapsulation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 影子DOM的好处是，在影子根内定义的CSS样式不会影响其父文档，而在影子根外部定义的CSS样式也不会影响影子根内的元素。这对于定义特定于组件的样式非常有用。简而言之，我们可以说影子DOM提供了样式封装。
- en: Style encapsulation is not the only benefit of shadow DOM. The HTML inside the
    shadow root is protected from accidental modification from JavaScript. We can
    still inspect the shadow root in browser developer tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 样式封装不是影子DOM的唯一好处。影子根内部的HTML受到来自JavaScript的意外修改的保护。我们仍然可以在浏览器开发工具中检查影子根。
- en: Many native element, such as `<video>` and `<audio>`, have a shadow root, but
    when you inspect it, you won't see the shadow root. Browsers by default hide the
    shadow roots of these elements. To see their shadow roots, you need to change
    browser-specific settings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多原生元素，如`<video>`和`<audio>`，都有一个影子根，但当您检查它时，您看不到影子根。浏览器默认隐藏这些元素的影子根。要查看它们的影子根，您需要更改特定于浏览器的设置。
- en: 'Let''s modify the previous custom element code to render the template inside
    shadow DOM. Replace the previous `createdCallback` method with this one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改以前的自定义元素代码，以在影子DOM内呈现模板。用以下方法替换以前的`createdCallback`方法：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, instead of appending the template code directly to the custom element,
    we created a shadow root using `createShadowRoot` and appended the template code
    to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是直接将模板代码附加到自定义元素，而是使用`createShadowRoot`创建了一个影子根，并将模板代码附加到其中。
- en: Setting up an Angular 2 project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Angular 2项目
- en: Angular 2 code can be written in JavaScript, TypeScript, or Dart. In case you
    are writing Angular 2 code in TypeScript or Dart, you will need to transpile the
    code to JavaScript before serving to the client. We will use JavaScript to write
    Angular 2 code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2代码可以用JavaScript、TypeScript或Dart编写。如果您在TypeScript或Dart中编写Angular 2代码，您需要在提供给客户端之前将代码转译为JavaScript。我们将使用JavaScript来编写Angular
    2代码。
- en: Create a directory named `angular2-demo`. Then, inside the directory, create
    the `app.js` and `package.json` files. Then, create a directory named `public`,
    and inside the directory, create four more directories named `html`, `js`, `componentTemplates`,
    and `componentStyles`. Now, create a file named `index.html` and place it in the
    `html` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`angular2-demo`的目录。然后，在该目录中，创建`app.js`和`package.json`文件。然后，创建一个名为`public`的目录，并在该目录中创建四个更多的目录，分别命名为`html`、`js`、`componentTemplates`和`componentStyles`。现在，创建一个名为`index.html`的文件，并将其放在`html`目录中。
- en: Then, download `angular2-polyfills.js`, `Rx.umd.js`, and `angular2-all.umd.js`
    from [https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)
    and place them in the `angular2-demo/js` directory. These files are what they
    sound like. You can also enqueue the CDN links directly if you want to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从[https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)下载`angular2-polyfills.js`、`Rx.umd.js`和`angular2-all.umd.js`，并将它们放在`angular2-demo/js`目录中。这些文件就是它们听起来的样子。如果您愿意，也可以直接排队CDN链接。
- en: 'Inside the `index.html` file, place this starting code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，放入以下起始代码：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the `app.js` file, place this code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，放入此代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the server-side code. It's self-explanatory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器端代码。它是不言自明的。
- en: 'Now, in the `package.json` file, place this code and run `npm install` to download
    the `express` package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`package.json`文件中，放入此代码并运行`npm install`以下载`express`包：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To start the server, run `node app.js`. Then, open the app using `localhost:8080`
    as the address in a browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务器，请运行`node app.js`。然后，在浏览器中使用`localhost:8080`作为地址打开应用程序。
- en: Angular 2 fundamentals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2基础知识
- en: An Angular 2 application is completely split into components. Technically, an
    Angular 2 component is a reusable `custom` tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2应用程序完全分为组件。从技术上讲，Angular 2组件是一个可重用的`custom`标签，它是可变的，并且封装了嵌入状态，即状态或属性的更改将改变UI。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that Angular 2 doesn't register the custom tag name as a custom element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular 2不会将自定义标签名称注册为自定义元素。
- en: All the components of the application are arranged in a tree structure, with
    a component as the root node.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的所有组件都以树结构排列，其中一个组件作为根节点。
- en: 'Here is an example of how to create a component. It creates a card component
    that displays an image, title, and description. Place this code in the `<script>`
    tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建组件的示例。它创建了一个显示图像、标题和描述的卡片组件。将此代码放入`<script>`标签中：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create a file named `card-template.html`, and place it in the `componentTemplates`
    directory. Place this code in the file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`card-template.html`的文件，并将其放在`componentTemplates`目录中。将此代码放入文件中：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, create a file named `card-style.css` and place it in the `componentStyles`
    directory. Place this code in the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个名为`card-style.css`的文件，并将其放在`componentStyles`目录中。将此代码放入文件中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is how these three code snippets work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个代码片段的工作原理：
- en: A component needs to be created by chaining `Component` and `Class` methods
    that belong to an `ng.core` object.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要通过链接属于`ng.core`对象的`Component`和`Class`方法来创建组件。
- en: The `Component` method takes a configuration object with various properties,
    whereas the `Class` method takes an object with component lifecycle methods, constructors,
    and UI action handlers.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component`方法接受一个具有各种属性的配置对象，而`Class`方法接受一个具有组件生命周期方法、构造函数和UI操作处理程序的对象。'
- en: Here, the configuration properties we've provided are `selector`, `inputs`,
    `templateUrl`, and `styleUrls`. The `selector` property is used to define the
    custom tag for the component. The `inputs` property is used to define the attributes
    that the custom tag takes. The `templateUrl` property is used to define the file
    containing the template of the component. You can also use `template` if you want
    to inline the template code. Finally, `styleUrls` is used to define the CSS files
    containing the style for the component. You can also use the `styles` property
    to inline CSS code, or you can define CSS using a `<style>` tag inside the template
    itself. CSS defined in any of these three ways won't affect other components,
    that is, it's encapsulated to the component itself.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们提供的配置属性是`selector`、`inputs`、`templateUrl`和`styleUrls`。`selector`属性用于定义组件的自定义标签。`inputs`属性用于定义自定义标签所需的属性。`templateUrl`属性用于定义包含组件模板的文件。如果要内联模板代码，也可以使用`template`。最后，`styleUrls`用于定义包含组件样式的CSS文件。您还可以使用`styles`属性来内联CSS代码，或者可以在模板本身内部使用`<style>`标签来定义CSS。以这三种方式定义的CSS不会影响其他组件，即它是封装在组件本身的。
- en: In the `Class` method, we will have to provide the `constructor` method even
    if it does nothing. It's invoked during the construction of a new instance of
    the component. By construction of the component, I mean the construction of the
    component in memory—not resolving attributes, resolving its children, rendering
    its view, and so on. The primary use of the `constructor` method is to inject
    services into the component. Services cannot be injected automatically as we may
    sometimes need to initialize services for every component, and Angular is unaware
    of how to do this. The `constructor` method has access to the state of the component
    but not its properties. Here, we shouldn't do any heavy work or something else
    that would slow down or cause the construction of the component to fail. `constructor`
    is not a component lifecycle method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Class`方法中，即使它什么也不做，我们也必须提供`constructor`方法。它在构建组件的新实例时被调用。构建组件时，我指的是在内存中构建组件，而不是解析属性、解析其子级、渲染其视图等等。`constructor`方法的主要用途是将服务注入到组件中。服务不能自动注入，因为有时我们可能需要为每个组件初始化服务，而Angular不知道如何做到这一点。`constructor`方法可以访问组件的状态，但不能访问其属性。在这里，我们不应该做任何繁重的工作或其他可能导致组件构建失败或变慢的事情。`constructor`不是组件的生命周期方法。
- en: Then, we have the component template code. In this template file, we are simply
    rendering the properties passed to the component. To render anything that's in
    the component state, we need to use the `{{}}` token.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有组件模板代码。在这个模板文件中，我们只是渲染传递给组件的属性。要渲染组件状态中的任何内容，我们需要使用`{{}}`标记。
- en: Let's create another component called `Cards`, which displays a list of cards.
    It gets information about cards from a service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`Cards`的组件，它显示一个卡片列表。它从一个服务中获取有关卡片的信息。
- en: 'Place this code in the `<script>` tag of the `index.html` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入`index.html`文件的`<script>`标签中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, create a file named `cards-template.html` in the `componentTemplates`
    directory and place this code in it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`componentTemplates`目录中创建一个名为`cards-template.html`的文件，并将以下代码放入其中：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create a file named `app-template.html` in the `componentTemplates` directory
    and place this code in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`componentTemplates`目录中创建一个名为`app-template.html`的文件，并将以下代码放入其中：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in the `<body>` tag of the `index.html` file, place this code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`index.html`文件的`<body>`标签中放入以下代码：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is how these four code snippets work:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个代码片段的工作方式如下：
- en: To create a service, we need to use the `ng.core.Class` method. It takes an
    object with the `constructor` method and other methods or properties that the
    service exposes. While injecting the service into other services or components,
    a new instance of the service is created and injected. While creating a new instance
    of a service, the `constructor` method is called. We have to provide this method
    even if it doesn't do anything. The primary purpose of this method is to inject
    services that this service depends on. Here, our `CardsService` method is not
    dependent on any other service, so we have no code inside the `constructor` method.
    Then, we defined a `getCards` method, which returns data of three different cards
    to display.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个服务，我们需要使用`ng.core.Class`方法。它接受一个带有`constructor`方法和其他方法或属性的对象，该服务公开。在将服务注入到其他服务或组件时，将创建并注入服务的新实例。在创建服务的新实例时，将调用`constructor`方法。即使`constructor`方法什么也不做，我们也必须提供这个方法。这个方法的主要目的是注入此服务所依赖的服务。在这里，我们的`CardsService`方法不依赖于任何其他服务，所以我们在`constructor`方法中没有任何代码。然后，我们定义了一个`getCards`方法，它返回三张不同卡片的数据以显示。
- en: Then, we created a `Cards` component. It takes the data from `CardsService`
    and renders a `Card` component for each card data. While creating the `Cards`
    component, we provide `viewProviders` and `directives` properties to the configuration
    object. `viewProviders` is the list of services the component is dependent on,
    and `directives` is the list of other components this component renders. Here,
    you can see that instead of directly assigning a function to the `constructor`
    property, we are assigning an array with a list of services the component depends
    upon and the last array item as the actual function. This is the format of injecting
    services into components. Inside the `constructor` method, we store references
    to the methods or properties of the service that the component needs, that is,
    we can use services inside the `constructor` method. We will learn more about
    `viewProviders` later on. The `this` keyword in any of the methods passed to the
    `Class` method points to the state of the component. After a component instance
    has been created, whenever the component state changes, the template bindings
    are updated. We have another method here, called `ngOnInit`. It's a lifecycle
    method that's invoked after a new instance of the component has been created and
    its attributes resolved. Inside this, we call the `getCards` method and store
    the returned value inside the `cards` property of the state. Note that the attributes
    passed to a component tag are accessible using the `this` keyword after the component
    instance has been created.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`Cards`组件。它从`CardsService`获取数据，并为每个卡片数据呈现一个`Card`组件。在创建`Cards`组件时，我们向配置对象提供了`viewProviders`和`directives`属性。`viewProviders`是组件依赖的服务列表，`directives`是该组件呈现的其他组件列表。在这里，您可以看到，我们没有直接将函数分配给`constructor`属性，而是将一个包含组件依赖的服务列表和最后一个数组项作为实际函数的数组分配给它。这是将服务注入组件的格式。在`constructor`方法中，我们存储组件需要的服务的方法或属性的引用，也就是说，我们可以在`constructor`方法中使用服务。我们将在后面学习更多关于`viewProviders`的知识。传递给`Class`方法的任何方法中的`this`关键字都指向组件的状态。创建组件实例后，每当组件状态发生变化时，模板绑定都会更新。这里还有另一个方法，叫做`ngOnInit`。这是一个生命周期方法，在创建组件的新实例并解析其属性后调用。在其中，我们调用`getCards`方法，并将返回的值存储在状态的`cards`属性中。请注意，在创建组件实例后，可以使用`this`关键字访问传递给组件标签的属性。
- en: Inside the template of `CardsComponent`, we are using the `*ngFor` directive
    to display the cards. We will learn more about directives later.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CardsComponent`的模板中，我们使用`*ngFor`指令来显示卡片。我们将在后面学习更多关于指令的知识。
- en: Then, we create an `App` component, which acts as the root of our component.
    Inside this component, we are displaying the `Cards` component.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`App`组件，它充当我们组件的根。在这个组件内部，我们显示了`Cards`组件。
- en: Finally, we initialize the application. An Angular 2 application is initialized
    explicitly. While initializing it, we need to provide a reference to the root
    component. This is done to ensure that applications are composed of nested components
    all the way down. The root component is the one that's added to the `<body>` tag.
    Adding tags of other components to the body tag will not do anything.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们初始化应用程序。Angular 2应用程序需要显式初始化。在初始化时，我们需要提供对根组件的引用。这是为了确保应用程序由嵌套组件组成。根组件是添加到`<body>`标签中的组件。将其他组件的标签添加到body标签中将不起作用。
- en: 'Now, if you refresh your `localhost:8080` page in your browser, you will see
    this output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中刷新`localhost:8080`页面，您将看到以下输出：
- en: '![Angular 2 fundamentals](img/00153.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2 fundamentals](img/00153.jpeg)'
- en: Styling components and shadow DOM
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件样式和影子DOM
- en: Earlier, we saw that there are three ways of defining styles specific to components
    (styles encapsulated in the component template scope). A component's CSS doesn't
    even affect the components it owns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了定义特定于组件的样式的三种方法（样式封装在组件模板范围内）。组件的CSS甚至不会影响它拥有的组件。
- en: Angular 2 doesn't use shadow DOM by default; instead, it uses a different technique
    to achieve style encapsulation. This is due to the lack of browser support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2默认不使用影子DOM；相反，它使用了一种不同的技术来实现样式封装。这是由于缺乏浏览器支持。
- en: 'By default, Angular 2 modifies the CSS selector in such a way that it only
    targets the elements in the component, and it then places the CSS in the `<head>`
    tag of the page. If you inspect our current app using browser developer tools,
    you will see this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 2会修改CSS选择器，以便只针对组件中的元素，并将CSS放在页面的`<head>`标签中。如果使用浏览器开发者工具检查我们当前的应用程序，您将看到这个：
- en: '![Styling components and shadow DOM](img/00154.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Styling components and shadow DOM](img/00154.jpeg)'
- en: Here, you can see that the CSS has been modified and inserted into the `<head>`
    tag.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到CSS已被修改并插入到`<head>`标签中。
- en: To force Angular 2 to use shadow DOM, we need to assign the encapsulation property
    of the component configuration object to `ng.core.ViewEncapsulation.Native`. By
    default, it's assigned to `ng.core.ViewEncapsulation.Emulated`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制Angular 2使用影子DOM，我们需要将组件配置对象的封装属性分配为`ng.core.ViewEncapsulation.Native`。默认情况下，它分配为`ng.core.ViewEncapsulation.Emulated`。
- en: 'When you inspect the app after assigning the encapsulation property of the
    `Card` and `Cards` components to `ng.core.ViewEncapsulation.Native`, you will
    see something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将`Card`和`Cards`组件的封装属性分配为`ng.core.ViewEncapsulation.Native`后，检查应用程序时，您将看到如下内容：
- en: '![Styling components and shadow DOM](img/00155.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Styling components and shadow DOM](img/00155.jpeg)'
- en: Here, you can see that shadow DOM was used to achieve style encapsulation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到使用影子DOM来实现样式封装。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you don't want style encapsulation for a component, you can assign the
    encapsulation property to `ng.core.ViewEncapsulation.None`. In this case, all
    of the CSS will be placed directly in the `<head>` tag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望为组件进行样式封装，可以将封装属性分配为`ng.core.ViewEncapsulation.None`。在这种情况下，所有的CSS都将直接放在`<head>`标签中。
- en: Angular 2 change detection
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2变更检测
- en: '**Change detection** is the process of detecting component state change. The
    state of a component is stored and manipulated using the `this` keyword. Therefore,
    there is no direct way for Angular 2 to detect when the state changes. So, Angular
    2 uses complex algorithms and third-party libraries to detect state changes.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更检测**是检测组件状态变化的过程。组件的状态是使用`this`关键字存储和操作的。因此，Angular 2没有直接的方法来检测状态的变化。因此，Angular
    2使用复杂的算法和第三方库来检测状态变化。'
- en: The first thing Angular 2 does for detecting state changes is that it pretends
    that all the changes happen asynchronously. Then, it uses the `zone.js` library
    to monitor browser events, timers, AJAX requests, WebSockets, and other asynchronous
    things that are supported by `zone.js`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2首先要做的是检测状态变化，它假装所有的变化都是异步发生的。然后，它使用`zone.js`库来监视浏览器事件、定时器、AJAX请求、WebSockets以及其他`zone.js`支持的异步操作。
- en: Now, whenever any of these asynchronous activities takes place, it checks everything
    that could change, including object properties and array elements of the `this`
    keyword of all the components from the root node; if any change is detected, then
    the template bindings of the component are updated. Angular 2 doesn't simply re-render
    the whole component. Instead, it checks for the bindings that have changed and
    selects and updates them specifically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当发生这些异步活动中的任何一个，它都会检查可能发生变化的所有内容，包括根节点中所有组件的`this`关键字的对象属性和数组元素；如果检测到任何变化，那么组件的模板绑定就会被更新。Angular
    2不仅仅重新渲染整个组件。相反，它会检查已经改变的绑定，并选择并更新它们。
- en: Some components can have a lot of state data, and checking the state for every
    asynchronous operation will unnecessarily impact app performance if their state
    has not changed. Therefore, Angular 2 provides an option to mark such kinds of
    components so that it does not check their states unless the component itself
    tells Angular 2 to check its state during the next detection cycle, that is, when
    the next asynchronous activity occurs. Let's look at an example to demonstrate
    this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件可能有大量的状态数据，如果它们的状态没有改变，为每个异步操作检查状态将不必要地影响应用程序的性能。因此，Angular 2提供了一种标记这种类型的组件的选项，这样它就不会检查它们的状态，除非组件本身告诉Angular
    2在下一个检测周期中检查它的状态，也就是在下一个异步活动发生时。让我们看一个例子来演示这一点。
- en: 'Place this code above the `App` component code in the `<script>` tag of the
    `index.html` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码放在`index.html`文件的`<script>`标签中`App`组件代码的上面：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add `SampleComponent1` to the `directives` array of the `App` component.
    So now, the `App` component''s code should be this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`SampleComponent1`添加到`App`组件的`directives`数组中。所以现在，`App`组件的代码应该是这样的：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, add this code to the end of the `app-template.html` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这段代码添加到`app-template.html`文件的末尾：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is how these three code snippets work:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这三个代码片段的工作原理：
- en: In this example, we are displaying a value that gets incremented every 2 seconds
    and the template is re-rendered to display the updated value.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们显示一个每2秒递增一次的值，并且模板会重新渲染以显示更新后的值。
- en: At first, we create a component called `SampleComponent1`. It simply displays
    `value`. We have set the `changeDetection` property to `ng.core.ChangeDetectionStrategy.Detached`,
    which tells Angular 2 to not check its state change. By default, the `changeDetection`
    property is assigned to `ng.core.ChangeDetectionStrategy.Default`, which tells
    Angular 2 to check its state change during every change-detection cycle. We then
    inject the `ng.core.ChangeDetectorRef` service into the component, which provides
    various APIs related to change detection. And then, in the `ngOnInit` method,
    we increment the value of `value` every 2 seconds, after which we call the `markForCheck`
    method of `ng.core.ChangeDetectorRef`, which tells Angular 2 to check for changes
    in the state of the component during the next change-detection cycle. `markForCheck`
    will make Angular 2 check for a change in state for the next detection cycle only,
    not for the ones after that.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`SampleComponent1`的组件。它简单地显示`value`。我们将`changeDetection`属性设置为`ng.core.ChangeDetectionStrategy.Detached`，这告诉Angular
    2不要检查它的状态变化。默认情况下，`changeDetection`属性被分配给`ng.core.ChangeDetectionStrategy.Default`，这告诉Angular
    2在每次变更检测周期中检查它的状态变化。然后，我们将`ng.core.ChangeDetectorRef`服务注入到组件中，它提供了与变更检测相关的各种API。然后，在`ngOnInit`方法中，我们每2秒递增`value`的值，之后我们调用`ng.core.ChangeDetectorRef`的`markForCheck`方法，这告诉Angular
    2在下一个变更检测周期中检查组件状态的变化。`markForCheck`只会让Angular 2在下一个检测周期中检查状态的变化，而不是在之后的周期中检查。
- en: Then, we simply display `SampleComponent1` in the `App` component.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`App`组件中简单地显示`SampleComponent1`。
- en: If a component depends only on its inputs and/or UI events or if you want a
    component's state change, check only whether its inputs have changed or events
    have been fired; then, you can assign `changeDetection` to `ng.core.ChangeDetectionStrategy.OnPush`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件只依赖于它的输入和/或UI事件，或者如果你想要一个组件的状态变化，只需检查它的输入是否已经改变或事件是否已经触发；然后，你可以将`changeDetection`分配给`ng.core.ChangeDetectionStrategy.OnPush`。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If at any time you want to force a change-detection cycle instead of waiting
    for an asynchronous operation to happen, you can call the `detectChanges` method
    of the `ng.core.ChangeDetectorRef` service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在任何时候强制进行一次变更检测周期，而不是等待异步操作发生，你可以调用`ng.core.ChangeDetectorRef`服务的`detectChanges`方法。
- en: Understanding view children and content children
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解视图子元素和内容子元素
- en: Elements present inside the tags of a component are called **content children**,
    and elements present inside the template of a component are called **view children**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组件标签内的元素称为**内容子元素**，而组件模板内的元素称为**视图子元素**。
- en: To display the content children of a component in the component's view, we need
    to use the `<ng-content>` tag. Let's look at an example of this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件的视图中显示内容子元素，我们需要使用`<ng-content>`标签。让我们看一个例子。
- en: 'Place this code above the `App` component''s code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码放在`App`组件代码的上面：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, change the `App` component''s code to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`App`组件的代码更改为这样：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To the end of the `app-template.html` file, add this code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app-template.html`文件的末尾添加此代码：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of this code is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '![Understanding view children and content children](img/00156.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![理解视图子代和内容子代](img/00156.jpeg)'
- en: 'This is how these three code snippets work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个代码片段的工作原理：
- en: In the `App` component's template file, we add a `<list>` tag, which displays
    a list. And inside its opening and closing tags, we define the individual list
    items that it should display.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件的模板文件中，我们添加了一个`<list>`标签，显示一个列表。在其开放和关闭标签内，我们定义了它应该显示的各个列表项。
- en: We create `ListItem` and `List` components that are bound to `<list>` and `<item>`
    tags, respectively.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了绑定到`<list>`和`<item>`标签的`ListItem`和`List`组件。
- en: We add `List` component to the `directives` property of the `App` component,
    not `List`, because the `<list>` tag is present in the template of the `App` component,
    and the `App` component is responsible for creating its instances.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`List`组件添加到`App`组件的`directives`属性中，而不是`List`，因为`<list>`标签存在于`App`组件的模板中，而`App`组件负责创建其实例。
- en: The `App` component looks for the `<ng-content>` tag in the template of the
    `List` component and renders the `List` component instances there.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App`组件在`List`组件的模板中查找`<ng-content>`标签，并在那里呈现`List`组件的实例。'
- en: '`<ng-content>` takes an optional `select` attribute that''s assigned to a CSS
    selector that indicates which elements of the content children we want to display.
    There can be multiple `<ng-content>` tags in a template. If the `select` attribute
    has not been provided, then all the content children will be rendered. Here, the
    `select` attribute is not required; we are using it just for demonstration.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<ng-content>`接受一个可选的`select`属性，该属性分配给指示我们要显示的内容子代元素的CSS选择器。模板中可以有多个`<ng-content>`标签。如果未提供`select`属性，则将呈现所有内容子代。这里，`select`属性不是必需的；我们只是用它来进行演示。'
- en: Getting the reference of components of content children and view children
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取内容子代和视图子代的组件引用
- en: To get access to the reference of components of view children or content children,
    we can use the `ng.core.ContentChildren`, `ng.coreViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ViewChild` constructors. The difference between `ng.core.ContentChildren`
    and `ng.core.ContentChild` is that the first one returns all the references of
    a given component whereas the second one returns the reference of the first occurrence.
    The same difference also stands for `ng.core.ViewChild` and `ng.core.ViewChildren`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问视图子代或内容子代的组件引用的引用，我们可以使用`ng.core.ContentChildren`、`ng.coreViewChildren`、`ng.core.ContentChild`和`ng.core.ViewChild`构造函数。`ng.core.ContentChildren`和`ng.core.ContentChild`之间的区别在于前者返回给定组件的所有引用，而后者返回第一个出现的引用。`ng.core.ViewChild`和`ng.core.ViewChildren`也有相同的区别。
- en: 'Here is an example to demonstrate `ng.core.ContentChildren`. Replace the code
    for the `List` component with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了`ng.core.ContentChildren`。用这个替换`List`组件的代码：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this code in the console is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，这段代码的输出如下：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Most of this code is self-explanatory. What's new is the `ngAfterContentInit`
    lifecycle method. It's triggered after the content children have been initialized.
    Similarly, if we want to access the view children, we need to use the `ngAfterViewInit`
    lifecycle method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是不言自明的。新的是`ngAfterContentInit`生命周期方法。它在内容子代初始化后触发。同样，如果我们想要访问视图子代，我们需要使用`ngAfterViewInit`生命周期方法。
- en: Note that we only have access to the state of the components—nothing else.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只能访问组件的状态，没有其他东西。
- en: Local template variables
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地模板变量
- en: We can assign a local template variable to a content child or view child. Local
    template variables let us get the reference of any element of the content children
    or view children, that is, component references or HTML element references.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将本地模板变量分配给内容子代或视图子代。本地模板变量让我们获取内容子代或视图子代的任何元素的引用，即组件引用或HTML元素引用。
- en: To assign a local template variable to an element of the view children or content
    children, we need to place `#variable_name` in the opening tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要将本地模板变量分配给视图子代或内容子代的元素，我们需要在开放标签中放置`#variable_name`。
- en: 'Here is an example to demonstrate how local template variables work. Place
    this code above the `App` component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示本地模板变量的工作原理。将此代码放在`App`组件之前：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change the `App` component''s code to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将`App`组件的代码更改为：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, add this code to the end of the `app-template.html` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`app-template.html`文件的末尾添加此代码：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of this code is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '![Local template variables](img/00157.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![本地模板变量](img/00157.jpeg)'
- en: 'Here is how these three code snippets work:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个代码片段的工作原理：
- en: We create a new component named `SampleComponent2`, which displays an HTML input
    text element. We assign the input element to a local template variable named `input`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`SampleComponent2`的新组件，它显示一个HTML输入文本元素。我们将输入元素分配给名为`input`的本地模板变量。
- en: Then, we use the `ng.core.ViewChild` to get a reference to the element. If we
    pass a string to `ng.core.ViewChild`, `ng.core.ViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ContentChildren`, then they will look for the elements with the same
    local variable name as the string, and if we pass a component, they will look
    for the component, like we saw before.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`ng.core.ViewChild`来获取对元素的引用。如果我们将一个字符串传递给`ng.core.ViewChild`、`ng.core.ViewChildren`、`ng.core.ContentChild`和`ng.core.ContentChildren`，那么它们将查找与字符串相同的本地变量名称的元素，如果我们传递一个组件，它们将查找组件，就像我们之前看到的那样。
- en: The reference of the components we get from the local template variable is of
    the same interface we got before. But for HTML element references, we can access
    the real DOM of the element by using the `nativeElement` property.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从本地模板变量中获取的组件引用与之前获得的接口相同。但是对于HTML元素引用，我们可以通过使用`nativeElement`属性来访问元素的真实DOM。
- en: Component lifecycle methods
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: When a `component` tag appears, Angular 2 creates an instance of a component,
    renders it, checks for changes in attributes, checks for changes in state, and
    destroys it when it's no longer needed. These steps together form the lifecycle
    of a component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现`component`标签时，Angular 2会创建一个组件实例，呈现它，检查属性的更改，检查状态的更改，并在不再需要时销毁它。这些步骤共同形成了组件的生命周期。
- en: Angular 2 lets us register methods that are called at various stages of the
    component lifecycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2允许我们注册在组件生命周期的各个阶段调用的方法。
- en: 'Here are the various lifecycle methods provided by Angular 2; lifecycle hooks
    are explained in the order they occur:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Angular 2提供的各种生命周期方法；生命周期钩子按它们发生的顺序进行解释：
- en: '`ngOnChanges`: This is invoked whenever the attributes of a component change.
    It''s also invoked after the attributes of a component are resolved for the first
    time after the creation of a new instance of the component. It''s invoked after
    the state has been changed due to the attributes but before the view is updated.
    This method receives the current and previous values of the attributes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnChanges`：每当组件的属性更改时调用。在组件的属性第一次创建新实例后解析属性之后也会调用。它在由于属性而更改状态之后但在视图更新之前被调用。此方法接收属性的当前值和先前值。'
- en: '`ngOnInit`: This is invoked after the first instance of `ngOnChanges`. It states
    that the component has been successfully created and attributes have been read.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnInit`：在第一次`ngOnChanges`实例之后调用。它表示组件已成功创建并且属性已被读取。'
- en: '`ngDoCheck`: This is called during every change-detection cycle and right after
    `ngOnInit`. We can detect and act upon changes that Angular 2 can''t or won''t
    detect on its own. This is invoked after Angular 2 is done checking state changes
    for the component and has updated the state if there was any change in the attributes
    but before the component view is updated. After this call is over, the view is
    rendered, and while rendering it, `ngAfterContentInit`, `ngAfterContentChecked`,
    `ngAfterViewInit`, and `ngAfterViewChecked` are invoked.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngDoCheck`：在每个变化检测周期期间以及`ngOnInit`之后调用。我们可以检测并对Angular 2无法或不会自行检测的更改进行操作。这在Angular
    2完成检查组件状态更改并更新状态（如果属性有任何更改）之后但在组件视图更新之前被调用。此调用结束后，视图被呈现，而在呈现时，会调用`ngAfterContentInit`，`ngAfterContentChecked`，`ngAfterViewInit`和`ngAfterViewChecked`。'
- en: '`ngAfterContentInit`: This is invoked after content children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, and `ngAfterContentChecked` methods of the content children
    have been called.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterContentInit`：在内容子级已初始化但尚未呈现之后调用，即在内容子级的`ngOnChanges`，`ngOnInit`，`ngDoCheck`，`ngAfterContentInit`和`ngAfterContentChecked`方法被调用之后调用。'
- en: '`ngAfterContentChecked`: This is invoked whenever the change-detection cycle
    checks whether the content children have changed as well as right after `ngAfterContentInit`.
    If there is a change, it''s invoked before the views of the content children are
    updated. Before invoking it, the query results of `ng.core.ViewChildren`, `ng.core.ContentChildren`,
    and so on are updated, that is, it''s invoked after `ngAfterContentChecked` of
    the content children has been invoked. After this call, the content children views
    are updated.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterContentChecked`：每当变化检测周期检查内容子级是否已更改以及在`ngAfterContentInit`之后立即调用。如果有变化，它会在内容子级的视图更新之前被调用。在调用它之前，`ng.core.ViewChildren`，`ng.core.ContentChildren`等的查询结果会被更新，即在内容子级的`ngAfterContentChecked`被调用之后被调用。在此调用之后，内容子级视图会被更新。'
- en: '`ngAfterViewInit`: This is invoked after view children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, and `ngAfterViewChecked`
    methods of the view children have been called.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterViewInit`：在视图子级已初始化但尚未呈现之后调用，即在视图子级的`ngOnChanges`，`ngOnInit`，`ngDoCheck`，`ngAfterContentInit`，`ngAfterContentChecked`，`ngAfterViewInit`和`ngAfterViewChecked`方法被调用之后调用。'
- en: '`ngAfterViewChecked`: This is invoked whenever the change-detection cycle checks
    whether the view children have changed as well as right after `ngAfterViewInit`.
    If there is a change, it''s invoked before the views of the view children are
    updated but after the `ngAfterViewChecked` methods of the view children have been
    invoked.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngAfterViewChecked`：每当变化检测周期检查视图子级是否已更改以及在`ngAfterViewInit`之后立即调用。如果有变化，它会在视图子级的视图更新之前但在视图子级的`ngAfterViewChecked`方法被调用之后被调用。'
- en: '`ngOnDestroy`: This is invoked before a component is destroyed. The `ngOnDestroy`
    method of a component is invoked before the `ngOnDestroy` methods of its content
    children and view children.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngOnDestroy`：在组件被销毁之前调用。在组件的`ngOnDestroy`方法在其内容子级和视图子级的`ngOnDestroy`方法之前被调用之前被调用。'
- en: Writing templates
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模板
- en: We need to use template language to write component templates. Template language
    is composed of HTML along with the `{}`, `[]`, `()`, `[()]`, `*`, `|`, and `#`
    tokens. Let's see what each of these is used for and how to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用模板语言来编写组件模板。模板语言由HTML和`{}`，`[]`，`()`，`[()]`，`*`，`|`和`#`标记组成。让我们看看每个标记的用途以及如何使用它们。
- en: Rendering a value
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染一个值
- en: To simply render a property of the `this` keyword, we need to use the `{{}}`
    token. Inside these braces, we can simply place the property name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地呈现`this`关键字的属性，我们需要使用`{{}}`标记。在这些大括号内，我们可以简单地放置属性名称。
- en: 'We can only place expressions inside braces. The expressions we place inside
    them look like JavaScript. But there are a few JavaScript expressions that we
    are not allowed to use inside these braces. Here they are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在大括号内放置表达式。我们放置在其中的表达式看起来像JavaScript。但是有一些JavaScript表达式是我们不允许在这些大括号内使用的。它们在这里：
- en: Assignments (`=`, `+=`, `-=`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值（`=`，`+=`，`-=`）
- en: The `new` operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`操作符'
- en: Chaining expressions with `;` or `,`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`；`或`,``链接表达式
- en: Increment and decrement operators (`++` and `--`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增和递减运算符（`++`和`--`）
- en: The bitwise operators `|` and `&`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位运算符`|`和`&`
- en: Pipes
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: We can also place `pipes` in braces. A pipe is a function that accepts an input
    value and returns a transformed value. A pipe is represented by the `|` operator.
    The final result of expressions inside braces can be transformed using pipes.
    There can be as many pipes in the braces as we want. A pipe can also take parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular 2 provides some built-in pipes: `date`, `uppercase`, `lowercase`, `currency`,
    and `percent`. We can also create our own pipes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `{{}}`. Place this code above the `App` component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace the `App` component code with this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then, place this in the `app-template.html` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipes](img/00158.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the final result of the expression inside the braces is converted
    into a string if the final value is not a string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle events of elements in a template, we need to use the `()` operator.
    Here is an example of how to handle events. Place this code above the `App` component
    code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Replace the `App` component code with this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Place this code in `app-template.html`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is self-explanatory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Binding state to element attributes
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bind the value of a property of the `this` keyword to the attribute of an
    element in a template, we can simply use `{{}}`, like this, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But if you want to pass an object, this method will not work, as the expression
    inside the `{{}}` token is always converted to a string. Therefore, Angular 2
    provides the `[]` operator, which enables a component to pass an object through
    attributes to a component in its template.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this. Place this code above the `App` component
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Place this code at the end of the `app-template.html` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of this code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding state to element attributes](img/00159.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that while assigning attributes to an HTML tag, if we assign an attribute
    that's not native to the element, we need to prefix the attribute name using `attr.`.
    For example, to assign a `value` attribute to a `<span>` tag, we need to name
    the attribute `attr.value`, not simply `value`. Otherwise, Angular 2 will throw
    an error. This is because while interpreting a template and creating its DOM,
    Angular 2 sets the attributes by assigning the values to the properties of DOM
    elements. So when we use the `attr.` prefix, it signals Angular 2 to use `setAttribute`
    instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Angular 2 doesn't use two-way data binding. It uses unidirectional
    binding but offers the `[()]` operator for two-way data binding, if needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `[()]`. Place this code above the `App` component''s
    code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the `App` component code with this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Place this code in the `app-template.html` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this code is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data binding](img/00160.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Here, enter something in the text field and click on the button. You will see
    an alert box with the text field's value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To capture the value of HTML form elements, we need to place `ngModel` inside
    the `[()]` brackets. We can place an attribute name if we are setting up two-way
    data binding between inputs and outputs. We will learn more about outputs later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Directives** are used to change the DOM based on the state. There are two
    types of directives: attribute directives and structural directives. Let''s look
    at each of them.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **attribute directive** changes the appearance or behavior of a DOM element
    based on a change in state. `ngClass` and `ngStyle` are the built-in attribute
    directives. We can also create our own attribute directives.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `ngClass` directive is used to add or remove CSS classes from an element
    whereas the `ngStyle` directive is used to set inline styles.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use the `ngClass` and `ngStyle` directives. Place
    this code above the `App` component''s code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`App`组件的代码：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, place this code at the end of the `app-template.html` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将这段代码放在`app-template.html`文件的末尾：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if you inspect the `<sampleeight>` tag in browser developer tools, you
    will see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器开发者工具中检查`<sampleeight>`标签，你会看到这个：
- en: '![Attribute directives](img/00161.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![属性指令](img/00161.jpeg)'
- en: Most of this code is self-explanatory. You can see that the same `[]` token
    is also used for attribute directives. When the `[]` token is used, Angular 2
    first checks to see whether a built-in attribute directive or custom directive
    is present with that name, and if not, it treats it as an attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分这段代码都是不言自明的。你可以看到相同的`[]`标记也用于属性指令。当使用`[]`标记时，Angular 2首先检查是否存在具有该名称的内置属性指令或自定义指令，如果没有，它会将其视为属性。
- en: Structural directives
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构指令
- en: A **structural directive** changes the DOM layout by adding or removing DOM
    elements. `ngIf`, `ngSwitch`, and `ngFor` are the three built-in structural directives.
    We can also create our own custom structural directives.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构指令**通过添加或删除DOM元素来改变DOM布局。`ngIf`、`ngSwitch`和`ngFor`是三个内置的结构指令。我们也可以创建自己的自定义结构指令。'
- en: 'Here is an example to demonstrate `ngIf` and `ngSwitch`. We have already seen
    an example of `ngFor` previously. Place this code above the `App` component''s
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示`ngIf`和`ngSwitch`的例子。我们之前已经看过一个`ngFor`的例子。将这段代码放在`App`组件的代码之前：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file named `samplecomponent9-template.html`, and place it in the `componentTemplates`
    directory. Place this code in that file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`samplecomponent9-template.html`的文件，并将其放在`componentTemplates`目录中。将这段代码放在该文件中：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`App`组件的代码：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, place this code in the `app-template.html` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这段代码放在`app-template.html`文件的末尾：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of this code is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '![Structural directives](img/00162.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![结构指令](img/00162.jpeg)'
- en: Most of this code is self-explanatory. You can see that we are using the `*`
    token for structural directives. The `*` token treats the element as a template,
    that is, it doesn't render the element but uses it as a template to create the
    DOM.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分这段代码都是不言自明的。你可以看到我们在结构指令中使用了`*`标记。`*`标记将元素视为模板，也就是说，它不会渲染元素，而是将其用作创建DOM的模板。
- en: 'Actually, both attribute and structural directives are written using the `[]`
    token, but writing code using structural directives with the `[]` token makes
    the code longer. Therefore, Angular 2 introduced the `*` token, which makes it
    easy to write code using structural directives. Internally, Angular 2 translates
    the code that uses the `*` token to use the `[]` token. Learn more about it here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，属性指令和结构指令都是使用`[]`标记编写的，但是使用`[]`标记编写结构指令的代码会变得更长。因此，Angular 2引入了`*`标记，这使得使用结构指令编写代码变得更容易。在内部，Angular
    2将使用`*`标记的代码转换为使用`[]`标记。在这里了解更多：
- en: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
- en: Outputs
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出
- en: '**Outputs** allow components to emit custom events. For example, if we have
    a component that displays a button and we want the parent component to be able
    to add an event handler for the click event of the child component, we can achieve
    this using outputs.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**Outputs**允许组件发出自定义事件。例如，如果我们有一个显示按钮的组件，并且我们希望父组件能够为子组件的点击事件添加事件处理程序，我们可以使用outputs来实现这一点。'
- en: 'Here is an example of how to integrate outputs. Place this code above the `App`
    component''s code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个集成输出的例子。将这段代码放在`App`组件的代码之前：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`App`组件的代码：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, place this code at the end of the `app-template.html` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这段代码放在`app-template.html`文件的末尾：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you will start seeing a counter appear on the page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会开始在页面上看到一个计数器出现。
- en: The `outputs` property is used to define the events the component emits. We
    need to create a property in this keyword with the same name as the output and
    assign it to a new instance of `ng.core.EventEmitter` so that it can emit events.
    `ng.core.EventEmitter` provides observer patterns to objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs`属性用于定义组件发出的事件。我们需要在这个关键字中创建一个与输出相同名称的属性，并将其分配给`ng.core.EventEmitter`的新实例，以便它可以发出事件。`ng.core.EventEmitter`为对象提供了观察者模式。'
- en: To capture events, we need to use the `()` token, just like we used it to capture
    native UI events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获事件，我们需要使用`()`标记，就像我们用它来捕获原生UI事件一样。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we need to assign output to a new instance of `ng.core.EventEmitter`
    inside the constructor property, that is, during the creation of a new instance
    of the component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要在构造函数属性内将输出分配给`ng.core.EventEmitter`的新实例，也就是在创建组件的新实例时。
- en: Two-way data binding with inputs and outputs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入和输出进行双向数据绑定
- en: You can implement two-way data binding between inputs and outputs. For example,
    if a parent component passes an attribute to a component of the view children
    and the child component notifies the parent component whenever the input value
    changes, then instead of using `()` and `[]` separately, we can use `[()]`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输入和输出之间实现双向数据绑定。例如，如果父组件将属性传递给视图子组件，并且子组件在输入值更改时通知父组件，那么我们可以使用`[()]`来代替分别使用`()`和`[]`。
- en: 'Here is an example to demonstrate this. Place this code above the `App` component''s
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示的例子。将这段代码放在`App`组件的代码之前：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`App`组件的代码：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, add this code to the end of the `app-template.html` file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这段代码添加到`app-template.html`文件的末尾：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the output is same as the previous example. Most of the things are self-explanatory.
    The only thing you need to know is that both these code snippets do the same thing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，输出与前面的例子相同。大部分内容都是不言自明的。你需要知道的唯一一件事是，这两个代码片段都是做同样的事情：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Understanding providers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解提供者
- en: A **provider** tells Angular 2 how to create an instance of a service while
    injecting it. A provider is set using the `providers` or `viewProviders` properties
    of a component.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供者**告诉Angular 2如何在注入时创建服务的实例。提供者是使用组件的`providers`或`viewProviders`属性设置的。'
- en: 'Let''s look at an example of how to create providers. Place this code above
    the `App` component''s code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何创建提供者的示例。将以下代码放在`App`组件的代码之上：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`App`组件的代码：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, add this to the end of the `app-template.html` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`app-template.html`文件的末尾添加以下内容：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is the console output of the code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的控制台输出：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is how it works:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理如下：
- en: 'First, we create four services: `Service1`, `Service2`, `Service3`, and `Service4`.
    They all have a `getValue` method, which returns a string. `Service4` is dependent
    on `Service2` and `Service3`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了四个服务：`Service1`、`Service2`、`Service3`和`Service4`。它们都有一个`getValue`方法，返回一个字符串。`Service4`依赖于`Service2`和`Service3`。
- en: Then, we create a component called `ServiceTest1`. It's dependent on `Service1`.
    In the `viewProviders` property, we passed an array of providers. A provider is
    created using the `ng.core.provide` method. It takes two arguments; the first
    one is the service name, and the second one is the configuration object, which
    states how to create an instance of this service. The `useClass` property tells
    Angular 2 to create a instance of this service when an instance of the service
    in the first argument is requested. So here, when an instance of `Service1` is
    required, an instance of `Service4` is what is actually created. Similarly, `useValue`
    is used to provide a value, and `useFactory` is used to pass control to a function
    to decide what to return when a new instance is requested. So here, when an instance
    of `Service2` is requested, we get the `def` string, and when `Service3` is requested,
    we get the `mno` string.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个名为`ServiceTest1`的组件。它依赖于`Service1`。在`viewProviders`属性中，我们传递了一个提供者数组。使用`ng.core.provide`方法创建提供者。它接受两个参数；第一个是服务名称，第二个是配置对象，说明如何创建此服务的实例。`useClass`属性告诉Angular
    2在请求第一个参数的服务实例时创建此服务的实例。因此，在这里，当需要`Service1`的实例时，实际上创建的是`Service4`的实例。类似地，`useValue`用于提供一个值，`useFactory`用于将控制传递给一个函数，以决定在请求新实例时返回什么。因此，在这里，当请求`Service2`的实例时，我们得到`def`字符串，当请求`Service3`时，我们得到`mno`字符串。
- en: Earlier in this chapter, we were simply assigning `viewProviders` to the services
    themselves. A service also implements the interface of a provider such that it
    creates the instance of the service itself.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们只是将`viewProviders`分配给了服务本身。服务还实现了提供者的接口，以便它自己创建服务的实例。
- en: If there are multiple providers matching a service, then the latest one overrides
    the previous one.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个提供者匹配一个服务，则最新的提供者将覆盖先前的提供者。
- en: The difference between providers and the viewProviders property
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者和viewProviders属性之间的区别
- en: The `viewProviders` property allows us to make providers available to the component's
    view only, whereas the `providers` property makes a provider available to its
    content children and view children.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewProviders`属性允许我们只将提供者提供给组件的视图，而`providers`属性则使提供者可用于其内容子级和视图子级。'
- en: 'The `providers` property creates a service instance only once and provides
    the same to whichever component asks for it. We have already seen how `viewProviders`
    works. Let''s look at an example of how `providers` works. Place this code above
    the App component''s code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers`属性仅创建一次服务实例，并将其提供给请求它的任何组件。我们已经看到了`viewProviders`的工作原理。让我们看一个`providers`的工作示例。将以下代码放在`App`组件的代码之上：'
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`App`组件的代码：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, at the end of the `app-template.html` file, place this code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`app-template.html`文件的末尾，放置以下代码：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The console output of this code is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的控制台输出如下：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Most of the things in this code are self-explanatory. We are using `providers`
    instead of `viewProviders`. The `ServiceTest2` component is dependent on `Service5`,
    but it doesn't have a provider for `Service5`, so Angular 2 uses the provider
    provided by `ServiceTest3`, as `ServiceTest3` is its parent. If `ServiceTest3`
    hadn't had a provider for `Service5`, Angular 2 would have gone further above
    and looked for the provider in the `App` component.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的大部分内容都是不言自明的。我们使用`providers`而不是`viewProviders`。`ServiceTest2`组件依赖于`Service5`，但它没有`Service5`的提供者，因此Angular
    2使用了`ServiceTest3`提供的提供者，因为`ServiceTest3`是它的父级。如果`ServiceTest3`没有为`Service5`提供提供者，Angular
    2将继续向上查找`App`组件中的提供者。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ng.platform.browser.bootstrap` method also takes a second argument, which
    is a list of providers that is available to all the components. So, instead of
    passing providers in the `App` component, we can pass them through the `ng.platform.browser.bootstrap`
    method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng.platform.browser.bootstrap`方法还接受第二个参数，这是一个可用于所有组件的提供者列表。因此，我们可以通过`ng.platform.browser.bootstrap`方法传递提供者，而不是在`App`组件中传递它们。'
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Angular 2\. We saw what components are, how
    to write templates, how to create services, and so on. We also learned about web
    components and how Angular 2 takes advantage of them. You should now be comfortable
    with building Angular 2 applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Angular 2。我们看到了组件是什么，如何编写模板，如何创建服务等等。我们还了解了Web组件以及Angular 2如何利用它们。您现在应该可以轻松构建Angular
    2应用程序了。
- en: In the next chapter, we will learn how to build an SPA using Angular 2 by building
    a complete app.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Angular 2构建SPA，通过构建一个完整的应用程序。

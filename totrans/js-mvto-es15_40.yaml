- en: Chapter 12. New Features of Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 1 was based on the MVC architecture whereas Angular 2 is based on a
    components-and-services architecture. Angular 1 and Angular 2 are completely different
    in terms of architecture and APIs, so previous knowledge of Angular 1 is unlikely
    to help you much in learning Angular 2\. In this chapter, we will learn Angular
    2 without comparing it with Angular 1 as doing that will create confusion and
    is unnecessary. Even if you don't have knowledge about Angular 1, you can continue
    with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Web components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Angular 2 architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more...
  prefs: []
  type: TYPE_NORMAL
- en: The Angular 2 architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 is a framework for building the client side of web applications, based
    on a services-and-components architecture.
  prefs: []
  type: TYPE_NORMAL
- en: An Angular 2 application is composed of a view and various services. Services
    are simple JavaScript objects that hold application logic and state. Services
    should be reusable. Views consume services, and services can also interact with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Views and services are loosely coupled so that an Angular 2 view can be used
    with any other architecture, such as Flux. Similarly, services can be used with
    any other view, such as React.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 views are based on component-oriented architecture. In component-oriented
    architecture, the application UI is divided into reusable components. A component
    has a UI with code to update the UI and handle user actions on the UI. A custom
    tag is associated with a component, and whenever the custom tag appears, a new
    instance of the component is created and rendered. So, we can say that component-oriented
    architecture is architecture for the view of an application. Actually, the components
    consume the services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous two chapters, we studied React, which is also based on component-oriented
    architecture, since with React, we build an application as a set of components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram from the official Angular 2 website ([https://angular.io](https://angular.io))
    that shows the complete architecture of Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Angular 2 architecture](img/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the UI of a **Component** is defined using a **Template**.
    Templates are written using template HTML, that is, a combination of HTML and
    many other tokens. A component also holds the UI state and event handlers of the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn't store application logic and state inside a component, as it will
    have an impact on code reusability and cause issues while developing large and
    complex apps. Application state and logic should be stored in services.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 only implements one-way data binding. This makes large and complex
    apps easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Services are injected into specific components that need them, and not all the
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into web components, you need to know why we are learning about
    them. Well, we are learning about web components because Angular 2 components
    utilize shadow DOM and templates, which are a part of web components.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, web components are a collection of four different browser specifications
    that enable the creation of reusable components in web pages. These four specifications
    are **HTML imports**, **shadow DOM**, **templates**, and **custom elements**.
    They can be used together or separately.
  prefs: []
  type: TYPE_NORMAL
- en: Web components provide native implementation of component-oriented architecture.
    A component created using web components is called a web component as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn about web components, let's consider a project for demonstration
    purposes. Create a directory named `web-components`, and then create a file named
    `index.html` in it. Web components have pretty poor browser support, so let's
    download `webcomponents.js polyfill`. Download the `webcomponents.js` file from
    [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    and place it in the `web-components` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, place this code in the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at an overview of shadow DOM, templates, and custom elements
    by building a component to display a card that has an image, title, and description.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Templates** are used to define reusable code. A template is defined using
    the `<template>` tag. Code for the template is placed inside this tag. We can
    place any tag, such as `<script>` and `<style>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the `<template>` tag is only parsed, not rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a template. Place this code in the `body`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the template holds the UI code for the card component. Now, if you open
    the `index.html` file in a browser, you won't see anything because the `<template>`
    tag is only parsed, not rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Custom elements** let us define new types of HTML elements (that is, new
    types of HTML tags). When we use a tag name that''s not recognized by the browser,
    the browser simply treats it like a `<span>` tag. But when we register a `custom`
    tag, it gets recognized by the browser. It can inherit other elements, lets us
    perform different operations on different stages of the element lifecycle, and
    much more.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `custom` element for our component. Wherever the tag appears,
    a new instance of the component will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to display the `custom` element. Place it in the `<body>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have to use the `-` character in the custom element name. This is compulsory
    because this restriction allows the parser to distinguish custom elements from
    regular elements and ensures forward compatibility when new tags are added to
    HTML. Here, we are passing properties of the component as data attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define `<custom-card>` as a custom element and place the template
    code inside the tag whenever a new instance of `<custom-card>` is created. To
    do that, place this code in the `<script>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the code works:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, custom elements inherit methods and properties of `HTMLElement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To register a custom element, we need to use the `document.registerElement`
    method. The first argument is the custom tag name and the second argument is an
    optional object. This optional object can take a property called **prototype**.
    The `prototype` property defines the HTML element it inherits, that is, the properties
    and methods of the HTML element it inherits. By default, it's assigned to `Object.create(HTMLElement.prototype)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also add new properties and methods to our custom element by adding new
    properties and methods to the object assigned to the `prototype` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we've added a method called `createdCallback`, which is invoked whenever
    an instance of a custom element is created, that is, either an instance created
    using JavaScript or HTML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `createdCallback`, we are retrieving our template and setting the image
    source, title, and description and then appending it to the custom element by
    creating a clone of it, as many custom elements will share the same template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you open `index.html` in a browser, you will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom elements](img/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shadow DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Shadow DOM** allows HTML elements to get a new kind of node called a shadow
    root associated with them. An element that has a shadow root associated with it
    is called a shadow host. The content of a shadow host isn''t rendered; the content
    of the shadow root is rendered instead. A shadow root can have another shadow
    root below it.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of shadow DOM is that CSS styles defined inside a shadow root won't
    affect its parent document, and CSS styles defined outside the shadow root will
    not affect the elements inside the shadow root. This is useful to define styles
    specific to the components. In short, we can say that shadow DOM provides style
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Style encapsulation is not the only benefit of shadow DOM. The HTML inside the
    shadow root is protected from accidental modification from JavaScript. We can
    still inspect the shadow root in browser developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: Many native element, such as `<video>` and `<audio>`, have a shadow root, but
    when you inspect it, you won't see the shadow root. Browsers by default hide the
    shadow roots of these elements. To see their shadow roots, you need to change
    browser-specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous custom element code to render the template inside
    shadow DOM. Replace the previous `createdCallback` method with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of appending the template code directly to the custom element,
    we created a shadow root using `createShadowRoot` and appended the template code
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Angular 2 project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 code can be written in JavaScript, TypeScript, or Dart. In case you
    are writing Angular 2 code in TypeScript or Dart, you will need to transpile the
    code to JavaScript before serving to the client. We will use JavaScript to write
    Angular 2 code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `angular2-demo`. Then, inside the directory, create
    the `app.js` and `package.json` files. Then, create a directory named `public`,
    and inside the directory, create four more directories named `html`, `js`, `componentTemplates`,
    and `componentStyles`. Now, create a file named `index.html` and place it in the
    `html` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, download `angular2-polyfills.js`, `Rx.umd.js`, and `angular2-all.umd.js`
    from [https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)
    and place them in the `angular2-demo/js` directory. These files are what they
    sound like. You can also enqueue the CDN links directly if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `index.html` file, place this starting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `app.js` file, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the server-side code. It's self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `package.json` file, place this code and run `npm install` to download
    the `express` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To start the server, run `node app.js`. Then, open the app using `localhost:8080`
    as the address in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Angular 2 application is completely split into components. Technically, an
    Angular 2 component is a reusable `custom` tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that Angular 2 doesn't register the custom tag name as a custom element.
  prefs: []
  type: TYPE_NORMAL
- en: All the components of the application are arranged in a tree structure, with
    a component as the root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a component. It creates a card component
    that displays an image, title, and description. Place this code in the `<script>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a file named `card-template.html`, and place it in the `componentTemplates`
    directory. Place this code in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create a file named `card-style.css` and place it in the `componentStyles`
    directory. Place this code in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how these three code snippets work:'
  prefs: []
  type: TYPE_NORMAL
- en: A component needs to be created by chaining `Component` and `Class` methods
    that belong to an `ng.core` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Component` method takes a configuration object with various properties,
    whereas the `Class` method takes an object with component lifecycle methods, constructors,
    and UI action handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the configuration properties we've provided are `selector`, `inputs`,
    `templateUrl`, and `styleUrls`. The `selector` property is used to define the
    custom tag for the component. The `inputs` property is used to define the attributes
    that the custom tag takes. The `templateUrl` property is used to define the file
    containing the template of the component. You can also use `template` if you want
    to inline the template code. Finally, `styleUrls` is used to define the CSS files
    containing the style for the component. You can also use the `styles` property
    to inline CSS code, or you can define CSS using a `<style>` tag inside the template
    itself. CSS defined in any of these three ways won't affect other components,
    that is, it's encapsulated to the component itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Class` method, we will have to provide the `constructor` method even
    if it does nothing. It's invoked during the construction of a new instance of
    the component. By construction of the component, I mean the construction of the
    component in memory—not resolving attributes, resolving its children, rendering
    its view, and so on. The primary use of the `constructor` method is to inject
    services into the component. Services cannot be injected automatically as we may
    sometimes need to initialize services for every component, and Angular is unaware
    of how to do this. The `constructor` method has access to the state of the component
    but not its properties. Here, we shouldn't do any heavy work or something else
    that would slow down or cause the construction of the component to fail. `constructor`
    is not a component lifecycle method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have the component template code. In this template file, we are simply
    rendering the properties passed to the component. To render anything that's in
    the component state, we need to use the `{{}}` token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create another component called `Cards`, which displays a list of cards.
    It gets information about cards from a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code in the `<script>` tag of the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a file named `cards-template.html` in the `componentTemplates`
    directory and place this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a file named `app-template.html` in the `componentTemplates` directory
    and place this code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `<body>` tag of the `index.html` file, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how these four code snippets work:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a service, we need to use the `ng.core.Class` method. It takes an
    object with the `constructor` method and other methods or properties that the
    service exposes. While injecting the service into other services or components,
    a new instance of the service is created and injected. While creating a new instance
    of a service, the `constructor` method is called. We have to provide this method
    even if it doesn't do anything. The primary purpose of this method is to inject
    services that this service depends on. Here, our `CardsService` method is not
    dependent on any other service, so we have no code inside the `constructor` method.
    Then, we defined a `getCards` method, which returns data of three different cards
    to display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we created a `Cards` component. It takes the data from `CardsService`
    and renders a `Card` component for each card data. While creating the `Cards`
    component, we provide `viewProviders` and `directives` properties to the configuration
    object. `viewProviders` is the list of services the component is dependent on,
    and `directives` is the list of other components this component renders. Here,
    you can see that instead of directly assigning a function to the `constructor`
    property, we are assigning an array with a list of services the component depends
    upon and the last array item as the actual function. This is the format of injecting
    services into components. Inside the `constructor` method, we store references
    to the methods or properties of the service that the component needs, that is,
    we can use services inside the `constructor` method. We will learn more about
    `viewProviders` later on. The `this` keyword in any of the methods passed to the
    `Class` method points to the state of the component. After a component instance
    has been created, whenever the component state changes, the template bindings
    are updated. We have another method here, called `ngOnInit`. It's a lifecycle
    method that's invoked after a new instance of the component has been created and
    its attributes resolved. Inside this, we call the `getCards` method and store
    the returned value inside the `cards` property of the state. Note that the attributes
    passed to a component tag are accessible using the `this` keyword after the component
    instance has been created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the template of `CardsComponent`, we are using the `*ngFor` directive
    to display the cards. We will learn more about directives later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create an `App` component, which acts as the root of our component.
    Inside this component, we are displaying the `Cards` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we initialize the application. An Angular 2 application is initialized
    explicitly. While initializing it, we need to provide a reference to the root
    component. This is done to ensure that applications are composed of nested components
    all the way down. The root component is the one that's added to the `<body>` tag.
    Adding tags of other components to the body tag will not do anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you refresh your `localhost:8080` page in your browser, you will see
    this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular 2 fundamentals](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Styling components and shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that there are three ways of defining styles specific to components
    (styles encapsulated in the component template scope). A component's CSS doesn't
    even affect the components it owns.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 doesn't use shadow DOM by default; instead, it uses a different technique
    to achieve style encapsulation. This is due to the lack of browser support.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Angular 2 modifies the CSS selector in such a way that it only
    targets the elements in the component, and it then places the CSS in the `<head>`
    tag of the page. If you inspect our current app using browser developer tools,
    you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling components and shadow DOM](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the CSS has been modified and inserted into the `<head>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: To force Angular 2 to use shadow DOM, we need to assign the encapsulation property
    of the component configuration object to `ng.core.ViewEncapsulation.Native`. By
    default, it's assigned to `ng.core.ViewEncapsulation.Emulated`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you inspect the app after assigning the encapsulation property of the
    `Card` and `Cards` components to `ng.core.ViewEncapsulation.Native`, you will
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling components and shadow DOM](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that shadow DOM was used to achieve style encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you don't want style encapsulation for a component, you can assign the
    encapsulation property to `ng.core.ViewEncapsulation.None`. In this case, all
    of the CSS will be placed directly in the `<head>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Change detection** is the process of detecting component state change. The
    state of a component is stored and manipulated using the `this` keyword. Therefore,
    there is no direct way for Angular 2 to detect when the state changes. So, Angular
    2 uses complex algorithms and third-party libraries to detect state changes.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing Angular 2 does for detecting state changes is that it pretends
    that all the changes happen asynchronously. Then, it uses the `zone.js` library
    to monitor browser events, timers, AJAX requests, WebSockets, and other asynchronous
    things that are supported by `zone.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever any of these asynchronous activities takes place, it checks everything
    that could change, including object properties and array elements of the `this`
    keyword of all the components from the root node; if any change is detected, then
    the template bindings of the component are updated. Angular 2 doesn't simply re-render
    the whole component. Instead, it checks for the bindings that have changed and
    selects and updates them specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Some components can have a lot of state data, and checking the state for every
    asynchronous operation will unnecessarily impact app performance if their state
    has not changed. Therefore, Angular 2 provides an option to mark such kinds of
    components so that it does not check their states unless the component itself
    tells Angular 2 to check its state during the next detection cycle, that is, when
    the next asynchronous activity occurs. Let's look at an example to demonstrate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code above the `App` component code in the `<script>` tag of the
    `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add `SampleComponent1` to the `directives` array of the `App` component.
    So now, the `App` component''s code should be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add this code to the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how these three code snippets work:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are displaying a value that gets incremented every 2 seconds
    and the template is re-rendered to display the updated value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At first, we create a component called `SampleComponent1`. It simply displays
    `value`. We have set the `changeDetection` property to `ng.core.ChangeDetectionStrategy.Detached`,
    which tells Angular 2 to not check its state change. By default, the `changeDetection`
    property is assigned to `ng.core.ChangeDetectionStrategy.Default`, which tells
    Angular 2 to check its state change during every change-detection cycle. We then
    inject the `ng.core.ChangeDetectorRef` service into the component, which provides
    various APIs related to change detection. And then, in the `ngOnInit` method,
    we increment the value of `value` every 2 seconds, after which we call the `markForCheck`
    method of `ng.core.ChangeDetectorRef`, which tells Angular 2 to check for changes
    in the state of the component during the next change-detection cycle. `markForCheck`
    will make Angular 2 check for a change in state for the next detection cycle only,
    not for the ones after that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we simply display `SampleComponent1` in the `App` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a component depends only on its inputs and/or UI events or if you want a
    component's state change, check only whether its inputs have changed or events
    have been fired; then, you can assign `changeDetection` to `ng.core.ChangeDetectionStrategy.OnPush`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If at any time you want to force a change-detection cycle instead of waiting
    for an asynchronous operation to happen, you can call the `detectChanges` method
    of the `ng.core.ChangeDetectorRef` service.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding view children and content children
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elements present inside the tags of a component are called **content children**,
    and elements present inside the template of a component are called **view children**.
  prefs: []
  type: TYPE_NORMAL
- en: To display the content children of a component in the component's view, we need
    to use the `<ng-content>` tag. Let's look at an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code above the `App` component''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the `App` component''s code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To the end of the `app-template.html` file, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding view children and content children](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how these three code snippets work:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `App` component's template file, we add a `<list>` tag, which displays
    a list. And inside its opening and closing tags, we define the individual list
    items that it should display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `ListItem` and `List` components that are bound to `<list>` and `<item>`
    tags, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `List` component to the `directives` property of the `App` component,
    not `List`, because the `<list>` tag is present in the template of the `App` component,
    and the `App` component is responsible for creating its instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `App` component looks for the `<ng-content>` tag in the template of the
    `List` component and renders the `List` component instances there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<ng-content>` takes an optional `select` attribute that''s assigned to a CSS
    selector that indicates which elements of the content children we want to display.
    There can be multiple `<ng-content>` tags in a template. If the `select` attribute
    has not been provided, then all the content children will be rendered. Here, the
    `select` attribute is not required; we are using it just for demonstration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the reference of components of content children and view children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get access to the reference of components of view children or content children,
    we can use the `ng.core.ContentChildren`, `ng.coreViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ViewChild` constructors. The difference between `ng.core.ContentChildren`
    and `ng.core.ContentChild` is that the first one returns all the references of
    a given component whereas the second one returns the reference of the first occurrence.
    The same difference also stands for `ng.core.ViewChild` and `ng.core.ViewChildren`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `ng.core.ContentChildren`. Replace the code
    for the `List` component with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code in the console is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is self-explanatory. What's new is the `ngAfterContentInit`
    lifecycle method. It's triggered after the content children have been initialized.
    Similarly, if we want to access the view children, we need to use the `ngAfterViewInit`
    lifecycle method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we only have access to the state of the components—nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Local template variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can assign a local template variable to a content child or view child. Local
    template variables let us get the reference of any element of the content children
    or view children, that is, component references or HTML element references.
  prefs: []
  type: TYPE_NORMAL
- en: To assign a local template variable to an element of the view children or content
    children, we need to place `#variable_name` in the opening tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how local template variables work. Place
    this code above the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `App` component''s code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, add this code to the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Local template variables](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how these three code snippets work:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new component named `SampleComponent2`, which displays an HTML input
    text element. We assign the input element to a local template variable named `input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `ng.core.ViewChild` to get a reference to the element. If we
    pass a string to `ng.core.ViewChild`, `ng.core.ViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ContentChildren`, then they will look for the elements with the same
    local variable name as the string, and if we pass a component, they will look
    for the component, like we saw before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reference of the components we get from the local template variable is of
    the same interface we got before. But for HTML element references, we can access
    the real DOM of the element by using the `nativeElement` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component lifecycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a `component` tag appears, Angular 2 creates an instance of a component,
    renders it, checks for changes in attributes, checks for changes in state, and
    destroys it when it's no longer needed. These steps together form the lifecycle
    of a component.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 lets us register methods that are called at various stages of the
    component lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the various lifecycle methods provided by Angular 2; lifecycle hooks
    are explained in the order they occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnChanges`: This is invoked whenever the attributes of a component change.
    It''s also invoked after the attributes of a component are resolved for the first
    time after the creation of a new instance of the component. It''s invoked after
    the state has been changed due to the attributes but before the view is updated.
    This method receives the current and previous values of the attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnInit`: This is invoked after the first instance of `ngOnChanges`. It states
    that the component has been successfully created and attributes have been read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngDoCheck`: This is called during every change-detection cycle and right after
    `ngOnInit`. We can detect and act upon changes that Angular 2 can''t or won''t
    detect on its own. This is invoked after Angular 2 is done checking state changes
    for the component and has updated the state if there was any change in the attributes
    but before the component view is updated. After this call is over, the view is
    rendered, and while rendering it, `ngAfterContentInit`, `ngAfterContentChecked`,
    `ngAfterViewInit`, and `ngAfterViewChecked` are invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentInit`: This is invoked after content children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, and `ngAfterContentChecked` methods of the content children
    have been called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentChecked`: This is invoked whenever the change-detection cycle
    checks whether the content children have changed as well as right after `ngAfterContentInit`.
    If there is a change, it''s invoked before the views of the content children are
    updated. Before invoking it, the query results of `ng.core.ViewChildren`, `ng.core.ContentChildren`,
    and so on are updated, that is, it''s invoked after `ngAfterContentChecked` of
    the content children has been invoked. After this call, the content children views
    are updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewInit`: This is invoked after view children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, and `ngAfterViewChecked`
    methods of the view children have been called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewChecked`: This is invoked whenever the change-detection cycle checks
    whether the view children have changed as well as right after `ngAfterViewInit`.
    If there is a change, it''s invoked before the views of the view children are
    updated but after the `ngAfterViewChecked` methods of the view children have been
    invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnDestroy`: This is invoked before a component is destroyed. The `ngOnDestroy`
    method of a component is invoked before the `ngOnDestroy` methods of its content
    children and view children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to use template language to write component templates. Template language
    is composed of HTML along with the `{}`, `[]`, `()`, `[()]`, `*`, `|`, and `#`
    tokens. Let's see what each of these is used for and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simply render a property of the `this` keyword, we need to use the `{{}}`
    token. Inside these braces, we can simply place the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only place expressions inside braces. The expressions we place inside
    them look like JavaScript. But there are a few JavaScript expressions that we
    are not allowed to use inside these braces. Here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Assignments (`=`, `+=`, `-=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining expressions with `;` or `,`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment and decrement operators (`++` and `--`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitwise operators `|` and `&`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also place `pipes` in braces. A pipe is a function that accepts an input
    value and returns a transformed value. A pipe is represented by the `|` operator.
    The final result of expressions inside braces can be transformed using pipes.
    There can be as many pipes in the braces as we want. A pipe can also take parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular 2 provides some built-in pipes: `date`, `uppercase`, `lowercase`, `currency`,
    and `percent`. We can also create our own pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `{{}}`. Place this code above the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, place this in the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipes](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the final result of the expression inside the braces is converted
    into a string if the final value is not a string.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle events of elements in a template, we need to use the `()` operator.
    Here is an example of how to handle events. Place this code above the `App` component
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this code in `app-template.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Binding state to element attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bind the value of a property of the `this` keyword to the attribute of an
    element in a template, we can simply use `{{}}`, like this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But if you want to pass an object, this method will not work, as the expression
    inside the `{{}}` token is always converted to a string. Therefore, Angular 2
    provides the `[]` operator, which enables a component to pass an object through
    attributes to a component in its template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this. Place this code above the `App` component
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this code at the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding state to element attributes](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that while assigning attributes to an HTML tag, if we assign an attribute
    that's not native to the element, we need to prefix the attribute name using `attr.`.
    For example, to assign a `value` attribute to a `<span>` tag, we need to name
    the attribute `attr.value`, not simply `value`. Otherwise, Angular 2 will throw
    an error. This is because while interpreting a template and creating its DOM,
    Angular 2 sets the attributes by assigning the values to the properties of DOM
    elements. So when we use the `attr.` prefix, it signals Angular 2 to use `setAttribute`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Angular 2 doesn't use two-way data binding. It uses unidirectional
    binding but offers the `[()]` operator for two-way data binding, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `[()]`. Place this code above the `App` component''s
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this code in the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data binding](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, enter something in the text field and click on the button. You will see
    an alert box with the text field's value.
  prefs: []
  type: TYPE_NORMAL
- en: To capture the value of HTML form elements, we need to place `ngModel` inside
    the `[()]` brackets. We can place an attribute name if we are setting up two-way
    data binding between inputs and outputs. We will learn more about outputs later.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Directives** are used to change the DOM based on the state. There are two
    types of directives: attribute directives and structural directives. Let''s look
    at each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **attribute directive** changes the appearance or behavior of a DOM element
    based on a change in state. `ngClass` and `ngStyle` are the built-in attribute
    directives. We can also create our own attribute directives.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngClass` directive is used to add or remove CSS classes from an element
    whereas the `ngStyle` directive is used to set inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use the `ngClass` and `ngStyle` directives. Place
    this code above the `App` component''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, place this code at the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you inspect the `<sampleeight>` tag in browser developer tools, you
    will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attribute directives](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Most of this code is self-explanatory. You can see that the same `[]` token
    is also used for attribute directives. When the `[]` token is used, Angular 2
    first checks to see whether a built-in attribute directive or custom directive
    is present with that name, and if not, it treats it as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **structural directive** changes the DOM layout by adding or removing DOM
    elements. `ngIf`, `ngSwitch`, and `ngFor` are the three built-in structural directives.
    We can also create our own custom structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `ngIf` and `ngSwitch`. We have already seen
    an example of `ngFor` previously. Place this code above the `App` component''s
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `samplecomponent9-template.html`, and place it in the `componentTemplates`
    directory. Place this code in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, place this code in the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural directives](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Most of this code is self-explanatory. You can see that we are using the `*`
    token for structural directives. The `*` token treats the element as a template,
    that is, it doesn't render the element but uses it as a template to create the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, both attribute and structural directives are written using the `[]`
    token, but writing code using structural directives with the `[]` token makes
    the code longer. Therefore, Angular 2 introduced the `*` token, which makes it
    easy to write code using structural directives. Internally, Angular 2 translates
    the code that uses the `*` token to use the `[]` token. Learn more about it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Outputs** allow components to emit custom events. For example, if we have
    a component that displays a button and we want the parent component to be able
    to add an event handler for the click event of the child component, we can achieve
    this using outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to integrate outputs. Place this code above the `App`
    component''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, place this code at the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will start seeing a counter appear on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The `outputs` property is used to define the events the component emits. We
    need to create a property in this keyword with the same name as the output and
    assign it to a new instance of `ng.core.EventEmitter` so that it can emit events.
    `ng.core.EventEmitter` provides observer patterns to objects.
  prefs: []
  type: TYPE_NORMAL
- en: To capture events, we need to use the `()` token, just like we used it to capture
    native UI events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we need to assign output to a new instance of `ng.core.EventEmitter`
    inside the constructor property, that is, during the creation of a new instance
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding with inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can implement two-way data binding between inputs and outputs. For example,
    if a parent component passes an attribute to a component of the view children
    and the child component notifies the parent component whenever the input value
    changes, then instead of using `()` and `[]` separately, we can use `[()]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this. Place this code above the `App` component''s
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this code to the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the output is same as the previous example. Most of the things are self-explanatory.
    The only thing you need to know is that both these code snippets do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Understanding providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **provider** tells Angular 2 how to create an instance of a service while
    injecting it. A provider is set using the `providers` or `viewProviders` properties
    of a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to create providers. Place this code above
    the `App` component''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this to the end of the `app-template.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the console output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create four services: `Service1`, `Service2`, `Service3`, and `Service4`.
    They all have a `getValue` method, which returns a string. `Service4` is dependent
    on `Service2` and `Service3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create a component called `ServiceTest1`. It's dependent on `Service1`.
    In the `viewProviders` property, we passed an array of providers. A provider is
    created using the `ng.core.provide` method. It takes two arguments; the first
    one is the service name, and the second one is the configuration object, which
    states how to create an instance of this service. The `useClass` property tells
    Angular 2 to create a instance of this service when an instance of the service
    in the first argument is requested. So here, when an instance of `Service1` is
    required, an instance of `Service4` is what is actually created. Similarly, `useValue`
    is used to provide a value, and `useFactory` is used to pass control to a function
    to decide what to return when a new instance is requested. So here, when an instance
    of `Service2` is requested, we get the `def` string, and when `Service3` is requested,
    we get the `mno` string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earlier in this chapter, we were simply assigning `viewProviders` to the services
    themselves. A service also implements the interface of a provider such that it
    creates the instance of the service itself.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple providers matching a service, then the latest one overrides
    the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between providers and the viewProviders property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `viewProviders` property allows us to make providers available to the component's
    view only, whereas the `providers` property makes a provider available to its
    content children and view children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `providers` property creates a service instance only once and provides
    the same to whichever component asks for it. We have already seen how `viewProviders`
    works. Let''s look at an example of how `providers` works. Place this code above
    the App component''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `App` component''s code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the end of the `app-template.html` file, place this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Most of the things in this code are self-explanatory. We are using `providers`
    instead of `viewProviders`. The `ServiceTest2` component is dependent on `Service5`,
    but it doesn't have a provider for `Service5`, so Angular 2 uses the provider
    provided by `ServiceTest3`, as `ServiceTest3` is its parent. If `ServiceTest3`
    hadn't had a provider for `Service5`, Angular 2 would have gone further above
    and looked for the provider in the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ng.platform.browser.bootstrap` method also takes a second argument, which
    is a list of providers that is available to all the components. So, instead of
    passing providers in the `App` component, we can pass them through the `ng.platform.browser.bootstrap`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Angular 2\. We saw what components are, how
    to write templates, how to create services, and so on. We also learned about web
    components and how Angular 2 takes advantage of them. You should now be comfortable
    with building Angular 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build an SPA using Angular 2 by building
    a complete app.
  prefs: []
  type: TYPE_NORMAL

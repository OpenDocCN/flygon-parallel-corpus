- en: Chapter 3. Testing Frontend Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing JavaScript browser code has been notoriously considered hard, and although
    there are many complications while dealing with cross-browser testing, the most
    common problem is not with the testing process but rather that the application
    code itself is not testable.
  prefs: []
  type: TYPE_NORMAL
- en: Since every element in the browser's document is accessible globally, it is
    easy to write a monolithic piece of JavaScript code, which deals with the whole
    page. This leads to a number of problems, and the biggest one is that it is pretty
    hard to test.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to get the best practices on how to write maintainable
    and testable browser code.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the user interface, we are going to use jQuery, a well-known JavaScript
    library that abstracts the browser's DOM in a clean and simple API that works
    across different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the writing of the specs easier, we''re going to use Jasmine jQuery,
    a Jasmine extension that adds new matchers to perform assertions on jQuery objects.
    To install it and its jQuery dependency, download the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Save these files as `jasmine-jquery.js` and `jquery.js` respectively inside
    the `lib` folder, and add them to `SpecRunner.html`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As seen until now, we have already created separate abstractions to handle both
    an investment and its associated stock. Now, it is time to develop this application's
    user interface and achieve a good result, which is all a matter of organization
    and good practices.
  prefs: []
  type: TYPE_NORMAL
- en: The same principles of software engineering that we apply on the server-side
    code must not be left behind when writing frontend JavaScript code. It is still
    important to think about components and proper separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in terms of components (Views)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about the monolithic JavaScript code bases that plague most of
    the Web, which that are code bases that are impossible to test. And the best way
    not to fall into this trap is by coding the application driven by tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the mockup interface of our Investment Tracker application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Thinking in terms of components (Views)](graphics/B04138_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows the Investment Tracker application's mockup interface
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we go about implementing it? It is easy to see that this application
    has two different responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: One responsibility is to add an investment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another responsibility is to list the added investments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we could start by breaking this interface into two different components.
    To better describe them, we are going to borrow a concept from **MVC frameworks**,
    such as `Backbone.js`, and call them **Views**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here it is, at the top level of the interface, with two base components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewInvestmentView`: This will be responsible for creating new investments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvestmentListView`: This is going to be a list of all added investments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we understand how we must break up the code, but how do we organize it?
    Until now, we have created a file for each new function. This is a good practice,
    and we are going to see how we can improve on that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by thinking about our `NewInvestmentView` component. We can follow
    the pattern we''ve used until now and create a new file, `NewInvestmentView.js`,
    and place it in the `src` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this JavaScript file is more robust than the examples shown
    until now. We have wrapped all the `NewInvestmentView` code inside an **immediately
    invoked function expression** (**IIFE**).
  prefs: []
  type: TYPE_NORMAL
- en: It is called an IIFE because it declares a function and immediately invokes
    it, effectively creating new scope to declare local variables in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice is to use only local variables inside the IIFE. If it needs
    to use a global dependency, pass it through as a parameter. In this example, it
    is already passing three dependencies to the `NewInvestmentView` code: `jQuery`,
    `Investment`, and `Stock`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this at the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And immediate invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The biggest advantage of this practice is that we no longer need to worry about
    polluting the global namespace since everything we declare inside the IIFE will
    be local. This makes it much harder to mess with the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to make anything global, we do that explicitly by attaching it with
    the global object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another advantage is the explicit dependency declaration. We know all about
    a file's external dependencies by glancing at its first line.
  prefs: []
  type: TYPE_NORMAL
- en: Although this practice does not have a great advantage right now (since all
    of the components are being exposed globally), we are going to see how to benefit
    from it in [Chapter 8](ch08.html "Chapter 8. Build Automation"), *Build Automation*.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is also known as the **module pattern**, and we will use it throughout
    the rest of the book (even though sometimes it is omitted for simplification purposes).
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing with the development of the `NewInvestmentView` component, we can
    write some basic acceptance criteria, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of shares'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of the share price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more, but this is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new spec file for this component in the new file `NewInvestmentViewSpec.js`
    inside the `spec` folder, and we can start to translate those specs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, before we can start to implement these, we must first understand the
    concept of **HTML fixtures**.
  prefs: []
  type: TYPE_NORMAL
- en: Test fixtures provide the base state in which the tests run. It could be a class
    instantiation, the definition of an object, or a piece of HTML. In other words,
    to test JavaScript code that handles a form submission, we need to have the form
    available when running the tests. The HTML code containing the form is an HTML
    fixture.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to handle this requirement is to manually append the required DOM element
    inside a setup function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, remove it during teardown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the spec would append a lot of garbage inside the document, and it
    could interfere with the results of other specs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to know that specs should be independent, and that they can
    be run in any particular order. So, as a rule, treat specs completely in isolation
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to have a container in the document where we always put
    the HTML fixtures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That way, the next time a spec runs, it automatically overwrites the previous
    fixture with its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, this can soon escalate into an incomprehensible mess as the fixtures get
    more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Wouldn't it be great if this fixture could be loaded from an external file?
    That is exactly what the Jasmine jQuery extension does with its **HTML fixture**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can place that HTML code in an external file and load it in the document
    with a simple call to `loadFixtures`, passing the fixture file path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the extension looks for files inside the `spec/javascripts/fixtures`
    folder (for the previous example, it would be `spec/javascripts/fixtures/MyFixture.html`)
    and loads its content inside a container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use another of the extension''s global functions to recreate the
    first example. The `setFixtures(html)` function accepts a parameter with the content
    to be placed in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The other available functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appendLoadFixtures(fixtureUrl[, fixtureUrl, …])`: Instead of overwriting the
    content of the fixture container, this appends it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readFixtures(fixtureUrl[, fixtureUrl, …])`: This reads a fixture container''s
    content, but instead of appending it to the document, it returns a string with
    its contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendSetFixtures(html)`: This is the same as `appendLoadFixtures` but with
    an HTML string instead of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jasmine jQuery fixture module caches each file, so we can load the same
    fixture multiple times without penalty at the test suite's speed.
  prefs: []
  type: TYPE_NORMAL
- en: It loads the fixtures using AJAX, and sometimes, a test might want to modify
    the inner workings of JavaScript or jQuery AJAX, as we will see in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*, which would
    break the loading of a fixture. A workaround for this issue is to preload the
    required fixtures on the cache using the `preloadFixtures()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `preloadFixtures(fixtureUrl[, fixtureUrl, …])` function loads one or more
    files in the cache without appending them to the document.
  prefs: []
  type: TYPE_NORMAL
- en: There is an issue, though, while using HTML. Jasmine jQuery loads the HTML fixtures
    using AJAX, but because of the **same origin policy** (**SOP**), modern browsers
    will block all AJAX requests when opening the `SpecRunner.html` with a `file://`
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this problem is to serve the spec runner through an HTTP server,
    as described in [Chapter 4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"),
    *Asynchronous Testing – AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, there is a workaround available in Chrome through the **command-line
    interface** (**CLI**) argument `--allow-file-access-from-files`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, in Mac OS X, it would require the following command in bash
    to open Chrome with this flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More details on this issue can be seen at the GitHub ticket [https://github.com/velesin/jasmine-jquery/issues/4](https://github.com/velesin/jasmine-jquery/issues/4).
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the `NewInvestmentView` component, we can start the development
    of the spec with the help of this HTML fixture plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder named `fixtures` inside the `spec` folder. Based on the mockup
    interface, we can create a new HTML fixture called `NewInvestmentView.html` inside
    the `fixtures` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is an HTML fixture because it would otherwise be rendered by a server and
    the JavaScript code would simply attach to it and add behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are not saving this fixture at the plugin''s default path, we need
    to add a new configuration at the end of the `SpecHelper.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `NewInvestmentSpec.js` file, add a call to load the fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, add both the spec and the source to the runner after the `Stock.js`
    and `Investment.js` files are added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Basic View coding rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to start coding the first View component. To help us through
    the process, we are going to lay two basic rules for View coding happiness:'
  prefs: []
  type: TYPE_NORMAL
- en: The View should encapsulate a DOM element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate Views with observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's see how they work individually.
  prefs: []
  type: TYPE_NORMAL
- en: The View should encapsulate a DOM element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a View is the behavior associated with a DOM element,
    so it makes sense to have this element related to the View. A good pattern is
    to pass a CSS `selector` in the View instantiation that indicates the element
    to which it should refer. Here is the spec for the `NewInvestmentView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor function at the NewInvestmentView.js file, it uses jQuery
    to get the element for this selector and to store it in an instance variable `$element`
    (source), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure this code works, we should write the following test for it in
    the `NewInvestmentViewSpec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `toExist` matcher is a custom matcher provided by the Jasmine jQuery extension
    to check whether an element exists in the document. It validates the existence
    of the property on the JavaScript object and also the successful association with
    the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the `selector` pattern to the View allows it to be instantiated multiple
    times to different elements on the document.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of having an explicit association is knowing that this View
    is not changing anything else on the document, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: A View is the behavior associated with a DOM element, so it shouldn't be messing
    around everywhere on the page. It should only change or access the element associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this concept, let''s implement another acceptance criterion
    regarding the default state of the View, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A naive implementation of the `getSymbolInput` method might use a global jQuery
    lookup to find the input and return its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, that could lead to a problem; if there is another input with that class
    name somewhere else in the document, it might get the wrong result.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to use the View''s associated element to perform a scoped
    lookup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `find` function will only look for elements that are children of `this.$element`.
    It is as if `this.$element` represents the entire document for the View.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will use this pattern everywhere inside the View code, we can create
    a function and use it instead, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s suppose that from somewhere else in the application, we want to
    change the value of a `NewInvestmentView` form input. We know its class name,
    so it could be as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, that simplicity hides a serious problem of encapsulation. This one
    line of code is creating a coupling with what should be an implementation detail
    of `NewInvestmentView`.
  prefs: []
  type: TYPE_NORMAL
- en: If another developer changes `NewInvestmentView`, renaming the input class name
    from `.new-investment-stock-symbol` to `.new-investment-symbol`, that one line
    would be broken.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, the developer would need to look at the entire code base for references
    to that class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A much safer approach is to respect the View and use its APIs, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When implemented, that would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That way, when the code gets refactored, there is only one point to perform
    the change—inside the `NewInvestmentView` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no sandboxing in the browser's document, which means that from
    anywhere in the JavaScript code, we can make a change anywhere in the document,
    there is not much that we can do, besides good practice, to prevent these mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Views with observers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the development of the Investment Tracker application, we would eventually
    need to implement the list of investments. But how would you go about integrating
    `NewInvestmentView` and `InvestmentListView`?
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write an acceptance criterion for `NewInvestmentView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given the new investment View, when its add button is clicked, then it should
    add an investment to the list of investments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very straightforward thinking, and you can see by the writing that
    we are creating a direct relationship between the two Views. Translating this
    into a spec clarifies this perception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This solution creates a dependency between the two Views. The `NewInvestmentView`
    constructor now receives an instance of `InvestmentListView` as its `listView`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'On its implementation, `NewInvestmentView` calls the `addInvestment` method
    of the `listView` object when its form is submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To better clarify how this code works, here is a diagram of how the integration
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Views with observers](graphics/B04138_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows a direct relationship between the two Views
  prefs: []
  type: TYPE_NORMAL
- en: Although very simple, this solution introduces a number of architectural problems.
    The first, and most obvious, is the increased complexity of the `NewInvestmentView`
    specs.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, it makes evolving these components even more difficult due to the
    tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better clarify this last problem, imagine that in the future, we want to
    list investments in a table too. This would impose a change in `NewInvestmentView`
    to support both the list and table Views, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Rethinking on the acceptance criterion, we can get into a much better, future-proof
    solution. Let''s rewrite it as:'
  prefs: []
  type: TYPE_NORMAL
- en: Given the Investment Tracker application, when a new investment is created,
    then it should add the investment to the list of investments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see by the acceptance criterion that it has introduced a new subject
    to be tested: Investment Tracker. This implies a new source and spec file. After
    creating both the files accordingly and adding them to the runner, we can write
    this acceptance criterion as a spec, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can see the same setup code that once was inside the `NewInvestmentView`
    spec. It loads the fixtures required by both Views, instantiates both `InvestmentListView`
    and `NewInvestmentView`, and creates a new instance of `InvestmentTracker`, passing
    both Views as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, while describing the behavior `when a new investment is created`,
    we can see the function call to the `newView.create` function to create a new
    investment.
  prefs: []
  type: TYPE_NORMAL
- en: Later, it checks that a new item was added to the `listView` object by checking
    that `listView.count()` is equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does the integration happen? We can see that by looking at the `InvestmentTracker`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `onCreate` function to register an observer function as a callback
    at `newView`. This observer function will be invoked later when a new investment
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation inside `NewInvestmentView` is quite simple. The `onCreate`
    method stores the `callback` parameter as an attribute of the object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The naming convention of the `_callback` attribute might sound strange, but
    it is a good convention to indicate it as a private member.
  prefs: []
  type: TYPE_NORMAL
- en: Although the prepended underline character won't actually change the visibility
    of the attribute, it at least informs a user of this object that the `_callback`
    attribute might change or even be removed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, when the `create` method is invoked, it invokes `_callback`, passing
    the new investment as a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A more complete implementation would need to allow multiple calls to `onCreate`,
    storing every passed callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the solution illustrated for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Views with observers](graphics/B04138_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using callbacks to integrate the two Views
  prefs: []
  type: TYPE_NORMAL
- en: Later, in [Chapter 7](ch07.html "Chapter 7. Testing React Applications"), *Testing
    React.js Applications*, we will see how the implementation of this `NewInvestmentView`
    spec turned out to be.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Views with jQuery matchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides its HTML fixture module, the Jasmine jQuery extension comes with a set
    of custom matchers, which help in writing expectations with the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of using these custom matchers, as demonstrated, is that
    they generate better error messages. So, although we can write all specs without
    using any of these matchers, it would get us much more useful information when
    an error happens if we used the matchers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this advantage, we can revisit the example of the `should
    expose a property with its DOM element` spec. There, it uses the `toExist` matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If this spec fails, we get a nice error message, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing Views with jQuery matchers](graphics/B04138_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows a nice custom matcher error message
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we rewrite this spec without the custom matcher (still making the same
    validation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the error message gets less informative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing Views with jQuery matchers](graphics/B04138_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upon reading the error, we can't understand what it is truly testing
  prefs: []
  type: TYPE_NORMAL
- en: 'So, use these matchers whenever you can to get better error messages. Let''s
    go over some of the available custom matchers, demonstrated by example, with these
    acceptance criteria of the `NewInvestmentView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of shares'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should allow the input of the share price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should have an empty stock symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should have its shares'' value at zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should have its share price value at zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should have its stock symbol input on focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewInvestmentView` should not allow to add'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important that you understand that these next examples, although useful
    to demonstrate how the Jasmine jQuery matchers work, are not really testing any
    JavaScript code but only the HTML elements that were loaded by the HTML fixture
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The toBeMatchedBy jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This matcher checks whether the element matches the passed CSS selector, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The toContainHtml jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This matcher checks whether the content of the element matches the passed HTML,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The toContainElement jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This matcher checks whether the element contains any child element matching
    the passed CSS selector, as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The toHaveValue jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Only valid for inputs, this validates the expected value against the element''s
    value attribute with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The toHaveAttr jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This matcher tests whether the element has any attribute with the name and
    value specified. The following example shows how to use this matcher to test an
    input for its value attribute, an expectation that could have been written with
    the `toHaveValue` matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The toBeFocused jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code illustrates how the matcher checks whether the input element
    is focused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The toBeDisabled jQuery matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This matcher checks whether the element is disabled with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: More matchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The extension has many more available matchers; make sure to check the documentation
    of the project at [https://github.com/velesin/jasmine-jquery#jquery-matchers](https://github.com/velesin/jasmine-jquery#jquery-matchers).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how testing can become so much easier once you
    drive the application development by tests. You saw how to use the module pattern
    to better organize the project code and how the View pattern can help create a
    more maintainable browser code.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use HTML fixtures, making your specs much more readable and
    understandable. I also showed you how to test code that interacts with the browser's
    DOM by the use of custom jQuery matchers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go a step further and start testing server integration
    and asynchronous code.
  prefs: []
  type: TYPE_NORMAL

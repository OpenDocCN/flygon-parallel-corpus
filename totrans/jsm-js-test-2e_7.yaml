- en: Chapter 7. Testing React Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a web developer, you are familiar with the way most websites are built today.
    There is usually a web server (in languages such as Java, Ruby, or PHP) that processes
    user requests and responds with markup (HTML).
  prefs: []
  type: TYPE_NORMAL
- en: This means that on every request, the web server interprets the user action
    through the URL and renders the entire page.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to improve the user experience, more and more functionality started
    to get pushed from the server side to the client side, and JavaScript was no longer
    simply adding behavior to the page but was rendering it entirely. The biggest
    advantage was that a user action was no longer triggering a whole page refresh;
    the JavaScript code could deal with the entire browser document and mutate it
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Although this did improve the user experience, it started to add a lot of complexity
    to the application code, which led to increased maintenance costs and the worst—bugs
    in the form of inconsistencies between different parts of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to bring sanity to this scenario, a number of libraries and frameworks
    were built, but they all failed in the sense that they didn't tackle the root
    cause of the entire problem—mutability.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering was easy because there was no mutation to deal with. Given
    a new application state, the server would simply render everything again. What
    if we could get benefits from this approach in our client-side JavaScript code?
  prefs: []
  type: TYPE_NORMAL
- en: That is exactly what **React** proposes to do. You declaratively write the interface
    code in the form of components and tell React to render. On any change of the
    application state, you can simply tell React to re-render again; it will then
    calculate the mutations required to move the DOM to the required state and apply
    them for you.
  prefs: []
  type: TYPE_NORMAL
- en: During this chapter, we are going to understand how React works by refactoring
    the code we've built so far into an SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, before we can dive into React, first we need a small setup in our project
    to allow us to create React components.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)
    and download the React Starter Kit Version 0.12.2 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: After the download, you can unpack its contents and move all the files from
    within the build folder to our application's lib folder. Then, just load the React
    library onto the `SpecRunner.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the setup complete, we can move on to writing our very first component.
  prefs: []
  type: TYPE_NORMAL
- en: Our first React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the introduction of this chapter, with React, you declaratively
    write the interface code through components.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a React component is analogous to the component concept presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*, so expect to see some similarities next.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's create our very first component. To better understand
    what a React component is, we are going to use a very simple acceptance criterion
    and as usual start from the spec.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement "InvestmentListItem should render". It's very simple and not
    really *feature oriented* but is a good example to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: 'With what we learned in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, we could start coding this spec by creating a
    new file called `InvestmentListItemSpec.js` and save it in the `components` folder
    inside the `spec` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Add the new file to the `SpecRunner.html` file, as already demonstrated in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: At the spec, we are basically using the `jasmine-jquery` plugin to expect that
    the encapsulated DOM element of our component is equal to a specific CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: How would we change this example to be a test of a React component? The only
    difference is the API to get the DOM node. Instead of `$element` with a jQuery
    object, React exposes a function called `getDOMNode()` that returns what it states—a
    DOM node.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we can use the same assertion as before and have our test ready,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy! So, the next step is to create the component, render it, and
    attach it to the document. That is simple as well; take a look at the following
    gist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It might seem like a lot of code, but half of it is just boilerplate to set
    up a document element fixture that we can render the React component in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use the `setFixtures` function from `jasmine-jquery` to create an
    element in the document with the `application-container` ID. Then, using the `getElementById`
    API, we query for this element and save it in the `container` variable. The next
    two steps are the ones specific to React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, in order to use a component, we must first create an element from its
    class; this is done through the `React.createElement` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, with the element instance, we can finally tell React to render it through
    the `React.render` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` function accepts the following two parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The React element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DOM node to render the element in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As of now, the spec is complete. You can run it and see it fail, showing the
    following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to code the component. So, let's feed the spec, create a new
    file in the `src` folder, name it `InvestmentListItem.js`, and add it to the spec
    runner. This file should follow the module pattern we've been using until now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a new class of component using the `React.createClass` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the least, the `React.createClass` method expects a single `render` function
    that should return a tree of React elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use again the `React.createElement` method to create the element that is
    going to be the root of the rendering tree, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference from its previous usage in the `beforeEach` block is that here,
    it is also passing a list of **props** (with `className`) and a single child containing
    the text `Investment`.
  prefs: []
  type: TYPE_NORMAL
- en: We will get deeper into the meaning of the props parameter, but you can think
    of it as analogous to the attributes of an HTML DOM element. The `className` prop
    will turn into the class HTML attribute of the `li` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `React.createElement` method signature accepts three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the component that can be either a string representing a real DOM
    element (such as `div`, `h1`, `p`) or a React component class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object containing the props values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And a variable number of children components, which in this case, is just the
    `Investment` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On rendering this component (by invoking the `React.render()` method), the
    result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a direct representation of the JavaScript code that generated it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You've built your first fully tested React component.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you define a component's render method and invoke the `React.createElement`
    method, you are not actually rendering anything in the document (you are not even
    creating DOM elements).
  prefs: []
  type: TYPE_NORMAL
- en: It is only through the `React.render` function that the representation created
    by invoking these `React.createElement` calls are effectively converted into real
    DOM elements and attached to the document.
  prefs: []
  type: TYPE_NORMAL
- en: This representation, defined by `ReactElements`, is what React calls the Virtual
    DOM. And `ReactElement` must not be confused with DOM elements; it is instead
    a light, stateless, immutable, virtual representation of a DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: So why did React get into the trouble of creating a new way of representing
    the DOM? The answer here is *performance*.
  prefs: []
  type: TYPE_NORMAL
- en: As browsers evolved, JavaScript performance kept getting better and better,
    and today's application bottlenecks aren't actually JavaScript. You've probably
    heard that you should try touching the DOM as little as possible, and React allows
    you to do that by letting you interact with its own version of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: However, that is not the only reason. React has built a very powerful diffing
    algorithm that can compare two distinct representations of the Virtual DOM, compute
    their differences, and with that information, create mutations that then get applied
    to the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to get back to the flow we used to have with server-side rendering.
    We can basically, on any change of the application state, ask React to re-render
    everything, and it will then compute the minimal number of changes required and
    apply only that to the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: It frees us developers from worrying about mutating the DOM and empowers us
    to write our user interfaces in a declarative way, while reducing bugs and improving
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any experience writing frontend JavaScript applications, you might
    be familiar with a few template languages. At this moment, you might be wondering
    where can you use your favorite template language (such as Handlebars) with React.
    And the answer is that you can't.
  prefs: []
  type: TYPE_NORMAL
- en: React doesn't make any distinction between markup and logic; in a React component,
    they are effectively the same.
  prefs: []
  type: TYPE_NORMAL
- en: However, what happens when we start crafting more complicated components? How
    would the form we built in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, translate into a React component?
  prefs: []
  type: TYPE_NORMAL
- en: 'To just render it without any other logic, it would take a bunch of `React.createElement`
    calls, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very verbose and hard to read. So, given that a React component is
    both markup and logic, wouldn''t it be better if we could write it as a mixture
    of HTML and JavaScript? Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That is **JSX**, a JavaScript syntax extension that looks like XML and was built
    to be used with React.
  prefs: []
  type: TYPE_NORMAL
- en: It transforms into JavaScript, so given the latter example, it would compile
    directly to the plain JavaScript code presented before.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of the transformation process is that it doesn't change
    the line numbers; so, *line 10* in the JSX will translate into *line 10* in the
    transformed JavaScript file. This helps while debugging the code and doing static
    code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the language, you can check the official specification
    at [http://facebook.github.io/jsx/](http://facebook.github.io/jsx/), but for now,
    you can just follow the next examples as we dive into the features of this language.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that it is not a requirement to use JSX while implementing
    React components, but it makes the process a lot easier. With that in mind, we
    are going to keep using it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSX with Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to use JSX with our Jasmine runner, there are a few changes
    we need to make.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to rename the files with which we want to use the JSX syntax
    to `.jsx`. Although this is not a requirement, it allows us to easily identify
    when a file is using this special syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on the `SpecRunner.html` file, we need to change the script tags to indicate
    that these are not regular JavaScript files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, these are not the only changes we need to make. The browser doesn't
    understand JSX syntax, so we need to load a special transformer that will first
    transform these files into regular JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This transformer comes bundled in the React starter kit, so just load it right
    after loading React, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this setup done, we should be able to run the tests, shouldn't we? Unfortunately,
    there is one more step.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to open the `SpecRunner.html` file in the browser, you will see that
    the tests of `InvestmentListItem` are not being executed. That is because the
    transformer works by loading the script files through AJAX, transforming them
    and finally attaching them to the DOM. By the time this process is complete, Jasmine
    has already run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to inform Jasmine to wait for these files to load and be transformed.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to do that is to change Jasmine's `boot.js` file placed in
    the `jasmine-2.1.3` folder, inside the `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the original file, you are going to need to find the line that contains
    the `env.execute();` method and comment it out. It should be something like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Everything else in the file should remain the same. After this change, you will
    see that the tests are no longer running—none of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing piece is invoking this `execute` method once the JSX files
    are loaded. To do so, we are going to create a new file called `boot-exec.js`
    inside the `jasmine.2.1.3` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you see, it is only executing the previously commented code from the original
    boot file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this custom boot is very simple. We add it to the last line of the `<head>`
    tag of `SpecRunner.html` as a JSX type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `JSXTransformer` library guarantees that the scripts are loaded in the order
    they are declared. So, by the time the `boot-exec.js` file is loaded, the source
    and test files are already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: With that, our test runner now supports JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Component attributes (props)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Props are the way to pass down data from a parent to a child component in React.
  prefs: []
  type: TYPE_NORMAL
- en: For this next example, we want to change the `InvestmentListItem` component
    to render the value of the `roi` variable formatted in percentage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the next specs, we are going to use a few helper methods that
    React offers through the `React.addons.TestUtils` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are no longer using the `setFixture` method from the `jasmine-jquery`
    matcher. Instead, we are using the `TestUtils` module to render the component.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference here is that `TestUtils.renderIntoDocument` doesn't actually
    render in the document, but it renders into a detached node.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you will notice is that the `InvestmentListItem` component has
    an attribute (actually called **prop**) where we pass down `investment`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, at the spec, we are using another helper method called `findRenderedDOMComponentWithClass`
    to look for a DOM element in our `component` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns `ReactElement`. And again, we will use the `getDOMNode`
    method to get the actual DOM element and then use the `jasmine-jquery` matcher
    to check for its text value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing this behavior in the component is actually very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can access any props passed to a component through the `this.props` object.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the original implementation, we've added a `span` element with the
    expected class from the spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the return on investment to be dynamic, JSX has a special syntax.
    Using `{}`, you can invoke any JavaScript code in the middle of the XML. We are
    invoking the `formatPercentage` function while passing the `investment.roi()`
    value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, just to make this clear, this JSX transformed into JavaScript would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to know that a prop should be immutable. It is not the responsibility
    of a component to change its own prop values. You can consider a React component
    that has only props as a pure function, in that it always returns the same result
    value given the same argument values.
  prefs: []
  type: TYPE_NORMAL
- en: This makes testing very simple as there are no mutations or changes in the state
    to test a component.
  prefs: []
  type: TYPE_NORMAL
- en: Component events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI applications have user events; in the web, they came in the form of DOM events.
    As React wraps each DOM element into React elements, handling them will be a little
    different yet very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this next example, let''s suppose that our application will allow users
    to delete an investment. We could write this requirement through the following
    acceptance criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: Given an investment, InvestmentListItem should notify an observer onClickDelete
    when the delete button is clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is the same as presented in the *Integrate Views with observers*
    section of [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing
    Frontend Code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how should we set the observer in a component? As we''ve already seen previously,
    **props** are the way to pass attributes to our component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we passed down another prop to the `onClickDelete` component,
    and as its value, we set a Jasmine spy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Then, we found the delete button through its tag and used the `TestUtils`
    module to simulate a click, expecting the previously created spy to be called,
    as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**The `TestUtils.Simulate` module contains helper methods to simulate all types
    of DOM events, as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Then, we got back to the implementation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**As you can see, it was as simple as nesting another `button` component and
    passing down the `onClickDelete` prop value as its `onClick` prop.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**React normalizes events so that they have consistent properties across different
    browsers, but its naming conventions and syntax is similar to inline JavaScript
    code in HTML. To get a comprehensive list of the supported events, you can check
    the official documentation at [http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**# Component state'
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we've dealt with React as a stateless rendering engine, but as we
    know, applications have state, especially when using forms. So, how would we implement
    the `NewInvestment` component in order for it to keep hold of the values of the
    investment being created and then notify an observer once the user completed the
    form?
  prefs: []
  type: TYPE_NORMAL
- en: To help us implement this behavior, we are going to use another component internal
    API—its **state**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following acceptance criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that the inputs of the `NewInvestment` component are correctly filled,
    when the form is submitted, it should notify the `onCreate` observer with the
    investment attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This spec is basically using every trick we've learned until now, so without
    getting into the details, let's dive directly into the component implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that any component with state must declare is its initial state
    by defining a `getInitialState` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in the preceding code, we are clearly defining the initial state
    of our form, and at the render method, we pass the state as `value` props to the
    input components.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this example in a browser, you will notice that you won't be able
    to change the values of the inputs. You can focus on the inputs, but trying to
    type won't change its values, and that is because of the way React works.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike HTML, React components must represent the state of the view at any point
    in time and not only at initialization time. If we want to change the value of
    an input, we need to listen for the `onChange` events of the inputs and, with
    that information, update the state. The change in the state will then trigger
    a render that will update the value on screen.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how this works, let's implement this behavior at the `stockSymbol`
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to change the render method, adding a handler to the `onChange`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the event is triggered, it will invoke the `_handleStockSymbolChange`
    method. Its implementation should update the state by invoking the `this.setState`
    method with the new value of the input, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The event handler is a good place to perform simple validation or transformation
    in the input data before passing it to the state.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a lot of boilerplate code just to handle a single input.
    Since we are not implementing any custom behavior into our event handlers, we
    can use a special React feature that implements this "linked state" for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a **Mixin** called `LinkedStateMixin`; but first, what
    is a Mixin? It is a way to share common functionality between components, which,
    in this case, is the "linked state". Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`LinkedStateMixin` works by adding the `linkState` function to the component,
    and instead of setting the `value` of the input, we set a special prop called
    `valueLink` with the link object returned by the function `this.linkState`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `linkState` function expects the name of the attribute of the **state**
    that it should link to the value of the input.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have noticed, React has an opinionated view on a component's API.
    But it also has a very strong opinion on its life cycle, allowing us developers
    to add hooks to create custom behavior and perform cleanup tasks as we develop
    our components.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of React's greatest triumphs because it is through this standardization
    that we can create bigger and better components by composition; through that,
    we can use not only our components, but other people's components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate one use case, we are going to implement a very simple behavior:
    on page load, we want the new investment form stock symbol input to be focused
    so that a user can start typing right away.'
  prefs: []
  type: TYPE_NORMAL
- en: But, before we can start writing the test, there is just one thing that we will
    need to do. As mentioned earlier, `TestUtils.renderIntoDocument` doesn't actually
    render anything in the document, but instead on a detached node. So, if we use
    it to render our component, we won't be able to make the assertion regarding the
    input's focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, yet again, we have to use the `setFixtures` method to actually render the
    React component in the document, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this small change completed, and the spec written, we can get back to the
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'React gives a few hooks that we can implement custom code in our component
    during its life cycle; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillReceiveProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUnmount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement our custom behavior, we are going to use the `componentDidMount`
    hook that is called only once, right after the component was rendered and attached
    into a DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we want to do is somehow inside this hook, get access to the input
    DOM element and trigger its focus. We already know how to get a DOM node; it is
    through the `getDOMNode` API. But, how do we get the input's React element?
  prefs: []
  type: TYPE_NORMAL
- en: React's other feature for this problem is called **ref**. It is basically a
    way to give names to a component's children to allow later access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want the stock symbol input, we need to add a `ref` attribute to it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the `componentDidMount` hook, we can get the input by its `ref` name
    and then its DOM element and trigger the focus, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The other hooks are setup in the same way, by simply defining them on the class
    definition object as properties. But each is called on different occasions, and
    has different rules. The official documentation is a great resource on their definition
    and possible use-cases which can be found at [http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods).
  prefs: []
  type: TYPE_NORMAL
- en: Composing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked a lot about **composability** in the way of creating components
    by composing React's default components. However, we haven't showed how to compose
    custom components into bigger components.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have guessed, this should be a pretty simple exercise, and to
    demonstrate how this works, we are going to implement a component to list investments,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as using the already available `InvestmentListItem` global variable
    as the root element of the `InvestmentList` component.
  prefs: []
  type: TYPE_NORMAL
- en: The component expects an `investments` prop to be an array of investments. It
    then maps it through creating an `InvestmentListItem` element for each investment
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it uses the `listItems` array as the children of an `ul` element, effectively
    defining how to render the list of investments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a rapidly evolving library that is getting a lot of traction by the
    JavaScript community; it introduced some interesting patterns and questioned some
    well-established dogmas as it is continually improving the development of rich
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's goal was not to give an in-depth look into the library but an
    overview of its primary features and philosophies. It demonstrated that it is
    possible to do test-driven development while coding your interface with React.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about **prop** and **state** and their differences: A **prop**
    is not owned by the component, and should, if needed, be changed by its parent.
    The **state** is the data that the component owns. It can be changed by the component,
    and by doing so, a new render is triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: The fewer components with state you have in your application, the easier it
    is going to be to reason about it and test it.
  prefs: []
  type: TYPE_NORMAL
- en: It is through React's opinionated API and life cycle that we can get the maximum
    benefit of composability and code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: As you move into application development with React, it is recommended that
    you learn about Flux, the recommended architecture to build applications by Facebook,
    at [http://facebook.github.io/flux/](http://facebook.github.io/flux/).**
  prefs: []
  type: TYPE_NORMAL

- en: Start Your Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动你的引擎
- en: 'In this chapter, we will be taking our first steps with Kubernetes. You will
    learn how to start a cluster suitable for learning and development use on your
    own workstation, and will begin to learn how to use Kubernetes itself. In this
    chapter, we will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将迈出Kubernetes的第一步。您将学习如何在自己的工作站上启动一个适合学习和开发使用的集群，并开始学习如何使用Kubernetes本身。在本章中，我们将做以下事情：
- en: Learn how to install and use Minikube to run Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何安装和使用Minikube来运行Kubernetes
- en: Build a simple application that runs in a Docker container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个在Docker容器中运行的简单应用程序
- en: Use Kubernetes to run simple applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes来运行简单的应用程序
- en: Your own Kubernetes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您自己的Kubernetes
- en: '**Minikube** is a tool that makes it easy to run a simple Kubernetes cluster
    on your workstation. It is very useful, as it allows you to test your applications
    and configurations locally and quickly iterate on your applications without needing
    access to a larger cluster. For our purposes, it is the ideal tool to get some
    practical hands-on experience with Kubernetes. It is very simple to install and
    configure, as you will discover.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Minikube**是一个工具，可以在您的工作站上轻松运行一个简单的Kubernetes集群。它非常有用，因为它允许您在本地测试应用程序和配置，并快速迭代应用程序，而无需访问更大的集群。对于我们的目的来说，它是获得一些实际的Kubernetes实践经验的理想工具。安装和配置非常简单，您会发现。'
- en: Installation
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'You will need a few tools to get Kubernetes running on your workstation:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一些工具来在您的工作站上运行Kubernetes：
- en: '`kubectl` is the Kubernetes command-line interface. Throughout this book, you
    will be using it to interact with Kubernetes.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`是Kubernetes命令行界面。在本书中，您将使用它与Kubernetes进行交互。'
- en: In the Kubernetes community, no one agrees how to pronounce `kubectl`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes社区中，没有人同意如何发音`kubectl`。
- en: 'Try out these different ways and choose your favorite:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些不同的方法并选择您喜欢的：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`minikube` is a command that manages Kubernetes on your local machine. It handles
    all the hard stuff, so you can get started with Kubernetes straight away.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`是一个在本地机器上管理Kubernetes的命令。它处理所有困难的事情，所以您可以立即开始使用Kubernetes。'
- en: '`docker`, the `minikube` virtual machine, has the Docker daemon running internally,
    but you might need the Docker command line installed on your workstation if you
    want to interact with it directly.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`，`minikube`虚拟机内部运行着Docker守护程序，但如果您想直接与其交互，您可能需要在您的工作站上安装Docker命令行。'
- en: 'It is best to use Minikube in conjunction with a virtual machine, as platforms
    like macOS and Windows don''t natively support Linux containers, and even on Linux
    it helps to keep your environment clean and isolated. There are various virtualization
    tools you can use with `minikube,` depending on your operating system:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好与虚拟机一起使用Minikube，因为像macOS和Windows这样的平台不本地支持Linux容器，即使在Linux上，也有助于保持您的环境干净和隔离。根据您的操作系统，您可以使用各种虚拟化工具与`minikube`一起使用：
- en: '**VirtualBox**: It is simple to use and can be installed on macOS, Windows,
    and Linux.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VirtualBox**：它易于使用，可以安装在macOS、Windows和Linux上。'
- en: '**VMware Fusion**: It is a commercial tool available on macOS.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMware Fusion**：这是macOS上可用的商业工具。'
- en: '**KVM**: It is a well-known Linux virtualization tool.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KVM**：这是一个众所周知的Linux虚拟化工具。'
- en: '**xhyve**: It is an open source project that utilizes the native hypervisor
    framework in macOS. It performs very well but can be a little harder to install
    and use.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xhyve**：这是一个利用macOS中的本机虚拟化框架的开源项目。它的性能非常好，但安装和使用可能有点困难。'
- en: '**Hyper-V**: It is the native virtualization tool for Windows. Remember, you
    might need to manually enable it on your machine and set up its networking.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hyper-V**：这是Windows的本地虚拟化工具。请记住，您可能需要在您的机器上手动启用它并设置其网络。'
- en: In this book, we are going to cover the default option, VirtualBox, but if you
    are using Minikube regularly, you might want to explore some of the other options,
    as they can be more performant and reliable if set up correctly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍默认选项VirtualBox，但如果你经常使用Minikube，你可能想探索一些其他选项，因为如果设置正确，它们可能更高效和可靠。
- en: You can find some documentation about the different drivers available at [https://git.k8s.io/minikube/docs/drivers.md](https://git.k8s.io/minikube/docs/drivers.md).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://git.k8s.io/minikube/docs/drivers.md](https://git.k8s.io/minikube/docs/drivers.md)找到一些关于不同驱动程序的文档。
- en: macOS
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: On a Mac, the best way to install `minikube` and `kubectl` is with the Homebrew
    package manager.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，安装`minikube`和`kubectl`的最佳方法是使用Homebrew软件包管理器。
- en: 'The Homebrew package manager for macOS is a simple way to install development
    tools. You can find out how to install it on the website: [https://brew.sh/](https://brew.sh/)[.](https://brew.sh/)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: macOS的Homebrew软件包管理器是安装开发工具的简单方法。你可以在网站上找到如何安装它：[https://brew.sh/](https://brew.sh/)。
- en: 'Start by installing the Kubernetes command-line client `kubectl`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装Kubernetes命令行客户端`kubectl`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, install `minikube` and `virtualbox`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装`minikube`和`virtualbox`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Linux
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, the simplest installation method is to download and install pre-built
    binaries:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，最简单的安装方法是下载并安装预构建的二进制文件：
- en: 'You should download the binaries for `minikube` and `kubectl`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该下载`minikube`和`kubectl`的二进制文件：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have downloaded the binaries, make them executable and move them to
    somewhere on your path:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你下载了二进制文件，将它们设置为可执行，并将它们移动到你的路径中的某个位置：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method of installing VirtualBox on Linux will depend on your distribution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上安装VirtualBox的方法将取决于你的发行版。
- en: 'Take a look at the instructions on the VirtualBox website: [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看VirtualBox网站上的说明：[https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads)。
- en: Windows
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Installing Minikube on a Windows machine is as simple as it is on Linux or macOS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上安装Minikube与在Linux或macOS上一样简单。
- en: Start by installing VirtualBox.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装VirtualBox。
- en: You can download the Windows installer for VirtualBox from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)下载VirtualBox的Windows安装程序。
- en: 'If you are using the chocolatey package manager, perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用chocolatey软件包管理器，请执行以下步骤：
- en: 'Install `minikube`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`minikube`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install `kubectl`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`kubectl`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are not using chocolatey, you can manually install `minikube` and `kubectl`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用chocolatey，你可以手动安装`minikube`和`kubectl`。
- en: 'Download `minikube` at [https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe)
    and rename it to `minikube.exe`. Then move it to a location on your path. Download
    `kubectl`: [https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe](https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe)
    and then move it to a location on your path.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe)下载`minikube`并将其重命名为`minikube.exe`。然后将它移动到你路径上的某个位置。下载`kubectl`：[https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe](https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe)，然后将它移动到你路径上的某个位置。
- en: Starting Minikube
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Minikube
- en: Once you have got `minikube` and your chosen virtualization tool installed,
    we can use it to build and start a local Kubernetes cluster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装好了`minikube`和你选择的虚拟化工具，我们就可以用它来构建和启动本地Kubernetes集群。
- en: 'If you choose to use `minikube` tool''s default settings, doing so couldn''t
    be simpler. Just run:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用`minikube`工具的默认设置，那么做起来就很简单。只需运行：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should then see some output, similar to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该会看到一些输出，类似于以下内容：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`minikube` start has many options that can be used to configure the cluster
    that is launched. Try running `minikube` help start to find out what you can customize.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`minikube` start有许多选项，可用于配置启动的集群。尝试运行`minikube` help start以找出您可以自定义的内容。'
- en: You might want to set `--cpus` and/or `--memory` to customize how much of your
    computer's resources are used for the Minikube VM.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要设置`--cpus`和/或`--memory`来自定义您的计算机资源用于Minikube VM的使用量。
- en: Assuming that everything went as expected, that's it; you should have a cluster
    installed and running on your local machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切都如预期那样进行，那就是了；您应该在本地机器上安装并运行了一个集群。
- en: The kubectl `config` file (found at `~/.kube/config` by default) defines contexts.
    A context links to a cluster and a user object. The cluster defines how.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl`配置`文件（默认情况下在`~/.kube/config`中找到）定义了上下文。上下文链接到一个集群和一个用户对象。集群定义了如何。
- en: The `minikube start` command creates a `kubectl` context pointing to the API
    server running within the Minikube VM, and is correctly configured with a user
    that will allow access to Kubernetes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`minikube start`命令创建了一个指向Minikube VM内运行的API服务器的`kubectl`上下文，并且正确配置了一个允许访问Kubernetes的用户。'
- en: 'As you progress through this book, you will of course want to add additional
    contexts in order to connect to remote clusters that you many have set up. You
    should be able to switch back to the `minikube` context whenever you want to use
    `minikube` by running the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本书时，您当然会想要添加额外的上下文，以便连接到您可能设置的远程集群。您应该能够通过运行以下命令随时切换回`minikube`上下文，以便使用`minikube`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First steps with kubectl
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl的第一步
- en: 'Let''s start by validating that `kubectl` has indeed been configured to use
    your cluster correctly and that we can connect to it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先验证`kubectl`是否确实已配置为正确使用您的集群，并且我们可以连接到它：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see some output like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似于这样的输出：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your output might show slightly different version numbers, but assuming that
    you see a version number from both the client and the server, you can connect
    to the cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能显示略有不同的版本号，但是假设您从客户端和服务器都看到了一个版本号，那么您就可以连接到集群。
- en: If you can't see the server version, or you saw some other error message, skip
    forward to the *Troubleshooting Minikube* section of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到服务器版本，或者看到其他错误消息，请跳转到本章的*Minikube故障排除*部分。
- en: Let's start interacting with the cluster with some of the `kubectl` commands
    that are going to be useful to us when we interact with our cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用一些在与集群交互时对我们有用的`kubectl`命令来与集群进行交互。
- en: 'The first command that we will explore is the `get` command. This lets us list
    basic information about the resources on the cluster. In this case, we are getting
    a list of all the node resources:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一个命令是`get`命令。这使我们能够列出有关集群上资源的基本信息。在这种情况下，我们正在获取所有节点资源的列表：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, on our Minikube installation, this is not very exciting, as
    we only have one node. But on larger clusters with many nodes, being able to see
    this information about all the nodes (or some subset) could be very useful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们的Minikube安装中，这并不是很令人兴奋，因为我们只有一个节点。但是在具有许多节点的较大集群上，能够查看有关所有节点（或某些子集）的信息可能非常有用。
- en: 'The next command will allow us to drill down and look at some more detailed
    information about a particular resource. Try running the following command against
    your installation to see what you can discover about the Minikube VM:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令将允许我们深入研究并查看有关特定资源的更详细信息。尝试运行以下命令来查看您可以发现有关Minikube VM的信息：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you progress through this book, you will discover that being able to get
    and describe the various resources that the Kubernetes API exposes will become
    second nature to you whenever you want to discover what is happening on your cluster
    and why.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您在本书中的进展，您将发现能够获取和描述Kubernetes API公开的各种资源将成为您的第二天性，无论何时您想要发现集群上发生了什么以及为什么。
- en: 'Before we move on, `kubectl` has one more trick to help us. Try running the
    following command for a description of each of the resource types available on
    the cluster and some examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，`kubectl`还有一个技巧可以帮助我们。尝试运行以下命令，以获取集群上可用的每种资源类型的描述和一些示例：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Building Docker containers inside the cluster
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集群内构建Docker容器
- en: You might already have Docker installation on your workstation, but when you
    are working on an application it can improve your workflow to build your images
    on the Docker daemon running inside the Minikube VM that hosts your Kubernetes
    cluster. This means that you can skip pushing your images to a Docker repo before
    using them in Kubernetes. All you need do is build and tag your images, and then
    refer to them by name in your Kubernetes resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在工作站上安装了Docker，但是当您在应用程序上工作时，将图像构建在托管Kubernetes集群的Minikube VM内部运行的Docker守护程序上可以改善您的工作流程。这意味着您可以跳过将图像推送到Docker仓库，然后在Kubernetes中使用它们。您只需要构建和标记您的图像，然后在Kubernetes资源中按名称引用它们。
- en: If you already have a Docker installation on your workstation, you should already
    have the command-line client installed that you need to interact with the Minikube
    Docker daemon. If you don't, it is quite easy to install, either by installing
    the Docker package for your platform or, if you just want the command-line tool,
    downloading the binary and copying it into your path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的工作站上已经安装了Docker，那么您应该已经安装了与Minikube Docker守护程序交互所需的命令行客户端。如果没有，安装也很容易，可以通过安装适用于您平台的Docker软件包，或者如果您只想要命令行工具，可以下载二进制文件并将其复制到您的路径中。
- en: 'To correctly configure the Docker CLI to communicate with the Docker demon
    inside the minikube VM, minikube provides a command that will return environment
    variables to configure the client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确配置Docker CLI与minikube VM内部的Docker守护进程通信，minikube提供了一个命令，将返回环境变量以配置客户端：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On Mac or Linux, you can correctly expand these variables into your current
    shell environment by running:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac或Linux上，您可以通过运行正确地将这些变量扩展到当前的shell环境中：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Try running some `docker` commands to check everything is set up correctly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行一些`docker`命令来检查一切是否设置正确：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This should show you the version of Docker running inside the Minikube VM. You
    might notice that the server version of Docker running in the Minikube VM is a
    little bit behind the latest version of Docker, since it takes some time for Kubernetes
    to be tested against new versions of Docker to be considered stable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向您显示在Minikube VM内运行的Docker版本。您可能会注意到，在Minikube VM中运行的Docker服务器版本略落后于最新版本的Docker，因为Kubernetes需要一些时间来测试新版本的Docker，以确保稳定性。
- en: 'Try listing the running containers. You should notice a container running the
    Kubernetes dashboard, as well as some other services that Kubernetes has launched,
    such as `kube-dns` and the `addon` manager:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试列出正在运行的容器。您应该注意到一个正在运行Kubernetes仪表板的容器，以及Kubernetes启动的一些其他服务，如`kube-dns`和`addon`管理器：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Building and launching a simple application on Minikube
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Minikube上构建和启动一个简单的应用程序
- en: Let's take our first steps to building a simple application on our local minikube
    cluster and getting it to run.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们迈出第一步，在我们的本地minikube集群上构建一个简单的应用程序并让它运行。
- en: The first thing we need to do is build a container image for our application.
    The simplest way to do this is to create a Dockerfile and use the `docker build`
    command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的应用程序构建一个容器映像。这样做的最简单方法是创建一个Dockerfile并使用 `docker build` 命令。
- en: 'Use your favorite text editor to create a file called Dockerfile with the following
    content:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器创建一个名为Dockerfile的文件，内容如下：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To build the application, first ensure your Docker client is pointing to the
    Docker instance inside the Minikube VM by running:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序，首先确保您的Docker客户端指向Minikube VM内的Docker实例，方法是运行：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then use Docker to build the image. In this case, we are tagging the image
    `hello`, but you could use any tag you wanted:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用Docker构建映像。在这种情况下，我们给映像打了一个标签 `hello`，但您可以使用任何您想要的标签：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Kubectl has a `run` command that we can use to quickly get a pod running on
    the Kubernetes cluster. In the background, it creates a Kubernetes deployment
    resource that ensures that a single instance of our `hello` container runs within
    a pod (we will learn more about this later):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl有一个 `run` 命令，我们可以使用它快速在Kubernetes集群上运行一个pod。在后台，它创建了一个Kubernetes部署资源，确保我们的
    `hello` 容器的单个实例在一个pod中运行（我们稍后会更多地了解这一点）：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are setting `--image-pull-policy=Never` here to ensure that Kubernetes uses
    the local image that we just built, rather than the default of pulling the image
    from a remote repository, such as Docker Hub.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里设置 `--image-pull-policy=Never` 是为了确保Kubernetes使用我们刚刚构建的本地映像，而不是默认从远程存储库（如Docker
    Hub）拉取映像。
- en: 'We can check that our container has started correctly with `kubectl get`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl get` 来检查我们的容器是否已经正确启动：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our hello world application was simple enough to set up, but we need some way
    to access it for our experiment to be considered a success. We can use the `kubectl
    expose` command to create a service pointing to the pod in the deployment that
    was just created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的hello world应用程序设置起来足够简单，但我们需要一些方法来访问它，以便我们的实验被认为是成功的。我们可以使用 `kubectl expose`
    命令来创建一个指向刚刚创建的部署中的pod的服务：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have set the service type to NodePort in this case so that Kubernetes will
    expose a random port on the Minikube VM so that we can access our service easily.
    In [Chapter 6](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml), *Planning for Production*,
    we will discuss exposing our applications to the outside world in more detail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已将服务类型设置为NodePort，这样Kubernetes将在Minikube VM上公开一个随机端口，以便我们可以轻松访问我们的服务。在[第6章](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml)中，*生产规划*，我们将更详细地讨论将应用程序暴露给外部世界的问题。
- en: When you create a service of the `NodePort` type, Kubernetes automatically allocates
    us a port number for the service to be exposed on. In a multi-node cluster, this
    port will be opened on every node in the cluster. Since we only have a single
    node, working out how to access the cluster is a little bit simpler.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个`NodePort`类型的服务时，Kubernetes会自动为我们分配一个端口号，以便服务可以在其上公开。在多节点集群中，此端口将在集群中的每个节点上打开。由于我们只有一个节点，因此找出如何访问集群会简单一些。
- en: 'First, we need to discover the IP address of the Minikube VM. Luckily, there
    is a simple command we can run to get this information:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要发现Minikube VM的IP地址。幸运的是，我们可以运行一个简单的命令来获取这些信息：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is more than likely that when the `minikube` VM started on your machine,
    it was allocated a different IP address from my own, so make a note of the IP
    address on your own machine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能当`minikube` VM在您的机器上启动时，它被分配了一个与我的不同的IP地址，所以请记下您自己机器上的IP地址。
- en: 'Next, in order to discover the port that Kubernetes has exposed our service
    on, let''s use `kubectl get` on our service:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了发现Kubernetes已经在哪个端口上公开了我们的服务，让我们在服务上使用 `kubectl get`：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see, in this case, that Kubernetes has exposed port `80` on our container
    as port `32286` on our node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以看到Kubernetes已经将容器上的端口`80`暴露为节点上的端口`32286`。
- en: 'You should now be able to construct a URL that you can visit in your browser
    to test out the application. In my case, it is `http://192.168.99.100:32286`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够构建一个URL，在浏览器中访问该应用程序进行测试。在我的情况下，它是`http://192.168.99.100:32286`：
- en: '![](assets/18dfc655-d7c2-4803-a1cf-717c4add609b.png)You should be able to visit
    your application with your web browser'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/18dfc655-d7c2-4803-a1cf-717c4add609b.png)您应该能够使用浏览器访问您的应用程序'
- en: What just happened?
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: So far, we have managed to build, run, and expose a single container on our
    Minikube instance. If you are used to using Docker to perform similar tasks, you
    might notice that although the steps we took were quite simple, there is a little
    more complexity in getting a simple hello world application like this up and running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功在Minikube实例上构建、运行和暴露了一个单个容器。如果您习惯使用Docker执行类似的任务，您可能会注意到，虽然我们所采取的步骤非常简单，但要使一个简单的hello
    world应用程序运行起来还是有一些复杂性的。
- en: A lot of this has to do with the scope of the tool. Docker provides a simple
    and easy to use workflow for building and running single containers on a single
    machine, whereas Kubernetes is, of course, first and foremost a tool designed
    to manage many containers running across multiple nodes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很多这些都与工具的范围有关。Docker提供了一个简单易用的工作流，用于在单个机器上构建和运行单个容器，而Kubernetes首先是一个旨在管理多个节点上运行的多个容器的工具。
- en: In order to understand some of the complexity that Kubernetes introduces, even
    in this simple example, we are going to explore the ways that Kubernetes is working
    behind the scenes to keep our application running reliably.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Kubernetes即使在这个简单的例子中引入的一些复杂性，我们将探索Kubernetes在幕后工作以确保我们的应用程序可靠运行的方式。
- en: 'When we executed `kubectl run`, Kubernetes created a new sort of resource:
    a deployment. A deployment is a higher level abstraction that manages the underlying
    `ReplicaSet` on our behalf. The advantage of this is that if we want to make changes
    to our application, Kubernetes can manage rolling out a new configuration to our
    running application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`kubectl run`时，Kubernetes创建了一种新的资源：部署。部署是一个更高级的抽象，代表我们管理的底层`ReplicaSet`。这样做的好处是，如果我们想对应用程序进行更改，Kubernetes可以管理向正在运行的应用程序滚动发布新配置：
- en: '![](assets/3d2f8ccd-a232-469c-95bc-7d1a9e1def08.png)The architecture of our
    simple Hello application'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3d2f8ccd-a232-469c-95bc-7d1a9e1def08.png)我们简单的Hello应用程序的架构'
- en: When we executed kubectl expose, Kubernetes created a service with a label selector
    that matched the pods under management by the deployment that we referenced.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行kubectl expose时，Kubernetes创建了一个带有标签选择器的服务，该选择器与我们引用的部署管理的pod匹配。
- en: Rolling out changes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动发布更改
- en: One of the key functions of the deployment resource is to manage the roll-out
    of new versions of an application. Let's look at an example of how you would do
    this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 部署资源的一个关键功能是管理应用程序的新版本的发布。让我们看一个如何执行这个操作的例子。
- en: 'First, let''s update the Dockerfile for version 2 of our `Hello World` application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的`Hello World`应用程序的版本2的Dockerfile：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You may have noticed that the HTML we used for version 1 was a little incomplete,
    so we are using the `COPY` command in the `Dockerfile` to copy an `index.html`
    file into our container image.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们在版本1中使用的HTML有点不完整，因此我们在`Dockerfile`中使用`COPY`命令将`index.html`文件复制到我们的容器镜像中。
- en: 'Use your text editor to create an `index.html` file that will be visually distinguishable
    from version 1\. I took the opportunity to add a proper DOCTYPE, and, of course,
    to use CSS to re-implement the sadly now defunct blink tag! Since this isn''t
    a book about web design, feel free to make whatever changes you want:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本编辑器创建一个`index.html`文件，它在视觉上与版本1有所区别。我抓住机会添加了一个合适的DOCTYPE，并且当然，使用CSS重新实现了可悲的已经废弃的闪烁标签！由于这不是一本关于网页设计的书，随意进行任何想要的更改：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, use Docker to build your version 2 image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用Docker构建您的第2版镜像：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can use kubectl to update the deployment resource to use the new image:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用kubectl来更新部署资源以使用新的镜像：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Wait a few moments for Kubernetes to launch the new pod, and then refresh your
    browser; you should see your changes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，直到Kubernetes启动新的pod，然后刷新您的浏览器；您应该能看到您的更改。
- en: 'When we update a deployment, behind the scenes Kubernetes creates a new replica
    set with the new configuration and handles rolling the new version out. Kubernetes
    also keeps track of the different configurations you have deployed. This also
    gives you the ability to roll a deployment back if required:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新一个部署时，Kubernetes在幕后创建一个新的副本集，具有新的配置，并处理新版本的滚动部署。Kubernetes还会跟踪您部署的不同配置。这也使您有能力在需要时回滚部署：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Resilience and scaling
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性和扩展性
- en: Being able to provide services that are resilient to errors and issues in the
    underlying infrastructure is one of the key reasons why we might want to use Kubernetes
    to deploy our containerized applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 能够提供对底层基础设施中的错误和问题具有弹性的服务是我们可能希望使用Kubernetes部署我们的容器化应用程序的关键原因之一。
- en: We are going to experiment with our `Hello World` deployment to discover how
    Kubernetes can deal with problems like these.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过我们的`Hello World`部署来进行实验，以发现Kubernetes如何处理这些问题。
- en: The first experiment is to see what happens when we deliberately remove the
    pod where our `hello` container is running.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实验是看当我们故意删除包含我们的`hello`容器的pod时会发生什么。
- en: 'To do this, we need to find the name of this pod, which we can do with the
    `kubectl get` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要找到这个pod的名称，我们可以使用`kubectl get`命令来做到这一点：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: On our Minikube cluster, we currently only have one pod running from the one
    deployment that we have created so far. Once you start to deploy more applications,
    the output from commands such as kubectl get can get lengthier. We can use the
    `-l` flag to pass a label selector to filter down the results. In this case, we
    would use `kubectl get pods -l run=hello` to show just the pods where the run
    label is set to `hello`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Minikube集群中，目前只有一个来自我们迄今为止创建的一个部署的运行中的pod。一旦开始部署更多的应用程序，诸如kubectl get之类的命令的输出就会变得更长。我们可以使用`-l`标志传递一个标签选择器来过滤结果。在这种情况下，我们将使用`kubectl
    get pods -l run=hello`来仅显示标签设置为`hello`的pod。
- en: 'Then we can use the `kubectl delete` command to remove the resource. Deleting
    a pod also terminates the processes running inside of the constituent containers,
    effectively cleaning up the Docker environment on our node:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`kubectl delete`命令来删除资源。删除一个pod也会终止其中的容器内运行的进程，有效地清理了我们节点上的Docker环境：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we then rerun the `get pods` command, you should notice that the pod we
    deleted has been replaced by a new one with a new name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果然后重新运行`get pods`命令，您应该注意到我们删除的pod已被一个新的带有新名称的pod所取代：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Kubernetes, we can use replica sets (and deployments) to ensure that pod
    instances continue to run in our cluster despite unexpected events, be they a
    failed server, or a fat-fingered admin deleting our pod (as has happened in this
    case).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，我们可以使用副本集（和部署）来确保尽管出现意外事件，例如服务器故障或管理员误删pod（就像在这种情况下发生的那样），但pod实例仍然在我们的集群中运行。
- en: You should begin to understand as part of this exercise that a pod is an ephemeral
    entity. When it is deleted or the node it is running on fails, it is gone forever.
    Kubernetes ensures that the missing pod is replaced by another, created in its
    image from the same template. This means that any state that is stored on the
    local filesystem or in memory, the identity of the pod itself is also lost when
    a pod inevitably fails and is replaced.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该开始理解作为这个练习的一部分，pod是一个短暂的实体。当它被删除或者它所在的节点失败时，它将永远消失。Kubernetes确保缺失的pod被另一个替换，从相同的模板中创建。这意味着当pod不可避免地失败并被替换时，存储在本地文件系统或内存中的任何状态，pod本身的身份也会丢失。
- en: This makes pods well-suited to some kinds of workload where it is not necessary
    for a state to be stored locally across runs, such as web applications and most
    batch jobs. If you are building new applications that you intend to deploy to
    Kubernetes, you will make them easier to manage by delegating the storage of state
    to an external store, such as a database or a service like Amazon S3.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得pod非常适合一些工作负载，不需要在运行之间在本地存储状态，比如Web应用程序和大多数批处理作业。如果你正在构建打算部署到Kubernetes的新应用程序，通过将状态的存储委托给外部存储，比如数据库或像Amazon
    S3这样的服务，可以使它们更易于管理。
- en: We will explore features in Kubernetes that allow us to deploy applications
    that need to store local state and/or maintain a stable identity in *Chapter 9*,
    *Storing State*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Kubernetes中探索允许我们部署需要存储本地状态和/或保持稳定身份的应用程序的功能，在*第9章*，*存储状态*中。
- en: One problem you may have noticed when we were testing the abilities of Kubernetes
    to replace a pod that was removed is that, for a short time, our service became
    unavailable. For a simple example service running on a single node cluster such
    as this, perhaps this is not the end of the world. But we do really need a way
    for our applications to run in a way that minimizes even momentary downtime.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试Kubernetes替换被移除的pod的能力时，你可能已经注意到一个问题，那就是在短时间内，我们的服务变得不可用。对于这样一个简单的单节点集群上运行的示例服务，也许这并不是世界末日。但我们确实需要一种方式，让我们的应用程序以最小化甚至瞬间的停机时间运行。
- en: 'The answer is, of course, to ask Kubernetes to run multiple pin stances for
    our application, so even if one is lost, a second can take the slack:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然是要求Kubernetes运行多个实例来运行我们的应用程序，因此即使一个丢失了，第二个也可以接管工作：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we now check the pods running, we can see a second `hello` pod has joined
    the party:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查正在运行的pod，我们可以看到第二个`hello` pod已经加入了：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the dashboard
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用仪表板
- en: The Kubernetes dashboard is a web application that runs within your Kubernetes
    cluster and offers an alternative, more graphical solution, for exploring and
    monitoring your cluster.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板是一个在Kubernetes集群内运行的Web应用程序，提供了一个替代的、更具图形化的解决方案，用于探索和监视你的集群。
- en: 'Minikube automatically installs the dashboard and provides a command that will
    open it in your web browser:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube会自动安装仪表板，并提供一个命令，可以在你的Web浏览器中打开它：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](assets/97e3c655-3fae-45db-a3ab-1ce32c32e713.png)The Kubernetes dashboard'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/97e3c655-3fae-45db-a3ab-1ce32c32e713.png)Kubernetes仪表板'
- en: The dashboard interface is very easy to use, and you should begin to notice
    more than a few similarities with the way that `kubectl` works, since they both
    allow you to interact with the same underlying API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板界面非常易于使用，你应该开始注意到与`kubectl`工作方式有更多相似之处，因为它们都允许你与相同的底层API进行交互。
- en: 'The Navigation bar on the left of the screen gives access to screens showing
    a list of resources of a particular kind. This is similar to the functionality
    provided by `the` `kubectl get` command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕左侧的导航栏可访问显示特定类型资源列表的屏幕。这类似于`kubectl get`命令提供的功能：
- en: '![](assets/5817fc35-e344-49e5-96d8-44d5a6a6e8a4.png)Using the Kubernetes dashboard
    to list currently running pods'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'In this view, we can click on the icon that looks like a stack of papers in
    order to open a log viewer to view the logs captured from standard out in each
    container in the pod:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5422944e-406e-47ce-a0db-88ded575e70b.png)Viewing container logs
    in the Kubernetes dashboard'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Other resources have other options appropriate to their function. For example,
    Deployments and Replica Sets have a dialog to scale the number of pods up or down.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the name of a particular resource, we get a view that shows
    similar information to `kubectl describe`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc0795df-1269-417a-81b1-5fa11a837d58.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'The detail screen provides us quite a lot of information about pods or other
    resources in Kubernetes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5830e05-da58-41a8-a5bf-7835b8866d94.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: As well as an overview of the configuration and settings for the resources,
    if you scroll to the bottom of the page, you should be able to see a feed of events.
    This is very useful if you are trying to debug issues and will highlight any errors
    or problems with a running resource.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'For pods, we get a number of other options for managing and inspecting the
    container. For example, opening an in-browser terminal by clicking the exec button:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a65495f4-3642-45ed-b80d-ef456c7014b3.png)Debugging a container using
    an interactive shell in the Kubernetes dashboard'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Currently**,** for this feature to work properly**,** your container needs to
    have `/bin/bash` available. This might change in future versions of the dashboard,
    but for now, to make this work add `RUN apk add --no-cache bash` to your `Dockerfile`
    and deploy the newly built image.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Configuration as code
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have interacted with Kubernetes by using commands
    provided by `kubectl` or the Kubernetes dashboard. In practice, I find that these
    tools are useful for quickly getting a container running in a cluster. When the
    configuration becomes more complex or I want to be able to deploy the same application
    to multiple environments, having a configuration file that I can submit to the
    cluster, and store in a version control system, is very useful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` and indeed the Kubernetes dashboard, will allow us to submit YAML
    or JSON formatted configurations for the resources we want to create on the cluster.
    We are going to take another look at how we would deploy the same `Hello World`
    application using YAML-formatted files rather than commands such as `kubectl run`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`，实际上包括Kubernetes仪表板，将允许我们提交YAML或JSON格式的配置以创建集群上的资源。我们将再次看看如何使用YAML格式的文件而不是`kubectl
    run`等命令来部署相同的“Hello World”应用程序。'
- en: This Kubernetes configuration is often referred to as a Manifest, and the YAML-or-JSON
    formatted files as Manifest files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Kubernetes配置通常被称为清单，而YAML或JSON格式的文件被称为清单文件。
- en: 'Let''s start by removing the configuration we created with `kubectl` so we
    have a clean state to reproduce the same configuration:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先删除我们用`kubectl`创建的配置，这样我们就有一个干净的状态来复制相同的配置：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s define a deployment for version 1 of the `hello` service:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`hello`服务的版本1定义一个部署：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can use `kubectl` to submit the deployment to Kubernetes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`kubectl`将部署提交到Kubernetes：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let''s do the same for a service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为一个服务做同样的事情：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Submit the definition to Kubernetes with `kubectl`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`提交定义到Kubernetes：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see that while we have sacrificed the speed and simplicity of just running
    a command to create a deployment, by explicitly specifying the resources we want
    to create, we gain greater control over exactly how our pods are configured, and
    we now have this definition in a form that we can check into version control and
    reliably update.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，虽然我们牺牲了只需运行一个命令来创建部署的速度和简单性，但通过明确指定我们想要创建的资源，我们可以更好地控制我们的pod的配置，并且现在我们可以将这个定义提交到版本控制，并可靠地更新。
- en: 'When it comes to updating a resource, we can make an edit to the file and then
    use the `kubectl apply` command to update the resource. `kubectl` detects that
    we are updating an existing resource and updates it to match our configuration.
    Try editing the image tag in `deployment.yaml` and then re submitting it to the
    cluster:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新资源时，我们可以对文件进行编辑，然后使用`kubectl apply`命令来更新资源。`kubectl`会检测到我们正在更新现有资源，并将其更新以匹配我们的配置。尝试编辑`deployment.yaml`中的图像标记，然后重新提交到集群：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we are just making changes to the resource on our local cluster, we might
    just want to quickly change something without having to edit the file at all.
    Firstly, as in our previous example, you can use `kubectl set` to update a property.
    Kubernetes doesn't really care how we created the resource, so everything we did
    previously is still valid. The other method of making a quick change is with the
    `kubectl edit` command. Assuming you have the `$EDITOR` environment variable set
    up correctly with your favorite text editor, you should be able to open YAML for
    a resource, edit it, and then save while `kubectl` seamlessly updates the resource
    for you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在本地集群上对资源进行更改，我们可能只是想快速更改一些东西，而无需编辑文件。首先，就像在我们之前的例子中一样，您可以使用`kubectl set`来更新属性。Kubernetes实际上并不关心我们如何创建资源，因此我们之前所做的一切仍然有效。进行快速更改的另一种方法是使用`kubectl
    edit`命令。假设您已经正确设置了`$EDITOR`环境变量与您喜欢的文本编辑器，您应该能够打开资源的YAML，进行编辑，然后保存，而`kubectl`会无缝地为您更新资源。
- en: Troubleshooting Minikube
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除Minikube
- en: One common problem that you might run into when trying to use Minikube is that
    you might not be able to access the VM because its network overlaps with another
    network configured on your machine. This can often happen if you are using a corporate
    VPN, or you connect to another network that configures routes for the `192.168.99.1/24`
    IP address range used by Minikube by default.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用Minikube时可能遇到的一个常见问题是，您可能无法访问VM，因为其网络与您的计算机上配置的另一个网络重叠。如果您正在使用企业VPN，或者连接到配置了默认情况下Minikube使用的`192.168.99.1/24`
    IP地址范围的另一个网络，这种情况经常会发生。
- en: 'It is simple to start Minikube with an alternative CIDR to be used for the
    VM. You can choose any private range that you want to use; just check that it
    won''t overlap with other services on your local network:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代CIDR启动Minikube非常简单，您可以选择任何您想要使用的私有范围；只需确保它不会与本地网络上的其他服务重叠：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Well done for making it this far. If you have followed along with the examples
    in this chapter, you should be well on your way to learning how to use Kubernetes
    to manage your own applications. You should be able to do the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好，能走到这一步真不容易。如果您在本章的示例中跟着做，那么您应该已经在学习如何使用Kubernetes来管理自己的应用程序的路上了。您应该能够做到以下几点：
- en: Use Minikube to set up a single node Kubernetes cluster on your workstation
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Minikube在您的工作站上设置单节点Kubernetes集群
- en: Build a simple application container using Docker
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker构建一个简单的应用程序容器
- en: Run a pod on your Minikube cluster
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Minikube集群上运行一个pod
- en: Declare a Kubernetes configuration using a Manifest file, so you can reproduce
    your setup
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用清单文件声明Kubernetes配置，以便您可以重现您的设置
- en: Set up a service so you can access your application
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个服务，以便您可以访问您的应用程序

- en: Building Your Own Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Kubernetes architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Kubernetes cluster on macOS by minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Kubernetes cluster on Windows by minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Kubernetes cluster on Linux by kubeadm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Kubernetes cluster on Linux by Ansible (kubespray)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first container in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to your journey into Kubernetes! In this very first section, you will
    learn how to build your own Kubernetes cluster. Along with understanding each
    component and connecting them together, you will learn how to run your first container
    on Kubernetes. Having a Kubernetes cluster will help you continue your studies
    in the chapters ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Kubernetes architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is an open source container management tool. It is a Go language-based
    ([https://golang.org](https://golang.org)), lightweight and portable application.
    You can set up a Kubernetes cluster on a Linux-based OS to deploy, manage, and
    scale Docker container applications on multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is made up of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These components are connected via a network, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e964924c-0254-4850-ae57-8d05133ea0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes master**: It connects to etcd via HTTP or HTTPS to store the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes nodes**: It connect to the Kubernetes master via HTTP or HTTPS
    to get a command and report the status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes network**: It L2, L3 or overlay make a connection of their container
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explain how to use the Kubernetes master and
    nodes to realize the main functions of the Kubernetes system.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kubernetes master is the main component of the Kubernetes cluster. It serves
    several functionalities, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful API entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container deployment scheduler to Kubernetes nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling and replicating controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the configuration to set up a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how master daemons work together to fulfill the
    aforementioned functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d05d8b65-158f-4a4b-8a4c-b9cf00ef1133.png)'
  prefs: []
  type: TYPE_IMG
- en: There are several daemon processes that form the Kubernetes master's functionality,
    such as `kube-apiserver`, `kube-scheduler` and `kube-controller-manager`. Hypercube,
    the wrapper binary, can launch all these daemons.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Kubernetes command-line interface, kubect can control the Kubernetes
    master functionality.
  prefs: []
  type: TYPE_NORMAL
- en: API server (kube-apiserver)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API server provides an HTTP- or HTTPS-based RESTful API, which is the hub
    between Kubernetes components, such as kubectl, the scheduler, the replication
    controller, the etcd data store, the kubelet and kube-proxy, which runs on Kubernetes
    nodes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler (kube-scheduler)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scheduler helps to choose which container runs on which nodes. It is a
    simple algorithm that defines the priority for dispatching and binding containers
    to nodes. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many containers are running?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller manager (kube-controller-manager)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The controller manager performs cluster operations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Manages Kubernetes nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates and updates the Kubernetes internal information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempts to change the current status to the desired status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line interface (kubectl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you install the Kubernetes master, you can use the Kubernetes command-line
    interface, `kubectl`, to control the Kubernetes cluster. For example, `kubectl
    get cs` returns the status of each component. Also, `kubectl get nodes` returns
    a list of Kubernetes nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes node is a slave node in the Kubernetes cluster. It is controlled
    by the Kubernetes master to run container applications using Docker ([http://docker.com](http://docker.com))
    or rkt ([http://coreos.com/rkt/docs/latest/)](http://coreos.com/rkt/docs/latest/).
    In this book, we will use the Docker container runtime as the default engine.
  prefs: []
  type: TYPE_NORMAL
- en: Node or slave?
  prefs: []
  type: TYPE_NORMAL
- en: The term slave is used in the computer industry to represent the cluster worker
    node; however, it is also associated with discrimination. The Kubernetes project
    uses minion in the early version and node in the current version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram displays the role and tasks of daemon processes in the
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd21b8ae-fe86-4015-8b84-3a5e8aa502a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The node also has two daemon processes, named kubelet and kube-proxy, to support
    its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kubelet is the main process on the Kubernetes node that communicates with the
    Kubernetes master to handle the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Periodically accesses the API controller to check and report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs container operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs the HTTP server to provide simple APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy (kube-proxy)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy handles the network proxy and load balancer for each container. It
    changes Linux iptables rules (nat table) to control TCP and UDP packets across
    the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the kube-proxy daemon, it configures iptables rules; you can
    use `iptables -t nat -L` or `iptables -t nat -S` to check the nat table rules,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two more components to complement Kubernetes node functionalities,
    the data store etcd and the inter-container network. You can learn how they support
    the Kubernetes system in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/)) is the distributed
    key-value data store. It can be accessed via the RESTful API to perform CRUD operations
    over the network. Kubernetes uses etcd as the main data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore the Kubernetes configuration and status in etcd (`/registry`)
    using the `curl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network communication between containers is the most difficult part. Because
    Kubernetes manages multiple nodes (hosts) running several containers, those containers
    on different nodes may need to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: If the container's network communication is only within a single node, you can
    use Docker network or Docker compose to discover the peer. However, along with
    multiple nodes, Kubernetes uses an overlay network or **container network interface**
    (**CNI**) to achieve multiple container communication.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes the basic architecture and methodology of Kubernetes and
    the related components. Understanding Kubernetes is not easy, but a step-by-step
    learning process on how to set up, configure, and manage Kubernetes is really
    fun.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Kubernetes cluster on macOS by minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes consists of combination of multiple open source components. These
    are developed by different parties, making it difficult to find and download all
    the related packages and install, configure, and make them work from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are some different solutions and tools that have been developed
    to set up Kubernetes clusters effortlessly. Therefore, it is highly recommended
    you use such a tool to set up Kubernetes on your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools are categorized by different types of solution to build
    your own Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Self-managed solutions that include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubeadm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubespray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enterprise solutions that include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenShift ([https://www.openshift.com](https://www.openshift.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tectonic ([https://coreos.com/tectonic/](https://coreos.com/tectonic/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud-hosted solutions that include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Kubernetes engine ([https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon elastic container service for Kubernetes (Amazon EKS, [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Container Service (AKS, [https://azure.microsoft.com/en-us/services/container-service/](https://azure.microsoft.com/en-us/services/container-service/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A self-managed solution is suitable if we just want to build a development environment
    or do a proof of concept quickly.
  prefs: []
  type: TYPE_NORMAL
- en: By using minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    and kubeadm ([https://kubernetes.io/docs/admin/kubeadm/](https://kubernetes.io/docs/admin/kubeadm/)),
    we can easily build the desired environment on our machine locally; however, it
    is not practical if we want to build a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: By using kubespray ([https://github.com/kubernetes-incubator/kubespray](https://github.com/kubernetes-incubator/kubespray))
    and kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)),
    we can also build a production-grade environment quickly from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'An enterprise solution or cloud-hosted solution is the easiest starting point
    if we want to create a production environment. In particular, the **Google Kubernetes
    Engine** (**GKE**), which has been used by Google for many years, comes with comprehensive
    management, meaning that users don''t need to care much about the installation
    and settings. Also, Amazon EKS is a new service that was introduced at AWS re:
    Invent 2017, which is managed by the Kubernetes service on AWS.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can also run on different clouds and on-premise VMs by custom solutions.
    To get started, we will build Kubernetes using minikube on macOS desktop machines
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: minikube runs Kubernetes on the Linux VM on macOS. It relies on a hypervisor
    (virtualization technology), such as VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org)),
    VMWare fusion ([https://www.vmware.com/products/fusion.html](https://www.vmware.com/products/fusion.html)),
    or hyperkit ([https://github.com/moby/hyperkit](https://github.com/moby/hyperkit))
    In addition, we will need to have the Kubernetes **command-line interface** (**CLI**)
    `kubectl`, which is used to connect through the hypervisor, to control Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: With minikube, you can run the entire suite of the Kubernetes stack on your
    macOS, including the Kubernetes master, node, and CLI. It is recommended that
    macOS has enough memory to run Kubernetes. By default, minikube uses VirtualBox
    as the hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, however, we will demonstrate how to use hyperkit, which is
    the most lightweight solution. As Linux VM consumes 2 GB of memory, at least 4
    GB of memory is recommended. Note that hyperkit is built on the top of the hypervisor
    framework ([https://developer.apple.com/documentation/hypervisor](https://developer.apple.com/documentation/hypervisor))
    on macOS; therefore, macOS 10.10 Yosemite or later is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the relationship between kubectl, the hypervisor,
    minikube, and macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52edf167-0558-4969-b440-eddb763d898e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: macOS doesn't have an official package management tool, such as yum and apt-get
    on Linux. But there are some useful tools available for macOS. `Homebrew` ([https://brew.sh](https://brew.sh))
    is the most popular package management tool and manages many open source tools,
    including minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install `Homebrew` on macOS, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal and then type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once installation is completed, you can type `/usr/local/bin/brew help` to see
    the available command options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you just install or upgrade Xcode on your macOS, the `Homebrew` installation
    may stop. In that case, open Xcode to accept the license agreement or type `sudo
    xcodebuild -license` beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the `hyperkit driver` for minikube. At the time of writing (February
    2018), HomeBrew does not support hyperkit; therefore type the following command
    to install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s install the Kubernetes CLI. Use Homebrew with the following comment
    to install the `kubectl` command on your macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can install minikube. It is not managed by Homebrew; however, Homebrew
    has an extension called `homebrew-cask` ([https://github.com/caskroom/homebrew-cask](https://github.com/caskroom/homebrew-cask))
    that supports minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install minikube by `homebrew-cask`, just simply type the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you have never installed **Docker for Mac** on your machine, you need to
    install it via `homebrew-cask` as well
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you are all set! The following command shows whether the required packages
    have been installed on your macOS or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'minikube is suitable for setting up Kubernetes on your macOS with the following
    command, which downloads and starts a Kubernetes VM stet, and then configures
    the kubectl configuration (`~/.kube/config`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting all the necessary packages, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a few minutes for the Kubernetes cluster setup to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `kubectl version` to check the Kubernetes master version and `kubectl get
    cs` to see the component status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, use the `kubectl get nodes` command to check whether the Kubernetes node
    is ready or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you can start to use Kubernetes on your machine. The following sections
    describe how to use the `kubectl` command to manipulate Docker containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that, in some cases, you may need to maintain the Kubernetes cluster,
    such as starting/stopping the VM or completely deleting it. The following commands 
    maintain the minikube environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Command** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube start --vm-driver=hyperkit` | Starts the Kubernetes VM using the
    hyperkit driver |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube stop` | Stops the Kubernetes VM |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube delete` | Deletes a Kubernetes VM image |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube ssh` | ssh to the Kubernetes VM guest |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube ip` | Shows the Kubernetes VM (node) IP address |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube update-context` | Checks and updates `~/.kube/config` if the VM
    IP address is changed |'
  prefs: []
  type: TYPE_TB
- en: '| `minikube dashboard` | Opens the web browser to connect the Kubernetes UI
    |'
  prefs: []
  type: TYPE_TB
- en: 'For example, minikube starts a dashboard (the Kubernetes UI) by the default.
    If you want to access the dashboard, type `minikube dashboard`; it then opens
    your default browser and connects the Kubernetes UI, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8d9207f5-35c3-4b5a-82cc-0025425f1ff1.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to set up a Kubernetes cluster on your macOS using
    minikube. It is the easiest way to start using Kubernetes. We also learned how
    to use kubectl, the Kubernetes command-line interface tool, which is the entry
    point to control our Kubernetes cluster!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Kubernetes cluster on Windows by minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By nature, Docker and Kubernetes are based on a Linux-based OS. Although it
    is not ideal to use the Windows OS to explore Kubernetes, many people are using
    the Windows OS as their desktop or laptop machine. Luckily, there are a lot of
    ways to run the Linux OS on Windows using virtualization technologies, which makes
    running a Kubernetes cluster on Windows machines possible. Then, we can build
    a development environment or do a proof of concept on our local Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the Linux VM by using any hypervisor on Windows to set up Kubernetes
    from scratch, but using minikube ([https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube))
    is the fastest way to build a Kubernetes cluster on Windows. Note that this recipe
    is not ideal for a production environment because it will set up a Kubernetes
    on Linux VM on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up minikube on Windows requires a hypervisor, either VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))
    or Hyper-V, because, again, minikube uses the Linux VM on Windows. This means
    that you cannot use the Windows virtual machine (for example, running the Windows
    VM on macOS by parallels).
  prefs: []
  type: TYPE_NORMAL
- en: However, `kubectl` , the Kubernetes CLI, supports a Windows native binary that
    can connect to Kubernetes over a network. So, you can set up a portable suite
    of Kubernetes stacks on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the relationship between kubectl, Hypervisor, minikube,
    and Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a68272cf-8a6b-4ad9-8b69-bf2e0a3b06b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Hyper-V is required for Windows 8 Pro or later. While many users still use Windows
    7, we will use VirtualBox as the minikube hypervisor in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, VirtualBox for Windows is required:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the VirtualBox website ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    to download the Windows installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Installation is straightforward, so we can just choose the default options
    and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/974c0731-431f-4311-92d5-e90fb7125196.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create the `Kubernetes` folder, which is used to store the minikube and
    kubectl binaries. Let''s create the `k8s` folder on top of the `C:` drive, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0e05fcfa-9a7e-4433-8092-da2715ed76df.png)'
  prefs: []
  type: TYPE_IMG
- en: This folder must be in the command search path, so open System Properties, then
    move to the Advanced tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Environment Variables... button, then choose Path , and then click
    the Edit... button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5aca299b-611c-48ae-973d-e8a219ab1b47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, append `c:\k8s` , as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/06503e44-8ead-4b89-b980-9317068883c4.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking the OK button, log off and logo on to Windows again (or reboot)
    to apply this change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, download minikube for Windows. It is a single binary, so use any web browser
    to download [https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64](https://github.com/kubernetes/minikube/releases/download/v0.26.1/minikube-windows-amd64)
    and then copy it to the `c:\k8s` folder, but change the filename to `minikube.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, download kubectl for Windows, which can communicate with Kubernetes. It
    is also single binary like minikube. So, download [https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe](https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/windows/amd64/kubectl.exe)
    and then copy it to the `c:\k8s` folder as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Eventually, you will see two binaries in the `c:\k8s` folder, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d769ed44-88be-4a27-93d7-bdb86f28fdbf.png)If you are running anti-virus
    software, it may prevent you from running `kubectl.exe` and `minikube.exe`. If
    so, please update your anti-virus software setting that allows running these two
    binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Command Prompt and then type `minikube start` , as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cf21415a-f5c0-4528-95d0-74ae67d5f90f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'minikube downloads the Linux VM image and then sets up Kubernetes on the Linux
    VM; now if you open VirtualBox, you can see that the minikube guest has been registered,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/49a5d949-29c4-4762-8ee0-f89969082c19.png)'
  prefs: []
  type: TYPE_IMG
- en: Wait for a few minutes to complete the setup of the Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per the following screenshot, type `kubectl version` to check the Kubernetes
    master version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `kubectl get nodes` command to check whether the Kubernetes node is
    ready or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d323c09d-4c29-4862-8fdd-9ab4ab63be36.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can start to use Kubernetes on your machine! Again, Kubernetes is running
    on the Linux VM, as shown in the next screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `minikube ssh` allows you to access the Linux VM that runs Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9f745739-14ce-487c-9a3b-16ff37edefe0.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, any Linux-based Docker image is capable of running on your Windows
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `minikube ip` to verify which IP address the Linux VM uses and also `minikube
    dashboard`, to open your default web browser and navigate to the Kubernetes UI
    ,as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4cac90a8-990e-4b86-b195-f660c51d0cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t need to use Kubernetes anymore, type `minikube stop` or open
    VirtualBox to stop the Linux guest and release the resource, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/09fe9f63-c0cf-420f-ac7d-a09f00810126.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to set up a Kubernetes cluster on your Windows OS
    using minikube. It is the easiest way to start using Kubernetes. It also describes
    kubectl, the Kubernetes command-line interface tool, which is the entry point
    form which to control your Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Kubernetes cluster on Linux via kubeadm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to show how to create a Kubernetes cluster along
    with kubeadm ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))
    on Linux servers. Kubeadm is a command-line tool that simplifies the procedure
    of creating and managing a Kubernetes cluster. Kubeadm leverages the fast deployment
    feature of Docker, running the system services of the Kubernetes master and the
    etcd server as containers. When triggered by the `kubeadm` command, the container
    services will contact kubelet on the Kubernetes node directly; kubeadm also checks
    whether every component is healthy. Through the kubeadm setup steps, you can avoid
    having a bunch of installation and configuration commands when you build everything
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will provide instructions of two types of OS:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Xenial 16.04 (LTS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CentOS 7.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure the OS version is matched before continuing. Furthermore, the software
    dependency and network settings should be also verified before you proceed to
    thecd cd next step. Check the following items to prepare the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Every node has a unique MAC address and product UUID**: Some plugins use
    the MAC address or product UUID as a unique machine ID to identify nodes (for
    example, `kube-dns`). If they are duplicated in the cluster, kubeadm may not work
    while starting the plugin:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Every node has a different hostname**: If the hostname is duplicated, the
    Kubernetes system may collect logs or statuses from multiple nodes into the same
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker is installed**: As mentioned previously, the Kubernetes master will
    run its daemon as a container, and every node in the cluster should get Docker
    installed. For how to perform the Docker installation, you can follow the steps
    on the official website: (Ubuntu: [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/),
    and CentOS: [https://docs.docker.com/engine/installation/linux/docker-ce/centos/](https://docs.docker.com/engine/installation/linux/docker-ce/centos/))
    Here we have Docker CE 17.06 installed on our machines; however, only Docker versions
    1.11.2 to 1.13.1, and 17.03.x are verified with Kubernetes version 1.10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network ports are available**: The Kubernetes system services need network
    ports for communication. The ports in the following table should now be occupied
    according to the role of the node:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Node role** | **Ports** | **System service** |'
  prefs: []
  type: TYPE_TB
- en: '| Master | `6443` | Kubernetes API server |'
  prefs: []
  type: TYPE_TB
- en: '| `10248/10250/10255` | kubelet local healthz endpoint/Kubelet API/Heapster
    (read-only) |'
  prefs: []
  type: TYPE_TB
- en: '| `10251` | kube-scheduler |'
  prefs: []
  type: TYPE_TB
- en: '| `10252` | kube-controller-manager |'
  prefs: []
  type: TYPE_TB
- en: '| `10249/10256` | kube-proxy |'
  prefs: []
  type: TYPE_TB
- en: '| `2379/2380` | etcd client/etcd server communication |'
  prefs: []
  type: TYPE_TB
- en: '| Node | `10250/10255` | Kubelet API/Heapster (read-only) |'
  prefs: []
  type: TYPE_TB
- en: '| `30000~32767` | Port range reserved for exposing container service to outside
    world |'
  prefs: []
  type: TYPE_TB
- en: 'The Linux command, `netstat`, can help to check if the port is in use or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Network tool packages are installed. `ethtool` and `ebtables` are two required
    utilities for kubeadm. They can be download and installed by the`apt-get` or `yum`package
    managing tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation procedures for two Linux OSes, Ubuntu and CentOS, are going
    to be introduced separately in this recipe as they have different setups.
  prefs: []
  type: TYPE_NORMAL
- en: Package installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get the Kubernetes packages first! The repository for downloading needs
    to be set in the source list of the package management system. Then, we are able
    to get them installed easily through the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Kubernetes packages in Ubuntu perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some repositories are URL with HTTPS. The `apt-transport-https` package must
    be installed to access the HTTPS endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the public key for accessing packages on Google Cloud, and add it
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a new source list for the Kubernetes packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is good to install the Kubernetes packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Kubernetes packages in CentOS perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Ubuntu, new repository information needs to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to pull the packages from the Kubernetes source base via
    the `yum` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: No matter what OS it is, check the version of the package you get!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: System configuration prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before running up the whole system by kubeadm, please check that Docker is running
    on your machine for Kubernetes. Moreover, in order to avoid critical errors while
    executing kubeadm, we will show the necessary service configuration on both the
    system and kubelet. As well as the master, please set the following configurations
    on the Kubernetes nodes to get kubelet to work fine with kubeadm.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS system settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other additional settings in CentOS to make Kubernetes behave correctly.
    Be aware that, even if we are not using kubeadm to manage the Kubernetes cluster,
    the following setup should be considered while running kubelet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable SELinux, since kubelet does not support SELinux completely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can `disable SELinux` through the following command, or by `modifying the
    configuration file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll need to `reboot` the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the usage of iptables. To prevent some routing errors happening, add
    runtime parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Booting up the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can start the service. First enable and then start kubelet on your Kubernetes
    master machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While checking the status of kubelet, you may be worried to see the status
    displaying activating (`auto-restart`); and you may get further frustrated to
    see the detail logs by the `journalctl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error: unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt:
    no such file or directory`'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry. kubeadm takes care of creating the certificate authorities file.
    It is defined in the service configuration file, `/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
    by argument KUBELET_AUTHZ_ARGS`. The kubelet service won't be a healthy without
    this file, so keep trying to restart the daemon by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and start all the master daemons via kubeadm. It is worth noting that
    using kubeadm requires the root permission to achieve a service level privilege.
    For any sudoer, each kubeadm would go after the `sudo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Find preflight checking error while firing command `kubeadm init`? Using following
    one to disable running swap as description.
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo kubeadm init --ignore-preflight-errors=Swap`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And you will see the sentence `Your Kubernetes master has initialized successfully!`
    showing on the screen. Congratulations! You are almost done! Just follow the information
    about the user environment setup below the greeting message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands ensure every Kubernetes instruction is fired by your
    account execute with the proper credentials and connects to the correct server
    portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'More than that, kubelet goes into a healthy state now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Network configurations for containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the master of the cluster is ready to handle jobs and the services are
    running, for the purpose of making containers accessible to each other through
    networking, we need to set up the network for container communication. It is even
    more important initially while building up a Kubernetes cluster with kubeadm,
    since the master daemons are all running as containers. kubeadm supports the CNI
    ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    We are going to attach the CNI via a Kubernetes network add-on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many third-party CNI solutions that supply secured and reliable container
    network environments. Calico ([https://www.projectcalico.org](https://www.projectcalico.org)),
    one CNI provide stable container networking. Calico is light and simple, but still
    well implemented by the CNI standard and integrated with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, whatever your host OS is, the command kubectl can fire any sub command
    for utilizing resources and managing systems. We use `kubectl` to apply the configuration
    of Calico to our new-born Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced management of networking and Kubernetes add-ons will be discussed
    in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), *Building Kubernetes
    on GCP*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a node involved
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s log in to your Kubernetes node to join the group controlled by kubeadm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, enable and start the service, `kubelet`. Every Kubernetes machine should
    have `kubelet` running on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, fire the `kubeadm` join command with an input flag token and the
    IP address of the master, notifying the master that it is a secured and authorized
    node. You can get the token on the master node via the `kubeadm` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, if `kubeadm init` succeeds, the default token will
    be generated. Copy the token and paste it onto the node, and then compose the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you call `kubeadm token list` to list the tokens, and see they are
    all expired? You can create a new one manually by this command: `kubeadm token
    create` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please make sure that the master''s firewall doesn''t block any traffic to
    port `6443`, which is for API server communication. Once you see the words `Successfully
    established connection` showing on the screen, it is time to check with the master
    if the group got the new member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Well done! No matter if whether your OS is Ubuntu or CentOS, kubeadm is installed
    and kubelet is running. You can easily go through the preceding steps to build
    your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering about the flag `discovery-token-unsafe-skip-ca-verification`
    used while joining the cluster. Remember the kubelet log that says the certificate
    file is not found? That''s it, since our Kubernetes node is brand new and clean,
    and has never connected with the master before. There is no certificate file to
    find for verification. But now, because the node has shaken hands with the master,
    the file exists. We may join in this way (in some situation requiring rejoining
    the same cluster):'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm join --token $TOKEN $MASTER_IPADDR:6443 --discovery-token-ca-cert-hash
    sha256:$HASH`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash value can be obtained by the `openssl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When kubeadm init sets up the master, there are six stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating certificate files and keys for services**: Certificated files
    and keys are used for security management during cross-node communications. They
    are located in the `/etc/kubernetes/pki` directory. Take kubelet, for example.
    It cannot access the Kubernetes API server without passing the identity verification.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing kubeconfig files**: The `kubeconfig` files define permissions, authentication,
    and configurations for kubectl actions. In this case, the Kubernetes controller
    manager and scheduler have related `kubeconfig` files to fulfill any API requests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating service daemon YAML files**: The service daemons under kubeadm''s
    control are just like computing components running on the master. As with setting
    deployment configurations on disk, kubelet will make sure each daemon is active.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waiting for kubelet to be alive, running the daemons as pods**: When kubelet
    is alive, it will boot up the service pods described in the files under the `/etc/kubernetes/manifests`
    directory. Moreover, kubelet guarantees to keep them activated, restarting the
    pod automatically if it crashes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Setting post-configuration for the cluster**: Some cluster configurations
    still need to be set, such as configuring **role-based accessing control** (**RBAC**)
    rules, creating a namespace, and tagging the resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Applying add-ons**: DNS and proxy services can be added along with the kubeadm
    system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the user enters kubeadm and joins the Kubernetes node, kubeadm will complete
    the first two stages like the master.
  prefs: []
  type: TYPE_NORMAL
- en: If you have faced a heavy and complicated set up procedure in earlier versions
    of Kubernetes, it is quite a relief to set up a Kubernetes cluster with kubeadm.
    kubeadm reduces the overhead of configuring each daemon and starting them one
    by one. Users can still do customization on kubelet and master services, by just
    modifying a familiar file, `10-kubeadm.conf` and the YAML files under `/etc/kubernetes/manifests`.
    Kubeadm not only helps to establish the cluster but also enhances security and
    availability, saving you time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about how to build a Kubernetes cluster. If you''re ready to run
    your first application on it, check the last recipe in this chapter and run the
    container! And for advanced management of your cluster, you can also look at [Chapter
    8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced Cluster Administration*,
    of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Advanced settings in kubeconfig*, in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Kubernetes cluster on Linux via Ansible (kubespray)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with configuration management, such as Puppet, Chef and
    Ansible, kubespray ([https://github.com/kubernetes-incubator/kubespray](https://github.com/kubernetes-incubator/kubespray))
    is the best choice to set up a Kubernetes cluster from scratch. It provides the
    Ansible playbook that supports the majority of Linux distributions and public
    clouds, such as AWS and GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible ([https://www.ansible.com](https://www.ansible.com)) is a Python-based
    SSH automation tool that can configure Linux as your desired state based on the
    configuration, which is called playbook. This cookbook describes how to use kubespray
    to set up Kubernetes on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of May 2018, the latest version of kubespray is 2.5.0, which supports the
    following operation systems to install Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: RHEL/CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 16.04 LTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the kubespray documentation, it also supports CoreOS and debian
    distributions. However, those distributions may need some additional steps or
    have technical difficulties. This cookbook uses CentOS 7 and Ubuntu 16.04 LTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you need to install Ansible on your machine. Ansible works on
    Python 2.6, 2.7, and 3.5 or higher. macOS and Linux might be the best choice to
    install Ansible because Python is preinstalled by most of macOS and Linux distributions
    by default. In order to check which version of Python you have, open a Terminal
    and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, you need at least three machines, as mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of host** | **Recommended OS/Distribution** |'
  prefs: []
  type: TYPE_TB
- en: '| Ansible | macOS or any Linux which has Python 2.6, 2.7, or 3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes master | RHEL/CentOS 7 or Ubuntu 16.04 LTS |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes node | RHEL/CentOS 7 or Ubuntu 16.04 LTS |'
  prefs: []
  type: TYPE_TB
- en: 'There are some network communicating with each other, so you need to at least
    open a network port (for example, AWS Security Group or GCP Firewall rule) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP/22 (ssh)**: Ansible to Kubernetes master/node host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP/6443 (Kubernetes API server)**: Kubernetes node to master'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol 4 (IP encapsulated in IP)**: Kubernetes master and node to each
    other by Calico'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Protocol 4 (IP encapsulated in IP), if you are using AWS, set an ingress
    rule to specify `aws ec2 authorize-security-group-ingress --group-id <your SG
    ID> --cidr <network CIDR> --protocol 4`. In addition, if you are using GCP, set
    the firewall rule to specify as `cloud compute firewall-rules create allow-calico
    --allow 4 --network <your network name> --source-ranges <network CIDR>`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to install Ansible, is to use pip, the Python package manager.
    Some of newer versions of Python have `pip` already (Python 2.7.9 or later and
    Python 3.4 or later):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm whether `pip` is installed or not, similar to the Python command,
    use `-V`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you see the following result, you need to install `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install pip, download `get-pip.py` and install by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to install Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed `pip`, you can install Ansible with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`pip` scans your Python and installs the necessary libraries for Ansible, so
    it may take a few minutes to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have successfully installed Ansible by `pip`, you can verify it with
    the following command and see output as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Installing python-netaddr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, according to kubespray''s documentation ([https://github.com/kubernetes-incubator/kubespray#requirements](https://github.com/kubernetes-incubator/kubespray#requirements)),
    it needs the `python-netaddr` package. This package can also be installed by pip,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Setting up ssh public key authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more thing, as mentioned previously, Ansible is actually the ssh automation
    tool. If you log on to host via ssh, you have to have an appropriate credential
    (user/password or ssh public key) to the target machines. In this case, the target
    machines mean the Kubernetes master and nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Due to security reasons, especially in the public cloud, Kubernetes uses only
    the ssh public key authentication instead of ID/password authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow the best practice, let''s copy the ssh public key from your Ansible
    machine to the Kubernetes master/node machines:'
  prefs: []
  type: TYPE_NORMAL
- en: If you've already set up ssh public key authentication between the Ansible machine
    to Kubernetes candidate machines, you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create an ssh public/private key pair from your Ansible machine,
    type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It will ask you to set a passphrase. You may set or skip (empty) this, but you
    have to remember it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have successfully created a key pair, you can see the private key
    as `~/.ssh/id_rsa` and public key as `~/.ssh/id_rsa.pub`. You need to append the
    public key to the target machine under `~/.ssh/authorized_keys`, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/669c5f59-6af8-4865-a8f6-5d4b7dea7d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: You need to copy and paste your public key to all Kubernetes master and node
    candidate machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make sure your ssh public key authentication works, just ssh from the Ansible
    machine to the target host that won''t ask for your logon password, as here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now you are all set! Let's set up Kubernetes using kubespray (Ansible) from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kubespray is provided through the GitHub repository ([https://github.com/kubernetes-incubator/kubespray/tags](https://github.com/kubernetes-incubator/kubespray/tags)),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59438d0b-62fd-4241-896c-f27f0e78185c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because kubespray is an Ansible playbook, not a binary, you can download the
    latest version (as of May 2018, version 2.5.0 is the latest) of the `zip` or `tar.gz`
    to your Ansible machine directly and unarchive it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Maintaining the Ansible inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to perform the Ansible playbook, you need to maintain your own inventory
    file, which contains target machine IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a sample inventory file under the inventory directory, so you can
    copy it by using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this cookbook, we are using target machines that have the following IP addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes master : `10.128.0.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes node : `10.128.0.4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, `hosts.ini` should be in the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ea729763-477f-49f1-b64e-4ef047102ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: Please change the IP address to match your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that hostname (`my-master-1` and `my-node-1`) will be set by the kubespray
    playbook based on this `hosts.ini`, so feel free to assign a meaningful hostname.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Ansible ad hoc command to test your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before running the kubespray playbook, let''s check whether `hosts.ini` and
    Ansible itself work properly or not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, use the Ansible ad hoc command, using the ping module, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f64fdf05-c6ff-4b77-9fc9-23af593c08aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This result indicates `SUCCESS`. But if you see the following error, probably
    the IP address is wrong or the target machine is down, so please the check target
    machine first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/13ae1baa-a1ae-4655-8ea9-426410983ed7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, check your authority whether you can escalate a privilege on the target
    machine or not. In other words, whether you can run `sudo` or not. This is because
    you will need to install Kubernetes, Docker, and some related binaries, and configurations
    that need a root privilege. To confirm that, add the `-b` (become) option, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0c2f06a0-2e53-40e7-be10-cb2c28eb05ae.png)'
  prefs: []
  type: TYPE_IMG
- en: With the `-b` option, it actually tries to perform sudo on the target machine.
    If you see `SUCCESS`, you are all set! Go to the *How it works…* section to run
    kubespray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're unfortunate enough to see some errors, please refer to the following
    section to solve Ansible issues.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ideal situation would be to use the same Linux distribution, version, settings,
    and logon user. However, the environment will be different based on policy, compatibility,
    and other reasons. Ansible is flexible and can support many use cases to run `ssh`
    and `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: Need to specify a sudo password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on your Linux machine setting, you may see the following error when adding
    the `-b` option. In this case, you need to type your password while running the
    `sudo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8cb344cb-f98a-4b6d-9526-bac1590dadbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, add `-K` (ask for the `sudo` password) and run again. It will
    ask for your sudo password when running the Ansible command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2efbf16-c053-420d-9fe7-8ee7933675fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If your Linux uses the `su` command instead of `sudo`, adding `--become-method=su`
    to run the Ansible command could help. Please read the Ansible documentation for
    more details : [http://docs.ansible.com/ansible/latest/become.html](http://docs.ansible.com/ansible/latest/become.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Need to specify different ssh logon user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may need to ssh to target machines using a different logon user.
    In this case, you can append the `ansible_user` parameter to an individual host
    in `hosts.ini`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the username `kirito` to `ssh` to `my-master-1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the username `asuna` to `ssh` to `my-node-1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, change `hosts.ini`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Need to change ssh port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another scenario is where you may need to run the ssh daemon on some specific
    port number rather than the default port number `22`. Ansible also supports this
    scenario and uses the `ansible_port` parameter to the individual host in `hosts.ini`,
    as shown in the following code (in the example, the `ssh` daemon is running at
    `10022` on `my-node-1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Common ansible issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is flexible enough to support any other situations. If you need any
    specific parameters to customize the ssh logon for the target host, read the Ansible
    inventory documentation to find a specific parameter: [http://docs.ansible.com/ansible/latest/intro_inventory.html](http://docs.ansible.com/ansible/latest/intro_inventory.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Ansible has a configuration file, `ansible.cfg`, on top of the
    `kubespray` directory. It defines common settings for Ansible. For example, if
    you are using a very long username that usually causes an Ansible error, change
    `ansible.cfg` to set `control_path` to solve the issue, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you plan to set up more than `10` nodes, you may need to increase ssh simultaneous
    sessions. In this case, adding the `forks` parameter also requires you to increase
    the ssh timeout from `10` seconds to `30` seconds by adding the timeout parameter,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot contains all of the preceding configurations in `ansible.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f7643fd9-85af-40ff-804c-f62fadabb2f3.png)'
  prefs: []
  type: TYPE_IMG
- en: For more details, please visit the Ansible configuration documentation at [http://docs.ansible.com/ansible/latest/intro_configuration.html](http://docs.ansible.com/ansible/latest/intro_configuration.html)
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you can start to run the kubepray playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: You've already created an inventory file as `inventory/mycluster/hosts.ini`.
    Other than `hosts.ini`, you need to check and update global variable configuration
    files at `inventory/mycluster/group_vars/all.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a lot of variables defined, but at least one variable, `bootstrap_os`
    , needs to be changed from `none` to your target Linux machine. If you are using
    RHEL/CentOS7, set `bootstrap_os` as `centos`. If you are using Ubuntu 16.04 LTS,
    set `bootstrap_os` as `ubuntu` as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6d901bec-7cf7-4f38-965b-8699f376d321.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also update other variables, such as `kube_version`, to change or install
    a Kubernetes version. For more details, read the documentation at [https://github.com/kubernetes-incubator/kubespray/blob/master/docs/vars.md](https://github.com/kubernetes-incubator/kubespray/blob/master/docs/vars.md).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can execute the playbook. Use the `ansible-playbook` command instead
    of the Ansible command. Ansible-playbook runs multiple Ansible modules based on
    tasks and roles that are defined in the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the kubespray playbook, type the ansible-playbook command with the following
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The ansible-playbook argument parameter is the same as the Ansible command.
    So, if you need to use `-K` (ask for the `sudo` password) or `--become-method=su`,
    you need to specify for ansible-playbook as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes around 5 to 10 minutes to complete based on the machine spec and network
    bandwidth. But eventually you can see `PLAY RECAP`, as shown in the following
    screenshot, to see whether it has succeeded or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1402d1ac-b161-4138-a5ad-5be4b9470580.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you see `failed=0` like in the preceding screenshot, you have been successful
    in setting up a Kubernetes cluster. You can ssh to the Kubernetes master machine
    and run the `/usr/local/bin/kubectl` command to see the status, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8a93387d-c43c-4f24-a7d3-4c2115f4fecd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that you have been successful in setting up the
    Kubernetes version 1.10.2 master and node. You can continue to use the `kubectl`
    command to configure you Kubernetes cluster in the following chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unfortunately, if you see a failed count of more than 0, the Kubernetes cluster
    has probably not been set up correctly. Because failure is caused by many reasons,
    there is no single solution. It is recommended that you append the verbose option
    `-v` to see more detailed output from Ansible, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If the failure is timeout, just retrying the ansible-playbook command again
    may solve it. Because Ansible is designed as an idempotency, if you re-perform
    the ansible-playbook command twice or more, Ansible still can configure correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the failure is change target IP address after you run ansible-playbook (for
    example, re-using the Ansible machine to set up another Kubernetes cluster), you
    need to clean up the fact cache file. It is located under `/tmp` directory, so
    you just delete this file, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6990eb72-ec1c-4471-8af9-6cb8fdc41985.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes how to set up the Kubernetes cluster on the Linux OS
    using kubespray. It is the Ansible playbook that supports major Linux distribution.
    Ansible is simple, but due to supporting any situation and environment, you need
    to care about some different use cases. Especially with ssh and sudo-related configurations,
    you need to understand Ansible deeper to fit it with your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Running your first container in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've built your own Kubernetes cluster in the previous recipes.
    Now, let's get on with running your very first container, nginx ([http://nginx.org/](http://nginx.org/)),
    which is an open source reverse proxy server, load balancer, and web server. Along
    with this recipe, you will create a simple nginx application and expose it to
    the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start to run your first container in Kubernetes, it''s better to
    check if your cluster is in a healthy mode. A checklist showing the following
    items would make your `kubectl` sub commands stable and successful, without unknown
    errors caused by background services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the master daemons. Check whether the Kubernetes components are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status of the Kubernetes master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether all the nodes are ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Ideal results should look like the preceding outputs. You can successfully fire
    the `kubectl` command and get the response without errors. If any one of the checked
    items failed to meet the expectation, check out the settings in the previous recipes
    based on the management tool you used.
  prefs: []
  type: TYPE_NORMAL
- en: Check the access permission of the Docker registry, as we will use the official
    free image as an example. If you want to run your own application, be sure to
    dockerize it first! What you need to do for your custom application is to write
    a Dockerfile ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)),
    and build and push it into the public or private Docker registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your node connectivity with the public/private Docker registry
  prefs: []
  type: TYPE_NORMAL
- en: On your node, try the Docker pull nginx command to test whether you can pull
    the image from the Docker Hub. If you're behind a proxy, please add `HTTP_PROXY`
    into your Docker configuration file([https://docs.docker.com/engine/admin/systemd/#httphttps-proxy](https://docs.docker.com/engine/admin/systemd/#httphttps-proxy)).
    If you want to run the image from the private repository in the Docker Hub, or
    the image from the private Docker registry, a Kubernetes secret is required. Please
    check *Working with secrets*, in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Working through Kubernetes Concepts*, *for the instructions.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the official Docker image of nginx as an example. The image is provided
    in the Docker Hub ([https://store.docker.com/images/nginx](https://store.docker.com/images/nginx)),
    and also the Docker Store ([https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the official and public images are available on the Docker Hub or Docker
    Store so that you do not need to build them from scratch. Just pull them and set
    up your custom setting on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Store versus Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: As you may be aware, there is a more familiar official repository, Docker Hub,
    which was launched for the community for sharing the based image. Compared with
    the Docker Hub, the Docker Store is focused on enterprise applications. It provides
    a place for enterprise-level Docker images, which could be free or paid for software.
    You may feel more confident in using a more reliable image on the Docker Store.
  prefs: []
  type: TYPE_NORMAL
- en: Running a HTTP server (nginx)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Kubernetes master, we can use `kubectl run` to create a certain number
    of containers. The Kubernetes master will then schedule the pods for the nodes
    to run, with general command formatting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example will create two replicas with the name `my-first-nginx`
    from the nginx image and expose port `80`. We can deploy one or more containers
    in what is referred to as a pod. In this case, we will deploy one container per
    pod. Just like a normal Docker behavior, if the nginx image doesn''t exist locally,
    it will pull it from the Docker Hub by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The name of deployment <my-first-nginx> cannot be duplicated
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource (pods, services, deployment, and so on) in one Kubernetes namespace
    cannot be duplicated. If you run the preceding command twice, the following error
    will pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on and see the current status of all the pods by `kubectl get pods`.
    Normally the status of the pods will hold on Pending for a while, since it takes
    some time for the nodes to pull the image from the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If the pod status is not running for a long time
  prefs: []
  type: TYPE_NORMAL
- en: "You could always use kubectl get pods to check the current status of the pods,\
    \ and kubectl describe pods `$pod_name` to check the detailed information in a\
    \ pod. If you make a typo of the image name, you might get the `ErrImagePull`\
    \ error message, and if you are pulling \Lthe images from a private repository\
    \ or registry without proper credentials, you might get the `ImagePullBackOff`\
    \ message. If you get the `Pending` status for a long time and check out the node\
    \ capacity, make sure you don't run too many replicas that exceed the node capacity.\
    \ If there are other unexpected error messages, you could either stop the pods\
    \ or the entire replication controller to force the master to schedule the tasks\
    \ again."
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the details about the deployment to see whether all the
    pods are ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Exposing the port for external access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might also want to create an external IP address for the nginx deployment.
    On cloud providers that support an external load balancer (such as Google compute
    engine), using the `LoadBalancer` type will provision a load balancer for external
    access. On the other hand, you can still expose the port by creating a Kubernetes
    service as follows, even though you''re not running on platforms that support
    an external load balancer. We''ll describe how to access this externally later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the service status we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You may find an additional service named `kubernetes` if the service daemon
    run as a container (for example, using kubeadm as a management tool). It is for
    exposing the REST API of the Kubernetes API server internally. The pending state
    of `my-first-nginx` service's external IP indicates that it is waiting for a specific
    public IP from cloud provider. Take a look at [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*, and [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    *Building Kubernetes on GCP*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just ran your first container with a Kubernetes pod and
    exposed port `80` with the Kubernetes service.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can stop the application using commands such as the delete deployment and
    service. Before this, we suggest you read through the following code first to
    understand more about how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the insight of the service using describe in the `kubectl`
    command. We will create one Kubernetes service with the type `LoadBalancer`, which
    will dispatch the traffic into two endpoints, `192.168.79.9` and `192.168.79.10`
    with port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The port here is an abstract service port, which will allow any other resources
    to access the service within the cluster. The `nodePort` will be indicating the
    external port to allow external access. The `targetPort` is the port the container
    allows traffic into; by default, it will be the same port.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, external access will access the service with `nodePort`.
    The service acts as a load balancer to dispatch the traffic to the pod using port
    `80`. The pod will then pass through the traffic into the corresponding container
    using `targetPort 80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f7b733a-b8aa-47b9-904e-137cc1e958f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In any nodes or master, once the inter-connection network is set up, you should
    be able to access the nginx service using `ClusterIP` `192.168.61.150` with port
    `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be the same result if we `curl` to the target port of the pod directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you'd like to try out external access, use your browser to access the external
    IP address. Please note that the external IP address depends on which environment
    you're running in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Google compute engine, you could access it via a `ClusterIP` with a
    proper rewall rules setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In a custom environment, such as on-premise data center, you could go through
    the IP address of nodes to access :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see the following page using a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3d0dfde-0b38-463c-809f-65f6cc14f357.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have run our very first container in this section. Go ahead and read the
    next chapter to aquire more knowledge about Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: Building Continuous Delivery Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving monolithic to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the private Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a perfect match for applications featuring the microservices architecture.
    However, most of the old applications are built in the monolithic style. We will
    give you an idea about how to move from the monolithic to the microservices world.
    As for microservices, deployment will become a burden if you are doing it manually.
    We will learn how to build up our own continuous delivery pipeline by coordinating
    Jenkins, the Docker registry, and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Moving monolithic to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, application architecture is the monolithic design that contains a
    **Model-View- Controller** (**MVC**) and every component within a single, big
    binary. A monolithic design has some benefits, such as less latency within components,
    being all in one straightforward package, and being easy to deploy and test.
  prefs: []
  type: TYPE_NORMAL
- en: However, a monolithic design has some downsides because the binary will be getting
    bigger and bigger. You always need to take care of the side effects when adding
    or modifying the code, therefore making release cycles longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers and Kubernetes give more flexibility when using microservices for
    your application. The microservices architecture is very simple and can be divided
    into some modules or some service classes together with MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9459422c-7fe8-4107-9f7c-2d0718edd145.png)Monolithic and microservices
    design'
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice provides a **Remote Procedure Call** (**RPC**) using RESTful
    or some standard network APIs to other microservices. The benefit is that each
    microservice is independent. There are minimal side effects when adding or modifying
    the code. Release the cycle independently, so it perfectly ties in with the Agile
    software development methodology and allows for the reuse of these microservices
    to construct another application that builds the microservices ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare the simple microservices program. In order to push and pull your microservices,
    please register to Docker hub ([https://hub.docker.com/](https://hub.docker.com/))
    to create your free Docker ID in advance.
  prefs: []
  type: TYPE_NORMAL
- en: If you push the Docker image to Docker hub, it will be public; anyone can pull
    your image. Therefore, don't put any confidential information into the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you successfully log in to your Docker ID, you will be redirected to your
    Dashboard page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2fa69dc3-7110-456f-9da3-b049acaa6b28.png)After logging in to Docker
    hub'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare both microservices and the frontend WebUI as a Docker image. Then, deploy
    them using the Kubernetes replication controller and service.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build a microservice which provides a simple math function by using following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the simple microservice using Python `Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a `Dockerfile` as follows in order to build the Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `docker build` command to build the Docker image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `docker login` command to log in to Docker hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the `docker push` command to register to your Docker hub repository
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon access to Docker hub, you can see your microservice in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0126d63d-fb96-4007-aacc-43f4518fb247.png)Your microservice Docker
    image on Docker hub'
  prefs: []
  type: TYPE_NORMAL
- en: Frontend WebUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build WebUI that uses preceding microservice by following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the simple frontend WebUI that also uses Python `Flask`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes service generates the Kubernetes service name and port number as
    an environment variable to the other pods. Therefore, the environment variable's
    name and the Kubernetes service name must be consistent. In this scenario, the
    `my-calc` service name must be `my-calc-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend WebUI uses the `Flask` HTML template; it is similar to PHP and
    JSP in that `entry.py` will pass the parameter to the template (`index.html`)
    to render the HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Dockerfile` is exactly the same as the microservice `my-calc`. So, eventually,
    the file structure will be as follows. Note that `index.html` is a jinja2 template
    file; therefore, put it under the `/templates` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, build a Docker image and push to Docker hub as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to push your image to Docker hub, you need to log in using the Docker
    login command. It is needed only once; the system checks `~/.docker/config.json`
    to read from there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon access to Docker hub, you can see your WebUI application in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png)Microservices and frontend
    WebUI image on Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's prepare two YAML configurations to launch a microservice container and
    frontend WebUI container using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices (`my-calc`) uses the Kubernetes deployment and service, but it
    needs to communicate to other pods only. In other words, there''s no need to expose
    it to the outside Kubernetes network. Therefore, the service type is set as `ClusterIP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `kubectl` command to load the `my-calc` pods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Frontend WebUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Frontend WebUI also uses the deployment and service, but it exposes the port
    (TCP port `30080`) in order to access it from an external web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to access `my-frontend-service` using a web browser. You can access
    any Kubernetes node''s IP address; specify the port number 30080\. If you are
    using minikube, simply type `minikube service my-frontend-service` to access.
    Then you can see the `my-frontend `application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7aed4df-0a7b-4e57-812a-91e75552352e.png)Access to the frontend
    WebUI'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the addition button, it will forward a parameter to microservices
    (`my-calc`). Microservices compute the addition (yes, just an addition!) and then
    return the result back to the frontend WebUI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75836636-1a08-480c-8683-294f03a36740.png)Getting a result from microservices
    and rendering the HTML'
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, it is easy to scale the pod for the frontend WebUI and microservices
    independently. For example, scale WebUI pod from `2` to `8` and microservice pod
    from `2` to `16`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Also, if there's a need to fix some bugs, for example, if there's a frontend
    need to validate
  prefs: []
  type: TYPE_NORMAL
- en: the input parameter to check whether it is numeric or a string (yes, if you
    type string and
  prefs: []
  type: TYPE_NORMAL
- en: then submit, it will show an error!), it will not affect the build and deploy
    the cycle against
  prefs: []
  type: TYPE_NORMAL
- en: 'microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/085ae157-527d-4a9f-b15d-174e0acfe8b0.png)Frontend and microservice
    pods and services'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if you want to add another microservice, for example, subtraction
    microservices, you may need to create another Docker image and deploy with another
    deployments and service, so it will be independent from the current microservices. Then,
    you can keep accumulating your own microservice ecosystem to reuse in another
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the private Docker registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start to build your microservice application via Docker, you'll need
    to have a Docker registry to put your container image in. Docker hub offers you
    free public repositories, however, in some cases you might want to make your image
    private due to business needs or organization policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker hub offers the **private repository**, which only allows authenticated
    users to push and pull your images, and is not visible to other users. However,
    there is only one quota (repository) for a free plan. You may pay to increase
    the number of private repositories, but if you adopt the microservices architecture,
    you will need a large number of private repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f17ae140-cc38-4932-95b1-cfadf4a27a26.png)Docker hub private repositories
    price list'
  prefs: []
  type: TYPE_NORMAL
- en: Docker hub with a paid plan is the easiest way to set up your private registry,
    but there are some other ways to set up your own private Docker registry, which
    the unlimited Docker image quota locates inside your network. In addition, you
    can also use other cloud-provided registry services to manage your private registry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will show you three different ways to set up your own private
    registries:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes to run a private registry image ([https://hub.docker.com/_/registry/](https://hub.docker.com/_/registry/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Amazon elastic container registry ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google container registry ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a Kubernetes to set up a private registry, you may use your own Kubernetes
    cluster on the private or public cloud, which allows you to have full control
    and utilize most of your physical resources.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when using a public cloud-provided service, such as AWS or
    GCP, you can be relieved of the management of servers and storage. Whatever you
    need, those public clouds provide you with elastic resources. We'll just have
    to set the credentials to Kubernetes and let the nodes know. The following recipes
    will go through these three different options.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes to run a Docker registry server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to launch a private registry server using Kubernetes, you need your
    own Kubernetes cluster. You will have set up your own Kubernetes while exploring
    this book. If you haven't done yet, please read [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*, to choose the easiest way.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Docker registry will store some of your Docker images. You
    must have a `PersistentVolume` to manage your storage via Kubernetes. In addition,
    we should expect that multiple pods will read and write to the same `PersistentVolume`
    due to scalability. Therefore, you must have the **ReadWriteMany** (**RWX**)access
    mode of `PersistentVolume`, such as GlusterFS or NFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Details of `PersistentVolume` are described in the *Working with volumes* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*. Let''s create a `PersistentVolume` that uses NFS and the name `pvnfs01`
    to allocate `100` GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can''t prepare RWX `PersistentVolume`, you may still be able to set
    up Docker registry by Kubernetes, but you can launch only one pod (replicas: one).
    As an alternative, you may use AWS S3 or GCP PD as private registry backend storage;
    please visit [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)
    to learn how to configure backend storage for your registry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create `PersistentVolumeClaim` that decouples NFS `PersistentVolume`
    and pod configuration. Let''s create one `PersistentVolumeClaim` named `pvc-1`. Make
    sure `accessModes` is `ReadWriteMany` and that `STATUS` became `Bound` after creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to set up your private registry. It has some prerequisites; alternatively,
    using the public cloud is much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Using Amazon elastic container registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon **elastic container registry** (**ECR**) was introduced as a part of
    Amazon **elastic container service** (**ECS**). This recipe won't touch on ECS
    itself; instead, just use ECR as a private registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Amazon ECR, you have to have an AWS account and install AWS
    CLI on your machine. It will be described in more detail in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS. *You''ll have to create an IAM user with `ACCESS
    KEY ID` and `SECRET ACCESS KEY`, and associated `AmazonEC2ContainerRegistryFullAccess` policies,
    which allow full administrator access to Amazon ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then configure the default settings in AWS CLI via the `aws configure` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then we can start to play with Amazon ECR.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google cloud registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google container registry** ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
    is a part of the GCP. Similar to AWS, having a GCP account is required, as well
    as Cloud SDK ([https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)),
    which is the command-line interface in GCP. More details about GCP will be described
    in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), *Building Kubernetes
    on GCP*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On GCP, we''ll just need to create a project and enable billing and the container
    registry API for our project. Otherwise, any operation in `gcloud` will display
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to enable billing and container registry API, visit the GCP web console
    ([https://console.cloud.google.com](https://console.cloud.google.com)), navigate
    to the billing page and container registry page, then just enable those. Once
    activation is done, you can use the `gcloud container` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start to use Google container registry.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have set up the preparation steps. Let's see how to configure your private
    registry step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a private registry server using Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to launch a private registry, it is necessary to configure these files
    in order to configure a private registry with appropriate security settings:'
  prefs: []
  type: TYPE_NORMAL
- en: SSL certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP basic authentication file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a self-signed SSL certificate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a pitfall—people tend to set up a plain HTTP (disable TLS) registry
    without authentication in the beginning. Then it also needs to configure a Docker
    client (Kubernetes node) to allow an insecure registry and so on. It is a bad
    practice that requires many steps to set up an insecure environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice is always using the official SSL certificate that is issued
    by the certificate authority. However, a self-signed certificate is always handy,
    especially in the testing phase. An official certificate can wait until we have
    FQDN defined. Therefore, this recipe will show you how to use OpenSSL to create
    a self-signed SSL certificate via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `secrets` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `openssl` command to specify the options to generate a certificate
    (`domain.crt`) and a private key (`domain.key`) under the secrets directory. Note
    that you may type `.` to skip to input location and email info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether both certificate and private keys are generated under the `secrets`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating HTTP secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regarding HTTP secret, it will be randomly generated by the private registry
    instance upon startup by default. However, it is a problem if you run multiple
    pods, because each pod may have a different HTTP secret that occur an error when
    Docker client push or pull the image. So we explicitly state that all pods will
    use the same HTTP secret, via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `openssl` command to create a `http.secret` file under the `secrets`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `secrets` directory, which has three files now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating the HTTP basic authentication file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, regarding the HTTP basic authentication file, if you set up a private
    registry, authentication is needed when you interact with the Docker registry.
    You''ll have to do `docker login` to get a token when pushing and pulling images.
    In order to create an HTTP basic authentication file, use the `htpasswd` command
    that is provided by Apache2 as this is easiest. Let''s create a HTTP basic authentication
    file via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Docker with Apache2 Docker image (`httpd`) to run the `htpasswd` command
    with the `bcrypt` (`-B`) option and generate a basic authentication file (`registry_passwd`)
    under the `secrets` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `secrets` directory so that now you have four files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Kubernetes secret to store security files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four files. We use **Kubernetes Secret** so that all pods can access
    it via an environment variable or mount a volume and access as a file. For more
    details about secrets, please refer to the *Working with secrets* section in [Chapter
    2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes Concepts*.
    You can use the `kubectl` command to load these four files to store to the Kubernetes
    secret via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `kubectl create` command with the `--from-file` parameter to specify
    the secrets directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status via the `kubectl describe` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a private registry to load a Kubernetes secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the other hand, the private registry itself supports reading the HTTP secret
    as an environment variable in string format. It also can support specifying the
    file path for the SSL certificate and HTTP basic authentication file as environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Environment variable name** | **Description** | **Sample value** |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_HTTP_SECRET` | HTTP secret string | `valueFrom`:    `secretKeyRef:`` 
          name: registry-secrets``        key: http.secret` |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_HTTP_TLS_CERTIFICATE` | File path for certificate  (`domain.crt`)
    | `/mnt/domain.crt` |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_HTTP_TLS_KEY` | File path for private key (`domain.key`) | `/mnt/domain.key`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_AUTH_HTPASSWD_REALM` | The realm in which the registry server authenticates
    | `basic-realm` |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_AUTH_HTPASSWD_PATH` | File path for `htpasswd` file (`registry_passwd`)
    | `/mnt/registry_passwd` |'
  prefs: []
  type: TYPE_TB
- en: '| `REGISTRY_HTTP_HOST` | Specify one of Kubernetes node IP and `nodePort` |
    `10.138.0.3:30500` |'
  prefs: []
  type: TYPE_TB
- en: Ideally, you should have a load balancer and set up a Kubernetes Service type
    as `LoadBalancer`. And then `REGISTRY_HTTP_HOST` could be the load balancer IP
    and port number. For simplicity, we'll just use `NodePort` in this recipe. For
    more information about `LoadBalancer`, refer to the *Working with services* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*, and the *Forwarding container ports* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll conduct a deployment to a Kubernetes YAML file for creating a registry,
    and include the preceding variables inside it, so the registry pods can use them. Now
    we have `PersistentVolumeClaim` as `pvc-1` that supplies the container image store,
    and mounts SSL certificate files (`domain.crt` and `domain.key`) and an HTTP basic
    authentication file (`registry_passwd`) via Secret `registry-secrets`. As well
    as reading the HTTP Secret string as an environment variable by Secret `registry-secrets`.
     The entire YAML configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now your own private registry is ready to use!
  prefs: []
  type: TYPE_NORMAL
- en: Create a repository on the AWS elastic container registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to push a container image to Amazon ECR, you need to create a repository
    beforehand. Unlike Docker hub or private registry, Amazon ECR doesn''t create
    a repository automatically when it is the first time to push the image. Therefore,
    if you want to push three container images, you have to create three repositories
    in advance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to type the `aws ecr create-repository` command to specify the
    repository name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You need to remember the `repositoryUri` (in the previous case, `************.dkr.ecr.us-east-1.amazonaws.com/my-nginx`) that
    will be used as the private image URL.
  prefs: []
  type: TYPE_NORMAL
- en: The previous URL is masked as an ID as `************`. It is tied with your
    AWS account ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you see something like the following error message, your
    IAM user doesn''t have the permission of the `CreateRepository` operation. In
    this case, you need to attach an IAM policy from `AmazonEC2ContainerRegistryFullAccess`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Determining your repository URL on Google container registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to push a container image to Google container registry, there is an
    important consideration regarding the repository URL. First of all, there are
    several Google container registry region hosts available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gcr.io` (currently USA region)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`us.gcr.io` (USA region)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eu.gcr.io` (Europe region)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asia.gcr.io` (Asia region)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these region hosts are network latency purpose, doesn't mean to restrict
    to a particular region. They are still accessible worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second of all, while you tag the container image, you also need to specify
    your `project-id` on which you''ve enabled billing and API. Therefore, the entire
    repository URL could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, I used the region USA default, the project ID is `kubernetes-cookbook`,
    and the image name is `my-nginx`; therefore, my repository URL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Other than that, Google container registry is ready to use now!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start to use private registry with Kubernetes, you must configure a
    credential properly. Amazon ECR and Google cloud registry need special consideration.
    Let's configure a credential for private registry, Amazon ECR and Google cloud
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Push and pull an image from your private registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you can push your container image to your private registry. Because we
    have set up an HTTP basic authentication, you need to do `docker login` first.
    Otherwise you get a `no basic auth credentials` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, you need `docker login` to specify the username and password, which
    you set onto the `registry_passwd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, as for pulling an image from a private registry, Kubernetes
    nodes also needs to have a credential for your private registry. But using the `docker
    login` command on every node is not realistic. Instead, Kubernetes supports storing
    this credential as a Kubernetes secret and each node will use this credential
    while pulling an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to create a `docker-registry` resource that needs to specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--docker-server`: In this example, `10.138.0.3:30500`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--docker-username`: In this example, `user01`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--docker-password`: In this example, `my-super-secure-password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--docker-email`: Your email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can pull your private image from the private registry that is
    specifying the `my-private-credential` secret. To do that, set `spec.imagePullSecrets`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Now you can feel free to push your private images to your private
    registry run by Kubernetes. Also, pull an image from Kubernetes too. At any time,
    you can scale out based on client traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Push and pull an image from Amazon ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon ECR has an authentication mechanism to provide access to your private
    repositories. AWS CLI has a functionality to generate an access token using the `aws
    ecr get-login` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It outputs the `docker login` command with the ID and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, just copy and paste to your terminal to acquire a token from AWS.
    Then try `docker push` to upload your Docker image to ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, pulling an image from ECR to Kubernetes follows exactly
    the same steps as the private registry that uses a Kubernetes secret to store
    the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `spec.imagePullSecrets` needs to specify `my-ecr-secret`. As well as the
    image URL, it also specifies the ECR repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this token is short-lived: it''s valid up to 12 hours. So, 12 hours
    later, you need to run `aws ecr get-login` again to acquire a new token, then
    update the secret `my-ecr-secret`. It is absolutely not ideal to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that Kubernetes supports the updating of the ECR token automatically
    via `CloudProvider`. However, it requires that your Kubernetes runs on an AWS
    environment such as EC2\. In addition, the EC2 instance has to have an IAM role
    that is equivalent or higher than the `AmazonEC2ContainerRegistryReadOnly` policy.
    It will be described in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*.
  prefs: []
  type: TYPE_NORMAL
- en: If you really want to use your Kubernetes cluster outside of AWS by pulling
    an image from the ECR repository, there is a challenge in that you need to update
    the ECR token every 12 hours. Maybe you can do this using a cron job or by adopting
    some automation tools.
  prefs: []
  type: TYPE_NORMAL
- en: For more detail, please visit the AWS online document at [https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html).
  prefs: []
  type: TYPE_NORMAL
- en: Push and pull an image from Google cloud registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to GCP documentation ([https://cloud.google.com/container-registry/docs/advanced-authentication](https://cloud.google.com/container-registry/docs/advanced-authentication)),
    there are several way to push/pull to a container registry.
  prefs: []
  type: TYPE_NORMAL
- en: Using gcloud to wrap the Docker command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `gcloud` command has a wrapper function to run a `docker` command to push
    and pull. For example, if you want to push the image `gcr.io/kubernetes-cookbook/my-nginx`,
    use the `gcloud` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It is sufficient to push the image from your machine, however, it is not ideal
    if you integrate with Kubernetes. This is because it is not easy to wrap the `gcloud`
    command on the Kubernetes node.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a solution that creates a GCP service account and grants
    a permission (role) to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GCP service account to grant a long-lived credential
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to integrate to pull an image from the Kubernetes node, which requires
    a long-lived credential that can be stored to the Kubernetes secret. To do that,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a GCP service account (`container-sa`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign `container-sa` (use full name) to the `roles/storage.admin` role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate a key file (`container-sa.json`) for `container-sa`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `docker login` to check whether the key file is working or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `docker pull` to check whether you can pull from container registry or
    not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Looks all fine! Now you can use the Kubernetes secret the exact same way with
    the private registry or AWS ECR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Kubernetes secret (`my-gcr-secret`) to specify `_json_key` and `container-sa.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify `my-gcr-secret` to `imagePullSecrets` to launch a pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Now you can use Google container registry for your private
    registry that is fully managed by GCP. And Kubernetes can pull your private image
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software engineering, **continuous integration** (**CI**) ([https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration))
    and **continuous delivery** (**CD**) ([https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery)),
    abbreviated as CI/CD, have the ability to simplify the procedure of the traditional
    development process with continuous developing, testing, and delivering mechanisms
    in order to reduce the panic of serious conflict, namely, to deliver small changes
    one at a time and to narrow down the problems immediately, if any. Furthermore,
    through automatic tools, a product delivered by the CI/CD system can achieve better
    efficiency and shorten time-to-market.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is one of the well-known CI systems, which can be configured as a continuous
    delivery system. Jenkins can pull your project codes from the source code control
    system, run the tests, and then deploy based on your configuration. In this recipe,
    we will show you how to integrate Jenkins to Kubernetes to achieve continuous
    delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start this recipe, prepare a Docker hub account ([https://hub.docker.com](https://hub.docker.com))
    or you may use your private registry that is described in the previous section.
    But the important part is you must have a credential to pull and push to the registry.
    If you use Docker hub, make sure `docker login` with your credentials works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make sure your Kubernetes is ready. But we will use RBAC authentication
    for access from the Jenkins pod to the Kubernetes master API. If you use `minikube`,
    you need to add the `--extra-config=apiserver.Authorization.Mode=RBAC` option
    when starting a minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can set up your own Jenkins server through Kubernetes as well; the
    details are in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some minikube versions have a `kube-dns` issue that can''t resolve the external
    domain name, such as [https://github.com/](https://github.com/) and [https://jenkins.io/](https://jenkins.io/), that
    can''t process this recipe. Replacing the `kube-dns` add-on with the `coredns`
    add-on could resolve the issue after launching `minikube` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ minikube addons disable kube-dns`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ minikube addons enable coredns`'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two important parts to go through in the Jenkins setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins needs to run a `docker` command to build your application to compose
    your container image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins need to communicate with the Kubernetes master to control deployment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve step 1, there is a tricky part that needs something like a **Docker-in-Docker**
    (**dind**). This is because Jenkins is run by Kubernetes as a pod (Docker container),
    and Jenkins also needs to invoke a `docker` command to build your application.
    It can be achieved by mounting `/var/run/docker.sock` from the Kubernetes node
    to the Jenkins pod that can communicate with Jenkins, the Kubernetes node, and
    the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Docker-in-Docker and mounting `/var/run/docker.sock` have been described at
    [https://blog.docker.com/2013/09/docker-can-now-run-within-docker/](https://blog.docker.com/2013/09/docker-can-now-run-within-docker/) and [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/.](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve step 2, we will set up a Kubernetes service account and
    assign one `ClusterRole` so that the Jenkins service account can have a necessary privilege.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom Jenkins image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run Jenkins by Kubernetes, we use an official image ([https://hub.docker.com/u/jenkins/](https://hub.docker.com/u/jenkins/))
    but customize it to install the following applications on it:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker CE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins Docker plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do that, prepare `Dockerfile `to maintain your own Jenkins image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `docker build` to build your Jenkins image and then  `docker push` command
    to upload to your own registry in Docker hub, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Or, alternatively, you could upload that to your private registry or any other
    cloud-provided registry.
  prefs: []
  type: TYPE_NORMAL
- en: Hurray! We have our build system image ready now.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kubernetes service account and ClusterRole
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that after using Jenkins successfully to build your application container,
    you then use `kubectl` to update deployment to roll out a new binary. To do that,
    invoke a `kubectl` command from the inside of a Jenkins pod. In this scenario,
    we need a credential to communicate to the Kubernetes master.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Kubernetes supports this kind of scenario, which uses a service
    account. It is described in detail in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*. So, this recipe will use the simplest way,
    which uses the `default` namespace and `cluster-admin ClusterRole`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether RBAC is enabled and also if the `cluster-admin ClusterRole`
    exists or not, type the `kubectl get clusterrole` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a service account, `jenkins-sa`, which will be used by a Jenkins
    pod. Prepare the following YAML configuration, and type the `kubectl create` command
    to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can associate the `jenkins-sa` service account with a `cluster-admin`
    `ClusterRole`. Prepare a `ClusterRoleBinding` configuration and run the `kubectl
    create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the result, if a pod is launched with the service account `jenkins-sa`, this
    Pod has the privilege to control a Kubernetes cluster because of the `cluster-admin
    ClusterRole`.
  prefs: []
  type: TYPE_NORMAL
- en: It should create a custom `ClusterRole` that has minimal privilege for Jenkins
    usage. But this recipe is to focus on the Jenkins setup itself. If you want to
    create a custom `ClusterRole`, please go to [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Jenkins server via Kubernetes deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the previous recipes, now you have:'
  prefs: []
  type: TYPE_NORMAL
- en: A custom Jenkins container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you can launch your custom Jenkins server on your Kubernetes cluster.
    Remember that we need to run a `docker` command in the Docker environment, which
    needs to mount `/var/run/docker.sock` from the local Kubernetes node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need to use a `jenkins-sa `service account to launch a Jenkins
    pod. It needs to specify `spec.template.spec.serviceAccountName: jenkins-sa` in
    the deployment configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also recommended to have a `PersistentVolume` to preserve Jenkins home
    (`/var/jenkins_home`), in case a pod is restarted. We just simply use the `hostPath
    /data/jenkins-data` directory (assuming you use minikube). You may change to another
    path or other types of `PersistentVolume` to fit with your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the deployments YAML configuration for Jenkins is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, Kubernetes pulls your custom Jenkins image and runs a
    Jenkins pod which is capable of running a `docker` command and a `kubectl` command
    without any configuration due to mounting the `/var/run/docker.sock` and `jenkins-sa` service
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You are all set! Now you can configure a Jenkins job to build your application,
    build a container, and deploy to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we start to configure Jenkins to build your application. However, to access
    the WebUI of your custom Jenkins, you need to access the Kubernetes service that
    binds to your Jenkins pod. It is easier to use `kubectl port-forward` to access
    remotely to configure Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial configuration of Jenkins is done via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the `http://127.0.0.1:58080` Jenkins WebUI; it asks you to input `initialAdminPassword`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `kubectl exec` to acquire the `initialAdminPassword`. Then copy and paste
    to the Jenkins WebUI to proceed with the initial configuration to install the
    suggested plugin and create an admin user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a Jenkins top page. Then click Manage Jenkins, then Configure
    System:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7ba133a9-48d4-4227-a747-9eeeb386699e.png)Navigate to Jenkins configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to the bottom and find a Cloud section. Click Add a new cloud to select
    Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7ee5f4ab-dbfb-4e9c-a3ad-cf7b4f5c1ef2.png)Adding a Docker setting'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put Name as your desired name (example: `my-docker`) and specify the Docker
    Host URI and Docker domain socket as `unix:///var/run/docker.sock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/53073463-06d0-4b8c-8e2e-7f27070df8c2.png)Configure Docker on Jenkins'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to build a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s configure a Jenkins job to build a sample microservice application,
    which was introduced in the previous recipe (`my-calc`). Perform the following
    steps to configure and build a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left navigation, click New Item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7eafbe4f-c882-454c-8ff4-994766bc6922.png)Navigating to create a
    new item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put your in desired item name (example: `my-calc`), select Freestyle project,
    then click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/911c131b-08a8-48e4-a814-5971bd062314.png)Creating a new Jenkins
    Job'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Source Code Management tab, select Git and set the Repository URL as [https://github.com/kubernetes-cookbook/my-calc.git](https://github.com/kubernetes-cookbook/my-calc.git),
    or you may use your own repository which has a `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a9dbdb04-69e8-428c-98ee-6e5682bab7c7.png)Source Code Management
    settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Build Environment tab, click Add build step to add Build / Publish Docker
    Image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/680b49b0-db5f-4d42-95fe-77730fdef7ad.png)Build Environment settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Build / Publish Docker Image panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directory for `Dockerfile` as current (`.`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose my-docker in the Cloud that we've set up
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put image as your Docker repository, but append `:${BUILD_NUMBER}` (example:
    `hidetosaito/my-calc:${BUILD_NUMBER}`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable Push image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Add to add your Docker hub ID credential
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png)Docker build/publish settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can click Build Now to trigger a build; for testing purposes you
    can click five times to see how it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png)Trigger a build'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can see a Console that knows it performs a Docker build and push:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b4447718-f02a-4986-8ed3-6588a887ebc0.png)Showing a build log'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access your Docker hub repository; it has been pushed five times (because of
    clicking on build five times):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png)Docker hub repository'
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You can achieve continuous integration to build a Docker image so
    that when you update a source in GitHub, you can continuously build and push the
    latest image to your Docker hub repository by Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the latest container image to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After each build, Jenkins keeps pushing your container image on your Docker
    hub repository at the end of the CI process. Next, update the Jenkins job configuration
    to use the latest image to deploy to Kubernetes, via the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time, we pre-deploy microservice application manually via `kubectl
    deploy --record`. Note that you may change `spec.template.spec.containers.image:
    hidetosaito/my-calc` to your repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Open Jenkins Job configuration; on the Build tab, right after the Docker build
    settings, click Add build step and choose Execute shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c473e1c8-40ee-4416-bb22-facf3f7438e8.png)Adding a build step'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this shell script and click Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Trigger a new build; you can see that after Docker push, it runs the preceding
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7b881532-d1b1-4322-b3ef-d27217f4b377.png)Kubernetes rollout result'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can extend continuous integration to continuous delivery! You may extend
    to add a unit test or integration test and roll back mechanisms onto the above
    script to make your CI/CD work stronger.
  prefs: []
  type: TYPE_NORMAL

- en: Advanced Cluster Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced settings in kubeconfig
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting resources in nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with WebUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Kubernetes DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will go through some advanced administration topics in this chapter. First,
    you will learn how to use kubeconfig to manage different clusters. Then, we will
    work on computing resources in nodes. Kubernetes provides a friendly user interface
    that illustrates the current status of resources, such as deployments, nodes,
    and pods. You will learn how to build and administrate it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to work with the RESTful API that Kubernetes exposes.
    It will be a handy way to integrate with other systems. Finally, we want to build
    a secure cluster; the last section will go through how to set up authentication
    and authorization in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced settings in kubeconfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**kubeconfig** is a configuration file that manages cluster, context, and authentication
    settings in Kubernetes, on the client side. Using the `kubeconfig` file, we are
    able to set different cluster credentials, users, and namespaces to switch between
    clusters or contexts within a cluster. It can be configured via the command line
    using the `kubectl config` subcommand or by updating a configuration file directly.
    In this section, we''ll describe how to use `kubectl config` to manipulate kubeconfig
    and how to input a kubeconfig file directly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have gone through the *Working with namespace* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*, where we first mentioned kubeconfig, you
    will know of its basic concepts. Let''s review some key points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e705eb01-9990-424f-8967-f63d4de49904.png)kubeconfig contains three
    parameters: user, cluster, and context'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**There are three parameters in kubeconfig**: User, cluster, and context—user
    has its own authentication, while cluster determines the specific API server with
    dedicated computing resources. Context is both *user* and cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building multiple contexts for various combinations of settings**: Users
    and clusters can be shared across different contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace can be aligned in one context**: The current context of a namespace
    sets up the rules. Any requests should follow the mapping user and cluster in
    the current  context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please run two Kubernetes clusters and give them the specified host name. You
    may just update the hostfile (`/etc/hosts`) on the master nodes. One is under
    localhost with the API server endpoint `http://localhost:8080` and the other is
    on the remote side with the endpoint `http://$REMOTE_MASTER_NODE:8080`. We will
    use these two clusters for our demonstration. The endpoints of the API server
    here are insecure channels. It is a simple configuration of an API server for
    the dummy accessing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enableing the API server''s insecure endpoint on kubeadm**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to pass additional arguments to the API server while running `kubeadm
    init`. In this case, a custom configuration file indicated by flag `--config`
    should be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After you boot up two clusters that have an insecure-accessing API server endpoint,
    make sure you can approach them on the localhost cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the insecure address configuration is just for our upcoming
    tutorial. Users should be careful to set it properly on a practical system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we should check the default kubeconfig in order to observe
    the changes after any updates. Fire the command `kubectl config view` to see your
    initial kubeconfig:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There will be some different settings based on your installation method. But
    we may also find a basic context has been initialized by the tool, which is `kubernetes-admin@kubernetes`
    in kubeadm. Go ahead and copy the physical `kubeconfig` file as the base for later
    updating, and also for resuming our original environment after our practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use localhost cluster as the main console to switch
    the cluster via context changes. First, run a different number of `nginx` into
    both the clusters and make sure the pods are all running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting new credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to set up two credentials for each cluster. Use the subcommand
    `set-credentials` as `kubectl config set-credentials <CREDENTIAL_NAME>` to add
    a credential into kubeconfig. There are different authentication methods supported
    in Kubernetes. We could use a password, client-certificate, or token. In this
    example, we''ll use HTTP basic authentication to simplify the scenario. Kubernetes
    also supports client certificate and token authentications. For more information,
    please fire the `set-credentials` command with the flag `-h` for a detailed introduction
    to its functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the preceding procedures, we successfully add a new credential in the `"new-kubeconfig"`
    `kubeconfig` file. The kubeconfig file will be formatted in YAML by default—you
    may check the file through a text editor. With this method, we are able to customize
    new configurations without interfering with the current settings. On the other
    hand, if there is no `--kubeconfig` flag, the update will be directly attached
    to the `live kubeconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, check your live kubeconfig settings and find out the new credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting new clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set a new cluster, we use the command `kubectl config set-cluster <CLUSTER_NAME>`.
    The additional flag `--server` is required to indicate the accessing cluster.
    Other flags work to define the security level, such as the `--insecure-skip-tls-verify` flag,
    which bypasses checking the server''s certificate. If you are setting up a trusted
    server with HTTPS, you will need to use `--certificate-authority=$PATH_OF_CERT
    --embed-certs=true` instead. For more information, fire the command with the `-h`
    flag for more information. In the following commands, we set up two cluster configurations
    in our localhost environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We do not associate anything with **users** and **clusters** yet. We will link
    them via **context** in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting contexts and changing current-context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One context contains a cluster, namespace, and user. According to the current
    context, the client will use the specified *user* information and namespace to
    send requests to the cluster. To set up a context, we will use the `kubectl config
    set-context <CONTEXT_NAME> --user=<CREDENTIAL_NAME> --namespace=<NAMESPACE> --cluster=<CLUSTER_NAME>` command
    to create or update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check our current kubeconfig. We can find two new contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating contexts, we can switch contexts in order to manage different
    clusters. Here, we will use the `kubectl config use-context <CONTEXT_NAME>` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it looks fine. How about if we switch to the context with the remote cluster
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All the operations we have done are in the localhost cluster. kubeconfig makes
    the scenario of working on multiple clusters with multiple users easier.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up kubeconfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can still leverage`kubectl config` to remove configurations in kubeconfig.
    For cluster sand context, you can delete the neglected one with the subcommands `delete-cluster`
    and `delete-context`. Alternatively, for these three categories, the `unset` subcommand
    can complete the deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the effects of the preceding command would apply to the live kubeconfig
    right away, an even faster and more reliable way is updating another kubeconfig
    file for the replacement. A kubeconfig file is the text file `new-kubeconfig`,
    the one we just updated, or the one we copied from the initial statement, `original-kubeconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, real use cases with credentials and
    permissions cannot be ignored like walking cross insecure endpoints, just like
    in our demonstration. To avoid security issues, you may take the official documentation
    (found at [https://kubernetes.io/docs/admin/authentication/](https://kubernetes.io/docs/admin/authentication/))
    while granting permissions to users.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kubeconfig manages  cluster, credential, and namespace settings. Check out
    the following recipes for complete concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Working with Secrets* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Working with Namespaces* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting resources in nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing resource management is very important in any infrastructure. We should
    know our application well and preserve enough CPU and memory capacity to avoid
    running out of resources. In this section, we'll introduce how to manage node
    capacity in Kubernetes nodes. Furthermore, we'll also describe how to manage pod
    computing resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes has the concept of resource **Quality of Service**(**QoS**). It
    allows an administrator to prioritize pods to allocate resources. Based on the
    pod''s setting, Kubernetes classifies each pod as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Guaranteed pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burstable pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BestEffort pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The priority is Guaranteed > Burstable > BestEffort. For example, if a BestEffort
    pod and a Guaranteed pod exist in the same Kubernetes node, and that node encounters
    CPU problems or runs out of memory, the Kubernetes master terminates the BestEffort
    pod first. Let's take a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to set a Resource QoS: pod configuration or namespace configuration.
    If you set a Resource QoS to the Namespace, it will apply to all pods that belong
    to the same Namespace. If you set a Resource QoS to a pod, it will apply to the
    pod only. In addition, if you set it to both namespace and pod, it takes a value
    from the namespace configuration first, and then overwrite it with the pod configuration.
    Thus, we will set up two Namespaces, one which has a Resource QoS, and one that
    does not, to see how different they are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two namespaces by using the `kubectl` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a YAML file that sets `spec.limits.defaultRequest.cpu: 0.1` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Do this by typing the `kubectl` command so that it applies to the `chap8-qos`
    namespace only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the resource limit on both `chap8-qos` and `chap8-no-qos` with the `kubectl`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's configure a BestEffort pod, a Guaranteed pod, and then a Burstable pod
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a BestEffort pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BestEffort pod has the lowest priority in the Resource QoS classes. Therefore,
    in the case of a resource shortage, this BestEffort pod will be terminated by
    the Kubernetes scheduler, then will yield CPU and memory resources to other, higher
    priority pods.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure a pod as a BestEffort, you need to set the resource limit
    as `0` (explicit), or specify no resource limit (implicit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare a pod configuration that explicitly sets the `spec.containers.resources.limits`
    as `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod on both the `chap8-qos` and `chap8-no-qos` namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `QoS` class; both pods have the `BestEffort` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a pitfall :  if you don''t set any resource settings in the pod configuration,
    the pod takes a value from the namespace''s default settings. Therefore, if you
    create a pod with no resource settings, the result will be different between `chap8-qos`
    and `chap8-no-qos`. The following example demonstrates how the namespace settings
    affect the result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the preceding pods from the `chap8-qos` and `chap8-no-qos` namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a pod configuration that doesn''t have resource settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod on both namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `QoS` class is different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `chap8-qos` namespace has the default setting `request.cpu: 0.1`,
    it causes the pod to configure with the `Burstable` class. Therefore, we will
    use the `chap8-no-qos` namespace, which avoids this unexpected result.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Guaranteed pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Guaranteed class has the highest priority of resource `QoS` classes. In
    the case of a resource shortage, the Kubernetes scheduler will try to retain the
    Guaranteed pod to the last.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure a pod to have the `guaranteed` class, explicitly set
    the resource limit and resource request as the same value, or only set the resource
    limit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare a pod configuration that has the same value for `resources.limit` and
    `resources.request`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod on the `chap8-no-qos` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `QoS class`; it has the `Guaranteed` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a Burstable pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Burstable pod has a priority that is higher than BestEffort but lower than
    Guaranteed. In order to configure a pod to be a Burstable Pod, you need to set `resources.request`. `resources.limit` is
    optional, but the value of `resources.request` and `resources.limit` must not
    be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare a pod configuration that has `resources.request` only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the `QoS` class; it is `Burstable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how resource requests/limits affect resource management. A preceding
    burstable YAML configuration declares both requests and limits by a different
    threshold as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of resource definition** | **Resource name** | **Value** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **requests** | CPU | 0.1 | At least 10% of 1CPU core |'
  prefs: []
  type: TYPE_TB
- en: '| Memory | 10Mi | At least 10 Mbytes of memory |'
  prefs: []
  type: TYPE_TB
- en: '| **limits** | CPU | 0.5 | Maximum 50% of 1 CPU core |'
  prefs: []
  type: TYPE_TB
- en: '| Memory | 300Mi | Maximum 300 Mbytes of memory |'
  prefs: []
  type: TYPE_TB
- en: 'For the CPU resources, acceptable value expressions are either cores (0.1,
    0.2 ... 1.0, 2.0) or millicpu (100 m, 200 m ... 1000 m, 2000 m). 1000 m is equivalent
    to 1.0 core. For example, if a Kubernetes node has 2 cores CPU (or 1 core with
    hyperthreading), there are a total of 2.0 cores or 2000 millicpu, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ce2f36e-be54-4b02-8fa7-48e38ba68343.png)Representing a 2.0 CPU
    resource'
  prefs: []
  type: TYPE_NORMAL
- en: 'By typing `kubectl describe node <node name>`, you can check what resources
    are available on the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the node `minikube` , which has 2.0 CPU and approximately 1,945
    MB memory. If you run the nginx example (`requests.cpu: 0.1`), it occupies at
    least 0.1 core, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6dbfa34c-d9ef-4cd8-9d73-4026023fd281.png)Requesting a 0.1 CPU resource'
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the CPU has enough spaces, it may occupy up to 0.5 cores (`limits.cpu:
    0.5`), as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e4e58894-3e05-489c-903f-ebac4cb546de.png)It can occupy up to 0.5
    CPU resources'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you set `requests.cpu` to be more than 2.0, the pod won't be assigned
    to this node, because the allocatable CPU is 2.0 and the nginx pod already occupies
    at least 0.1 CPU.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you learned how to configure Resource QoS by setting a resource
    request and limit. The Namespace's default value affects the resulting pod configuration,
    so you should explicitly specify resource requests and limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please revisit the following chapter to recap how to configure namespaces as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),* Walking
    through Kubernetes Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with WebUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has a WebUI that visualizes the status of resources and machines,
    and also works as an additional interface for managing your application without
    command lines. In this recipe, we are going to introduce Kubernetes dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes dashboard ([https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard))
    is like a server-side application. In the beginning, just make sure you have a
    healthy Kubernetes cluster running, and we will go through the installation and
    related setup in the coming pages. Since the dashboard will be accessed by the
    browser, we can use a minikube-booted, laptop-running Kubernetes system, and reduce
    procedures for forwarding network ports or setting firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Kubernetes systems booting up by minikube, check that both minikube and
    the system itself are working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While booting up your Kubernetes system with minikube, it would help to create
    the dashboard by default. So, we will talk about both scenarios separately.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on the dashboard created by minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because the Kubernetes dashboard has been started, what we have do is to open
    the web UI with a specific URL. It is convenient; you just need to fire a command
    on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, you will see your favourite browser opening a new webpage, as we introduced
    in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own
    Kubernetes Cluster*. Its URL will look like [http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default](http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default).
    Most of all, we bypass the expected network proxy and authentication procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dashboard manually on a system using other booting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run Kubernetes dashboard, we simply fire a command to apply a configuration
    file, and every resource is created automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s use the command `kubectl proxy` to open a gateway connecting localhost
    and the API server. Then, we are good to access the dashboard via a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you see a halting result showing, as in the preceding code, you can now
    access the dashboard by URL: [http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/).
    There, you will see the following screen in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b64d4fc-7349-4385-bf46-7877f2e3fc06.png)The login portal of Kubernetes
    dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'To step into our demonstration quickly, we will take the token of an existed
    service account to log in with. No matter what booting tool you use, leveraging
    the one created by the dashboard is suitable in every case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the token and paste it into console on the browser, then, click SIGN IN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe682158-1db8-4f8a-8f62-041683a327a0.png)Authentication with the
    token of a service account'
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcome to the dashboard home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9319f189-19d4-40e2-a573-e10dd4ec8e91.png)The home page of the Kubernetes
    dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes dashboard has two main functions: inspecting the status of resources,
    and deploying resources. It can cover most of our works in the client terminal
    using the command `kubectl`, however, the graphic interface is more friendly.'
  prefs: []
  type: TYPE_NORMAL
- en: Browsing your resource by dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can check both hardware and software resources on the dashboard. For example,
    to take a look at the nodes a cluster, click on **Nodes** under the **Cluster**
    section in the left-hand menu; every node in the current cluster will be shown
    on the page, with some basic information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d2d70c8-65d3-4df0-aebb-133b8dda5fb4.png)The status of Kubernetes
    nodes on the dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your result on screen may be different from the preceding screenshot, since
    it will be based on your environment. Go ahead and click on the name of one node;
    even more details will be shown. Some of them are illustrated in beautiful graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b21650a8-65fe-4a70-91b4-40202faef84a.png)Computing the resource
    status of a node'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show software resources, let''s take a look at the one holding this dashboard.
    In the left-hand menu, change the Namespace to kube-system and click Overview,
    which gathers all the resources under this Namespace. It is easy to find out any
    issue by putting resources together on a single page with a clear diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11aa609b-d4d3-4783-87b8-57b89b183d4c.png)Resource overview of the
    namespace kube-system'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s more; click on the Deployments kubernetes-dashboard, and then click
    the small text-file icon on the right side of the only pod in the replica set.
    You can see the logs for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7a0b7ba5-205e-4995-b015-6208a8201d26.png)Deployment information
    of kubernetes-dashboard![](assets/19522040-4c1e-4172-8d41-472b089eb917.png) Logs
    of the dashboard application'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have seen that Kubernetes dashboard provides a brilliant interface for
    displaying resource status, covering nodes, Kubernetes workloads and controllers,
    and the application log.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying resources by dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will prepare a YAML configuration file for creating Kubernetes Deployments
    and related Services under a new Namespace. It will be used to build resources
    through the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, click the CREATE button on the top right side of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods for deployment. Let''s choose the second one and upload
    the configuration file introduced previously. Click the UPLOAD button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68c65a6f-4f65-4b33-938f-092e0f640ffb.png)Creating a resource by
    configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, errors happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e78630f7-bc05-4fae-a611-b9fe02e43992.png)Error message for problems
    due to bad deployment'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard displays the resource according to a given Namespace, which is picked
    by *user* on the left-hand menu. This error message popped up and told users that
    the Namespace mentioned in the file does not match to dashboard one. What we have
    to do is to create a new Namespace and switch to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we are going to create a Namespace using plain text. Click the CREATE button
    again, and pick the create from text input method. Paste the following lines for
    a new Namespace to the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a new Namespace, `dashboard-test`. Choose it as the main Namespace
    on the dashboard, and submit the `my-nginx.yaml` file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f458157c-6ead-44c7-b3e5-deaaf4022df2.png)Picking a correct Namespace
    before submitting the configuration file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can see the overview of this deployment! Yellow circles mean the pending
    status. They will turn to green once the pods are ready, or turn to red if they
    failed, but you will not see red ones if you are following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68af09be-08da-4a67-a923-44a844f8d51b.png)Status graph of creating
    a resource'
  prefs: []
  type: TYPE_NORMAL
- en: Removing resources by dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also remove Kubernetes resources through the dashboard. Try to find
    the Service `my-nginx` we just created by yourself! Perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the Namespace on the left-hand menu to dashboard-test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Services under the Discovery and load balancing section on left-hand menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the Service my-nginx on the hyperlinked name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click DELETE at the top right of the page, below the CREATE button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it! Once you see your screen launching a message for confirmation, just
    click it. Finally, you have not only created a resource but also removed it from
    the Kubernetes dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe described how to launch a web interface that will help with easily
    exploring and managing Kubernetes instances, such as pods, deployments, and services,
    without the `kubectl` command. Please refer to the following recipes on how to
    get detailed information via the `kubectl` command.
  prefs: []
  type: TYPE_NORMAL
- en: The *Working with Pods*, *Deployment API*, and *Working with Services* recipes
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users can control Kubernetes clusters via the `kubectl` command; it supports
    local and remote execution. However, some administrators or operators may need
    to integrate a program to control the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has a RESTful API that controls Kubernetes clusters via an API, similar
    to the `kubectl` command. Let's learn how to manage Kubernetes resources by submitting
    API requests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, to bypass additional network settings and having to verify
    permissions, we will demonstrate the a *minikube-*created cluster with a Kubernetes
    proxy: it is easy to create a Kubernetes cluster on the host, and enable local
    proximity to an API server with a proxy entry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run up a proxy for fast API request forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Having worked with Kubernetes proxy for a while, you may find it is somehow
    annoying that the command `kubectl proxy` is a halt process on your terminal,
    forcing you to open a new channel for the following commands. To avoid this, just
    add & as the last parameter in your command. This `&` symbol in the shell will
    make your command run in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that you should kill this process manually if you don''t use the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it is good to try the endpoint with a simple path, `/api`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once you see some basic API server information showing as in the preceding code,
    congratulations! You can now play with the kubernetes RESTful API of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '**A secured way to access the Kubernetes API server**'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you consider accessing a more secure API server, likes a kubeadm
    cluster, the following items should be taken care of:'
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint of the API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the required information through the following commands. And you
    can successfully fire the API request for the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you may see a message showing `permission denied` when accessing
    resources in kubeadm. If so, the solution is to bind the default service account
    to the role of administrator, that is `cluster-admin` in kubeadm system. We provide
    the configuration file `rbac.yaml` in the code bundle; please check it out if
    you need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Be careful of the  `--insecure` flags, since the endpoint using HTTPS protocol,
    and `-H`, add headers with a token. These are the additional ones comparing with
    our naive demonstration settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show you how to manage resources through the RESTful
    API. Generally, the command line pattern of `curl` will cover the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The operation**: `curl` without an indicating operation will fire `GET` by
    default. To specify your operation, add one with the `X` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The body data**: Like creating a Kubernetes resource through `kubectl`, we
    apply resource configuration with the `d` flag. The value with symbol `@` can
    attach a file. Additionally, the `h` flag helps to add request headers; here we
    need to add content type in the JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The URL**: There are various paths after the endpoint, based on different
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a deployment using the following JSON configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get every function in the API reference page ([https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/)).
    It is similar to searching for the configuration of a resource while writing up
    a configuration file. To submit an API request, you should know what kind of resource
    to work on, and what operation to perform on it. Perform the following procedures
    to find the corresponding information on the reference webpage:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an operation, for example, read or write.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the details of the operation, for example, Create or Delete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The information will show in the middle panel of the webpage. An optional step
    is to switch `kubectl` to `curl` on the top right of the console. More details
    such as command flags will show on the right panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check the information for creating a Deployment, your web console may look
    as it does in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27576170-067f-4473-ad48-66beacb359aa.png)The steps finding the path
    for API using to create a deployment'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the reference page, we can combine a specified `curl` command and
    fire a request now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For a successful request, the server returns the status of the resource. Go
    ahead and check if we can find the new Deployment through the `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it also works while checking it via the RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try to delete this new Deployment, `my-nginx`, as well. It is a kind
    of `write` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RESTful API allows CRUD (Create, Read, Update, and Delete) operations, which
    are the same concepts behind every modern web application. For more details, please
    refer to [https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete).
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the CRUD structure, the Kubernetes RESTful API has the following
    basic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **HTTP Method** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Create | `POST` | `POST /api/v1/namespaces/default/pods` |'
  prefs: []
  type: TYPE_TB
- en: '| Read | `GET` | `GET /api/v1/componentstatuses` |'
  prefs: []
  type: TYPE_TB
- en: '| Update | `PUT` | `PUT /apis/apps/v1/namespaces/default/deployments/my-nginx`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | `DELETE` | `DELETE /api/v1/namespaces/default/services/nginx-service`
    |'
  prefs: []
  type: TYPE_TB
- en: As we mentioned in the recipe *Working with configuration files* in [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*, Kubernetes
    builds the RESTful API with *swagger* ([https://swagger.io/](https://swagger.io))
    and OpenAPI ([https://www.openapis.org](https://www.openapis.org)). We can open
    the swagger UI console of your cluster to check the API functions. Nevertheless,
    it is recommended that you check them through the official website, the one we
    demonstrated in the last section. The description on the website is more elaborate
    and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An even more programmatic way to utilize Kubernetes API is to use the client
    library ([https://kubernetes.io/docs/reference/client-libraries/](https://kubernetes.io/docs/reference/client-libraries/)).
    Making good use of these client tools not only saves you time in resource management,
    but also produce a robust and reliable CI/CD environment. Here, we would like
    to introduce the Kubernetes client library for Python: [https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python).
    To start, you should install the Python library for Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, please put the following Python file at the same location as the JSON
    configuration file, `nginx-deployment.json`, where firing `kubectl` does work
    on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t even enable the Kubernetes proxy now; continue to run this script
    directly and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe described how to use the Kubernetes RESTful API via a program.
    It is important to integrate this with your automation program remotely. For detailed
    parameter and security enhancement, please refer to the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Working with configuration files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Authentication and authorization* recipe in [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Kubernetes DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you deploy many pods to a Kubernetes cluster, service discovery is one
    of the most important functions, because pods may depend on other pods but the
    IP address of a pod will be changed when it restarts. You need to have a flexible
    way to communicate a pod's IP address to other pods. Kubernetes has an add-on
    feature called `kube-dns` that helps in this scenario. It can register and look
    up an IP address for pods and Kubernetes Services.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore how to use `kube-dns`, which gives you a flexible
    way to configure DNS in your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Kubernetes version 1.3, `kube-dns` has come with Kubernetes and is enabled
    by default. To check whether `kube-dns` is working or not, check the `kube-system`
    namespace with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using minikube, type the following command to see the addon''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If it shows as disabled, you need to enable it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, prepare two namespaces, `chap8-domain1` and `chap8-domain2`, to
    demonstrate how `kube-dns` assigns domain names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kube-dns` assigns the **fully** **qualified domain name** (**FQDN**) to pods
    and Kubernetes Services. Let''s look at some differences.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS for pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes assigns the domain name for the pod as `<IP address>.<Namespace name>.pod.cluster.local`.
    Because it uses the pod's IP address, FQDN is not guaranteed to be present permanently,
    but it is nice to have in case an application needs FQDN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deploy apache2 (`httpd`) on `chap8-domain1` and `chap8-domain2`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `kubectl get pod -o wide` to capture an IP address for those pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `my-apache-55fb679f49-qw58f` on `chap8-domain1` uses `172.17.0.4`.
    On the other hand, `my-apache-55fb679f49-z9gsr` on `chap8-domain2` uses `172.17.0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the FQDN would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`172-17-0-4.chap8-domain1.pod.cluster.local` (`chap8-domain1`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172-17-0-5.chap8-domain2.pod.cluster.local` (`chap8-domain2`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the dots (`.`) in the IP address are changed to hyphens (`-`). This
    is because the dot is a delimiter to determine subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether name resolution works or not, launch the busybox pod in the
    foreground (using the `-it` option). Then use the `nslookup` command to resolve
    FQDN to the IP address, as in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `busybox` with the `-it` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the busybox pod, type `nslookup` to resolve the FQDN of apache on `chap8-domain1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, type `nslookup` to resolve the FQDN of apache on `chap8-domain`2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the busybox pod, then delete it to release a resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: DNS for Kubernetes Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, DNS for Kubernetes Service is most important from the service
    discovery point of view. This is because an application usually connects to Kubernetes
    Service instead of connecting to the pod. This is why the application looks up
    the DNS entry for Kubernetes Service more often than for the pod.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the DNS entry for Kubernetes Service will use the name of Kubernetes
    Service instead of an IP address. For instance, it will look like this: `<Service
    Name>.<Namespace name>.svc.cluster.local`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, Kubernetes Service has 2 different behaviors for DNS; either normal
    service or headless service. Normal service has its own IP address, while headless
    service uses the pod's IP address(es). Let's go through normal service first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal service is the default Kubernetes Service. It will assign an IP address.
    Perform the following steps to create a normal service and check how DNS works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a normal service for apache on `chap8-domain1` and `chap8-domain2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the IP address for those two services by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to perform name resolution, use the busybox pod in the foreground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the busybox pod, use the `nslookup` command to query the IP address of those
    two services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Access to service for apache whether traffic can dispatch to the backend apache
    pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Quit the `busybox` pod and delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: DNS for a normal service behaves as a proxy; traffic goes to the normal service,
    then dispatches to the pod. What about the headless service? This will be discussed
    in the *How it works...* section.
  prefs: []
  type: TYPE_NORMAL
- en: DNS for StatefulSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: StatefulSet was described in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*. It assigns a pod name with a sequence number—for example, `my-nginx-0`,
    `my-nginx-1`, `my-nginx-2`. StatefulSet also uses these pod names to assign a
    DNS entry instead of IP addresses. Because it uses Kubernetes Service, FQDN appear
    as follows: `<StatefulSet name>-<sequence number>.<Service name>.<Namespace name>.svc.cluster.local`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create StatefulSet to examine how DNS works in StatefulSet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare StatefulSet and normal service YAML configurations as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Create StatefulSet on `chap8-domain2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `kubectl` command to check the status of the pod and service creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the `busybox` pod in the foreground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `nslookup` command to query the service''s IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `nslookup` command to query the individual pod''s IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Clean up the `busybox` pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have set up several components to see how DNS entries are created initially.
    The Kubernetes Service name is especially important for determining the name of
    a DNS.
  prefs: []
  type: TYPE_NORMAL
- en: However, Kubernetes Service has 2 modes, either normal service or headless service.
    Normal service has already been described in the preceding section; it has its
    own IP address. On the other hand, headless service doesn't have an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to create a headless service and how name resolution works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a headless service (specify `--cluster-ip=None`) for apache on `chap8-domain1`
    and `chap8-domain2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Check there is no IP address for those two headless services with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the `busybox` pod in the foreground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `busybox` pod, query those two services. It must show the addresses
    as the pod''s address (`172.168.0.4` and `172.168.0.5`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the `busybox` pod and delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Headless service when pods scale out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example shows only one IP address, because we have been setup
    only one Pod. What happens if you increase an instance using the `kubectl scale`
    command?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s increase the Apache instances on `chap8-domain1` from 1 to 3, then see
    how the headless service DNS works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is straightforward: one DNS entry, `my-apache-svc-hl.chap8-domain1.svc.cluster.local` returns
    3 IP addresses. Therefore, when your HTTP client tries to access the Kubernetes
    Service `my-apache-svc-hl.chap8-domain1.svc.cluster.local`, it gets these 3 IP
    addresses from `kube-dns`, then accesses one of them directly, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f93148d8-eea0-4c05-bc39-49c50ef4edcf.png)Sequence of accessing to
    Headless Service and pod'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Kubernetes headless service doesn't do any traffic dispatches. This
    is why it is called headless.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section described how `kube-dns` names pods and services in DNS. It is
    important to understand the differences between normal service and headless service
    to understand how to connect to your application. The StatefulSet use case was
    also described in the following recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ensuring flexible usage of your containers* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are both crucial for a platform such as Kubernetes.
    Authentication ensures users are who they claim to be. Authorization verifies
    if users have sufficient permission to perform certain operations. Kubernetes
    supports various authentication and authorization plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a request comes to an API server, it firstly establishes a TLS connection
    by validating the clients' certificate with the **certificate authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it goes to the authentication stage. In Kubernetes, authentication modules are
    chain-based. We can use more than one authentication module. When the request
    comes, Kubernetes will try all the authenticators one by one until it succeeds.
    If the request fails on all authentication modules, it will be rejected as HTTP
    401 unauthorized. Otherwise, one of the authenticators verifies the user's identity,
    and the requests are authenticated. Then, the Kubernetes authorization modules
    come into play. They verify if the *user* has the permission to do the action
    that they requested using a set of policies. Authorization modules are checked
    one by one. Just like authentication modules, if all modules are failed, the request
    will be denied. If the user is eligible to make the request, the request will
    pass through the authentication and authorization modules and go into admission
    control modules. The request will be checked by various admission controllers
    one by one. If any admission controller fails the request, the request will be
    rejected immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34ebdbc5-c58c-44cb-af44-76c75ee70733.png)Requests passing through
    a Kubernetes API server'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kubernetes, there are two types of account; service accounts and user accounts.
    The major difference between them is that user accounts are not stored and managed
    in Kubernetes itself. They cannot be added through API calls. The following table
    is a simple comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Service account** | **User account** |'
  prefs: []
  type: TYPE_TB
- en: '| **Scope** | Namespaced | Global |'
  prefs: []
  type: TYPE_TB
- en: '| **Used by** | Processes | Normal user |'
  prefs: []
  type: TYPE_TB
- en: '| **Created by** | API server or via API calls | Administrators, can''t be
    added via API calls |'
  prefs: []
  type: TYPE_TB
- en: '| **Managed by** | API server | Outside the cluster |'
  prefs: []
  type: TYPE_TB
- en: 'Service accounts are used by processes inside a Pod to contact the API server.
    Kubernetes by default will create a service account named **default**. If there
    is no service account associated with a Pod, it''ll be assigned to the default
    service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We may find there is a Secret associated with this service account. This is
    controlled by the token controller manager. When a new service account is created,
    the controller will create a token and associate it with the service account with
    the `kubernetes.io/service-account.name` annotation, allowing API access. Token
    is in the Secret format in Kubernetes. Anybody with the Secret view permission
    can see the token. The following is an example of creating a service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several account authentication strategies supported in Kuberentes,
    from client certificates, bearer tokens, and static files to OpenID connect tokens.
    More than one option could be chosen and combined with others in authentication
    chains. In this recipe, we'll introduce how to use token, client certs, and OpenID
    connect token authenticators.
  prefs: []
  type: TYPE_NORMAL
- en: Service account token authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve created a service account in the previous section; now, let''s see how
    to use a service account token to do the authentication. We''ll have to retrieve
    the token first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the three items under the data are all base64-encoded. We can
    decode them easily with the `echo "encoded content" | base64 --decode` command
    in Linux. For example, we can decode encoded namespace content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same command we can get the bearer token and use it in a request.
    The API server expects a HTTP header of `Authorization: Bearer $TOKEN` along with
    the request. The following is an example of how to use the token to authenticate
    and make a request directly to the API server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we''ll have to get our decoded token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, we''ll have to decode `ca.crt` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to know what the API server is. Using the `kubectl config
    view` command, we can get a list of servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Find the one you're currently using. In this example, we're using minikube.
    The server is at `https://192.168.99.100:8443`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `kubectl config current-context` command to find the current
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Then we should be good to go! We'll request the API endpoint directly via `https://$APISERVER/api`
    with`--cacert` and `--header`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the available version is `v1`. Let''s see what we have in `/api/v1`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'It will list all the endpoints and verbs we requested. Let''s take `configmaps`
    as an example and `grep` the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four default configmaps listed in my cluster in this example. We
    can use `kubectl` to verify this. The result should match the ones we previously
    got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: X509 client certs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common authentication strategy for user accounts is to use client certificates.
    In the following example, we''ll create a user named Linda and generate a client
    cert for her:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll generate a cert for Linda via a private key and sign request files,
    along with the CA and private key of our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: In minikube, it's under `~/.minikube/`. For other self-hosted solutions, normally
    it's under `/etc/kubernetes/`. If you use `kops` to deploy the cluster, the location
    is under `/srv/kubernetes`, where you can find the path in the`/etc/kubernetes/manifests/kube-apiserver.manifest`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We got Linda signed by our cluster cert; now we can set it into our `kubeconfig`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `kubectl config view` to verify the user is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'After the user is created, we can create a context to associate the namespace
    and cluster with this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: After that, Kubernetes should be able to identify linda and pass it to the authorization
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID connect tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another popular authentication strategy is OpenID connect tokens. Delegating
    the identity verification to OAuth2 providers, is a convenient way to manage users.
    To enable the feature, two required flags have to be set to the API server: `--oidc-issuer-url`,
    which indicates the issuer URL that allows the API server to discover public signing
    keys, and `--oidc-client-id`, which is the client ID of your app to associate
    with your issuer. For full information, please refer to the official documentation
    [https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server](https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server).
    The following is an example of how we set Google OpenID authentication with our
    minikube cluster. The following steps can be programmed easily for authentication
    usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll have to request a set consisting of the client ID, client
    secret, and redirect URL from Google. The following are the steps for requesting
    and downloading the secret from Google:'
  prefs: []
  type: TYPE_NORMAL
- en: In GCP console, go to APIs & Services | Credentials | Create credentials | OAuth
    client ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Other in application type and click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the JSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, the credential is successfully created. We can take a look at the
    JSON file. The following is the file we got from our example project kubernetes-cookbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to start our cluster. Don''t forget the OIDC flags have
    to be passed on. In minikube, this is done via the `--extra-config` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'After the cluster is started, the user has to log in to the identity provider
    in order to get `access_token`*,* `id_token`*,* and `refresh_token`. In Google, you''ll
    get a code after login, and you pass the code with the request to get the tokens.
    Then we pass the token to the request to the API server via kubectl. The following
    is the sequence diagram for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d0012bfc-9d77-400a-9ba7-1ff5acc5f21c.png)Time diagram of Google
    OpenID connect authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'To request the code, your app should send the HTTP request in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a browser window will pop out to ask for sign in to Google. After signing
    in, the code will be shown in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7a66cd3-ece7-4f59-b157-7f5c33543105.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we pass the code for requesting the token to `https://www.googleapis.com/oauth2/v4/token`.
    Then, we should be able to get `access_token`, `refresh_token`, and `id_token`
    from the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we''ll have the user `chloe-k8scookbook@gmail.com` to associate with
    this Google account. Let''s create it in our cluster. We can append user information
    into our kubeconfig. The default location of the file is `$HOME/.kube/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let''s use the user to list nodes and see if it can pass the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We encounter an authorization error! After verifying the identity, the next
    step will be checking if the user has sufficient rights to perform the request.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After passing the authentication phase, authorizers take place. Before we move
    on to authorization strategies, let's talk about `Role` and `RoleBinding` first.
  prefs: []
  type: TYPE_NORMAL
- en: Role and RoleBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Role` in Kubernetes contains a set of rules. A rule defines a set of permissions
    for certain operations and resources by specifying `apiGroups`, `resources`, and
    `verbs`. For example, the following role defines a read-only rule for `configmaps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'A `RoleBinding` is used to associate a role with a list of accounts. The following
    example shows we assign the `configmap-ro` role to a list of subjects. It only
    has the user `linda` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`Role` and `RoleBinding` are namespaced. Their scope is only within a single
    namespace. For accessing `cluster-wide` resources, we''ll need `ClusterRole` and
    `ClusterRoleBinding`.'
  prefs: []
  type: TYPE_NORMAL
- en: For adding namespace into `Role` or `RoleBinding`, simply add a namespace field
    into the metadata in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRole and ClusterRoleBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ClusterRole` and `ClusterRoleBinding` are basically similar to `Role` and
    `RoleBinding`. Unlike how `Role` and `RoleBinding` are scoped into a single namespace,
    `ClusterRole` and `ClusterRoleBinding` are used to grant cluster-wide resources.
    Therefore, access to resources across all namespaces, non-namespaced resources,
    and non-resource endpoints can be granted to `ClusterRole`, and we can use `ClusterRoleBinding`
    to bind the users and the role.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also bind a service account with `ClusterRole`. As a service account
    is namespaced, we''ll have to specify its full name, which includes the namespace
    it''s created in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of `ClusterRole` and `ClusterRoleBinding`. In this
    role, we grant all operations for lots of resources, such as `deployments`, `replicasets`,
    `ingresses`, `pods`, and `services` to it, and we limit the permission to read-only
    for namespaces and events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Note [`""`] in `apiGroup`; this indicates the core group in Kubernetes. To
    see the full list of resources and verbs, check out the Kubernetes API reference
    site: [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we create a `cd-role`, which is the role for performing continuous
    deployment. Also, we create a `ClusterRoleBinding` to associate the service account
    `chapter8-serviceaccount` with `cd-role`.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of role-based access control is surrounded by `Role`, `ClusterRole`,
    `RoleBinding`, and `ClusterRoleBinding`. By `role.yaml` and `rolebinding.yaml`,
    as we showed previously, Linda should get read-only access to the `configmaps`
    resource. To apply authorization rules to `chloe-k8scookbook@gmail.com`, simply
    associate a `ClusterRole` and `ClusteRoleBinding` with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should be able to see if we can get nodes with the `chloe-k8scookbook@gmail.com`
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: It works like a charm. We didn't encounter the Forbidden error anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Before RBAC, Kubernetes provided **Attribute-based access control** (**ABAC**),
    which allows a cluster administrator to define a set of user authorization polices
    into a file with one JSON per line format. However, the file has to exist when
    launching the API server, which makes it unusable in the real world. After RBAC
    was introduced in Kubernetes 1.6, ABAC became legacy and was deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Admission control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admission control modules come into play after Kubernetes verifies who makes
    requests and whether the requester has sufficient permission to perform them.
    Unlike authentication and authorization, admission control can see the content
    of the request, or even have the ability to validate or mutate it. If the request
    doesn't pass through one of admission controllers, the request will be rejected
    immediately. For turning on admission controllers in Kubernetes, simply pass `--admission-control
    (version < 1.10) --enable-admission-plugins (version >= 1.10)` parameters when
    starting the API server.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you provision your cluster, the method for passing on the `--enable-admission-plugin`
    parameter may vary. In minikube, adding `--extra-config=apiserver.Admission.PluginNames=
    $ADMISSION_CONTROLLERS` and separate controllers with commas should do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different admission controllers are designed for different purposes. In the
    following recipe, we''ll introduce some important admission controllers and those
    that Kubernetes officially recommends that users have. The recommended list for
    version >= 1.6.0 is as follows: `NamespaceLifecycle`, `LimitRanger`, `ServiceAccount`,
    `PersistentVolumeLabel`, `DefaultStorageClass`, `DefaultTolerationSeconds`, `ResourceQuota`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the sequence of admission controllers matters since the requests
    pass one by one in sequence (this is true for versions before 1.10, using the `--admission-control`
    option; in v1.10, the parameter is replaced by `--enable-admission-plugins` and
    the sequence no longer matters). We don't want to have `ResourceQuota` checking
    first and finding out that the resource information is outdated after checking
    the long chain of admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: If the version is >= 1.9.0, `MutatingAdmissionWebhook` and `ValidatingAdmissionWebhook`
    will be added before `ResourceQuota`. For more information about `MutatingAdmissionWebhook`
    and `ValidatingAdmissionWebhook`, please refer to the *There's more* section in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: NamespaceLifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a namespace is deleted, all objects in that namespace will be evicted as
    well. This plugin ensures no new object creation requests can be made in a namespace
    that is terminating or non-existent. It also saves Kubernetes native Namespaces
    from deletion.
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures `LimitRange` can work properly. With `LimitRange`, we can
    set default requests and limits in a namespace, be used when launching a pod without
    specifying the requests and limits.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ServiceAccount plugin must be added if you intend to leverage ServiceAccount
    objects in your use cases. For more information about ServiceAccount, revisit
    ServiceAccount as we learned it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumeLabel (deprecated from v1.8)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PersistentVolumeLabel` adds labels to newly-created PV''s, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated from 1.8\. The function of this controller is now taken care of by
    cloud controller manager, which defines cloud-specific control logic and runs
    as a daemon.'
  prefs: []
  type: TYPE_NORMAL
- en: DefaultStorageClass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin ensures default storage classes can work as expected if no `StorageClass`
    is set in a `PersistentVolumeClaim`. Different provisioning tools with different
    cloud providers will leverage `DefaultStorageClass` (such as GKE, which uses Google
    Cloud Persistent Disk). Ensure you have this enabled.
  prefs: []
  type: TYPE_NORMAL
- en: DefaultTolerationSeconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taints and tolerations are used to prevent a set of pods from scheduling running
    on some nodes. Taints are applied to nodes, while tolerations are specified for
    pods. The value of taints could be `NoSchedule` or `NoExecute`. If pods running
    one tainted node have no matching toleration, the pods will be evicted.
  prefs: []
  type: TYPE_NORMAL
- en: The `DefaultTolerationSeconds` plugin is used to set those pods without any
    toleration set. It will then apply for the default toleration for the taints `notready:NoExecute`
    and unreachable:NoExecute for 300 s. If a node is not ready or unreachable, wait
    for 300 seconds before the pod is evicted from the node.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceQuota
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like `LimitRange`, if you're using the `ResourceQuota` object to administer
    different levels of QoS, this plugin must be enabled. The `ResourceQuota` should
    be always be put at the end of the admission control plugin list. As we mentioned
    in the `ResourceQuota` section, if the used quota is less than the hard quota,
    resource quota usage will be updated to ensure that clusters have sufficient resources
    to accept requests. Putting it into the end of ServiceAccount admission controller
    list could prevent the request from increasing quota usage prematurely if it eventually
    gets rejected by the following controllers.
  prefs: []
  type: TYPE_NORMAL
- en: DenyEscalatingExec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin denies any kubectl exec and kubectl attach command escalated privilege
    mode. Pods with privilege mode have access to the host namespace, which could
    become a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysPullImages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pull policy defines the behavior when kubelet is pulling images. The default
    pull policy is `IfNotPresent`; that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become Always,
    which is, always pull the latest image. This plugin also provides another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image whether the image exists locally or not. Then we
    can ensure pod creation requests always go through an authorization check against
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of admission controllers, visit the official site ([https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Kubernetes 1.7, admission controllers needed to compile with the API
    server, and configure before the API server starts. **Dynamic admission control**
    is designed to break these limitations. As two major components in dynamic admission
    control are both not GA at the moment we wrote this book, excepting adding them
    into the admission control chain, additional runtime configuration is required
    in the API server: `--runtime-config=admissionregistration.k8s.io/v1alpha1`.'
  prefs: []
  type: TYPE_NORMAL
- en: In minikube, ServiceAccount runtime config is set to `api/all`, so it's enabled
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Initializers (alpha)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initializers are a set of tasks during the object initialization stage. They
    could be a set of checks or mutations to perform force policies or inject defaults.
    For example, you could implement an initializer to inject a sidecar container
    or a volume containing test data to a pod. Initializers are configured in `metadata.initializers.pending`
    for an object. After the corresponding initializer controller (identified by name)
    performs the task, it'll remove its name from the metadata. If for some reasonsone
    initializer doesn't work well, all the objects with that initializer will be stuck
    in ServiceAccount uninitialized stage, and not visible in the API. Use it with
    caution.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook admission controllers (beta in v1.9)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of webhook admission controller as of v1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ValidatingAdmissionWebhook`: It can do extra customized validation to reject
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MutatingAdmissionWebhooks`: It can mutate the object to force default policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more implementation information, please refer to the official documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/admin/extensible-admission-controllers/](https://kubernetes.io/docs/admin/extensible-admission-controllers/)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes are of relevance to this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting up continuous delivery pipelines* in [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced settings in kubeconfig* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working with ServiceAccount RESTful API* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*,
    Advanced Cluster Administration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

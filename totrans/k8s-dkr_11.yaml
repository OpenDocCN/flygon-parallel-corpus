- en: '*Chapter 8*: RBAC Policies and Auditing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is only the first step in managing access in a cluster. Once
    access to a cluster is granted, it's important to limit what accounts can do,
    depending on whether an account is for an automated system or a user. Authorizing
    access to resources is an important part of both protecting against accidental
    issues and bad actors looking to abuse a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to detail how Kubernetes authorizes access via
    its **Role-Based Access Control** (**RBAC**) model. The first part of this chapter
    will be a deep dive into how Kubernetes RBAC is configured, what options are available,
    and mapping the theory into practical examples. Debugging and troubleshooting
    RBAC policies will be the focus of the second half.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to RBAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace multi-tenancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **audit2rbac** to debug policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: A KinD cluster running with the configuration from [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203),
    *Integrating Authentication into Your Cluster*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the SAML2 lab from [*Chapter 6*](B15514_06_Final_ASB_ePub.xhtml#_idTextAnchor174),
    *Services, Load Balancing, and External DNS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into RBAC, let's take a quick look at the history of Kubernetes
    and access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Before Kubernetes 1.6, access controls were based on **Attribute-Based Access
    Control** (**ABAC**). As the name implies, ABAC provides access by comparing a
    rule against attributes, rather than roles. The assigned attributes can be assigned
    any type of data, including user attributes, objects, environments, locations,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, to configure a Kubernetes cluster for ABAC, you had to set two
    values on the API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**--authorization-policy-file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--authorization-mode=ABAC**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**authorization-policy-file** is a local file on the API server. Since it''s
    a local file on each API server, any changes to the file require privileged access
    to the host and will require you to restart the API server. As you can imagine,
    the process to update ABAC policies becomes difficult and any immediate changes
    will require a short outage as the API servers are restarted.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting in Kubernetes 1.6, **RBAC** became the preferred method of authorizing
    access to resources. Unlike **ABAC**, **RBAC** uses Kubernetes native objects,
    and updates are reflected without restarts to the API servers. **RBAC** is also
    compatible with different authentication methods. From here, our focus will be
    on how to develop RBAC policies and applying them to your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: What's a Role?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kubernetes, a Role is a way to tie together permissions into an object that
    can be described and configured. Roles have rules, which are a collection of resources
    and verbs. Working backward, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbs**: The actions that can be taken on an API, such as reading (**get**),
    writing (**create**, **update**, **patch**, and **delete**), or listing and watching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: Names of APIs to apply the verbs to, such as **services**, **endpoints**,
    and so on. Specific sub-resources may be listed as well. Specific resources can
    be named to provide very specific permissions on an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Role does not say who can perform the verbs on the resources—that is handled
    by **RoleBindings** and **ClusterRoleBindings**. We will learn more about these
    in the *RoleBindings and ClusterRoleBindings* section.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The term "role" can have multiple meanings, and RBAC is often used in other
    contexts. In the enterprise world, the term "role" is often associated with a
    business role and used to convey entitlements to that role instead of a specific
    person. As an example, an enterprise may assign all accounts' payable staff the
    ability to issue checks instead of creating a specific assignment for each member
    of the accounts' payable department the specific permission in order to issue
    a check. When someone moves between roles, they lose the permissions from their
    old role and gain permisions for their new role. In the instance of moving from
    accounts payable to accounts receivable the user would lose the ability to make
    payments and gain the ability to accept payment. By tying the permisions to roles,
    instead of individuals, the change in permissions happens automatically with the
    role change instead of having to manually toggle permissions for each user. This
    is the more "classic" use of the term RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each resource that a rule will be built of is identified by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**apiGroups**: A list of groups the resources are a member of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resources**: The name of the object type for the resource (and potentially
    sub-resources)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resourceNames**: An optional list of specific objects to apply this rule
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each rule *must* have a list of **apiGroups** and **resources**. **resourceNames**
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself authorizing access to specific objects in a namespace from
    within that namespace, it's time to rethink your authorization strategy. Kubernetes'
    tenant boundary is the namespace. Except for very specific reasons, naming specific
    Kubernetes objects in an RBAC Role is an anti-pattern and should be avoided. When
    specific objects are being named by RBAC Roles, consider breaking up the namespace
    they're in to create separate namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Once the resource is identified in a rule, verbs can be specified. A verb is
    an action that can be taken on the resource, providing access to the object in
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: If the desired access to an object should be **all**, you do not need to add
    each verb; instead, the wildcard character may be used to identify all the **verbs**,
    **resources**, or **apiGroups**.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a Role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kubernetes authorization page ([https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/))
    uses the following Role as an example to allow someone to get the details of a
    pod and its logs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Role'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroups: [""]'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: ["pods", "pods/log"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs: ["get", "list"]'
  prefs: []
  type: TYPE_NORMAL
- en: Working backward to determine how this Role was defined, we will start with
    **resources**, since it is the easiest aspect to find. All objects in Kubernetes
    are represented by URLs. If you want to pull all the information about the pods
    in the default namespace, you would call the **/api/v1/namespaces/default/pods**
    URL, and if you wanted the logs for a specific pod, you would call the **/api/v1/namespaces/default/pods/mypod/log**
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The URL pattern will be true of all namespace-scoped objects. **pods** lines
    up to **resources**, as does **pods/log**. When trying to identify which resources
    you want to authorize, use the **api-reference** document from the Kubernetes
    API documentation at [https://kubernetes.io/docs/reference/#api-reference](https://kubernetes.io/docs/reference/#api-reference).
  prefs: []
  type: TYPE_NORMAL
- en: If you are trying to access an additional path component after the name of the
    object (such as with status and logs on pods), it needs to be explicitly authorized.
    Authorizing pods does not immediately authorize logs or status.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the use of URL mapping to **resources**, your next thought may be that
    **verbs** is going to be HTTP verbs. This is not the case. There is no **GET**
    verb in Kubernetes. Verbs are instead defined by the schema of the object in the
    API server. The good news is that there's a static mapping between HTTP verbs
    and RBAC verbs (https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb).
    Looking at this URL, notice that there are verbs on top of the HTTP verbs for
    **PodSecurityPolicies** and impersonation. That's because the **RBAC** model is
    used beyond authorizing specific APIs and is also used to authorize who can impersonate
    users and how to assign a **PodSecurityPolicy** object. The focus of this chapter
    is going to be on the standard HTTP verb mappings.
  prefs: []
  type: TYPE_NORMAL
- en: The final component to identify is **apiGroups**. This is an additional area
    of inconsistency from the URL model. **pods** is part of the "core" group, but
    the **apiGroups** list is just an empty string (**""**). These are legacy APIs
    that were part of the original Kubernetes. Most other APIs will be in an API group
    and that group will be part of their URL. You can find the group by looking at
    the API documentation for the object you are looking to authorize.
  prefs: []
  type: TYPE_NORMAL
- en: The inconsistencies in the RBAC model can make debugging difficult, to say the
    least. The last lab in this chapter will walk through the debugging process and
    take much of the guesswork out of defining your rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've defined the contents of a Role and how to define specific permissions,
    it's important to note that Roles can be applied at both the namespace and cluster
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Roles versus ClusterRoles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RBAC rules can be scoped either to specific namespaces or to the entire cluster.
    Taking our preceding example, if we defined it as a ClusterRole instead of a Role,
    and removed the namespace, we would have a Role that authorizes someone to get
    the details and logs of all pods across the cluster. This new role could alternatively
    be used in individual namespaces to assign the permissions to the pods in a specific
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroups: [""]'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: ["pods", "pods/log"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs: ["get", "list"]'
  prefs: []
  type: TYPE_NORMAL
- en: Whether this permission is applied globally across a cluster or within the scope
    of a specific namespace depends on how it's bound to the subjects it applies to.
    This will be covered in the *RoleBindings and ClusterRoleBindings* section.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to applying a set of rules across the cluster, ClusterRoles are
    used to apply rules to resources that aren't mapped to a namespace, such as PersistentVolume
    and StorageClass objects.
  prefs: []
  type: TYPE_NORMAL
- en: After understanding how a Role is defined, let's understand the different ways
    Roles can be designed for specific purposes. In the next sections, we'll look
    at different patterns for defining Roles and their application in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common requests for authorization is "*can I write a Role that
    lets me do everything EXCEPT xyz*?". In RBAC, the answer is *NO*. RBAC requires
    either every resource to be allowed or specific resources and verbs to be enumerated.
    There are two reasons for this in RBAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better security through simplicity**: Being able to enforce a rule that says
    *every Secret except this one* requires a much more complex evaluation engine
    than RBAC provides. The more complex an engine, the harder it is to test and validate,
    and the easier it is to break. A simpler engine is just simpler to code and keep
    secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unintended consequences**: Allowing someone to do everything *except* xyz
    leaves the door open for issues in unintended ways as the cluster grows and new
    capabilities are added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the first point, building an engine with this capability is difficult to
    build and maintain. It also makes the rules much harder to keep track of. To express
    this type of rule, you need to not only have authorization rules but also an order
    to those rules. For instance, to say *I want to allow everything except this Secret*,
    you would first need a rule that says *allow everything* and then a rule that
    says *deny this secret*. If you switch the rules to say *deny this secret* then
    *allow everything*, the first rule would be overridden. You could assign priorities
    to different rules, but that now makes it even more complex.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to implement this pattern, either by using a custom authorization
    webhook or by using a controller to dynamically generate RBAC **Role** objects.
    These should both be considered security anti-patterns and so won't be covered
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The second point deals with unintended consequences. It's becoming more popular
    to support the provisioning of infrastructure that isn't Kubernetes using the
    operator pattern, where a custom controller looks for new instances of a **CustomResourceDefinition**
    (**CRD**) to provision infrastructure such as databases. Amazon Web Services publishes
    an operator for this purpose ([https://github.com/aws/aws-controllers-k8s](https://github.com/aws/aws-controllers-k8s)).
    These operators run in their own namespaces with administrative credentials for
    their cloud looking for new instances of their objects to provision resources.
    If you have a security model that allows everything "except…", then once deployed,
    anyone in your cluster can provision cloud resources that have real costs and
    can create security holes. Enumerating your resources, from a security perspective,
    is an important part of knowing what is running and who has access.
  prefs: []
  type: TYPE_NORMAL
- en: The trend of Kubernetes clusters is to provide more control over infrastructure
    outside of the cluster via the custom resource API. You can provision anything
    from VMs to additional nodes, to any kind of API-driven cloud infrastructure.
    There are other tools you can use besides RBAC to mitigate the risk of someone
    creating a resource they shouldn't, but these should be secondary measures.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregated ClusterRoles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ClusterRoles can become confusing quickly and be difficult to maintain. It''s
    best to break them up into smaller ClusterRoles that can be combined as needed.
    Take the admin ClusterRole, which is designed to let someone do generally anything
    inside of a specific namespace. When we look at the admin ClusterRole, it enumerates
    just about every resource there is. You may think someone wrote this ClusterRole
    so that it would contain all those resources, but that would be really inefficient,
    and what happens as new resource types get added to Kubernetes? The admin ClusterRole
    is an aggregated ClusterRole. Take a look at the **ClusterRole**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: admin'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kubernetes.io/bootstrapping: rbac-defaults'
  prefs: []
  type: TYPE_NORMAL
- en: 'annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rbac.authorization.kubernetes.io/autoupdate: ''true'''
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: 'aggregationRule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'clusterRoleSelectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '- matchLabels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rbac.authorization.k8s.io/aggregate-to-admin: ''true'''
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is the **aggregationRule** section. This section tells Kubernetes to
    combine the rules for all ClusterRoles where the **rbac.authorization.k8s.io/aggregate-to-admin**
    label is true. When a new CRD is created, an admin is not able to create instances
    of that CRD without adding a new ClusterRole that includes this label. To allow
    namespace admin users to create an instance of the new **myapi**/**superwidget**
    objects, create a new **ClusterRole**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: aggregate-superwidget-admin'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: Add these permissions to the "admin" default role.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'rbac.authorization.k8s.io/aggregate-to-admin: "true"'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroups: ["myapi"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: ["superwidgets"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]'
  prefs: []
  type: TYPE_NORMAL
- en: The next time you look at the admin ClusterRole, it will include **myapi**/**superwidgets**.
    You can also reference this ClusterRole directly for more specific permissions.
  prefs: []
  type: TYPE_NORMAL
- en: RoleBindings and ClusterRoleBindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a permission is defined, it needs to be assigned to something to enable
    it. "Something" can be a user, a group, or a service account. These options are
    referred to as subjects. Just as with Roles and ClusterRoles, a RoleBinding binds
    a Role or ClusterRole to a specific namespace and a ClusterRoleBinding will apply
    a ClusterRole across the cluster. A binding can have many subjects but may only
    reference a single Role or ClusterRole. To assign the **pod-and-pod-logs-reader**
    Role created earlier in this chapter to a service account called **mysa** in the
    default namespace, a user named **podreader**, or anyone with the **podreaders**
    group, create a **RoleBinding**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: RoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: mysa'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: User'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreader'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreaders'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Role'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding **RoleBinding** lists three different subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ServiceAccount**: Any service account in the cluster can be authorized to
    a RoleBinding. The namespace must be included since a RoleBinding could authorize
    a service account in any namespace, not just the one the RoleBinding is defined
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: A user is asserted by the authentication process. Remember from [*Chapter
    7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203), *Integrating Authentication
    into Your Cluster*, that there are no objects in Kubernetes that represent users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: Just as with users, groups are asserted as part of the authentication
    process and have an object associated with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the Role we created earlier is referenced. In a similar fashion, to
    assign the same subjects the ability to read pods and their logs across the cluster,
    a ClusterRoleBinding can be created to reference the **cluster-pod-and-pod-logs-reader**
    ClusterRole created earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: mysa'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: User'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreader'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreaders'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: The **ClusterRoleBinding** is bound to the same subjects, but is instead bound
    to a ClusterRole instead of a namespace-bound Role. Now, instead of having the
    ability to read pod details and pod/logs in the default namespace, these users
    can read all pod details and pod/logs in all namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Combining ClusterRoles and RoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a use case where a log aggregator wants to pull logs from pods in multiple
    namespaces, but not all namespaces. A ClusterRoleBinding is too broad. While the
    Role could be recreated in each namespace, this is inefficient and a maintenance
    headache. Instead, define a ClusterRole but reference it from a RoleBinding in
    the applicable namespaces. This allows the reuse of permission definitions while
    still applying those permissions to specific namespaces. In general, note the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRole + ClusterRoleBinding = cluster-wide permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterRole + RoleBinding = namespace-specific permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply our ClusterRoleBinding in a specific namespace, create a Role, referencing
    the **ClusterRole** instead of a namespaced **Role** object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: RoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: ServiceAccount'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: mysa'
  prefs: []
  type: TYPE_NORMAL
- en: 'namespace: default'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: User'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreader'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: podreaders'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-pod-and-pod-logs-reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding **RoleBinding** lets us reuse the existing **ClusterRole**. This
    cuts down on the number of objects that need to be tracked in the cluster and
    makes it easier to update permissions cluster-wide if the ClusterRole permissions
    need to change.
  prefs: []
  type: TYPE_NORMAL
- en: Having built our permissions and defined how to assign them, next we'll look
    at how to map enterprise identities into cluster policies.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping enterprise identities to Kubernetes to authorize access to resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the benefits of centralizing authentication is leveraging the enterprise''s
    existing identities instead of having to create new credentials that users that
    interact with your clusters need to remember. It''s important to know how to map
    your policies to these centralized users. In [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203),
    *Integrating Authentication into Your Cluster*, you created a cluster and integrated
    it with either **Active Directory Federation Services** (**ADFS**) or Tremolo
    Security''s testing identity provider. To finish the integration, the following
    **ClusterRoleBinding** was created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: ou-cluster-admins'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: k8s-cluster-admins'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-admin'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: This binding allows all users that are members of the **k8s-cluster-admins**
    group to have full cluster access. At the time, the focus was on authentication,
    so there weren't many details provided as to why this binding was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to authorize our users directly? That way, we have control
    over who has access to our cluster. Our RBAC **ClusterRoleBinding** would look
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: ou-cluster-admins'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: User'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp#mlbiamext'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-admin'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: Using the same ClusterRole as before, this ClusterRoleBinding will assign the
    **cluster-admin** privileges only to my testing user.
  prefs: []
  type: TYPE_NORMAL
- en: The first issue to point out is that the user has the URL of our OpenID Connect
    issuer in front of the username. When OpenID Connect was first introduced, it
    was thought that Kubernetes would integrate with multiple identity providers and
    different types of identity providers, so the developers wanted you to be able
    to easily distinguish between users from different identity sources. For instance,
    **mlbiamext** in domain 1 is a different user then **mlbiamext** in domain 2\.
    To ensure that a user's identity doesn't collide with another user across identity
    providers, Kubernetes requires the identity provider's issuer to be prepended
    to your user. This rule doesn't apply if the username claim defined in your API
    server flags is mail. It also doesn't apply if you're using certificates or impersonation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the inconsistent implementation requirements, this approach can cause
    problems in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing your identity provider URL**: Today, you''re using an identity provider
    at one URL, but tomorrow you decide to move it. Now, you need to go through every
    ClusterRoleBinding and update them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audits**: You can''t query for all RoleBindings associated with a user. You
    need to instead enumerate every binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large bindings**: Depending on how many users you have, your bindings can
    get quite large and difficult to track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there are tools you can use to help manage these issues, it's much easier
    to associate your bindings with groups instead of individual users. You could
    use the **mail** attribute to avoid the URL prefix, but that is considered an
    anti-pattern and will result in equally difficult changes to your cluster if an
    email address changes for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we have learned how to define access policies and map
    those policies to enterprise users. Next, we need to determine how clusters will
    be divided into tenants.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing namespace multi-tenancy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clusters deployed for multiple stakeholders, or tenants, should be divided
    up by namespace. This is the boundary that was designed into Kubernetes from the
    very beginning. When deploying namespaces, there are generally two ClusterRoles
    that are assigned to users in the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '**admin**: This aggregated ClusterRole provides access to every verb and nearly
    every resource that ships with Kubernetes, making the admin user the ruler of
    their namespace. The exception to this is any namespace-scoped object that could
    affect the entire cluster, such as **ResourceQuotas**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**edit**: Similar to **admin**, but without the ability to create RBAC Roles
    or RoleBindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to note that the **admin** ClusterRole can't make changes to
    the namespace object by itself. Namespaces are cluster-wide resources, so they
    can only be assigned permissions via a ClusterRoleBinding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your strategy for multi-tenancy, the **admin** ClusterRole may
    not be appropriate. The ability to generate RBAC Role and RoleBinding objects
    means that a namespace admin may grant themselves the ability to change resource
    quotas or run elevated PodSecurityPolicy privileges. This is where RBAC tends
    to fall apart and needs some additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t grant access to Kubernetes**: Many cluster owners want to keep Kubernetes
    out of the hands of their users and limit their interaction to external CI/CD
    tools. This works well with microservices but begins to fall apart on multiple
    lines. First, more legacy applications being moved into Kubernetes means more
    legacy administrators needing to directly access their namespace. Second, if the
    Kubernetes team keeps users out of the clusters, they are now responsible. The
    people who own Kubernetes may not want to be the reason things aren''t happening
    the way application owners want them to and often, the application owners want
    to be able to control their own infrastructure to ensure they can handle any situation
    that impacts their own performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Treat access as privileged**: Most enterprises require a privileged user
    to access infrastructure. This is typically done using a privileged access model
    where an admin has a separate account that needs to be "checked out" in order
    to use it and is only authorized at certain times as approved by a "change board"
    or process. The use of these accounts is closely monitored. This is a good approach
    if you already have a system in place, especially one that integrates with your
    enterprise''s central authentication system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Give each tenant a cluster**: This model moves multi-tenancy from the cluster
    to the infrastructure layer. You haven''t eliminated the problem, only moved where
    it is addressed. This can lead to sprawl that becomes unmanageable and can skyrocket
    costs depending on how you are implementing Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admission controllers**: These augment RBAC by limiting which objects can
    be created. For instance, an admission controller can decide to block an RBAC
    policy from being created, even if RBAC explicitly allows it. This topic will
    be covered in [*Chapter 11*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272),
    *Extending Security Using Open Policy Agent*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to authorizing access to namespaces and resources, a multi-tenant
    solution needs to know how to provision tenants. This topic will be covered in
    the final chapter, [*Chapter 14*](B15514_14_Final_ASB_ePub.xhtml#_idTextAnchor337),
    *Provisioning a Platform*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a strategy for implementing authorization policies, we'll need
    a way to debug those policies as we create them and also to know when those policies
    are violated. Kubernetes provides an audit capability that will be the focus of
    the next section where we will add the audit log to our KinD cluster and debug
    the implementation of RBAC policies.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes audit log is where you track what is happening in your cluster
    from an API perspective. It's in JSON format, which makes reading it directly
    more difficult, but makes it much easier to parse using tools such as Elasticsearch.
    In [*Chapter 12*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295), *Pod Auditing
    Using Falco and EFK*, we will cover how to create a full logging system using
    the **Elasticsearch, Fluentd, and Kibana (EFK)** stack.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an audit policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A policy file is used to control what events are recorded and where to store
    the logs, which can be a standard log file or a webhook. We have included an example
    audit policy in the **chapter8** directory of the GitHub repository and we will
    apply it to the KinD cluster that we have been using throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: An audit policy is a collection of rules that tell the API server which API
    calls to log and how. When Kubernetes parses the policy file, all rules are applied
    in order and only the initial matching policy event will be applied. If you have
    more than one rule for a certain event, you may not receive the expected data
    in your log files. For this reason, you need to be careful that your events are
    created correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Policies use the **audit.k8s.io** API and the manifest kind of **Policy**.
    The following example shows the beginning of a policy file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: audit.k8s.io/v1beta1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Policy'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- level: Request'
  prefs: []
  type: TYPE_NORMAL
- en: 'userGroups: ["system:nodes"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs: ["update","patch"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- group: "" # core'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: ["nodes/status", "pods/status"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'omitStages:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "RequestReceived"'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While a policy file may look like a standard Kubernetes manifest, you do not
    apply it using **kubectl**. A policy file is used with the **--audit-policy-file**
    API flag on the API server(s). This will be explained in the *Enabling auditing
    on a cluster* section.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the rule and what it will log, we will go through each section
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section of the rule is **level**, which determines the type of information
    that will be logged for the event. There are four levels that can be assigned
    to events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – Kubernetes auditing levels'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15514_table_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 – Kubernetes auditing levels
  prefs: []
  type: TYPE_NORMAL
- en: The **userGroups**, **verbs**, and **resources** values tell the API server
    the object and action that will trigger the auditing event. In this example, only
    requests from **system:nodes** that attempt an action of **update** or **patch**
    on a **node/status** or **pod/status** on the **core** API will create an event.
  prefs: []
  type: TYPE_NORMAL
- en: '**omitStages** tells the API server to skip any logging events during a *stage*,
    which helps you to limit the amount of data that is logged. There are four stages
    that an API request goes through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.2 – Auditing stages'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15514_table_8.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.2 – Auditing stages
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have set the event to ignore the **RequestReceived** event,
    which tells the API server not to log any data for the incoming API request.
  prefs: []
  type: TYPE_NORMAL
- en: Every organization has its own auditing policy, and policy files can become
    long and complex. Don't be afraid to set up a policy that logs everything until
    you get a handle on the types of events that you can create. Logging everything
    is not a good practice since the log files become very large. Fine-tuning an audit
    policy is a skill that is learned over time and as you learn more about the API
    server, you will start to learn what events are most valuable to audit.
  prefs: []
  type: TYPE_NORMAL
- en: Policy files are just the start of enabling cluster auditing, and now that we
    have an understanding of the policy file, let's explain how to enable auditing
    on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling auditing on a cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling auditing is specific to each distribution of Kubernetes. In this section,
    we will enable the audit log in KinD to understand the low-level steps. As a quick
    refresher, the finished product of the last chapter was a KinD cluster with impersonation
    enabled (instead of directly integrating with OpenID Connect). The rest of the
    steps and examples in this chapter assume this cluster is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the steps in this section manually or you can execute the included
    script, **enable-auditing.sh**, in the **chapter8** directory of the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the example audit policy from the **chapter8** directory to the
    API server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: k8s@book:~/kind-oidc-ldap-master$ docker cp k8s-audit-policy.yaml cluster01-control-plane:/etc/kubernetes/audit/
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the directories to store the audit log and policy configuration
    on the API server. We will exec into the container since we need to modify the
    API server file in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: k8s@book:~/kind-oidc-ldap-master$ docker exec -ti cluster01-control-plane bash
  prefs: []
  type: TYPE_NORMAL
- en: root@cluster01-control-plane:/# mkdir /var/log/k8s
  prefs: []
  type: TYPE_NORMAL
- en: root@cluster01-control-plane:/# mkdir /etc/kubernetes/audit
  prefs: []
  type: TYPE_NORMAL
- en: root@cluster01-control-plane:/# exit
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have the audit policy on the API server and you can enable
    the API options to use the file.
  prefs: []
  type: TYPE_NORMAL
- en: On the API server, edit the **kubeadm** configuration file, **/etc/kubernetes/manifests/kube-apiserver.yaml**,
    which is the same file that we updated to enable OpenID Connect. To enable auditing,
    we need to add three values. It's important to note that many Kubernetes clusters
    may only require the file and the API options. We need the second and third steps
    since we are using a KinD cluster for our testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add command-line flags for the API server that enable the audit logs.
    Along with the policy file, we can add options to control the log file rotation,
    retention, and maximum size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- --tls-private-key-**file=/etc/kubernetes/pki/apiserver.key**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - --audit-log-path=/var/log/k8s/audit.log**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - --audit-log-maxage=1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - --audit-log-maxbackup=10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - --audit-log-maxsize=10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - --audit-policy-file=/etc/kubernetes/audit/k8s-audit-policy.yaml**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the option is pointing to the policy file that you copied over in
    the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the directories that store the policy configuration and the resulting
    logs to the **volumeMounts** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- mountPath: /usr/share/ca-certificates'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: usr-share-ca-certificates'
  prefs: []
  type: TYPE_NORMAL
- en: 'readOnly: true'
  prefs: []
  type: TYPE_NORMAL
- en: '**- mountPath: /var/log/k8s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      name: var-log-k8s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      readOnly: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    - mountPath: /etc/kubernetes/audit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      name: etc-kubernetes-audit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      readOnly: true**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the **hostPath** configurations to the **volumes** section so
    that Kubernetes knows where to mount the local paths to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- hostPath:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /usr/share/ca-certificates'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: DirectoryOrCreate'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: usr-share-ca-certificates'
  prefs: []
  type: TYPE_NORMAL
- en: '**  - hostPath:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      path: /var/log/k8s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      type: DirectoryOrCreate**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    name: var-log-k8s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  - hostPath:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      path: /etc/kubernetes/audit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**      type: DirectoryOrCreate**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    name: etc-kubernetes-audit**'
  prefs: []
  type: TYPE_NORMAL
- en: Save and exit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like all API option changes, you need to restart the API server for the changes
    to take effect; however, KinD will detect that the file has changed and restart
    the API server's pod automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit from the attached shell and check the pods in the **kube-system** namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k8s@book:~/kind-oidc-ldap-master$ kubectl get pods -n kube-system**'
  prefs: []
  type: TYPE_NORMAL
- en: '**NAME                                              READY   STATUS    RESTARTS   AGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**calico-kube-controllers-5b644bc49c-q68q7          1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**calico-node-2cvm9                                 1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**calico-node-n29tl                                 1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**coredns-6955765f44-gzvjd                          1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**coredns-6955765f44-r567x                          1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**etcd-cluster01-control-plane                      1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-apiserver-cluster01-control-plane            1/1     Running   0          14s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-controller-manager-cluster01-control-plane   1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-proxy-h62mj                                  1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-proxy-pl4z4                                  1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kube-scheduler-cluster01-control-plane            1/1     Running   0          28m**'
  prefs: []
  type: TYPE_NORMAL
- en: The API server is highlighted to have been running for only 14 seconds, showing
    that it successfully restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having verified that the API server is running, let''s look at the audit log
    to verify that it''s working correctly. To check the log, you can use **docker
    exec** to tail **audit.log**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$ docker exec cluster01-control-plane  tail /var/log/k8s/audit.log**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command generates the following log data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"473e8161-e243-4c5d-889c-42f478025cc2","stage":"ResponseComplete","requestURI":"/apis/crd.projectcalico.org/v1/clusterinformations/default","verb":"get","user":{"usernam**'
  prefs: []
  type: TYPE_NORMAL
- en: '**e":"system:serviceaccount:kube-system:calico-kube-controllers","uid":"38b96474-2457-4ec9-a146-9a63c2b8182e","groups":["system:serviceaccounts","system:serviceaccounts:kube-system","system:authenticated"]},"sourceIPs":["172.17.0.2"],"userAgent":"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Go-http-client/2.0","objectRef":{"resource":"clusterinformations","name":"default","apiGroup":"crd.projectcalico.org","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2020-05-20T00:27:07.378345Z","stageT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**imestamp":"2020-05-20T00:27:07.381227Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC:
    allowed by ClusterRoleBinding \"calico-kube-controllers\" of ClusterRole \"calico-kube-controllers\"
    to ServiceAc**'
  prefs: []
  type: TYPE_NORMAL
- en: '**count \"calico-kube-controllers/kube-system\""}}**'
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a bit of information in this JSON, and it would be challenging
    to find a specific event looking at a log file directly. Luckily, now that you
    have auditing enabled, you can forward events to a central logging server. We
    will do this in [*Chapter 12*](B15514_12_Final_ASB_ePub.xhtml#_idTextAnchor295)*,
    Auditing Using Falco and EFK*, where we will deploy an EFK stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have auditing enabled, the next step is to practice debugging RBAC
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: Using audit2rbac to debug policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a tool called **audit2rbac** that can reverse engineer errors in the
    audit log into RBAC policy objects. In this section, we''ll use this tool to generate
    an RBAC policy after discovering that one of our users can''t perform an action
    they need to be able to do. This is a typical RBAC debugging process and learning
    how to use this tool can save you hours trying to isolate RBAC issues:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, a generic RBAC policy was created to allow all members
    of the **k8s-cluster-admins** group to be administrators in our cluster. If you're
    logged into OpenUnison, log out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, log in again, but before hitting the **Finish Login** button at the bottom
    of the screen, remove the **k8s-cluster-admins** group and add **cn=k8s-create-ns,cn=users,dc=domain,dc=com**:![Figure
    8.1 – Updated login attributes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Fig_8.1_B15514.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Updated login attributes
  prefs: []
  type: TYPE_NORMAL
- en: Next, click on **Finish Login**. Once logged in, go to the dashboard. Just as
    when OpenUnison was first deployed, there won't be any namespaces or other information
    because the RBAC policy for cluster administrators doesn't apply anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The format of the **memberOf** attribute was changed from a simple name to an
    LDAP distinguished name because this is the format that's most often presented
    by ADFS or Active Directory. A **distinguished name**, or **DN**, is read from
    left to right with the leftmost component being the name of the object and each
    component to its right being its placement in the LDAP tree. For example, the
    **name cn=k8s-create-ns,cn=users,dc=domain,dc=com** group is read as "The group
    **k8s-create-ns** in the **users** container (**cn**) in the **domain.com** domain
    (**dc**)." While ADFS can generate more user-friendly names, that requires specific
    configuration or scripting, so most implementations just add the **memberOf**
    attributes, which list all the groups the user is a member of.
  prefs: []
  type: TYPE_NORMAL
- en: Next, copy your **kubectl** configuration from the token screen, making sure
    to paste it into a window that isn't your main KinD terminal so as to not overwrite
    your master configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your tokens are set, attempt to create a namespace called **not-going-to-work**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PS C:\Users\mlb> kubectl create ns not-going-to-work**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error from server (Forbidden): namespaces is forbidden: User "mlbiamext"
    cannot create resource "namespaces" in API group "" at the cluster scope**'
  prefs: []
  type: TYPE_NORMAL
- en: There's enough information here to reverse engineer an RBAC policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to eliminate this error message, create a **ClusterRole** with a resource
    for **"namespaces"**, **apiGroups** set to **""**, and a verb of **"create"**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-create-ns'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroups: [""]'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources: ["namespaces"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs: ["create"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a **ClusterRoleBinding** for the user and this ClusterRole:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-create-ns'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- kind: User'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: mlbiamext'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cluster-create-ns'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the ClusterRole and ClusterRoleBinding are created, try running the command
    again and it will work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PS C:\Users\mlb> kubectl create ns not-going-to-work namespace/not-going-to-work
    created**'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is not likely how most RBAC debugging will go. Most of the
    time, debugging RBAC will not be this clear or simple. Typically, debugging RBAC
    means getting unexpected error messages between systems. For instance, if you're
    deploying the **kube-Prometheus** project for monitoring, you'll generally want
    to monitor by **Service** objects, not by explicitly naming pods. In order to
    do this, the Prometheus ServiceAccount needs to be able to list the **Service**
    objects in the namespace of the service you want to monitor. Prometheus won't
    tell you this needs to happen; you just won't see your services listed. A better
    way to debug is to use a tool that knows how to read the audit log and can reverse
    engineer a set of roles and bindings based on the failures in the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **audit2rbac** tool is the best way to do this. It will read the audit
    log and give you a set of policies that will work. It may not be the exact policy
    that''s needed, but it will provide a good starting point. Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, attach a shell to the **control-plane** container of your cluster and
    download the tool from GitHub ([https://github.com/liggitt/audit2rbac/releases](https://github.com/liggitt/audit2rbac/releases)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**root@cluster01-control-plane:/# curl -L https://github.com/liggitt/audit2rbac/releases/download/v0.8.0/audit2rbac-linux-amd64.tar.gz
    2>/dev/null > audit2rbac-linux-amd64.tar.gz**'
  prefs: []
  type: TYPE_NORMAL
- en: '**root@cluster01-control-plane:/# tar -xvzf audit2rbac-linux-amd64.tar.gz**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the tool, make sure to close the browser with the Kubernetes dashboard
    in it to keep from polluting the logs. Also, remove the **cluster-create-ns**
    ClusterRole and ClusterRoleBinding created previously. Finally, try creating the
    **still-not-going-to-work** namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PS C:\Users\mlb> kubectl create ns still-not-going-to-work**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error from server (Forbidden): namespaces is forbidden: User "mlbiamext"
    cannot create resource "namespaces" in API group "" at the cluster scope**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the **audit2rbac** tool to look for any failures for your test user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**root@cluster01-control-plane:/# ./audit2rbac --filename=/var/log/k8s/audit.log  --user=mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening audit source...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading events...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Evaluating API calls...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating roles...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**apiVersion: rbac.authorization.k8s.io/v1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kind: ClusterRole**'
  prefs: []
  type: TYPE_NORMAL
- en: '**metadata:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  annotations:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/version: v0.8.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  labels:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/generated: "true"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/user: mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  name: audit2rbac:mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**rules:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**- apiGroups:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  - ""**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  resources:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  - namespaces**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  verbs:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  - create**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---**'
  prefs: []
  type: TYPE_NORMAL
- en: '**apiVersion: rbac.authorization.k8s.io/v1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**kind: ClusterRoleBinding**'
  prefs: []
  type: TYPE_NORMAL
- en: '**metadata:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  annotations:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/version: v0.8.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  labels:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/generated: "true"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    audit2rbac.liggitt.net/user: mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  name: audit2rbac:mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**roleRef:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  apiGroup: rbac.authorization.k8s.io**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  kind: ClusterRole**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  name: audit2rbac:mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**subjects:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**- apiGroup: rbac.authorization.k8s.io**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  kind: User**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  name: mlbiamext**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complete!**'
  prefs: []
  type: TYPE_NORMAL
- en: This command generated a policy that will exactly allow the test user to create
    namespaces. This becomes an anti-pattern, though, of explicitly authorizing access
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to better leverage this policy, it would be better to use our group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: create-ns-audit2rbac'
  prefs: []
  type: TYPE_NORMAL
- en: 'rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroups:'
  prefs: []
  type: TYPE_NORMAL
- en: '- ""'
  prefs: []
  type: TYPE_NORMAL
- en: 'resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '- namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '- create'
  prefs: []
  type: TYPE_NORMAL
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRoleBinding'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: create-ns-audit2rbac'
  prefs: []
  type: TYPE_NORMAL
- en: 'roleRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: ClusterRole'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: create-ns-audit2rbac'
  prefs: []
  type: TYPE_NORMAL
- en: 'subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '- apiGroup: rbac.authorization.k8s.io'
  prefs: []
  type: TYPE_NORMAL
- en: '**kind: Group**'
  prefs: []
  type: TYPE_NORMAL
- en: '**  name: cn=k8s-create-ns,cn=users,dc=domain,dc=com**'
  prefs: []
  type: TYPE_NORMAL
- en: The major change is highlighted. Instead of referencing the user directly, the
    **ClusterRoleBinding** is now referencing the **cn=k8s-create-ns,cn=users,dc=domain,dc=com**
    group so that any member of that group can now create namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter's focus was on RBAC policy creation and debugging. We explored
    how Kubernetes defines authorization policies and how it applies those policies
    to enterprise users. We also looked at how these policies can be used to enable
    multi-tenancy in your cluster. Finally, we enabled the audit log in our KinD cluster
    and learned how to use the **audit2rbac** tool to debug RBAC issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes' built-in RBAC policy management objects lets you enable access
    that's needed for operational and development tasks in your clusters. Knowing
    how to design policies can help limit the impact of issues, providing the confidence
    to let users do more on their own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be learning about how to secure the Kubernetes dashboard,
    as well as how to approach security for other infrastructure applications that
    make up your cluster. You'll learn how to apply what we've learned about authentication
    and authorization to the applications that make up your cluster, providing your
    developers and infrastructure team with a better and more secure experience.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: True or false – ABAC is the preferred method of authorizing access to Kubernetes
    clusters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: What are the three components of a Role?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Subject, noun, and verb
  prefs: []
  type: TYPE_NORMAL
- en: B. Resource, action, and group
  prefs: []
  type: TYPE_NORMAL
- en: C. **apiGroups**, resources, and verbs
  prefs: []
  type: TYPE_NORMAL
- en: D. Group, resource, and sub-resource
  prefs: []
  type: TYPE_NORMAL
- en: Where can you go to look up resource information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Kubernetes API reference
  prefs: []
  type: TYPE_NORMAL
- en: B. The library
  prefs: []
  type: TYPE_NORMAL
- en: C. Tutorials and blog posts
  prefs: []
  type: TYPE_NORMAL
- en: How can you reuse Roles across namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. You can't; you need to re-create them.
  prefs: []
  type: TYPE_NORMAL
- en: B. Define a ClusterRole and reference it in each namespace as a RoleBinding.
  prefs: []
  type: TYPE_NORMAL
- en: C. Reference the Role in one namespace with the RoleBindings of other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above.
  prefs: []
  type: TYPE_NORMAL
- en: How should bindings reference users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Directly, listing every user.
  prefs: []
  type: TYPE_NORMAL
- en: B. RoleBindings should only reference service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: C. Only ClusterRoleBindings should reference users.
  prefs: []
  type: TYPE_NORMAL
- en: D. Whenever possible, RoleBindings and ClusterRoleBindings should reference
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: True or false – RBAC can be used to authorize access to everything except for
    one resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL
- en: True or false – RBAC is the only method of authorization in Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  prefs: []
  type: TYPE_NORMAL

- en: Running Serverless Workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, our final chapter, we are going to talk about a few of the different
    scenarios where you would want to host your own serverless workloads, and what
    to consider when choosing a tool. We are going to start by discussing the advantages
    and disadvantages of working with a technology that is still in its infancy and
    is still going through quite a lot of active development.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving software and platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pretty much all of the technology we have looked at in this book is currently
    in development. Some of the projects, as we already discussed, are in the very
    early stages of development, while others are more mature. Let's start by discussing
    Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is very much in active development, though it is quite far into its
    development cycle. I started writing this book at the beginning of September 2017
    and now, as I write the final chapter, it is the end of December 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this period there have been a total of 48 releases, as you can see from
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1404c003-3e78-40f6-a1ad-f83f18256b56.png)'
  prefs: []
  type: TYPE_IMG
- en: These updates cover everything from the maintenance releases v1.5, v1.6, and
    v1.7; the actual releases of v.1.8 and v1.9; and the subsequent maintenance releases
    all the way to the first alpha versions of v1.10\. With such an active release
    cycle, how easy is it to keep on top of the releases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, given the frequency of releases, not as bad as you may think, though
    it can get complicated. As you can see from the table, each Kubernetes release
    has a major version, a minor version, and a patch version. For example, the current
    releases at the time of writing are:'
  prefs: []
  type: TYPE_NORMAL
- en: v1.6.13 (older release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v1.7.11 (older release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v1.8.6 (current release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: v1.9.0 (development release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, as of *December 12, 2017*, there are four minor versions of the same major
    release being actively worked on and patched. Kubernetes itself supports three
    minor versions at a time; namely the current release (v1.8) and two older releases
    (v1.6 and v1.7). What this means is:'
  prefs: []
  type: TYPE_NORMAL
- en: A master node running the current release is expected to work with nodes that
    are running the two previous versions. That is, you can have a v1.8 master and
    a mixture of v1.7 and v1.6 nodes within your cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A master node running the current release is expected to work with a client,
    like kubectl, that is one version behind and one version ahead of the current
    release; this means that we can interact our v1.8 master with the v1.9 and v1.10
    client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended that whichever version you are running, you always run the
    latest patch version, as the patches often contain critical bug and security fixes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this support model means is that features that may be present in version
    v1.6.13 could potentially be unavailable in version v1.9.0\. With a new minor
    release roughly every two months, you have around four months to plan your updates,
    and then two months to action them—this may mean reviewing and possibly updating
    existing applications that are deployed in your cluster to make sure that they
    are not using any functionality that is being phased out of recent releases.
  prefs: []
  type: TYPE_NORMAL
- en: This is where reading the release notes becomes invaluable, as new minor versions
    always have a *Before Upgrading* section that confirms exactly what potential
    cluster-breaking changes there have been since the previous release. For example,
    the current development version is v1.9.0\. I know that it will become the current
    release in about two months, so to prepare for that I need to work my cluster
    and make sure that I take into account all of the changes detailed at [https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.9.md#before-upgrading](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.9.md#before-upgrading).
  prefs: []
  type: TYPE_NORMAL
- en: Features are only added, deprecated, and removed in minor versions. Patch releases
    are just that, patches to existing functionality. I also recommend reading through
    *Kubernetes Depreciation Policy*, which explains the rules for removing/disabling
    functionality. The policy can be found at [https://kubernetes.io/docs/reference/deprecation-policy/](https://kubernetes.io/docs/reference/deprecation-policy/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the versions of Kubernetes that can be deployed using Minikube
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The supported versions of Kubernetes releases for Google Cloud can be found
    at [https://cloud.google.com/kubernetes-engine/supported-versions](https://cloud.google.com/kubernetes-engine/supported-versions).
    Microsoft Azure supports all of the current releases; an example of this support
    can be found at the AKS introductory blog post at [https://azure.microsoft.com/en-us/blog/introducing-azure-container-service-aks-managed-kubernetes-and-azure-container-registry-geo-replication/](https://azure.microsoft.com/en-us/blog/introducing-azure-container-service-aks-managed-kubernetes-and-azure-container-registry-geo-replication/),
    where the example shows a live upgrade of v1.7.7 to v1.8.1.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So how does the on-going development cycle of Kubernetes affect the development
    of the serverless tools we have been looking at, and how does that affect their
    own development cycles?
  prefs: []
  type: TYPE_NORMAL
- en: To start, let's look at the type of tool. In the last chapter, when looking
    at security, we found out that there are basically two types of tool. The first
    adds and extends functionality within Kubernetes, such as Kubeless and Funktion.
    The second type of tool consumes Kubernetes services by basically sitting on top
    of Kubernetes and making API calls, such as Apache OpenWhisk, Fission, and OpenFaaS.
  prefs: []
  type: TYPE_NORMAL
- en: The tools that are closely coupled with Kubernetes will always have to not only
    plan their releases in line with Kubernetes, but also have to keep a very close
    eye on the path that Kubernetes is taking, as decisions made by the Kubernetes
    special interest groups will directly affect their own roadmaps.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in September 2017, Kubeless released an update to change from using
    **ThirdPartyResources** (**TPR**) to **CustomResourceDefinitions** (**CRD**),
    as TPR was deprecated as of Kubernetes v.1.7 and removed in v1.8.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does mean that your choice of tool will require a little research. The
    questions you should be asking yourself are:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the tool I am evaluating work with the version of Kubernetes I will be
    deploying in my cluster? If in doubt, you can check by doing a few test installations
    with Minikube.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any open issues that could affect my deployment? Before you commit
    to the tool, I recommend looking at any open issues on the tools GitHub project
    page; do any of the problems sound familiar, and could they be applicable to your
    installation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the tool I am looking at deploying in active development, and how frequent
    are new releases? Does there appear to be a community supporting the tool? Review
    the releases page on GitHub; how frequent are releases, and does there appear
    to be any service-breaking releases?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How secure is the tool? Based on the previous chapter, how secure is the default
    configuration, and how will making it secure affect how you use the tool?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of useful links that should help you answer the previous questions
    can be found as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The useful links for Kubeless are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project homepage**: [http://kubeless.io/](http://kubeless.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project License**: [https://github.com/kubeless/kubeless/blob/master/LICENSE](https://github.com/kubeless/kubeless/blob/master/LICENSE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: [https://github.com/kubeless/kubeless/issues](https://github.com/kubeless/kubeless/issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releases**: [https://github.com/kubeless/kubeless/releases](https://github.com/kubeless/kubeless/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributing guidelines**: [https://github.com/kubeless/kubeless/blob/master/CONTRIBUTING.md](https://github.com/kubeless/kubeless/blob/master/CONTRIBUTING.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: [https://github.com/kubeless/kubeless/tree/master/docs](https://github.com/kubeless/kubeless/tree/master/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The useful links for  OpenWhisk  are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project homepage**: [https://openwhisk.apache.org](https://openwhisk.apache.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project License**: [https://github.com/apache/incubator-openwhisk/blob/master/LICENSE.txt](https://github.com/apache/incubator-openwhisk/blob/master/LICENSE.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: [https://github.com/apache/incubator-openwhisk/issues](https://github.com/apache/incubator-openwhisk/issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributing guidelines**: [https://github.com/apache/incubator-openwhisk/blob/master/CONTRIBUTING.md](https://github.com/apache/incubator-openwhisk/blob/master/CONTRIBUTING.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: [https://cwiki.apache.org/confluence/display/OPENWHISK/OpenWhisk+Project+Wiki](https://cwiki.apache.org/confluence/display/OPENWHISK/OpenWhisk+Project+Wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The useful links for Fission are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project homepage**: [http://fission.io/](http://fission.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project License**: [https://github.com/fission/fission/blob/master/LICENSE](https://github.com/fission/fission/blob/master/LICENSE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: [https://github.com/fission/fission/issues](https://github.com/fission/fission/issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releases**: [https://github.com/fission/fission/releases](https://github.com/fission/fission/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributing guidelines**: [https://github.com/fission/fission/blob/master/CONTRIBUTING.md](https://github.com/fission/fission/blob/master/CONTRIBUTING.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: [https://github.com/fission/fission/tree/master/Documentation](https://github.com/fission/fission/tree/master/Documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenFaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The useful links for  OpenFaaS  are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project homepage**: [https://www.openfaas.com](https://www.openfaas.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project License**: [https://github.com/openfaas/faas/blob/master/LICENSE](https://github.com/openfaas/faas/blob/master/LICENSE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: [https://github.com/openfaas/faas/issues](https://github.com/openfaas/faas/issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releases**: [https://github.com/openfaas/faas/releases](https://github.com/openfaas/faas/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributing guidelines**: [https://github.com/openfaas/faas/blob/master/CONTRIBUTING.md](https://github.com/openfaas/faas/blob/master/CONTRIBUTING.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: [https://github.com/openfaas/faas/tree/master/docs](https://github.com/openfaas/faas/tree/master/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Funktion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The useful links for Funktion  are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book was first started, Funktion has been sandboxed. The source
    code remains available for anyone to use, or fork their own version to continue
    development. The authors recommend two alternatives: either Kubeless or Apache
    OpenWhisk.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project homepage**: [https://funktion.fabric8.io](https://funktion.fabric8.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project License**: [https://github.com/funktionio/funktion/blob/master/LICENSE.md](https://github.com/funktionio/funktion/blob/master/LICENSE.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues**: [https://github.com/funktionio/funktion/issues](https://github.com/funktionio/funktion/issues)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Releases**: [https://github.com/funktionio/funktion/releases](https://github.com/funktionio/funktion/releases)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributing guidelines**: [https://cwiki.apache.org/confluence/display/OPENWHISK/OpenWhisk+Project+Wiki](https://cwiki.apache.org/confluence/display/OPENWHISK/OpenWhisk+Project+Wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docs**: [https://funktion.fabric8.io/docs/](https://funktion.fabric8.io/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future developments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three months is a long time in technology. There have been a few changes to
    the Kubernetes ecosystem since I first started writing this book; the most notable
    two are currently in private beta and are expected to open up for public use in
    early 2018.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is an alternative to running Kubernetes locally using Minikube, which
    came from an unexpected source: Docker. During DockerCon Europe 2017, it was announced
    that Docker will be supporting Kubernetes alongside Docker swarm in both the Community
    and Enterprise Editions of Docker for macOS and Docker for Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more information on this upcoming release at [https://www.docker.com/kubernetes](https://www.docker.com/kubernetes),
    or watch Elton Stoneman's introduction video for the service at [https://www.youtube.com/watch?v=jWupQjdjLN0](https://www.youtube.com/watch?v=jWupQjdjLN0).
  prefs: []
  type: TYPE_NORMAL
- en: The second service, which came as no surprise, is the introduction of the **Amazon
    Elastic Container Service for Kubernetes** service, or **Amazon EKS** for short.
    Amazon announced this at their yearly re:Invent conference, and as you would expect,
    it has deep levels of integration with other AWS services such as Amazon VPC,
    IAM, Elastic Load Balancing, and AWS CloudTrail, to name a few—you can find out
    more about the service, which is currently in private beta, at [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/),
    as well as watching the announcement at [https://www.youtube.com/watch?v=gUFtUU7qvSQ](https://www.youtube.com/watch?v=gUFtUU7qvSQ).
  prefs: []
  type: TYPE_NORMAL
- en: Why Functions as a Service on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first few chapters, we spoke about serverless functions and Kubernetes
    and the advantages of using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**: the biggest use case for using Kubernetes to deploy your application
    is that it allows you to develop once and then deploy in a consistent way across
    multiple platforms, be it self-hosted bare-metal servers, or private clouds running
    virtual machines on VMWare, OpenStack, KVM, Hyper-V, and more. The same goes for
    public cloud providers such as Google Cloud, Microsoft Azure, and now AWS, who
    all offer their own native-managed Kubernetes services all the way through to
    your local machine running Minikube or the soon-to-be-released versions of Docker
    for macOS or Docker for Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**: Deploying all or parts of your application as serverless functions
    can help it scale with ease. All of a sudden, you do not need to worry about whether
    your virtual machine or container has enough resources to be able to handle a
    flood of incoming connections, or how those connections are routed to your application.
    Each request will be sent to an individual or cluster of containers managed where
    your request will be processed—once complete, that container will either be terminated
    or recycled for the next request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes plus serverless**: As already mentioned, the serverless portions
    of your application can easily scale—this can combine with Kubernetes, where additional
    nodes can quickly be spun up and added to your cluster both manually and via scripts.
    Once the additional resource is part of the cluster, your serverless functions
    will automatically be scheduled on the new resource, with the need for you make
    any further changes either to your application routing or code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, couple this with the knowledge that you can pretty much deploy your application
    in any of the major public cloud providers, and you will get a consistent experience,
    rather than having to adapt your code to have to work with the provider's own
    Functions as a Service offerings, such as the ones we discussed in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml),
    *The Serverless Landscape*.
  prefs: []
  type: TYPE_NORMAL
- en: Your choice of serverless tool will more than likely come down to two factors,
    the first being what language your application is written in—for example, is your
    application written in Python, Node.js, PHP, Java, .NET, or Go?
  prefs: []
  type: TYPE_NORMAL
- en: The second factor will be personal preference. You have probably already formed
    an opinion, while working through the chapters of this book, about which of the
    tools is best for you, and which will fit in with both your development workflows
    and your own way of working. Issues such as security will always be a contributing
    factor, but as discussed in the previous chapter, there are ways of overcoming
    these.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have been discussing lots of potentially small moving parts. What
    about big fixed points such as databases and file storage? How do they fit in
    with FaaS services on Kubernetes?
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still debate going on as to whether you should be running your database
    services in containers—this has pretty much been around since Docker first started
    to get traction, and unfortunately, there is no simple yes or no answer.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever I approach a project, I tend to look at the usage and what impact the
    database has on the overall performance of the application itself, and then work
    back from there.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes allows you to run a PetSet; think back to the pet versus cattle analogy
    from the start of the book. In Kubernetes v1.5, as the feature left alpha, it
    became known as a StatefulSet. The feature came out of beta in Kubernetes v1.9.
  prefs: []
  type: TYPE_NORMAL
- en: See the following GitHub issue for a discussion about the change of name from
    PetSet to StatefulSet [https://github.com/kubernetes/kubernetes/issues/27430](https://github.com/kubernetes/kubernetes/issues/27430).
  prefs: []
  type: TYPE_NORMAL
- en: 'A StatefulSet allows you to run what would traditionally be quite difficult
    to run in a clustered service such as Kubernetes. Using a combination of pods
    and persistent storage, it basically creates a fixed point within your Kubernetes
    cluster which:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a stable unique network identifier that will persist should the StatefulSet
    need to move between hosts or the pod need restarting because of error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has stable persistent storage that is dedicated to the StatefulSet, useful for
    storing databases, configuration, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has ordered and graceful deployment and scaling, deletion and termination, and
    automated rolling updates, all of which means you have control over the software
    that needs to be controlled when it is started, moved, or shut down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these mean that it is more than possible to host your databases within
    your Kubernetes cluster. Doing so means that you will be able to connect to your
    database within the same namespaces, but this solution may not be suitable for
    all scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a large dataset, or your database needs to be accessible
    outside of your Kubernetes cluster by other applications, then you may be better
    off using the native database services offered by your public cloud provider.
    These services include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Relational Database Service** (**Amazon RDS**): This service supports
    MySQL, PostgreSQL, MariaDB, Oracle, and Microsoft SQL. For more details, see [https://aws.amazon.com/rds/](https://aws.amazon.com/rds/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure Database**: There are Microsoft SQL, MySQL, and PostgreSQL
    options; see [https://azure.microsoft.com/en-gb/services/sql-database/](https://azure.microsoft.com/en-gb/services/sql-database/),
    [https://azure.microsoft.com/en-gb/services/mysql/](https://azure.microsoft.com/en-gb/services/mysql/),
    and [https://azure.microsoft.com/en-gb/services/postgresql/](https://azure.microsoft.com/en-gb/services/postgresql/)
    for further details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud SQL**: This supports MySQL and PostgreSQL. See the following
    link for more information: [https://cloud.google.com/sql/](https://cloud.google.com/sql/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using these services exposes you to a little vendor lock-in as you will
    have large parts of your data outside of your Kubernetes cluster, all three offer
    open source database engines, which from an application point of view means they
    are still consuming the same database service, be it hosted within your cluster
    or as one of your public cloud providers services.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about StatefulSets, I would recommend reading through
    the following two examples on the Kubernetes website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/](https://kubernetes.io/docs/tasks/run-application/run-single-instance-stateful-application/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/](https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please remember that up until Kubernetes v1.9 this feature was in beta, so you
    may have to check the documentation if your cluster is running an older version.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern applications should already not be storing files that are being
    generated on local drives—instead, they should be using an object store. Typically,
    an object offers an API that allows the application to both write files to the
    service, and also query the service to find out metadata for the files, including
    retrieving a URL where the file can be accessed over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big three public cloud providers all offer object storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon S3**: [https://aws.amazon.com/s3/](https://aws.amazon.com/s3/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure Blob storage**: [https://azure.microsoft.com/en-gb/services/storage/blobs/](https://azure.microsoft.com/en-gb/services/storage/blobs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Storage**: [https://cloud.google.com/storage/](https://cloud.google.com/storage/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon S3 is the granddaddy of them all; it is more than likely that at some
    point in the last 48 hours you have accessed a file which has been served either
    directly from Amazon S3, or indirectly, using a content delivery network where
    Amazon S3 is the origin for the file.
  prefs: []
  type: TYPE_NORMAL
- en: What if you wish to keep your application within Kubernetes, including the object
    store? Don't worry, it is possible to run your own object store; in fact, you
    can run one that has a highlevel of compatibility with Amazon S3, meaning that
    your application should continue to work with little to no modification.
  prefs: []
  type: TYPE_NORMAL
- en: Minio is a multi-cloud object store that you can deploy to Kubernetes as well
    as other cloud and service providers; it is even possible to run it locally using
    Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Minio on Kubernetes, see the following link: [https://www.minio.io/kubernetes.html](https://www.minio.io/kubernetes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here we are at the end of the book. We have worked through what we mean
    by serverless, and addressed the confusion about running serverless functions
    on servers.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about how Kubernetes started and some of its core concepts,
    as well as about deploying clusters locally and in public clouds using both tools
    provided by Kubernetes themselves, and also the cloud provider's native solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Using these clusters, we worked through several tools that all provide Functions
    as a Service functionality, either by extending Kubernetes with new functionality,
    or by taking advantages of the Platform as a Service functionality of Kubernetes
    and installing themselves on top of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed potential security issues with these deployments and how to
    monitor them, before then talking about how we try and keep ahead of an ever-evolving
    technology, and what you will need to consider when starting out on your own deploying
    serverless functions on Kubernetes.
  prefs: []
  type: TYPE_NORMAL

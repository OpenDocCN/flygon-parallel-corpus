["```java\nProperties props = new Properties();\nprops.put(\"bootstrap.servers\", \"broker1:9092,broker2:9092\");\nprops.put(\"group.id\", \"CountryCounter\");\nprops.put(\"key.deserializer\",\n    \"org.apache.kafka.common.serialization.StringDeserializer\");\nprops.put(\"value.deserializer\",\n    \"org.apache.kafka.common.serialization.StringDeserializer\");\n\nKafkaConsumer<String, String> consumer =\n    new KafkaConsumer<String, String>(props);\n```", "```java\nconsumer.subscribe(Collections.singletonList(\"customerCountries\")); ![1](assets/1.png)\n```", "```java\nconsumer.subscribe(Pattern.compile(\"test.*\"));\n```", "```java\nDuration timeout = Duration.ofMillis(100);\n\nwhile (true) { ![1](assets/1.png)\n    ConsumerRecords<String, String> records = consumer.poll(timeout); ![2](assets/2.png)\n\n    for (ConsumerRecord<String, String> record : records) { ![3](assets/3.png)\n        System.out.printf(\"topic = %s, partition = %d, offset = %d, \" +\n                        \"customer = %s, country = %s\\n\",\n        record.topic(), record.partition(), record.offset(),\n                record.key(), record.value());\n        int updatedCount = 1;\n        if (custCountryMap.containsKey(record.value())) {\n            updatedCount = custCountryMap.get(record.value()) + 1;\n        }\n        custCountryMap.put(record.value(), updatedCount);\n\n        JSONObject json = new JSONObject(custCountryMap);\n        System.out.println(json.toString()); ![4](assets/4.png)\n    }\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\n\nwhile (true) {\n    ConsumerRecords<String, String> records = consumer.poll(timeout);\n    for (ConsumerRecord<String, String> record : records) {\n        System.out.printf(\"topic = %s, partition = %d, offset =\n            %d, customer = %s, country = %s\\n\",\n            record.topic(), record.partition(),\n            record.offset(), record.key(), record.value()); ![1](assets/1.png)\n    }\n    try {\n        consumer.commitSync(); ![2](assets/2.png)\n    } catch (CommitFailedException e) {\n        log.error(\"commit failed\", e) ![3](assets/3.png)\n    }\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\n\nwhile (true) {\n    ConsumerRecords<String, String> records = consumer.poll(timeout);\n    for (ConsumerRecord<String, String> record : records) {\n        System.out.printf(\"topic = %s, partition = %s,\n            offset = %d, customer = %s, country = %s\\n\",\n            record.topic(), record.partition(), record.offset(),\n            record.key(), record.value());\n    }\n    consumer.commitAsync(); ![1](assets/1.png)\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\n\nwhile (true) {\n    ConsumerRecords<String, String> records = consumer.poll(timeout);\n    for (ConsumerRecord<String, String> record : records) {\n        System.out.printf(\"topic = %s, partition = %s,\n        offset = %d, customer = %s, country = %s\\n\",\n        record.topic(), record.partition(), record.offset(),\n        record.key(), record.value());\n    }\n    consumer.commitAsync(new OffsetCommitCallback() {\n        public void onComplete(Map<TopicPartition,\n        OffsetAndMetadata> offsets, Exception e) {\n            if (e != null)\n                log.error(\"Commit failed for offsets {}\", offsets, e);\n        }\n    }); ![1](assets/1.png)\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\n\ntry {\n    while (!closing) {\n        ConsumerRecords<String, String> records = consumer.poll(timeout);\n        for (ConsumerRecord<String, String> record : records) {\n            System.out.printf(\"topic = %s, partition = %s, offset = %d,\n                customer = %s, country = %s\\n\",\n                record.topic(), record.partition(),\n                record.offset(), record.key(), record.value());\n        }\n        consumer.commitAsync(); ![1](assets/1.png)\n    }\n    consumer.commitSync(); ![2](assets/2.png)\n} catch (Exception e) {\n    log.error(\"Unexpected error\", e);\n} finally {\n        consumer.close();\n}\n```", "```java\nprivate Map<TopicPartition, OffsetAndMetadata> currentOffsets =\n    new HashMap<>(); ![1](assets/1.png)\nint count = 0;\n\n....\nDuration timeout = Duration.ofMillis(100);\n\nwhile (true) {\n    ConsumerRecords<String, String> records = consumer.poll(timeout);\n    for (ConsumerRecord<String, String> record : records) {\n        System.out.printf(\"topic = %s, partition = %s, offset = %d,\n            customer = %s, country = %s\\n\",\n            record.topic(), record.partition(), record.offset(),\n            record.key(), record.value()); ![2](assets/2.png)\n        currentOffsets.put(\n            new TopicPartition(record.topic(), record.partition()),\n            new OffsetAndMetadata(record.offset()+1, \"no metadata\")); ![3](assets/3.png)\n        if (count % 1000 == 0)   ![4](assets/4.png)\n            consumer.commitAsync(currentOffsets, null); ![5](assets/5.png)\n        count++;\n    }\n}\n```", "```java\nprivate Map<TopicPartition, OffsetAndMetadata> currentOffsets =\n    new HashMap<>();\nDuration timeout = Duration.ofMillis(100);\n\nprivate class HandleRebalance implements ConsumerRebalanceListener { ![1](assets/1.png)\n    public void onPartitionsAssigned(Collection<TopicPartition>\n        partitions) { ![2](assets/2.png)\n    }\n\n    public void onPartitionsRevoked(Collection<TopicPartition> partitions) {\n        System.out.println(\"Lost partitions in rebalance. \" +\n            \"Committing current offsets:\" + currentOffsets);\n        consumer.commitSync(currentOffsets); ![3](assets/3.png)\n    }\n}\n\ntry {\n    consumer.subscribe(topics, new HandleRebalance()); ![4](assets/4.png)\n\n    while (true) {\n        ConsumerRecords<String, String> records = consumer.poll(timeout);\n        for (ConsumerRecord<String, String> record : records) {\n            System.out.printf(\"topic = %s, partition = %s, offset = %d,\n                 customer = %s, country = %s\\n\",\n                 record.topic(), record.partition(), record.offset(),\n                 record.key(), record.value());\n             currentOffsets.put(\n                 new TopicPartition(record.topic(), record.partition()),\n                 new OffsetAndMetadata(record.offset()+1, null));\n        }\n        consumer.commitAsync(currentOffsets, null);\n    }\n} catch (WakeupException e) {\n    // ignore, we're closing\n} catch (Exception e) {\n    log.error(\"Unexpected error\", e);\n} finally {\n    try {\n        consumer.commitSync(currentOffsets);\n    } finally {\n        consumer.close();\n        System.out.println(\"Closed consumer and we are done\");\n    }\n}\n```", "```java\nLong oneHourEarlier = Instant.now().atZone(ZoneId.systemDefault())\n          .minusHours(1).toEpochSecond();\nMap<TopicPartition, Long> partitionTimestampMap = consumer.assignment()\n        .stream()\n        .collect(Collectors.toMap(tp -> tp, tp -> oneHourEarlier)); ![1](assets/1.png)\nMap<TopicPartition, OffsetAndTimestamp> offsetMap\n        = consumer.offsetsForTimes(partitionTimestampMap); ![2](assets/2.png)\n\nfor(Map.Entry<TopicPartition,OffsetAndTimestamp> entry: offsetMap.entrySet()) {\n    consumer.seek(entry.getKey(), entry.getValue().offset()); ![3](assets/3.png)\n}\n```", "```java\nRuntime.getRuntime().addShutdownHook(new Thread() {\n    public void run() {\n        System.out.println(\"Starting exit...\");\n        consumer.wakeup(); ![1](assets/1.png)\n        try {\n            mainThread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n});\n\n...\nDuration timeout = Duration.ofMillis(10000); ![2](assets/2.png)\n\ntry {\n    // looping until ctrl-c, the shutdown hook will cleanup on exit\n    while (true) {\n        ConsumerRecords<String, String> records =\n            movingAvg.consumer.poll(timeout);\n        System.out.println(System.currentTimeMillis() +\n            \"--  waiting for data...\");\n        for (ConsumerRecord<String, String> record : records) {\n            System.out.printf(\"offset = %d, key = %s, value = %s\\n\",\n                record.offset(), record.key(), record.value());\n        }\n        for (TopicPartition tp: consumer.assignment())\n            System.out.println(\"Committing offset at position:\" +\n                consumer.position(tp));\n        movingAvg.consumer.commitSync();\n    }\n} catch (WakeupException e) {\n    // ignore for shutdown ![3](assets/3.png)\n} finally {\n    consumer.close(); ![4](assets/4.png)\n    System.out.println(\"Closed consumer and we are done\");\n}\n```", "```java\npublic class Customer {\n    private int customerID;\n    private String customerName;\n\n    public Customer(int ID, String name) {\n        this.customerID = ID;\n        this.customerName = name;\n    }\n\n    public int getID() {\n        return customerID;\n    }\n\n    public String getName() {\n        return customerName;\n    }\n}\n```", "```java\nimport org.apache.kafka.common.errors.SerializationException;\n\nimport java.nio.ByteBuffer;\nimport java.util.Map;\n\npublic class CustomerDeserializer implements Deserializer<Customer> { ![1](assets/1.png)\n\n    @Override\n    public void configure(Map configs, boolean isKey) {\n        // nothing to configure\n    }\n\n    @Override\n    public Customer deserialize(String topic, byte[] data) {\n        int id;\n        int nameSize;\n        String name;\n\n        try {\n            if (data == null)\n                return null;\n            if (data.length < 8)\n                throw new SerializationException(\"Size of data received \" +\n                    \"by deserializer is shorter than expected\");\n\n            ByteBuffer buffer = ByteBuffer.wrap(data);\n            id = buffer.getInt();\n            nameSize = buffer.getInt();\n\n            byte[] nameBytes = new byte[nameSize];\n            buffer.get(nameBytes);\n            name = new String(nameBytes, \"UTF-8\");\n\n            return new Customer(id, name); ![2](assets/2.png)\n\n        } catch (Exception e) {\n  \t        throw new SerializationException(\"Error when deserializing \" +   \t        \"byte[] to Customer \" + e);\n        }\n    }\n\n    @Override\n    public void close() {\n        // nothing to close\n    }\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\nProperties props = new Properties();\nprops.put(\"bootstrap.servers\", \"broker1:9092,broker2:9092\");\nprops.put(\"group.id\", \"CountryCounter\");\nprops.put(\"key.deserializer\",\n    \"org.apache.kafka.common.serialization.StringDeserializer\");\nprops.put(\"value.deserializer\",\n    CustomerDeserializer.class.getName());\n\nKafkaConsumer<String, Customer> consumer =\n    new KafkaConsumer<>(props);\n\nconsumer.subscribe(Collections.singletonList(\"customerCountries\"))\n\nwhile (true) {\n    ConsumerRecords<String, Customer> records = consumer.poll(timeout);\n    for (ConsumerRecord<String, Customer> record : records) {\n        System.out.println(\"current customer Id: \" +\n            record.value().getID() + \" and\n            current customer name: \" +  record.value().getName());\n    }\n    consumer.commitSync();\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\nProperties props = new Properties();\nprops.put(\"bootstrap.servers\", \"broker1:9092,broker2:9092\");\nprops.put(\"group.id\", \"CountryCounter\");\nprops.put(\"key.deserializer\",\n    \"org.apache.kafka.common.serialization.StringDeserializer\");\nprops.put(\"value.deserializer\",\n    \"io.confluent.kafka.serializers.KafkaAvroDeserializer\"); ![1](assets/1.png)\nprops.put(\"specific.avro.reader\",\"true\");\nprops.put(\"schema.registry.url\", schemaUrl); ![2](assets/2.png)\nString topic = \"customerContacts\"\n\nKafkaConsumer<String, Customer> consumer = new KafkaConsumer<>(props);\nconsumer.subscribe(Collections.singletonList(topic));\n\nSystem.out.println(\"Reading topic:\" + topic);\n\nwhile (true) {\n    ConsumerRecords<String, Customer> records = consumer.poll(timeout); ![3](assets/3.png)\n\n    for (ConsumerRecord<String, Customer> record: records) {\n        System.out.println(\"Current customer name is: \" +\n            record.value().getName()); ![4](assets/4.png)\n    }\n    consumer.commitSync();\n}\n```", "```java\nDuration timeout = Duration.ofMillis(100);\nList<PartitionInfo> partitionInfos = null;\npartitionInfos = consumer.partitionsFor(\"topic\"); ![1](assets/1.png)\n\nif (partitionInfos != null) {\n    for (PartitionInfo partition : partitionInfos)\n        partitions.add(new TopicPartition(partition.topic(),\n            partition.partition()));\n    consumer.assign(partitions); ![2](assets/2.png)\n\n    while (true) {\n        ConsumerRecords<String, String> records = consumer.poll(timeout);\n\n        for (ConsumerRecord<String, String> record: records) {\n            System.out.printf(\"topic = %s, partition = %s, offset = %d,\n                customer = %s, country = %s\\n\",\n                record.topic(), record.partition(), record.offset(),\n                record.key(), record.value());\n        }\n        consumer.commitSync();\n    }\n}\n```"]
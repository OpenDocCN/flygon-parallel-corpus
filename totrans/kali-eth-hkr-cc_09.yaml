- en: Buffer Overflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting stack-based buffer overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting buffer overflow on real software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEH bypass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting egg hunters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of ASLR and NX bypass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a software program, buffer overflow occurs when a program, while writing
    data to a buffer, overruns the buffer size allocated and starts overwriting data
    to adjacent memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: A buffer can be considered a temporary area in the memory allocated to a program
    to store and retrieve data when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer overflows have been known to be exploited since long back.
  prefs: []
  type: TYPE_NORMAL
- en: When exploiting buffer overflows, our main focus is on overwriting some control
    information so that the flow of control of the program changes, which will allow
    our code to take control of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram that will give us a basic idea of an overflow happening in
    a buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edcf143a-1eb8-44ce-b001-e0f59b5f229c.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can assume this is what a program looks like.
    Since it is a stack, it starts from bottom and moves toward the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the preceding diagram, we also notice that the program has a fixed buffer
    to store 16 letters/bytes of data.
  prefs: []
  type: TYPE_NORMAL
- en: We first enter the 8 characters (*1 char=1 byte*); on the right-hand side of
    the diagram, we can see that they have been written in the buffer of the program's
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we write 20 characters into the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f33b307-ee03-4cb4-8ed2-f4d10fc4b5b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: http://www.cbi.umn.edu/'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that data is correctly written upto 16 characters, but the last 4
    characters have now gone out of the buffer and have overwritten the values stored
    in the **Return Address** of the program. This is where a classic buffer overflow
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a live example; we will take a sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program simply takes an input at runtime and copies it into a
    variable called `buffer`. We can see that the size of the variable buffer is set
    to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now compile it using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to be careful as `gcc` by default has inbuilt security features, which
    prevent buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the program using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We see that it has stored the data and we get the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will see the program exits as a segmentation fault. This is the enabled security
    feature of `gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the return address in the next recipe. However, overwriting
    the return address with our own code can cause a program to behave differently
    from its usual execution and helps us in exploiting the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing is the easiest way to discover buffer overflows in a program. There
    are various fuzzers available in Kali, or we can write a custom script to make
    our own, depending on the type of program we have.
  prefs: []
  type: TYPE_NORMAL
- en: Once fuzzing is done and a crash occurs, our next step is to debug the program
    to find the exact part where a program crashes and how we can use it to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are multiple debuggers available online. My personal favorite for
    Windows is Immunity Debugger (Immunity Inc.). Kali also comes with an inbuilt
    debugger, GDB. It is a command-line debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump any further into more exciting topics, note that there are two
    types of overflows that usually happen in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly two types of buffer overflows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap-based overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be covering these in more detail in the later part of the chapter. For
    now, let's clear up some basics, that will help us in exploiting overflow vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting stack-based buffer overflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our basics are clear, let's move on to the exploitation of stack-based
    buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps demonstrate the stack-based buffer overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another simple C program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This program uses a vulnerable method `strcyp()`. We save the program to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then compile the program with `gcc` using the `fno-stack-protector` and
    `execstack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we turn off address space randomization using this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we open our program in `gdb` using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc9e7142-0794-46bb-bdf8-322a513388d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we supply our input using Python using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/985cb9a0-5002-4993-8d7c-8a3e7d86131f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the program crashed and it shows error `0x41414141`. This just
    means that the character we entered, `A`, has overwritten the EIP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We confirm it by typing `i r`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/572fdc5f-2ff5-4bba-b6b4-48eef12325d2.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows us that the value of the EIP register has been successfully overwritten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we find the exact byte that overwrites the EIP. We can do this by entering
    different characters in our program and then checking which of them overwrites
    the EIP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So we run the program again, this time, with different characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8bbcd1-9a6d-4e1f-99a5-b262105e0777.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, we see that the EIP has the value `CCCC`. This implies that the bytes
    we need are somewhere in the last 25 characters we supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We similarly try different combinations of 124 characters until we have the
    position of the exact 4 characters that overwrite the EIP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/691d6b8d-bcf4-4aa5-8019-8f9c0dd9c747.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, since we have found the exact location of the EIP, and in order to perform
    a successful exploitation, we need to overwrite these 4 bytes with the memory
    address where we will store our shellcode. We have about 100 bytes in the memory
    where `A` is stored currently, which is more than enough for our shellcode. So,
    we need to add breakpoints in our debugger, where it will stop before jumping
    to the next instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We list the program using the `list 8` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a365f60-2e6a-4b5a-bfd1-75914c58fb8b.png)'
  prefs: []
  type: TYPE_IMG
- en: And we add our breakpoints in the line where the function is called and after
    it is called using `b <linenumber>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we run the program again, and it will stop at the breakpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/42088718-8f43-41a1-b036-46c996900a12.png)'
  prefs: []
  type: TYPE_IMG
- en: We press `c` to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s see the `esp` (stack pointer) register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1300130-681f-494a-8359-b08e0d3730e9.png)'
  prefs: []
  type: TYPE_IMG
- en: This will show us 16 bytes after the `esp` register, and on the left-hand side
    column, we will see the memory address corresponding to the data being stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we see that data starts at address `0xbffff190`. We note the next memory
    address, `0xbfff1a0`. This is the address we will use to write in the EIP. When
    the program overwrites the EIP, it will make it jump to this address, where our
    shellcode will be stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e448340f-ef70-4c50-8128-34e5fff7bfec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to open a shell by exploiting the overflow. We can find the shellcode
    that will execute a shell for us on Google:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c42bb2b9-3caa-4f65-8a04-43f7eff0c8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: We have 100 bytes and our shellcode is 24 bytes. We can use this one in our
    exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we simply replace the `A`s with the `76` no op assembly instruction (`0x90`)
    and the rest of the 24 bytes with the shellcode, then the `B`s with the memory
    address we want the EIP to point to, and `C`s with the no op code again. This
    should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun the program and pass this as an input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We type `c` to continue from breakpoints, and once execution is done, we will
    have our shell executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploiting buffer overflow on real software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned the basics of exploitation earlier. Now let's try these on
    some of the software already exploited long ago and with public exploits available.
    In this recipe, you will learn about publicly available exploits for old software
    and create your own version of the exploit for it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, we will need an old version of a Windows OS (preferably, Windows
    XP) and a debugger for Windows. I have used Immunity Debugger and an old software
    with a known buffer overflow vulnerability. We will use *Easy RM to MP3 Converter*.
    This version had a buffer overflow vulnerability in playing large M3U files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The free version of Immunity Debugger can be downloaded at [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the given steps to learn about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we download and install our MP3 converter on the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This converter had a vulnerability in playing M3U files. The software crashed
    when a large file was opened for conversion with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a file with about 30,000 `A`s written into it and save it as
    `<filename>.m3u`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2237b2f9-0aa0-4912-80e7-01c65bcc2b91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then drag and drop the file into the player, and we will see that it crashes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24084d91-a809-4a7c-a5e6-bb289d7855aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to find the exact number of bytes that cause the crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Typing so many `A`s manually in a file will take a lot of time, so we write
    a simple Python program to do that for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we play around with bytes to find the exact value of the crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, it came out to be 26,105 as the program did not crash at 26,104
    bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff14a5e0-2a9f-4c2a-8ac8-4b2cf31e5ee6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we run our debugger and attach our running converter program to it by
    navigating to FileÂ | Attach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6ee96ff-ee75-41e1-9695-f6e2d1bb137d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we select the process name from the list of running programs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37bb1dd1-3b80-4193-8bc9-d4198c05a5e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it is attached, we open our M3U file in the program. We will see a warning
    in the status bar of the debugger. We simply click on continue by pressing the
    *F9* key or clicking on the play button from the top menu bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b1bd8d3-d2fb-4640-8104-cbfe0677069d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will see that the EIP was overwritten with `A`s and the program crashed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57f2063e-3b69-42d4-a4ce-3df272fdadad.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to find the exact 4 bytes that cause the crash. We will use the
    script from Kali known as *pattern create*. It generates a unique pattern for
    the number of bytes we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can find the path of the script using the locate command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52b2870-f2a2-42dd-91f8-51a6a93423f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the path, we run the script and pass the number of bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We used 5,000 because we already know it will not crash at 25,000, so we only
    create a pattern for the next 5,000 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have our unique pattern. We now paste this in our M3U file along with 25,000
    `A`s.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We open up our application and attach the process to our debugger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9da7ca5f-52ae-4996-abf2-c5e624cfe55c.png)'
  prefs: []
  type: TYPE_IMG
- en: We then drag and drop our M3U file into the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It crashes and we have our EIP overwritten with 42386b42.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Metasploit has another great script to find the location of the offset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the offset match at `1104`; adding it to the 25,000 `A`s, we now
    know that EIP is overwritten after 26,104 bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a66fd3d6-f421-4b69-8373-154c3d24ad26.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to find out a reliable way of jumping to the shellcode. We do
    this by simply writing extra random characters into the stack after EIP, making
    sure the shellcode we write will be written properly into the memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the program, attach it to the debugger, and let it crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will see the EIP has been overwritten successfully. In the window in the
    bottom-right corner, we right-click and select Go to ESP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc1958bb-6806-4d8b-993e-5d8e1efda69c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we notice that the ESP actually starts from the 5th byte. To make sure
    our shellcode is executed properly, we now need to make sure shellcode starts
    after 4 bytes. We can insert four NOPs to fix this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23e8cfb9-541d-4e8e-8896-63b9bdec3c24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have control over EIP, there are multiple ways to execute our shellcode,
    and we will cover two of them here. The first one is simple: we find the `jmp
    esp` instruction in the code and overwrite the address with it. To do that, we
    right-click and navigate to Search for | All commands in all modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f18c4ddb-e46a-4e5f-aec8-1f44eb248d02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We type the `jmp esp` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/919c5b9a-9e80-4612-913d-db6e215b8f8e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the results box, we see our instruction, and we copy the address for our
    exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/976f95ba-72d9-4eff-b9be-673c1aeca92e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s write an exploit now. The basic concept would be `junk bytes + address
    of jump ESP + NOP bytes + Shellcode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/505d2867-3bd2-4f61-b10e-fa7058d6d247.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can generate the shellcode of the calculator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we run the exploit, and we should see the calculator open once the program
    crashes!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f66e9a99-f581-456c-95d9-a005e49b0e74.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's try another method; suppose there are no `jmp` esps available for us to
    use. In this case, we can use `push esp` and then use the `ret` instruction, which
    will move the pointer to the top of the stack and then call the `esp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We follow the same steps until *step 25*. Then, we right-click and go to Search
    for | All sequences in all modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we type `push esp ret`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb49615b-16b0-447a-bbba-38ac7012266e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the result, we see we have the sequence in the address: `018F1D88`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we simply replace the EIP address in our exploit code with this and run
    the exploit, and we should have a calculator open up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6a07761-4b4d-4742-b69f-aa38900d5c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: SEH bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, we need to understand what SEH is. **SEH** stands for **structured
    exception handling**. We may have often seen programs popping up an error saying
    the *software has encountered a problem and needs to close*. This basically means
    it's the default exception handler of Windows kicking in.
  prefs: []
  type: TYPE_NORMAL
- en: 'SEH handlers can be considered the block of `try` and `catch` statements that
    are executed in order when there''s an exception in the program. This is what
    a typical SEH chain would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f9ef080-d0b9-4e2f-86c9-86aafce20782.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: https://www.corelan.be/wp-content/uploads/2009/07/image_thumb45.png'
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs, the SEH chain comes to the rescue and handles the
    exception based on its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when an illegal instruction occurs, the application gets a chance to handle
    the exception. If no exception handler is defined in the application, we will
    see an error shown by Windows: something like Send a report to Microsoft.'
  prefs: []
  type: TYPE_NORMAL
- en: To perform a successful exploitation of a program with the SEH handler, we first
    try to fill the stack with our buffer and then try to overwrite the memory address
    that stores the first SEH record chain. However, that is not enough; we need to
    generate an error as well, that will actually trigger the SEH handler and then
    we will be able to gain complete control over the execution flow of the program.
    An easy way is to keep filling the stack all the way down, which will create an
    exception to be handled, and since we already have control over the first SEH
    record, we will be able to exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's download a program called AntServer. It has a lot of public exploits available,
    and we will try to build our own exploit for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will install it on the Windows XP SP2 machine that we used in the previous
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AntServer had a vulnerability that could be triggered by sending a long USV
    request to the AntServer running on port `6600`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea4fd8f1-96bc-4169-b405-16cdfaa4739f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the AntServer by opening the software and navigating to Server |
    Run Service Control...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/110334f7-16d2-4b7d-9747-fe7014451572.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s write a simple Python script, that will send a large request to
    this server on port `6600`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Coming back to the Windows machine, let's start Immunity Debugger and attach
    the process `AntServer.exe` to it. And then, click on `Run`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the program is running, we run our Python script from Kali, and in our
    Debugger, we will see a violation error. However, our EIP has not been overwritten
    yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76b1c96e-24e2-4ee9-8a55-2bf78cd130bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the File menu in the debugger, we go to View | SEH chain. Here, we will
    see that the address has been overwritten by `AAAA`. Now we press *Shift*+ *F9*
    to pass an exception to the program. We will see that the EIP has been overwritten,
    and we get an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77e531fa-d148-4908-9c41-8ad662900580.png)'
  prefs: []
  type: TYPE_IMG
- en: We will also notice that the other register values have now become zero. This
    zeroing of registers was introduced in Windows XP SP1 and later in order to make
    SEH exploitation more difficult.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using Windows XP SP2\. It has a feature called **SAFESEH**. When this
    option is enabled in the module, only the memory addresses listed on the registered
    SEH handlers list can be used, which means if we use any address that is not on
    the list, from a module compiled with `/SAFESEH ON`, the SEH address will not
    be used by the Windows exception handler and the SEH overwrite will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few ways to bypass this, and this is one of them: using an overwrite
    address from a module that was not compiled with the `/SAFESEH ON` or `IMAGE_DLLCHARACTERISTICS_NO_SEH`
    options.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find that, we will use a plugin called **mona** for Immunity Debugger. It
    can be downloaded from [https://github.com/corelan/mona](https://github.com/corelan/mona):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a4e6fef0-c9bd-4a0a-ab80-631458aa0a24.png)'
  prefs: []
  type: TYPE_IMG
- en: We simply copy the Python file into the `PyCommands` folder of the Immunity
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move on to making the exploit. We have seen that the EIP has already
    been overwritten. Now we will try to find the exact bytes at which the crash occurs
    using the pattern create script in Kali Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a92070e-e7f6-4ebc-8139-733ababfc285.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code should be something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79e71616-6b73-4c64-8b4a-8c51bfda71b0.png)'
  prefs: []
  type: TYPE_IMG
- en: We now run this file, and in Immunity Debugger, we will see the access violation
    error. We now go to View | SEH chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will see that our SEH has been overwritten with bytes. We copy the `42326742`
    value and find its location using the `pattern_offset` script in Kali:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/627727a0-1665-449e-b580-bf31f157d06f.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a3a41d-f031-4c46-b222-106ce855f3e9.png)'
  prefs: []
  type: TYPE_IMG
- en: We will see that the offset is `966` bytes at which the handler is overwritten.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s modify our exploit a bit and see what happens. We have `966` bytes;
    we will use `962` bytes of As and 4 bytes of breakpoint and 4 with Bs and the
    rest of the bytes with Cs to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We run this and view the SEH chain. Here, we will notice an interesting thing:
    the first 4 breakpoints we added have actually overwritten a memory address, and
    the next 4 have been overwritten into our SEH handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9923fd87-3710-4aa9-ac11-2a4873962b40.png)'
  prefs: []
  type: TYPE_IMG
- en: This happens as the SEH is a pointer that points to the memory address where
    the code is stored when an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pass the exception to the program and we will see that EIP has been overwritten,
    but when we look in the memory, we will see that our Cs have been written approximately
    6 bytes after our Bs in the memory. We can use a `POP RET` followed by a short
    `JUMP` code to jump to our shellcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We type the `!safeseh` command in the debugger''s console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5fe1f24-019f-47fb-b5ac-841de81bcc5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will show us the list of all DLLs that are not compiled using `SAFESEH/ON`.
    In the log window, we will see the list of the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6732dd8a-5f97-4211-97bb-3ba05ebc9e64.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's use a DLL `vbajet32.dll`. Our goal is to find a `POP POP RET` sequence
    in the DLL, that we can use to bypass SEH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We find our DLL on the Windows machine and copy it to Kali. Kali has another
    great tool known as `msfpescan`, that can be used to find the `POP POP RET` sequence
    in the DLL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/227092fd-5f40-4a32-b23e-d3b72b31bfb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have the address for all the `POP POP RET` sequences in the `.dll`.
    We will use the first one, `0x0f9a1f0b`. We also need a short `JUMP` code, that
    will cause a jump to our shellcode or Cs stored in the memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Short `JUMP` is `\xeb\x06`, where `06` is the number of bytes we need to jump.
    We are still 2 bytes short of the 4-byte address space and we can use 2 NOPs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a shellcode; since we are sending this over HTTP, we need to
    make sure we avoid bad characters. We will use msfvenom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a72551c-1e19-414f-a9f1-33d95e744367.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will put everything in the exploit, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a5ad769-7b63-423a-8e12-8068eeaf83ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run this without the debugger this time. We will open our handler in
    Kali, and we should have meterpreter access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44862fbb-f064-4d32-b21d-026f52f9e59d.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/](http://resources.infosecinstitute.com/bypassing-seh-protection-a-real-life-example/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting egg hunters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Egg hunting is used when there is not enough space in the memory to place our
    shellcode consecutively. Using this technique, we prefix a unique tag with our
    shellcode and then the egg hunter will basically search for that tag in the memory
    and execute the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The egg hunter contains a set of programming instructions; it is not much different
    from shellcode. There are multiple egg hunters available. You can learn more about
    them and how they work with this paper by skape: [http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will try to make an exploit with an egg hunter for the same software we
    used in the previous recipe. The logic behind the exploitation would be something
    similar to what is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eba1c6c-372e-4d0e-850e-96b87d14b964.png)'
  prefs: []
  type: TYPE_IMG
- en: Our aim is to overwrite the **nSEH** and then **SEH** in order to make it jump
    to the egg hunter shellcode, which, when executed, will find and execute our shellcode
    in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the steps that demonstrate the use of the egg hunter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the software on Windows XP and attach it to the debugger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a58a884f-8baa-43f0-b726-980a8d468454.png)'
  prefs: []
  type: TYPE_IMG
- en: We already know the crash bytes and the address to bypass the SAFESEH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to add our egg hunter and then use it to jump to our shellcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we know, the egg hunter is a shellcode and the basic rule for using a shellcode
    is to make sure it does not have any bad characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the previous exploit we made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider that the shellcode isn't actually after the 6 bytes of jump we
    made in the memory. In this situation, we can use an egg hunter to make a reliable
    exploit for the software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it may sound easy, but there are some complications. We need our final exploit
    to follow the flow like we mentioned in the diagram, but we also need to make
    sure we have enough NOPs in the code to ensure the exploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what our exploit flow should look like, as in our case, we had enough
    memory to have the shellcode. But in other cases, we may not have so much memory,
    or our shellcode may be stored somewhere else in the memory. In those cases, we
    can go for egg hunting, which we will cover in the later recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98bb2d9f-1042-4142-a474-9d170c4f0a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following the preceding flow diagram, our shellcode would look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We go ahead and save it as `script.py` and run it using `python script.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And, we should have our meterpreter session waiting for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exploit code we wrote may not work in the exact same way on every system
    because there are multiple dependencies depending on the OS version, software
    version, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/](https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.fuzzysecurity.com/tutorials/expDev/4.html](http://www.fuzzysecurity.com/tutorials/expDev/4.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of ASLR and NX bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Address Space Layout Randomization** (**ASLR**) was introduced in 2001 by
    PaX project as a Linux patch and was integrated into Windows Vista and later OS.
    It is a memory protection that protects against buffer overflows by randomizing
    the location where executables are loaded in the memory. **Data Execution Prevention**
    (**DEP**) or **no-execute** (**NX**) was also introduced with Internet Explorer
    7 on Windows Vista, and it helps prevent buffer overflows by blocking code execution
    from the memory, which is marked as non-executable.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to first evade ASLR. There are basically two ways in which ASLR can
    be bypassed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We look for any anti-ASLR modules being loaded in the memory. We will have
    the base address of any module at a fixed location. From here, we can use the
    **Return Oriented Programming** (**ROP**) approach. We will basically use small
    parts of code followed by a return instruction and chain everything to get the
    desired result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84aa6fc8-e246-4289-ae33-e655f26d184b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: https://www.slideshare.net/dataera/remix-ondemand-live-randomization-finegrained-live-aslr-during-runtime'
  prefs: []
  type: TYPE_NORMAL
- en: We get pointer leak/memory leak here, and we adjust the offset to grab the base
    address of the module whose pointer gets leaked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to bypass the NX/DEP. To do this, we use a well-known *ret-to-libc*
    attack (in Linux) or ROP chaining (in Windows).This method allows us to use `libc`
    functions to perform the task we would have done with our shellcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's another method used for bypassing ASLR in 32-bit systems since 32 bit
    is a comparatively small address space compared to 64-bit systems. This makes
    the range of randomization smaller and feasible to brute force.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is pretty much the basic concept behind bypassing ASLR and DEP. There are
    many more advanced ways of writing exploits, and as the patches are applied, every
    day new methods are discovered to bypass those.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/](https://www.trustwave.com/Resources/SpiderLabs-Blog/Baby-s-first-NX-ASLR-bypass/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://taishi8117.github.io/2015/11/11/stack-bof-2/](http://taishi8117.github.io/2015/11/11/stack-bof-2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.exploit-db.com/docs/17914.pdf](https://www.exploit-db.com/docs/17914.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html](http://tekwizz123.blogspot.com/2014/02/bypassing-aslr-and-dep-on-windows-7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/](https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: Chapter 5. WPA/WPA2 Cracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine the **Wi-Fi Protected Access** (**WPA/WPA2**)
    protocol and take a look at the techniques and the tools to recover the encryption
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to WPA/WPA2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA cracking with Aircrack-ng
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA cracking with Cowpatty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA cracking with the GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WPA cracking with automated tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to WPA/WPA2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WPA/WPA2 are two different versions of a security protocol developed by
    the Wi-Fi Alliance to substitute WEP as the security standard for 802.11 protocols.
    The WPA protocol was first published in 2003 and was in turn replaced by its successor
    WPA2 in 2004, as part of the IEEE 802.11i standard. Both WPA and WPA2 support
    two authentication modes: **WPA-Personal** and **WPA-Enterprise**. In the WPA-Personal
    mode, a **preshared key** (**PSK**) is used for authentication and there is no
    need for an authentication server. The PSK could be a passphrase of 8 to 63 printable
    ASCII characters. While, the WPA-Enterprise mode requires an authentication server
    that communicates with the access point (AP) with the RADIUS protocol and clients
    are authenticated using the **Extensible Authentication Protocol** (**EAP**).
    We will see attacks against WPA-Enterprise in detail in [Chapter 6](ch06.html
    "Chapter 6. Attacking Access Points and the Infrastructure"), *Attacking Access
    Points and the Infrastructure*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on attacking the WPA-Personal authentication.
    WPA-Personal and WPA-Enterprise share the authentication process between the AP
    and the client (STA in the following diagram), that is called the **Four-way handshake**.
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to WPA/WPA2](img/B04527_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The four phases of the authentication process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, a 256 bit **Pairwise Master Key** (**PMK**) is independently
    established by both parties. It is generated from the PSK and the network SSID.
    Then the AP sends a random number, the **A-Nonce**, to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends a random **S-Nonce** to the AP, plus a **Message Integrity
    Code** (**MIC**). Meanwhile, the client computes a **Pairwise Transient Key**
    (**PTK**) that will be used to encrypt the traffic. The PTK is derived from the
    PMK, the A-Nonce, the S-Nonce, and the MAC addresses of both the client and the
    AP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AP derives the PTK itself and then sends to the client a **Group Temporal
    Key** (**GTK**), used to decrypt multicast and broadcast traffic, and a MIC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends an acknowledgement to the AP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the four-way handshake, we can notice that, unlike WEP, the encryption
    key (the PTK) is unique, because it is a function of the parameters related to
    the handshake process and it is never exchanged between the AP and the client.
    WPA uses the **Temporal Key Integrity Protocol** (**TKIP**) encryption protocol
    that was developed by the Wi-Fi Alliance to temporarily replace WEP encryption,
    but some vulnerabilities have also been discovered and it has been deprecated
    in the latest versions of the 802.11 standard.
  prefs: []
  type: TYPE_NORMAL
- en: WPA2 uses **CCMP** (**Counter Cipher Mode Protocol**) by default, which is a
    protocol based on the **Advanced Encryption Standard** (**AES**)—the de facto
    standard symmetric encryption algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: To learn the details of the WPA/WPA2 implementation and of the attacks that
    we are going to cover in the next section, refer to the links in [Appendix](apa.html
    "Appendix A. References"), *References*.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the WPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WPA/WPA2 protocol (hereafter, simply WPA) is considered secure because it
    relies on strong authentication and encryption protocols, especially WPA2 with
    AES-CCMP. Next, we show that it is vulnerable only if weak PSKs are used.
  prefs: []
  type: TYPE_NORMAL
- en: TKIP has been proved to be vulnerable to attacks that could lead to packet decryption
    and injection, but not to the PSK recovery. For PSK cracking, we need to capture
    the four handshake frames, that give us all the parameters from which the PTK
    is calculated, including the MIC used to check whether our candidate key is correct
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the captured packet file, we can attempt to crack the key either
    by launching an offline *brute force attack* or a *dictionary attack* on it. A
    brute force attack implies checking the entire key space, that is all the possible
    combinations of characters that could form the key. To be feasible, the PSK must
    be short. Otherwise, a strong PSK would require a very long time to be cracked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have an idea of the amount of time required, we need to estimate it through
    one of the brute force calculators available online, for example, the one at [http://calc.opensecurityresearch.com/](http://calc.opensecurityresearch.com/).
    Assuming that we could test 100,000 keys per second, which is a fairly high rate,
    and the charset of the key is alphanumeric, we could be surprised to discover
    the time needed to crack an 8-character long key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the WPA](img/B04527_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a 63-character long key, it is quite discouraging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attacking the WPA](img/B04527_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a dictionary attack, we instead need to test all the words contained in a
    dictionary file or wordlist. To succeed, the key must be included in the wordlists
    used.
  prefs: []
  type: TYPE_NORMAL
- en: There are some techniques to speed up the cracking process. For a dictionary
    attack, one technique is to use a list (or table) of precomputed hashes, also
    called a *rainbow table*, instead of a wordlist. In this way, we precompute the
    PMKs from the words of a dictionary file and store them in the rainbow table.
    The drawbacks are that each network ESSID requires its rainbow table, as the PMK
    also depends on the ESSID, and that a large amount of disk space is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique to accelerate the process is to exploit the computational
    power of the **Graphical Processing Unit** (**GPU**) of recent video cards.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to crack a WPA key leveraging the GPU later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WPA cracking with Amazon Linux AMI**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting and relatively new way to crack a WPA key is to use the Amazon
    Linux AMI with the NVIDIA GRID GPU Driver enabled, provided by Amazon EC2\. The
    AMI (Amazon Machine Image) allows leveraging the processing power of a NVIDIA
    GPU with 1,536 CUDA cores and 4 GB of video memory. For more information, read
    the guide available at [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cluster_computing.html](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cluster_computing.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are also online, cloud-based services that allow, upon payment of a fee,
    to crack WPA/WPA2 keys, just providing the four-way handshake file and the network
    SSID.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this kind of service is CloudCracker—[https://www.cloudcracker.com/](https://www.cloudcracker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we are going to cover the cracking process of a WPA
    PSK using the Aircrack-ng suite and Cowpatty.
  prefs: []
  type: TYPE_NORMAL
- en: WPA cracking with Aircrack-ng
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we have mentioned that to crack a WPA key, we must
    first capture the four frames related to a WPA handshake between the target AP
    and a client. To do so, we could passively wait for a client to authenticate successfully,
    completing the handshake, and capture the relative frames. In some cases, we will
    need to wait a little longer, so we could accelerate the process deauthenticating
    an already connected client, inducing it to re-authenticate with the AP (the *deauthentication
    attack*).
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by putting, as usual, our wireless interface in monitor mode with
    the `airmon-ng start wlan0` command and then run `airodump-ng`, using the BSSID
    and the channel of our target AP as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![WPA cracking with Aircrack-ng](img/B04527_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a client authenticates to the AP, the first line of the airodump-ng output
    displays the occurred WPA handshake. In this case, airodump-ng saves the captured
    handshake in the `wpa_crack` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no handshake occurs, but a client is already connected and we are not too
    far from it, we could deauthenticate it from the AP with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `--deauth` (or -0) is for the deauthentication attack, `1` stands for
    one bunch of frames to send, `-c` is the MAC address of the client, and `-a` is
    the MAC address of the AP.
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA cracking with Aircrack-ng](img/B04527_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the attack is successful, we should see the client reconnect in a short time
    and we could then capture the WPA handshake.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have captured the handshake, we can proceed to crack the key with aircrack-ng,
    specifying the dictionary file or wordlist to use. Aircrack-ng would be able to
    find the WPA PSK only if it is present in the dictionary file used.
  prefs: []
  type: TYPE_NORMAL
- en: There are many wordlists available on the Web and some are listed at [http://www.aircrack-ng.org/doku.php?id=faq#where_can_i_find_good_wordlists](http://www.aircrack-ng.org/doku.php?id=faq#where_can_i_find_good_wordlists).
  prefs: []
  type: TYPE_NORMAL
- en: Wordlists are also included by default in Kali Linux, under `/usr/share/wordlists`,
    where the `rockyou.txt.gz` file provides a large compressed wordlist to use.
  prefs: []
  type: TYPE_NORMAL
- en: Custom wordlists can be created with the **crunch** tool (type `man crunch`
    for the manual page).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we use the `rockyou.txt.gz` wordlist, so we first unzip it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To reduce the number of words to try, we must consider that the PSK is composed
    by a minimum of eight characters and a maximum of 63 characters. Thus, we can
    create, from `rockyou.txt`, a new wordlist that meets these requirements. A tool
    that allows you to filter and reduce a wordlist is **pw-inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the new wordlist `wparockyou.txt` by giving `rockyou.txt` as the
    input to pw-inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we execute the dictionary attack with `aircrack-ng`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![WPA cracking with Aircrack-ng](img/B04527_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a variable amount of time, if the key is found in the wordlist used,
    aircrack-ng returns it in the output, along with the elapsed time, the number
    of tested keys, and the testing speed, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA cracking with Aircrack-ng](img/B04527_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we want to conduct a dictionary attack using a rainbow table, we can use
    the `airolib-ng` tool that creates databases of network ESSIDs with the relative
    precomputed PMKs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a database `wpa_db` of our target network, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we import the dictionary file we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before proceeding to calculate the PMKs, it is advisable to clean and optimize
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![WPA cracking with Aircrack-ng](img/B04527_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we compute the PMKs with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can execute `aircrack-ng` on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: WPA cracking with Cowpatty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to aircrack-ng is Cowpatty, an easy-to-use and effective tool
    for WPA PSK cracking, developed by **Joshua Wright**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its usage is very similar to that of aircrack-ng, as it takes as input a packet
    capture containing the four-way handshake and a wordlist, plus the network ESSID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![WPA cracking with Cowpatty](img/B04527_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the following screenshot, the cracked PSK is displayed in
    the output. Cowpatty like aircrack-ng, also shows the elapsed time, the number
    of passphrases tested, and the rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WPA cracking with Cowpatty](img/B04527_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Cowpatty can also take a rainbow table as the input. To build it from our wordlist,
    we use the `genpmk` tool, by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![WPA cracking with Cowpatty](img/B04527_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we launch the program, specifying the rainbow table with the `-d` option
    instead of the wordlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: WPA cracking with the GPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GPUs of recent video cards usually comprise a large number of cores that
    can execute threads concurrently, resulting in faster performing of complex calculations
    than a CPU.
  prefs: []
  type: TYPE_NORMAL
- en: To be suitable for **general purpose computing** (**GPGPU**), the GPU must support
    the NVIDIA **Compute Unified Device Architecture** (**CUDA**) or the **Open Computing
    Language** (**OpenCL**) platforms, which allow normal programs to access and take
    advantage of the hardware of the GPU when executing specified portions of code.
  prefs: []
  type: TYPE_NORMAL
- en: The two most popular programs included in Kali Linux that make use of the GPU
    to crack passwords are **Pyrit** and **oclHashcat**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Getting ready for GPU cracking**'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is worth specifying that GPU-based cracking tools don't work
    in a virtual machine, as they need direct access to the physical video card. So,
    we need to run them in a native installation of Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: To do GPU cracking, we first need to check that the proper drivers for our video
    card are installed. We must install the proprietary drivers for the relative cards
    (NVIDIA or AMD/ATI), if we want to use CUDA or OpenCL.
  prefs: []
  type: TYPE_NORMAL
- en: A useful reference is [http://docs.kali.org/general-use/install-nvidia-drivers-on-kali-linux](http://docs.kali.org/general-use/install-nvidia-drivers-on-kali-linux)
    for NVIDIA cards, while for AMD/ATI cards the following post might be helpful
    [https://forums.kali.org/showthread.php?17681-Install-AMD-ATI-Driver-in-Kali-Linux-1-x](https://forums.kali.org/showthread.php?17681-Install-AMD-ATI-Driver-in-Kali-Linux-1-x).
  prefs: []
  type: TYPE_NORMAL
- en: We also need to install the NVIDIA CUDA Toolkits or the AMD APP SDK (refer [Appendix](apa.html
    "Appendix A. References"), *References*).
  prefs: []
  type: TYPE_NORMAL
- en: Pyrit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pyrit is a tool written in Python that supports both CPU and GPU cracking, the
    latter through CUDA and OpenCL modules. With the latest video cards, Pyrit is
    able to compute up to 100,000 **PMKs** (**Pairwise Master Keys**) per second,
    speeding up the cracking process a lot compared to relying only on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Pyrit works by taking as input a dictionary file, like aircrack-ng does, or
    by using a database of precomputed PMKs for our target ESSID.
  prefs: []
  type: TYPE_NORMAL
- en: The latter method is much faster, but requires you to create the database previously
    or to use a prebuilt database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, the command to launch would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Pyrit](img/B04527_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `attack_passthrough` specifies the attack with a dictionary file, `-r`
    specifies the packet capture, and `-i` the wordlist to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, when a database is used, we first add the ESSID to the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we import the dictionary file into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Pyrit](img/B04527_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we compute the PMKs from the relative passwords with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can run the cracking process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: oclHashcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The oclHashcat tool is a powerful GPGPU-based multihash cracker that supports
    both the CUDA and OpenCL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: OclHashcat is the GPGPU version of the popular **Hashcat** tool and it is a
    fusion of the previous versions *oclHashcat-plus* and *oclHashcat-lite*. It supports
    many hashing algorithm attacks, among which are the dictionary and the brute force
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'OclHashcat doesn''t accept packet capture in the `.cap` format, but it must
    be converted in its own format `.hccap`. To do so, we can use aircrack-ng:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform the dictionary attack against the captured handshake, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `-m 2500` specifies the WPA attack mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a brute force attack, for example, on an eight characters PSK formed
    by four lowercase letters and four digits, we will need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, oclHashcat has its own built-in charsets that we could use to define
    masks, that is, strings that configure the key space of the passwords we want
    to crack.
  prefs: []
  type: TYPE_NORMAL
- en: WPA cracking with automated tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we covered two automated tools to crack WEP (and also
    WPA) keys: Wifite and Fern WiFi Cracker.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we showed a practical example of WEP cracking with
    Fern WiFi Cracker; in this chapter, we will see how to crack a WPA key using Wifite.
  prefs: []
  type: TYPE_NORMAL
- en: Wifite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, Wifite is a tool based on the Aircrack-ng suite. By
    default, it relies on aircrack-ng for WPA cracking, but also supports Cowpatty,
    Pyrit, and oclHashcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To crack a WPA key, we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Wifite](img/B04527_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The program scans for WPA wireless networks and displays the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wifite](img/B04527_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we have identified our target network, we press *Ctrl* + *C* and select
    the network (in this case the number `1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wifite](img/B04527_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wifite starts listening to capture a WPA handshake.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the program begins the cracking process, using the dictionary file
    provided earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wifite](img/B04527_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, it returns the cracked key and displays the other relative information
    like aircrack-ng does (elapsed time, number of tested keys, and the rate):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wifite](img/B04527_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If no handshake is captured, Wifite tries to deauthenticate a connected client,
    automatizing the deauthentication attack performed by aireplay-ng.
  prefs: []
  type: TYPE_NORMAL
- en: We can also choose to use other tools to crack the key instead of aircrack-ng,
    specifying the relative option (for example, Pyrit or Cowpatty).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the WPA/WPA2 security protocol and analyzed
    how to capture the WPA four-way handshake and use it to crack the PSK with the
    many tools available on Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an attack against **Wi-Fi Protected Setup** (**WPS**) deployments
    that can lead to WPA PSK recovery in a relatively short time. We will cover this
    and other attacks against access points in [Chapter 6](ch06.html "Chapter 6. Attacking
    Access Points and the Infrastructure"), *Attacking Access Points and the Infrastructure*.
  prefs: []
  type: TYPE_NORMAL

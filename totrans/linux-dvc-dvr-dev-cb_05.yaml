- en: Managing Interrupts and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When implementing a device driver, a developer has to resolve two main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: How to exchange data with peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage interrupts that peripherals generate to the CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point was covered (at least for char drivers) in previous chapters,
    while the second one (and its related matter) will be the main topic of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the kernel, we can consider the CPU (or the internal core executing some
    code) running in two main execution contexts — the **interrupt context** and the
    **process context**. The interrupt context is very easy to understand; in fact,
    the CPU is in this context each time it executes an interrupt handler (that is,
    special code the kernel executes each time an interrupt occurs). In addition to
    this, interrupts can be generated by the hardware or even by the software; that's
    why we talk about hardware interrupts and software interrupts (we'll take a closer
    look at software interrupts in the following sections), which in turn define the
    **hardware interrupt context** and the **software interrupt context**.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the **process context** is when the CPU (or one of its internal
    cores) executes some code of a process in the kernel space (processes also execute
    in the user space, but we are not covering that here), that is, when the CPU executes
    the code of a system call that has been invoked by a process (see [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*). In this situation, it's very common to yield the
    CPU and then suspend the current process because some data from the peripheral
    is not ready to be read; for instance; this can be done by asking to the scheduler
    to take the CPU and then assign it to another process. When this happens we usually
    say that the current **process has gone to sleep,** and when data is newly available
    we say that a **process has been awakened**, and, it restarts its execution where
    it was previously interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to do all these actions, how a device driver
    developer can ask the kernel to suspend the current reading process because the
    peripheral is not ready to serve the request, and also how to wake up a sleeping
    process. We'll also see how to manage concurrent access to our driver's methods
    to avoid data corruption due to a race condition, and how to manage time flow
    in order to do a specific action after a well-defined amount of time, respecting
    the possible time constraints a peripheral may require.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also look at how to exchange data between a char driver and the userspace,
    and how to handle those kernel events a driver should be able to manage. The first
    (and probably the most important) example is how to manage interrupts, followed
    by how to defer a job "later in time," and how to wait for an event. We can do
    all these using the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interrupt handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing time with kernel timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on this chapter, you can visit the *Appendix*.
  prefs: []
  type: TYPE_NORMAL
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_05).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interrupt handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the kernel, an **interrupt handler** is a function associated with a
    CPU interrupt line (or pin) that Linux executes whenever the peripheral connected
    with this line changes the pin status; when this happens, an interrupt request
    is generated for the CPU, and it's captured by the kernel, which in turn executes
    the proper handler.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to install an interrupt handler which the kernel
    executes each time an interrupt occurs on a well-defined line.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest code to implement an interrupt handler is the code in `linux/drivers/misc/dummy-irq.c`.
    Here is the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code to install or to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is really simple, and, as we can see, it calls the `request_irq()`
    function in the `dummy_irq_init()` module initialization function, and the `free_irq()`
    function in the `dummy_irq_exit()` module exit function. Then, these two functions
    respectively ask the kernel to connect the `dummy_interrupt()` interrupt handler
    to the `irq` interrupt line and, in the opposite operation, to detach the handler
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: This code briefly shows how to install an interrupt handler; however, it doesn't
    show how a device driver's developer can install its own handler; that's why in
    the next section we're going to do a practical example using a real interrupt
    line simulated with a General Purpose Input Output line (GPIO).
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement a management for our first **interrupt request** (**IRQ**)
    handler, we can use a normal GPIO as an interrupt line; however, before doing
    so, we have to verify that our GPIO line correctly detects high and low input
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: To manage GPIOs we're going to use its sysfs interface so, first of all, we
    have to verify that it is currently enabled for our kernel by checking if the
    `/sys/class/gpio` directory exists. If not we'll have to enable the `CONFIG_GPIO_SYSFS`
    kernel configuration entry by using the kernel configuration menu (`make menuconfig`);
    the can be done by going to Device Drivers, then GPIO Support, and enabling the
    /sys/class/gpio/... (sysfs interface) menu entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to quickly check if the entry is enabled is by using the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if it is not enabled, we''ll get the following output, and then
    we must enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is in place, we should get something something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `gpiochip446` and `gpiochip476` directories represent the two ESPRESSObin's
    GPIOs controller as we saw in the previous chapter describing the device tree.
    (See *The Armada 3720* section in Appendix of [Chapter 4](fdfcddc8-11dc-4e60-8653-a3fd8970d70d.xhtml),
    *Using the Device Tree,* *Configuring CPU's pins for specific peripherals* section).
    The `export` and `unexport` files are used to get access to GPIO lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do our job, we need to get access to the MPP2_20 CPU line, which is mapped
    on pin 12 of the ESPRESSObin extension #2; that is, the connector P8 (or J18)
    on the ESPRESSObin schematics. (See the *Technical requirements* section in [Chapter
    1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), I*nstalling the Development System*).
    In the CPU datasheet, we discover that the MPP2_20 line is attached to the second
    pinctrl controller (named south bridge and mapped as `pinctrl_sb: pinctrl@18800`
    in the device tree). To know which is the right gpiochip device to use, we can
    still use the sysfs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now clear that we have to use `gpiochip446`. In that directory, we will
    find the `base` file that tells us the corresponding number of the first GPIO
    line, and, since we''re using the 20th line, we should export the `base+20` GPIO
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works well, a new `gpio466` entry is now present in the `/sys/class/gpio`
    directory, corresponding to our just exported GPIO line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! The `gpio466` directory is now ready to be used, and, by taking a look
    inside it, we get the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To see if we are able to modify our GPIO line, we can simply use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the line is set to 1, even if unconnected, because this pin is normally
    configured with an internal pull-up that forces the pin state to the high level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This output tells us that the GPIO line 20 is currently high, but, if we connect
    pin 12 of the P8 connector to the ground (pin 1 or 2) of the same connector (P8/J8),
    the GPIO line should go to the downstate and the preceding command should now
    return 0, instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the line doesn''t change, you should verify that you''re working on the
    correct pins/connector. Also, you should take a look at the `/sys/class/gpio/gpio466/direction`
    file, which should hold the `in` string, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`# cat /sys/class/gpio/gpio466/direction`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`in`'
  prefs: []
  type: TYPE_NORMAL
- en: OK. Now we are ready to generate our interrupts!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume that we have a dedicated platform driver named `irqtest`
    , defined as follows in the ESPRESSObin device tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the ESPRESSObin device tree file is `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have to add a platform driver to the kernel as we did in the previous
    chapter with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all code presented here can be obtained from the GitHub repository
    by applying the `add_irqtest_module.patch` patch within the root directory of
    kernel sources by executing the `patch` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ patch -p1 < ../linux_device_driver_development_cookbook/chapter_5/add_irqtest_module.patch**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know that, once the kernel detects in the device tree that a driver
    is compatible with `ldddc,irqtest`, the following `irqtest_probe()` probing function
    should be executed. This function is very similar to the one in the preceding
    `linux/drivers/misc/dummy-irq.c` file, even if a bit more complex. In fact, first
    we have to read from the device tree which is the GPIO line where interrupts will
    come from, by using the `of_get_gpio()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to ask the kernel for the GPIO line, by using the `devm_gpio_request()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After we are sure that the GPIO is for us only, we have to set it up as an
    input (interrupts are incoming signals) using the `gpio_direction_input()` function,
    and then we have to get the corresponding interrupt line number (which, very often,
    is a different number) by using the `gpio_to_irq()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have all the necessary information to install our interrupt
    handler using the `request_irq()` function defined in the `linux/include/linux/interrupt.h`
    header file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `handler` parameter specifies the function to be executed as an
    interrupt handler and `dev` is a pointer, which the kernel will pass as-is to
    the handler when executed. In our example, the interrupt handler is defined as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 1*, the node declares a device compatible with the driver named `ldddc,irqtest`,
    that requires for its usage the GPIO line 20 of the `gpiosb` node, defined as
    follows in the Armada 3270 device tree `arch/arm64/boot/dts/marvell/armada-37xx.dtsi`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the confirmation that the `gpiosb` node is related to MPP2 lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2* we just declare the driver within the kernel while in *step* *3*,
    the function gets GPIO information from the `gpio` property, and, by using the
    second argument set to `0`, we simply ask for the first entry. The return value
    is saved into the module''s data structure, which is now defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In step 4, in reality, the `devm_gpio_request()` call is not strictly needed
    since we're in the kernel and nobody can stop us using a resource; however, if
    all drivers do this, we can ensure that we're informed if someone else is holding
    the resource!
  prefs: []
  type: TYPE_NORMAL
- en: We should now notice that the `devm_gpio_request()` function does not have a
    counterpart in the module's `exit()` function `irqtest_remove()` . This is because
    functions with the `devm` prefix are related to managed devices that are able
    to automatically deallocate resources when the owner device is removed from the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `linux/drivers/gpio/devres.c` file, where this function is defined,
    we see the following comment, which explains how this function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* devm_gpio_request - request a GPIO for a managed device`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* @dev: device to request the GPIO for`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* @gpio: GPIO to allocate`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* @label: the name of the requested GPIO`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* Except for the extra @dev argument, this function takes the`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* same arguments and performs the same function as`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* gpio_request(). GPIOs requested with this function will be`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* automatically freed on driver detach.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* If an GPIO allocated with this function needs to be freed`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* separately, devm_gpio_free() must be used.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is advanced resource management and beyond the scope of this book. However,
    if you are interested, there is a lot of information on the internet, and the
    following is a good article to start with: [https://lwn.net/Articles/222860/](https://lwn.net/Articles/222860/).'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway the normal counterparts of the `devm_gpio_request()` function are the
    `gpio_request()` and `gpio_free()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, note that a GPIO line number almost never corresponds to an interrupt
    line number; that's why we need to invoke the `gpio_to_irq()` function in order
    to get the correct IRQ line related to our GPIO line.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we can see the `request_irq()` function is a special case of the
    `request_threaded_irq()` function, which informs us that an interrupt handler
    can run in an interrupt context, or inside a kernel thread that is in a process
    context.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, we still don't know what kernel threads are (they will be explained
    in [Chapter 6](ed0f6f71-13aa-413b-ac84-b4e833caa071.xhtml), *Miscellaneous Kernel
    Internals*), but it should be easy to understand that they are something like
    a thread (or process) executed in the kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: Also the `request_any_context_irq()` function can be used to delegate the kernel
    to automatically request a normal interrupt handler or a threaded one depending
    of the IRQ line characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: This a really advanced use of interrupt handlers, which is fundamental when
    we have to manage peripherals (such as I2C or SPI devices) where we need to suspend
    the interrupt handler to be able to read from, or write data to, the peripheral's
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these aspects, all the `request_irq*()` functions take several parameters.
    First of all, the `irq` line, then a symbolic `name` describing the interrupt
    line we can find in the `/proc/interrupts` file, and then we can use the `flags`
    argument to specify some special settings, shown as follows (see the `linux/include/linux/interrupt.h`
    file for a complete list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `IRQF_SHARED` flag should be used when the IRQ line is shared with more
    than one peripheral. (Nowadays it is quite useless but, in the past, it was very
    useful, especially on x86 machines.) The `IRQF_ONESHOT` flag is used by the system
    to be sure that even threaded interrupt handlers can run with their own IRQ line
    disabled. The `IRQF_NO_SUSPEND` flag can be used to allow our peripheral to wake
    the system from a suspended state, by sending a proper interrupt request. (See
    the `linux/Documentation/power/suspend-and-interrupts.txt` file for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: Then the `IRQF_TRIGGER_*` flag can be used to specify the IRQ trigger mode for
    our peripheral, that is, if the interrupt must be generated on high or low levels
    or during a rising or falling transition.
  prefs: []
  type: TYPE_NORMAL
- en: These last flag groups should be carefully checked against the device tree pinctrl
    settings; otherwise, we might see some unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In step 7, since in the `request_irq()` function we set the `dev` parameter
    to the pointer of the `struct irqtest_data` module, when the `irqtest_interrupt()`
    interrupt handler executes, it will find in the `dev_id` argument the same pointer
    we supplied to `request_irq()`. By using this trick, we can get back the `dev`
    value we got from the probing function, and we can safely reuse it as an argument
    of the `dev_info()` function, as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the interrupt handler does almost nothing but display a message.
    However, usually in the interrupt handler, we have to acknowledge the peripheral,
    read from or write data to it, and then wake up all the sleeping processes that
    are waiting for peripheral activities. In any case, at the end, the handler should
    return one value from the ones listed in the `linux/include/linux/irqreturn.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `IRQ_NONE` value is useful in case we're working on a shared interrupt to
    inform the system that the current IRQ is not for us, and that it must be propagated
    to the next handler, while `IRQ_WAKE_THREAD` should be used in the case of threaded
    IRQ handlers. Of course, `IRQ_HANDLED` must be used to report to the system that
    the IRQ has been served.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to check how this works, we can do so by testing our example. We
    have to compile it and then reinstall the kernel with our code compiled as built-in,
    so let''s use the usual `make menuconfig` command and enable our testing code,
    or just use `make oldconfig`, answering `y` when the system asks for a choice,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we''ve just to recompile and reinstall the kernel and then reboot
    the ESPRESSObin. If everything works well during the boot sequence, we should
    see kernel messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the MPP2_20 line has been taken by the kernel and converted into the number
    40 interrupt line. To verify it, we can take a look at the `/proc/interrupts`
    file, which holds all registered interrupt lines within the kernel. Earlier, we
    used the `irqtest` label in the `request_irq()` function during an interrupt handler
    registration, so we have to search for it within the file with `grep` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'OK. The interrupt line 40 has been assigned to our module, and we notice that
    this IRQ line corresponds to the GPIO line 20 of the GPIO2 group (that is, the
    MPP2_20 line). If we take a look at the beginning of the `/proc/interrupts` file,
    we should get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first number is the interrupt line; the second and third ones show how many
    interrupts have been served by the CPU0 and CPU1, respectively, so we can use
    this information to verify which CPU served our interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK. Now we''re ready to go. Just connect pin 12 to pin 1 of the P8 extension
    connector; at least one interrupt should be generated and a message, such as the
    following, should appear in the kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that you may get several messages due to the fact that, during the short
    circuit operation, the electrical signal may generate several oscillations, which
    in turn will generate several interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, let''s take a look at what happens if we try to export the
    number 466 GPIO line, as we did earlier, using the sysfs interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we correctly get a busy error due to the fact such a GPIO has been requested
    by the kernel when we used the `devm_gpio_request()` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about interrupts handlers, a good starting point ( even
    if it is slightly outdated) is The Linux Kernel Module Programming Guide at [https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)[.](https://www.tldp.org/LDP/lkmpg/2.4/html/x1210.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interrupts are events generated by peripherals, but, as said earlier, they are
    not the only events that the kernel can handle. In fact, software interrupts exist,
    which are similar to hardware interrupts but generated by software. In this book,
    we'll see two examples of such software interrupts; both of them can be used to
    safely defer a job for a future time. We'll also have a look at a useful mechanism
    that a device driver developer can use to catch special kernel events and perform
    actions as a consequence (for instance, when a network device is enabled, or the
    system is doing a reboot, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to defer a job when a specific event happens
    within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since tasklets and workqueues were implemented to defer jobs, their main usage
    is in an interrupt handler where we just acknowledge the Interrupt Request (usualy
    named IRQ), and then we invoke the tasklet/workqueue to finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: However, don't forget that this is just only one of the several possible usage
    of tasklets and workqueues that, of course, can be used even without interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to present simple examples regarding both tasklets
    and workqueues by using patches against the previous `irqtest.c` example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, whenever needed, we're going to present more complex usages
    of these mechanisms, but, for the moment, we're interested in understanding their
    basic usage only.
  prefs: []
  type: TYPE_NORMAL
- en: Tasklets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modifications are needed to add a custom tasklet invocation to
    our `irqtest_interrupt()` interrupt handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The previous patch can be found in the GitHub resources in the `add_tasklet_to_irqtest_module.patch`
    file, and it can be applied as usual with the
  prefs: []
  type: TYPE_NORMAL
- en: '**`patch -p1 < add_tasklet_to_irqtest_module.patch`** command.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the tasklet has been defined, it can be invoked by using the `tasklet_schedule()`
    function as shown previously. To stop it, we can use the `tasklet_kill()` function,
    which was in our example for the `irqtest_remove()` function to stop the tasklet
    before unloading the module from the kernel. In fact, we must make sure that every
    resource previously allocated and/or enabled by our driver has been disabled and/or
    released before unloading our module or a memory corruption can occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the compile-time usage of `DECLARE_TASKLET()` is not the only way
    to declare a tasklet. In fact, the following is an alternate way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our tasklet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding patch can be found in the GitHub resources in the `add_tasklet_2_to_irqtest_module.patch`
    file, and it can be applied as usual with the
  prefs: []
  type: TYPE_NORMAL
- en: '**`patch -p1 < add_tasklet_2_to_irqtest_module.patch`** command.'
  prefs: []
  type: TYPE_NORMAL
- en: This second form is useful when we have to embed a tasklet inside a device structure
    and then generate it dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Workqueues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now take a look at workqueues. In the following example, we add a custom
    workqueue referenced by the `irqtest_wq` pointer and named `irqtest`, which, in
    turn, executes two different works described by the `work` and `dwork` structures:
    the former is a normal work, while the latter represents a delayed work, that
    is, a work that is executed after a well-known delay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to add our data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All these modifications can be found in the GitHub resources in the `add_workqueue_to_irqtest_module.patch`
    file and it can be applied as usual with the
  prefs: []
  type: TYPE_NORMAL
- en: '**`patch -p1 < add_workqueue_to_irqtest_module.patch`** command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have to create the workqueue and it works. For the workqueue creation,
    we can use the `create_singlethread_workqueue()` function, while the two works
    can be initialized by using `INIT_WORK()` and `INIT_DELAYED_WORK(),`, shown as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To create a workqueue, we can also use the `create_workqueue()` function; however,
    this creates a workqueue that has a dedicated thread for each processor on the
    system. In many cases, all those threads are simply overkilled and the single
    worker thread obtained with `create_singlethread_workqueue()` will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Concurrency Managed Workqueue API, available in the kernel's documentation
    file (`linux/Documentation/core-api/workqueue.rst`), states that the `create_*workqueue()`
    functions are deprecated and scheduled for removal. However, they seem to be still
    widely used with kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are the handlers bodies representing the effective workloads for the normal
    workqueue and the delayed workqueue, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that to specify a delay of two seconds we used the `2*HZ `code, where `HZ`
    is a define (see the next section for further information about `HZ`) representing
    how many jiffies are needed to compose one second. So, to have a delay of two
    seconds, we have to multiply `HZ` by two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interrupt handler now just uses the following `queue_work()` function to
    execute the first workqueue before returning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, when `irqtest_interrupt()` ends, the system invokes `irqtest_work_handler()`
    which in turn, invokes `irqtest_dwork_handler()` with a two-second delay by using
    `queue_delayed_work()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as for tasklets, before exiting the module, we have to cancel all
    works and workqueues (if created) by using `cancel_work_sync()` for normal work,
    `cancel_delayed_work_sync()` for delayed work, and (in our case) `flush_workqueue()`
    to stop the `irqtest` workqueue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can check how it works, by testing our examples. So, we have to apply the
    desired patch and then we have to recompile the kernel, reinstalling and rebooting
    the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: Tasklets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test tasklets, we can do exactly as before, that is, connecting pin 12 to
    pin 1 of extension connector P8\. The following are the kernel messages we should
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As expected, an IRQ is generated and then managed by the hardware `irqtest_interrupt()`
    interrupt handler that, in turn, executes the `irqtest_tasklet_handler()`. tasklet
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Workqueues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test workqueues, we have to short circuit our well known pins, and we should
    have an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that, this time, I didn't remove the first part of kernel messages, in
    order to see timings, and to better evaluate delay between the normal work and
    delayed one.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, as soon as we connect ESPRESSObin pins, we have several interrupts
    followed by the work, but the delayed work is executed just once. This happens
    because, even if scheduled several times, it's just the first invocation that
    takes effect, and so here we can see that the delayed work has been finally executed
    2.025106 seconds after its first `schedule_work()` invocation. This also means
    that it has been effectively executed 25.106 ms later than the required and expected
    two seconds. Such an apparent anomaly is due to the fact that, when you ask the
    kernel to schedule some work to happen at a later point in time with a delayed
    workqueue, the kernel will certainly schedule your work at the desired point in
    the future, but it won't guarantee you that it will be executed at exactly that
    point in time. It will only assure you that such work won't be executed any earlier
    than the requested deadline. The length of such an additional random delay depends
    on the level of system workload at the time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regarding tasklets, you may wish to take a look at [https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html.](https://www.kernel.org/doc/htmldocs/kernel-hacking/basics-softirqs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For workqueues, more information is available at [https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html](https://www.kernel.org/doc/html/v4.15/core-api/workqueue.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing time with kernel timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the device driver development, it may be necessary to perform several
    repeated operations at specific moments in time, or we may have to postpone the
    execution of some code after a well-defined delay. In these situations, kernel
    timers come to help the device driver developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use kernel timers to do repeated jobs at
    well-defined periods of time, or to defer a job until after a well-defined time
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a simple example of kernel timers, we can still use a kernel module where
    we define a kernel timer during a module's initialization function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter_05/timer` directory of GitHub resources, there are two simple
    examples about **kernel timers** (**ktimer**) and **high-resolution timers** (**hrtimer**),
    and in the next sections we're going to explain them in detail, starting with
    the new high-resolution implementation, which should be preferred in new drivers.
    An old API is also presented to complete the picture.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following main parts of the `hires_timer.c` file contain a simple example
    about high resolution kernel timers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from the end of the file, with the module `init()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see where the module `exit()` function is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in module `hires_timer_init()` initialization function, we read
    the `delay_ns` parameter, and, using the `hrtimer_init()` function, we first initialize
    the timer by specifying some features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `which_clock` argument, we ask the kernel to use a particular clock.
    In our example, we used `CLOCK_MONOTONIC`, which is very useful for reliable timestamps
    and measuring short time intervals accurately (it starts at system boot time but
    stops during suspend), but we can use other values (see `linux/include/uapi/linux/time.h`
    header file for the complete list), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLOCK_BOOTTIME`: This clock is like `CLOCK_MONOTONIC` but does not stop when
    the system goes into suspend mode. This can be useful for key expiration times
    that need to be synchronized with other machines across a suspend operation.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_REALTIME`: This clock uses the time as relative to the UNIX epoch starting
    in 1970 using the **Coordinated Universal Time** (**UTC**) as `gettimeofday()`
    does in userspace. This is used for all timestamps that need to persist across
    a reboot, since it can jump backward due to a leap second update, **Network Time
    Protocol (NTP)** adjustment with the `settimeofday()` operation from the userspace.
    However, this clock is rarely used for device drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLOCK_MONOTONIC_RAW`: Like `CLOCK_MONOTONIC` but runs at the same rate as
    the hardware clock source without adjustments for clock drift (like NTP has).
    This is also rarely needed in device drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the timer initialization, we have to set up the callback or handler function
    by using the `function` pointer as follows, where we''ve set `timer.function`
    to `hires_timer_handler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `hires_tinfo` module data structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After the timer has been initialized, we can start it by calling `hrtimer_start()`
    where we just set the expiry time with a function like `ns_to_ktime()` , in case
    we have a time interval, or by using `ktime_set()` , in case we have a seconds/nanoseconds
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the `linux/include/linux/ktime.h` header for more of the `ktime*()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the `linux/include/linux/hrtimer.h` file, we discover
    that the main function to start a high-resolution timer is `hrtimer_start_range_ns()`
    and `hrtimer_start()` is a particular case of that function, as can be seen in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We also discover that the `HRTIMER_MODE_SOFT` mode should not be used apart
    from for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `hrtimer_start_range_ns()` function, we allow a `range_ns` delta
    time, which gives the kernel the freedom to schedule the actual wake up to a time
    that is both power and performance friendly. The kernel gives the normal best
    effort behavior for expiry time plus delta, but may decide to fire the timer earlier,
    but no earlier than the `tim` expiry time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hires_timer_handler()` function from the `hires_timer.c` file is an example
    of the callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By using the `container_of()` operator, we can take a pointer to our data structure
    (defined in the example as `struct hires_timer_data`) and, then, having completed
    our job, we call `hrtimer_forward_now()` to set up a new expiry time, and, by
    returning the `HRTIMER_RESTART` value, we ask the kernel to restart the timer.
    For one-shot timers, we can return `HRTIMER_NORESTART`.
  prefs: []
  type: TYPE_NORMAL
- en: On the module exit, within the `hires_timer_exit()` function, we must use the
    `hrtimer_cancel()` function to wait for the timer to stop. It's really important
    to wait for the timer to stop, because timers are asynchronous events and it may
    happen that we remove the `struct hires_timer_data` module freeing structure while
    the timer callback is executing, which can result in a severe memory corruption!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that syncing is implemented as a sleep (or suspend) `process,` and it means
    that the `hrtimer_cancel()` function cannot be called when we're in interrupt
    context (hard or soft). However, in these situations, we can use `hrtimer_try_to_cancel()`,
    which simply returns a non-negative value if the timer has been correctly stopped
    (or is simply not active).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how it works, we test our code by simply compiling it as usual and then
    move the code to our ESPRESSObin. When everything is in place, we just have to
    load the module into the kernel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in kernel messages, we should get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In *steps 1*, *2*, and *3* we set up the timer, and here we know that it has
    been started with a delay of one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the timer expires, thanks to step 4, we execute the kernel timer''s handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: I've left the timings so you have an idea about kernel timer's precision.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the expiration time is really accurate (a few microseconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, thanks to *step 5*, if we remove the module, the timer is stopped, as
    the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just to complete your understanding, it could be interesting to take a look
    at the legacy kernel timer API.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy kernel timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ktimer.c` file contains a simple example of legacy kernel timers. As usual,
    let''s start from the end of the file where the module `init()` and `exit()` functions
    are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The module data structure with the handler function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this implementation is very similar to high-resolution timers.
    In fact in the `ktimer_init()` initialization function, we read the module `delay_ms`
    parameter and, by using `msecs_to_jiffies()`, we translate its value into jiffies,
    which are the unit of measurement of kernel timers. (Remember that legacy kernel
    timers have a lower time limit set to one jiffy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we use the `timer_setup()` and `mod_timer()` functions to respectively
    set up the kernel timer and to start it. The `timer_setup()` function takes three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable `timer` of the `struct timer_list` type, a function `callback` (or
    handler), and some flags (within `flags` variable) which can be used to specify
    some particular features of our kernel timer. Just to give you an idea about available
    flags and their meanings, here are some flag definitions from the `linux/include/linux/timer.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With regard to the callback function, let''s look at `ktimer_handler()` from
    our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By using `from_timer()` , we can take a pointer to our data structure (defined
    in the example as `struct ktimer_data`), then, after having completed our job,
    we can call again `mod_timer()` to reschedule a new timer execution; otherwise,
    everything will stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `from_timer()` function still uses `container_of()` to do its
    job, as the following definition from the `linux/include/linux/timer.h` file shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define from_timer(var, callback_timer, timer_fieldname) \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`container_of(callback_timer, typeof(*var), timer_fieldname)`.'
  prefs: []
  type: TYPE_NORMAL
- en: On the module exit, within the `ktimer_exit()` function, we must use the `del_timer_sync()`
    function to wait for the timer to stop. Whatever we stated previously regarding
    waiting for exit is still valid, so, to stop a kernel timer from an interrupt
    context, we can use `try_to_del_timer_sync()`, which simply returns a non-negative
    value if the timer has been correctly stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our code, we simply need to compile and then move it to our ESPRESSObin,
    then we can load the module into the kernel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the kernel messages, we should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Again, I've left the timings to give you an idea about kernel timer's precision.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we discover that 1,000 ms is equal to 250 jiffies; that is, 1 jiffy is
    4 ms, and also we can see that timer's handler is executed more or less every
    second. (With a jitter very near to 4 ms, that is 1 jiffy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When we remove the module the timer is stopped as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interesting documentation about high-resolution kernel timers is in the kernel
    sources at `linux/Documentation/timers/hrtimers.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous sections, we saw how to manage an interrupt directly in its handler
    or by deferring the interrupt activities by using tasklets, workqueues, and so
    on. Also, we saw how to do periodic operations or how to delay an action forward
    in time; however, a device driver may need to wait for a specific event, such
    as waiting for some data, waiting for a buffer to become full, or a for a variable
    to reach a desired value.
  prefs: []
  type: TYPE_NORMAL
- en: Please don't confuse events managed by the notifiers, we saw before, which are
    kernel related, with generic events for a specific driver.
  prefs: []
  type: TYPE_NORMAL
- en: When there is no data to be read from a peripheral, the reading process must
    be put on sleep and then awakened when the "data ready" event arrives. Another
    example is when we start a complex job and we wish to be signaled when it's finished;
    in this case, we start the job and then we go to sleep until the "job finished"
    event arrives. All these tasks can be done by using **waiting queues** (waitqueues)
    or **completions** (which are still implemented by waitqueues).
  prefs: []
  type: TYPE_NORMAL
- en: A waiting queue (or a completion) is just a queue where one or more processes
    stays waiting for the event related to the queue; when the event arrives, one,
    more than one, or even all sleeping processes are awakened in order to allow someone
    to manage it. In this recipe, we will learn how to use a waitqueue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to prepare a simple example about waiting queues, we can again use
    a kernel module where we define a kernel timer during the module initialization
    function, which has the task of generating our event, and then we use a waitqueue
    or completion to wait for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter_05/wait_event` directory of GitHub resources, there are two
    simple examples about waitqueues and completions, then, in the *How it works...*
    section, we're going to explain them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's see a simple example regarding a waitqueue used to wait for the
    "data is greater then 5" event.
  prefs: []
  type: TYPE_NORMAL
- en: Waitqueues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is the main part of the `waitqueue.c` file, which holds a simple
    example about waitqueues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again let''s start from the end, to see the module `init()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After the kernel timer has been started, we can use the `wait_event_interruptible()`
    function to wait for the `wqinfo.data > 5` event on the `wqinfo.waitq` waitqueue,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The data structure is now defined, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: However, before any action can happen on the waitqueue, it must initialized,
    so, before starting the kernel timer, we use the `init_waitqueue_head()` function
    to properly set up `struct wait_queue_head waitq` stored in `struct ktimer_data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we take a look in the `linux/include/linux/wait.h` header, we can see how
    `wait_event_interruptible()` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how to awake the sleeping processes, we should consider the kernel timer
    handler in the `waitqueue.c` file named `ktimer_handler()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Completions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we wish to wait for a job to complete, we still can use a waitqueue, but
    it's better to use a completion that (as the name says) is specifically designed
    to carry out such activities. Here is a simple example, which can be retrieved
    from the `completion.c` file of GitHub resources about competitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see the module `init()` and `exit()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The module data structure is now like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When the job is done, we can signal it as done to the `ktimer_handler ()` kernel
    timer handler by using the `complete()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When `complete()` is called, a single thread waiting on the completion is signaled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'While if we call `complete_all()`, all threads waiting for the completion are
    signaled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how this works in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Waitqueues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 3, the calling process simply continues its execution if the condition
    is true; otherwise, it goes to sleep until the condition becomes true or a signal
    is received. (In this case the function returns the `-ERESTARTSYS` value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete understanding, we should notice that there are two other variants
    of waiting event functions defined in the `linux/include/linux/wait.h` header.
    The first variant is just the `wait_event()` function, which works exactly as
    `wait_event_interruptible()`, but it cannot be interrupted by any signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'While the second is `wait_event_timeout()` or `wait_event_interruptible_timeout()`,
    which works in the same way until a timeout elapses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In *step 4*, in this function, we change the value stored into data and then
    we use `wake_up_interruptible()` on the waitqueue in order to signal a sleeping
    process that the data has been changed, and it should awake to test if the conditions
    are true.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `linux/include/linux/wait.h` header, there are several functions defined
    that are used to wake up one, more than one, or just all waiting processes (interruptible
    or not) by using a common `__wake_up()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we asked for data greater than five, so the first five calls
    of `wake_up_interruptible()` should not awake our process; let's verify it in
    the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the process that will go to sleep is just the `insmod` command, which
    is the one that calls the module initialization function.
  prefs: []
  type: TYPE_NORMAL
- en: Completions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we can see the code is quite similar to the previous waitqueue
    example; we simply use the `init_completion()` function to initialize the completion
    as usual, and then we call `wait_for_completion()` on `struct completion done`
    within the `struct ktimer_data` structure to wait for the job ending.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for waitqueues, inside the `linux/include/linux/completion.h` header, we
    can find several variants of the `wait_for_completion()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to test our code in both cases, we have to compile the kernel modules and
    then move them on the ESPRESSObin; moreover, in order to better understand how
    the example works, we should use an SSH connection and then look for the kernel
    messages on the serial console from another terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: Waitqueues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we insert the `waitqueue.ko` module with `insmod`, as follows, we should
    notice that the process is suspended until the data becomes greater than five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When the `insmod` process is suspended, you should not get the prompt until
    the test is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the serial console, we should get the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the `got event data > 5` message is shown on the screen, the `insmod`
    process should return, and a new prompt should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that `wait_event_interruptible()` returns with `-ERESTARTSYS`, when
    a signal arrives, we can unload the module and the reload it, then just press
    *CTRL*+*C* keys before data reaches 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This time in the kernel messages, we should get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Completions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test completions, we have to insert the `completion.ko` module into the
    kernel. Now you should notice that if we press *CTRL*+*C* nothing happens because
    we used `wait_for_completion()` instead of `wait_for_completion_interruptible()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the prompt returns after five seconds and the kernel messages are something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although slightly outdated, there is some good information about waitqueues
    at URL [https://lwn.net/Articles/577370/](https://lwn.net/Articles/577370/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic operations are a crucial step during device driver development. In fact,
    a driver is not like a normal program that executes from the beginning till the
    end, as it provides several methods (for example, read or write data to a peripheral,
    or set some communication parameters), which can be called asynchronously one
    to another. All these methods operate concurrently on common data structures that
    must be modified in a consistent manner. That's why we need to be able to perform
    atomic operations.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel uses a large variety of atomic operations. Each is used for
    different operations, depending on whether the CPU is running in an interrupt
    or process context.
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU is in the process context, we can safely use **mutexes,** which
    can put the current running process to sleep if the mutex is locked; however,
    in an interrupt context "going to sleep" is not allowed so we need another mechanism,
    and Linux gives us **spinlocks**, which allow locking everywhere, but for short
    periods of time. This happens because spinlocks get their job done performing
    a busy-waiting tight-loop on the current CPU, and, if we stay too long, we can
    lose performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to do operations on data in an uninterruptible
    manner in order to avoid data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, to build our examples, we can use a kernel module that defines a kernel
    timer during the module `init()` function, which has the task of generating an
    asynchronous execution where we can use our mutual exclusion mechanism to protect
    our data.
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter_05/atomic` directory of GitHub resources, there are simple examples
    of mutexes, spinlocks, and atomic data, and, in the next sections, we're going
    to explain them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this paragraph, we're going to present two examples of how to use mutexes
    and spinlocks. We should consider them as just a demonstration about how to use
    the API, because, in real drivers, their usage is a bit different, and it will
    be covered in [Chapter 7](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml), *Advanced
    Char Driver Operations*, and the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the end of `mutex.c` file where mutexes are defined and initialized
    for the module `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the initialization for the module `exit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the module initialization `mut_init()` function, we use `mutex_init()` to
    initialize the `lock` mutex; then we can safely start the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The module data structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `mutex_trylock()` to try to acquire the lock safely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Spinlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, the `spinlock.c` file is shown as an example of spinlock usage. Here
    is the module `init()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the module `exit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The module data structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we use `spin_lock_init()` to initialize the spinlock, and then
    we use two different function pairs to protect our data: `spin_lock()` and `spin_unlock()`;
    both of these just use the spinlock to avoid race conditions, while `spin_lock_irqsave()`
    and `spin_unlock_irqrestore()` use the spinlock while the current CPU interrupts
    are disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: By using `spin_lock_irqsave()` and `spin_unlock_irqrestore()`, we can be sure
    that nobody can interrupt us because the IRQs are disabled, and that no other
    CPU can execute our code (thanks to the spinlock).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how mutexes and spinlocks work in the following two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, each time we have to modify our data, we can protect it by calling
    the `mutex_lock()` and `mutex_unlock()` pair, passing a pointer to the mutex to
    lock as a parameter; of course, we cannot do it in an interrupt context (as the
    kernel timer handler is), and that's why we use `mutex_trylock()` to try to acquire
    the lock safely.
  prefs: []
  type: TYPE_NORMAL
- en: Spinlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In step 1, the example is very similar to the previous one, but it shows a
    really important difference between mutexes and spinlocks: the former protects
    code from the process''s concurrency while the latter protects code from the CPU''s
    concurrency! In fact, if the kernel has no symmetric multiprocessing support (`CONFIG_SMP=n`
    in the kernel `.config` file), then spinlocks just vanish into void code.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a really important concept, which device driver developers should understand
    very well; otherwise, a driver may not work at all, or lead to a severe bug.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the last example is only meant to present the mutexes and spinlocks,
    API testing is quite useless. However, if we wish to do it anyway, the procedure
    is the same: compile modules and then move them to the ESPRESSObin.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we insert the `mutex.ko` module, the output should be something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In step 1, we execute the module `init()` function where we increase `minfo.data`
    within a mutex protected area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the handler, we can be sure that it cannot increase `minfo.data`
    if the module `init()` function is currently holding the mutex.
  prefs: []
  type: TYPE_NORMAL
- en: Spinlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we insert the `spinlock.ko` module, the output should be something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As before, in *step 1*, we execute the module `init()` function where we increase
    `minfo.data` within a spinlock protected area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Again, when we execute the handler, we can be sure that it cannot increase `minfo.data`
    if the module `init()` function is currently holding the spinlock.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the case of mono core machines, spinlocks vanish, and we assure
    the `minfo.data` lock by just disabling interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: By using mutexes and spinlocks, we have whatever we need to protect our data
    from race conditions; however, Linux offers us another API, **atomic operations**.
  prefs: []
  type: TYPE_NORMAL
- en: The atomic data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During device driver development, we may need to atomically increment or decrement
    a variable, or more simply, set one or more bits in a variable. To do so, instead
    of using a complex mutual exclusion mechanism, we can use a set of variables and
    operations that are guaranteed to be atomic by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `atomic.c` file from GitHub resources, we can see a simple example about
    them, where the atomic variables can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the following is the module `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the module `exit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use `ATOMIC_INIT()` to statically define and initialize
    an atomic variable, while the `atomic_set()` function can be used to do the same
    dynamically. Subsequently, atomic variables can be manipulated by using functions
    with the `atomic_*()` prefix, which are in the `linux/include/linux/atomic.h`
    and `linux/include/asm-generic/atomic.h` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the kernel timer handler can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Atomic data can be added or subtracted by specific values, incremented, decremented,
    OR-ed, AND-ed, XOR-ed, and so on, and all these operations are guaranteed to be
    atomic by the kernel, so their usage is really simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, testing the code is quite useless. However, if we compile and then insert
    the `atomic.ko` module in the ESPRESSObin, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `data` stays at `-1` and doesn't decrement any further.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For several examples about kernel locking mechanisms, refer to [https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)[.](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about atomic operations, have a look at [https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html](https://www.kernel.org/doc/html/v4.12/core-api/atomic_ops.html)[.](https://www.kernel.org/doc/htmldocs/kernel-locking/locks.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

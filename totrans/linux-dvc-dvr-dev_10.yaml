- en: IIO Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Industrial I/O** (**IIO** ) is a kernel subsystem dedicated to **analogic
    to digitals converters** (**ADC** ) and **digital to analogic converters** (**DAC**
    ). With the growing number of sensors (measurement devices with analogue to digital,
    or digital to analogue, capabilities) with different code implementations, scattered
    over the kernel sources, gathering them became necessary. This is what IIO framework
    does, in a generic and homogeneous way. Jonathan Cameron and the Linux-IIO community
    have been developing it since 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: Accelerometer, Gyroscope, current/voltage measurement chips, light sensors,
    pressure sensors, and so on all fall into the IIO family of devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IIO model is based on devices and channels architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Device represents the chip itself. It is the top level of the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel represents a single acquisition line of the device. A device may have
    one or more channels. For example, an accelerometer is a device with three channels,
    one for each axis (X, Y, and Z).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IIO chip is the physical and hardware sensor/converter. It is exposed to
    the user space as a character device (when triggered buffering is supported),
    and a **sysfs** directory entry which will contain a set of files, some of which
    represent the channels. A single channel is represented with a single **sysfs**
    file entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the two ways to interact with an IIO driver from the user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/` : This represents the sensor along with its channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/iio:deviceX` : This is a character device which exports the device''s
    events and data buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: IIO framework architecture and layout
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how the IIO framework is organized between kernel
    and user space. The driver manages the hardware and report processing to the IIO
    core, using a set of facilities and API exposed by the IIO core. The IIO subsystem
    then abstracts the whole underlying mechanism to the user space by means of the
    sysfs interface and character device, on top of which users can execute system
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIO APIs are spread over several header files, listed as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will describe and handle every concepts of IIO framework,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: A walk through its data structure (device, channel, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggered buffer support and continuous capture, along with its sysfs interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring existing IIO triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing data in either one-shot mode or continuous mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing available tools that can help developers in testing their devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIO data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IIO device is represented in the kernel as an instance of the `struct iio_dev`
    , and described by a `struct iio_info` structure. All of the important IIO structures
    are defined in `include/linux/iio/iio.h` .
  prefs: []
  type: TYPE_NORMAL
- en: iio_dev structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This structure represents the IIO device, describing the device, and the driver.
    It tells us about:'
  prefs: []
  type: TYPE_NORMAL
- en: How many channels are available on the device?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What modes can the device operate in: one-shot, triggered buffer?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What hooks are available for this driver?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The complete structure is defined in the IIO header file. Fields that we are
    not interested in are removed here.
  prefs: []
  type: TYPE_NORMAL
- en: '`modes` : This represents the different modes supported by the device. Supported
    modes are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INDIO_DIRECT_MODE` which says device provides sysfs type interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INDIO_BUFFER_TRIGGERED` says that the device supports hardware triggers. This
    mode is automatically added to your device when you set up a trigger buffer using
    the `iio_triggered_buffer_setup()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INDIO_BUFFER_HARDWARE` shows the device has a hardware buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INDIO_ALL_BUFFER_MODES` is the union of the above two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentmode` : This represents the mode actually used by the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` : This represents the struct device (according to Linux device model)
    the IIO device is tied to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buffer` : This is your data buffer, pushed to the user space when using triggered
    buffer mode. It is automatically allocated and associated to your device when
    you enable trigger buffer support using the `iio_triggered_buffer_setup` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_bytes` : This is the number of bytes captured and to be fed to the `buffer`
    . When using trigger buffer from the user space, the buffer should be at least
    `indio->scan_bytes` bytes large.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`available_scan_masks` : This is an optional array of allowed bit masks. When
    using trigger buffer, one can enable channels to be captured and fed into the
    IIO buffer. If you do not want to allow some channels to be enabled, you should
    fill this array with only allowed ones. The following is an example of providing
    a scan mask for an accelerometer (with X, Y, and Z channels):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`active_scan_mask` : This is a bitmask of enabled channels. Only the data from
    those channels should be pushed into the `buffer` . For example, for an 8 channels
    ADC converter, if one only enables the first (0), third (2), and last (7) channels,
    the bitmask would be 0b10000101 (0x85). `active_scan_mask` will be set to 0x85\.
    The driver can then use the `for_each_set_bit` macro to walk through each set
    bit, fetch the data according to the channel, and fill the buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_timestamp` : This tells us whether to push the capture timestamp into
    the buffer or not. If true, the timestamp will be pushed as the last element of
    the buffer. The timestamp is 8 bytes (64bits) large.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trig` : This is the current device trigger (when buffer mode is supported).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollfunc` : This is the function run on the trigger being received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channels` : This represents the table channel specification structure, to
    describe every channel the device has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_channels` : This represents the number of channels specified in `channels`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : This represents the device name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` : Callbacks and constant information from the driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup_ops` : Set of callback functions to call before and after the buffer
    is enabled/disabled. This structure is defined in `include/linux/iio/iio.h` shown
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`setup_ops` : If this is not specified, the IIO core uses the default `iio_triggered_buffer_setup_ops`
    defined in `drivers/iio/buffer/industrialio-triggered-buffer.c` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chrdev` : This is the associated character device created by the IIO core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function used to allocate memory for an IIO device is `iio_device_alloc()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`dev` is the device for which `iio_dev` is allocated, and `sizeof_priv` is
    the memory space used to allocate for any private structure. This way, passing
    per-device (private) data structure is quite straightforward. The function returns
    `NULL` if the allocation fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the IIO device memory has been allocated, the next step is to fill different
    fields. Once done, one has to register the device with the IIO subsystem using
    `iio_device_register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The device will be ready to accept requests from the user space after this
    function executes. The reverse operation (usually done in the release function)
    is `iio_device_unregister()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once unregistered, the memory allocated by `iio_device_alloc` can be freed
    with `iio_device_free` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Given an IIO device as parameter, one can retrieve the private data in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: iio_info structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `struct iio_info` structure is used to declare the hooks used by the IIO
    core in order to read/write channels/attributes values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Fields that we are not interested in have been removed.
  prefs: []
  type: TYPE_NORMAL
- en: '`driver_module` : This is the module structure used to ensure correct ownership
    of `chrdevs` , usually set to `THIS_MODULE` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attrs` : This represents the devices attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_raw` : This is the callback run when the user reads a device `sysfs`
    file attribute. The `mask` parameter is a bitmask that allows us to know which
    type of value is requested. The `channel` parameter lets us know the channel concerned.
    It can be for the sampling frequency, the scale used to convert the raw value
    into usable value, or the raw value itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_raw` : This is the callback used to write values to the device. One
    can, for example, use it to set the sampling frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to set up a `struct iio_info` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: IIO channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A channel represents a single acquisition line. An accelerometer will have,
    for example, 3 channels (X, Y, Z), since each axis represents a single acquisition
    line. `struct iio_chan_spec` is the structure that represents and describes a
    single channel in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type` : This specifies which type of measurement the channel makes. In case
    of voltage measurement, it should be `IIO_VOLTAGE` . For a light sensor, it is
    `IIO_LIGHT` . For an accelerometer, `IIO_ACCEL` is used. All available types are
    defined in `include/uapi/linux/iio/types.h` , as `enum iio_chan_type` . To write
    drivers for a given converter, look into that file to see the type each of your
    channels falls in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel` : This specifies the channel index when `.indexed` is set to 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel2` : This specifies the channel modifier when `.modified` is set to
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modified` : This specifies whether a modifier is to be applied to this channel
    attribute name or not. In that case, the modifier is set in `.channel2` . (For
    example, `IIO_MOD_X` , `IIO_MOD_Y` , `IIO_MOD_Z` are modifiers for axial-sensors
    about the xyz-axis). Available modifier list is defined in the kernel IIO header
    as `enum iio_modifier` . Modifiers only mangle the channel attribute name in `sysfs`
    , not the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexed` : This specifies whether the channel attribute name has an index
    or not. If yes, the index is specified in the `.channel` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan_index` and `scan_type` : These fields are used to identify elements from
    a buffer, when using buffer triggers. `scan_index` sets the position of the captured
    channel inside the buffer. Channels with a lower `scan_index` will be placed before
    channels with a higher index. Setting `.scan_index` to `-1` will prevent the channel
    from buffered capture (no entry in the `scan_elements` directory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Channel sysfs attributes exposed to user space are specified in the form of
    bitmasks. Depending on their shared information, attributes can be set into one
    of the following masks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`info_mask_separate` marks the attributes as being specific to this channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info_mask_shared_by_type` marks the attribute as being shared by all channels
    of the same type. The information exported is shared by all channels of the same
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info_mask_shared_by_dir` marks the attribute as being shared by all channels
    of the same direction. The information exported is shared by all channels of the
    same direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info_mask_shared_by_all` marks the attribute as being shared by all channels,
    whatever their type or direction may be. The information exported is shared by
    all channels. Bitmasks for enumeration of those attributes are all defined in
    `include/linux/iio/iio.h` *:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The endianness field should be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Channel attribute naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The attribute''s name is automatically generated by the IIO core with the following
    pattern: `{direction}_{type}_{index}_{modifier}_{info_mask}` :'
  prefs: []
  type: TYPE_NORMAL
- en: '`direction` corresponds to the attribute direction, according to the `struct
    iio_direction` structure in `drivers/iio/industrialio-core.c` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`type` corresponds to the channel type, according to the char array `const
    iio_chan_type_name_spec` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`index` pattern depends on the channel `.indexed` field being set or not. If
    set, the index will be taken from the `.channel` field in order to replace the
    `{index}` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modifier` pattern depends on the channel `.modified` field being set or not.
    If set, the modifier will be taken from the `.channel2` field, and the `{modifier}`
    pattern will be replaced according to the char array `struct iio_modifier_names`
    structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`info_mask` depends on the channel info mask, private or shared, indexing value
    in the char array `iio_chan_info_postfix` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Distinguishing channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may find yourself in trouble when there are multiple data channels per
    channel type. The dilemma would be: how to identify them. There are two solutions
    for that: indexes and modifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using indexes** : Given an ADC device with one channel line, indexation is
    not needed. Its channel definition would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The attribute name resulting from the preceding channel described will be `in_voltage_raw`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_voltage_raw`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us say the converter has 4 or even 8 channels. How do we identify them?
    The solution is to use indexes. Setting the `.indexed` field to 1 will mangle
    the channel attribute name with the `.channel` value replacing the `{index}` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting channel attributes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_voltage0_raw`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_voltage1_raw`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_voltage2_raw`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_voltage3_raw`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using modifiers** : Given a light sensor with two channelsâ€”one for infrared
    light and one for both infrared and visible light, without index or modifier,
    an attribute name would be `in_intensity_raw` . Using indexes here can be error-prone,
    because it makes no sense to have `in_intensity0_ir_raw` , and `in_intensity1_ir_raw`
    . Using modifiers will help to provide meaningful attribute names. The channel''s
    definition could look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Resulting attributes will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_ir_raw` for the channel measuring IR
    intensity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_both_raw` for the channel measuring
    both infrared and visible light'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/in_illuminance_input` for the processed data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/iio:deviceX/sampling_frequency` for the sampling frequency, shared
    by all'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is valid with accelerometer too, as we will see further on in the case
    study. For now, let's summarize what we have discussed so far in a dummy IIO driver.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us summarize what we have seen so far in a simple dummy driver, which will
    expose four voltage channels. We will ignore `read()` or `write()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After loading the module above, we will have the following output, showing
    that our device really corresponds to the platform device we have registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following listing shows the channels that this device has, along with its
    name, which correspond exactly to what we have described in the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Triggered buffer support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many data analysis applications, it is useful to be able to capture data
    based on some external signal (trigger). These triggers might be:'
  prefs: []
  type: TYPE_NORMAL
- en: A data ready signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IRQ line connected to some external system (GPIO or something else)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On-processor periodic interrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User space reading/writing a specific file in sysfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIO device drivers are completely unrelated to triggers. A trigger may initialize
    data capture on one or many devices. These triggers are used to fill buffers,
    exposed to user space as character devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can develop one''s own trigger driver, but that is beyond the scope of
    this book. We will try to focus on existing ones only. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iio-trig-interrupt` : This provides support for using any IRQ as IIO triggers.
    In old kernel versions, it used to be `iio-trig-gpio` . The kernel option to enable
    this trigger mode is `CONFIG_IIO_INTERRUPT_TRIGGER` . If built as a module, the
    module would be called `iio-trig-interrupt` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio-trig-hrtimer` : This provides a frequency-based IIO trigger using HRT
    as the interrupt source (since kernel v4.5). In older kernel versions, it used
    to be `iio-trig-rtc` . The kernel option responsible for this trigger mode is
    `IIO_HRTIMER_TRIGGER` . If built as a module, the module would be called `iio-trig-hrtimer`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio-trig-sysfs` : This allow us to use sysfs entry to trigger data capture.
    `CONFIG_IIO_SYSFS_TRIGGER` is the kernel option to add the support of this trigger
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio-trig-bfin-timer` : This allows us to use a blackfin timer as IIO triggers
    (still in staging).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IIO exposes API so that we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare any given number of triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose which channels will have their data pushed into buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your IIO device provides the support of the trigger buffer, you must set
    `iio_dev.pollfunc` , which is executed when the trigger fires. This handler has
    the responsibility to find enabled channels through `indio_dev->active_scan_mask`
    , retrieve their data, and feed them into `indio_dev->buffer` using the `iio_push_to_buffers_with_timestamp`
    function. As such, buffers and triggers are very connected in the IIO subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: The IIO core provides a set of helper functions to set up triggered buffers
    that one can find in `drivers/iio/industrialio-triggered-buffer.c` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to support triggered buffers from within your driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill an `iio_buffer_setup_ops` structure if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the top half associated to the trigger. In 99% of cases, one has to just
    feed the timestamp associated with the capture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the trigger bottom half, which will fetch data from each enabled channel,
    and feed them into the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `probe` function, one has to set up the buffer itself, prior
    to registering the device with `iio_device_register()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The magic function here is `iio_triggered_buffer_setup` . This will also give
    the `INDIO_DIRECT_MODE` capability to your device. When a trigger is given (from
    user space) to your device, you have no way of knowing when capture will be fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'While continuous buffered capture is active, one should prevent (by returning
    an error) the driver from performing sysfs per-channel data capture (performed
    by the `read_raw()` hook) in order to avoid undetermined behavior, since both
    the trigger handler and `read_raw()` hook will try to access the device at the
    same time. The function used to check whether buffered mode is actually used is
    `iio_buffer_enabled()` . The hook will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `iio_buffer_enabled()` function simply tests if the buffer is enabled for
    a given IIO device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us describe some important things used in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iio_buffer_setup_ops` provides buffer setup functions to be called at fixed
    step of the buffer configuration sequence (before/after enable/disable). If not
    specified, the default `iio_triggered_buffer_setup_ops` will be given to your
    device by the IIO core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensor_iio_pollfunc` is the trigger''s top half. As with every top half, it
    runs in interrupt context and must do as little processing as possible. In 99%
    of cases, you just have to feed the timestamp associated with the capture. Once
    again, one can use the default IIO `iio_pollfunc_store_time` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensor_trigger_handler` is the bottom half, which runs in a kernel thread,
    allowing us to do any processing including even acquiring mutex or sleep. The
    heavy processing should take place here. It usually reads data from the device
    and stores it in the internal buffer together with the timestamp recorded in the
    top half, and pushes it to your IIO device buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trigger is mandatory for triggered buffering. It tells the driver when to
    read the sample from the device and put it into the buffer. Triggered buffering
    is not mandatory to write IIO device drivers. One can use single shot capture
    through sysfs too, by reading raw attributesof the channel, which will only perform
    a single conversion (for the channel attribute being read). Buffer mode allows
    continuous conversions, thus capturing more than one channel in a single shot.
  prefs: []
  type: TYPE_NORMAL
- en: IIO trigger and sysfs (user space)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two locations in sysfs related to triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/devices/triggerY/` which is created once an IIO trigger is registered
    with the IIO core and corresponds to triggers with index `Y` . There is at least
    one attribute in the directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` which is the trigger name that can be later used for association with
    a device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/devices/iio:deviceX/trigger/*` directory will be automatically
    created if your device supports a triggered buffer. One can associate a trigger
    with our device by writing the trigger''s name in the `current_trigger` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysfs trigger interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sysfs trigger is enabled in the kernel by the `CONFIG_IIO_SYSFS_TRIGGER=y`
    config option, which will result in the `/sys/bus/iio/devices/iio_sysfs_trigger/`
    folder being automatically created, and can be used for sysfs trigger management.
    There will be two files in the directory, `add_trigger` and `remove_trigger` .
    Its driver is in `drivers/iio/trigger/iio-trig-sysfs.c` .
  prefs: []
  type: TYPE_NORMAL
- en: add_trigger file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is used to create a new sysfs trigger. You can create a new trigger by
    writing a positive value (which will be used as a trigger ID) into that file.
    It will create the new sysfs trigger, accessible at `/sys/bus/iio/devices/triggerX`
    , where `X` is the trigger number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new sysfs trigger, accessible at `/sys/bus/iio/devices/trigger2`
    . If the trigger with the specified ID is already present in the system, an invalid
    argument message will be returned. The sysfs trigger name pattern is `sysfstrig{ID}`
    . The command `echo 2 > add_trigger` will create the trigger `/sys/bus/iio/devices/trigger2`
    whose name is `sysfstrig2` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Each sysfs trigger contains at least one file: `trigger_now` . Writing `1`
    into that file will instruct all devices having the corresponding trigger name
    in their `current_trigger` to start capture, and push data into their respective
    buffer. Each device buffer must have its size set, and must be enabled (`echo
    1 > /sys/bus/iio/devices/iio:deviceX/buffer/enable` ).'
  prefs: []
  type: TYPE_NORMAL
- en: remove_trigger file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove a trigger, the following command is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tying a device with a trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Associating a device with a given trigger consists of writing the name of the
    trigger to the `current_trigger` file available under the device''s trigger directory.
    For example, let us say we need to tie a device with the trigger that has index
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To detach the trigger from the device, one should write an empty string to
    the `current_trigger` file of the device trigger directory, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We will see further on in the chapter a practical example dealing with the sysfs
    trigger for data capture.
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt trigger interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare our IRQ trigger and it will result in the IRQ trigger standalone module
    being loaded. If its `probe` function succeeds, there will be a directory corresponding
    to the trigger. IRQ trigger names have the form `irqtrigX` , where `X` corresponds
    to the virtual IRQ you just passed, the one you will see in `/proc/interrupt`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`irqtrig85` : As we have done with other triggers, you just have to assign
    that trigger to your device, by writing its name into your device `current_trigger`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time the interrupt will be fired, device data will be captured.
  prefs: []
  type: TYPE_NORMAL
- en: The IRQ trigger driver does not support DT yet, which is the reason why we used
    our board `init` file. But it does not matter; since the driver requires a resource,
    we can use DT without any code change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of device tree node declaring the IRQ trigger interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The example supposes the IRQ line is the GPIO#30 that belongs to the GPIO controller
    node `gpio4` . This consists of using a GPIO as an interrupt source, so that whenever
    the GPIO changes to a given state, the interrupt is raised, thus triggering the
    capture.
  prefs: []
  type: TYPE_NORMAL
- en: The hrtimer trigger interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hrtimer` trigger relies on the configfs file system (see *Documentation/iio/iio_configfs.txt*
    in kernel sources), which can be enabled through the `CONFIG_IIO_CONFIGFS` config
    option, and mounted on our system (usually under the `/config` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, loading the module `iio-trig-hrtimer` will create IIO groups accessible
    under `/config/iio` , allowing users to create hrtimer triggers under `/config/iio/triggers/hrtimer`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Each hrtimer trigger contains a single `sampling_frequency` attribute in the
    trigger directory. A full and working example is provided further in the chapter
    in the section *Data capture using hrtimer trigger* .
  prefs: []
  type: TYPE_NORMAL
- en: IIO buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IIO buffer offers continuous data capture, where more than one data channel
    can be read at once. The buffer is accessible from the user space through the
    `/dev/iio:device` character device node. From within the trigger handler, the
    function used to fill the buffer is `iio_push_to_buffers_with_timestamp` . The
    function responsible to allocate the trigger buffer for your device is `iio_triggered_buffer_setup()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: IIO buffer sysfs interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An IIO buffer has an associated attributes directory under `/sys/bus/iio/iio:deviceX/buffer/*`
    . Here are some of the existing attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` : The total number of data samples (capacity) that can be stored by
    the buffer. This is the number of scans contained by the buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable` : This activates buffer capture, start the buffer capture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`watermark` : This attribute has been available since kernel version v4.2\.
    It is a positive number which specifies how many scan elements a blocking read
    should wait for. If using `poll` for example, it will block until the watermark
    is reached. It makes sense only if the watermark is greater than the requested
    amount of reads. It does not affect non-blocking reads. One can block on poll
    with a timeout and read the available samples after the timeout expires, and thus
    have a maximum delay guarantee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIO buffer setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A channel whose data is to be read and pushed into the buffer is called a scan
    element. Their configurations are accessible from the user space through the `/sys/bus/iio/iio:deviceX/scan_elements/*`
    directory, containing the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`en` (actually a suffix for attribute name), is used to enable the channel.
    If and only if its attribute is non-zero, then a triggered capture will contain
    data samples for this channel. For example, `in_voltage0_en` , `in_voltage1_en`
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` describes the scan element data storage within the buffer, and hence
    the form in which it is read from user space. For example, `in_voltage0_type`
    . The format is `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`be` or `le` specifies the endianness (big or little).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` or `u` specifies the sign, either signed (2''s complement) or unsigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bits` is the number of valid data bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`storagebits` is the number of bits this channel occupies in the buffer. That
    said, a value may be really coded in 12 bits (**bits** ), but occupies 16 bits
    (**storagebits** ) in the buffer. One must therefore shift the data four times
    to the right to obtain the actual value. This parameter depends on the device,
    and one should refer to its data sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shift` represents the number of times one should shift the data value prior
    to masking out unused bits. This parameter is not always needed. If the number
    of valid bit (**bits** ) is equal to the number of storage bits, the shift will
    be 0\. One can also find this parameter in the device data sheet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat` specifies the number of bit/storagebit repetitions. When the repeat
    element is 0 or 1, then the repeat value is omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to explain this section is by an excerpt of kernel doc, which
    can find here: [https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html](https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html)
    . For example, a driver for a 3-axis accelerometer, with 12-bit resolution where
    data is stored in two 8-bit registers, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'will have the following scan element type for each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: One should interpret this as being little endian-signed data, 16 bits-sized,
    which needs to be shifted right by 4 bits before masking out the 12 valid bits
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: The element in `struct iio_chan_spec` that is responsible for determining how
    a channel's value should be stored into the buffer is `scant_type` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure absolutely matches `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`
    , which is the pattern described in the previous section. Let us have a look at
    each member of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sign` represents the sign of the data and matches `[s|u]` in the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`realbits` corresponds to `bits` in the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`storagebits` matches the same name in the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shift` corresponds to shift in the pattern, same for `repeat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio_indian` represents the endianness and matches `[be|le]` in the pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, one is able to write the IIO channel structure that corresponds
    to the type previously explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a closer look at the digital triaxial acceleration sensor BMA220
    from BOSH. This is an SPI/I2C-compatible device, with 8 bit-sized registers, along
    with an on-chip motion-triggered interrupt controller, which actually senses tilt,
    motion, and shock vibration. Its data sheet is available at: [http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF](http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF)
    , and its driver has been introduced since kernel v4.8 (`CONFIG_BMA200` ). Let
    us walk through it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we declare our IIO channels using `struct iio_chan_spec` . Once the
    triggered buffer is used, then we need to fill the `.scan_index` and `.scan_type`
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)` says there will be a `*_raw`
    sysfs entry (attribute) for each channel, and `.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)`
    says that there is only a `*_scale` sysfs entry for all channels of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Reading `in_accel_scale` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_SCALE`
    . Reading `in_accel_x_raw` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_RAW`
    . The real value is therefore `raw_value * scale` .
  prefs: []
  type: TYPE_NORMAL
- en: 'What `.scan_type` says is that the value returned by each channel is, 8 bit-sized
    (will occupy 8 bits in the buffer), but the useful payload only occupies 6 bits,
    and the data must be right-shifted 2 times prior to masking out unused bits. Any
    scan element type will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is our `pollfunc` (actually it is the bottom half), which reads
    samples from the device and pushes read values into the buffer (`iio_push_to_buffers_with_timestamp()`
    ). Once done, we inform the core (`iio_trigger_notify_done()` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `read` function. It is a hook, called every time one reads
    a sysfs entry of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When one reads a `*raw` sysfs file, the hook is called, given `IIO_CHAN_INFO_RAW`
    in the `mask` parameter, and the corresponding channel in the `*chan` parameter.
    `*val` and `val2` are actually output parameters. They must be set with the raw
    value (read from the device). Any read performed on the `*scale` sysfs file will
    call the hook with `IIO_CHAN_INFO_SCALE` in mask parameter, and so on for each
    attribute mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the case with the `write` function, used to write value into the
    device. There is an 80% chance your driver does not require a `write` function.
    This `write` hook lets the user change the device''s scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is called whenever one writes a value to the device. Frequently
    changed parameters are the scale. An example could be: `echo <desired-scale> >
    /sys/bus/iio/devices/iio;devices0/in_accel_scale` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it comes to fill a `struct iio_info` structure, to be given to our `iio_device`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `probe` function, we allocate and set up a `struct iio_dev` IIO device.
    Memory for private data is reserved too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: One can enable this driver by means of the `CONFIG_BMA220` kernel option. That
    said, this is available only from v4.8 onwards in kernel. The closest device one
    can use for this on older kernel versions is BMA180, which one can enable using
    the `CONFIG_BMA180` option.
  prefs: []
  type: TYPE_NORMAL
- en: IIO data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have guessed that there are only two ways to access data with the IIO
    framework; one-shot capture through sysfs channels, or continuous mode (triggered
    buffer) through an IIO character device.
  prefs: []
  type: TYPE_NORMAL
- en: One-shot capture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One-shot data capture is done through sysfs interface. By reading the sysfs
    entry that corresponds to a channel, you''ll capture only the data specific to
    that channel. Given a temp sensor with two channels: one for the ambient temp,
    and the other for the thermocouple temp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Processed value is obtained by multiplying the scale by the raw value.
  prefs: []
  type: TYPE_NORMAL
- en: '`Voltage value` : `6646 * 0.305175781 = 2028.19824053`'
  prefs: []
  type: TYPE_NORMAL
- en: The device datasheet says the process value is given in MV. In our case, it
    corresponds to 2.02819V.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a triggered acquisition working, the trigger support must have been
    implemented in your driver. Then, to acquire data from within user space, one
    must: create a trigger, assign it, enable the ADC channels, set the dimension
    of the buffer, and enable it). Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing using the sysfs trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Capturing data using the sysfs trigger consists of sending a set of command
    few sysfs files. Let us enumerate what we should do to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create the trigger** : Before the trigger can be assigned to any device,
    it should be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, `0` corresponds to the index we need to assign to the trigger. After this
    command, the trigger directory will be available under `*/sys/bus/iio/devices/*`
    , as `trigger0` .
  prefs: []
  type: TYPE_NORMAL
- en: '**Assign the trigger to the device** : A trigger is uniquely identified by
    its name, which we can use in order to tie device to the trigger. Since we used
    0 as index, the trigger will be named `sysfstrig0` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have used this command too: `cat /sys/bus/iio/devices/trigger0/name
    > /sys/bus/iio/devices/iio:device0/trigger/current_trigger` . That said, if the
    value we wrote does not correspond to an existing trigger name, nothing will happen.
    To make sure we really defined a trigger, we can use `cat /sys/bus/iio/devices/iio:device0/trigger/current_trigger`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable some scan elements** : This step consists of choosing which channels
    should have their data value pushed into the buffer. One should pay attention
    to `available_scan_masks` in the driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**Setup the buffer size** : Here one should set the number of sample sets that
    may be held by the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Enable the buffer** : This step consists of marking the buffer as being ready
    to receive pushed data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To stop the capture, we'll have to write 0 in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fire the trigger** : Launch acquisition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now acquisition is done, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Detach the trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Dump the content of our IIO character device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Capturing using the hrtimer trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the set of commands that allow to capture data using hrtimer
    trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we look at the type to figure out how to process data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Voltage processing: `0x188 >> 2 = 98 * 250 = 24500 = 24.5 v`'
  prefs: []
  type: TYPE_NORMAL
- en: IIO tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some useful tools you can use in order to ease and speed up your
    app''s development with IIO devices. They are available in `tools/iio` in the
    kernel tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lsiio.c` **:** To enumerate IIO triggers, devices, and channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio_event_monitor.c` : Monitor an IIO device''s ioctl interface for IIO events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic_buffer.c` : To retrieve, process, and print data received from an
    IIO device''s buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libiio` : A powerful library developed by analog device to interface IIO devices,
    and available at [https://github.com/analogdevicesinc/libiio](https://github.com/analogdevicesinc/libiio)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should now be familiar with IIO framework and
    vocabulary. You know what channels, device, and triggers are. You can even play
    with your IIO device from the user space, through sysfs or character device. The
    time to write your own IIO driver has come. There are a lot of available existing
    drivers not supporting trigger buffers. You can try to add such features in one
    of them. In the next chapter, we will play with the most useful/used resource
    on a system: the memory. Be strong, the game has just started.'
  prefs: []
  type: TYPE_NORMAL

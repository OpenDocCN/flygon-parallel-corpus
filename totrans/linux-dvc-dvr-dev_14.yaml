- en: Pin Control and GPIO Subsystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most embedded Linux driver and kernel engineers write using GPIOs or play with
    pins multiplexing. By pins, I mean outgoing line of component. SoC does multiplex
    pins, meaning that a pin may have several functions, for example, `MX6QDL_PAD_SD3_DAT1`
    in `arch/arm/boot/dts/imx6dl-pinfunc.h` can be either an SD3 data line 1, UART1's
    cts/rts, Flexcan2's Rx, or normal GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism by which one choses the mode a pin should work on is called pin
    muxing. The system responsible for is called the pin controller. In the second
    part of the chapter, we will discuss the **General Purpose Input Output** (**GPIO**
    ), which is a special function (mode) in which a pin can operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Walk through the pin control subsystem, and see how one can declare their nodes
    in DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore both legacy integer-based GPIO interfaces, as well as the new descriptor-based
    interface API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deal with GPIO mapped to IRQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle sysfs interfaces dedicated to GPIOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin control subsystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Pin control** (**pinctrl** ) subsystem allows managing pin muxing. In
    the DT, devices that need pins to be multiplexed in a certain way must declare
    the pin control configuration they need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pinctrl subsystem provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin multiplexing, which allows for reusing the same pin for different purposes,
    such as one pin being a UART TX pin, GPIO line, or HSI data line. Multiplexing
    can affect groups of pins or individual pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin configuration, applying electronic properties of pins such as pull-up, pull-down,
    driver strength, debounce period, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this book is limited to using functions exported by the pin controller
    driver, and does not not how to write a pin controller driver.
  prefs: []
  type: TYPE_NORMAL
- en: Pinctrl and the device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pinctrl is nothing but a way to gather pins (not only GPIO), and pass them
    to the driver. The pin controller driver is responsible for parsing pin descriptions
    in the DT and applying their configuration in the chip. The driver usually needs
    a set of two nested nodes to describe group of pins configurations. The first
    node describes the function of the group (what purpose the group will be used
    for), the second holds the pins configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How pin groups are assigned in the DT heavily depends on the platform, and thus
    the pin controller driver. Every pin control state is given an integer ID starting
    at 0 and contiguous. One can use a name property, which will be mapped on top
    of IDs, so that the same name always points to the same ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each client device''s own binding determines the set of states that must be
    defined in its DT node, and whether to define the set of state IDs that must be
    provided, or whether to define the set of state names that must be provided. In
    any case, a pin configuration node can be assigned to a device by means of two
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pinctrl-<ID>` : This allows for giving the list of pinctrl configurations
    needed for a certain state of the device. It is a list of phandles, each of which
    points to a pin configuration node. These referenced pin configuration nodes must
    be child nodes of the pin controller that they configure. Multiple entries may
    exist in this list so that multiple pin controllers may be configured, or so that
    a state may be built from multiple nodes for a single pin controller, each contributing
    part of the overall configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pinctrl-name` : This allows for giving a name to each state in a list. List
    entry 0 defines the name for integer state ID 0, list entry 1 for state ID 1,
    and so on. The state ID 0 is commonly given the name *default* . The list of standardized
    states can be found in `include/linux/pinctrl/pinctrl-state.h` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an excerpt of DT, showing some device nodes, along with their
    pin control nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, a pin configuration is given in the form `<PIN_FUNCTION>
    <PIN_SETTING>` . For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09` represents the pin function, which is
    GPIO in this case, and `0x80000000` represents the pin settings.'
  prefs: []
  type: TYPE_NORMAL
- en: For this line,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`MX6QDL_PAD_EIM_D25__UART3_RX_DATA` represents the pin function, which is the
    RX line of UART3, and `0x1b0b1` represent is settings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pin function is a macro whose value is meaningful for pin controller driver
    only. These are generally defined in header files located in `arch/<arch>/boot/dts/`
    . If one uses a UDOO quad, for example, which has an i.MX6 quad core (ARM), the
    pin function header would be `arch/arm/boot/dts/imx6q-pinfunc.h` . The following
    is the macro corresponding to the fifth line of the GPIO5 controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`<PIN_SETTING>` can be used to set up things like pull-ups, pull-downs, keepers,
    drive strength, and so on. How it should be specified depends on the pin controller
    binding, and the meaning of its value depends on the SoC data sheet, generally
    in the IOMUX section. On i.MX6 IOMUXC, only lower than 17 bits are used for this
    purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: These preceding nodes are called from the corresponding driver-specific node.
    Moreover, these pins are configured during corresponding driver initialization.
    Prior to selecting a pin group state, one must get the pin control first using
    the `pinctrl_get()` function, call `pinctrl_lookup_state()` in order to check
    whether the requested state exist or not, and finally `pinctrl_select_state()`
    to apply the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample that shows how to get a pincontrol and apply its
    default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One usually performs such steps during driver initialization. The suitable place
    for this code could be within the `probe()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`pinctrl_select_state()` internally calls `pinmux_enable_setting()` , which
    in turn calls the `pin_request()` on each pin in the pin control node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pin control can be released with the `pinctrl_put()` function. One can use
    the resource-managed version of the API. That said, one can use `pinctrl_get_select()`
    , given the name of the state to select, in order to configure pinmux. The function
    is defined in `include/linux/pinctrl/consumer.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'where `*name` is the state name as written in `pinctrl-name` property. If the
    name of the state is `default` , one can just call `pinctr_get_select_default()`
    function, which is a wrapper around `pinctl_get_select()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see a real example in a board-specific dts file (`am335x-evm.dts` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the corresponding driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The pin control core will automatically claim the `default` pinctrl state for
    us when the device is probed. If one defines an `init` state, the pinctrl core
    will automatically set pinctrl to this state before the `probe()` function, and
    then switch to the `default` state after `probe()` (unless the driver explicitly
    changed states already).
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO subsystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the hardware point of view, a GPIO is a functionality, a mode in which
    a pin can operate. From a software point of view, a GPIO is nothing but a digital
    line, which can operate as an input or output, and can have only two values: (`1`
    for high or `0` for low). Kernel GPIO subsystems provide every function you can
    imagine to set up and handle GPIO line from within your driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to using a GPIO from within the driver, one should claim it to the kernel.
    This is a way to take the ownership of the GPIO, preventing other drivers from
    accessing the same GPIO. After taking the ownership of the GPIO, one can:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggle its output state (driving line high or low) if used as output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the debounce-interval and read the state, if used as input. For GPIO lines
    mapped to IRQ, one can define at what edge/level the interrupt should be triggered,
    and register a handler that will be run whenever the interrupt occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are actually two different ways to deal with GPIO in the kernel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The legacy and depreciated integer-based interface, where GPIOs are represented
    by integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new and recommended descriptor-based interface, where a GPIO is represented
    and described by an opaque structure, with a dedicated API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The integer-based GPIO interface: legacy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integer-based interface is the most well-known. The GPIO is identified
    by an integer, which is used for every operation that needs to be performed on
    the GPIO. The following is the header that contains legacy GPIO access functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are well known functions to handle GPIO in kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Claiming and configuring the GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One can allocate and take the ownership of a GPIO using the `gpio_request()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`gpio` represents the GPIO number we are interested in, and `label` is the
    label used by the kernel for the GPIO in sysfs, as we can see in `/sys/kernel/debug/gpio`
    . You have to check the value returned, where `0` mean success, and negative error
    code on error. Once done with the GPIO, it should be set free with the `gpio_free()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If in doubt, one can use `gpio_is_valid()` function to check whether this GPIO
    number is valid on the system prior to allocate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we own the GPIO, we can change its direction, depending on the need, and
    whether it should be an input or output, using the `gpio_direction_input()` or
    `gpio_direction_output()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`gpio` is the GPIO number we need to set the direction. There is a second parameter
    when it comes to configuring the GPIO as output: `value` , which is the state
    the GPIO should be in once the output direction is effective. Here again, the
    return value is zero or a negative error number. These functions are internally
    mapped on top of lower level callback functions exposed by the driver of the GPIO
    controller that provides the GPIO we use. In the next [Chapter 15](http://gpio)
    , *GPIO Controller Drivers - gpio_chip* , dealing with GPIO controller drivers,
    we will see that a GPIO controller, through its `struct gpio_chip` structure,
    must expose a generic set of callback functions to use its GPIOs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some GPIO controllers offer the possibility to change the GPIO debounce-interval
    (this is only useful when the GPIO line is configured as input). This feature
    is platform-dependent. One can use `int gpio_set_debounce()` to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: where `debounce` is the debounce time in ms.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding functions should be called in a context that may sleep. It
    is a good practice to claim and configure GPIOs from within the driver's `probe`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the GPIO â€“ getting/setting the value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should pay attention when accessing GPIO. In an atomic context, especially
    in an interrupt handler, one has to be sure the GPIO controller callback functions
    will not sleep. A well-designed controller driver should be able to inform other
    drivers (actually clients) whether call to its methods may sleep or not. This
    can be checked with `gpio_cansleep()` function.
  prefs: []
  type: TYPE_NORMAL
- en: None of the functions used to access GPIO return an error code. That is why
    you should pay attention and check return values during GPIO allocation and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In atomic context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are GPIO controllers that can be accessed and managed through simple
    memory read/write operations. These are generally embedded in the SoC, and do
    not need to sleep. `gpio_cansleep()` will always return `false` for those controllers.
    For such GPIOs, you can get/set their value from within an IRQ handler, using
    the well-known `gpio_get_value()` or `gpio_set_value()` , depending on the GPIO
    line being configured as input or output :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`gpio_get_value()` should be used when the GPIO is configured as input (using
    `gpio_direction_input()` ), and return the actual value (state) of the GPIO. On
    the other hand, `gpio_set_value()` will affect the value of the GPIO, which should
    have been configured as an output using `gpio_direction_output()` . For both function,
    `value` can be considered as `Boolean` , where zero means low, and non-zero value
    mean high.'
  prefs: []
  type: TYPE_NORMAL
- en: In a non-atomic context (that may sleep)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the other hand, there are GPIO controllers wired on buses such as SPI and
    I2C. Since functions accessing those buses may lead to sleep, the `gpio_cansleep()`
    function should always return `true` (it is up to the GPIO controller to take
    of returning true). In this case, you should not access those GPIOs from within
    the IRQ handled, at least not in the top half (the hard IRQ). Moreover, the accessors
    you have to use as your general-purpose access should be suffixed with `_cansleep`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: They behave exactly like accessors without the `_cansleep()` name suffix, with
    the only difference being that they prevent the kernel from printing warnings
    when the GPIOs are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: GPIOs mapped to IRQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Input GPIOs can often be used as IRQ signals. Such IRQs can be edge-triggered
    or level-triggered. The configuration depends on your needs. The GPIO controller
    is responsible for providing the mapping between the GPIO and its IRQ. One can
    use `goio_to_irq()` to map a given GPIO number to its IRQ number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is the IRQ number, on which one can call `request_irq()` (or
    the threaded version `request_threaded_irq()` ) in order to register a handler
    for this IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code is a summary putting into practice all the concepts discussed
    regarding integer-based interfaces. This driver manages four GPIOs: two buttons
    (btn1 and btn2), and two LEDs (green and red). Btn1 is mapped to an IRQ, and whenever
    its state changes to LOW, the state of btn2 is applied to LEDs. For example, if
    the state of btn1 goes LOW while btn2 is high, `GREEN` and `RED` led will be driven
    to HIGH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The descriptor-based GPIO interface: the new and recommended way'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the new descriptor-based GPIO interface, a GPIO is characterized by a
    coherent `struct gpio_desc` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One should use the following header to be able to use the new interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With the descriptor-based interface, prior to allocating and taking the ownership
    of GPIOs, those GPIOs must have been mapped somewhere. By mapped, I mean they
    should be assigned to your device, whereas with the legacy integer-based interface,
    you just have to fetch a number anywhere and request it as a GPIO. Actually, there
    are three kinds of mapping in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform data mapping** : The mapping is done in the board file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device tree** : The mapping is done in DT style, the same as discussed in
    the preceding sections. This is the mapping we will discuss in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Configuration and Power Interface mapping** (**ACPI** ): The mapping
    is done in ACPI style. Generally used on x86-based systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIO descriptor mapping - the device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GPIO descriptor mappings are defined in the consumer device's node. The property
    that contains a GPIO descriptor mapping must be named `<name>-gpios` or `<name>-gpio`
    , where `<name>` is meaningful enough to describe the function for which those
    GPIOs will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'One should always suffix the property name with either `-gpio` or `-gpios`
    because every descriptor-based interface function relies on the `gpio_suffixes[]`
    variable, defined in `drivers/gpio/gpiolib.h` and shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how by having a look at the function used to look for GPIO descriptors
    mappings in devices in DT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us consider the following node, which is an excerpt of `Documentation/gpio/board.txt`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is what a mapping should look like, with meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and using GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One can use either `gpiog_get()` or `gpiod_get_index()` to allocate a GPIO
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On error, these functions will return `-ENOENT` if no GPIO with the given function
    is assigned, or another error on which one can use the `IS_ERR()` macro. The first
    function returns the GPIO descriptor structure that corresponds to the GPIO at
    a given index, whereas the second function returns the GPIO at index 0 (useful
    for one-GPIO mapping). `dev` is the device to which the GPIO descriptor will belong.
    It is your device. `con_id` is the function within the GPIO consumer. It corresponds
    to the `<name>` prefix of the property name in the DT. `idx` is the index (starting
    from 0) of the GPIO for which one needs a descriptor. `flags` is an optional parameter
    that determines the GPIO initialization flags, to configure direction and/or output
    value. It is an instance of `enum gpiod_flags` , defined in `include/linux/gpio/consumer.h`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us allocate GPIO descriptors for mappings defined in the preceding
    DT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The LED GPIOs will be active-high, while the power GPIO will be active-low
    (that is, `gpiod_is_active_low(power)` will be true). The reverse operation of
    allocation is done with the `gpiod_put()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how one can release `red` and `blue` GPIO LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Before we go further, keep in mind that apart from the `gpiod_get()` /`gpiod_get_index()`
    and `gpio_put()` functions, which completely differ from `gpio_request()` and
    `gpio_free()` , one can perform API translation from integer-based interfaces
    to descriptor-based ones just by changing the `gpio_` prefix into `gpiod_` .
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, to change direction, one should use the `gpiod_direction_input()`
    and `gpiod_direction_output()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`value` is the state to apply to the GPIO once the direction is set to output.
    If the GPIO controller has this feature, one can set the debounce timeout of a
    given GPIO using its descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access a GPIO given its descriptor, the same attention must be
    paid as with the integer-based interface. In other words, one should take care
    whether one is in an atomic (cannot sleep) or non-atomic context, and then use
    the appropriate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For a GPIO descriptor mapped to IRQ, one can use `gpiod_to_irq()` in order
    to get the IRQ number that corresponds to the given GPIO descriptor, which can
    be used with the `request_irq()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At any given time in the code, one can switch from the descriptor-based interface
    to the legacy integer-based interface and vice versa, using the `desc_to_gpio()`
    or `gpio_to_desc()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The driver bellows summarizes the concepts introduced in descriptor-based interfaces.
    The principle is the same, as are the GPIOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The GPIO interface and the device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever interface one needs to use GPIO for, how to specify GPIOs depends on
    the controller providing them, especially regarding its `#gpio-cells` property,
    which determines the number of cells used for a GPIO specifier. A GPIO specifier
    contains at least the controller phandle, and one or more argument, where the
    number of arguments on `#gpio-cells` property of the controller that provides
    the GPIO. The first cell is generally the GPIO offset number on the controller,
    and the second represents the GPIO flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIO properties should be named `[<name>-]gpios]` , with `<name>` being the
    purpose of this GPIO for the device. Keep in mind this rule is a must for descriptor-based
    interfaces, and becomes `<name>-gpios` (note the absence of square brackets, meaning
    that the `<name>` prefix is mandatory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample, CS GPIOs contain both controller-1 and controller-2
    GPIOs. If one does not need to specify a GPIO at a given index in the list, one
    can use `<0>` . The reset GPIO has two cells (two arguments after the controller
    phandle), whereas CD GPIO has only one cell. You can see how meaningful the names
    are that I gave to my GPIO specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy integer-based interface and device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This interface relies on the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two functions you should remember when you need to support DT from
    within your driver using legacy integer-based interfaces; these are `of_get_named_gpio()`
    and `of_get_named_gpio_count()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a device node, the former returns the GPIO number of the property `*propname`
    at `index` position. The second just returns the number of GPIOs specified in
    the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are drivers still supporting the old specifier, where GPIO properties
    are named `[<name>-gpio` ] or `gpios` . In that case, one should use unnamed API
    versions, by means of `of_get_gpio()` and `of_gpio_count()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The DT node would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the driver would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'One can summarize this by rewriting the first driver (the one for integer-based
    interfaces), in order to comply with the platform drivers structure, and use DT
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: GPIO mapping to IRQ in the device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One can easily map GPIO to IRQ in the device tree. Two properties are used
    to specify an interrupt:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interrupt-parent` : This is the GPIO controller for GPIO'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interrupts` : This is the interrupts specifier list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This applies to legacy and descriptor-based interface. The IRQ specifier depends
    on the `#interrupt-cell` property of the GPIO controller providing this GPIO.
    `#interrupt-cell` determine the number of cells used when specifying the interrupt.
    Generally, the first cell represents the GPIO number to map to an IRQ and the
    second cell represents what level/edge should trigger the interrupt. In any case,
    interrupt specifier always depends on its parent (the one which has the interrupt-controller
    set), so refer to its binding documentation in the kernel source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two solutions for obtaining the corresponding IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your device sits on a known bus (I2C or SPI)** : The IRQ mapping will be
    done for you, and made available either through the `struct i2c_client` or `struct
    spi_device` structure given to your `probe()` function (by means of `i2c_client.irq`
    or `spi_device.irq` ).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Your device sits on the pseudo-platform bus** : The `probe()` function will
    be given a `struct platform_device` , on which you can call `platform_get_irq()`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to have a look at [Chapter 6](text00162.html) , *The Concept of Device
    Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: GPIO and sysfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sysfs GPIO interface lets people manage and control GPIOs through sets
    or files. It is located under `/sys/class/gpio` . The device model is heavily
    used here, and there are three kinds of entries available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/class/gpio/:` This is where everything begins. This directory contains
    two special files, `export` and `unexport` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export` : This allow us to ask the kernel to export control of a given GPIO
    to user space by writing its number to this file. Example: `echo 21 > export`
    will create a GPIO21 node for GPIO #21, if that''s not requested by kernel code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unexport` : This reverses the effect of exporting to user space. Example:
    `echo 21 > unexport` will remove any GPIO21 node exported using the export file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/class/gpio/gpioN/` : This directory corresponds to the GPIO number N
    (where N is global to the system, not relative to the chip), exported either using
    the `export` file, or from within the kernel. For example: `/sys/class/gpio/gpio42/`
    (for GPIO #42) with the following read/write attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `direction` file is used to get/set GPIO direction. Allowed values are either
    `in` or `out` strings. This value may normally be written. Writing as out defaults
    to initializing the value as low. To ensure glitch-free operation, low and high
    values may be written to configure the GPIO as an output with that initial value.
    This attribute will not exist if the kernel code has exported this GPIO, disabling
    direction (see the `gpiod_export()` or `gpio_export()` function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `value` attribute lets us get/set the state of the GPIO line, depending
    on the direction, input or output. If the GPIO is configured as an output, any
    non-zero value written will be treated as HIGH state. If configured as an output,
    writing `0` will set the output low, whereas `1` will set the output high. If
    the pin can be configured as an interrupt-generating lines and if it has been
    configured to generate, one can call the `poll(2)` system call on that file and
    `poll(2)` will return whenever the interrupt was triggered. Using `poll(2)` wil
    require setting the events `POLLPRI` and `POLLERR` . If one uses `select(2)` instead,
    one should set the file descriptor in `exceptfds` . After `poll(2)` returns, either
    `lseek(2)` to the beginning of the sysfs file and read the new value or close
    the file and re-open it to read the value. It is the same principle as we discussed
    regarding the pollable sysfs attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edge` determines the signal edge that will let the `poll()` or `select()`
    function return. Allowed values are `none` , `rising` , `falling` , or `both`
    . This file is readable/writable, and exists only if the pin can be configured
    as an interrupt-generating input pin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_low` reads as either 0 (false) or 1 (true). Writing any non-zero value
    will invert the *value* attribute for both reading and writing. Existing and subsequent
    `poll(2)` support configurations through the edge attribute for rising and falling
    edges will follow this setting. The relevant function from kernel to set this
    value is `gpio_sysf_set_active_low()` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting a GPIO from kernel code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from using `/sys/class/gpio/export` file to export a GPIO to user space,
    one can use functions like `gpio_export` (for legacy interface) or `gpioD_export`
    (the new interface) from the kernel code in order to explicitly manage export
    of GPIOs which have already been requested using `gpio_request()` or `gpiod_get()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `direction_may_change` parameter decides if one can change the signal direction
    from input to output and vice versa. The reverse operations from kernel are `gpio_unexport()`
    or `gpiod_unexport():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once exported, one can use `gpio_export_link()` (or `gpiod_export_link()` for
    descriptor-based interfaces) in order to create symbolic links from elsewhere
    in sysfs, which will point to the GPIO sysfs node. Drivers can use this to provide
    the interface under their own device in sysfs with a descriptive name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'One could use this in the `probe()` function for descriptor-based interfaces
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For integer-based interfaces, the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with a GPIO from within the kernel is an easy task, as shown in this
    chapter. Both legacy and new interfaces are discussed, giving the possibility
    to choose the one that fits your needs, in order to write enhanced GPIO drivers.
    You'll be able to handle IRQs mapped to GPIOs. The next chapter will deal with
    the chip that provides and exposes GPIO lines, known as the GPIO controller.
  prefs: []
  type: TYPE_NORMAL

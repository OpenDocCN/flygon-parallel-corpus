- en: Chapter 2. Basic Components That Make Up a Three.js Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned the basics of Three.js. We showed a couple
    of examples, and you created your first complete Three.js scene. In this chapter,
    we''ll dive a bit deeper into Three.js and explain the basic components that make
    up a Three.js scene. In this chapter, you''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The components that are used in a Three.js scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you can do with the `THREE.Scene` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How geometries and meshes are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the orthographic and perspective cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start with looking at how you can create a scene and add objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you created `THREE.Scene`, so you already know the
    basics of Three.js. We saw that for a scene to show anything, we need three types
    of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Camera | This determines what is rendered on the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| Lights | These have an effect on how materials are shown and used when creating
    shadow effects (discussed in detail in [Chapter 3](ch03.html "Chapter 3. Working
    with the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*). |'
  prefs: []
  type: TYPE_TB
- en: '| Objects | These are the main objects that are rendered from the perspective
    of the camera: cubes, spheres, and the like. |'
  prefs: []
  type: TYPE_TB
- en: '`THREE.Scene` serves as the container for all these different objects. This
    object itself doesn''t have that many options and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`THREE.Scene` is a structure that is sometimes also called a scene graph. A
    scene graph is a structure that can hold all necessary information of a graphical
    scene. In Three.js, this means that `THREE.Scene` contains all the objects, lights,
    and other objects necessary for rendering. What is interesting to note is that
    a scene graph, as the name implies, isn''t just an array of objects; a scene graph
    consists of a set of nodes in a tree structure. Each object you can add to the
    scene in Three.js, and even `THREE.Scene` itself, extends from a base object named
    `THREE.Object3D`. A `THREE.Object3D` object can also have its own children, which
    you can use to create a tree of objects that Three.js will interpret and render.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic functionality of a scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to explore the functionality of a scene is by looking at an example.
    In the source code for this chapter, you can find the `01-basic-scene.html` example.
    I''ll use this example to explain the various functions and options a scene has.
    When we open this example in the browser, the output will look somewhat like what''s
    shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic functionality of a scene](graphics/2215OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This looks pretty much like the examples we saw in the previous chapter. Even
    though the scene looks pretty empty, it already contains a couple of objects.
    Looking at the following source, we can see that we used the `scene.add(object)`
    function from the `THREE.Scene` object to add `THREE.Mesh` (the ground plane you
    see), `THREE.SpotLight`, and `THREE.AmbientLight`. The `THREE.Camera` object is
    added automatically by Three.js when you render the scene, but it is good practice
    to add it to the scene manually, especially when you''re working with multiple
    cameras. Take a look at the following source code for this scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look deeper into the `THREE.Scene` object, I''ll first explain what
    you can do in the demo, and after that, we''ll look at some code. Open the `01-basic-scene.html`
    example in your browser and look at the controls in the upper-right corner, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic functionality of a scene](graphics/2215OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With these controls, you can add a cube to the scene, remove the cube that
    was last added to the scene, and show all the current objects that the scene contains
    in the console of your browser. The last entry in the controls section shows the
    current number of objects in the scene. What you''ll probably notice when you
    start up the scene is that there are already four objects in the scene. These
    are the ground plane, the ambient light, and the spotlight, as well as the camera
    we mentioned earlier. We''ll look at each of the functions in the control section
    and start with the easiest one, `addCube`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code should already be pretty easy to read by now. Not many new
    concepts are introduced here. When you hit the **addCube** button, a new `THREE.BoxGeometry`
    object is created whose width, height, and depth are set to a random value between
    1 and 3\. Besides a random size, the cube also gets a random color and a random
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new element that we introduce here is that we also give the cube a name using
    its `name` attribute. Its name is set to `cube-`, appended with the number of
    objects currently in the scene (`scene.children.length`). A name is very useful
    for debugging purposes but can also be used to directly access an object from
    your scene. If you use the `THREE.Scene.getObjectByName(name)` function, you can
    directly retrieve a specific object and, for instance, change its location without
    having to make the JavaScript object a global variable. You might wonder what
    the last line does. The `numberOfObjects` variable is used by our control GUI
    to list the number of objects in the scene. So, whenever we add or remove an object,
    we set this variable to the updated count.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we can call from the control GUI is `removeCube`. As the
    name implies, clicking on the **removeCube** button removes the last added cube
    from the scene. In code, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To add an object to the scene, we use the `add` function. To remove an object
    from the scene, we use, not very surprisingly, the `remove` function. Since Three.js
    stores its children as a list (new ones are added at the end), we can use the
    `children` property, which contains an array of all the objects in the scene,
    from the `THREE.Scene` object to get the last object that was added. We also need
    to check whether that object is a `THREE.Mesh` object to avoid removing the camera
    and the lights. After we've removed the object, we once again update the GUI property,
    `numberOfObjects`, that holds the number of objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final button on our GUI is labeled **outputObjects**. You probably already
    clicked on this and nothing seemed to happen. This button prints out all the objects
    that are currently in our scene to the web browser console, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic functionality of a scene](graphics/2215OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to output information to the console log makes use of the built-in
    `console` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great for debugging purposes, and especially when you name your objects,
    it''s very useful to find issues and problems with a specific object in your scene.
    For instance, the properties of `cube-17` look like this (if you already know
    the name beforehand, you could also use `console.log(scene.getObjectByName("cube-17")`
    to output only that single object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Until now, we''ve seen the following scene-related functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.Scene.Add`: This adds an object to the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.Scene.Remove`: This removes an object from the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.Scene.children`: This gets a list of all the children in the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.Scene.getObjectByName`: This gets a specific object, by name, from the
    scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the most important scene-related functions, and most often, you won't
    need any more than this. There are, however, a couple of helper functions that
    could come in handy, and I'd like to show them based on the code that handles
    the cube rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous chapter, we used a *render loop* to render the scene.
    Let''s look at that loop for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the `THREE.Scene.traverse()` function being used. We can pass a
    function to the `traverse()` function that will be called for each child of the
    scene. If a child itself has children, remember that a `THREE.Scene` object can
    contain a tree of objects. The `traverse()` function will also be called for all
    the children of that object. You traverse through the complete scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `render()` function to update the rotation for each of the cubes
    (note that we explicitly ignore the ground plane). We could also have done this
    by iterating ourselves over the `children` property array using a `for` loop since
    we've only added objects to `THREE.Scene` and haven't created a nested structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the details of `THREE.Mesh` and `THREE.Geometry`, I''d
    like to show two interesting properties that you can set on the `THREE.Scene`
    object: `fog` and `overrideMaterial`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding fog to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **fog** property lets you add a fog effect to the complete scene; the farther
    off an object is, the more it will be hidden from sight, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding fog to the scene](graphics/2215OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enabling fog is really easy in Three.js. Just add the following line of code
    after you''ve defined your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a white fog (`0xffffff`). The preceding two properties can
    be used to tune how the mist appears. The `0.015` value sets the `near` property,
    and the `100` value sets the `far` property. With these properties, you can determine
    where the mist starts and how fast it gets denser. With the `THREE.Fog` object,
    the fog increases linearly. There is also a different way to set the mist for
    the scene; for this, use the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, we don't specify `near` and `far`, but just the color (`0xffffff`)
    and the mist's density (`0.01`). It's best to experiment a bit with these properties
    to get the effect you want. Note that with `THREE.FogExp2`, the fog doesn't increase
    linearly but grows exponentially denser with the distance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the overrideMaterial property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last property we discuss for the scene is **overrideMaterial**. When you
    use this property, all the objects in the scene will use the material that is
    set to the `overrideMaterial` property and ignore the material that is set on
    the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon using the `overrideMaterial` property as shown in the preceding code,
    the scene will be rendered as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the overrideMaterial property](graphics/2215OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, you can see that all the cubes are rendered using the
    same material and the same color. In this example, we used a `THREE.MeshLambertMaterial`
    object as the material. With this material type, we can create non-shiny-looking
    objects that respond to the lights that are present in the scene. In [Chapter
    4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working with Three.js
    Materials*, you'll learn more about this material.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we looked at the first of the core concepts of Three.js: `THREE.Scene`.
    The most important thing to remember about the scene is that it is basically a
    container for all the objects, lights, and cameras you want to use when rendering.
    The following table summarizes the most important functions and attributes of
    the `THREE.Scene` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function/Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add(object)` | This is used to add an object to the scene. You can also
    use this function, as we''ll see later on, to create groups of objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `children` | This returns a list of all the objects that have been added
    to the scene, including the camera and lights. |'
  prefs: []
  type: TYPE_TB
- en: '| `getObjectByName(name, recursive)` | When you create an object, you can give
    it a distinct name. The scene object has a function that you can use to directly
    return an object with a specific name. If you set the recursive argument to `true`,
    Three.js will also search through the complete tree of objects to find the object
    with the specified name. |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(object)` | If you have a reference to an object in the scene, you
    can also remove it from the scene using this function. |'
  prefs: []
  type: TYPE_TB
- en: '| `traverse(function)` | The children property returns a list of all the children
    in the scene. With the traverse function, we can also access these children. With
    traverse, all the children are passed in to the supplied function one by one.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fog` | This property allows you to set the fog for the scene. The fog will
    render a haze that hides faraway objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `overrideMaterial` | With this property, you can force all the objects in
    the scene to use the same material. |'
  prefs: []
  type: TYPE_TB
- en: In the next section, we'll take a closer look at the objects that you can add
    to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Geometries and meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In each of the examples until now, you''ve seen geometries and meshes being
    used. For instance, to add a sphere to the scene, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We defined the shape of the object and its geometry (`THREE.SphereGeometry`),
    we defined what this object looks like (`THREE.MeshBasicMaterial`) and its material,
    and we combined these two in a mesh (`THREE.Mesh`) that can be added to a scene.
    In this section, we'll take a closer look at what a geometry is and what a mesh
    is. We'll start with the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: The properties and functions of a geometry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js comes with a large set of geometries out of the box that you can use
    in your 3D scene. Just add a material, create a mesh, and you''re pretty much
    done. The following screenshot, from example `04-geometries`, shows a couple of
    the standard geometries available in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The properties and functions of a geometry](graphics/2215OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 6](ch06.html "Chapter 6. Advanced Geometries
    and Binary Operations"), *Advanced Geometries and Binary Operations*, we'll explore
    all the basic and advanced geometries that Three.js has to offer. For now, we'll
    look in greater detail at what a geometry actually is.
  prefs: []
  type: TYPE_NORMAL
- en: 'A geometry in Three.js, and in most other 3D libraries, is basically a collection
    of points in a 3D space, also called vertices, and a number of faces connecting
    those points together. Take, for example, a cube:'
  prefs: []
  type: TYPE_NORMAL
- en: A cube has eight corners. Each of these corners can be defined as an *x*, *y*,
    and *z* coordinate. So each cube has eight points in a 3D space. In Three.js,
    these points are called vertices, and a single one is called a vertex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cube has six sides, with a vertex at each corner. In Three.js, a face always
    consists of three vertices that make a triangle. So, in the case of a cube, each
    side consists of two triangles to make the complete side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you use one of the geometries provided by Three.js, you don''t have to
    define all the vertices and faces yourself. For a cube, you only need to define
    the width, height, and depth. Three.js uses that information and creates a geometry
    with eight vertices at the correct position and the correct number of faces (12
    in the case of a cube). Even though you''d normally use the geometries provided
    by Three.js or generate them automatically, you can still create geometries completely
    by hand using vertices and faces. This is shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code shows how to create a simple cube. We define the points that make
    up this cube in the `vertices` array. These points are connected to create triangular
    faces and are stored in the `faces` array. For instance, `new THREE.Face3(0,2,1)`
    creates a triangular face using the points `0`, `2`, and `1` from the `vertices`
    array. Note that you have to take care of the sequence of the vertices used to
    create `THREE.Face`. The order in which they are defined determines whether Three.js
    thinks it is a front-facing face (a face facing the camera) or a back-facing face.
    If you create the faces, you should use a clockwise sequence for front-facing
    faces and a counterclockwise sequence if you want to create a back-facing face.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we used a `THREE.Face3` element to define the six sides of
    the cube, with two triangles for each face. In previous versions of Three.js,
    you could also use a quad instead of a triangle. A quad uses four vertices instead
    of three to define the face. Whether using quads or triangles is better is a heated
    debate raging in the 3D modeling world. Basically though, using quads is often
    preferred during modeling since they can be more easily enhanced and smoothed
    than triangles. For render and game engines though, working with triangles is
    often easier since every shape can be rendered very efficiently as a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: Using these vertices and faces, we can now create a new instance of `THREE.Geometry`
    and assign the vertices to the `vertices` attribute and the faces to the `faces`
    attribute. The last step that we need to take is call `computeFaceNormals()` on
    the geometry we created. When we call this function, Three.js determines the *normal*
    vector for each of the faces. This is the information Three.js uses to determine
    how to color the faces based on the various lights in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this geometry, we can now create a mesh just as we saw earlier. I''ve
    created an example that you can use to play around with the position of the vertices,
    and which also shows the individual faces. In example `05-custom-geometry`, you
    can change the position of all the vertices of a cube and see how the faces react.
    This is shown in the following screenshot (should the control GUI be in the way,
    you can hide it by pressing *H*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The properties and functions of a geometry](graphics/2215OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This example, which uses the same setup as all our other examples, has a render
    loop. Whenever you change one of the properties in the drop-down control box,
    the cube is rendered based on the changed position of one of the vertices. This
    isn''t something that works out of the box. For performance reasons, Three.js
    assumes that the geometry of a mesh won''t change during its lifetime. For most
    geometries and use cases, this is a very valid assumption. To get our example
    to work, however, we need to make sure the following is added to the code in the
    render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we point the vertices of the mesh you see on screen to an
    array of updated vertices. We don't need to reconfigure the faces since they are
    still connected to the same points as they were before. After we've set the updated
    vertices, we need to tell the geometry that the vertices need to be updated. We
    do this by setting the `verticesNeedUpdate` property of the geometry to `true`.
    Finally, we do a recalculation of the faces to update the complete model using
    the `computeFaceNormals` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last geometry functionality we''ll look at is the `clone()` function. We
    mentioned that the geometry defines the form and shape of an object, and combined
    with a material, we create an object that can be added to the scene to be rendered
    by Three.js. With the `clone()` function, as the name implies, we can make a copy
    of the geometry, and for instance, use it to create a different mesh with a different
    material. In the same example, `05-custom-geometry`, you can see a **clone** button
    at the top of the control GUI, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The properties and functions of a geometry](graphics/2215OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on this button, a clone (a copy) will be made of the geometry
    as it currently is, a new object is created with a different material, and it
    is added to the scene. The code for this is rather simple but is made a bit more
    complex because of the materials I used. Let''s take a step back and first look
    at how the green material for the cube was created, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I didn't use a single material, but I used an array of two materials.
    The reason is that besides showing a transparent green cube, I also wanted to
    show you the wireframe since that shows up very clearly where the vertices and
    faces are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js, of course, supports using multiple materials when creating a mesh.
    You can use the `SceneUtils.createMultiMaterialObject` function for this, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What Three.js does in this function is that it doesn''t create one `THREE.Mesh`
    object, but it creates one for each material you specified and puts these meshes
    in a group (a `THREE.Object3D` object). This group can be used in the same manner
    as you''ve used the scene object. You can add meshes, get objects by name, and
    so on. For instance, to make sure all the children of the group cast shadows,
    you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s get back to the `clone()` function we were discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This piece of JavaScript is called when the **clone** button is clicked on.
    Here, we clone the geometry of the first child of our cube. Remember, the mesh
    variable contains two children; it contains two meshes, one for each material
    we specified. Based on this cloned geometry, we create a new mesh, aptly named
    `mesh2`. We move this new mesh using translate functions (more on this in [Chapter
    5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning to Work
    with Geometries*), remove the previous clone (if present), and add the clone to
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we used `createMultiMaterialObject` from the `THREE.SceneUtils`
    object to add a wireframe to the geometry we created. Three.js also provides an
    alternative way of adding a wireframe using `THREE.WireFrameHelper`. To use this
    helper, first instantiate the helper like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You provide the mesh you want to show the wireframe for and the color of the
    wireframe. Three.js will now create a helper object that you can add to the scene,
    `scene.add(helper)`. Since this helper internally is just a `THREE.Line` object,
    you can style how the wireframe appears. For instance, to set the width of the
    wireframe lines, use `helper.material.linewidth = 2;`.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough on geometries for now.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and attributes for meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already learned that to create a mesh, we need a geometry and one or
    more materials. Once we have a mesh, we add it to the scene and it''s rendered.
    There are a couple of properties that you can use to change where and how this
    mesh appears on the scene. In this first example, we''ll look at the following
    set of properties and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function/Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | This determines the position of this object relative to the
    position of its parent. Most often, the parent of an object is a `THREE.Scene`
    object or a `THREE.Object3D` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `rotation` | With this property, you can set the rotation of an object around
    any of its axes. Three.js also provides specific functions for rotations around
    an axis: `rotateX()`, `rotateY()`, and `rotateZ()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `scale` | This property allows you to scale the object around its *x*, *y*,
    and *z* axes. |'
  prefs: []
  type: TYPE_TB
- en: '| `translateX(amount)` | This property moves the object the specified amount
    over the *x* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `translateY(amount)` | This property moves the object the specified amount
    over the *y* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `translateZ(amount)` | This property moves the object the specified amount
    over the *z* axis.For the translate functions, you could also use the `translateOnAxis(axis,
    distance)` function, which allows you to translate the mesh a distance along a
    specific axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `visible` | If you set this property to `false`, `THREE.Mesh` won''t be rendered
    by Three.js. |'
  prefs: []
  type: TYPE_TB
- en: 'As always, we have an example ready for you that will allow you to play around
    with these properties. If you open up `06-mesh-properties.html` in your browser,
    you get a drop-down menu where you can alter all these properties and directly
    see the result, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions and attributes for meshes](graphics/2215OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let me walk you through them, and I''ll start with the position property. We''ve
    already seen this property a couple of times, so let''s quickly address this.
    With this property, you set the *x*, *y*, and *z* coordinates of the object. This
    position is relative to its parent object, which is normally the scene you add
    the object to, but could also be a `THREE.Object3D` object or another `THREE.Mesh`
    object. We''ll get back to this in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, when we look at
    grouping objects. We can set an object''s position property in three different
    ways. We can set each coordinate directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also set all of them at once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a third option. The `position` property is a `THREE.Vector3`
    object. That means, we can also do the following to set this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I want to make a quick sidestep before looking at the other properties of this
    mesh. I mentioned that this position is set relative to the position of its parent.
    In the previous section on `THREE.Geometry`, we used `THREE.SceneUtils.createMultiMaterialObject`
    to create a multi-material object. I explained that this doesn't really return
    a single mesh but a group that contains a mesh based on the same geometry for
    each material; in our case, it's a group that contains two meshes. If we change
    the position of one of these meshes that is created, you can clearly see that
    it really is two distinct `THREE.Mesh` objects. However, if we now move the group
    around, the offset will remain the same, as shown in the following screenshot.
    In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, we look deeper into parent-child relations and how grouping
    affects transformation, such as scaling, rotation, and translation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions and attributes for meshes](graphics/2215OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'OK, next on the list is the `rotation` property. You''ve already seen this
    property being used a couple of times in this chapter and the previous chapter.
    With this property, you set the rotation of the object around one of its axes.
    You can set this value in the same manner as we did the position. A complete rotation,
    as you might remember from math class, is *2 x π*. You can configure this in Three.js
    in a couple of different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use degrees (from 0 to 360) instead, we''ll have to convert
    those to radians. This can be easily done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can play around with this property using the `06-mesh-properties.html` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next property on our list is one we haven''t talked about: `scale`. The
    name pretty much sums up what you can do with this property. You can scale the
    object along a specific axis. If you set the scale to values smaller than one,
    the object will shrink, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions and attributes for meshes](graphics/2215OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you use values larger than one, the object will become larger, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions and attributes for meshes](graphics/2215OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next part of the mesh that we''ll look at in this chapter is the **translate**
    functionality. With translate, you can also change the position of an object,
    but instead of defining the absolute position where you want the object to be,
    you define where the object should move to, relative to its current position.
    For instance, we have a sphere that is added to a scene, and its position has
    been set to `(1,2,3)`. Next, we translate the object along its *x* axis: `translateX(4)`.
    Its position will now be `(5,2,3)`. If we want to restore the object to its original
    position, we do this: `translateX(-4)`. In the `06-mesh-properties.html` example,
    there is a menu tab called **translate**. From there, you can experiment with
    this functionality. Just set the translate values for *x*, *y*, and *z* and hit
    the **translate** button. You''ll see the object being moved to a new position
    based on these three values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last property you can use from the menu in the top-right corner is the
    **visible** property. If you click on the **visible** menu item, you''ll see that
    the cube becomes invisible, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions and attributes for meshes](graphics/2215OS_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on it another time, the cube becomes visible again. For more
    information on meshes, geometries, and what you can do with these objects, look
    at [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 7](ch07.html "Chapter 7. Particles, Sprites,
    and the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: Different cameras for different uses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two different camera types in Three.js: the orthographic camera and
    the perspective camera. In [Chapter 3](ch03.html "Chapter 3. Working with the
    Different Light Sources Available in Three.js"), *Working with the Different Light
    Sources Available in Three.js*, we''ll have a much more detailed look at how to
    work with these cameras, so in this chapter, I''ll stick to the basics. The best
    way to explain the differences between these cameras is by looking at a couple
    of examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Orthographic camera versus perspective camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples for this chapter, you can find a demo called `07-both-cameras.html`.
    When you open this example, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is called a perspective view and is the most natural view. As you can see
    from this figure, the farther away the cubes are from the camera, the smaller
    they are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the camera to the other type supported by Three.js, the orthographic
    camera, you''ll see the following view of the same scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the orthographic camera, all the cubes are rendered the same size; the
    distance between an object and the camera doesn't matter. This is often used in
    2D games such as *SimCity 4* and old versions of *Civilization*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our examples, we''ll use the perspective camera the most since it best resembles
    the real world. Switching cameras is really very easy. The following piece of
    code is called whenever you hit the switch camera button on the `07-both-cameras`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this table, you can see that there is a difference in the way we create
    the camera. Let''s look at `THREE.PerspectiveCamera` first. This camera takes
    the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fov` | **FOV** stands for **Field Of View**. This is the part of the scene
    that can be seen from the position of the camera. Humans, for instance, have an
    almost 180-degree FOV, while some birds might even have a complete 360-degree
    FOV.But since a normal computer screen doesn''t completely fill our vision, normally
    a smaller value is chosen. Most often, for games, a FOV between 60 and 90 degrees
    is chosen.*Good default: 50* |'
  prefs: []
  type: TYPE_TB
- en: '| `aspect` | This is the aspect ratio between the horizontal and vertical sizes
    of the area where we''re to render the output. In our case, since we use the entire
    window, we just use that ratio. The aspect ratio determines the difference between
    the horizontal FOV and the vertical FOV, as you can see in the following image.*Good
    default: window.innerWidth / window.innerHeight* |'
  prefs: []
  type: TYPE_TB
- en: '| `near` | The `near` property defines from how close to the camera Three.js
    should render the scene. Normally, we set this to a very small value to directly
    render everything from the position of the camera.*Good default: 0.1* |'
  prefs: []
  type: TYPE_TB
- en: '| `far` | The `far` property defines how far the camera can see from the position
    of the camera. If we set this too low, a part of our scene might not be rendered,
    and if we set it too high, in some cases, it might affect the rendering performance.*Good
    default: 1000* |'
  prefs: []
  type: TYPE_TB
- en: '| `zoom` | The `zoom` property allows you to zoom in and out of the scene.
    When you use a number lower than `1`, you zoom out of the scene, and if you use
    a number higher than `1`, you zoom in. Note that if you specify a negative value,
    the scene will be rendered upside down.*Good default value: 1* |'
  prefs: []
  type: TYPE_TB
- en: 'The following image gives a good overview of how these properties work together
    to determine what you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `fov` property of the camera determines the horizontal FOV. Based on the
    `aspect` property, the vertical FOV is determined. The `near` property is used
    to determine the position of the near plane, and the `far` property determines
    the position of the far plane. The area between the near plane and the far plane
    will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the orthographic camera, we need to use other properties. The
    orthographic projection isn''t interested either in the aspect ratio to use or
    with what FOV we look at the scene since all the objects are rendered at the same
    size. What you do when you define an orthographic camera is define the cuboid
    area that needs to be rendered. The properties for the orthographic camera reflect
    this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `left` | This is described in the Three.js documentation as *Camera frustum
    left plane*. You should see this as what is the left-hand border of what will
    be rendered. If you set this value to `-100`, you won''t see any objects that
    are farther to the left-hand side. |'
  prefs: []
  type: TYPE_TB
- en: '| `right` | The `right` property works in a way similar to the `left` property,
    but this time, to the other side of the screen. Anything farther to the right
    won''t be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `top` | This is the top position to be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `bottom` | This is the bottom position to be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `near` | From this point, based on the position of the camera, the scene
    will be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `far` | To this point, based on the position of the camera, the scene will
    be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `zoom` | This allows you to zoom in and out of the scene. When you use a
    number lower than `1`, you''ll zoom out of the scene; if you use a number higher
    than `1`, you''ll zoom in. Note that if you specify a negative value, the scene
    will be rendered upside down. The default value is `1`. |'
  prefs: []
  type: TYPE_TB
- en: 'All these properties can be summarized in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Orthographic camera versus perspective camera](graphics/2215OS_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looking at specific points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, you''ve seen how to create a camera and what the various arguments
    mean. In the previous chapter, you also saw that you need to position your camera
    somewhere in the scene, and that the view from that camera is rendered. Normally,
    the camera is pointed to the center of the scene: position (0,0,0). We can, however,
    easily change what the camera is looking at, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve added an example where the camera moves, and the point it is looking
    at is marked with a red dot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking at specific points](graphics/2215OS_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you open the `08-cameras-lookat` example, you'll see the scene moving from
    left to right. The scene isn't really moving. The camera is looking at different
    points (see the red dot in the center), which gives the effect that the scene
    is moving from left to right. In this example, you can also switch cameras to
    the orthographic one. There, you see that changing the point the camera looks
    at has pretty much the same effect as with `THREE.PerspectiveCamera`. The interesting
    part to notice, though, is that with `THREE.OrthographicCamera`, you can clearly
    see that the sizes of all the cubes stay the same regardless of where the camera
    is looking.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking at specific points](graphics/2215OS_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use the `lookAt` function, you point the camera at a specific position.
    You can also use this to make the camera follow an object around the scene. Since
    every `THREE.Mesh` object has a position that is a `THREE.Vector3` object, you
    can use the `lookAt` function to point to a specific mesh in the scene. All you
    need to do is this: `camera.lookAt(mesh.position)`. If you call this in the render
    loop, you''ll make the camera follow an object as it moves through the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed a lot of items in this second introduction chapter. We showed all
    the functions and properties of `THREE.Scene` and explained how you can use these
    properties to configure your main scene. We also showed you how you can create
    geometries. You can either create them from scratch using a `THREE.Geometry` object
    or use any of the built-in geometries Three.js provides. Finally, we showed you
    how you can configure the two cameras Three.js provides. `THREE.PerspectiveCamera`
    renders a scene using a real-world perspective, and `THREE.OrthographicCamera`
    provides a fake 3D effect also often seen in games. We've also introduced how
    geometries work in Three.js. You can now easily create your own geometries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the various light sources that are available
    in Three.js. You'll learn how the various light sources behave, how to create
    and configure them, and how they affect specific materials.
  prefs: []
  type: TYPE_NORMAL

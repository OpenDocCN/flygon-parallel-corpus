- en: Chapter 4. Working with Three.js Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we talked a bit about materials. You learned that
    a material, together with `THREE.Geometry`, forms `THREE.Mesh`. The material is
    like the skin of the object that defines what the outside of a geometry looks
    like. For example, a skin defines whether a geometry is metallic-looking, transparent,
    or shown as a wireframe. The resulting `THREE.Mesh` object can then be added to
    the scene to be rendered by Three.js. Until now, we haven''t really looked at
    materials in much detail. In this chapter, we''ll dive into all the materials
    Three.js has to offer, and you''ll learn how you can use these materials to create
    good-looking 3D objects. The materials we''ll explore in this chapter are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshBasicMaterial` | This is a basic material that you can use to give your
    geometries a simple color or show the wireframe of your geometries. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshDepthMaterial` | This is a material that uses the distance from the
    camera to determine how to color your mesh. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshNormalMaterial` | This is a simple material that bases the color of
    a face on its normal vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshFacematerial` | This is a container that allows you to specify a unique
    material for each face of the geometry. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshLambertMaterial` | This is a material that takes lighting into account
    and is used to create *dull* non-shiny-looking objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshPhongMaterial` | This is a material that also takes lighting into account
    and can be used to create shiny objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `ShaderMaterial` | This material allows you to specify your own shader programs
    to directly control how vertices are positioned and pixels are colored. |'
  prefs: []
  type: TYPE_TB
- en: '| `LineBasicMaterial` | This is a material that can be used on the `THREE.Line`
    geometry to create colored lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `LineDashMaterial` | This is the same as `LineBasicMaterial`, but this material
    also allows you to create a dashed effect. |'
  prefs: []
  type: TYPE_TB
- en: If you look through the source code of Three.js, you might run into `THREE.RawShaderMaterial`.
    This is a specialized material that can only be used together with `THREE.BufferedGeometry`.
    This geometry is a specialized form that is optimized for static geometries (for
    instance, vertices and faces don't change). We won't explore this material in
    this chapter, but we will use it in [Chapter 11](ch11.html "Chapter 11. Custom
    Shaders and Render Postprocessing"), *Custom Shaders and Render Postprocessing*,
    when we talk about creating custom shaders. In the code, you can also find `THREE.SpriteCanvasMaterial`,
    `THREE.SpriteMaterial`, and `THREE.PointCloudMaterial`. These are materials you
    use when styling individual points. We won't discuss those in this chapter, but
    we'll explore them in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and
    the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: Materials have a number of common properties, so before we look at the first
    material, `MeshBasicMaterial`, we'll look at the properties shared by all the
    materials.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding common material properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can quickly see for yourself which properties are shared between all the
    materials. Three.js provides a material base class, `THREE.Material`, that lists
    all the common properties. We''ve divided these common material properties into
    the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic properties**: These are the properties you''ll use most often. With
    these properties, you can, for instance, control the opacity of the object, whether
    it is visible, and how it is referenced (by ID or custom name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blending properties**: Every object has a set of blending properties. These
    properties define how the object is combined with its background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced properties**: There are a number of advanced properties that control
    how the low-level WebGL context renders objects. In most cases, you won''t need
    to mess with these properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in this chapter, we skip any properties related to textures and maps.
    Most materials allow you to use images as textures (for instance, a wood-like
    or stone-like texture). In [Chapter 10](ch10.html "Chapter 10. Loading and Working
    with Textures"), *Loading and Working with Textures*, we will dive into the various
    texture and mapping options that are available. Some materials also have specific
    properties related to animation (skinning and `morphTargets`); we'll also skip
    those properties. These will be addressed in [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the first one from the list: the basic properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic properties of the `THREE.Material` object are listed in the following
    table (you can see these properties in action in the section on `THREE.BasicMeshMaterial`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | This is used to identify a material and is assigned when you create
    a material. This starts at `0` for the first material and is increased by `1`
    for each additional material that is created. |'
  prefs: []
  type: TYPE_TB
- en: '| `uuid` | This is a uniquely generated ID and is used internally. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | You can assign a name to a material with this property. This can
    be used for debugging purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `opacity` | This defines how transparent an object is. Use this together
    with the `transparent` property. The range of this property is from `0` to `1`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `transparent` | If this is set to `true`, Three.js will render this object
    with the set opacity. If this is set to `false`, the object won''t be transparent—just
    more lightly colored. This property should also be set to `true` if you use a
    texture that uses an alpha (transparency) channel. |'
  prefs: []
  type: TYPE_TB
- en: '| `overdraw` | When you use `THREE.CanvasRenderer`, the polygons will be rendered
    a bit bigger. Set this to `true` when you see gaps when using this renderer. |'
  prefs: []
  type: TYPE_TB
- en: '| `visible` | This defines whether this material is visible. If you set this
    to `false`, you won''t see the object in the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `Side` | With this property, you can define to which side of the geometry
    a material is applied. The default is `THREE.Frontside`, which applies the material
    to the front (outside) of an object. You can also set this to `THREE.BackSide`,
    which applies is to the back (inside), or `THREE.DoubleSide`, which applies it
    to both sides. |'
  prefs: []
  type: TYPE_TB
- en: '| `needsUpdate` | For some updates to the material, you need to tell Three.js
    that the material has been changed. If this property is set to `true`, Three.js
    will update its cache with the new material properties. |'
  prefs: []
  type: TYPE_TB
- en: For each material, you can also set a number of blending properties.
  prefs: []
  type: TYPE_NORMAL
- en: Blending properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Materials have a couple of generic blending-related properties. Blending determines
    how the colors we render interact with the colors that are behind them. We''ll
    touch upon this subject a little bit when we talk about combining materials. The
    blending properties are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `blending` | This determines how the material on this object blends with
    the background. The normal mode is `THREE.NormalBlending`, which only shows the
    top layer. |'
  prefs: []
  type: TYPE_TB
- en: '| `blendsrc` | Besides using the standard blending modes, you can also create
    custom blend modes by setting `blendsrc`, `blenddst`, and `blendequation`. This
    property defines how this object (the source) is blended into the background (the
    destination). The default `THREE.SrcAlphaFactor` setting uses the alpha (transparency)
    channel for blending. |'
  prefs: []
  type: TYPE_TB
- en: '| `blenddst` | This property defines how the background (the destination) is
    used in blending and defaults to `THREE.OneMinusSrcAlphaFactor`, which means this
    property too uses the alpha channel of the source for blending but uses `1` (alpha
    channel of the source) as the value. |'
  prefs: []
  type: TYPE_TB
- en: '| `blendequation` | This defines how the `blendsrc` and `blenddst` values are
    used. The default is to add them (`AddEquation`). With these three properties,
    you can create your own custom blend modes. |'
  prefs: []
  type: TYPE_TB
- en: The last set of properties is mostly used internally and controls the specifics
    of how WebGL is used to render the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We won''t go into the details of these properties. These are related to how
    WebGL works internally. If you do want to know more about these properties, the
    OpenGL specification is a good starting point. You can find this specification
    at [http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf](http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf).
    The following table provides a brief description of these advanced properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `depthTest` | This is an advanced WebGL property. With this property, you
    can enable or disable the `GL_DEPTH_TEST` parameter. This parameter controls whether
    the *depth* of a pixel is used to determine a new pixel''s value. Normally, you
    wouldn''t need to change this. More information can be found in the OpenGL specifications
    we mentioned earlier. |'
  prefs: []
  type: TYPE_TB
- en: '| `depthWrite` | This is another internal property. This property can be used
    to determine whether this material affects the WebGL depth buffer. If you use
    an object for a 2D overlay (for example, a hub), you should set this property
    to `false`. Usually, though, you shouldn''t need to change this property. |'
  prefs: []
  type: TYPE_TB
- en: '| `polygonOffset`, `polygonOffsetFactor`, and `polygonOffsetUnits` | With these
    properties, you can control the `POLYGON_OFFSET_FILL` WebGL feature. These are
    normally not needed. For an explanation of what they do in detail, you can look
    at the OpenGL specifications. |'
  prefs: []
  type: TYPE_TB
- en: '| `alphatest` | This value can be set to a specific value (`0` to `1`). Whenever
    a pixel has an alpha value smaller than this value, it won''t be drawn. You can
    use this property to remove some transparency-related artifacts. |'
  prefs: []
  type: TYPE_TB
- en: Now, let's look at all the available materials so that you can see the effect
    these properties have on the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a simple mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at a few simple materials: `MeshBasicMaterial`,
    `MeshDepthMaterial`, `MeshNormalMaterial`, and `MeshFaceMaterial`. We start with
    `MeshBasicMaterial`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look into the properties of these materials, here''s a quick note
    on how you can pass in properties to configure the materials. There are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass in the arguments in the constructor as a parameters object, like
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also create an instance and set the properties individually,
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Usually, the best way is to use the constructor if we know all the properties'
    values while creating the material. The arguments used in both these styles use
    the same format. The only exception to this rule is the `color` property. In the
    first style, we can just pass in the hex value, and Three.js will create a `THREE.Color`
    object itself. In the second style, we have to explicitly create a `THREE.Color`
    object. In this book, we'll use both of these styles.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshBasicMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MeshBasicMaterial` is a very simple material that doesn''t take into account
    the lights that are available in the scene. Meshes with this material will be
    rendered as simple, flat polygons, and you also have the option to show the geometry''s
    wireframe. Besides the common properties we saw in the earlier section on this
    material, we can set the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This property allows you to set the color of the material. |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframe` | This allows you to render the material as a wireframe. This
    is great for debugging purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wireframelinecap` | This property defines how the ends of lines look in
    wireframe mode. The possible values are `butt`, `round`, and `square`. The default
    value is `round`. In practice, the results from changing this property are very
    difficult to see. This property isn''t supported on `WebGLRenderer`. |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframeLinejoin` | This defines how the line joints are visualized. The
    possible values are `round`, `bevel`, and `miter`. The default value is `round`.
    If you look very closely, you can see this in the example using low `opacity`
    and a very large `wireframeLinewidth` value. This property isn''t supported on
    `WebGLRenderer`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading`, `THREE.NoShading`, and `THREE.FlatShading`. The default
    value is `THREE.SmoothShading`, which results in a smooth object where you won''t
    see the individual faces. This property isn''t enabled in the example for this
    material. For an example, look at the section on `MeshNormalMaterial`. |'
  prefs: []
  type: TYPE_TB
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. The default value is `THREE.NoColors`. If you set this value
    to `THREE.VertexColors`, the renderer will take the colors set on the colors property
    of `THREE.Geometry` into account.This property doesn''t work on `CanvasRenderer`
    but does work on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where
    we use this property to color the various parts of a line. You can also use this
    property to create a gradient effect for this material type. |'
  prefs: []
  type: TYPE_TB
- en: '| `fog` | This property determines whether this material is affected by global
    fog settings. This is not shown in action, but if this is set to `false`, the
    global fog we saw in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make
    Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t
    affect how this object is rendered. |'
  prefs: []
  type: TYPE_TB
- en: 'In the previous chapters, we saw how to create materials and assign them to
    objects. For `THREE.MeshBasicMaterial`, we do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new `THREE.MeshBasicMaterial` and initializes the `color` property
    to `0x7777ff` (which is purple).
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve added an example that you can use to play around with the `THREE.MeshBasicMaterial`
    properties and the basic properties we discussed in the previous section. If you
    open up the `01-basic-mesh-material.html` example in the `chapter-04` folder,
    you''ll see a rotating cube like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshBasicMaterial](graphics/2215OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a very simple object. With the menu in the upper-right corner, you
    can play around with the properties and select different meshes (you can also
    change the renderer). For instance, a sphere with `opacity` of `0.2`, `transparent`
    set to `true`, `wireframe` set to `true`, `wireframeLinewidth` of `9`, and using
    `CanvasRenderer` is rendered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshBasicMaterial](graphics/2215OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the properties you can set in this example is the `side` property. With
    this property, you define to which side of `THREE.Geometry` the material is applied.
    You can test how this property works when you select the plane mesh. Since normally
    a material is only applied to the front side of a material, the rotating plane
    will be invisible half the time (when it shows it's back to you). If you set the
    `side` property to `double`, the plane will be visible the whole time, since the
    material is applied to both sides of the geometry. Note, though, that the renderer
    will need to do more work when the `side` property is set to `double`, so this
    could have an impact on the performance of your scene.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshDepthMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next material on the list is `THREE.MeshDepthMaterial`. With this material,
    the way an object looks isn''t defined by lights or by a specific material property;
    it is defined by the distance from the object to the camera. You can combine this
    with other materials to easily create fading effects. The only relevant properties
    this material has are the following two that control whether you want to show
    a wireframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: 'To demonstrate this, we modified the cubes example from [Chapter 2](ch02.html
    "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic Components
    That Make Up a Three.js Scene* (`02-depth-material` from the `chapter-04` folder).
    Remember that you have to click on the **addCube** button to populate the scene.
    The following screenshot shows the modified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshDepthMaterial](graphics/2215OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though the material doesn't have many additional properties to control
    how an object is rendered, we can still control how fast the object's color fades
    out. In this example, we exposed the `near` and `far` properties of the camera.
    As you probably remember from [Chapter 2](ch02.html "Chapter 2. Basic Components
    That Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*,
    with these two properties, we set the visible area for the camera. Any objects
    that are nearer to the camera than the `near` property aren't shown, and any objects
    further away than the `far` property also fall outside the camera's visible area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance between the `near` and `far` properties of the camera defines
    the brightness and the rate at which objects fade out. If the distance is very
    large, objects will only fade out a little as they move away from the camera.
    If the distance is small, the fadeout will be much more notable (as you can see
    in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshDepthMaterial](graphics/2215OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating `THREE.MeshDepthMaterial` is very easy and the object doesn''t require
    any arguments. For this example, we''ve used the `scene.overrideMaterial` property
    to make sure all the objects in the scene use this material without having to
    explicitly specify it for each `THREE.Mesh` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next part in this chapter isn't really about a specific material, but shows
    a way in which you can combine multiple materials together.
  prefs: []
  type: TYPE_NORMAL
- en: Combining materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look back at the properties of `THREE.MeshDepthMaterial`, you can see
    that there isn''t an option to set the color of the cubes. Everything was decided
    for you by the default properties of the material. Three.js, however, has the
    option to combine materials together to create new effects (this is also where
    blending comes into play). The following code shows how we can combine materials
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following green-colored cubes that use the brightness from `THREE.MeshDepthMaterial`
    and the color from `THREE.MeshBasicMaterial` (open `03-combined-material.html`
    for this example). The following screenshot shows the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining materials](graphics/2215OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at the steps you need to take to get this specific result.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create our two materials. For `THREE.MeshDepthMaterial`, we
    don't do anything special; for `THREE.MeshBasicMaterial`, however, we set `transparent`
    to `true` and define a `blending` mode. If we don't set the `transparent` property
    to `true`, we'll just have solid, green objects since Three.js won't know to take
    the already-rendered colors into account. With `transparent` set to `true`, Three.js
    will check the `blending` property to see how the green `THREE.MeshBasicMaterial`
    object should interact with the background. The background in this case is the
    cube rendered with `THREE.MeshDepthMaterial`. In [Chapter 9](ch09.html "Chapter 9. Animations
    and Moving the Camera"), *Animations and Moving the Camera*, we'll discuss in
    greater detail the various blend modes that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, though, we used `THREE.MultiplyBlending`. This blend mode
    multiplies the foreground color with the background color and gives you the desired
    effect. The last line in this code fragment is also an important one. What happens
    when we create a mesh with the `THREE.SceneUtils.createMultiMaterialObject()`
    function is that the geometry gets copied and two exactly the same meshes are
    returned in a group. If we render these without the last line, you should see
    a flickering effect. This can happen sometimes when objects are rendered one on
    top of the other and one of them is transparent. By scaling down the mesh created
    with `THREE.MeshDepthMaterial`, we can avoid this. To do so, use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next material is also one where we won't have any influence on the colors
    used in rendering.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshNormalMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to understand how this material is rendered is by first looking
    at an example. Open up the `04-mesh-normal-material.html` example from the `chapter-04`
    folder. If you select the sphere as the mesh, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, each face of the mesh is rendered in a slightly different color,
    and even though the sphere rotates, the colors stay pretty much at the same place.
    This happens because the color of each face is based on the *normal* pointing
    out from the face. This normal is the vector perpendicular to the face. The normal
    vector is used in many different parts of Three.js. It is used to determine light
    reflections, helps in mapping textures to 3D models, and gives information on
    how to light, shade, and color pixels on a surface. Luckily, though, Three.js
    handles the computation of these vectors and uses them internally, so you don''t
    have to calculate them yourselves. The following screenshot shows all the normal
    vectors of `THREE.SphereGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The direction this normal points in determines the color a face gets when you
    use `THREE.MeshNormalMaterial`. Since all normals for the faces of a sphere point
    in a different direction, we get the colorful sphere you can see in the examples.
    As a quick side note, to add these normal arrows, you can use `THREE.ArrowHelper`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we iterate through all the faces of `THREE.SphereGeometry`.
    For each of these `THREE.Face3` objects, we calculate the center (the centroid)
    by adding the vertices that make up this face and dividing the result by 3\. We
    use this centroid, together with the normal vector of the face, to draw an arrow.
    The `THREE.ArrowHelper` takes the following arguments: `direction`, `origin`,
    `length`, `color`, `headLength`, and `headWidth`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of other properties that you can set on `THREE.MeshNormalMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframe` | This determines whether or not to show the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframeLineWidth` | This determines the width of the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: '| `shading` | This configures shading in the form of flat shading with `THREE.FlatShading`
    and smooth shading with `THREE.SmoothShading`. |'
  prefs: []
  type: TYPE_TB
- en: 'We''ve already seen `wireframe` and `wireframeLinewidth` but skipped the `shading`
    property in our `THREE.MeshBasicMaterial` example. With the `shading` property,
    we can tell Three.js how to render our objects. If you use `THREE.FlatShading`,
    each face will be rendered as is (as you can see in the previous couple of screenshots),
    or you can use `THREE.SmoothShading`, which smoothens out the faces of our object.
    For instance, if we render the sphere using `THREE.SmoothShading`, the result
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshNormalMaterial](graphics/2215OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're almost done with the simple materials. The last one is `THREE.MeshFaceMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshFaceMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last of the basic materials isn''t really a material but much more a container
    of other materials. `THREE.MeshFaceMaterial` allows you to assign a different
    material to each face of your geometry. For instance, if you have a cube, which
    has 12 faces (remember, Three.js only works with triangles), you can use this
    material to assign a different material (for example, with a different color)
    to each side of the cube. Using this material is really simple, as you can see
    from the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create an array, named `matArray`, to hold all the materials. Next,
    we create a new material, `THREE.MeshBasicMaterial` in this example, with a different
    color for each face. With this array, we instantiate `THREE.MeshFaceMaterial`
    and use it together with the cube geometry to create the mesh. Let''s dive a bit
    deeper into the code and see what you need to do to recreate the following example:
    a simple 3D Rubik''s cube. You can find this example in `05-mesh-face-material.html`.
    The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshFaceMaterial](graphics/2215OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This Rubik''s cube consists of a number of smaller cubes: three cubes along
    the *x* axis, three along the *y* axis, and three along the *z* axis. Here''s
    how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we first create `THREE.Mesh`, which will hold all the
    individual cubes (`group`); next, we create the materials for each face and push
    them to the `mats` array. Remember, each side of the cube consists of two faces,
    so we need 12 materials. From these materials, we create `THREE.MeshFaceMaterial`.
    Then, we create three loops to make sure we create the right number of cubes.
    In this loop, we create each of the individual cubes, assign the material, position
    them, and add them to the group. What you should remember is that the position
    of the cubes is relative to the position of this group. If we move or rotate the
    group, all the cubes will move and rotate with it. For more information on how
    to work with groups, look at [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve opened the example in your browser, you can see that the complete
    Rubik''s cube rotates, and not the individual cubes. This happens because we use
    the following in our rendering loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This causes the complete group to rotate around its center (0,0,0). When we
    positioned the individual cubes, we made sure they were positioned around this
    center point. That's why you see the -3 offset in the `cube.position.set(x * 3
    - 3, y * 3, z * 3 - 3);` line of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look at this code, you might wonder how Three.js determines which material
    to use for a specific face. For this, Three.js uses the `materialIndex` property,
    which you can set on each individual face of the `geometry.faces` array. The property
    points to the array index of the materials we add in the constructor of the `THREE.FaceMaterial`
    object. When you create a geometry using one of the standard Three.js geometries,
    Three.js provides sensible defaults. If you want other behavior, you can just
    set the `materialIndex` property yourself for each face to point at one of the
    provided materials.
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.MeshFaceMaterial` was the last of our basic materials. In the next section,
    we''ll look at some of the more advanced materials available in Three.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at the more advanced materials Three.js has to
    offer. We''ll first look at `THREE.MeshPhongMaterial` and `THREE.MeshLambertMaterial`.
    These two materials react to light sources and can be used to create shiny and
    dull-looking materials, respectively. In this section, we''ll also look at one
    of the most versatile, but most difficult to use, materials: `THREE.ShaderMaterial`.
    With `THREE.ShaderMaterial`, you can create your own shader programs that define
    how the material and object should be shown.'
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshLambertMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This material can be used to create dull-looking, non-shiny surfaces. This
    is a very easy-to-use material that responds to the lighting sources in the scene.
    This material can be configured with a number of properties we''ve seen before:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframeLineJoin`, `vertexColors`,
    and `fog`. We won''t go into the details of those properties, but will focus on
    the ones specific to this material. That just leaves us with the following four
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  prefs: []
  type: TYPE_TB
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapRGB` | When `wrapAround` is set to true, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  prefs: []
  type: TYPE_TB
- en: 'This material is created just like all the other ones. Here''s how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For an example of this material, look at `06-mesh-lambert-material.html`. The
    following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshLambertMaterial](graphics/2215OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the material looks rather dull.
    There is another material we can use to create shiny surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.MeshPhongMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `THREE.MeshPhongMaterial`, we can create a material that is shiny. The
    properties you can use for that are pretty much the same as for a non-shiny `THREE.MeshLambertMaterial`
    object. We''ll once again skip the basic properties and those already discussed:
    `color`, `opacity`, `shading`, `blending`, `depthTest`, `depthWrite`, `wireframe`,
    `wireframeLinewidth`, `wireframeLinecap`, `wireframelineJoin`, and `vertexColors`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting properties for this material are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ambient` | This is the *ambient* color of the material. This works together
    with the ambient light we saw in the previous chapter. This color is multiplied
    with the color provided by the ambient light. This defaults to white. |'
  prefs: []
  type: TYPE_TB
- en: '| `emissive` | This is the color this material emits. It doesn''t really act
    as a light source, but this is a solid color that is unaffected by other lighting.
    This defaults to black. |'
  prefs: []
  type: TYPE_TB
- en: '| `specular` | This property defines how shiny the materials are and with what
    color it shines. If this is set to the same color as the `color` property, you
    get a more metallic-looking material. If this is set to grey, it results in a
    more plastic-looking material. |'
  prefs: []
  type: TYPE_TB
- en: '| `shininess` | This property defines how shiny the specular highlight is.
    The default value for the shininess is `30`. |'
  prefs: []
  type: TYPE_TB
- en: '| `metal` | When this property is set to `true`, Three.js uses a slightly different
    way of calculating the color of a pixel to make the object look more like a metal.
    Note that the effect is very minimal. |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapAround` | If this property is set to `true`, you enable the half-lambert
    lighting technique. With half-lambert lighting, the drop-off of light is more
    subtle. If you have a mesh with harsh, dark areas, enabling this property will
    soften the shadows and more evenly distribute the light. |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapRGB` | When `wrapAround` is set to `true`, you can use `THREE.Vector3`
    to control how fast the light is dropped off. |'
  prefs: []
  type: TYPE_TB
- en: 'Initializing a `THREE.MeshPhongMaterial` object is done in the same way as
    we''ve already seen for all the other materials and is shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To give you the best comparison, we''ve created the same example for this material
    as we did for `THREE.MeshLambertMaterial`. You can use the control GUI to play
    around with this material. For instance, the following settings create a plastic-looking
    material. You can find this example in `07-mesh-phong-material.html`. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.MeshPhongMaterial](graphics/2215OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last one of the advanced materials we'll explore is `THREE.ShaderMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own shaders with THREE.ShaderMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`THREE.ShaderMaterial` is one of the most versatile and complex materials available
    in Three.js. With this material, you can pass in your own custom shaders that
    are directly run in the WebGL context. A shader converts Three.js JavaScript meshes
    to pixels on screen. With these custom shaders, you can define exactly how your
    object should be rendered and how to override or alter the defaults from Three.js.
    In this section, we won''t go into the details yet of how to write custom shaders.
    For more information on that, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Postprocessing*. For now,
    we''ll just look at a very basic example that shows how you can configure this
    material.'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.ShaderMaterial` has a number of properties you can set that we''ve already
    seen. With `THREE.ShaderMaterial`, Three.js passes in all the information regarding
    these properties, but you still have to process the information in your own shader
    programs. The following are the properties of `THREE.ShaderMaterial` that we have
    already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wireframe` | This renders the material as a wireframe. This is great for
    debugging purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wireframelinewidth` | If you enable the wireframe, this property defines
    the width of the wires from the wireframe. |'
  prefs: []
  type: TYPE_TB
- en: '| `linewidth` | This defines the width of the line to be drawn. |'
  prefs: []
  type: TYPE_TB
- en: '| `Shading` | This defines how shading is applied. The possible values are
    `THREE.SmoothShading` and `THREE.FlatShading`. This property isn''t enabled in
    the example for this material. For example, look at the section on `MeshNormalMaterial`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vertexColors` | You can define individual colors to be applied to each vertex
    with this property. This property doesn''t work on `CanvasRenderer` but does work
    on `WebGLRenderer`. Look at the `LineBasicMaterial` example, where we use this
    property to color the various parts of a line. |'
  prefs: []
  type: TYPE_TB
- en: '| `fog` | This determines whether this material is affected by global fog settings.
    This is not shown in action. If this is set to `false`, the global fog we saw
    in [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js
    Scene"), *Basic Components That Make Up a Three.js Scene*, doesn''t affect how
    this object is rendered. |'
  prefs: []
  type: TYPE_TB
- en: 'Besides these properties that are passed into the shader, `THREE.ShaderMaterial`
    also provides a number of specific properties you can use to pass in additional
    information into your custom shader (they might seem a bit obscure at the moment;
    for more details, see [Chapter 11](ch11.html "Chapter 11. Custom Shaders and Render
    Postprocessing"), *Custom Shaders and Render Postprocessing*), which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fragmentShader` | This shader defines the color of each pixel that is passed
    in. Here, you need to pass in the string value of your fragment shader program.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `vertexShader` | This shader allows you to change the position of each vertex
    that is passed in. Here, you need to pass in the string value of your vertex shader
    program. |'
  prefs: []
  type: TYPE_TB
- en: '| `uniforms` | This allows you to send information to your shader. The same
    information is sent to each vertex and fragment. |'
  prefs: []
  type: TYPE_TB
- en: '| `defines` | Converts to #define code fragments. With these fragments, you
    can set some additional global variables in the shader programs. |'
  prefs: []
  type: TYPE_TB
- en: '| `attributes` | These can change between each vertex and fragment. They are
    usually used to pass positional and normal-related data. If you want to use this,
    you need to provide information for all the vertices of the geometry. |'
  prefs: []
  type: TYPE_TB
- en: '| `lights` | This determines whether light data should be passed into the shaders.
    This defaults to `false`. |'
  prefs: []
  type: TYPE_TB
- en: 'Before we look at an example, we''ll give a quick explanation about the most
    important parts of `ShaderMaterial`. To work with this material, we have to pass
    in two different shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vertexShader`: This is run on each vertex of the geometry. You can use this
    shader to transform the geometry by moving the position of the vertices around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fragmentShader`: This is run on each fragment of the geometry. In `vertexShader`,
    we return the color that should be shown for this specific fragment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all the materials we've discussed until now in this chapter, Three.js provides
    `fragmentShader` and `vertexShader`, so you don't have to worry about those.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we'll look at a simple example that uses a very simple `vertexShader`
    program that changes the *x*, *y*, and *z* coordinates of the vertices of a cube
    and a `fragmentShader` program that uses shaders from [http://glslsandbox.com/](http://glslsandbox.com/)
    to create an animating material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up next, you can see the complete code for `vertexShader` that we''ll use.
    Note that writing shaders isn''t done in JavaScript. You write shaders in a C-like
    language called **GLSL** (WebGL supports OpenGL ES Shading Language 1.0—for more
    information on GLSL, see [https://www.khronos.org/webgl/](https://www.khronos.org/webgl/)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t go into too much detail here and just focus on the most important
    parts of this code. To communicate with the shaders from JavaScript, we use something
    called uniforms. In this example, we use the `uniform float time;` statement to
    pass in an external value. Based on this value, we change the *x*, *y*, and *z*
    coordinates of the passed-in vertex (which is passed in as the position variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `posChanged` vector now contains the new coordinate for this vertex based
    on the passed-in time variable. The last step we need to perform is pass this
    new position back to Three.js, which is always done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gl_Position` variable is a special variable that is used to return the
    final position. Next, we need to create `shaderMaterial` and pass in `vertexShader`.
    For this, we''ve created a simple helper function, which we use like this: `var
    meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");` in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments point to the ID of the `script` element in the HTML page. Here,
    you can also see that we set up a uniforms variable. This variable is used to
    pass information from our renderer into our shader. Our complete render loop for
    this example is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we increase the time variable by 0.01 each time the render
    loop is run. This information is passed into `vertexShader` and used to calculate
    the new position of the vertices of our cube. Now open up the `08-shader-material.html`
    example, and you''ll see that the cube shrinks and grows around its axis. The
    following screenshot gives a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own shaders with THREE.ShaderMaterial](graphics/2215OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can see that each of the cube''s faces has an animating
    pattern. The fragment shader that is assigned to each face of the cube creates
    these patterns. As you might have guessed, we''ve used `THREE.MeshFaceMaterial`
    (and the `createMaterial` function we explained earlier) for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The only part we haven''t explained yet is about `fragmentShader`. For this
    example, all the `fragmentShader` objects were copied from [http://glslsandbox.com/](http://glslsandbox.com/).
    This site provides an experimental playground where you can write and share `fragmentShader`
    objects. I won''t go into the details here, but `fragment-shader-6` used in this
    example looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The color that finally gets passed back to Three.js is the one set with `gl_FragColor
    = color_final`. A good way to get a bit more of a feeling for `fragmentShader`
    is to explore what''s available at [http://glslsandbox.com/](http://glslsandbox.com/)
    and to use the code for your own objects. Before we move to the next set of materials,
    here is one more example of what is possible with a custom `vertexShader` program
    ([https://www.shadertoy.com/view/4dXGR4](https://www.shadertoy.com/view/4dXGR4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own shaders with THREE.ShaderMaterial](graphics/2215OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Much more on the subject of fragment and vertex shaders can be found in [Chapter
    11](ch11.html "Chapter 11. Custom Shaders and Render Postprocessing"), *Custom
    Shaders and Render Postprocessing*.
  prefs: []
  type: TYPE_NORMAL
- en: Materials you can use for a line geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last couple of materials we''re going to look at can only be used on one
    specific geometry: `THREE.Line`. As the name implies, this is just a single line
    that only consists of vertices and doesn''t contain any faces. Three.js provides
    two different materials you can use on a line, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.LineBasicMaterial`: The basic material for a line allows you to set
    the `colors`, `linewidth`, `linecap`, and `linejoin` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.LineDashedMaterial`: This has the same properties as `THREE.LineBasicMaterial`
    but allows you to create a *dash* effect by specifying dash and spacing sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with the basic variant and after that look at the dashed variant.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.LineBasicMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The materials available for the `THREE.Line` geometry are very simple. The
    following table shows the properties available to this material:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `color` | This determines the color of the line. If you specify `vertexColors`,
    this property is ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `linewidth` | This determines the width of the line. |'
  prefs: []
  type: TYPE_TB
- en: '| `linecap` | This property defines how the ends of lines look in the wireframe
    mode. The possible values are `butt`, `round`, and `square`. The default is `round`.
    In practice, the results from changing this property are very difficult to see.
    This property isn''t supported on `WebGLRenderer`. |'
  prefs: []
  type: TYPE_TB
- en: '| `linejoin` | Define how the line joints are visualized. The possible values
    are `round`, `bevel`, and `miter`. The default value is `round`. If you look very
    closely, you can see this in the example using low `opacity` and a very large
    `wireframeLinewidth`. This property isn''t supported on `WebGLRenderer`. |'
  prefs: []
  type: TYPE_TB
- en: '| `vertexColors` | You can supply a specific color for each vertex by setting
    this property to the `THREE.VertexColors` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `fog` | This determines whether this object is affected by the global fog
    property. |'
  prefs: []
  type: TYPE_TB
- en: 'Before we look at an example of `LineBasicMaterial`, let''s first have a quick
    look at how we can create a `THREE.Line` mesh from a set of vertices and combine
    that with `LineMaterial` to create the mesh, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this code fragment, `var points = gosper(4, 60);`, is used
    as an example to get a set of *x* and *y* coordinates. This function returns a
    gosper curve (for more information, check out [http://en.wikipedia.org/wiki/Gosper_curve](http://en.wikipedia.org/wiki/Gosper_curve)),
    which is a simple algorithm that fills a 2D space. What we do next is we create
    a `THREE.Geometry` instance, and for each coordinate, we create a new vertex,
    which we push into the lines property of this instance. For each coordinate, we
    also calculate a color value that we use to set the `colors` property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we''ve set the color using the `setHSL()` method. Instead
    of providing values for red, green, and blue, with HSL, we provide the hue, saturation,
    and lightness. Using HSL is much more intuitive than RGB, and it is much easier
    to create sets of matching colors. A very good explanation of HSL can be found
    in the CSS specification: [http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color](http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our geometry, we can create `THREE.LineBasicMaterial` and
    use this together with the geometry to create a `THREE.Line` mesh. You can see
    the result in the `09-line-material.html` example. The following screenshot shows
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.LineBasicMaterial](graphics/2215OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next and last material we'll discuss in this chapter is only slightly different
    from `THREE.LineBasicMaterial`. With `THREE.LineDashedMaterial`, not only can
    we color lines, but we can also add a *dash* effect.
  prefs: []
  type: TYPE_NORMAL
- en: THREE.LineDashedMaterial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This material has the same properties as `THREE.LineBasicMaterial` and two
    additional ones you can use to define the dash width and the width of the gaps
    between the dashes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `scale` | This scales `dashSize` and `gapSize`. If the scale is smaller than
    `1`, `dashSize` and `gapSize` increase, and if the scale is larger than `1`, `dashSize`
    and `gapSize` decrease. |'
  prefs: []
  type: TYPE_TB
- en: '| `dashSize` | This is the size of the dash. |'
  prefs: []
  type: TYPE_TB
- en: '| `gapSize` | This is the size of the gap. |'
  prefs: []
  type: TYPE_TB
- en: 'This material works almost exactly like `THREE.LineBasicMaterial`. Here''s
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that you have to call `computeLineDistances()` (which
    is used to determine the distance between the vertices that make up a line). If
    you don''t do this, the gaps won''t be shown correctly. An example of this material
    can be found in `10-line-material-dashed.html` and looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![THREE.LineDashedMaterial](graphics/2215OS_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js gives you a lot of materials you can use to skin your geometries. The
    materials range from the very simple `(THREE.MeshBasicMaterial`) to the complex
    `(THREE.ShaderMaterial`), where you can provide your own `vertexShader` and `fragmentShader`
    programs. Materials share a lot of basic properties. If you know how to use a
    single material, you'll probably also know how to use the other materials. Note
    that not all materials respond to the lights in your scene. If you want a material
    that takes lighting into effect, use `THREE.MeshPhongMaterial` or `THREE.MeshLamberMaterial`.
    Determining the effect of certain material properties just from code is very hard.
    Often, a good idea is to use a dat.GUI approach to experiment with these properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, remember that most of the properties of a material can be modified at
    runtime. Some though (for example, `side`) can''t be modified at runtime. If you
    change such a value, you need to set the `needsUpdate` property to `true`. For
    a complete overview of what can and cannot be changed at runtime, see the following
    page: [https://github.com/mrdoob/three.js/wiki/Updates](https://github.com/mrdoob/three.js/wiki/Updates).'
  prefs: []
  type: TYPE_NORMAL
- en: In this and the previous chapters, we talked about geometries. We used these
    in our examples and explored a couple of them. In the next chapter, you'll learn
    everything about geometries and how you can work with them.
  prefs: []
  type: TYPE_NORMAL

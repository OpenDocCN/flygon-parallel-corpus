["```js\nrender();\n\nfunction render() {\n\n  // render the scene\n  renderer.render(scene, camera);\n  // schedule the next rendering using requestAnimationFrame\n  requestAnimationFrame(render);\n}\n```", "```js\nfunction render() {\n  cube.rotation.x += controls.rotationSpeed;\n  cube.rotation.y += controls.rotationSpeed;\n  cube.rotation.z += controls.rotationSpeed;\n\n  step += controls.bouncingSpeed;\n  sphere.position.x = 20 + ( 10 * (Math.cos(step)));\n  sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));\n\n  scalingStep += controls.scalingSpeed;\n  var scaleX = Math.abs(Math.sin(scalingStep / 4));\n  var scaleY = Math.abs(Math.cos(scalingStep / 5));\n  var scaleZ = Math.abs(Math.sin(scalingStep / 7));\n  cylinder.scale.set(scaleX, scaleY, scaleZ);\n\n  renderer.render(scene, camera);\n  requestAnimationFrame(render);\n}\n```", "```js\nvar projector = new THREE.Projector();\n\nfunction onDocumentMouseDown(event) {\n  var vector = new THREE.Vector3(event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);\n  vector = vector.unproject(camera);\n\n  var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());\n\n  var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);\n\n  if (intersects.length > 0) {\n    intersects[ 0 ].object.material.transparent = true;\n    intersects[ 0 ].object.material.opacity = 0.1;\n  }\n}\n```", "```js\ndistance: 49.9047088522448\nface: THREE.Face3\nfaceIndex: 4\nobject: THREE.Mesh\npoint: THREE.Vector3\n```", "```js\nvar tween = new TWEEN.Tween({x: 10}).to({x: 3}, 10000).easing(TWEEN.Easing.Elastic.InOut).onUpdate( function () {\n  // update the mesh\n})\n```", "```js\n// first create the tweens\nvar posSrc = {pos: 1}\nvar tween = new TWEEN.Tween(posSrc).to({pos: 0}, 5000);\ntween.easing(TWEEN.Easing.Sinusoidal.InOut);\n\nvar tweenBack = new TWEEN.Tween(posSrc).to({pos: 1}, 5000);\ntweenBack.easing(TWEEN.Easing.Sinusoidal.InOut);\n\ntween.chain(tweenBack);\ntweenBack.chain(tween);\n\nvar onUpdate = function () {\n  var count = 0;\n  var pos = this.pos;\n\n  loadedGeometry.vertices.forEach(function (e) {\n    var newY = ((e.y + 3.22544) * pos) - 3.22544;\n    particleCloud.geometry.vertices[count++].set(e.x, newY, e.z);\n  });\n\n  particleCloud.sortParticles = true;\n};\n\ntween.onUpdate(onUpdate);\ntweenBack.onUpdate(onUpdate);\n```", "```js\nvar loader = new THREE.PLYLoader();\nloader.load( \"../assets/models/test.ply\", function (geometry) {\n  ...\n  tween.start()\n  ...\n});\n```", "```js\nfunction render() {\n  TWEEN.update();\n  webGLRenderer.render(scene, camera);\n  requestAnimationFrame(render);\n}\n```", "```js\n<script type=\"text/javascript\" src=\"../libs/TrackballControls.js\"></script>\n```", "```js\nvar trackballControls = new THREE.TrackballControls(camera);\ntrackballControls.rotateSpeed = 1.0;\ntrackballControls.zoomSpeed = 1.0;\ntrackballControls.panSpeed = 1.0;\n```", "```js\nvar clock = new THREE.Clock();\nfunction render() {\n  var delta = clock.getDelta();\n  trackballControls.update(delta);\n  requestAnimationFrame(render);\n  webGLRenderer.render(scene, camera);\n}\n```", "```js\n<script type=\"text/javascript\" src=\"../libs/FlyControls.js\"></script>\n```", "```js\nvar flyControls = new THREE.FlyControls(camera);\nflyControls.movementSpeed = 25;\nflyControls.domElement = document.querySelector('#WebGL-output');\nflyControls.rollSpeed = Math.PI / 24;\nflyControls.autoForward = true;\nflyControls.dragToLook = false;\n```", "```js\n<div id=\"WebGL-output\"></div>\n```", "```js\nflyControls.domElement = document.querySelector('#WebGL-output');\n```", "```js\nvar rollControls = new THREE.RollControls(camera);\nrollControls.movementSpeed = 25;\nrollControls.lookSpeed = 3;\n```", "```js\nvar camControls = new THREE.FirstPersonControls(camera);\ncamControls.lookSpeed = 0.4;\ncamControls.movementSpeed = 20;\ncamControls.noFly = true;\ncamControls.lookVertical = true;\ncamControls.constrainVertical = true;\ncamControls.verticalMin = 1.0;\ncamControls.verticalMax = 2.0;\ncamControls.lon = -150;\ncamControls.lat = 120;\n```", "```js\n<script type=\"text/javascript\" src=\"../libs/OrbitControls.js\"></script>\n...\nvar orbitControls = new THREE.OrbitControls(camera);\norbitControls.autoRotate = true;\nvar clock = new THREE.Clock();\n...\nvar delta = clock.getDelta();\norbitControls.update(delta);\n```", "```js\nvar loader = new THREE.JSONLoader();\nloader.load('../assets/models/horse.js', function(geometry, mat) {\n\n  var mat = new THREE.MeshLambertMaterial({ morphTargets: true, vertexColors: THREE.FaceColors});\n\n  morphColorsToFaceColors(geometry);\n  geometry.computeMorphNormals();\n  meshAnim = new THREE.MorphAnimMesh(geometry, mat );\n  scene.add(meshAnim);\n\n},'../assets/models' );\n\nfunction morphColorsToFaceColors(geometry) {\n\n  if (geometry.morphColors && geometry.morphColors.length) {\n\n    var colorMap = geometry.morphColors[ 0 ];\n    for (var i = 0; i < colorMap.colors.length; i++) {\n      geometry.faces[ i ].color = colorMap.colors[ i ];\n      geometry.faces[ i ].color.offsetHSL(0, 0.3, 0);\n    }\n  }\n}\n```", "```js\nfunction render() {\n\n  var delta = clock.getDelta();\n  webGLRenderer.clear();\n  if (meshAnim) {\n    meshAnim.updateAnimation(delta *1000);\n    meshAnim.rotation.y += 0.01;\n  }\n\n  // render using requestAnimationFrame\n  requestAnimationFrame(render);\n  webGLRenderer.render(scene, camera);\n}\n```", "```js\n// create a cube\nvar cubeGeometry = new THREE.BoxGeometry(4, 4, 4);\nvar cubeMaterial = new THREE.MeshLambertMaterial({morphTargets: true, color: 0xff0000});\n\n// define morphtargets, we'll use the vertices from these geometries\nvar cubeTarget1 = new THREE.CubeGeometry(2, 10, 2);\nvar cubeTarget2 = new THREE.CubeGeometry(8, 2, 8);\n\n// define morphtargets and compute the morphnormal\ncubeGeometry.morphTargets[0] = {name: 'mt1', vertices: cubeTarget2.vertices};\ncubeGeometry.morphTargets[1] = {name: 'mt2', vertices: cubeTarget1.vertices};\ncubeGeometry.computeMorphNormals();\n\nvar cube = new THREE.Mesh(cubeGeometry, cubeMaterial);\n```", "```js\nvar controls = new function () {\n  // set to 0.01 to make sure dat.gui shows correct output\n  this.influence1 = 0.01;\n  this.influence2 = 0.01;\n\n  this.update = function () {\n    cube.morphTargetInfluences[0] = controls.influence1;\n    cube.morphTargetInfluences[1] = controls.influence2;\n  };\n}\n```", "```js\nvar loader = new THREE.JSONLoader();\nloader.load('../assets/models/hand-1.js', function (geometry, mat) {\n  var mat = new THREE.MeshLambertMaterial({color: 0xF0C8C9, skinning: true});\n  mesh = new THREE.SkinnedMesh(geometry, mat);\n\n  // rotate the complete hand\n  mesh.rotation.x = 0.5 * Math.PI;\n  mesh.rotation.z = 0.7 * Math.PI;\n\n  // add the mesh\n  scene.add(mesh);\n\n  // and start the animation\n  tween.start();\n\n}, '../assets/models');\n```", "```js\nvar tween = new TWEEN.Tween({pos: -1}).to({pos: 0}, 3000).easing(TWEEN.Easing.Cubic.InOut).yoyo(true).repeat(Infinity).onUpdate(onUpdate);\n```", "```js\nvar onUpdate = function () {\n  var pos = this.pos;\n\n  // rotate the fingers\n  mesh.skeleton.bones[5].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[6].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[10].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[11].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[15].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[16].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[20].rotation.set(0, 0, pos);\n  mesh.skeleton.bones[21].rotation.set(0, 0, pos);\n\n  // rotate the wrist\n  mesh.skeleton.bones[1].rotation.set(pos, 0, 0);\n};\n```", "```js\nhelper = new THREE.SkeletonHelper( mesh );\nhelper.material.linewidth = 2;\nhelper.visible = false;\nscene.add( helper );\n```", "```js\nvar loader = new THREE.JSONLoader();\nloader.load('../assets/models/hand-2.js', function (model, mat) {\n\n  var mat = new THREE.MeshLambertMaterial({color: 0xF0C8C9, skinning: true});\n  mesh = new THREE.SkinnedMesh(model, mat);\n\n  var animation = new THREE.Animation(mesh, model.animation);\n\n  mesh.rotation.x = 0.5 * Math.PI;\n  mesh.rotation.z = 0.7 * Math.PI;\n  scene.add(mesh);\n\n  // start the animation\n  animation.play();\n\n}, '../assets/models');\n```", "```js\n<script type=\"text/javascript\" src=\"../libs/ColladaLoader.js\"></script>\n```", "```js\nvar loader = new THREE.ColladaLoader();\nloader.load('../assets/models/monster.dae', function (collada) {\n\n  var child = collada.skins[0];\n  scene.add(child);\n\n  var animation = new THREE.Animation(child, child.geometry.animation);\n  animation.play();\n\n  // position the mesh\n  child.scale.set(0.15, 0.15, 0.15);\n  child.rotation.x = -0.5 * Math.PI;\n  child.position.x = -100;\n  child.position.y = -60;\n});\n```", "```js\nfunction render() {\n  ...\n  meshAnim.updateAnimation( delta *1000 );\n  ...\n}\n```", "```js\nmesh.playAnimation('crattack', 10);\n```", "```js\nmesh.parseAnimations();\n```", "```js\nmesh.parseAnimations();\n\nvar animLabels = [];\nfor (var key in mesh.geometry.animations) {\n  if (key === 'length' || !mesh.geometry.animations.hasOwnProperty(key)) continue;\n  animLabels.push(key);\n}\n\ngui.add(controls,'animations',animLabels).onChange(function(e) {\n  mesh.playAnimation(controls.animations,controls.fps);\n});\n```"]
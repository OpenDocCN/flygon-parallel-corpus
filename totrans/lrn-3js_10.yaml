- en: Chapter 10. Loading and Working with Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。加载和使用纹理
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working
    with Three.js Materials*, we introduced you to the various materials that are
    available in Three.js. In that chapter, however, we didn''t talk about applying
    textures to meshes. In this chapter, we''ll look at that subject. More specifically,
    in this chapter, we''ll discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用Three.js材质")中，*使用Three.js材质*，我们向您介绍了Three.js中可用的各种材质。然而，在那一章中，我们没有讨论如何将纹理应用到网格上。在本章中，我们将讨论这个主题。更具体地说，在本章中，我们将讨论以下主题：
- en: Loading textures in Three.js and applying them to a mesh
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js中加载纹理并将其应用于网格
- en: Using bump and normal maps to apply depth and detail to a mesh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凹凸和法线贴图为网格应用深度和细节
- en: Creating fake shadows using a light map
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光照图创建假阴影
- en: Adding detailed reflection to a material using an environment map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境贴图为材质添加详细的反射
- en: Using a specular map to set the *shininess* of specific parts of a mesh
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高光贴图来设置网格特定部分的*光泽*
- en: Fine-tuning and customizing the UV mapping of a mesh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调和自定义网格的UV映射
- en: Using the HTML5 canvas and video element as input for a texture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5画布和视频元素作为纹理的输入
- en: Let's start with the most basic example, where we show you how to load and apply
    a texture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的示例开始，向您展示如何加载和应用纹理。
- en: Using textures in materials
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在材质中使用纹理
- en: There are different ways textures are used in Three.js. You can use them to
    define the colors of the mesh, but you can also use them to define shininess,
    bumps, and reflections. The first example we look at, though, is the most basic
    approach, where we use a texture to define the colors of the individual pixels
    of a mesh.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中有不同的纹理使用方式。您可以使用它们来定义网格的颜色，但也可以使用它们来定义光泽、凹凸和反射。我们首先看的例子是最基本的方法，即使用纹理来定义网格的每个像素的颜色。
- en: Loading a texture and applying it to a mesh
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载纹理并将其应用于网格
- en: The most basic usage of a texture is when it's set as a map on a material. When
    you use this material to create a mesh, the mesh will be colored based on the
    supplied texture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的最基本用法是将其设置为材质上的映射。当您使用此材质创建网格时，网格的颜色将基于提供的纹理着色。
- en: 'Loading a texture and using it on a mesh can be done in the following manner:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加载纹理并在网格上使用它可以通过以下方式完成：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code sample, we use the `THREE.ImageUtils.loadTexture` function to
    load an image file from a specific location. You can use PNG, GIF, or JPEG images
    as input for a texture. Note that loading textures is done asynchronously. In
    our scenario, this isn''t an issue as we have a `render` loop where we render
    the scene around 60 times per second. If you want to wait until a texture is loaded,
    you could use the following approach:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们使用`THREE.ImageUtils.loadTexture`函数从特定位置加载图像文件。您可以使用PNG、GIF或JPEG图像作为纹理的输入。请注意，加载纹理是异步完成的。在我们的场景中，这不是一个问题，因为我们有一个`render`循环，每秒渲染大约60次。如果您想要等待直到纹理加载完成，您可以使用以下方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we supply a callback function to `loadTexture`. This callback
    is called when the texture is loaded. In our examples, we don't use the callback
    and rely on the `render` loop to eventually show the texture when it's loaded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们向`loadTexture`提供了一个回调函数。当纹理加载时，将调用此回调。在我们的示例中，我们不使用回调，而是依赖于`render`循环最终在加载纹理时显示纹理。
- en: 'You can use pretty much any image you''d like as a texture. The best results,
    however, are when you use a square texture whose dimensions are a power of 2\.
    So dimensions such as 256 x 256, 512 x 512, 1024 x 1024, and so on work the best.
    The following image is an example of a square texture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎可以使用任何您喜欢的图像作为纹理。然而，最好的结果是当您使用一个边长是2的幂的正方形纹理时。因此，边长为256 x 256、512 x 512、1024
    x 1024等尺寸效果最好。以下图像是一个正方形纹理的示例：
- en: '![Loading a texture and applying it to a mesh](graphics/2215OS_10_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![加载纹理并将其应用于网格](graphics/2215OS_10_01.jpg)'
- en: 'Since the pixels of a texture (also called **texels**) usually don''t map one-to-one
    on the pixels of the face, the texture needs to be magnified or minified. For
    this purpose, WebGL and Three.js offer a couple of different options. You can
    specify how the texture is magnified by setting the `magFilter` property and how
    it is minified with the `minFilter` property. These properties can be set to the
    following two basic values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理的像素（也称为**texels**）通常不是一对一地映射到面的像素上，因此需要对纹理进行放大或缩小。为此，WebGL和Three.js提供了一些不同的选项。您可以通过设置`magFilter`属性来指定纹理的放大方式，通过设置`minFilter`属性来指定缩小方式。这些属性可以设置为以下两个基本值：
- en: '| Name | Description |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.NearestFilter` | This filter uses the color of the nearest texel that
    it can find. When used for magnification, this will result in blockiness, and
    when used for minification, the result will lose much detail. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestFilter` | 此滤镜使用它能找到的最近的像素的颜色。当用于放大时，这将导致块状，当用于缩小时，结果将丢失很多细节。
    |'
- en: '| `THREE.LinearFilter` | This filter is more advanced and uses the color value
    of the four neighboring texels to determine the correct color. You''ll still lose
    much detail in minification, but the magnification will be much smoother and less
    blocky. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearFilter` | 此滤镜更先进，使用四个相邻像素的颜色值来确定正确的颜色。在缩小时仍会丢失很多细节，但放大会更加平滑，不那么块状。
    |'
- en: 'Besides these basic values, we can also use a mipmap. A **mipmap** is a set
    of texture images, each half the size of the previous one. These are created when
    you load the texture and allow much smoother filtering. So, when you''ve got a
    square texture (as a power of 2), you can use a couple of additional approaches
    for better filtering. The properties can be set using the following values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本值，我们还可以使用mipmap。**Mipmap**是一组纹理图像，每个图像的尺寸都是前一个的一半。当加载纹理时会创建这些图像，并允许更平滑的过滤。因此，当您有一个正方形纹理（作为2的幂），您可以使用一些额外的方法来获得更好的过滤效果。这些属性可以使用以下值进行设置：
- en: '| Name | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.NearestMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the nearest filter principle that
    we discussed in the previous table. Magnification is still blocky, but minification
    looks much better. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestMipMapNearestFilter` | 此属性选择最佳映射所需分辨率的mipmap，并应用我们在前表中讨论的最近过滤原则。放大仍然很粗糙，但缩小看起来好多了。
    |'
- en: '| `THREE.NearestMipMapLinearFilter` | This property selects not just a single
    mipmap but the two nearest mipmap levels. On both these levels, a nearest filter
    is applied to get two intermediate results. These two results are passed through
    a linear filter to get the final result. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestMipMapLinearFilter` | 此属性不仅选择单个mipmap，还选择两个最接近的mipmap级别。在这两个级别上，应用最近的过滤器以获得两个中间结果。这两个结果通过线性过滤器传递以获得最终结果。
    |'
- en: '| `THREE.LinearMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the linear filter principle we discussed
    in the previous table. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearMipMapNearestFilter` | 此属性选择最佳映射所需分辨率的mipmap，并应用我们在前表中讨论的线性过滤原则。|'
- en: '| `THREE.LinearMipMapLinearFilter` | This property selects not a single mipmap
    but the two nearest mipmap levels. On both these levels, a linear filter is applied
    to get two intermediate results. These two results are passed through a linear
    filter to get the final result. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearMipMapLinearFilter` | 此属性不仅选择单个mipmap，还选择两个最接近的mipmap级别。在这两个级别上，应用线性过滤器以获得两个中间结果。这两个结果通过线性过滤器传递以获得最终结果。
    |'
- en: 'If you don''t specify the `magFilter` and `minFilter` properties explicitly,
    Three.js uses `THREE.LinearFilter` as the default for the `magFilter` property
    and `THREE.LinearMipMapLinearFilter` as the default for the `minFilter` property.
    In our examples, we''ll just use these default properties. An example for the
    basic texture can be found in `01-basic-texture.html`. The following screenshot
    shows this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有明确指定`magFilter`和`minFilter`属性，Three.js将使用`THREE.LinearFilter`作为`magFilter`属性的默认值，并使用`THREE.LinearMipMapLinearFilter`作为`minFilter`属性的默认值。在我们的示例中，我们将使用这些默认属性。基本纹理的示例可以在`01-basic-texture.html`中找到。以下屏幕截图显示了此示例：
- en: '![Loading a texture and applying it to a mesh](graphics/2215OS_10_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![加载纹理并将其应用于网格](graphics/2215OS_10_02.jpg)'
- en: 'In this example, we load a couple of textures (using the code you saw earlier)
    and apply them to various shapes. In this example, you can see that the textures
    nicely wrap around the shapes. When you create geometries in Three.js, it makes
    sure that any texture that is used is applied correctly. This is done by something
    called **UV mapping** (more on this later in this chapter). With UV mapping, we
    tell the renderer which part of a texture should be applied to a specific face.
    The easiest example for this is the cube. The UV mapping for one of the faces
    looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们加载了一些纹理（使用您之前看到的代码）并将它们应用于各种形状。在此示例中，您可以看到纹理很好地包裹在形状周围。在Three.js中创建几何图形时，它会确保正确应用任何使用的纹理。这是通过一种称为**UV映射**的东西完成的（本章后面将详细介绍）。通过UV映射，我们告诉渲染器应将纹理的哪一部分应用于特定的面。最简单的示例是立方体。其中一个面的UV映射如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that we use the complete texture (UV values range from 0 to 1) for
    this face.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们对这个面使用完整的纹理（UV值范围从0到1）。
- en: 'Besides the standard image formats we can load with `THREE.ImageUtils.loadTexture`,
    Three.js also provides a couple of custom loaders you can use to load textures
    provided in different formats. The following table shows the additional loaders
    you can use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可以使用`THREE.ImageUtils.loadTexture`加载的标准图像格式之外，Three.js还提供了一些自定义加载程序，您可以使用这些加载程序加载以不同格式提供的纹理。以下表格显示了您可以使用的其他加载程序：
- en: '| Name | Description |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.DDSLoader` | With this loader, you can load textures that are provided
    in the DirectDraw Surface format. This format is a proprietary Microsoft format
    to store compressed textures. Using this loader is very easy. First, include the
    `DDSLoader.js` file in your HTML page and then use the following to use a texture:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.DDSLoader` | 使用此加载程序，您可以加载以DirectDraw Surface格式提供的纹理。这种格式是一种专有的微软格式，用于存储压缩纹理。使用此加载程序非常简单。首先，在HTML页面中包含`DDSLoader.js`文件，然后使用以下内容使用纹理：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see an example of this loader in the sources for this chapter in `01-basic-texture-dds.html`.
    Internally, this loader uses `THREE.CompressedTextureLoader`. |
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的源代码中看到此加载程序的示例：`01-basic-texture-dds.html`。在内部，此加载程序使用`THREE.CompressedTextureLoader`。|
- en: '| `THREE.PVRLoader` | Power VR is another proprietary file format to store
    compressed textures. Three.js supports the Power VR 3.0 file format and can use
    textures provided in this format. To use this loader, include the `PVRLoader.js`
    file in your HTML page and then use the following to use a texture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.PVRLoader` | Power VR是另一种专有文件格式，用于存储压缩纹理。Three.js支持Power VR 3.0文件格式，并可以使用以此格式提供的纹理。要使用此加载程序，请在HTML页面中包含`PVRLoader.js`文件，然后使用以下内容使用纹理：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see an example of this loader in the sources for this chapter: `01-basic-texture-pvr.html`.
    Note that not all WebGL implementations support textures in this format. So when
    you use this and don''t see a texture, check the console for errors. Internally,
    this loader also uses `THREE.CompressedTextureLoader`. |'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的源代码中看到此加载程序的示例：`01-basic-texture-pvr.html`。请注意，并非所有的WebGL实现都支持此格式的纹理。因此，当您使用此格式但未看到纹理时，请检查控制台以查看错误。在内部，此加载程序还使用`THREE.CompressedTextureLoader`。|
- en: '| `THREE.TGALoader` | Targa is a raster graphics file format that is still
    used by a large number of 3D software programs. With the `THREE.TGALoader` object,
    you can use textures provided in this format with your 3D models. To use these
    image files, you first have to include the `TGALoader.js` file in your HTML, and
    then you can use the following to load a TGA texture:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.TGALoader` | Targa是一种光栅图形文件格式，仍然被大量3D软件程序使用。使用`THREE.TGALoader`对象，您可以在3D模型中使用以此格式提供的纹理。要使用这些图像文件，您首先必须在HTML中包含`TGALoader.js`文件，然后可以使用以下内容加载TGA纹理：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An example of this loader is provided in the sources of this chapter. You can
    view this example by opening `01-basic-texture-tga.html` in your browser. |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码中提供了此加载器的示例。您可以通过在浏览器中打开`01-basic-texture-tga.html`来查看此示例。|
- en: In these examples, we've used textures to define the color of the pixels of
    our mesh. We can also use textures for other purposes. The following two examples
    are used to define how shading is applied to a material. You use this to create
    bumps and wrinkles on the surface of a mesh.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们使用纹理来定义网格像素的颜色。我们还可以将纹理用于其他目的。以下两个示例用于定义如何应用阴影到材质上。您可以使用这个来在网格表面创建凸起和皱纹。
- en: Using a bump map to create wrinkles
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用凸起贴图创建皱纹
- en: 'A **bump map** is used to add more depth to a material. You can see this in
    action by opening up the `02-bump-map.html` example. Refer to the following screenshot
    to see the example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**凸起贴图**用于增加材质的深度。您可以通过打开`02-bump-map.html`示例来看到其效果。请参考以下截图查看示例：'
- en: '![Using a bump map to create wrinkles](graphics/2215OS_10_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用凸起贴图创建皱纹](graphics/2215OS_10_03.jpg)'
- en: 'In this example, you can see that the left-hand side wall looks much more detailed
    and seems to have much more depth when you compare it with the wall on the right-hand
    side. This is done by setting an additional texture, a so-called bump map, on
    the material:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以看到左侧墙看起来比右侧墙更详细，并且在比较时似乎具有更多的深度。这是通过在材质上设置额外的纹理，所谓的凸起贴图来实现的：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see in this code that besides setting the `map` property, we also set
    the `bumpMap` property to a texture. Additionally, with the `bumpScale` property,
    we can set the height (or depth if set to a negative value) of the bumps. The
    textures used in this example are shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此代码中看到，除了设置`map`属性之外，我们还将`bumpMap`属性设置为纹理。另外，通过`bumpScale`属性，我们可以设置凸起的高度（或如果设置为负值则为深度）。此示例中使用的纹理如下所示：
- en: '![Using a bump map to create wrinkles](graphics/2215OS_10_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用凸起贴图创建皱纹](graphics/2215OS_10_04.jpg)'
- en: The bump map is a grayscale image, but you can also use a color image. The intensity
    of the pixel defines the height of the bump. A bump map only contains the relative
    height of a pixel. It doesn't say anything about the direction of the slope. So
    the level of detail and perception of depth that you can reach with a bump map
    is limited. For more details, you can use a normal map.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 凸起贴图是灰度图像，但您也可以使用彩色图像。像素的强度定义了凸起的高度。凸起贴图只包含像素的相对高度。它并不表示坡度的方向。因此，使用凸起贴图可以达到的细节水平和深度感知是有限的。要获得更多细节，您可以使用法线贴图。
- en: Achieving more detailed bumps and wrinkles with a normal map
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用法线贴图实现更详细的凸起和皱纹
- en: 'In a normal map, the height (displacement) is not stored, but the direction
    of the normal for each picture is stored. Without going into too much detail,
    with normal maps, you can create very detailed-looking models that still only
    use a small number of vertices and faces. For instance, have a look at the `03-normal-map.html`
    example. The following screenshot depicts this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在法线贴图中，高度（位移）不会被存储，而是存储了每个图像的法线方向。不详细介绍，使用法线贴图，您可以创建看起来非常详细的模型，而仍然只使用少量的顶点和面。例如，查看`03-normal-map.html`示例。以下截图显示了此示例：
- en: '![Achieving more detailed bumps and wrinkles with a normal map](graphics/2215OS_10_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用法线贴图实现更详细的凸起和皱纹](graphics/2215OS_10_05.jpg)'
- en: 'In this screenshot, you can see a very detailed plastered cube to the left.
    The light source moves around the cubes, and you can see that the texture responds
    naturally to the light source. This provides a very realistic-looking model and
    only requires a very simple model and a couple of textures. The following code
    fragment shows how to use a normal map in Three.js:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，您可以看到左侧有一个非常详细的抹灰立方体。光源在立方体周围移动，您可以看到纹理对光源的自然响应。这提供了一个非常逼真的模型，只需要一个非常简单的模型和几个纹理。以下代码片段显示了如何在Three.js中使用法线贴图：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same approach is used here as was done for the bump map. This time, though,
    we set the `normalMap` property to the normal texture. We can also define how
    pronounced the bumps look by setting the `normalScale` property `mat.normalScale.set(1,1)`.
    With these two properties, you can scale along the *x* and *y* axes. The best
    approach, though, is to keep these values the same for the best effect. Note that
    once again, when these values are below zero, the heights inverse. The following
    screenshot shows both the texture (on the left-hand side) and the normal map (on
    the right-hand side):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法与凸起贴图相同。不过这次，我们将`normalMap`属性设置为法线纹理。我们还可以通过设置`normalScale`属性`mat.normalScale.set(1,1)`来定义凸起的外观。通过这两个属性，您可以沿着*x*和*y*轴进行缩放。不过，最好的方法是保持这些值相同以获得最佳效果。请注意，再次强调，当这些值低于零时，高度会反转。以下截图显示了纹理（左侧）和法线贴图（右侧）：
- en: '![Achieving more detailed bumps and wrinkles with a normal map](graphics/2215OS_10_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用法线贴图实现更详细的凸起和皱纹](graphics/2215OS_10_06.jpg)'
- en: The problem with normal maps, however, is that they aren't very easy to create.
    You need to use specialized tools, such as Blender or Photoshop. They can use
    high-resolution renderings or textures as input and create normal maps from them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，法线贴图的问题在于它们不太容易创建。您需要使用专门的工具，如Blender或Photoshop。它们可以使用高分辨率渲染或纹理作为输入，并从中创建法线贴图。
- en: Three.js also provides a way to do this during runtime. The `THREE.ImageUtils`
    object has a function called `getNormalMap`, which takes a JavaScript/DOM `Image`
    as input and converts it into a normal map.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了一种在运行时执行此操作的方法。`THREE.ImageUtils`对象有一个名为`getNormalMap`的函数，它接受JavaScript/DOM`Image`作为输入，并将其转换为法线贴图。
- en: Creating fake shadows using a light map
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用光照贴图创建虚假阴影
- en: 'In the previous examples, we used specific maps to create real-looking shadows
    that react to the lighting in the room. There is an alternative option to create
    fake shadows. In this section, we''ll use a light map. A **light map** is a pre-rendered
    shadow (also called a prebaked shadow) that you can use to create the illusion
    of a real shadow. The following screenshot, from the `04-light-map.html` example,
    shows how this looks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用特定的贴图来创建看起来真实的阴影，这些阴影会对房间中的光照做出反应。还有另一种选择可以创建假阴影。在本节中，我们将使用光照贴图。**光照贴图**是一个预渲染的阴影（也称为预烘烤阴影），您可以使用它来营造真实阴影的错觉。以下截图来自`04-light-map.html`示例，展示了这个效果：
- en: '![Creating fake shadows using a light map](graphics/2215OS_10_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用光照贴图创建假阴影](graphics/2215OS_10_07.jpg)'
- en: 'If you look at the previous example, it shows a couple of very nice shadows,
    which seem to be cast by the two cubes. These shadows, however, are based on a
    light map texture that looks like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下之前的示例，会发现有两个非常漂亮的阴影，似乎是由两个立方体投射出来的。然而，这些阴影是基于一个看起来像下面这样的光照贴图的：
- en: '![Creating fake shadows using a light map](graphics/2215OS_10_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用光照贴图创建假阴影](graphics/2215OS_10_08.jpg)'
- en: 'As you can see, the shadows, as specified in the light map, are also shown
    as the shadows on the ground plane, creating the illusion of real shadows. You
    can use this technique to create high-resolution shadows, without incurring a
    heavy rendering penalty. This, of course, only works for static scenes. Using
    a light map is pretty much the same as using other textures with a couple of small
    differences. This is how we go about using a light map:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，光照贴图中指定的阴影也显示在地面上，营造出真实阴影的错觉。您可以使用这种技术创建高分辨率的阴影，而不会产生沉重的渲染惩罚。当然，这仅适用于静态场景。使用光照贴图与使用其他纹理基本相同，只有一些小差异。以下是我们使用光照贴图的方法：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To apply a light map, we just need to set the `lightMap` property of the material
    to the light map we just showed. There is, however, an additional step required
    to get the light map to show up. We need to explicitly define the UV mapping (what
    part of the texture is shown on a face) for the light map. This needs to be done
    so that you can apply and map the light map independently of the other textures.
    In our example, we just use the basic UV mapping, automatically created by Three.js
    when we created the ground plane. More information and a background of why an
    explicit UV mapping is required can be found at [http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op](http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用光照贴图，我们只需要将材质的`lightMap`属性设置为我们刚刚展示的光照贴图。然而，还需要额外的步骤才能让光照贴图显示出来。我们需要明确定义UV映射（纹理在面上的哪一部分）以便独立应用和映射光照贴图。在我们的示例中，我们只使用了基本的UV映射，这是在创建地面时由Three.js自动创建的。更多信息和为什么需要明确定义UV映射的背景可以在[http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op](http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op)找到。
- en: When the shadow map is positioned correctly, we need to place the cubes in the
    correct location so that it looks as though the shadows are being cast by them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当阴影贴图正确放置后，我们需要将立方体放置在正确的位置，以便看起来阴影是由它们投射出来的。
- en: Three.js provides another texture that you can use to fake advanced 3D effects.
    In the next section, we'll look at using environment maps for fake reflections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了另一种纹理，您可以使用它来模拟高级的3D效果。在下一节中，我们将看看如何使用环境贴图来模拟反射。
- en: Creating fake reflections using an environment map
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境贴图创建假反射
- en: 'Calculating environment reflections is very CPU-intensive and usually requires
    a ray tracer approach. If you want to use reflections in Three.js, you can still
    do that, but you''ll have to fake it. You can do this by creating a texture of
    the environment the object is in and apply this to the specific object. First,
    we''ll show you the result we''re aiming for (see `05-env-map-static.html`, which
    is also shown in the following screenshot):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算环境反射非常消耗CPU，并且通常需要使用光线追踪器方法。如果您想在Three.js中使用反射，仍然可以做到，但您需要模拟它。您可以通过创建对象所在环境的纹理并将其应用于特定对象来实现这一点。首先，我们将展示我们的目标结果（请参阅`05-env-map-static.html`，也显示在以下截图中）：
- en: '![Creating fake reflections using an environment map](graphics/2215OS_10_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境贴图创建假反射](graphics/2215OS_10_09.jpg)'
- en: 'In this screenshot, you can see the sphere and cube reflect the environment.
    If you move your mouse around, you can also see that the reflection corresponds
    with the camera angle in relation to the city environment you see. To create this
    example, we perform the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，您可以看到球体和立方体反射了环境。如果您移动鼠标，还可以看到反射与您在城市环境中的相机角度相对应。为了创建这个示例，我们执行以下步骤：
- en: '**Create a CubeMap object**: The first thing we need to do is create a `CubeMap`
    object. `CubeMap` is a set of six textures that can be applied to each side of
    a cube.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建CubeMap对象**：我们需要做的第一件事是创建一个`CubeMap`对象。`CubeMap`是一组可以应用于立方体每一面的六个纹理。'
- en: '**Create a box with this CubeMap object**: The box with `CubeMap` is the environment
    you see when you move the camera around. It gives the illusion that you''re standing
    in an environment where you can look around. In reality, you''re inside a cube
    with textures rendered on the inside to give an illusion of space.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用这个CubeMap对象创建一个盒子**：带有`CubeMap`的盒子是您在移动相机时看到的环境。它给人一种错觉，好像您站在一个可以四处看的环境中。实际上，您是在一个立方体内部，内部渲染了纹理，给人一种空间的错觉。'
- en: '**Apply the CubeMap object as a texture**: The same `CubeMap` object we used
    to simulate the environment can be used as a texture on the meshes. Three.js will
    make sure it looks like a reflection of the environment.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将CubeMap对象应用为纹理**：我们用来模拟环境的`CubeMap`对象也可以作为网格的纹理。Three.js会确保它看起来像环境的反射。'
- en: 'Creating `CubeMap` is pretty easy once you''ve got the source material. What
    you need are six images that together make up a complete environment. So you need
    the following pictures: looking forward (`posz`), looking backward (`negz`), looking
    up (`posy`), looking down (`negy`), looking right (`posx`), and looking left (`negx`).
    Three.js will patch these together to create a seamless environment map. There
    are a couple of sites where you can download these pictures. The ones used in
    this example are from [http://www.humus.name/index.php?page=Textures](http://www.humus.name/index.php?page=Textures).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了源材料，创建`CubeMap`就非常简单。您需要的是六张图片，它们共同组成一个完整的环境。因此，您需要以下图片：向前看（`posz`）、向后看（`negz`）、向上看（`posy`）、向下看（`negy`）、向右看（`posx`）和向左看（`negx`）。Three.js将这些拼接在一起，以创建一个无缝的环境映射。有几个网站可以下载这些图片。本例中使用的图片来自[http://www.humus.name/index.php?page=Textures](http://www.humus.name/index.php?page=Textures)。
- en: 'Once you''ve got the six separate pictures, you can load them as shown in the
    following code fragment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了六张单独的图片，您可以按照以下代码片段中所示的方式加载它们：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We again use the `THREE.ImageUtils` JavaScript object, but this time, we pass
    in an array of textures and create the `CubeMap` object using the `loadTextureCube`
    function. If you''ve already got a 360-degree panoramic image, you can also convert
    that into a set of images you can use to create `CubeMap`. Just go to [http://gonchar.me/panorama/](http://gonchar.me/panorama/)
    to convert an image, and you end up with six images with names like `right.png`,
    `left.png`, `top.png`, `bottom.png`, `front.png`, and `back.png`. You can use
    these by creating the `urls` variable like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`THREE.ImageUtils` JavaScript对象，但这次，我们传入一个纹理数组，并使用`loadTextureCube`函数创建`CubeMap`对象。如果您已经有了360度全景图像，您也可以将其转换为一组图像，以便创建`CubeMap`。只需转到[http://gonchar.me/panorama/](http://gonchar.me/panorama/)来转换图像，您最终会得到六张带有名称如`right.png`、`left.png`、`top.png`、`bottom.png`、`front.png`和`back.png`的图像。您可以通过创建以下方式的`urls`变量来使用这些图像：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can also let Three.js handle the conversion when you load
    the scene by creating `textureCube` like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您还可以在加载场景时让Three.js处理转换，方法是创建`textureCube`，如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With `CubeMap`, we first create a box, which can be created like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CubeMap`，我们首先创建一个盒子，可以这样创建：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Three.js provides a specific shader that we can use with `THREE.ShaderMaterial`
    to create an environment based on `CubeMap` (`var shader = THREE.ShaderLib[ "cube"
    ];`). We configure this shader with `CubeMap`, create a mesh, and add it to the
    scene. This mesh, if seen from the inside, represents the fake environment we're
    standing in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一个特定的着色器，我们可以使用`THREE.ShaderMaterial`来基于`CubeMap`创建一个环境（`var shader
    = THREE.ShaderLib[ "cube" ];`）。我们使用`CubeMap`配置此着色器，创建一个网格，并将其添加到场景中。如果从内部看，这个网格代表我们所处的虚假环境。
- en: 'This same `CubeMap` object should be applied to the meshes we want to render
    to create the fake reflection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的`CubeMap`对象应该应用于我们想要渲染的网格，以创建虚假的反射：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we set the `envMap` property of the material to the `cubeMap`
    object we created. The result is a scene where it looks like we're standing in
    a wide, outdoors environment, where the meshes reflect this environment. If you
    use the sliders, you can set the `reflectivity` property of the material, and,
    as the name implies, this determines how much of the environment is reflected
    by the material.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将材质的`envMap`属性设置为我们创建的`cubeMap`对象。结果是一个场景，看起来我们站在一个宽阔的室外环境中，网格反映了这个环境。如果您使用滑块，可以设置材质的`reflectivity`属性，正如其名称所示，这决定了材质反射了多少环境。
- en: 'Besides reflection, Three.js also allows you to use a `CubeMap` object for
    refraction (glass-like objects). The following screenshot shows this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反射，Three.js还允许您为折射（类似玻璃的对象）使用`CubeMap`对象。以下屏幕截图显示了这一点：
- en: '![Creating fake reflections using an environment map](graphics/2215OS_10_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境映射创建虚假反射](graphics/2215OS_10_10.jpg)'
- en: 'To get this effect, we just need to change the loading of the textures to this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这种效果，我们只需要将纹理加载更改为以下内容：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can control the `refraction` ratio with the `refraction` property on the
    material, just as with the `reflection` property. In this example, we''ve used
    a static environment map for the meshes. In other words, we only saw the environment
    reflection and not the other meshes in this environment. In the following screenshot
    (which you can see in action by opening `05-env-map-dynamic.html` in your browser),
    we''ll show you how you can create a reflection that also shows the other objects
    in the scene:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用材质上的`refraction`属性来控制`refraction`比例，就像使用`reflection`属性一样。在本例中，我们为网格使用了静态环境映射。换句话说，我们只看到了环境反射，而没有看到环境中的其他网格。在下面的屏幕截图中（您可以通过在浏览器中打开`05-env-map-dynamic.html`来查看），我们将向您展示如何创建一个反射，同时还显示场景中的其他对象：
- en: '![Creating fake reflections using an environment map](graphics/2215OS_10_22.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境映射创建虚假反射](graphics/2215OS_10_22.jpg)'
- en: 'To also show reflections from the other objects in the scene, we need to use
    some other Three.js components. The first thing we need is an additional camera
    called `THREE.CubeCamera`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示场景中其他对象的反射，我们需要使用一些其他Three.js组件。我们需要的第一件事是一个名为`THREE.CubeCamera`的额外相机：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will use `THREE.CubeCamera` to take a snapshot of the scene with all the
    objects rendered, and use that to set up `CubeMap`. You need to make sure you
    position this camera at the exact location of `THREE.Mesh` on which you want to
    show the dynamic reflections. For this example, we'll only show reflections on
    the center sphere (as you can see in the previous screenshot). This sphere is
    located at the position 0, 0, 0, so for this example, we don't need to explicitly
    position `THREE.CubeCamera`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`THREE.CubeCamera`来拍摄包含所有渲染对象的场景快照，并使用它来设置`CubeMap`。您需要确保将此相机定位在您想要显示动态反射的`THREE.Mesh`的确切位置上。在本例中，我们将仅在中心球上显示反射（如前一个屏幕截图中所示）。该球位于位置0,
    0, 0，因此在本例中，我们不需要显式定位`THREE.CubeCamera`。
- en: 'We only apply the dynamic reflections to the sphere, so we''re going to need
    two different materials:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将动态反射应用于球体，因此我们需要两种不同的材质：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The main difference with our previous example is that for the dynamic reflections,
    we set the `envMap` property to `cubeCamera.renderTarget` instead of to `textureCube`,
    which we created earlier. For this example, we use `dynamicEnvMaterial` on the
    central sphere and `envMaterial` for the other two objects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的例子的主要区别是，对于动态反射，我们将`envMap`属性设置为`cubeCamera.renderTarget`，而不是我们之前创建的`textureCube`。对于这个例子，我们在中心球体上使用`dynamicEnvMaterial`，在其他两个对象上使用`envMaterial`：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that is left to do is make sure `cubeCamera` renders the scene, so we can
    use that output as input for the center sphere. To do this, we update the `render`
    loop like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是确保`cubeCamera`渲染场景，这样我们就可以将其输出用作中心球体的输入。为此，我们更新`render`循环如下：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we first disable the visibility of `sphere`. We do this because
    we only want to see reflections from the other two objects. Next, we render the
    scene using `cubeCamera` by calling the `updateCubeMap` function. After that,
    we make `sphere` visible again and render the scene as normal. The result is that
    in the reflection of the sphere, you can see the reflections of the cube and the
    cylinder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先禁用了`sphere`的可见性。我们这样做是因为我们只想看到来自其他两个对象的反射。接下来，我们通过调用`updateCubeMap`函数使用`cubeCamera`渲染场景。之后，我们再次使`sphere`可见，并像平常一样渲染场景。结果是，在球体的反射中，你可以看到立方体和圆柱的反射。
- en: The last of the basic materials we'll look at is the specular map.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的基本材质的最后一个是高光贴图。
- en: Specular map
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高光贴图
- en: 'With a **specular map**, you can specify a map that defines the shininess and
    the highlight color of a material. For instance, in the following screenshot,
    we''ve used a specular map together with a normal map to render a globe. You can
    see this example if you open `06-specular-map.html` in your browser. The result
    of this is also shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**高光贴图**，你可以指定一个定义材质光泽度和高光颜色的贴图。例如，在下面的截图中，我们使用了高光贴图和法线贴图来渲染一个地球。你可以在浏览器中打开`06-specular-map.html`来查看这个例子。其结果也显示在下面的截图中：
- en: '![Specular map](graphics/2215OS_10_11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![高光贴图](graphics/2215OS_10_11.jpg)'
- en: 'In this screenshot, you can see that the oceans are highlighted and reflect
    light. The continents, on the other hand, are very dark and don''t reflect (much)
    light. For this effect, we didn''t use any specific normal textures, but only
    a normal map to show heights and the following specular map to highlight the oceans:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，你可以看到海洋被突出显示并反射光线。另一方面，大陆非常黑暗，不反射（太多）光线。为了达到这种效果，我们没有使用任何特定的法线纹理，而只使用了法线贴图来显示高度和以下高光贴图来突出显示海洋：
- en: '![Specular map](graphics/2215OS_10_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![高光贴图](graphics/2215OS_10_12.jpg)'
- en: 'Basically, what happens is that the higher the value of the pixel (from black
    to white), the shinier the surface will appear. A specular map is usually used
    together with the `specular` property that you can use to determine the color
    of the reflection. In this case, it is set to red:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，像素的值越高（从黑色到白色），表面看起来就越有光泽。高光贴图通常与`specular`属性一起使用，你可以用它来确定反射的颜色。在这种情况下，它被设置为红色：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also note that the best effects are usually realized with low shininess, but
    depending on the lighting and the specular map you use, you might need to experiment
    to get the desired effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，通常使用低光泽度可以实现最佳效果，但根据光照和你使用的高光贴图，你可能需要进行实验以获得期望的效果。
- en: Advanced usage of textures
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理的高级用法
- en: In the previous section, we saw some basic texture usages. Three.js also provides
    options for more advanced texture usage. In this section, we'll look at a couple
    of options that Three.js provides.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一些基本的纹理用法。Three.js还提供了更高级纹理用法的选项。在本节中，我们将看一下Three.js提供的一些选项。
- en: Custom UV mapping
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义UV映射
- en: 'We''ll start off with a deeper look at UV mappings. We explained earlier that
    with UV mapping, you can specify what part of a texture is shown on a specific
    face. When you create a geometry in Three.js, these mappings will also be automatically
    created based on the type of geometry you created. In most cases, you don''t really
    need to change this default UV mapping. A good way to understand how UV mapping
    works is to look at an example from Blender, which is shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更深入地了解UV映射开始。我们之前解释过，使用UV映射，你可以指定纹理的哪一部分显示在特定的面上。当你在Three.js中创建几何体时，这些映射也会根据你创建的几何体类型自动创建。在大多数情况下，你不需要真正改变这个默认的UV映射。理解UV映射工作原理的一个好方法是看一个来自Blender的例子，如下面的截图所示：
- en: '![Custom UV mapping](graphics/2215OS_10_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](graphics/2215OS_10_13.jpg)'
- en: 'In this example, you see two windows. The window on the left-hand side contains
    a cube geometry. The window on the right-hand side is the UV mapping, where we''ve
    loaded an example texture to show how the mapping is. In this example, we''ve
    selected a single face for the window on the left-hand side and the window on
    the right-hand side shows the UV mapping for this face. As you can see, each vertex
    of the face is positioned in one of the corners of the UV mapping on the right
    (the small circles). This means that the complete texture will be used for that
    face. All the other faces of this cube are mapped in the same manner, so the result
    will show a cube where each face shows the complete texture; see `07-uv-mapping.html`,
    which is also shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到两个窗口。左侧的窗口包含一个立方体几何体。右侧的窗口是UV映射，我们加载了一个示例纹理来展示映射的方式。在这个例子中，我们选择了左侧窗口的一个单独面，并且右侧窗口显示了这个面的UV映射。你可以看到，面的每个顶点都位于右侧UV映射的一个角落（小圆圈）。这意味着完整的纹理将被用于这个面。这个立方体的所有其他面也以相同的方式映射，因此结果将显示一个每个面都显示完整纹理的立方体；参见`07-uv-mapping.html`，也显示在下面的截图中：
- en: '![Custom UV mapping](graphics/2215OS_10_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](graphics/2215OS_10_14.jpg)'
- en: 'This is the default for a cube in Blender (also in Three.js). Let''s change
    the UV by selecting only two-thirds of the texture (see the selected area in the
    following screenshot):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Blender中（也是Three.js中）立方体的默认设置。让我们通过只选择纹理的三分之二来改变UV（在下面的截图中看到所选区域）：
- en: '![Custom UV mapping](graphics/2215OS_10_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](graphics/2215OS_10_15.jpg)'
- en: 'If we now show this in Three.js, you can see that the texture is applied differently,
    as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在Three.js中展示这个，你会看到纹理被应用的方式不同，如下截图所示：
- en: '![Custom UV mapping](graphics/2215OS_10_16.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](graphics/2215OS_10_16.jpg)'
- en: 'Customizing UV mappings is normally done from programs such as Blender, especially
    when the models become more complex. The most important part to remember here
    is that UV mappings run in two dimensions, `u` and `v`, from 0 to 1\. To customize
    the UV mapping, you need to define, for each face, what part of the texture should
    be shown. You do this by defining the `u` and `v` coordinates for each of the
    vertices that make up the face. You can use the following code to set the `u`
    and `v` values:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义UV映射通常是从诸如Blender之类的程序中完成的，特别是当模型变得更加复杂时。这里最重要的部分是记住UV映射在两个维度上运行，从0到1。要自定义UV映射，你需要为每个面定义应该显示纹理的部分。你需要通过定义组成面的每个顶点的`u`和`v`坐标来实现这一点。你可以使用以下代码来设置`u`和`v`值：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code snippet will set the `uv` properties of the first face to the specified
    value. Remember that each face is defined by three vertices, so to set all the
    `uv` values for a face, we need to set six properties. If you open the `07-uv-mapping-manual.html,`
    example you can see what happens when you change the `uv` mappings manually. The
    following screenshot shows the example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将把第一个面的`uv`属性设置为指定的值。记住每个面由三个顶点定义，所以要设置一个面的所有`uv`值，我们需要设置六个属性。如果你打开`07-uv-mapping-manual.html`例子，你可以看到当你手动改变`uv`映射时会发生什么。以下截图展示了这个例子：
- en: '![Custom UV mapping](graphics/2215OS_10_23.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](graphics/2215OS_10_23.jpg)'
- en: Next, we'll look at how textures can be repeated, which is done by some internal
    UV mapping tricks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下纹理如何通过一些内部UV映射技巧来重复。
- en: Repeat wrapping
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复包装
- en: 'When you apply a texture to a geometry created by Three.js, Three.js will try
    to apply the texture as optimally as possible. For instance, for cubes, this means
    each side will show the complete texture, and for spheres, the complete texture
    is wrapped around the sphere. There are, however, situations where you don''t
    want the texture to spread around a complete face or the complete geometry, but
    have the texture repeat itself. Three.js provides detailed functionality that
    allows you to control this. An example where you can play around with the repeat
    properties is provided in the `08-repeat-wrapping.html` example. The following
    screenshot shows this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Three.js中应用纹理到一个几何体上时，Three.js会尽可能地优化应用纹理。例如，对于立方体，这意味着每一面都会显示完整的纹理，对于球体，完整的纹理会被包裹在球体周围。然而，有些情况下你可能不希望纹理在整个面或整个几何体上展开，而是希望纹理重复出现。Three.js提供了详细的功能来控制这一点。一个可以用来调整重复属性的例子在`08-repeat-wrapping.html`中提供。以下截图展示了这个例子：
- en: '![Repeat wrapping](graphics/2215OS_10_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![重复包装](graphics/2215OS_10_17.jpg)'
- en: In this example, you can set the property that controls how a texture repeats
    itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以设置控制纹理重复的属性。
- en: 'Before this property has the desired effect, you need to make sure you set
    the wrapping of the texture to `THREE.RepeatWrapping`, as shown in the following
    code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个属性产生期望效果之前，你需要确保你将纹理的包装设置为`THREE.RepeatWrapping`，如下代码片段所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `wrapS` property defines how you want the texture to behave along its *x*
    axis and the `wrapT` property defines how the texture should behave along its
    *y* axis. Three.js provides two options for this, which are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapS`属性定义了你希望纹理在*x*轴上的行为，`wrapT`属性定义了纹理在*y*轴上的行为。Three.js为此提供了两个选项，如下所示：'
- en: '`THREE.RepeatWrapping` allows the texture to repeat itself.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.RepeatWrapping`允许纹理重复出现。'
- en: '`THREE.ClampToEdgeWrapping` is a default setting. With `THREE.ClampToEdgeWrapping,`
    the texture doesn''t repeat as a whole, but only the pixels at the edge are repeated.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ClampToEdgeWrapping`是默认设置。使用`THREE.ClampToEdgeWrapping`，纹理不会整体重复，而只有边缘的像素会重复。'
- en: 'If you disable the **repeatWrapping** menu option, the `THREE.ClampToEdgeWrapping`
    option is used, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你禁用了**repeatWrapping**菜单选项，将会使用`THREE.ClampToEdgeWrapping`选项，如下所示：
- en: '![Repeat wrapping](graphics/2215OS_10_18.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![重复包装](graphics/2215OS_10_18.jpg)'
- en: 'If we use `THREE.RepeatWrapping`, we can set the `repeat` property as shown
    in the following code fragment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`THREE.RepeatWrapping`，我们可以设置`repeat`属性，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `repeatX` variable defines how often the texture is repeated along its *x*
    axis and the `repeatY` variable defines the same for the *y* axis. If these values
    are set to `1`, the texture won't repeat itself; if they are set to a higher value,
    you'll see that the texture will start repeating. You can also use values less
    than 1\. In that case, you can see that you'll zoom in on the texture. If you
    set the repeat value to a negative value, the texture will be mirrored.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatX`变量定义了纹理在*x*轴上重复的次数，`repeatY`变量定义了在*y*轴上的重复次数。如果这些值设置为`1`，纹理就不会重复；如果设置为更高的值，你会看到纹理开始重复。你也可以使用小于1的值。在这种情况下，你会看到你会放大纹理。如果你将重复值设置为负值，纹理会被镜像。'
- en: 'When you change the `repeat` property, Three.js will automatically update the
    textures and render with this new setting. If you change from `THREE.RepeatWrapping`
    to `THREE.ClampToEdgeWrapping`, you need to explicitly update the texture:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你改变`repeat`属性时，Three.js会自动更新纹理并使用新的设置进行渲染。如果你从`THREE.RepeatWrapping`改变到`THREE.ClampToEdgeWrapping`，你需要显式地更新纹理：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Until now, we've only used static images for our textures. Three.js, however,
    also has the option to use the HTML5 canvas as a texture.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了静态图像作为纹理。然而，Three.js也有选项可以使用HTML5画布作为纹理。
- en: Rendering to canvas and using it as a texture
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染到画布并将其用作纹理
- en: In this section, we're going to look at two different examples. First, we're
    going to look at how you can use the canvas to create a simple texture and apply
    it to a mesh, and after that, we'll go one step further and create a canvas that
    can be used as a bump map using a randomly generated pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看两个不同的示例。首先，我们将看一下如何使用画布创建一个简单的纹理并将其应用于网格，然后，我们将进一步创建一个可以用作凹凸贴图的画布，使用随机生成的图案。
- en: Using the canvas as a texture
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用画布作为纹理
- en: 'In the first example, we will use the **Literally** library (from [http://literallycanvas.com/](http://literallycanvas.com/))
    to create an interactive canvas that you can draw on; see the bottom-left corner
    in the following screenshot. You can view this example at `09-canvas-texture`.
    The ensuing screenshot shows this example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将使用**Literally**库（来自[http://literallycanvas.com/](http://literallycanvas.com/)）创建一个交互式画布，您可以在其上绘制；请参见以下截图的左下角。您可以在`09-canvas-texture`中查看此示例。随后的截图显示了此示例：
- en: '![Using the canvas as a texture](graphics/2215OS_10_19.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用画布作为纹理](graphics/2215OS_10_19.jpg)'
- en: 'Anything you draw on this canvas is directly rendered on the cube as a texture.
    Accomplishing this in Three.js is really simple and only takes a couple of steps.
    The first thing we need to do is create a canvas element and, for this specific
    example, configure it to be used with the `Literally` library, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此画布上绘制的任何内容都会直接呈现在立方体上作为纹理。在Three.js中实现这一点非常简单，只需要几个步骤。我们需要做的第一件事是创建一个画布元素，并且对于这个特定的示例，配置它以便与`Literally`库一起使用，如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We just create a `canvas` element from JavaScript and add it to a specific
    `div` element. With the `literallycanvas` call, we can create the drawing tools
    that you can use to directly draw on the canvas. Next, we need to create a texture
    that uses the canvas drawing as its input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需从JavaScript中创建一个`canvas`元素，并将其添加到特定的`div`元素中。通过`literallycanvas`调用，我们可以创建绘图工具，您可以直接在画布上绘制。接下来，我们需要创建一个使用画布绘制作为其输入的纹理：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the code shows, the only thing you need to do to is pass in the reference
    to the canvas element when you create a new texture, `new THREE.Texture(canvas)`.
    This will create a texture that uses the canvas element as its material. All that
    is left is to update the material whenever we render so that the latest version
    of the canvas drawing is shown on the cube, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如代码所示，您在创建新纹理时所需做的唯一事情就是在传入画布元素的引用时，`new THREE.Texture(canvas)`。这将创建一个使用画布元素作为其材质的纹理。剩下的就是在每次渲染时更新材质，以便在立方体上显示画布绘制的最新版本，如下所示：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To inform Three.js that we want to update the texture, we just set the `needsUpdate`
    property of the texture to `true`. In this example, we've used the canvas element
    as input for the most simple of textures. We can, of course, use this same idea
    for all the different types of maps we've seen so far. In the next example, we'll
    use it as a bump map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知Three.js我们想要更新纹理，我们只需将纹理的`needsUpdate`属性设置为`true`。在这个示例中，我们已经将画布元素用作最简单的纹理输入。当然，我们可以使用相同的思路来处理到目前为止看到的所有不同类型的地图。在下一个示例中，我们将把它用作凹凸贴图。
- en: Using the canvas as a bump map
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用画布作为凹凸贴图
- en: As we've seen earlier in this chapter, we can create a simple wrinkled texture
    with a bump map. The higher the intensity of a pixel in this map, the higher the
    wrinkling. Since a bump map is just a simple black-and-white image, nothing keeps
    us from creating this on a canvas and using that canvas as an input for the bump
    map.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，我们可以使用凹凸贴图创建一个简单的皱纹纹理。在这个地图中，像素的强度越高，皱纹越深。由于凹凸贴图只是一个简单的黑白图像，所以我们可以在画布上创建这个图像，并将该画布用作凹凸贴图的输入。
- en: 'In the following example, we use a canvas to generate a random grayscale image,
    and we use that image as an input for the bump map we apply to the cube. See the
    `09-canvas-texture-bumpmap.html` example. The following screenshot shows this
    example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用画布生成一个随机灰度图像，并将该图像用作我们应用于立方体的凹凸贴图的输入。请参见`09-canvas-texture-bumpmap.html`示例。以下截图显示了此示例：
- en: '![Using the canvas as a bump map](graphics/2215OS_10_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![使用画布作为凹凸贴图](graphics/2215OS_10_20.jpg)'
- en: 'The JavaScript code required for this is not that different from the previous
    example we explained. We need to create a canvas element and fill this canvas
    with some random noise. For the noise, we use **Perlin noise**. Perlin noise ([http://en.wikipedia.org/wiki/Perlin_noise](http://en.wikipedia.org/wiki/Perlin_noise))
    generates a very natural-looking random texture as you can see in the preceding
    screenshot. We use the Perlin noise function from [https://github.com/wwwtyro/perlin.js](https://github.com/wwwtyro/perlin.js)
    for this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要的JavaScript代码与我们之前解释的示例并没有太大不同。我们需要创建一个画布元素，并用一些随机噪声填充这个画布。对于噪声，我们使用**Perlin
    noise**。Perlin noise ([http://en.wikipedia.org/wiki/Perlin_noise](http://en.wikipedia.org/wiki/Perlin_noise))
    生成一个非常自然的随机纹理，正如您在前面的截图中所看到的。我们使用来自[https://github.com/wwwtyro/perlin.js](https://github.com/wwwtyro/perlin.js)的Perlin
    noise函数来实现这一点：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use the `perlin.noise` function to create a value from 0 to 1 based on the
    *x* and *y* coordinates of the canvas element. This value is used to draw a single
    pixel on the canvas element. Doing this for all the pixels creates the random
    map you can also see in the bottom-left corner of the previous screenshot. This
    map can then be easily used as a bump map. Here''s how the random map can be created:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`perlin.noise`函数根据画布元素的*x*和*y*坐标创建一个从0到1的值。这个值用于在画布元素上绘制一个单个像素。对所有像素执行此操作会创建一个随机地图，您也可以在上一张截图的左下角看到。然后可以轻松地将此地图用作凹凸贴图。以下是创建随机地图的方法：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this example, we've rendered Perlin noise using an HTML canvas element. Three.js
    also provides an alternative way to dynamically create a texture. The `THREE.ImageUtils`
    object has a `generateDataTexture` function, which you can use to create a `THREE.DataTexture`
    texture of a specific size. This texture contains `Uint8Array` in the `image.data`
    property, which you can use to directly set the RGB values of this texture.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用HTML画布元素渲染了Perlin噪声。Three.js还提供了一种动态创建纹理的替代方法。`THREE.ImageUtils`对象有一个`generateDataTexture`函数，你可以使用它来创建特定大小的`THREE.DataTexture`纹理。这个纹理包含在`image.data`属性中的`Uint8Array`，你可以直接使用它来设置这个纹理的RGB值。
- en: 'The final input we use for the texture is another HTML element: the HTML5 video
    element.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于纹理的最终输入是另一个HTML元素：HTML5视频元素。
- en: Using the output from a video as a texture
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视频输出作为纹理
- en: 'If you''ve read the previous paragraph on rendering to canvas, you might have
    thought about rendering video to canvas and using that as input for a texture.
    That is an option, but Three.js (through WebGL) already has direct support to
    use the HTML5 video element. Check out `11-video-texture.html`. Refer to the following
    screenshot for a still image of this example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过前面关于渲染到画布的段落，你可能会考虑将视频渲染到画布并将其用作纹理的输入。这是一个选择，但是Three.js（通过WebGL）已经直接支持使用HTML5视频元素。查看`11-video-texture.html`。参考以下截图，了解这个例子的静态图像：
- en: '![Using the output from a video as a texture](graphics/2215OS_10_21.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用视频输出作为纹理](graphics/2215OS_10_21.jpg)'
- en: 'Using video as input for a texture is, just like using the canvas element,
    very easy. First off, we need to have a video element to play the video:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视频作为纹理的输入，就像使用画布元素一样，非常容易。首先，我们需要有一个视频元素来播放视频：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This was just a basic HTML5 video element that we set to automatically play.
    Next, we can configure Three.js to use this video as an input for a texture, as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的HTML5视频元素，我们设置为自动播放。接下来，我们可以配置Three.js以将此视频用作纹理的输入，如下所示：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since our video isn''t square, we need to make sure we disable the mipmap generation
    on the material. We also set some simple high-performance filters as the material
    changes very often. All that is left to do now is create a mesh and set the texture.
    In this example, we''ve used `MeshFaceMaterial` together with `MeshBasicMaterial`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视频不是正方形的，我们需要确保在材质上禁用mipmap生成。我们还设置了一些简单的高性能滤镜，因为材质经常变化。现在剩下的就是创建一个网格并设置纹理。在这个例子中，我们使用了`MeshFaceMaterial`和`MeshBasicMaterial`：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All that is left to do is make sure that in our `render` loop, we update the
    texture, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是确保在我们的`render`循环中更新纹理，如下所示：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we just rendered the video to one side of the cube, but since
    this is a normal texture, we could do anything we want with it. We could, for
    instance, divide it along the sides of a cube using custom UV mapping, or we could
    even use video input as input for a bump map or a normal map.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是将视频渲染到立方体的一侧，但由于这是一个普通的纹理，我们可以随心所欲地使用它。例如，我们可以使用自定义UV映射沿着立方体的边缘分割它，或者甚至将视频输入用作凹凸贴图或法线贴图的输入。
- en: 'In Three.js version r69, a texture specifically for dealing with videos was
    introduced. This texture (`THREE.VideoTexture`) wraps the code you''ve seen in
    this section, and you can use the `THREE.VideoTexture` approach as an alternative.
    The following code fragment shows how to use `THREE.VideoTexture` to create a
    texture (you can see this in action by looking at the `11-video-texture.html`
    example):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js版本r69中，引入了一个专门用于处理视频的纹理。这个纹理（`THREE.VideoTexture`）包装了你在本节中看到的代码，你可以使用`THREE.VideoTexture`方法作为一种替代方法。以下代码片段显示了如何使用`THREE.VideoTexture`创建纹理（你可以通过查看`11-video-texture.html`示例来查看这个过程）：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: And so we end this chapter on textures. As you've seen, there are lots of different
    kinds of textures available in Three.js, each with their different uses. You can
    use any image in the PNG, JPG, GIF, TGA, DDS, or PVR format as a texture. Loading
    these images is done asynchronously, so remember to either use a rendering loop
    or add a callback when you load the texture. With textures, you can create great-looking
    objects from low-poly models and even add fake detailed depth using bump maps
    and normal maps. With Three.js, it is also easy to create dynamic textures using
    either the HTML5 canvas element or the video element. Just define a texture with
    these elements as the input and set the `needsUpdate` property to `true` whenever
    you want the texture to be updated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们结束了关于纹理的这一章。正如你所看到的，Three.js中有许多不同类型的纹理，每种都有不同的用途。你可以使用PNG、JPG、GIF、TGA、DDS或PVR格式的任何图像作为纹理。加载这些图像是异步进行的，所以记得要么使用渲染循环，要么在加载纹理时添加回调。使用纹理，你可以从低多边形模型创建出色的对象，甚至可以使用凹凸贴图和法线贴图添加虚假的详细深度。使用Three.js，还可以使用HTML5画布元素或视频元素轻松创建动态纹理。只需定义一个以这些元素为输入的纹理，并在需要更新纹理时将`needsUpdate`属性设置为`true`。
- en: With this chapter out of the way, we've pretty much covered all the important
    concepts of Three.js. We haven't, however, looked at an interesting feature Three.js
    offers—**postprocessing**. With postprocessing, you can add effects to your scene
    after it is rendered. You could, for instance, blur or colorize your scene or
    add a TV-like effect using scan lines. In the next chapter, we'll look at postprocessing
    and how you can apply it to your scene.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一章，我们基本上涵盖了Three.js的所有重要概念。然而，我们还没有看到Three.js提供的一个有趣的功能——**后期处理**。通过后期处理，你可以在场景渲染后添加效果。例如，你可以模糊或着色你的场景，或者使用扫描线添加类似电视的效果。在下一章中，我们将看看后期处理以及如何将其应用到你的场景中。

- en: Chapter 12. Adding Physics and Sounds to Your Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we'll look at Physijs, another library you can use to
    extend the basic functionality of Three.js. Physijs is a library that allows you
    to introduce physics into your 3D scene. By physics, we mean that your objects
    are subject to gravity, they can collide with each other, can be moved by applying
    impulse, and can be constrained in their movement through hinges and sliders.
    This library internally makes use of another well-known physics engine called
    **ammo.js**. Besides physics, we'll also look at how Three.js can help you with
    adding spatial sounds to your scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Physijs scene where your objects are subject to gravity and can collide
    with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how to change the friction and restitution (bounciness) of the objects
    in the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the various shapes supported by Physijs and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how to create compound shapes by combining simple shapes together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how a height field allows you to simulate a complex shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the movement of an object by applying a point, hinge, slider, and cone
    twist, and the 'degree of freedom' constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound sources to your scene whose sound volume and direction is based
    on their distance to the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first thing we will do is create a Three.js scene that can be used with
    Physijs. We'll do that in our first example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic Three.js scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up a Three.js scene for Physijs is very simple and only takes a couple
    of steps. The first thing we need to do is include the correct JavaScript file,
    which you can get from the GitHub repository at [http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/).
    Add the Physijs library to your HTML page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simulating a scene is rather processor intensive. If we run all the simulation
    computations on the render thread (since JavaScript is single threaded in nature),
    it will seriously affect the frame rate of our scene. To compensate for that,
    Physijs does its calculations in a background thread. This background thread is
    provided through the "web workers" specification that is implemented by most modern
    browsers. With this specification, you can run CPU-intensive tasks in a separate
    thread, thus not affecting the rendering. More information on web workers can
    be found at [http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/).
  prefs: []
  type: TYPE_NORMAL
- en: For Physijs, this means we have to configure the JavaScript file that contains
    this worker task and also tell Physijs where it can find the ammo.js file needed
    to simulate our scene. The reason we need to include the ammo.js file is that
    Physijs is a wrapper around ammo.js to make it easy to use. Ammo.js (which you
    can find at [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/))
    is the library that implements the physics engine; Physijs just provides an easy-to-use
    interface to this physics library. Since Physijs is just a wrapper, we can also
    use other physics engines together with Physijs. On the Physijs repository, you
    can also find a branch that uses Cannon.js, a different physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Physijs, we have to set the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first property points to the worker tasks we want to execute, and the second
    property points to the ammo.js library that is used internally. The next step
    we need to perform is create a scene. Physijs provides a wrapper around the Three.js
    normal scene, so in your code, you do the following to create a scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new scene where physics is applied, and we set the gravity. In
    this case, we set the gravity on the *y* axis to be `-10`. In other words, objects
    fall straight down. You can set, or change at runtime, the gravity for the various
    axes to any value you see fit, and the scene will respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start simulating the physics in the scene, we need to add some
    objects. For this, we can use the normal way Three.js specifies objects, but we
    have to wrap them inside a specific Physijs object so that they can be managed
    by the Physijs library, as you can see in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a simple `THREE.BoxGeometry` object. Instead of creating
    `THREE.Mesh`, we create `Physijs.BoxMesh`, which tells Physijs to treat the shape
    of the geometry as a box when simulating physics and detecting collisions. Physijs
    provides a number of meshes you can use for the various shapes. More information
    on the available shapes can be found later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `THREE.BoxMesh` has been added to the scene, we have all the ingredients
    for the first Physijs scene. All that is left to do is tell Physijs to simulate
    the physics and update the position and rotation of the objects in our scene.
    We can do this by calling the simulate method on the scene we just created. So,
    for this, we change our basic render loop to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And with that final step, by calling `scene.simulate()`, we have our basic setup
    for a Physijs scene. If we would run this example, though, we wouldn't see much.
    We would just see a single cube in the middle of the screen, which starts falling
    down as soon as the scene renders. So, let's look at a more complex example, where
    we'll simulate dominos falling down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''re going to create the following scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a basic Three.js scene](graphics/2215OS_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open the `01-basic-scene.html` example in your browser, you''ll see
    a set of domino stones that start falling down as soon as the scene is loaded.
    The first one will tip over the second one, and so on. The complete physics of
    this scene is managed by Physijs. The only thing we did to start this animation
    is tip over the first domino. Creating this scene is actually very easy and only
    takes a few steps, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a Physijs scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the ground area that holds the stones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the stones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip over the first stone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s skip this first step since we''ve already seen how to do this and go
    directly to the second step, where we define the sandbox that contains all the
    stones. This sandbox is constructed out of a couple of boxes that are grouped
    together. The following is the code required to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code isn't very complicated. First, we create a simple box that serves
    as the ground plane, and next we add a couple of borders to prevent objects falling
    off this ground plane. We add these borders to the ground object to create a compound
    object. This is an object that is treated by Physijs as a single object. There
    are a couple of other new things in this code that we'll explain in more depth
    in the following sections. The first one is `ground_material`, which we create.
    We use the `Physijs.createMaterial` function to create this material. This function
    wraps a standard Three.js material but allows us to set `friction` and `restitution`
    (bounciness) of the material. More on this can be found in the next section. Another
    new aspect is the final parameter we add to the `Physijs.BoxMesh` constructor.
    For all the `BoxMesh` objects we create in this section, we add `0` as the final
    parameter. With this parameter, we set the weight of the object. We do this to
    prevent the ground from being subject to the gravity in the scene so that it doesn't
    fall down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the ground, we can place the dominos. For this, we create
    simple `Three.BoxGeometry` instances that we wrap inside `BoxMesh` and place them
    at a specific position on top of the ground mesh, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We don't show the code where the position of each domino is calculated (see
    the `getPoints()` function in the source code of the example for this); this code
    just shows how the dominos are positioned. What you can see here is that we once
    again create `BoxMesh`, which wraps `THREE.BoxGeometry`. To make sure the dominos
    are aligned correctly, we use the `lookAt` function to set their correct rotation.
    If we don't do this, they'll all face the same way and won't fall down. We have
    to make sure that after we manually update the rotation (or the position) of a
    Physijs wrapped object, we tell Physijs that something has changed so that Physijs
    can update it's own internal representation of all the objects in the scene. For
    the rotation, we can do this with the internal `__dirtyRotation` property, and
    for the position, we set `__dirtyPosition` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all that is left to do is tip the first domino. We do this by just setting
    the rotation on the *x* axis to 0.2, which tips it slightly. The gravity in the
    scene will do the rest and completely tip over the first domino. Here''s how we
    tip the first domino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the first example, which already shows a lot of features from
    Physijs. If you want to play around with the gravity, you can change it through
    the menu in the top-right corner. The change to the gravity is applied when you
    push the **resetScene** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a basic Three.js scene](graphics/2215OS_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll have a closer look at how the Physijs material properties
    affect the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Material properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with an explanation of the example. When you open up the `02-material-properties.html`
    example, you''ll see an empty box somewhat similar to the previous example. This
    box is rotating up and down around its *x* axis. In the menu in the top-right
    corner, you have several sliders that can be used to change some of the material
    properties of Physijs. These properties apply to the cubes and spheres you can
    add with the **addCubes** and **addSpheres** buttons. When you press the **addSpheres**
    button, five spheres will be added to the scene, and when you press the **addCubes**
    button, five cubes will be added. The following is an example demonstrating friction
    and restitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Material properties](graphics/2215OS_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This example allows you to play around with the `restitution` (bounciness)
    and `friction` properties that you can set when you create a Physijs material.
    If, for example, you set **cubeFriction** all the way to `1` and add some cubes,
    you''ll see that, even though the ground is moving, the cubes barely move. If
    you set **cubeFriction** to **0**, you''ll notice the cubes sliding around as
    soon as the ground stops being level. The following screenshot shows that high
    friction allows cubes to resist gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Material properties](graphics/2215OS_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other property you can set in this example is the `restitution` property.
    The `restitution` property defines how much of the energy that an object possesses
    is restituted when it collides. In other words, high restitution creates a bouncy
    object, and low restitution results in an object that stops immediately when it
    hits another object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you use a physics engine, you normally don't have to worry about detecting
    collisions. The engine will take care of that. It is, however, sometimes very
    useful to be informed when a collision between two objects occurs. For instance,
    you might want to create a sound effect, or when creating a game, deduct a life.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Physijs, you can add an event listener to a Physijs mesh, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This way, you'll be informed whenever this mesh collides with another of the
    meshes handled by Physijs.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to demonstrate this is using spheres, setting the restitution to
    `1`, and clicking on the **addSpheres** button a couple of times. This will create
    a number of spheres that bounce everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, let''s look at a bit of code used in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code that gets executed when we add spheres to the scene. This
    time, we use a different Physijs mesh: `Physijs.SphereMesh`. We''re creating `THREE.SphereGeometry,`
    and the best match from the set of meshes provided is, logically, `Physijs.SphereMesh`
    (more on this in the next section). When we create `Physijs.SphereMesh`, we pass
    in our geometry and use `Physijs.createMaterial` to create a Physijs-specific
    material. We do this so that we can set `friction` and `restitution` for this
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we've seen `BoxMesh` and `SphereMesh`. In the next section, we'll
    explain and show the different types of meshes provided by Physijs that you can
    use to wrap your geometries.
  prefs: []
  type: TYPE_NORMAL
- en: Basic supported shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physijs provides a number of shapes you can use to wrap your geometries. In
    this section, we'll walk you through all the available Physijs meshes and demonstrate
    these meshes through an example. Remember that all you have to do to use these
    meshes is replace the `THREE.Mesh` constructor with one of these meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table provides an overview of the meshes that are available in
    Physijs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.PlaneMesh` | This mesh can be used to create a zero-thickness plane.
    You could also use `BoxMesh` for this together with `THREE.BoxGeometry` with low
    height. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.BoxMesh` | If you have geometries that look like cubes, use this
    mesh. For instance, this is a good match for `THREE.BoxGeometry`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.SphereMesh` | For sphere shapes, use this geometry. This geometry
    is a good match for `THREE.SphereGeometry`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.CylinderMesh` | With `THREE.Cylinder`, you can create various cylinder-like
    shapes. Physijs provides multiple meshes depending on the shape of the cylinder.
    `Physijs.CylinderMesh` should be used for a normal cylinder with the same top
    radius and bottom radius. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.ConeMesh` | If you specify the top radius as `0` and use a positive
    value for the bottom radius, you can use `THREE.Cylinder` to create a cone. If
    you want to apply physics to such an object, the best fit from Physijs is `ConeMesh`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.CapsuleMesh` | A capsule is just like `THREE.Cylinder`, but with
    a rounded top and a rounded bottom. We''ll show you how to create a capsule in
    Three.js later on in this section. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.ConvexMesh` | `hysijs.ConvexMesh` is a rough shape you can use for
    more complex objects. It creates a convex (just like `THREE.ConvexGeometry`) to
    approximate the shape of complex objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.ConcaveMesh` | While `ConvexMesh` is a rough shape, `ConcaveMesh`
    is a more detailed representation of your complex geometry. Note that the performance
    penalty of using `ConcaveMesh` is very high. Usually, it is better to either create
    separate geometries with their own specific Physijs meshes or group them together
    (as we do with the floors shown in the previous examples). |'
  prefs: []
  type: TYPE_TB
- en: '| `Physijs.HeightfieldMesh` | This mesh is a very specialized one. With this
    mesh, you can create a height field from `THREE.PlaneGeometry`. Look at the `03-shapes.html`
    example for this mesh. |'
  prefs: []
  type: TYPE_TB
- en: We'll quickly walk you through these shapes using `03-shapes.html` as a reference.
    We won't explain `Physijs.ConcaveMesh` any further since its usage is very limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the example, we''ll first have a quick look at `Physijs.PlaneMesh`.
    This mesh creates a simple plane based on `THREE.PlaneGeometry`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, you can see that we just pass in a simple `THREE.PlaneGeometry`
    to create this mesh. If you add this to the scene, you''ll notice something strange.
    The mesh you just created doesn''t respond to gravity. The reason is that `Physijs.PlaneMesh`
    has a fixed weight of `0`, so it won''t respond to gravity or be moved by collisions
    with other objects. Besides this mesh, all the other meshes respond to gravity
    and collisions, as you''d expect. The following screenshot shows a height field
    on which the various supported shapes can be dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic supported shapes](graphics/2215OS_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous image shows the `03-shapes.html` example. In this example, we've
    created a random height field (more on that later) and have a menu in the top-right
    corner that you can use to drop objects of various shapes. If you play around
    with this example, you'll see how different shapes respond differently to the
    height map and in collisions with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the construction of some of these shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing special here; we create a geometry and use the best matching
    mesh from Physijs to create the object we add to the scene. However, what if we
    want to use `Physijs.CapsuleMesh`? Three.js doesn''t contain a capsule-like geometry,
    so we have to create one ourselves. Here''s the code for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Physijs.CapsuleMesh` looks like a cylinder but has a rounded top and bottom.
    We can easily recreate this in Three.js by creating a cylinder (`cyl`) and two
    spheres (`top` and `bot`) and merging them together using the `merge()` function.
    The following screenshot shows a number of capsules rolling down the height map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic supported shapes](graphics/2215OS_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we look at the height map, let''s look at the last of the shapes you
    can add to this example, `Physijs.ConvexMesh`. A convex is the minimal shape that
    wraps all the vertices of a geometry. The resulting shape will only have angles
    smaller than 180 degrees. You would use this mesh for complex shapes such as torus
    knots, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, for physics simulation and collisions, the convex of the torus
    knot will be used. This is a very good way to apply physics and detect collisions
    for complex objects, while still minimizing the performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last mesh from Physijs to discuss is `Physijs.HeightMap`. The following
    screenshot shows a height map created with Physijs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic supported shapes](graphics/2215OS_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With a height map, you can very easily create a terrain that contains bumps
    and shallows. Using `Physijs.Heightmap`, we make sure all the objects respond
    correctly to the height differences of this terrain. Let''s look at the code required
    to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, we take a couple of steps to create the height map you
    can see in the example. First off, we create the Physijs material and a simple
    `PlaneGeometry` object. To create a bumpy terrain from `PlaneGeometry`, we walk
    through each of the vertices of this geometry and randomly set the `z` property.
    For this, we use a Perlin noise generator to create a bump map just as we used
    in the *Using the canvas as a bump map* section of [Chapter 10](ch10.html "Chapter 10. Loading
    and Working with Textures"), *Loading and Working with Textures*. We need to call
    `computeFaceNormals` and `computeVertexNormals` to make sure the texture, lighting,
    and shadows are rendered correctly. At this point, we have `PlaneGeometry`, which
    contains the correct height information. With `PlaneGeometry`, we can create `Physijs.HeightFieldMesh`.
    The last two parameters for the constructor take the number of horizontal and
    vertical segments of `PlaneGeometry` and should match the last two properties
    used to construct `PlaneGeometry`. Finally, we rotate `HeightFieldMesh` to the
    position we want and add it to the scene. All other Physijs objects will now interact
    correctly with this height map.
  prefs: []
  type: TYPE_NORMAL
- en: Using constraints to limit movement of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we''ve seen some basic physics in action. We''ve seen how the various
    shapes respond to gravity, friction, and restitution and how they affect collisions.
    Physijs also provides advanced constructs that allow you to limit the movement
    of your objects. In Physijs, these objects are called constraints. The following
    table gives an overview of the constraints that are available in Physijs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PointConstraint` | This allows you to fix the position of one object to
    the position of another object. If one object moves, the other will move with
    it, keeping the distance and orientation between them the same. |'
  prefs: []
  type: TYPE_TB
- en: '| `HingeConstraint` | `HingeConstraint` allows you to limit the movement of
    an object as if it were on a hinge, such as a door. |'
  prefs: []
  type: TYPE_TB
- en: '| `SliderConstraint` | This constraint, as the name implies, allows you to
    limit the movement of an object to a single axis, for instance, a sliding door.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ConeTwistConstraint` | With this constraint, you can limit the rotation
    and the movement of one object to another. This constraint functions like a ball-and-socket
    joint, for instance, the way your arm moves in your shoulder socket. |'
  prefs: []
  type: TYPE_TB
- en: '| `DOFConstraint` | `DOFConstraint` allows you to specify the limit of movement
    around any of the three axes, and it allows you to set the minimum and maximum
    angle that is allowed. This is the most versatile of the constraints available.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The easiest way to understand these constraints is to see them in action and
    play around with them. For this, we''ve provided an example where all these constraints
    are used together, `04-physijs-constraints.js`. The following screenshot shows
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using constraints to limit movement of objects](graphics/2215OS_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on this example, we'll walk you through four of these five constraints.
    For `DOFConstraint`, we've created a separate example. The first one we look at
    is `PointConstraint`.
  prefs: []
  type: TYPE_NORMAL
- en: Using PointConstraint to limit movement between two points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you open the example, you'll see two red spheres. These two spheres are connected
    to each other using `PointConstraint`. With the menu in the top-left corner, you
    can move the green sliders around. As soon as one of the sliders hits one of the
    red spheres, you'll see that both of them move in the same manner, and they keep
    the distance between them the same, while still complying with weight, gravity,
    friction, and other aspects of physics.
  prefs: []
  type: TYPE_NORMAL
- en: '`PointConstraint` in this example was created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that we create objects using a Physijs-specific mesh (`SphereMesh`
    in this case) and add them to the scene. We use the `Physijs.PointConstraint`
    constructor to create the constraint. This constraint takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two arguments define which objects you want to connect to each other.
    In this case, we connect the two spheres to one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument defines to what position the constraint is bound. For instance,
    if you bind the first object to a very large object, you can set this position,
    for instance, to the right-hand side of that object. Usually, if you just want
    to connect two objects together, a good choice is to just set it to the position
    of the second object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't want to fix an object to another one, but to a static position
    in the scene, you can omit the second parameter. In that case, the first object
    keeps the same distance to the position you specified, while complying with gravity
    and other aspects of physics, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Once the constraint is created, we can enable it by adding it to the scene with
    the `addConstraint` function. As you start experimenting with constraints, you'll
    likely run into some strange issues. To make debugging easier, you can pass in
    `true` to the `addConstraint` function. If you do this, the constraint point and
    orientation is shown in the scene. This can help you get the rotation and position
    of your constraint correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating door-like constraints with HingeConstraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HingeConstraint`, as the name implies, allows you to create an object that
    behaves like a hinge. It rotates around a specific axis, limiting the movement
    to a specified angle. In our example, `HingeConstraint` is shown with two white
    flippers at the center of the scene. These flippers are constrained to the small,
    brown cubes and can rotate around them. If you want to play around with these
    hinges, you can enable them by checking the `enableMotor` box in the **hinge**
    menu. This will accelerate the flippers to the velocity specified in the **general**
    menu. A negative velocity will move the hinges down, and a positive velocity will
    move them up. The following screenshot shows the hinges in the up position and
    in the down position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating door-like constraints with HingeConstraint](graphics/2215OS_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at how we created one of these flippers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This constraint takes four parameters. Let''s look at each one in a bit more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the white cube that serves
    as the flipper. This is the object that is constrained in its movements. |'
  prefs: []
  type: TYPE_TB
- en: '| `mesh_b` | The second object defines to which object `mesh_a` is constrained.
    In this example, `mesh_a` is constrained to the small, brown cube. If we move
    this mesh around, `mesh_a` would follow it around, still keeping `HingeConstraint`
    in place. You''ll see that all constraints have this option. You could, for instance,
    use this if you''ve created a car that moves around and want to create a constraint
    for opening a door. If this second parameter is omitted, the hinge will be constrained
    to the scene (and never be able to move around). |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | This is the point where the constraint is applied. In this case,
    it''s the hinge point around which `mesh_a` rotates. If you''ve specified `mesh_b`,
    this hinge point will move around with the position and rotation of `mesh_b`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | This is the axis around which the hinge should rotate. In this example,
    we''ve set the hinge horizontally (0,1,0). |'
  prefs: []
  type: TYPE_TB
- en: Adding `HingeConstraint` to the scene works in the same way as we've seen with
    `PointConstraint`. You use the `addConstraint` method, specify the constraint
    to add, and optionally add `true` to show the exact location and orientation of
    the constraint for debugging purposes. For `HingeConstraint`, however, we also
    need to define the range of movement that is allowed. We do this with the `setLimits`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes the following four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `low` | This is the minimum angle, in radians, of motion. |'
  prefs: []
  type: TYPE_TB
- en: '| `high` | This is the maximum angle, in radians, of motion. |'
  prefs: []
  type: TYPE_TB
- en: '| `bias_factor` | This property defines the rate with which the constraint
    corrects itself after an error in position. For instance, when the hinge is pushed
    out of its constraints by a different object, it will move itself to its correct
    position. The higher this value, the faster it will correct its position. It is
    best to keep it below `0.5`. |'
  prefs: []
  type: TYPE_TB
- en: '| `relaxation_factor` | This defines the rate at which the velocity is changed
    by the constraint. If this is set to a high value, the object will bounce when
    it reaches its minimum or maximum angle of motion. |'
  prefs: []
  type: TYPE_TB
- en: 'You can change these properties at runtime if you want. If you add `HingeConstraint`
    with these properties, you won''t see much movement. The mesh will only move when
    hit by another object or based on gravity. This constraint, as with many others,
    however, can also be moved by an internal motor. This is what you see when you
    check the `enableMotor` box in the **hinge** submenu from our example. The following
    code is used to enable this motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will speed up the mesh (in our case, the flipper) to the specified velocity
    using the acceleration provided. If we want to move the flipper the other way,
    we just specify a negative velocity. If we didn''t have any limits, this would
    cause our flipper to rotate as long as our motor kept running. To disable a motor,
    we can just call the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now the mesh will slow down based on friction, collisions, gravity, and other
    aspects of physics.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting movement to a single axis with SliderConstraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next constraint is `SliderConstraint`. With this constraint, you can limit
    the movement of an object to any one of its axes. The green sliders in the `04-constraints.html`
    example can be controlled from the **sliders** submenu. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Limiting movement to a single axis with SliderConstraint](graphics/2215OS_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the **SlidersLeft** button, the sliders will move to the left-hand side
    (their lower limit), and with the **SlidersRight** button, they will move to the
    right-hand side (their upper limit). Creating these constraints from code is very
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the code, this constraint takes three arguments (or four
    if you want to constrain an object to another object). The following table explains
    the arguments for this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the green cube that serves
    as the slider. This is the object that will be constrained in its movements. |'
  prefs: []
  type: TYPE_TB
- en: '| `mesh_b` | This is the second object, which defines to which object `mesh_a`
    is constrained. This is an optional argument and omitted in this example. If omitted,
    the mesh will be constrained to the scene. If it is specified, the slider will
    move around when this mesh moves around or when its orientation changes. |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | This is the point where the constraint is applied. This is especially
    important when you constrain `mesh_a` to `mesh_b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | This is the axis on which `mesh_a` will slide. Note that this is
    relative to the orientation of `mesh_b` if it is specified. In the current version
    of Physijs, there seems to be a strange offset to this axis when using a linear
    motor with linear limits. The following works for this version if you want to
    slide along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *x* axis: `new` `THREE.Vector3(0,1,0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *y* axis: `new` `THREE.Vector3(0,0,Math.PI/2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *z* axis: `new` `THREE.Vector3(Math.PI/2,0,0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve created the constraint and added it to the scene using `scene.addConstraint`,
    you can set the `constraint.setLimits(-10,` `10,` `0,` `0)` limits for this constraint
    to specify how far the slider may slide. You can set the following limits on `SliderConstraint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `linear_lower` | This is the lower linear limit of the object |'
  prefs: []
  type: TYPE_TB
- en: '| `linear_upper` | This is the upper linear limit of the object |'
  prefs: []
  type: TYPE_TB
- en: '| `angular_lower` | This is the lower angular limit of the object |'
  prefs: []
  type: TYPE_TB
- en: '| `angular_higher` | This is the upper angular limit of the object |'
  prefs: []
  type: TYPE_TB
- en: Finally, you can set the restitution (the bounce) that'll occur when you hit
    one of these limits. You do this with `constraint.setRestitution(res_linear,`
    `res_angular)`, where the first parameter sets the amount of bounce when you hit
    the linear limit and the second one sets the amount of bounce when you hit the
    angular limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the complete constraint has been configured, and we can wait until collisions
    occur that slide the object around or use a motor. For `SlideConstraint`, we have
    two options: we can use an angular motor to accelerate along the axis we specified,
    complying with the angular limits we set, or use a linear motor to accelerate
    along the axis we specified, complying with the linear limits. In this example,
    we used a linear motor. For using an angular motor, take a look at `DOFConstraint`,
    which is explained later on in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `ConeTwistConstraint`, it is possible to create a constraint where the
    movement is limited to a set of angles. We can specify what the minimum and maximum
    angle is from one object to the other for the *x*, *y*, and *z* axes. The following
    screenshot shows that `ConeTwistConstraint` allows you to move an object around
    a reference at certain angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](graphics/2215OS_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The easiest way to understand `ConeTwistConstraint` is by looking at the code
    required to create one. The code required to accomplish this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this piece of JavaScript, you''ll probably already recognize a number of
    concepts we discussed earlier. We start with creating the objects that we connect
    to each other with the constraint: `objectOne` (a sphere) and `objectTwo` (a box).
    We position these objects so that `objectTwo` hangs below `objectOne`. Now we
    can create `ConeTwistConstraint`. The arguments this constraint takes aren''t
    anything new if you''ve already looked at the other constraints. The first parameter
    is the object to constrain, the second parameter is the object to which the first
    object is constrained, and the last parameter is the location where the constraint
    is constructed (in this case, it''s the point around which `objectOne` rotates).
    After adding the constraint to the scene, we can set its limits with the `setLimit`
    function. This function takes three radian values that specify the maximum angle
    for each of the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with most of the other constraints, we can move `objectOne` using the
    motor provided by the constraint. For `ConeTwistConstraint`, we set `MaxMotorImpulse`
    (how much force the motor can apply), and we set the target angles the motor should
    move `objectOne` to. In this example, we move it to its resting position directly
    below the sphere. You can play around with this example, as shown in the following
    screenshot, by setting this target value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](graphics/2215OS_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last constraint we'll look at is also the most versatile—`DOFConstraint`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating detailed control with DOFConstraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DOFConstraint`, also called the degree of freedom constraint, allows you to
    exactly control an object''s linear and angular movement. We''ll show how to use
    this constraint by creating an example where you can drive around a simple, car-like
    shape. This shape consists of a single rectangle that serves as the body and four
    spheres that serve as the wheels. Let''s start by creating the wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this piece of code, we just created a simple `CylinderGeometry` and `CylinderMesh`
    object, which can be used as the wheels for our car. The following screenshot
    depicts the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating detailed control with DOFConstraint](graphics/2215OS_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to create the body of the car and add everything to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Until now, we just created the separate components that will have to make up
    our car. To tie everything together, we''re going to create constraints. Each
    wheel will be constrained to `body`. The constraints are created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each wheel (the first argument) has it''s own constraint, and the position
    where it is attached to the car (the second argument) is specified with the last
    argument. If we ran with this configuration, we''d see that the four wheels hold
    up the body of the car. We need to do two more things to get the car moving: we
    need to set up the constraints for the wheels (along which axis they can move),
    and we need to configure the correct motors. First, we set up the constraints
    for the two front wheels; what we want for these front wheels is just to be able
    to rotate along the *z* axis so that they can power the car, and they shouldn''t
    be allowed to move along the other axes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code required to accomplish this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this might seem weird. By setting the lower and upper limits
    to the same value, we make sure that no rotation is possible in the specified
    direction. This would also mean that the wheels can't rotate around their *z*
    axis. The reason we specify it like this is that when you enable a motor for a
    specific axis, these limits are ignored. So setting limits on the *z* axis at
    this point doesn't have any effect on our front wheels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to steer with our rear wheels, and to make sure they don''t fall
    over, we need to fix the *x* axis. With the following code, we fix the *x* axis
    (set upper and lower limits to `0`), fix the *y* axis so that these wheels are
    already initially turned, and disable any limit on the *z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to disable the limits, we have to set the lower limit of that
    specific axis higher than the upper limit. This will allow free rotation around
    that axis. If we don't set this for the *z* axis, these two wheels will just be
    dragged along. In this case, they'll turn together with the other wheels because
    of the friction with the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left to do is set up the motors for the front wheels, which can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are three axes we can create a motor for, we need to specify the
    axis the motor works on: 0 is the *x* axis, 1 is the *y* axis, and 2 is the *z*
    axis. The second and third arguments define the angular limits for the motor.
    Here, we once again set the lower limit (`0.1`) higher than the upper limit (`0`)
    to allow free rotation. The third argument specifies the velocity we want to reach,
    and the last argument specifies the force this motor can apply. If this last one
    is too little, the car won''t move; if it''s too high, the rear wheels will lift
    off from the ground.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable them with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open up the `05-dof-constraint.html` example, you can play around with
    the various constraints and motors and drive the car around. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating detailed control with DOFConstraint](graphics/2215OS_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll look at the last subject we'll discuss in this book,
    and that is how to add sounds to your Three.js scene.
  prefs: []
  type: TYPE_NORMAL
- en: Add sound sources to your scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the subjects discussed until now, we have a lot of the ingredients in
    place to create beautiful scenes, games, and other 3D visualizations. What we
    haven''t shown, however, is how to add sounds to your Three.js scene. In this
    section, we''ll look at two Three.js objects that allow you to add sources of
    sound to your scene. This is especially interesting since these sound sources
    respond to the position of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: The distance between the sound source and the camera determines the volume of
    the sound source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The positions to the left-hand side and the right-hand side of the camera determine
    the sound volume of the left-hand side speaker and the right-hand side speaker,
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to explain this is to see this in action. Open up the `06-audio.html`
    example in your browser, and you''ll see three cubes with pictures of animals.
    The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Add sound sources to your scene](graphics/2215OS_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example uses the first-person controls we saw in [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*,
    so you can use the arrow keys in combination with the mouse to move around the
    scene. What you'll see is that the closer you move to a specific cube, the louder
    that specific animal will sound. If you position the camera between the dog and
    the cow, you'll hear the cow from the right-hand side and the dog from the left-hand
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we used a specific helper, `THREE.GridHelper`, from Three.js
    to create the grid beneath the cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To create a grid, you need to specify the size of the grid (500 in this case)
    and the size of the individual grid elements (we used 10 here). If you want, you
    can also set the colors of the horizontal lines by specifying the `color1` and
    `color2` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accomplishing this only takes a small amount of code. The first thing we need
    to do is define `THREE.AudioListener` and add it to `THREE.PerspectiveCamera`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create `THREE.Mesh` and add a `THREE.Audio` object to that
    mesh, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code snippet, we first create a standard `THREE.Mesh`
    instance. Next, we create a `THREE.Audio` object, which we connect to the `THREE.AudioListener`
    object we created earlier. Finally, we add the `THREE.Audio` object to the mesh
    we created and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of properties we can set on the `THREE.Audio` object to
    configure its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load`: This allows us to load an audio file to be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRefDistance`: This determines the distance from the object from where the
    sound will be reduced in volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLoop`: By default, a sound is played once. By setting this property to
    `true`, the sound is looped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRolloffFactor`: This determines how quickly the volume decreases as you
    move away from the sound source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, Three.js uses the Web Audio API ([http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/))
    to play the sound and determine the correct volume. Not all browsers support this
    specification. The best support currently is from Chrome and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, we explored how you can extend the basic 3D functionality
    from Three.js by adding physics. For this, we used the Physijs library, which
    allows you to add gravity, collisions, constraints, and much more. We also showed
    how you can add positional sound to your scene using the `THREE.Audio` and `THREE.AudioListener`
    objects. With those subjects, we've reached the end of this book on Three.js.
    In these chapters, we covered a lot of different subjects and explored pretty
    much everything Three.js has to offer. In the first couple of chapters, we explained
    the core concepts and ideas behind Three.js; after that, we looked at the available
    lights and how materials affect how an object is rendered. After the basics, we
    explored the various geometries Three.js has to offer and how you can combine
    geometries to create new ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the book, we looked at a few more advanced subjects. You
    learned how to create particle systems, how to load models from external sources,
    and how to create animations. Finally, in these last couple of chapters, we looked
    at the advanced textures you can use in skinning and the postprocessing effects
    that can be applied after the scene is rendered. We end the book with this chapter
    on physics, which, besides explaining how you can add physics to your Three.js
    scene, also shows the active community of projects surrounding Three.js that you
    can use to add even more functionality to an already great library.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you've enjoyed reading this book and playing around with the examples
    as much as I have writing it!
  prefs: []
  type: TYPE_NORMAL

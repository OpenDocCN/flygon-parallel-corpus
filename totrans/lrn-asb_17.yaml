- en: Next Steps with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss how Ansible can be integrated into your day-to-day
    workflows, from continuous integration tools to monitoring tools and troubleshooting.
    We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to integrate Ansible with services such as Slack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can use Ansible to troubleshoot problems when they occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive straight in and look at how we can hook our playbooks into third-party
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with third-party services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you may be the one running the playbooks, you may keep a log of your
    playbook run or keep other members of your team or even other departments up to
    date with the results of the playbook run. Ansible ships with several core modules
    that allow you to work with third-party services to provide real-time notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slack has very quickly become the go-to choice for team-based collaboration
    services for various departments in IT services. Not only does it support third-party
    applications via its App Directory, but it also has a powerful API that you can
    use to bring your tools into the chat rooms provided by Slack.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to look at the example in this section, the full playbook, which
    can be found in the `Chapter17/slack` folder in the GitHub repository. I have
    taken the playbook from [Chapter 9](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml),
    *Building Out a Cloud Network*, where we created a VPC in AWS, and I have adapted
    it to use the `slack` Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use the Slack module in our Playbook, we need an access token
    to request one login to your Slack workspace; you can sign up for a workspace
    for free at [https://slack.com/](https://slack.com/) if you don't already have
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are logged into your workspace, either using the web client or desktop
    application, select the Manage apps option from the Administration menu, as seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1f3b335-5823-4712-bdea-36fa6db8418b.png)'
  prefs: []
  type: TYPE_IMG
- en: This will open your browser and take you to the App Directory for your workspace;
    from here, search for `Incoming WebHooks` and then click on Add Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the configuration is to choose which channel you would like
    the incoming Webhook to post messages to. I selected the general channel—once
    selected, you will be taken to a page that gives you a Webhook URL; make sure
    that you make a note of this URL as we will need it shortly. At the bottom of
    the page, you have the option to customize your Webhook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Integration Settings at the bottom of the page, I entered the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Post to Channel: I left it as #general'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webhook URL: This is prepopulated for you; you also have the choice of regenerating
    the URL here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Descriptive Label: I entered `Ansible` here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customize Name: I entered `Ansible` here as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customize Icon: I left this as it was'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the preceding details had been filled in, I clicked on the Save Settings
    button; this left me with a single incoming Webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76ce0142-b8e1-4210-bfe2-85b7d536d0d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned already, I also made a note of the Webhook URL; for me, it was:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://hooks.slack.com/services/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`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything, we need to be configured on the Slack side to be
    able to start to send messages to our users using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am only going to cover the updating of the tasks for a single role here,
    and it is the role that creates the VPC. The first change I made was to add a
    few lines to the `group_vars/common.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I added the following three nested variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`token`: This is taken from the Webhook URL; as you can see, I entered everything
    after `https://hooks.slack.com/services/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: We can override the username through which the updates will be
    posted, as I just kept it as Ansible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon`: This is the avatar that will be displayed as part of our post'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you remember the VPC role from before, you''ll recall that it contained
    a single task that used the `ec2_vpc_net` module to create a VPC. Now, we want
    to introduce Slack notifications, and to be able to provide our users with feedback.
    So, first of all, let''s send a notification to say that we are checking whether
    the VPC exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding task, we are sending a message that, in our
    case, will read `Checking for VPC called ''VPC-Slack''`, along with `token`, `username`,
    and `icon`. The next task in the role is the one from the original role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one of two things would have happened: a VPC called `VPC-Slack` would
    have been created, or Ansible would have gathered information on an already-existing
    VPC called `VPC-Slack`. When we send the message to our users, it should change
    depending upon what Ansible did. The following task sends a message informing
    our users that a new VPC has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that I only run this task when the `vpc_info` variable I registered is
    marked as changed. Also, I pass the ID of the VPC as part of the message. If `vpc_info`
    didn''t register any changes, then the preceding task will be skipped; the following
    task will run instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how I am changing the wording and also how it is only being called when
    there is no change. I went through the rest of the roles, adding tasks to send
    notifications to Slack using the same logic as in the preceding code; as mentioned,
    you can find all the additions in the `Chapter17/slack` folder in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Running the playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running the playbook, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I received the following notifications from Slack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0367dde3-92bd-456f-a67c-c06edc828a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a lot of the messages are talking about services within the
    VPC being created. Rerunning the playbook immediately after returns the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0174ed9-8e7a-4925-928f-f7c13b3d1277.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, the messages are talking about finding existing services and returning
    the IDs. Slack is just one service. Let's now take a brief look at a few more
    of the services you can interact with from your Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slack is not the only service that Ansible can interact with; here are some
    more that you may want to use in your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Campfire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Campfire is a chat service built into Basecamp; you can use this module to
    send updates to your project stakeholders directly from Ansible, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cisco Webex Teams (Cisco Spark)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cisco Webex Teams, or Cisco Spark as it was formally known, is the collaboration
    service from Cisco that provides your teams with virtual meeting spaces, messages,
    and video calling. Also, it has a rich API that Ansible can be configured to interact
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: CA Flowdock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CA Flowdock is a messaging service, which has been designed from the ground
    up to integrate with developer-focused services, such as GitHub, Bitbucket, Jira,
    Jenkins, and Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hipchat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hipchat is the group-messaging service provided by Atlassian; it has tight
    integration with the rest of the Atlassian family of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This service shouldn''t need any introduction; Ansible can be configured to
    send emails using all sorts of configuration. The following example shows an email
    being sent through an external SMTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Mattermost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mattermost is an open source alternative to proprietary services like the ones
    we have covered elsewhere in the list (for example, Slack, Cisco Webex Teams,
    and Hipchat):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Say
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most modern computers come with some level of voice synthesis built in; using
    this module, you can have Ansible verbally inform you of the status of your playbook
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ServiceNow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ServiceNow is the enterprise-grade IT service management Software as a service
    product provided by ServiceNow, Inc. Using the `snow_record` module, your playbook
    can open incidents within your ServiceNow installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you ship the log files from your hosts, then you may want to send the results
    of the playbook run to your hosts syslog so that it is shipped to your central
    logging service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Twilio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use your Twilio account to send an SMS message directly from your Ansible playbook,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary of third-party services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the takeaways I hope you get from this book is that automation is great—it
    is not only a real-time saver, but using tools like the ones we covered in the
    previous chapter, Ansible Tower and Ansible AWX, can enable people who are not
    sys-admins or developers to execute their playbooks from a friendly web interface.
  prefs: []
  type: TYPE_NORMAL
- en: The modules we have covered in this section allow you take your automation to
    the next level by not only allowing you to record the results, but to also automatically
    do some housekeeping during your playbook run and have it notify your users itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say, for example, you need to deploy a new configuration to your server.
    Your service desk raises a change for you to action the work within your ServiceNow
    installation. Your playbook could be written in such a way that before the change
    is actioned, it uses the `fetch` module to copy the configuration file to your
    Ansible Controller. The playbook could then use the `snow_record` module attach
    a copy of the existing configuration file to the change request, proceed to make
    the changes, and then automatically update the change request with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find details on the services mentioned in this part of the chapter
    at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slack**: [https://slack.com/](https://slack.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Campfire**: [https://basecamp.com/](https://basecamp.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cisco Webex Teams (Cisco Spark)**: [https://www.webex.com/products/teams/](https://www.webex.com/products/teams/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CA Flowdock**: [https://www.flowdock.com/](https://www.flowdock.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mattermost**: [https://mattermost.com/](https://mattermost.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceNow**: [https://www.servicenow.com/](https://www.servicenow.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twilio**: [https://twilio.com/](https://twilio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible playbook debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible has a debugger built in. Let''s take a look at how you can build this
    into your playbook by creating a simple playbook with an error. As we have just
    mentioned it, we are going to write a playbook that uses the `say` module. The
    playbook itself looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to point out: the first being the mistake. As you can
    see, we are defining a variable named `message`, but when we come to use it the
    task, I have made a typo and entered `massage` instead. Luckily, as I am developing
    the playbook, I have instructed Ansible to drop to the interactive debugger whenever
    a task fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run the playbook and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first problem is that we are not passing a host inventory file, so there
    will be warnings that only the localhost is available; this is fine, as we want
    to run the `say` module only on our Ansible Controller anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, Ansible runs the play itself; this should result in a fatal error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, the playbook run will stop, and you will be returned to your shell;
    however, because we have instructed Ansible to drop into the interactive debugger,
    we now see the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can start to look into the problem a little more; for example,
    we can review the error by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you hit the *Enter* key, the results of the failed task will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the variables used in the task by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the two arguments we are using in the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the variables that are available to the task using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noted that we instructed Ansible to execute the setup module as
    part of the playbook run; that is to keep this list of available variables to
    a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is a lot of information there about the environment our
    playbook is being executed on. In the list of variables, you will notice that
    two of them are prefixed with a `u`: they are `voice` and `message`. We can find
    out more about these by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the contents of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that we are passing a misspelt variable to the `msg` argument, so we
    make some changes on the fly and continue the playbook run. To do this, we are
    going to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update the argument to use the correct variable meaning, so that
    we can rerun the task by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will immediately rerun the task with the correct argument and, with any
    luck, you should hear *The task has completed, and all is well*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, because we only have a single task,
    the playbook completed. If we had more, then it would carry on from where it left
    off. You can now update your playbook with the correct spelling and proceed with
    the rest of your day.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we wanted to, we could have typed either `continue` or `quit` to proceed
    or stop respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of the Ansible debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible debugger is an extremely useful option to enable when you are working
    on creating large playbooks—for example, imagine that you have a playbook that
    takes about 20 minutes to run, but there is an error somewhere toward the end,
    say, 15 minutes after you first run the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Having Ansible drop into the interactive debugger shell not only means you can
    see exactly what is and isn't defined, but it also means that you don't have to
    blindly make changes to your playbook and then wait another 15 minutes to see
    whether those changes resolved whatever was causing the fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we finish the chapter, and also the book, I thought I would give a few
    examples of how I am using Ansible and interacting with Ansible: the first is
    interacting with Ansible using chat.'
  prefs: []
  type: TYPE_NORMAL
- en: The chat example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few months ago, I needed to set up a demo to show automation working—however,
    I needed to be able to show the demo on my laptop or phone, which meant that I
    couldn't assume I had access to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The demo I came up with ended up using Slack and a few other tools that we
    haven''t covered in this book, namely Hubot and Jenkins; before I go into any
    details, let''s quickly have a look at the output of the demo running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7fb0ae5-d86c-4d81-a9b2-b64a66d6dcad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding output, I asked the following in a Slack
    channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '*@bot give me a linux server*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This then triggered an Ansible playbook run, which launched an instance in
    AWS and returned information on the instance once the playbook had confirmed that
    the server was available on the network. I also configured it to remove all running
    instances by asking the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*@bot terminate all servers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this runs another playbook, and this time, returns an animated
    GIF once the instance has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2171890b-ee00-4138-adee-d95714316cab.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what did I use for this? As already mentioned, for a start, I used Hubot.
    Hubot is an open source extendable chatbot developed by GitHub. It was configured
    using the `hubot-slack` plugin in my Slack channel, and it listened out for any
    commands it was given.
  prefs: []
  type: TYPE_NORMAL
- en: I used the `hubot-alias` plugin to define an alias that translated *@bot give
    me a linux server* into *build awslaunch OS=linux*; this used the`hubot-yardmaster`
    plugin to trigger to a build in my Jenkins installation.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is an open source automation server, used mostly for continuous integration
    and also continuous delivery—it too has a plugin architecture. Using the Jenkins
    Ansible plugin and also the Jenkins Git  plugin, I was able to pull the playbook
    and roles used to launch the AWS instance to my Jenkins server and then have Jenkins
    run the playbook for me—the playbook itself wasn't too dissimilar from the playbook
    we worked through in [Chapter 9](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml),
    *Building Out a Cloud Network*, and [Chapter 10](56e8175f-d1a8-4b63-ad3f-fe94ff55135e.xhtml),
    *Highly Available Cloud Deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook had a little logic built into it that limited the number of instances
    that could be launched, randomized the name of the instance that it was launching,
    and also displayed a random GIF from a list of several options—all of this information,
    along with details of the instance and the AMI, were all passed to the user via
    the Ansible Slack module to give the impression that the playbook was actually
    doing more than it was.
  prefs: []
  type: TYPE_NORMAL
- en: In the two preceding examples, the bot user is Hubot, and Jenkins is actually
    the feedback from the playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: Automated deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another example—I recently worked with several developers who needed a way to
    automatically deploy their code to both their development and staging servers.
    Using a combination of Docker, GitHub, Jenkins, and Ansible AWX, I was able to
    provide the developers with a workflow that was triggered every time they pushed
    code to either the development or staging branches of their repository on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, I deployed the code on their own Jenkins server, using Ansible
    to deploy Jenkins in a container, and also deployed AWX using Docker on the same
    server. Then, using the **Jenkins GitHub** plugin, I connected the Jenkins projects
    to GitHub to create the Webhooks needed to trigger the build. Then using the **Jenkins
    Ansible Tower** plugin, I had Jenkins trigger a playbook run in AWX.
  prefs: []
  type: TYPE_NORMAL
- en: I did this because at the moment, AWX does not hook in that easily with GitHub
    Webhooks, whereas **Jenkins** and the **Jenkins GitHub** plugin have a great level
    of compatibility—I imagine with the rate at which AWX is being developed, this
    slight niggle will be ironed out at some point soon.
  prefs: []
  type: TYPE_NORMAL
- en: As AWX allows you to grant role-based access to playbooks, I gave the development
    manager and operations engineers access to run the production playbook, and the
    developers have read-only access so that they can review the results of the playbook
    run.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the deployment to production was also able to be automated,
    be it that, someone with the correct permissions had to trigger the playbook run
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: The level of control which AWX allows us to have of who could trigger deployments,
    fitted it in with our existing deployment strategy which stated that the developers
    should not have access to production systems to deploy code which they had written.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have come to the end of not only the chapter but also our book. I have
    been trying to think of a way I can sum up Ansible, and I have managed to find
    it in a tweet ([https://twitter.com/laserllama/status/976135074117808129](https://twitter.com/laserllama/status/976135074117808129))
    from Ansible creator Michael DeHaan, who, in response to a technical recruiter,
    said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Anyone using Ansible for a few months is as good as anyone using Ansible for
    three years. It''s a simple tool on purpose."'
  prefs: []
  type: TYPE_NORMAL
- en: That perfectly sums up my experience of Ansible and hopefully yours. Once you
    know the basics, it is very easy to quickly move on and start to build more and
    more complex playbooks, which can not only assist with deploying basic code and
    applications, but also with deploying complex cloud and even physical architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to not only reuse your own roles but have access to a large collection
    of a community-contributed roles via Ansible Galaxy means you have many examples
    or quick starting points for your next project. So, you can roll your sleeves
    up and get stuck in a lot sooner than maybe you would with other tools. Also,
    if there is something Ansible cannot do, then odds are there is a tool it can
    be integrated with to provide the missing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to what we discussed back in [Chapter 1](4648440f-c619-462b-9e31-001dc98210ca.xhtml),
    *An Introduction to Ansible*, being able to define your infrastructure and deployment
    in code in a repeatable and shareable way that encourages others to contribute
    to your playbooks should really be the ultimate aim of why you would start to
    introduce Ansible into your day-to-day workflows. I hope that, through this book,
    you have started to think of day-to-day tasks where Ansible could help you and
    save you time.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More information on the tools mentioned in this chapter can be found at the
    following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hubot**: [https://hubot.github.com](https://hubot.github.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hubot Slack**: [https://github.com/slackapi/hubot-slack](https://github.com/slackapi/hubot-slack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hubot Alias**: [https://github.com/dtaniwaki/hubot-alias](https://github.com/dtaniwaki/hubot-alias)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hubot Yardmaster**: [https://github.com/hacklanta/hubot-yardmaster](https://github.com/hacklanta/hubot-yardmaster)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins Git**: [https://plugins.jenkins.io/git](https://plugins.jenkins.io/git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins Ansible**: [https://plugins.jenkins.io/ansible](https://plugins.jenkins.io/ansible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins GitHub**: [https://plugins.jenkins.io/github](https://plugins.jenkins.io/github)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins Ansible Tower**: [https://plugins.jenkins.io/ansible-tower](https://plugins.jenkins.io/ansible-tower)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

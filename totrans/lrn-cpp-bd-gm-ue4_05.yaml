- en: Functions and Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing code, you''ll find yourself needing to run the same code multiple
    times. The last thing you want to do is to copy and paste the same code in a bunch
    of different places (after all, what happens if you need to make a change?). Wouldn''t
    it be easier to just write it once and call it multiple times? That''s what we''re
    covering in this chapter. The topics we will cover include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializer lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constexpr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some things need to be repeated. Code is not one of them. A function is a bundle
    of code that can get called any number of times, as often you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Analogies are good. Let's explore an analogy that deals with waiters, chefs,
    pizzas, and functions. In English, when we say a person has a function, we mean
    that the person performs some very specific (usually very important) task. They
    can do this task again and again, whenever they are called upon to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following comic strip shows the interaction between a waiter (caller) and
    a chef (callee). The waiter wants food for his table, so he calls upon the chef
    to prepare the food required by the waiting table. The chef prepares the food
    and then returns the result to the waiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc74aa10-910d-4458-9ff7-f6a46c30b1c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the chef performs his function of cooking food. The chef accepted the
    parameters about what type of food to cook (three pepperoni pan pizzas). The chef
    then went away, did some work, and returned with three pizzas. Note that the waiter
    does not know and does not care about how the chef goes about cooking the pizzas.
    The chef abstracts away the process of cooking pizzas for the waiter, so cooking
    a pizza is just a simple, single-line command for the waiter. The waiter just
    wants his request to be completed and the pizzas returned to him.
  prefs: []
  type: TYPE_NORMAL
- en: When a function (chef) gets called with some arguments (types of pizzas to be
    prepared), the function performs some actions (preparing the pizzas) and optionally
    returns a result (the actual finished pizzas).
  prefs: []
  type: TYPE_NORMAL
- en: An example of a library function – sqrt()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's talk about a more practical example and relate it to the pizza example.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a function in the `<cmath>` library called the `sqrt()` function.
    Let me quickly illustrate its use, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function call is after the `=` character: `sqrt( 5 )`. So, `sqrt()` can
    find the mathematical square root of any number given to it.
  prefs: []
  type: TYPE_NORMAL
- en: Do you know how to find the square root of a tough number such as 5? It's not
    simple. A clever soul sat down and wrote a function that can find the square roots
    of all types of numbers. Do you have to understand the math behind how the square
    root of 5 is found to use the `sqrt(5)` function call? Heck, no! So, just as the
    waiter didn't have to understand how to cook a pizza in order to get a pizza as
    the result, the caller of a C++ library function does not have to fully understand
    how that library function works internally to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of using functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions abstract away a complex task into a simple, callable routine. This
    makes the code required to *cook a pizza*, for instance, just a single-line command
    for the caller (the caller is typically your program).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions avoid the repetition of code where it is not necessary. Say we have
    20 or so lines of code that can find the square root of a double value. We wrap
    these lines of code into a callable function; instead of repeatedly copying and
    pasting these 20 lines of code, we simply call the `sqrt` function (with the number
    to root) whenever we need a root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the process of finding a square root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59897c3a-4d94-4e10-b59b-a99f766f8a8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing our own functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say we want to write some code that prints out a strip of road, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, say we want to print two strips of road in a row, or three strips of road.
    Or, say we want to print any number of strips of road. We will have to repeat
    the four lines of code that produce the first strip of road once per strip of
    road we're trying to print.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we introduced our own C++ command that allowed us to print a strip
    of road on calling the command? Here''s how that will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the definition of a function. A C++ function has the following anatomy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bbc34fb-1b86-45cd-9566-5d90babc62e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `void` means it does not return any values and, since there is nothing
    inside the parentheses, it doesn''t take any parameters. We''ll get into parameters
    and return values later. Using a function is simple: we simply invoke the function
    we want to execute by name, followed by two round brackets, `()`. For example,
    calling the `printRoad()` function will cause the `printRoad()` function to run.
    Let''s trace an example program to fully understand what this means.'
  prefs: []
  type: TYPE_NORMAL
- en: A sample program trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a complete example of how a function call works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's trace the program's execution from beginning to end. Remember that, for
    all C++ programs, execution begins on the first line of `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`main()` is also a function. It oversees the execution of the whole program.
    Once `main()` executes the `return` statement, your program ends.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A line-by-line trace of the execution of the preceding program is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the output of this program will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an explanation of the preceding code, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The program's execution begins on the first line of `main()`, which outputs
    `program begin!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next line of code that is run is the call to `printRoad()`. What this does
    is it jumps the program counter to the first line of `printRoad()`. All the lines
    of `printRoad()` then execute in order (lines 3-6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the function call to `printRoad()` is complete, control returns to the
    `main()` statement. We then see `Program end` printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget the brackets after the function call to `printRoad()`. A function
    call must always be followed by round brackets, `()`, otherwise the function call
    will not work and you will get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to print four strips of road:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, instead of repeating the four lines of `cout` every time a box is printed,
    we simply call the `printRoad()` function to make it print. Also, if we want to
    change how a printed road looks, we have to simply modify the implementation of
    the `printRoad()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function entails running the entire body of that function, line by
    line. After the function call is complete, the control of the program then resumes
    at the point of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an exercise, find out what is wrong with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The correct answer to this problem is that the call to `myFunction` (in the
    last line of `main()`) is not followed by round brackets. All function calls must
    be followed by round brackets. The last line of `main()` should read `myFunction();`,
    not just `myFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we extend the `printRoad()` function to print a road with a certain
    number of segments? The answer is simple. We can let the `printRoad()` function
    accept a parameter, called `numSegments`, to print a certain number of road segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how that will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the anatomy of a function that accepts an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/696b374e-dfb2-4f95-b0c2-ce4c02b8ed63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Call this new version of `printRoad()`, asking it to print four segments, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value `4` between the brackets of `function call` in the preceding statement
    gets assigned to the `numSegments` variable of the `printRoad(int numSegments)`
    function. This is how the value `4` gets passed to `numSegments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b5ac394-8767-4232-9b36-27f662031484.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of how printRoad(4) will assign the value 4 to the numSegments
    variable
  prefs: []
  type: TYPE_NORMAL
- en: So, `numSegments` gets assigned the value passed between the brackets in the
    call
  prefs: []
  type: TYPE_NORMAL
- en: to `printRoad()`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An example of a function that returns a value is the `sqrt()` function. The
    `sqrt()` function accepts a single parameter between its brackets (the number
    to root) and returns the actual root of the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using the `sqrt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `sqrt()` function does something analogous to what the chef did when preparing
    the pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: As a caller of the function, you do not care about what goes on inside the body
    of the `sqrt()` function; that information is irrelevant since all you want is
    the result of the square root of the number that you are passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare our own simple function that returns a value, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the anatomy of a function with parameters and
    a returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac3d5a85-c21c-45c1-b467-d1a6eb6f54e6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `sum` function is very basic. All it does is take two `int` numbers, `a`
    and `b`, sums them up together, and returns a result. You might say that we don't
    even need an entire function just to add two numbers. You're right, but bear with
    me for a moment. We will use this simple function to explain the concept of returned
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use the `sum` function in this way (from `main()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For the `cout` command to complete, the `sum( 5,6 )` function call must be evaluated.
    At the point where the `sum( 5,6 )` function call occurs, the returned value from
    `sum( 5,6 )` is put right there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, this is the line of code that `cout` actually sees after evaluating
    the `sum( 5,6 )` function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The returned value from `sum( 5,6 )` is effectively cut and pasted at the point
    of the function call. A value must always be returned by a function that promises
    to do so (if the return type of the function is anything other than `void`).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write an `isPositive` function that returns `true` when the double parameter
    passed to it is indeed positive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the following function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Write a `getGrade()` function that accepts an integer value (marks out of 100)
    and returns the grade (either `A`, `B`, `C`, `D`, or `F`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mathematical function is of the form `f(x) = 3x + 4`. Write a C++ function
    that returns values for `f(x)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `isPositive` function accepts a double parameter and returns a Boolean
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the completed `absEqual` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getGrade()` function is given in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This program is a simple one that should entertain you. The origin of the name function in
    C++ actually came from the math world, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Initializer lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may not know how many items you want to pass to an array. Newer
    versions of C++ have added a simple way of doing this, an initializer list. This
    allows you to pass in any number of items inside curly brackets and separated
    by commas, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To set this up, you need to use `initializer_list` as the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a template, which we will go into later, but for now all you need to
    know is the type of object you''re putting in the list is inside the angle brackets
    like this: `<int>`.  This could just as easily been another type, such as `float`
    or `char`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this function, you can pass in the values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `10` for this case.
  prefs: []
  type: TYPE_NORMAL
- en: Variables revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's always nice to revisit a topic you've covered before, now that you understand
    C++ coding in much more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've introduced the concept of functions, the concept of a global
    variable can be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: What is a global variable? A global variable is any variable that is made accessible
    to all of the functions of the program. How can we make a variable that is accessible
    to all of the functions of the program? We simply declare the global variable
    at the top of the code file, usually after or near the `#include` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example program with some global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, the same `g_string` global variable is accessible to all four functions
    in the program (`addA()`, `addB()`, `addC()`, and `main()`). Global variables
    live for the duration of the program.
  prefs: []
  type: TYPE_NORMAL
- en: People sometimes prefer to prefix global variables with `g_`, but prefixing
    the variable name with `g_` is not a requirement for a variable to be global.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A local variable is a variable that is defined within a block of code. Local
    variables go out of scope at the end of the block in which they are declared.
    Some examples will follow in the next section, *The* *scope of a variable*.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scope of a variable is the area of code where that variable can be used.
    The scope of any variable is basically the block in which it is defined. We can
    demonstrate a variable''s scope using an example, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The main thing that defines a variable''s scope is a block. Let''s discuss
    the scope of a couple of the variables defined in the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g_int`: This is a global integer with a scope that ranges from the point it
    was declared until the end of the code file. That is to say, `g_int` can be used
    inside `func()` and `main()`, but it cannot be used in other code files. To have
    a single global variable that is used across multiple code files, you will need
    an external variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg` (the argument of `func()`): This can be used from the first line of `func()`
    (after the opening curly brace, `{`) to the last line of `func()` (until the closing
    curly brace, `}`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fx`: This can be used anywhere inside `func()` until the closing curly brace
    (`}`) of `func()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main()` (variables inside `main()`): This can be used as marked in the comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice how variables declared inside the brackets of a function''s argument
    list can only be used inside the block below that function''s declaration, for
    example, the `arg` variable passed to `func()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `arg` variable will die after the closing curly brace (`}`) of the `func()`
    function. This is counter intuitive as the round brackets are technically outside
    the curly braces that define the `{` block `}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for variables declared inside the round brackets of a `for` loop.
    Take as an example the following `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `int c` variable can be used inside the round brackets of the `for` loop
    declaration or inside the block below the `for` loop declaration. The `c` variable
    will die after the closing of the curly brace of the `for` loop it is declared
    in. If you want the `c` variable to live on after the brace brackets of the `for`
    loop, you need to declare the `c` variable before the `for` loop, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Static local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`static` local variables have a local scope, but they don''t go away when you
    exit the function, and instead remember the value between calls, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With the use of the `static` keyword inside `testFunc()`, the `runCount` variable
    remembers its value between calls of `testFunc()`. So, the output of the two separate
    preceding runs of `testFunc()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s because static variables are only created and initialized once (the
    first time when the function they are declared in runs), and after that, the static
    variable retains its old value. Say we declare `runCount` as a regular, local,
    nonstatic variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, this is how the output will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see `testFunc` saying `Ran this function 1 time` both times. As a local
    variable, the value of `runCount` is not retained between function calls.
  prefs: []
  type: TYPE_NORMAL
- en: You should not overuse static local variables. In general, you should only use
    a static local variable when it is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Const variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `const` variable is a variable whose value you promise the compiler not to
    change after the first initialization. We can declare one simply, for example,
    for the value of `pi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `pi` is a universal constant (one of the few things you can rely on to
    be the same), there should be no need to change `pi` after initialization. In
    fact, changes to `pi` should be forbidden by the compiler. Try, for example, to
    assign `pi` a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This error makes perfect sense because, besides the initialization, we should
    not be able to change the value of `pi`—a variable that is constant.
  prefs: []
  type: TYPE_NORMAL
- en: Const and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`const` can be used in many ways, some of which involve functions. Sometimes,
    you are passing a variable into a function, but you don''t want the function to
    make any changes to the value. You may think well, I can just make sure I don''t
    change it, can''t I? That may be the case on your own projects, but what if you''re
    on a big team with multiple programmers? You could just put a comment, but it''s
    generally better to make sure the parameter is marked as `const`. To do that,
    you write the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to change either of these values, you will cause an error.
    For example, this won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also return a constant value by changing it to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Just make sure you save the value that the function returns in a variable that
    is also marked as `const` or you'll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Function prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function prototype is the signature of the function without the body. For
    example, let''s prototype the `isPositive`, `absEqual`, and `getGrade` functions
    from the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the function prototypes are just the return type, function name,
    and argument list that the function requires. Function prototypes don't get a
    body. The body of the function is typically put in the `.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: .h and .cpp files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is typical to put your function prototypes in a `.h` file and the bodies
    of the functions in a `.cpp` file. The reason for this is you can include your
    `.h` file in a bunch of `.cpp` files and not get multiple definition errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot gives you a clear picture of `.h` and `.cpp` files,
    showing `.cpp` files for the main code and for functions, and a `.h` file holding
    the function prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95086156-bec4-4b0d-bb04-96ccf2f21185.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have three files in this Visual C++ project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe37fba4-9f16-44bf-a7a6-42836edb896e.png)'
  prefs: []
  type: TYPE_IMG
- en: prototypes.h
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `prototypes.h` file contains function prototypes. We will explain what
    the `extern` keyword does later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: funcs.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the content of `funcs.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the content of `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When you split up the code into `.h` and `.cpp` files, the `.h` file (the header
    file) is called the interface and the `.cpp` file (the one with the actual functions
    in it) is called the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The puzzling part at first for some programmers is how does C++ know where the
    `isPositive` and `getGrade` function bodies are, if we only `#include` the prototypes?
    Shouldn't we `#include` the `funcs.cpp` file into `main.cpp` too?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is *magic*. You only need to `#include` the `prototypes.h` header
    file in both `main.cpp` and `funcs.cpp`. As long as both `.cpp` files are included
    in your C++ **Integrated Development Environment** (**IDE**) project (that is,
    they appear in the Solution Explorer tree view at the left-hand side), the linkup
    of the prototypes to the function bodies is done automatically by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: extern variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `extern` declaration is similar to a function prototype, only it is used
    on a variable. You can put an `extern` global variable declaration in a `.h` file
    and include this `.h` file in a whole bunch of other files. This way, you can
    have a single global variable that gets shared across multiple source files, without
    getting the multiply defined symbols found linker error. You'd put the actual
    variable declaration in a `.cpp` file so that the variable only gets declared
    once. There is an `extern` variable in the `prototypes.h` file in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ macros are from a class of C++ commands called preprocessor directives.
    A preprocessor directive is executed before compilation takes place. Macros start
    with `#define`. For example, say we have the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At the lowest level, macros are simply copy and paste operations that occur
    just before compile time. In the preceding macro statement, the `3.14159` literal
    will be copied and pasted everywhere the symbol `PI` occurs in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What the C++ preprocessor will do is first go through the code and look for
    any use of the `PI` symbol. It will find one such use on this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line will convert into the following just before compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, all that happens with a `#define` statement is that all of the occurrences
    of the symbol used (for example, `PI`) are replaced by the literal number `3.14159`
    even before compilation occurs. The point of using macros in this way is to avoid
    hardcoding numbers into the code. Symbols are typically easier to read than big,
    long numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advice: try to use `const` variables where possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use macros to define constant variables. You can also use `const` variable
    expressions instead. So, say we have the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be encouraged to use the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using a `const` variable will be encouraged because it stores your value inside
    an actual variable. The variable is typed and typed data is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Macros with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also write macros that accept arguments. Here''s an example of a macro
    with an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'What this macro will do is every time `println("Some value")` is encountered
    in the code, the code on the right-hand side (`cout << "Some value" << endl`)
    will be copied and pasted into the console. Notice how the argument between the
    brackets is copied in the place of `X`. Say we had the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be replaced by the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Macros with arguments are exactly like very short functions. Macros cannot contain
    any newline characters in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advice: use inline functions instead of macros with arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: You have to know about how macros with arguments work because you will encounter
    them in C++ code a lot. Whenever possible, however, many C++ programmers prefer
    to use inline functions over macros with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A normal function call execution involves a `jump` instruction to the function
    and then the execution of the function. An inline function is one whose lines
    of code are copied to the point of the function call and no jump is issued. Using
    inline functions usually makes sense for very small, simple functions that don''t
    have a lot of lines of code. For example, we might inline a simple function, `max`,
    that finds the larger of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Everywhere this `max` function is used, the code for the function body will
    be copied and pasted at the point of the function call. Not having to `jump` to
    the function saves execution time, making inline functions effectively similar
    to macros.
  prefs: []
  type: TYPE_NORMAL
- en: There is a catch to using inline functions. Inline functions must have their
    bodies completely contained in the `.h` header file. This is so that the compiler
    can make optimizations and actually inline the function wherever it is used. Functions
    are made inline typically for speed (since you don't have to jump to another body
    of the code to execute the function) but at the cost of code bloat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the reasons why inline functions are preferred over macros:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros are error prone: The argument to the macro is not typed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Macros have to be written in one line or you will see them using escaped:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the macro is not carefully written, it will result in difficult-to-fix compiler
    errors. For example, if you do not bracket your argument properly, your code will
    just be wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large macros are hard to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be said that macros do allow you to perform some preprocessor compilation
    magic. UE4 makes a lot of use of macros with arguments, as you will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Constexpr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one other new way you can also do things that happen at compile time,
    instead of at runtime, and that is by using `constexpr`. As with macros, you can
    create variables and functions that will get automatically copied by the compiler
    to where they are used. So, you can do variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add `constexpr` to functions you want to run at compile time like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'One more thing you can do with `constexpr` is use it with `if` statements to
    evaluate something at compile time. So, if you want to do something different
    for the demo version of the game when you compile it, you can do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You'll find more uses for these when we talk about templates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function calls allow you to reuse basic code. Code reuse is important for a
    number of reasons, mainly because programming is hard and duplicating effort should
    be avoided wherever possible. The efforts of the programmer that wrote the `sqrt()`
    function do not need to be repeated by other programmers who want to solve the
    same problem.
  prefs: []
  type: TYPE_NORMAL

- en: Inventory System and Pickup Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want our player to be able to pick up items from the game world. In this
    chapter, we will code and design a backpack for our player to store items. We
    will display what the player is carrying in the pack when the user presses the
    *I* key.
  prefs: []
  type: TYPE_NORMAL
- en: As a data representation, we can use the `TMap<FString, int>` items covered
    in the previous chapter to store our items. When the player picks up an item,
    we add it to the map. If the item is already in the map, we just increase its
    value by the quantity of the new items picked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the backpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PickupItem base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing the player inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring the backpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can represent the player''s backpack as a simple `TMap<FString, int>` item. To
    allow our player to gather items from the world, open the `Avatar.h` file and add
    the following `TMap` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Forward declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the `AAvatar` class, notice that we have a `class APickupItem` forward
    declaration. Forward declarations are needed in a code file when a class is mentioned
    (such as the `APickupItem::Pickup( APickupItem *item );` function prototype),
    but there is no code in the file actually using an object of that type inside
    the file. Since the `Avatar.h` header file does not contain executable code that
    uses an object of the type `APickupItem`, a forward declaration is what we need.
    While it may seem easier to include a .h file. sometimes it's better to avoid
    that, or you may get circular dependencies (two classes that each try including
    the other one can cause problems).
  prefs: []
  type: TYPE_NORMAL
- en: The absence of a forward declaration will give a compiler error, since the compiler
    won't have heard of `class APickupItem` before compiling the code in `class AAvatar`.
    The compiler error will come at the declaration of the `APickupItem::Pickup( APickupItem
    *item );` function prototype declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declared two `TMap` objects inside the `AAvatar` class. This is how the
    objects will look, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `FString` (name) | `int` (quantity) | `UTexture2D*` (im) |'
  prefs: []
  type: TYPE_TB
- en: '| `GoldenEgg` | `2` | ![](img/c3918bbc-1d30-4f56-aea2-4df86976f902.png) |'
  prefs: []
  type: TYPE_TB
- en: '| `MetalDonut` | `1` | ![](img/9b920363-321a-41c9-a215-8f472aad5bc9.png) |'
  prefs: []
  type: TYPE_TB
- en: '| `Cow` | `2` | ![](img/771da95a-5e07-4846-94f1-346279693904.png) |'
  prefs: []
  type: TYPE_TB
- en: In the `TMap` backpack, we store the `FString` variable of the item that the
    player is holding. In the `Icons` map, we store a single reference to the image
    of the item the player is holding.
  prefs: []
  type: TYPE_NORMAL
- en: 'At render time, we can use the two maps working together to look up both the
    quantity of an item that the player has (in his `Backpack` mapping), and the texture
    asset reference of that item (in the `Icons` map). The following screenshot shows
    how the rendering of the HUD will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ead175d8-8699-48a9-88de-6c8fa1c2086b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we can also use an array of `struct` with an `FString` variable and
    `UTexture2D*` in it instead of using two maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can keep `TArray<Item> Backpack;` with a `struct` variable,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, as we pick up items, they will be added to the linear array. However,
    counting the number of each item we have in the backpack will require constant
    re-evaluation by iterating through the array of items each time we want to see
    the count. For example, to see how many hairbrushes you have, you will need to
    make a pass through the whole array. This is not as efficient as using a map.
  prefs: []
  type: TYPE_NORMAL
- en: Importing assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed the Cow asset in the preceding screenshot, which is not
    a part of the standard set of assets that UE4 provides in a new project. In order
    to use the Cow asset, you need to import the cow from the Content Examples project.
    There is a standard importing procedure that UE4 uses.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, I have outlined the procedure for importing the
    Cow asset. Other assets will be imported from other projects in UE4 using the
    same method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to import the Cow asset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and open UE4''s Content Examples project. Find it under Learn in the
    Epic Game Launcher, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6b3e574-9bbc-455d-a1aa-44ad05f4822e.png)'
  prefs: []
  type: TYPE_IMG
- en: After you have downloaded Content Examples, open it and click on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d191f3be-af11-46e1-b608-8255fd89edc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, name the folder in which you will put your `ContentExamples` and click
    on Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your `ContentExamples` project from the library. Browse the assets available
    in the project until you find one that you like. Searching for `SM_` will help
    since all static meshes usually begin with `SM_` by convention:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c401500f-fb64-4339-ad53-cb369c27eed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Assets available in the project
  prefs: []
  type: TYPE_NORMAL
- en: 'When you find an asset that you like, import it into your project by right-clicking
    on the asset and then clicking on Asset Actions > Migrate...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aaf26cd5-cdb2-4f0c-9784-bd815f8f43c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on OK in the Asset Report dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/335e3f20-4f45-4d42-b3b0-2f87a74e648b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Content folder from your project that you want to add the SM_Toy_Cow
    file to. We will add it to `/Documents/Unreal Projects/GoldenEgg/Content`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be9114fd-5243-4752-b5a0-eaa04fed5e27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the import was completed successfully, you will see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd127d7a-4618-45e8-9a57-66f9bca8328e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you import your asset, you will see it show up in your asset browser inside
    your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2eea6f29-6e2e-4ef0-a5a5-7fc312a12e4e.png)'
  prefs: []
  type: TYPE_IMG
- en: You can then use the asset inside your project normally.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching an action mapping to a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to attach a key to activate the display of the player''s inventory.
    Inside the UE4 editor, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an Action Mappings + called `Inventory`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign it to the keyboard key *I*, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b70bffd-3536-4c2b-b521-1103b6ba0183.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in the `Avatar.h` file, add a member function to be run when the player''s
    inventory needs to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Avatar.cpp` file, implement the `ToggleInventory()` function, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, connect the `"Inventory"` action to `AAvatar::ToggleInventory()` in `SetupPlayerInputComponent()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The PickupItem base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to define how a pickup item looks in code. Each pickup item will be
    derived from a common base class. Let's construct the base class for a `PickupItem`
    class now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PickupItem` base class should inherit from the `AActor` class. Similar
    to how we created multiple NPC blueprints from the base NPC class, we can create
    multiple `PickupItem` blueprints from a single `PickupItem` base class, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01cb7674-3e98-4a88-b927-5a8a3b556723.png)'
  prefs: []
  type: TYPE_IMG
- en: The text in this screenshot is not important. this image gives you an idea of
    how to create multiple `PickupItem` blueprints from a single `PickupItem` base
    class
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the `PickupItem` class, open its code in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `APickupItem` class will need quite a few members, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An `FString` variable for the name of the item being picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `int32` variable for the quantity of the item being picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `USphereComponent` variable for the sphere that you will collide with for
    the item to be picked up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UStaticMeshComponent` variable to hold the actual `Mesh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UTexture2D` variable for the icon that represents the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer for the HUD (which we will initialize later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how the code in `PickupItem.h` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The point of all these `UPROPERTY()` declarations is to make `APickupItem`
    completely configurable by blueprints. For example, the items in the Pickup category
    will be displayed as follows in the blueprints editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5a2836e-5c31-47f8-8303-68ad756e0f6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `PickupItem.cpp` file, we complete the constructor for the `APickupItem`
    class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first two lines, we perform an initialization of `Name` and `Quantity`
    to values that should stand out to the game designer as being uninitialized. We
    used block capitals so that the designer can clearly see that the variable has
    never been initialized before.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize the `ProxSphere` and `Mesh` components using `ObjectInitializer.CreateDefaultSubobject`.
    The freshly initialized objects might have some of their default values initialized,
    but `Mesh` will start out empty. You will have to load the actual mesh later,
    inside blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: For the mesh, we set it to simulate realistic physics so that pickup items will
    bounce and roll around if they are dropped or moved. Pay special attention to
    the line `ProxSphere->AttachToComponent(Mesh, FAttachmentTransformRules::KeepWorldTransform);`.
    This line tells you to make sure the pickup item's `ProxSphere` component is attached
    to the `Mesh` root component. This means that when the mesh moves in the level,
    `ProxSphere` follows. If you forget this step (or if you did it the other way
    around), then `ProxSphere` will not follow the mesh when it bounces.
  prefs: []
  type: TYPE_NORMAL
- en: The root component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, we assigned `RootComponent` of `APickupItem` to the
    `Mesh` object. The `RootComponent` member is a part of the `AActor` base class,
    so every `AActor` and its derivatives have a root component. The root component
    is basically meant to be the core of the object, and also defines how you collide
    with the object. The `RootComponent` object is defined in the `Actor.h` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the UE4 creators intended `RootComponent` to always be a reference to the
    collision primitive. Sometimes the collision primitive can be capsule shaped—other
    times it can be spherical or even box-shaped, or it can be arbitrarily shaped,
    as in our case, with the mesh. It''s rare that a character should have a box-shaped
    root component, however, because the corners of the box can get caught on walls.
    Round shapes are usually preferred. The `RootComponent` property shows up in the
    blueprints, where you can see and manipulate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3283ccec-e589-4b8e-a8b9-140c368d86d8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can edit the ProxSphere root component from its blueprints once you create
    a blueprint based on the PickupItem class
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Prox_Implementation` function gets implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure you add the following at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of tips here that are pretty important: first, we have to access a
    couple of *globals* to get the objects we need. There are three main objects we''ll
    be accessing through these functions that manipulate the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller (`APlayerController`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HUD (`AMyHUD`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player himself (`AAvatar`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is only one of each of these three types of objects in the game instance.
    UE4 has made finding them easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for this to compile you also need to add another constructor to the `Message`
    struct in `MyHud.h`. You need one that lets you pass in the image like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To compile, you will also need to add another variable to the struct, `UTexture2D*
    tex;`. You also need to implement the Pickup function in Avatar.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the avatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `player` class object can be found at any time from any place in the code
    by simply calling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We then pass the player the item by calling the `AAvatar::Pickup()` function
    defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `PlayerPawn` object is really an `AAvatar` instance, we cast the
    result to the `AAvatar` class, using the `Cast<AAvatar>` command. The `UGameplayStatics`
    family of functions are accessible anywhere in your code as they are global functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the player controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retrieving the player controller can be done from a global function as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `GetWorld()` function is actually defined in the `UObject` base class. Since
    all UE4 objects derive from `UObject`, any object in the game actually has access
    to the `world` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although this organization might seem strange at first, the HUD is actually
    attached to the player''s controller. You can retrieve the HUD as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We cast the HUD object since we previously set the HUD to be an `AMyHUD` instance
    in blueprints. Since we will be using the HUD often, we can actually store a permanent
    pointer to the HUD inside our `APickupItem` class. We will discuss this point
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement `AAvatar::Pickup`, which adds an object of the type `APickupItem`
    to the Avatar''s backpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Also, make sure you add `#include "PickupItem.h"` at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we check whether the pickup item that the player just
    got is already in his pack. If it is, we increase its quantity. If it is not in
    his pack, we add it to both his pack and the `Icons` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the pickup items to the pack, use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`APickupItem::Prox_Implementation` is the way this member function will get
    called.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to display the contents of our backpack in the HUD when the player
    presses *I*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the player inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inventory screen in a game such as *Diablo* features a pop-up window, with
    the icons of the items you've picked up in the past arranged in a grid. We can
    achieve this type of behavior in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of approaches to drawing a UI in UE4\. The most basic way
    is to simply use `HUD::DrawTexture()` calls. Another way is to use Slate. Another
    way still is to use the newest UE4 UI functionality: **Unreal Motion Graphics**
    (**UMG**) Designer.'
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses a declarative syntax to lay out UI elements in C++. Slate is best
    suited for menus and the like. UMG has been around since UE 4.5 and uses a heavily
    blueprint-based workflow. Since our focus here is on exercises that use C++ code,
    we will stick to a `HUD::DrawTexture()` implementation, but we will go over UMG
    in a later chapter. This means that we will have to manage all the data that deals
    with the inventory in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Using HUD::DrawTexture()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HUD::DrawTexture()` is what we will use to draw the inventory to the screen
    at this point.   We will achieve this in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We push the contents of our inventory to the HUD when the user presses the *I*
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we render the icons into the HUD in a grid-like fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep all the information about how a widget can be rendered, we declare a
    simple structure to keep the information concerning what icon it uses, its current
    position, and current size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `Icon` and `Widget` structures look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can add these structure declarations to the top of `MyHUD.h`, or you can
    add them to a separate file and include that file everywhere those structures
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the four member functions on the `Widget` structure to get to the `left()`,
    `right()`, `top()`, and `bottom()` functions of the widget. We will use these
    later to determine whether a click point is inside the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare the function that will render the widgets out on the screen
    in the `AMyHUD` class. First, in `MyHud.h`, add an array to hold widgets and a
    vector to hold the screen dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the line `void DrawWidgets();`. Then, add this to `MyHud.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to the `DrawWidgets()` function should be added to the `DrawHUD()` function,
    and you might want to move the current message handling code into a separate `DrawMessages`
    function so you can then get this (or just leave the original code there):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will fill the `ToggleInventory()` function. This is the function that
    runs when the user presses *I*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding code to compile, we need to add two functions to `AMyHUD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you add the following to the `.h` file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep using the `Boolean` variable in `inventoryShowing` to tell us whether
    the inventory is currently displayed or not. When the inventory is shown, we also
    show the mouse so that the user knows what he''s clicking on. Also, when the inventory
    is displayed, the free motion of the player is disabled. The easiest way to disable
    a player''s free motion is by simply returning from the movement functions before
    actually moving. The following code is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add `if( inventoryShowing ) { return; }` to each of the movement functions so
    when inventory is showing it will block all movement.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting inventory item clicks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can detect whether someone is clicking on one of our inventory items by doing
    a simple test to see if the point is inside the `rect` (rectangle) of an object.
    This test is done by checking the point of the click against the contents of the
    `rect` containing the area you want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check against the `rect`, add the following member function to `struct Widget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The test against the `rect` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d31e3ea5-d9e9-4708-b3a0-6e15ee9f845c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, it is a hit if `p.X` is all of:'
  prefs: []
  type: TYPE_NORMAL
- en: Right of `left() (p.X > left())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left of `right() (p.X < right())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below `top() (p.Y > top())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above `bottom() (p.Y < bottom())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that in UE4 (and UI rendering in general), the *y* axis is inverted.
    In other words, y goes down in UE4\. This means that `top()` is less than `bottom()`,
    since the origin (the `(0, 0)` point) is at the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Dragging elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can drag elements easily:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to enable dragging is to respond to the left mouse button click.
    First, we''ll write the function to execute when the left mouse button is clicked.
    In the `Avatar.h` file, add the following prototype to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Avatar.cpp` file, we can add a function to execute on a mouse click
    and pass the click request to the HUD, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `AAvatar::SetupPlayerInputComponent`, we have to attach our responder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how you set up the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fcda832-ff9a-491d-9c16-031a2ca91188.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a member to the `AMyHUD` class, plus two new function definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `AMyHUD::MouseClicked()`, we start searching for the `Widget` hit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `AMyHUD::MouseClicked` function, we loop through all the widgets that
    are on the screen and check for a hit with the current mouse position. You can
    get the current mouse position from the controller at any time by simply looking
    up `PController->GetMousePosition()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each widget is checked against the current mouse position, and the widget that
    got hit by the mouse click will be moved once the mouse is dragged. Once we have
    determined which widget got hit, we can stop checking, so we have a `return` value
    from the `MouseClicked()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hitting the widget is not enough, though. We need to drag the widget that got
    hit when the mouse moves. For this, we need to implement a `MouseMoved()` function
    in `AMyHUD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The drag function looks at the difference in the mouse position between the
    last frame and this frame, and moves the selected widget by that amount. A `static`
    variable (global with local scope) is used to remember the `lastMouse` position
    between the calls for the `MouseMoved()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we link the mouse''s motion to running the `MouseMoved()` function
    in `AMyHUD`? If you remember, we have already connected the mouse motion in the
    `Avatar` class. The two functions that we used were these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AAvatar::Pitch()` (the y axis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AAvatar::Yaw()` (the x axis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extending these functions will enable you to pass mouse inputs to the HUD.
    I will show you the `Yaw` function now, and you can extrapolate how `Pitch` will
    work from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `AAvatar::Yaw()` function first checks whether the inventory is showing
    or not. If it is showing, inputs are routed straight to the HUD, without affecting
    `Avatar`. If the HUD is not showing, inputs just go to `Avatar`.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you added `#include "MyHUD.h"` to the top of the file for this to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complete the `AAvatar::Pitch()` function (y axis) to route inputs to the HUD
    instead of to `Avatar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the NPC characters from [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml),
    *Actors and Pawns*, and give the player an item (such as `GoldenEgg`) when he
    goes near them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Putting things together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have all this code, you'll want to put this together and see it
    working. Use the Meshes you copied over to create new blueprints by right-clicking
    the `PickupItem` class in the Class Viewer and select Create Blueprint Class as
    we did previously. Set the values (including the Mesh) and then drag objects into
    the game. When you walk into them, you will get a message that it was picked up.
    At that point, you can hit *I* to view your inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to set up multiple pickup items for the player
    to see displayed in the level and also pick up. We also displayed them on screen
    and added functionality to drag the widgets. In [Chapter 11](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml), *Monsters*,
    we will introduce Monsters and how to make them follow and attack the player.
  prefs: []
  type: TYPE_NORMAL

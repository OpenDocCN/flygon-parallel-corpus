- en: Repeating Method Invocation Using Recursive Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, you learned about immutable states that make us not deal
    with the side effect. In this chapter, let''s take a look at the concept of recursion.
    As a programmer in object-oriented programming, we usually use iteration to repeat
    the process instead of recursion. However, recursion gives more benefit than iteration.
    For instance, some problems (mathematics, especially) are solved easily using
    recursion, and, fortunately, all algorithms can be defined recursively. That makes
    it much, much easier to visualize and prove. To get to know more about the recursion,
    the following topics will be discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating the iteration and recursion invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recurring the immutable function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a better way in recursion using tail recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating three kinds of recursion--functional, procedural, and backtracking
    recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating the function invocation recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a programmer, especially in object-oriented programming, we usually use the
    iteration technique to repeat our process. For now, we will discuss the recursion
    method to repeat our process and use it in the functional approach. Basically,
    recursion and iteration perform the same task, which is to solve a complicated
    task piece by piece then combine the results. However, they have a difference.
    The iteration process emphasizes that we should keep repeating the process until
    the task is done, whereas recursion emphasizes that need to break the task up
    into smaller pieces until we can solve the task, then combine the result. We can
    use the iteration process when we need to run a certain process until the limit
    is reached or read a stream until it reaches `eof()`. Also, recursion can give
    the best value when we use it, for instance, on the calculation of a factorial.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the iteration procedure to repeat the process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the iteration process. As we discussed earlier, the calculation
    of a factorial will be better if it''s designed using the recursion approach.
    However, it''s possible as well to design it with the iteration approach. Here,
    we will have a `factorial_iteration_do_while.cpp` code that we can use to calculate
    the factorial. We will have a function named `factorial ()` that passes a single
    parameter that will calculate the factorial value we pass in the argument. The
    code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we depend on the value of `n`, which we
    pass to the `factorial()` function, in determining how many iterations will occur.
    Every time the iteration performs, the `result` variable will be multiplied by
    the counter `i`. At the end, the `result` variable will hold the last result by
    combining the iteration''s result value. The output we should get on the screen
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/444549f8-8a38-48bb-b1e5-2be38e9f7bee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another technique in an iteration is using another iteration procedure. We
    can refactor the preceding code to use the `for` loop in the `factorial()` function.
    The following is the `factorial_iteration_for.cpp` code that is refactored from
    our preceding `factorial_iteration_do_while.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we replace the `do-while` loop with the `for` loop. However,
    the behavior of the program will be exactly the same, since it will also multiply
    the current result with the `i` counter each time the iteration performs. At the
    end of this iteration, we will obtain the final result from this multiplication
    process. The screen should display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c604f1cb-6277-4b29-a074-4bbf92bd02bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have successfully performed iteration to gain the factorial purpose,
    either use the `do-while` or `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: It looks too trivial when we try to refactor the `do-while` loop into the `for`
    loop. As we may know, `for` loops allow us to run through the loop when we know
    how many times we'd like it to run through the problem, while the `do-while` loops
    give us more flexibility in what we put in it and when it will stop, for instance
    `while(i > 0)` or use a Boolean value such as `while(true)`. However, based on
    the preceding example, we now can say that we can switch the `for` loop or the
    `do-while` loop into recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the recursion procedure to repeat the process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed earlier that recursion gives better performance in functional
    programming. We also developed the `factorial()` function in the iteration approach.
    Now, let''s refactor our previous code into `factorial_recursion.cpp`, which will
    use the recursion approach rather than the iteration one. The code will perform
    the same task comparing our previous code. However, we will modify the `factorial()`
    function to call itself at the end of the function. The code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `factorial()` function in the preceding code calls itself
    until `n` is `0`. Each time the function calls itself, it decrements the `n` parameter.
    The function will return `1` soon after the passed parameter is `0`. We will also
    get the same output compared to our two previous code blocks, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9c6c1c3-250a-4a02-961f-1ae358de0e60.png)'
  prefs: []
  type: TYPE_IMG
- en: Although recursion gives us the simplicity required to easily maintain code,
    we have to be aware of the parameter we pass to the recursion function. For instance,
    in the `factorial()` function in the `factorial_recursion.cpp` code, if we pass
    the negative number to the `n < 0` function, we will get the infinity loop, and
    it can crash our device.
  prefs: []
  type: TYPE_NORMAL
- en: Recurring the immutable function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the previous chapter, we need to loop the immutable function
    recursively. Let''s suppose we have the `fibonacci()` function that is immutable.
    We then need to refactor it to be a recursive function. The `fibonacci_iteration.cpp`
    code implements the `fibonacci()` function in the iteration way. The code is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `fibonacci()` function is immutable
    since it will return the same value each time it gets the exact same `n` input.
    The output should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb62a358-6e52-44fb-9628-d55839169d48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we need to refactor it to be a recursive function, we can use the following
    `fibonacci_recursion.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding code has the recursion approach since it calls
    the function itself at the end of the function. Now that we have the recursion
    `fibonacci()` function, it will give the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb853f00-201a-493a-b561-5eed14833299.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, compared to the `fibonacci_iteration.cpp` code, the `fibonacci_recursion.cpp`
    code shows the exact same output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting closer to tail recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tail recursion happens when the recursive call is executed at the end by
    the function. It''s considered better than the non-tail recursion code we developed
    previously because the compiler can optimize the code better. Since the recursive
    call is the last statement that is executed by the function, there is nothing
    more to do in this function. The result is that the compiler does not need to
    save the current function''s stack frame. Let''s see the following `tail_recursion.cpp`
    code implementing tail recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the `displayNumber()` function is a tail
    recursive call function since it calls itself at the end of the process. Indeed,
    if we run the preceding `tail_recursion.cpp` code, the program will not end since
    it will increase the value of `n` in the `displayNumber()` function. The program
    may be crashed when the value of `n` has reached the maximum value of the `long
    long` data type. However, the program will not have the stack issued (stack overflowed)
    since the tail recursion doesn't store a value in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can refactor the preceding `displayNumber()` function in the `tail_recursion.cpp`
    code to use the `goto` keyword instead of calling the function over and over.
    The refactored code can be seen in the following `tail_recursion_goto.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we can remove the last call in the `displayNumber()`
    function with the `goto` keyword. This is how the compiler optimizes the tail
    recursion by performing a tail-call elimination that will replace the last call
    with the `goto` keyword. We will also see that no stack is needed in the `displayNumber()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to compile the code containing a tail recursion with the optimization
    option provided by the compiler. Since we use GCC, always enable optimization
    level 2 (`-O2`) to gain the optimized code. The effect of not compiling with optimizations
    enabled, is that our two preceding programs (`tail_recursion.cpp` and `tail_recursion_goto.cpp`)
    will crash with the stack overflowed issue. For more information about the optimizations
    option in GCC, check out [https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Optimize-Options.html](https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Optimize-Options.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a useful tail recursion call. In the previous section, we
    have successfully refactored our iteration function into a recursive one. The
    `factorial()` function now has become a recursive function and calls itself at
    the end of the function. However, it is not tail recursion, although the function
    calls itself at the end of the function. If we look closer, the value returned
    by `factorial(n-1)` is used in `factorial(n)`, so the call to `factorial(n-1)`
    is not the last thing done by `factorial(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our `factorial_recursion.cpp` code to become the tail recursion
    function. We will develop the following `factorial_recursion_tail.cpp` code, modify
    the `factorial()` function, and add a new function named `factorialTail()`. The
    code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have moved the `factorial()` function in the `factorial_recursion.cpp`
    code to the `factorialTail()` function that requires two arguments in the `factorial_recursion_tail.cpp`
    code. As the result, after we invoke `factorial(i)`, it will then invoke the `factorialTail()`
    function. At the end of this function, the `factorialTail()` function is the only
    function that is invoked. The following image is the output of the `factorial_recursion_tail.cpp`
    code, which is exactly the same as the `factorial_recursion.cpp` code. It also
    proves that we have successfully refactored the `factorial_recursion.cpp` code
    into tail recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de6f4d4b-d59c-40cc-8ed7-f041a58a3d1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting acquainted with functional, procedural, and backtracking recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now that we have understood a little about recursion, the recursion function
    will call itself from inside its body. The recursion will be stopped only when
    it has reached a certain value. There are three types of recursion that we will
    discuss right away--**functional recursion**, **procedural recursion**, and **backtracking
    recursion**; however, these three types of recursion may not be standard terms.
    Functional recursion is a recursion process that returns some value. Procedural
    recursion is a recursion process that doesn't return a value, yet performs the
    action in each recursion it takes. Backtracking recursion is a recursion process
    to break down the task into a small set of subtasks that can be cancelled if they
    don't work. Let's consider these recursion types in the following discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting results from functional recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional recursion, the process tries to solve the problem by combining
    the results from the subproblems recursively. The result we combine comes from
    the return value of subproblems. Let''s suppose we have a problem to calculate
    a number to a power, for instance, `2` power `2` is `4` (`2Â² = 4`). By using iteration,
    we can build a code like the following `exponential_iteration.cpp` code. We have
    a function named `power()` that will be passed by two arguments--`base` and `exp`.
    The notation will be `base^(exp)` and the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we use the iteration version first, before
    we go to the recursive one, since we usually use the iteration most on a daily
    basis. We combine the `result` value in each iteration by multiplying it by the
    `base` value. If we run the preceding code, we will get the following output on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84a5e00c-542f-40cc-b398-d5124ddb94e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s refactor our preceding code to the recursive version. We will have
    the `exponential_recursion.cpp` code that will have the same `power()` function
    signature. However, we will not use the `for` loop instead of the recursion that
    the function calls itself at the end of the function. The code should be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed earlier that functional recursion returns value, the `power()`
    function is a functional recursion since it returns the `int` value. We will get
    the final result from the value returned by each subfunction. As a result, we
    will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2488e227-b4d4-4275-98c4-a499df6d85de.png)'
  prefs: []
  type: TYPE_IMG
- en: Running a task recursively in procedural recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have a functional recursion that expects the return value from the function.
    Sometimes, we don't need the return value since we run the task from inside the
    function. To achieve that purpose, we can use procedural recursion. Let's suppose
    we want to permute a short string to find all possible arrangements of it. Instead
    of returning the value, we just need to print the result every time the recursion
    is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following `permutation.cpp` code to demonstrate this task. It has
    the `permute()` function that will be invoked once, then it will invoke the `doPermute()`
    function recursively. The code should be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we ask the user to input a string, then
    the code will find the possibility of this permutation using the `permute()` function.
    It will start with the empty string in `doPermute()` since the given string from
    the user is possible also. The output on the console should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b9a4176-1af8-412e-a860-110982c72225.png)'
  prefs: []
  type: TYPE_IMG
- en: Backtracking recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, we can undo the process if the subtask doesn''t work.
    Let''s try with a labyrinth where we have to find the way from the starting point
    to the finishing point. Let''s suppose we have to find the way from `S` to `F`
    as in the following labyrinth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this problem, we have to decide the route we need, to find the finishing
    point. However, we will assume that each choice is good until we prove it''s not.
    The recursion will return a Boolean value to mark whether it''s the right way
    or not. If we choose the wrong way, the call stack unwinds and it will undo the
    choice. First, we will draw the `labyrinth` in our code. In the following code,
    there will be the `createLabyrinth()` and `displayLabyrinth()` functions. The
    code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there''s no recursion in the preceding code. The `createLabyrinth()`
    function just creates a two-dimensional array that contains the pattern of the
    `labyrinth`, whereas `displayLabyrinth()` just shows the array to console. We
    will see the following output on the console if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5caa72-94f1-4458-9bf4-e723d64e3fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can see there are two points there--`S` is
    the starting point and `F` is the finishing point. The code has to find the way
    to reach `F` from `S`. The expected route should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb949478-e271-4a23-96c1-fdc57ad1d0cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The white arrow on the preceding screenshot is a path we expected to reach
    `F` from `S`. Now, let''s develop the code to solve this labyrinth problem. We
    will create a function named `navigate` to find the possible route by figuring
    out these three states:'
  prefs: []
  type: TYPE_NORMAL
- en: If we find `F` in the [*x*,*y*] position, for instance `labyrinth[2][4]`, we
    have solved the problem then just return `true` as the return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the [*x*,*y*] position is `#`, it means that we face the wall and have to
    revisit the other [*x*,*y*] position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, we print `*` on that position to mark that we have visited it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we have analyzed the three states, we will start with the recursive cases
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The path seeker will go upward if it can navigate to `row - 1`, and it's greater
    than or equal to `0` (`row - 1 >= 0 && navigate(labyrinth, row - 1, col)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path seeker will go downward if it can navigate to `row + 1`, and it's smaller
    than `8` (`row + 1 < 8 && navigate(labyrinth, row + 1, col)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path seeker will go to the left if it can navigate to `col - 1`, and it's
    greater than or equal to `0` (`col - 1 >= 0 && navigate(labyrinth, row, col -
    1)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path seeker will go to the right if it can navigate to `col + 1`, and it's
    smaller than `8` ( `col + 1 < 8 && navigate(labyrinth, row, col + 1)` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will have the `navigate()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the `navigate()` function to find out the correct path to find
    `F`. However, before we run the `navigate()` function, we have to ensure that
    `S` is there. We then have to develop the helper function named `isLabyrinthSolvable()`.
    It will loop through the labyrinth array and will inform whether `S` is there
    or not. The following code snippet is the implementation of the `isLabyrinthSolvable()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we mention the `rows` and `cols`
    variables. We will initialize them as global variables, as we can see in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the following code if we insert the `navigate()`
    and `isLabyrinthSolvable()` functions to the `labyrinth.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding quote, in the `main()` function, we first run
    the `isLabyrinthSolvable()` function, which, in turn, invokes the `navigate()`
    function. The `navigate()` function will then go through the labyrinth to find
    out the correct path. The following is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/529db26b-9492-4c16-bfba-ea14a2a6061d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we trace how the program solves the labyrinth, it faces the wrong
    route when it finds the finish flag, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be30241d-2365-4325-907c-8761c1460abd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, there is a white square in the preceding screenshot. It''s the
    wrong choice when it is looking for the correct path. Once it meets an obstacle,
    it goes back and finds the other ways. It will also undo the choice it has made.
    Let''s see the following screenshot that shows us when the recursion finds another
    route and undoes the previous choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6bd29c3-e866-4819-8eaf-eb23403b3dc4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the recursion tries another route
    and the previously failed route has disappeared since the backtrack recursion
    undoes the route. The recursion now has the correct path, and it can just continue
    until it finds the finish flag. As a result, we now have successfully developed
    the backtracking recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given us the technique for repeating the function invocation
    by using iteration and recursion. However, since recursion is more functional
    than iteration, we emphasized our discussion on recursion instead of iteration.
    We started with the difference between iteration and recursion. We then continued
    the discussion about refactoring the immutable function to become a recursive
    immutable function.
  prefs: []
  type: TYPE_NORMAL
- en: After we learned about the recursion, we found other better recursion techniques.
    We also discussed tail recursion to get this improved technique. Lastly, we enumerated
    three kinds of recursion--functional, procedural, and backtracking recursion.
    We usually use functional recursion when we expect the return value for the recursion.
    Otherwise, we use procedural recursion. And, if we need to break down the problem
    and undo the recursion performance when it doesn't work, we can use backtracking
    recursion to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss lazy evaluation to make the code run faster.
    This will make the code become efficient since it will make sure that unnecessary
    code won't be executed.
  prefs: []
  type: TYPE_NORMAL

- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Stacks, Queues, and HashSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we revisited variables, types, and classes to see what
    they had to offer beyond the basic features introduced at the beginning of the
    book. In this chapter, we'll take a closer look at new collection types and learn
    about their intermediate-level capabilities. Remember, being a good programmer
    isn't about memorizing code, it's about choosing the right tool for the right
    job.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the new collection types in this chapter has a specific purpose. For
    most scenarios where you need a collection of data, a list or array works just
    fine. However, when you need temporary storage or control over the order of collection
    elements, or more specifically, the order they are accessed, look to stacks and
    queues. When you need to perform operations that depend on every element in a
    collection to be unique, meaning not duplicated, look to HashSets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start on the code in the following section, let''s lay out the topics
    you''ll be learning about:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peeking and popping elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, removing, and peeking elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HashSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its most basic level, a stack is a collection of elements of the same specified
    type. The length of a stack is variable, meaning it can change depending on how
    many elements it's holding. The important difference between a stack and a list
    or array is how the elements are stored. While lists or arrays store elements
    by index, stacks follow the **last-in-first-out** (**LIFO**) model, meaning the
    last element in the stack is the first accessible element. This is useful when
    you want to access elements in reverse order. You should note that they can store
    `null` and duplicate values. A helpful analogy is a stack of plates—the last plate
    you put on the stack is the first one you can easily get to. Once it's removed,
    the next-to-last plate you stacked is accessible, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the collection types in this chapter are a part of the `System.Collections.Generic`
    namespace, meaning you need to add the following code to the top of any file that
    you want to use them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know what you're about to work with, let's take a look at the basic
    syntax for declaring stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stack variable declaration needs to meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Stack` keyword, its element type between left and right arrow characters,
    and a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` keyword to initialize the stack in memory, followed by the `Stack`
    keyword and element type between arrow characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of parentheses capped off by a semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In blueprint form, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the other collection types you've worked with, stacks can't be initialized
    with elements when they're created. Instead, all elements have to be added after
    the stack is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# supports a non-generic version of the stack type that doesn''t require you
    to define the type of element in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, this is less safe and more costly than using the preceding generic
    version, so the generic version above is recommended. You can read more about
    Microsoft's recommendation at [https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md).
  prefs: []
  type: TYPE_NORMAL
- en: Your next task is to create a stack of your own and get hands-on experience
    with working with its class methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, you''re going to modify the existing item collection logic
    in *Hero Born* by using a stack to store possible loot that can be collected.
    A stack works nicely here because we won''t have to worry about supplying indexes
    to get loot items, we can just get the last one added every time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GameBehavior.cs` and add in a new stack variable named `LootStack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `Initialize` method with the following code to add new items to
    the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method to the bottom of the script to print out the stack information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `ItemBehavior.cs` and call `PrintLootReport` from the `GameManager` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Breaking this down, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates an empty stack with elements of type string to hold the loot items we'll
    add in next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses the `Push` method to add string elements to the stack (which are loot item
    names), increasing its size each time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints out the stack count whenever the `PrintLootReport` method is called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `PrintLootReport` inside `OnCollisionEnter` every time an item is collected
    by the player, which we set up in earlier chapters with Collider components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit play in Unity, collect an item Prefab, and take a look at the new loot report
    that's printed out.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Output from using stacks'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a working stack holding all the game loot, you're ready to
    experiment with how items are accessed using the stack class's `Pop` and `Peek`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Popping and peeking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already talked about how stacks store elements using the LIFO method.
    Now, we need to look at how elements are accessed in a familiar but different
    collection type—by peeking and popping:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Peek` method returns the next item on the stack without removing it, letting
    you "peek" at it without changing anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Pop` method returns and removes the next item on the stack, essentially
    "popping" it off and handing it to you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these methods can be used by themselves or together depending on what
    you need. You'll get hands-on experience with both methods in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next task is to grab the last item added to `LootStack`. In our example,
    the last element is determined programmatically in the `Initialize` method, but
    you could always programmatically randomize the order the loot items were added
    to the stack in `Initialize`. Either way, update `PrintLootReport()` in `GameBehavior`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: Calls `Pop` on `LootStack`, removes the next item on the stack, and stores it.
    Remember, stack elements are ordered by the LIFO model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `Peek` on `LootStack` and stores the next item on the stack without removing
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds a new debug log to print out the item that was popped off and the next
    item on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see from the console that a **Mythril Bracer**, the last item added
    to the stack, was popped off first, followed by a **Pair of Winged Boots**, which
    was peeked at but not removed. You can also see that `LootStack` has four remaining
    elements that can be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Output from popping and peeking on a stack'
  prefs: []
  type: TYPE_NORMAL
- en: Our player can now pick up loot items in the reverse order that they were added
    to the stack. For instance, the first item picked up will always be a **Mythril
    Bracer**, followed by a **Pair of Winged Boots**, then a **Golden Key**, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create, add, and query elements from a stack, we can
    move on to some common methods that you have access to through the stack class.
  prefs: []
  type: TYPE_NORMAL
- en: Common methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of the methods in this section are for example purposes only, they are
    not included in our game as we don't need the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can use the `Clear` method to empty out or delete the entire contents
    of a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know whether an element exists in your stack, use the `Contains`
    method and specify the element you''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to copy the elements of a stack to an array, the `CopyTo` method
    will let you specify the destination and the starting index for the copy operation.
    This feature is helpful when you need to insert stack elements at a specific place
    in an array. Note that the array you want to copy the stack elements to must already
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to convert a stack into an array, simply use the `ToArray()` method.
    This conversion creates a new array out of your stack, which is different than
    the `CopyTo()` method, which copies the stack elements to an existing array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can find the entire list of stack methods in the C# documentation at [https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1?view=netcore-3.1](https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1?view=netcore-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up our introduction to stacks, but we're going to talk about its
    cousin, the queue, in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like stacks, queues are collections of elements or objects of the same type.
    The length of any queue is variable just like a stack, meaning its size changes
    as elements are added or removed. However, queues follow the **first-in-first-out**
    (**FIFO**) model, meaning the first element in the queue is the first accessible
    element. You should note that queues can store `null` and duplicate values but
    can't be initialized with elements when they're created. The code in this section
    is for example purposes only, and is not included in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'A queue variable declaration needs to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Queue` keyword, its element type between left and right arrow characters,
    and a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` keyword to initialize the queue in memory, followed by the `Queue`
    keyword and element type between arrow characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of parentheses capped off by a semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In blueprint form, a queue looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'C# supports a non-generic version of the queue type that doesn''t require you
    to define the type of element it stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, this is less safe and more costly than using the preceding generic
    version. You can read more about Microsoft's recommendation at [https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md).
  prefs: []
  type: TYPE_NORMAL
- en: An empty queue all by itself isn't all that useful; you want to be able to add,
    remove, and peek at its elements whenever you need, which is the topic of the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding, removing, and peeking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `LootStack` variable in the previous sections could easily be a queue,
    we'll keep the following code out of our game scripts for efficiency. However,
    feel free to explore the differences, or similarities, of these classes in your
    own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a queue of string elements, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To add elements to the queue, call the `Enqueue` method with the element you
    want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the first element in the queue without removing it, use the `Peek` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To return and remove the first element in the queue, use the `Dequeue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to work with the basic features of a queue, feel free
    to explore the more intermediate and advanced methods that the queue class offers.
  prefs: []
  type: TYPE_NORMAL
- en: Common methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queues and stacks share almost the exact same features, so we won't go over
    them a second time. You can find a complete list of methods and properties in
    the C# documentation at [https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1?view=netcore-3.1](https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1?view=netcore-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: Before closing out the chapter, let's take a look at the HashSet collection
    type and the mathematical operations it's uniquely suited for.
  prefs: []
  type: TYPE_NORMAL
- en: Using HashSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last collection type we''ll get our hands on in this chapter is the HashSet.
    This collection is very different from any other collection type that we''ve come
    across: it cannot store duplicate values and is not sorted, meaning its elements
    are not ordered in any way. Think of HashSets as dictionaries with just keys,
    instead of key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: They can perform set operations and element lookups extremely fast, which we'll
    explore at the end of this section, and are best suited to situations where the
    element order and uniqueness are a top priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'A HashSet variable declaration needs to meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `HashSet` keyword, its element type between left and right arrow characters,
    and a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` keyword to initialize the HashSet in memory, followed by the `HashSet`
    keyword and element type between arrow characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of parentheses capped off by a semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In blueprint form, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike stacks and queues, you can initialize a HashSet with default values
    when declaring the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To add elements, use the `Add` method and specify the new element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an element, call `Remove` and specify the element you want to delete
    from the HashSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's it for the easy stuff, and this should start to feel pretty familiar
    at this point in your programming journey. Set operations are where the HashSet
    collection really shines, which is the topic of the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Performing operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set operations need two things: a calling collection object and a passed-in
    collection object.'
  prefs: []
  type: TYPE_NORMAL
- en: The calling collection object is the HashSet you want to modify based on which
    operation is used, while the passed-in collection object is used for comparison
    by the set operation. We'll get into this in more detail in the following code,
    but first, let's go over the three main set operations that crop up in programming
    scenarios the most often.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following definitions, `currentSet` refers to the HashSet calling an
    operation method and `specifiedSet` refers to the passed-in HashSet method parameter.
    The modified HashSet is always the current set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three main operations that we''ll be working with in the rest of
    this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnionWith` adds the elements of the current and specified sets together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntersectWith` stores only the elements that are in both the current and specified
    sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExceptWith` subtracts the elements of the specified set from the current set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two more groups of set operations that deal with subset and superset
    computations, but these are targeted at specific use cases that are beyond the
    scope of this chapter. You can find all the relevant information for these methods
    at [https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1?view=netcore-3.1](https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1?view=netcore-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have two sets of player names—one for active players and one
    for inactive players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We would use the `UnionWith()` operation to modify a set to include all the
    elements in both sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we have two different sets—one for active players and one for
    premium players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We would use the `IntersectWith()` operation to find any active players that
    are also premium members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we wanted to find all active players that are not premium members?
    We would do the opposite of what we did with the `IntersectWith()` operation by
    calling `ExceptWith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I'm using brand-new instances of the two example sets for each operation
    because the current set is modified after each operation is executed. If you keep
    using the same sets throughout, you will get different results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned how to perform fast mathematical operations with HashSets,
    it's time to close our chapter and drive home what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate collections roundup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you move on to the summary and the next chapter, let's drive home some
    key points from what we've just learned. Topics that don't always have a 1-to-1
    relationship with the actual game prototype we're building need a little extra
    love sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one question I''m sure you''re asking yourself at this point is: why use
    any of these other collection types when I could just use lists for everything?
    And that''s a perfectly valid question. The easy answer is that stacks, queues,
    and HashSets offer better performance than lists when applied in the correct circumstances.
    For example, when you need to store items in a specific order, and access them
    in a specific order, a stack would be more efficient than a list.'
  prefs: []
  type: TYPE_NORMAL
- en: The more complicated answer is that using different collection types enforces
    how your code is allowed to interact with them and their elements. This is a mark
    of good code design, as it removes any ambiguity on how you're planning to use
    a collection. With lists everywhere, things get confusing when you don't remember
    what functions you're asking them to perform.
  prefs: []
  type: TYPE_NORMAL
- en: As with everything we've learned in this book, it's always best to use the right
    tool for the job at hand. More importantly, you need to have different tools available
    for that to be an option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you're almost at the finish line! In this chapter, you learned
    about three new collection types, and how they can be used in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are great if you want to access your collection elements in the reverse
    order that they were added, queues are your ticket if you want to access your
    elements in sequential order, and both are ideal for temporary storage. The important
    difference between these collection types and lists or arrays is how they can
    be accessed with popping and peeking operations. Lastly, you learned about the
    almighty HashSet and its performance-based mathematical set operations. In situations
    where you need to work with unique values and perform additions, comparisons,
    or subtractions on large collections, these are key.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll be taken a little deeper into the intermediate world
    of C# with delegates, generics, and more as you approach the end of this book.
    Even after all you've learned, the last page is still just the beginning of another
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – intermediate collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which collection type stores its elements using the LIFO model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method lets you query the next element in a stack without removing it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can stacks and queues store `null` values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you subtract one HashSet from another?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG

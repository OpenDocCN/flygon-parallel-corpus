- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving, Loading, and Serializing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game you've ever played works with data, whether it's your player stats,
    game progress, or online multiplayer scoreboards. Your favorite game also manages
    internal data, meaning the programmers used hardcoded information to build levels,
    keep track of enemy stats, and write helpful utilities. In other words, data is
    everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to start with how both C# and Unity handle the
    filesystem on your computer, and move on to reading, writing, and serializing
    our game data. Our focus is on working with the three most common data formats
    you''ll likely come across: text files, XML, and JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a foundational understanding of your
    computer's filesystem, data formats, and basic read-write functionality. This
    will be the foundation you build your game data on, creating a more enriching
    and engaging experience for your players. You'll also be in a good position to
    start thinking about what game data is important enough to save, and how your
    C# classes and objects will look in different data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing text, XML, and JSON formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with different stream types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing game data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data can take different forms in programming, but the three formats you should
    be familiar with at the beginning of your data journey are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**, which is what you''re reading right now'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**Extensible Markup Language**), which is a way of encoding document
    information so it''s readable for you and a computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**), which is a human-readable text format
    made up of attribute-value pairs and arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these data formats has its own strengths and drawbacks, as well as applications
    in programming. For instance, text is generally used to store simpler, non-hierarchical,
    or nested information. XML is better at storing information in a document format,
    while JSON has a more diverse range of capabilities, specifically with database
    information and server communication with applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about XML at [https://www.xml.com](https://www.xml.com)
    and JSON at [https://www.json.org](https://www.json.org).
  prefs: []
  type: TYPE_NORMAL
- en: Data is a big topic in any programming language, so let's start off by breaking
    down what XML and JSON formats actually look like in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical XML file has a standardized format. Each element of the XML document
    has an opening (`<element_name>`), a closing tag (`</element_name>`), and supports
    tag attributes (`<element_name attribute= "attribute_name"></element_name>`).
    A basic file will start with the version and encoding being used, then the starting
    or root element, followed by a list of element items, and finally the closing
    element. As a blueprint, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'XML data can also store more complex objects by using child elements. For example,
    we''ll be turning a list of weapons into XML using the `Weapon` class we wrote
    earlier in the book. Since each weapon has properties for its name and damage
    value, that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the example above to make sure we''ve got it right:'
  prefs: []
  type: TYPE_NORMAL
- en: The XML document starts with the version being used
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root element is declared with an opening tag named `ArrayOfWeapon`, which
    will hold all our element items
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A weapon item is created with an opening tag named `Weapon`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its child properties are added with opening and closing tags on a single line
    for `name` and `damage`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The weapon item is closed, and two more weapon items are added
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array is closed, marking the end of the document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The good news is our application doesn't have to manually write our data in
    this format. C# has an entire library of classes and methods to help us translate
    simple text and class objects directly into XML.
  prefs: []
  type: TYPE_NORMAL
- en: We'll dive into practical code examples a little later on, but first we need
    to understand how JSON works.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON data format is similar to XML, but without the tags. Instead, everything
    is based on attribute-value pairs, like the **Dictionary** collection type we
    worked with back in *Chapter 4*, *Control Flow and Collection Types*. Each JSON
    document starts with a parent dictionary that holds as many attribute-value pairs
    as you need. Dictionaries use open and closed curly braces ( `{ }` ), a colon
    separates each attribute and value, and each attribute-value pair is separated
    by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON can also have child or nested structures by setting the value of an attribute-value
    pair to an array of attribute-value pairs. For instance, if we want to store a
    weapon, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, JSON data is often made up of lists, or arrays, or objects. Continuing
    our example, if we wanted to store a list of all the weapons our player could
    choose, we would use a pair of square brackets to denote an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can mix and match any of these techniques to store any kind of complex data
    you need, which is one of JSON's main strengths. But just like with XML, don't
    be overtaken by the new syntax – C# and Unity both have helper classes and methods
    to translate text and class objects into JSON without us having to do any heavy
    lifting. Reading XML and JSON is sort of like learning a new language—the more
    you use it the more familiar it becomes. Soon it'll be second nature!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've dipped our toes into data formatting basics, we can start talking
    about how the filesystem on your computer works and what properties we can access
    from our C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say filesystem, we're talking about something you're already familiar
    with – how files and folders are created, organized, and stored on your computer.
    When you create a new folder on your computer, you can name it and put files or
    other folders inside it. It's also represented by an icon, which is both a visual
    cue and a way to drag, drop, and move it anywhere you like.
  prefs: []
  type: TYPE_NORMAL
- en: Everything you can do on your desktop you can do in code. All you need is the
    name of the folder, or directory as it's called, and a location to store it. Anytime
    you want to add a file or subfolder, you reference the parent directory and add
    your new content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive the filesystem home, let''s start building out the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** and choose **Create Empty**, then name it **Data_Manager**:![](img/B17573_12_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.1: Data_Manager in the Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Data_Manager** object in the **Hierarchy** and drag the `DataManager`
    script we created in *Chapter 10*, *Revisiting Types, Methods, and Classes*, from
    the **Scripts** folder into the **Inspector**:![](img/B17573_12_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.2: Data_Manager in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DataManager` script and update it with the following code to print
    out a few filesystem properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we add the `System.IO` namespace, which has all the classes and methods
    we need to work with the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `FilesystemInfo` method we create in the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create the `FilesystemInfo` method to print out a few filesystem properties.
    Every operating system handles its filesystem paths differently—a path is the
    location of a directory or file written in a string. On Macs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paths are separated by a colon (`:`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories are separated by a forward slash (`/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current directory path is where the *Hero Born* project is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temporary path is the location of your filesystem's temporary folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're on other platforms and operating systems, make sure to check the `Path`
    and `Directory` methods for yourself before working with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Console messages from Data Manager'
  prefs: []
  type: TYPE_NORMAL
- en: The `Path` and `Directory` classes are the foundation we're going to be building
    on to store our data in the following sections. However, they're both large classes,
    so I encourage you to look into their documentation as you continue your data
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more documentation for the Path class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)
    and the Directory class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a simple example of filesystem properties printed out in our
    `DataManager` script, we can create a filesystem path to the location where we
    want to save our data.
  prefs: []
  type: TYPE_NORMAL
- en: Working with asset paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a purely C# application, you would have to choose what folder to save your
    files in and write out the folder path in a string. However, Unity provides a
    handy pre-configured path as part of the `Application` class where you can store
    persistent game data. Persistent data means the information is saved and kept
    each time the program runs, which makes it ideal for this kind of player information.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to know that the path to Unity's persistent data directory is
    cross-platform, meaning that it's different whether you're building a game for
    iOS, Android, Windows, and more. You can find out more information in the Unity
    documentation at [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html).
  prefs: []
  type: TYPE_NORMAL
- en: The only update we need to make to `DataManager` is creating a private variable
    to hold our path string. We're making this private because we don't want any other
    script to be able to access or change the value. That way, `DataManager` is responsible
    for all data-related logic and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following variable to `DataManager.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our code update:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a private variable to hold the data path string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We set the data path string to the application''s `persistentDataPath` value,
    added a new folder name called **Player_Data** using open and closed forward slashes,
    and printed out the complete path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to note that `Application.persistentDataPath` can only be used
    in a `MonoBehaviour` method like `Awake()`, `Start()`, `Update()`, and so on and
    the game needs to be running for Unity to return a valid path.![](img/B17573_12_04.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 12.4: File path for Unity persistent data files'
  prefs: []
  type: TYPE_NORMAL
- en: Since I'm using a Mac, my persistent data folder is nested inside my `/Users`
    folder. Remember to check out [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    to find out where your data is stored if you're using a different device.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re not working with a predefined asset path like Unity''s persistent
    data directory, C# has a handy method called `Combine` in the `Path` class for
    automatically configuring path variables. The `Combine()` method can take up to
    four strings as input parameters or an array of strings representing the path
    components. For example, a path to your `User` directory might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This takes care of any potential cross-platform issues with separating characters
    and back or forward slashes in paths and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a path to store our data, let's create a new directory, or
    folder, in the filesystem. This will let us store our data securely and between
    game runs, as opposed to temporary storage where it would be deleted or overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deleting directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new directory folder is straightforward—we check to see if one already
    exists with the same name at the same path, and if not, we tell C# to create it
    for us. Everyone has their own ways of dealing with duplicates in their files
    and folders, so we'll be repeating a fair bit of duplicate checking code in the
    rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d still recommend following the **DRY** (**Don''t Repeat Yourself**) principle
    in real-world applications; the duplicate checking code is only repeated here
    to make the examples complete and easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method inside `Initialize()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the directory folder already exists using the path we created
    in the last step
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's already been created, we send ourselves a message in the console and
    use the `return` keyword to exit the method without going any further
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the directory folder doesn't exist, we pass the `CreateDirectory()` method
    our data path and log that it's been created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and make sure that you see the right debug logs in the console,
    as well as the new directory folder in your persistent data folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't find it, use the `_dataPath` value we printed out in the previous
    step.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Console message for new directory creation'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: New directory created on the desktop'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game a second time, no duplicate directory folder will be created,
    which is exactly the kind of safe code we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Console message for duplicate directory folders'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a directory is very similar to how we created it – we check if it exists,
    then we use the `Directory` class to delete whatever folder is at the path we
    pass in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `DataManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we want to keep the directory we just created, you don't have to call
    this function right now. However, if you want to try it out all you need to do
    is replace `NewDirectory()` with `DeleteDirectory()` in the `Initialize()` function.
  prefs: []
  type: TYPE_NORMAL
- en: An empty directory folder isn't super useful, so let's create our first text
    file and save it in our new location.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, updating, and deleting files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with files is similar to creating and deleting a directory, so we already
    have the basic building blocks we need. To make sure we don't duplicate data,
    we'll check if the file already exists, and if not, we'll create a new one in
    our new directory folder.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be working with the `File` class for this section, which has a ton of
    helpful methods to help us implement our features. You can find the entire list
    at [https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file).
  prefs: []
  type: TYPE_NORMAL
- en: An important point to drive home about files before we start is that they need
    to be opened before you can add text, and they need to be closed after you're
    finished. If you don't close the file you're programmatically working with, it
    will stay open in the program's memory. This both uses computation power for something
    you're not actively editing and can create potential memory leaks. More on them
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be writing individual methods for each action we want to perform
    (create, update, and delete). We're also going to check if the files we're working
    with exist or not in each case, which is repetitive. I've structured this part
    of the book so you can get a solid grasp of each of the procedures. However, you
    can absolutely combine them into more economical methods after you've learned
    the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new private string path for the new text file and set its value in `Awake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our new code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We check if the file already exists, and if it does we `return` out of the
    method to avoid duplicates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's worth noting that this approach works well for new files that aren't going
    to be changed. We'll cover updating and overwriting data to files in the next
    exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the `WriteAllText()` method because it does everything we need all in
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new file is created using our `_textFile` path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add a title string that says `<SAVE DATA>` and add two new lines with the
    `\n` characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the file is closed for us automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We print out a log message to let us know everything went smoothly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the game now, you''ll see the debug log in the console and the
    new text file in your persistent data folder location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Console messages for new file creation'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: New file created on desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'To update our new text file, we''ll do a similar set of operations. It''s always
    nice to know when a new game is started, so your next task is to add a method
    to write that information to our save data file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: If the file exists, we don't want to duplicate it so we just exit out of the
    method without any further action
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the file does exist, we use another all-in-one method called `AppendAllText()`
    to add the game''s start time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method opens the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds a new line of text that's passed in as a method parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It closes the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print out a log message to let us know everything went smoothly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game again and you''ll see our console message and a new line in our
    text file with the new game''s date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Console messages for updating the text file'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Text file data updated'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read our new file data, we need a method to grab all the file''s
    text and hand it back to us in a string. Luckily, the `File` class has methods
    to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()` and pass in the `_textFile` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the new method''s code below:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new method that takes in a string parameter for the file we want
    to read
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file doesn't exist, there's no action needed so we exit out of the method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `ReadAllText()` method to get all the file's text data as a string
    and print it out to the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game and you'll see a console message with our previous save and a
    new one!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: Console message with saved text data read from file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s add a method to delete our text file if we wanted. We''re not
    actually going to use this method, as we want to keep our text file as is, but
    you can always try it out for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've dipped our toes a little deeper into the filesystem waters, it's
    time to talk about a slightly upgraded way of working with information — data
    streams!
  prefs: []
  type: TYPE_NORMAL
- en: Working with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been letting the `File` class do all of the heavy lifting with
    our data. What we haven't talked about is how the `File` class, or any other class
    that deals with reading and writing data, does that work under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: For computers, data is made up of bytes. Think of bytes as the computer's atoms,
    they make up everything—there's even a C# `byte` type. When we read, write, or
    update a file, our data is converted into an array of bytes, which are then streamed
    to or from the file using a `Stream`. The data stream is responsible for carrying
    the data as a sequence of bytes to or from a file, acting as a translator or intermediary
    for us between our game application and the data files themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: Diagram of streaming data to a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` class uses `Stream` objects for us automatically, and there are
    different `Stream` subclasses for different functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `FileStream` to read and write data to your files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `MemoryStream` to read and write data to memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `NetworkStream` to read and write data to other networked computers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `GZipStream` to compress data for easier storage and downloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we'll get into managing stream resources, using helper
    classes called `StreamReader`and `StreamWriter` to create, read, update, and delete
    files. You'll also learn how to format XML more easily using the `XmlWriter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your Stream resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important topic we haven't talked about yet is resource allocation. What
    that means is some processes in your code will put computing power and memory
    on a sort of layaway plan where you can't touch it. These processes will wait
    until you explicitly tell your program or game to close and return the layaway
    resources to you so you're back to full power. Streams are one such process, and
    they need to be closed after you're done using them. If you don't properly close
    your streams, your program will keep using those resources even though you're
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, C# has a handy interface called `IDisposable` that all `Stream` classes
    implement. This interface only has one method, `Dispose()`, which tells the stream
    when to give you back the resources it's been using.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to worry too much about this, as we'll cover an automatic way
    to make sure your streams are always closed correctly. Resource management is
    just a good programming concept to understand.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using a `FileStream` for the rest of the chapter, but we'll be doing
    so with convenience classes called `StreamWriter` and `StreamReader`. These classes
    leave out the manual conversion of data to bytes, but still use `FileStream` objects
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Using a StreamWriter and StreamReader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the `StreamWriter` and `StreamReader` classes serve as helpers for using
    objects belonging to `FileStream` to write and read text data to a specific file.
    These classes are a big help because they create, open, and return a stream you
    can use with minimal boilerplate code. The example code we've covered so far is
    fine for small data files, but streams are the way to go if you're dealing with
    large and complex data objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need is the name of the file we want to write to or read from and we''re
    all set. Your next task is to use a stream to write text to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new private string path for the new streaming text file and set its value
    in `Awake()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete or comment out the methods in `Initialize()` that we used in the previous
    section and add in our new code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the new method in the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file doesn't exist
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file hasn't been created yet, we add a new `StreamWriter` instance called
    `newStream`, which uses the `CreateText()` method to create and open the new file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the file is open, we use the `WriteLine()` method to add a header, close
    the stream, and print out a debug message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file already exists and we just want to update it, we grab our file through
    a new `StreamWriter` instance using the `AppendText()` method so our existing
    data doesn't get overwritten
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we write a new line with our game data, close the stream, and print
    out a debug message:![](img/B17573_12_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.14: Console messages for writing and updating text with a stream'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: New file created and updated with a stream'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading from a stream is almost exactly like the `ReadFromFile()` method we
    created in the last section. The only difference is that we''ll use a `StreamReader`
    instance to open and read the information. Again, you want to use streams when
    you''re dealing with big data files or complex objects instead of manually creating
    and writing to files with the `File` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method to `DataManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()` and pass in the `_streamingTextFile`
    as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our new code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file doesn't exist, and if it doesn't then we print out
    a console message and exit the method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file does exist, we create a new `StreamReader` instance with the name
    of the file we want to access and print out the entire contents using the `ReadToEnd`
    method:![](img/B17573_12_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 12.16: Console printing out saved data read from a stream'
  prefs: []
  type: TYPE_NORMAL
- en: As you'll start to notice, a lot of our code is starting to look the same. The
    only difference is our use of stream classes to do the actual reading-writing
    work. However, it's important to keep in mind how different use cases will determine
    which route you take. Refer back to the beginning of this section to review how
    each stream type is different.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've covered the basic features of a **CRUD** (**Creating**, **Reading**,
    **Updating**, **and** **Deleting**) application using text files. But text files
    aren't the only data format you'll be using in C# games and applications. You're
    likely to see lots of XML and JSON in the wild once you start working with databases
    and your own complex data structures, which text can't compare to in efficiency
    or storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll work with some basic XML data, then talk about an
    easier way to manage streams.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an XMLWriter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you won't just have plain old text to write and read from a file.
    Your project might require XML-formatted documents, in which case you'll need
    to know how to use a regular `FileStream` to save and load XML data.
  prefs: []
  type: TYPE_NORMAL
- en: Writing XML data to a file isn't all that different from what we've been doing
    with text and streams. The only difference is we'll explicitly create a `FileStream`
    and use it to create an instance of an `XmlWriter`. Think of the `XmlWriter` class
    as a wrapper that takes our data stream, applies XML formatting, and spits out
    our information as an XML file. Once we have that, we can structure the document
    in the proper XML format using methods from the `XmlWriter` class and close the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next task is to create a file path for a new XML document and add the
    ability to write XML data to that file using the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted `using` directive to the top of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method at the bottom of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()` and pass in `_xmlLevelProgress` as a
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our XML writing method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file already exists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file doesn't exist, we create a new `FileStream` using the new path variable
    we created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `XmlWriter` instance and pass it our new `FileStream`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the `WriteStartDocument` method to specify XML version 1.0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we call the `WriteStartElement` method to add the opening root element
    tag named `level_progress`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can add individual elements to our document using the `WriteElementString`
    method, passing in `level` as the element tag and the level number using a `for`
    loop and its index value of `i`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To close the document, we use the `WriteEndElement` method to add a closing
    `level` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we close the writer and stream to release the stream resources we've
    been using
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the game now, you''ll see a new `.xml` file in our **Player_Data**
    folder with the level progress information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: New XML file created with document data'
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that there is no indenting or formatting, which is expected because
    we didn't specify any output formatting. We're not going to use any of them in
    this example because we'll be talking about a more efficient way of writing XML
    data in the next section, on serialization.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the list of output formatting properties at [https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format).
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that reading an XML file is no different than reading any
    other file. You can call either the `readfromfile()` or `readfromstream()` methods
    inside `initialize()` and get the same console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B17573_12_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: Console output from reading the XML file data'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've written a few methods using streams, let's take a look at how
    to efficiently, and more importantly automatically, close any stream.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically closing streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're working with streams, wrapping them in a `using` statement automatically
    closes the stream for you by calling the `Dispose()` method from the `IDisposable`
    interface we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you never have to worry about unused allocated resources your program
    might be keeping open for no reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is almost exactly the same as what we''ve already done, except we
    use the `using` keyword at the beginning of the line, then reference a new stream
    inside a pair of parentheses, followed by a set of curly braces. Anything we want
    the stream to do, like read or write data, is done inside the curly braces block
    of code. For example, creating a new text file as we did in the `WriteToStream()`
    method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the stream logic is inside the code block, the outer `using` statement
    automatically closes the stream and returns the allocated resources to your program.
    From here on out, I'd recommend always using this syntax to write your streaming
    code. It's more efficient, much safer, and will demonstrate your understanding
    of basic resource management!
  prefs: []
  type: TYPE_NORMAL
- en: With our text and XML stream code working, it's time to move on. If you're wondering
    why we didn't stream any JSON data, it's because we need to add one more tool
    to our data toolbox—serialization!
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about serializing and deserializing data, what we're really talking
    about is translation. While we've been translating our text and XML piecemeal
    in previous sections, being able to take an entire object and translate it in
    one shot is a great tool to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition:'
  prefs: []
  type: TYPE_NORMAL
- en: The act of **serializing** an object translates the object's entire state into
    another format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The act of **deserializing** is the reverse, taking the data from a file and
    restoring it to its former object state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17573_12_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.19: Example of serializing an object into XML and JSON'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a practical example from the above image — an instance of our `Weapon`
    class. Each weapon has its own name and damage properties and associated values,
    which is called its state. The state of an object is unique, which allows the
    program to tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: An object's state also includes properties or fields that are reference types.
    For instance, if we had a `Character` class that had a `Weapon` property, C# would
    still recognize the weapon's `name` and `damage` properties when serializing and
    deserializing. You might hear objects with reference properties referred to as
    object graphs out in the programming world.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump in, it's worth noting that serializing objects can be tricky
    if you're not keeping a close eye on making sure the object properties match the
    data from a file, and vice versa. For example, if there's a mismatch between your
    class object properties and the data being deserialized, the serializer will return
    an empty object. We'll cover this in more detail when we try to serialize a C#
    list into JSON later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To really get the hang of this, let's take our `Weapon` example and turn it
    into working code.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your task for the rest of this chapter is to serialize and deserialize a list
    of weapons into XML and JSON, with XML going first!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a serializable attribute to the `Weapon` class so Unity and C# know the
    object can be serialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two new variables, one for the XML file path and one for the list of weapons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the XML file path value in `Awake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method at the bottom of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an `XmlSerializer` instance and pass in the type of data we''re
    going to be translating. In this case, the _`weaponInventory` is of type `List<Weapon>`,
    which is what we use in the `typeof` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `XmlSerializer` class is another helpful formatting wrapper, just like the
    `XmlWriter` class we used earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create a `FileStream` using the `_xmlWeapons` file path and wrapped
    in a `using` code block to make sure it's closed properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `Serialize()` method and pass in the stream and the data
    we want to translate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game again and take a look at the new XML document we created without
    having to specify any additional formatting!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.20: XML output in the weapon inventory file'
  prefs: []
  type: TYPE_NORMAL
- en: 'To read back our XML into a list of weapons, we set up everything almost exactly
    same except we use the `Deserialize()` method from the `XmlSerializer` class instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the bottom of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize` and pass in the `_xmlWeapons` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the `deserialize()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file exists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file exists, we create an `XmlSerializer` object and specify that we're
    going to put the XML data back into a `List<Weapon>` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we open up a `FileStream` with the `_xmlWeapons` file name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using `File.OpenRead()` to specify that we want to open the file for reading,
    not writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we create a variable to hold our deserialized list of weapons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We put the explicit `List<Weapon>` cast in front of the call to `Deserialize()`
    so that we get the correct type back from the serializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use a `foreach` loop to print out each weapon's name and damage
    values in the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the game once again, you'll see that we get a console message for
    each weapon we deserialized from the XML list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.21: Console output from deserializing XML'
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to do for XML data, but before we finish out the chapter
    we still need to learn how to work with JSON!
  prefs: []
  type: TYPE_NORMAL
- en: Serializing and deserializing JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to serializing and deserializing JSON, Unity and C# aren't completely
    in sync. Essentially, C# has its own `JsonSerializer` class that works the exact
    same way as the `XmlSerializer` class we used in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: In order to access the JSON serializer, you need the `System.Text.Json` `using`
    directive. Here's the rub—Unity doesn't support that namespace. Instead, Unity
    uses the `System.Text` namespace and implements its own JSON serializer class
    called `JsonUtility`.
  prefs: []
  type: TYPE_NORMAL
- en: Because our project is in Unity, we're going to work with Unity's supported
    serialization class. However, if you're working with a non-Unity C# project, the
    concepts are the same as the XML code we just wrote.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete how-to that includes code from Microsoft at [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your next task is to serialize a single weapon to get the hang of the `JsonUtility`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new method at the bottom of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()` and pass in the `_jsonWeapons` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown of the serialize method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a weapon to work with, so we create one with our class initializer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we declare a variable to hold the translated JSON data when it''s formatted
    as a string and call the `ToJson()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ToJson()` method we're using takes in the `sword` object we want to serialize
    and a Boolean value of `true` so the string is pretty printed with proper indenting.
    If we didn't specify a `true` value, the JSON would still print out, it would
    just be a regular string, which isn't easily readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a text string to write to a file, we create a `StreamWriter`
    stream and pass in the `_jsonWeapons` file name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the `WriteLine()` method and pass it the `jsonString` value
    to write to the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the program and look at the new JSON file we created and wrote data into!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.22: JSON file with weapon properties serialized'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try and serialize our list of weapons we used in the XML examples
    and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SerializeJSON()` method to use the existing list of weapons instead
    of the single `sword` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the game again, you''ll see the JSON file data was overwritten
    and all we ended up with is an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.23: JSON file with an empty object after serialization'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is because the way Unity handles JSON serialization doesn't support
    lists or arrays by themselves. Any list or array needs to be part of a class object
    for Unity's `JsonUtility` class to recognize and handle it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Don't panic, if we think about this, it's a fairly intuitive fix—we just need
    to create a class that has a weapons list property and use that when we serialize
    our data into JSON!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Weapon.cs` and add the following serializable `WeaponShop` class to the
    bottom of the file. Be super careful to put the new class outside the `Weapon`
    class curly braces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `DataManager` class, update the `SerializeJSON()` method with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the changes we just made:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new variable called `shop`, which is an instance of the `WeaponShop`
    class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we set the `inventory` property to the `weaponInventory` list of weapons
    we already declared
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we pass the `shop` object to the `ToJson()` method and write the new
    string data to the JSON file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the game again and look at the pretty printed list of weapons we''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.24: List object properly serialized into JSON'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserializing JSON text back into an object is the reverse process of what
    we just did:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method at the bottom of the `DataManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the new method in `Initialize()` and pass `_jsonWeapons` in as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the `DeserializeJSON()` method below:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if the file exists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does exist, we create a stream with the `_jsonWeapons` file path wrapped
    in a `using` code block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the stream's `ReadToEnd()` method to grab the entire JSON text
    from the file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create a variable to hold our deserialized list of weapons and call
    the `FromJson()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we specify that we want to turn our JSON into a `WeaponShop` object
    with the `<WeaponShop>` syntax before passing in the JSON string variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we loop through the weapon shop's `inventory` list property and print
    out each weapon's name and damage values in the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the game one last time and you''ll see a console message printed out for
    each weapon in our JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_12_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.25: Console output from deserializing a list of JSON objects'
  prefs: []
  type: TYPE_NORMAL
- en: Data roundup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every individual module and topic we've covered in this chapter can be used
    by itself or combined to suit your project's needs. For example, you could use
    text files to store character dialogue and only load it when you need to. This
    would be more efficient than having the game keep track of it every time it runs,
    even when the information isn't being used.
  prefs: []
  type: TYPE_NORMAL
- en: You could also put character data or enemy statistics into either an XML or
    JSON file and read from the file anytime you need to level up a character or spawn
    a new monster. Finally, you could fetch data from a third-party database and serialize
    it into your own custom classes. This is a super common scenario with storing
    player accounts and external game data.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a list of data types that can be serialized in C# at [https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer).
    Unity handles serialization a little differently, so make sure you check the available
    types at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  prefs: []
  type: TYPE_NORMAL
- en: The point I'm trying to make is that data is everywhere, and it's your job to
    create a system that handles it the way your game needs, brick by brick.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And that's a wrap on the basics of working with data! Congratulations on making
    it through this monster chapter intact. Data in any programming context is a big
    topic, so take everything you've learned in this chapter as a jumping-off point.
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to navigate the filesystem, and create, read, update, and
    delete files. You also learned how to effectively work with text, XML, and JSON
    data formats, as well as data streams. And you know how to take an entire object's
    state and serialize or deserialize it into both XML and JSON. All in all, learning
    these skills was no small feat. Don't forget to review and revisit this chapter
    more than once; there's a lot here that might not become second nature on the
    first run-through.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – data management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which namespace gives you access to the `Path` and `Directory` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, what folder path do you use to save data between runs of your game?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What data type do `Stream` objects use to read and write information to files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you serialize an object into JSON?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG

- en: '*Chapter 8*: Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about the language syntax, data types,
    working with classes and structures, generics, collections, and other topics that
    have equipped you with the knowledge necessary to write at least simple C# programs.
    However, there's more to the language than that and in this chapter, we will explore
    more advanced concepts. This will include delegates, which are key for functional
    and asynchronous programming that we cover later in this book, as well as various
    forms of pattern matching including regular expressions for texts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will discuss are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will understand how to use delegates to respond
    to events that occur in your application, how to use tuples to handle multiple
    values without introducing new types, how to perform pattern matching in code
    with `is` and `switch` expressions as well as search and replace texts using regular
    expressions. Last, but not least, you will learn how to extend types without modifying
    their actual source code with the help of extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin this chapter by learning about delegates and events.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **callback** is a function (or more generally, any executable code) that is
    passed as a parameter to another function in order to be called immediately (**synchronous
    callbacks**) or at a later time (**asynchronous callbacks**). Operating systems
    (such as Windows) use callbacks extensively to allow applications to respond to
    events such as mouse events or key presses. Another typical example for callbacks
    is general purpose algorithms that use callbacks for processing elements from
    a collection, such as comparing them in order to sort them or filter them out.
  prefs: []
  type: TYPE_NORMAL
- en: In languages such as C and C++, a callback is simply a *function pointer* (that
    is, the address of a function). However, in .NET, callbacks are *strongly-typed
    objects* that hold not only the reference to one or more methods but also the
    information about their parameters and return type. In .NET and C#, callbacks
    are represented by delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `delegate` keyword. The declaration looks like a function signature, but the
    compiler actually introduces a class that can hold references to methods whose
    signatures match the signature of the delegate. A delegate can hold references
    to either *static* or *instance methods*.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the way delegates are defined and used, we will consider
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a class that represents an engine. There can be different things the
    engine can do but we will focus on starting and stopping this engine. When these
    events happen, we want to let the clients using the engine to know about this
    and give them the chance to do something. For simplicity, the client will only
    log the event to the console. In this simple model, the engine can be in any of
    these two states: `StatusChange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`StatusChange` is not a function but a *type*. We will use this for declaring
    a variable in the engine that will hold a reference to a callback method. The
    class that represents the engine is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `RegisterStatusChangeHandler()` method takes an argument of the delegate
    type (`StatusChange`) and assigns it to the `statusChangeHandler` member field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the `Start()` and `Stop()` methods do not actually do much (for simplicity
    only), but you can imagine they are performing a start and a stop of the engine.
    However, after this, they invoke the callback, just like a regular function, passing
    all the necessary arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the delegate does not return any value, but a delegate can
    return anything. However, before invoking the callback method, a *null check*
    is performed. If the delegate was not assigned a reference to a method, invoking
    the delegate results in `NullReferenceException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client code creates an instance of the `Engine` class, registers a handler
    for status changes, and then starts and stops its. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The static method, `OnEngineStatusChanged()`, is used as a callback for the
    engine start and stop events. Its signature matches the type of the delegate.
    Executing this program results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An important aspect of .NET delegates is that they support *multicasting*. This
    means that you can actually set references to as many methods you want to be called;
    the delegate will then invoke them in the order they are added. Multicast delegates
    are represented by the `System.MulticastDelegate` class. This class has, internally,
    a linked list of delegates that is called an *invocation list*. This list can
    have any number of elements. When the multicast delegate is invoked, all of the
    delegates in the invocation list are called in the order they appear in the list
    (which is the order in which they were added). This operation is synchronous and
    if any error appears during the execution of the invocation list, an exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you can remove a reference to a method from the delegate
    when you no longer want it to be called. Both of these aspects will be exemplified
    in the following example where we change the `Engine` class to allow multiple
    callbacks to be not only registered but also unregistered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, there are two things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `RegisterStatusChangeHandler()` method no longer simply assigns its
    argument to the `statusChangeHandler` field, but actually uses the `+=` operator
    to add a new reference to the list the delegate is holding internally. Consequently,
    the `UnregisterStatusChangeHandler()` method is using the `-=` operator to remove
    a reference from the delegate. The `+=` and `-=` operators are overloaded for
    the delegate types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the code in `Start()` and `Stop()` has slightly changed. The null-conditional
    operator (`?.`) is used to call the `Invoke()` method only if the object is not
    `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the changes in the main program are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we register two callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that records the event on the *console*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that records to a *file*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start and stop the engine and then we unregister the callback that logs
    to the file on disk. Last, we start the engine again. As a result, the output
    on the console will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, only the first two lines also appear on the file on disk, because the
    second callback was removed before restarting the engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this second example, we used the `Invoke()` method to call the methods referred
    by the delegate. Where did the `Invoke()` method come from? Behind the scenes,
    when you declare a delegate type, the compiler generates a sealed class derived
    from `System.MulticastDelegate` that in turn is derived from `System.Delegate`.
    These are system types that you are not allowed to derive explicitly from. However,
    they provide all of the functionalities we have seen so far, such as the ability
    to add and remove methods from the delegate's invocation list.
  prefs: []
  type: TYPE_NORMAL
- en: The class created by the compiler contains three methods—`Invoke()` (used to
    invoke the callbacks in a *synchronous manner*), `BeginInvoke()`, and `EndInvoke()`
    (used to invoke the callbacks in an *asynchronous manner*). For examples of asynchronous
    delegates, consult additional references. You can actually check the compiler-generated
    code by opening the assembly in a disassembler such as **ildasm.exe** or **ILSpy**.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code we have written so far is a little too *explicit*. We had to create
    methods for registering and unregistering references to callback methods. That
    was because the delegate that held those references was private in the class.
    We could make it public, but then we break encapsulation and risk allowing the
    clients to erroneously overwrite the delegate's invocation list. To help with
    these aspects, .NET and C# offer *events*, which are simply syntactic sugar for
    the explicit code we wrote earlier for registering and unregistering callbacks.
    Events are introduced with the `event` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last implementation of the engine will change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we no longer have the methods for registering and unregistering
    callbacks, only an event object called `StatusChanged`. These are done in the
    client code on the event object, using the `+=` (to add a reference to a method)
    and `-=` (to remove a reference to a method) operators. We can see the client
    code in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create an `Engine` object and register to callbacks for
    the `StatusChanged` event—one is a reference to the `OnEngineStatusChanged()`
    method (that logs the event to a file) and the other one is a lambda expression
    (that logs the event to the console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After starting and stopping the engine, we unregister the reference to `OnEngineStatusChanged()`
    and then restart the engine. The result of executing this program is identical
    to the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of the examples so far, the delegate type had a single argument that
    was the status of the engine. However, proper implementation of the event''s pattern
    (used throughout the entire .NET Framework) is to have two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is `System.Object`, which holds a reference to the object
    that generated the event. It is up to the client being called to use this reference
    or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is of a type derived from `System.EventArgs`, which holds
    all of the event-related information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To comply with this pattern, our implementation of `Engine` will change to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will leave it as an exercise to the reader to make the necessary changes
    to the main program to use the new implementation of the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key takeaways about delegates and events are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegates allow methods to be passed as arguments to be called later, either
    synchronously or asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates support multicasting, that is, the invocation of multiple callback
    methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods, instance methods, anonymous methods, and lambda expressions
    can be used as callbacks with delegates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates can be generic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are syntactic sugar that help with registration and removal of callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next topic to discuss in this chapter are anonymous types.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes necessary to construct temporary objects that hold some values,
    usually a subset of some larger object. To avoid creating a specific type for
    this purpose only, the language provides so-called *anonymous types*. These are
    a sort of use-and-forget types typically used in query expressions with **Language
    Integrated Query** (**LINQ**). This topic will be discussed in [*Chapter 10*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184),
    *Lambdas, LINQ, and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: These types are called anonymous because you do not specify a name in the source
    code. The name is assigned by the compiler. They consist of read-only properties
    only; any other member type is not allowed. The type of the read-only properties
    cannot be explicitly specified and is inferred by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'An anonymous type is introduced with the `new` keyword followed by a list of
    properties in angle-brackets (an object initializer). The following code snippet
    shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined an anonymous type with three properties: `Name`, `Capacity`,
    and `Power`. The types of these properties are inferred by the compiler from their
    initialization value. In this case, they are `string` for `Name`, `int` for `Capacity`,
    and `double` for `Power`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is mandatory to specify a name for a property when it is initialized from
    an expression. However, if it is initialized from a field or property of another
    object, the name is optional. In this case, the compiler uses the same name as
    that of the member used to initialize it. To show an example, let''s consider
    the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have created an instance of the `Engine` class. From this instance, we have
    created another object of an anonymous type that has two properties, which the
    compiler calls `Name` and `Power` because they are initialized from the `Name`
    and `Power` properties of the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous types have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are implemented as sealed classes and are, therefore, reference types.
    The CLI does not make any difference between anonymous types and other reference
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are directly derived from `System.Object` and can only be cast to `System.Object`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only contain read-only properties. No other members are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot be used as the type of a field, property, event, the return type
    of a method, or the type of a parameter of a method, constructor, or indexer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify names for the read-only properties of an anonymous type. This
    is mandatory when initializing from an expression, but optional when initializing
    from a field or property. In this case, the compiler uses the name of the member
    for the property's name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression used to initialize a property cannot be null, an anonymous function,
    or a pointer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of an anonymous type is the method in which it is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you declare a variable of an anonymous type, you must use `var` as a placeholder
    for the type name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A similar concept of ad hoc types but with different semantics is presented
    by tuples, which is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`out` or `ref` parameters or when you want to pass multiple values to a method
    as a single object.'
  prefs: []
  type: TYPE_NORMAL
- en: This aspect represents the key difference between anonymous types and tuples.
    The former is meant for use within the scope of a single method and cannot be
    passed as an argument or returned from a method. The latter are intended for this
    exact purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, there are two kinds of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Tuple` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.ValueTuple` structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, we will look at both of these types.
  prefs: []
  type: TYPE_NORMAL
- en: The Tuple class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reference tuples were introduced in .NET Framework 4.0\. The generic class,
    `System.Tuple`, can hold up to eight values of different types. Should you need
    tuples with more than eight values, you will have to create nested tuples. Tuples
    can be instantiated in either of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the *constructor* of `Tuple<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the *helper method*, `Tuple.Create()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two lines are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second line here is preferred because it is simpler as you do not have to
    specify the type of each value. This is because it is inferred by the compiler
    from the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of the tuple are accessible through properties called `Item1`,
    `Item2`, `Item3`, `Item4`, `Item5`, `Item6`, `Item7`, and `Rest`. In the following
    example, we use the `Item1`, `Item2`, and `Item3` properties to print the engine
    name, capacity, and power to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Nested tuples can be used when you need more than eight elements. In this case,
    it makes sense to put the nested tuple as the last element. The following example
    creates a tuple with 10 values, the last three of them (representing various engine
    powers in kW) being grouped in a second, nested tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice here that we used `Rest.Item1` and not simply `Rest`. The output of
    this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that the inferred type for the variable engine is `Tuple<string,
    int, int, double, int, string, int, Tuple<Tuple<int, int, int>>>`. Consequently,
    `Rest` represents a tuple that holds a single value that is also a tuple that
    holds three `int` values. To access the elements of the nested tuple, you must
    use, for this case, `Rest.Item1.Item1`, `Rest.Item1.Item2`, and `Rest.Item1.Item3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a tuple of the type, `Tuple<string, int, int, double, int, string,
    int, Tuple<int, int, int>>`, you must use the explicit syntax using constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`System.Tuple` is a reference type and therefore objects of this type are allocated
    on the heap. If many allocations of small objects occur during the execution of
    a program, it can impact performance.'
  prefs: []
  type: TYPE_NORMAL
- en: This adds to the limitations we have seen earlier—the number of elements and
    the unnamed properties. To overcome these problems, C# 7.0, .NET Framework 4.7,
    and .NET Standard 2.0 have introduced value type tuples, which we will explore
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Value tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are represented by the `System.ValueTuple` structure. If your project
    does not target .NET Framework 4.7 or higher or .NET Standard 2.0 or higher, you
    can still use `ValueTuple` by installing it as a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Various value tuple features have been added in the several 7.x releases of
    the languages. The functionalities described here are aligned with C# 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the value semantics, value tuples differ from the reference tuples
    in several important ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They can hold a sequence of any number of elements, but at least two are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may have compile-time named fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a simpler, yet richer syntax for creating, assigning, deconstructing,
    and comparing values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a value tuple is done using *parentheses syntax* with values specified
    in between. The following three declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In all these cases, the type of the variable engine is `ValueTuple<string,
    int, double>` and the tuple is said to be *unnamed*. In this case, its values
    are available in the public fields—`Item1`, `Item2`, and `Item3`, which are implicit
    names assigned by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when creating a value tuple, you can choose to give names to the values
    and therefore create synonyms for the fields, `Item1`, `Item2`, and so on. Such
    value tuples are called **named tuples**. You can see an example of a named tuple
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These synonyms are only available at compile time because IDEs leverage the
    Roslyn APIs to make them available for you from the source code, but in the compiler
    intermediate language code, they are not available, only the unnamed fields—`Item1`,
    `Item2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of a field can appear on either side of the assignment; moreover,
    they can appear on both sides, in which case the *left name* will take *precedence*
    and the *right name* will be *ignored*. The following two declarations will produce
    a named value tuple identical to the one seen in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The names for the fields can also be inferred from variables used to initialize
    the value tuple (as for C# 7.1). In the following example, the value tuple will
    have fields called `name`, `capacity` (lowercase), and `Item3` because the last
    value is a literal without an explicitly specified name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning value tuples from a method is very simple. In the following example,
    the `GetEngine()` function returns an unnamed value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can choose to return a named value type, in which case, you need
    to specify the names of the fields, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Beginning with C# 7.3, value tuples can be tested for *equality* and *inequality*
    using the `==` and `!=` operators. These operators work by comparing, in order,
    each element from the left side with each element on the right side. The comparison
    stops when the first pair is not equal. However, this only happens when the shape
    of the tuples is the same, that is, the number of fields and their type. The names
    do not participate in the test of equality or inequality. The next example does
    a comparison of two value tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Tuple equality** performs a *lifted conversion* if one tuple is a nullable
    tuple, as well as *implicit conversions* on each member of both tuples. The latter
    include lifted conversions, widening conversions, or other implicit conversions.
    As an example, the following tuples are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to deconstruct the value of a tuple. You can do so either by
    explicitly specifying the type of the variables or using `var`. The following
    declarations are all equivalent. In the following and last example, the use of
    `var` is combined with explicit type names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are values that you are not interested in, you can ignore them by
    using the `_` placeholder like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to deconstruct any .NET type provided that a method called `Deconstruct`
    with `out` parameters for every value that you want to retrieve is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Engine` class has three properties: `Name`,
    `Capacity`, and `Power`. The `Deconstruct()` public method takes three out arguments
    matching these properties. This makes it possible for objects of this type to
    be deconstructed using tuple syntax. The following listing shows an implementation
    of the `Engine` class that provides tuple deconstruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Deconstruct` method can be made available as an extension method, enabling
    you to provide deconstruction semantics even for types you did not author, provided
    that you only need to deconstruct values accessible through the public interface
    of the type. Such an example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a hierarchy of classes and you provide `Deconstruct()` methods,
    then you must make sure you do not introduce ambiguities, such as in cases where
    different overloads have the same number of arguments. It should be noted that
    deconstruction operators do not participate in testing equality. Therefore, the
    following sample will generate a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Summarizing on this topic, the support for value tuples in C# 7 makes it much
    easier to work with tuples in key scenarios such as holding temporary values or
    records from a database. This can be done without introducing new types or returning
    multiple values from a method without the use of `out` or `ref` parameters. With
    the performance benefit of value semantics and the improvements on element access
    based on names, as well as other key features, named values are an important improvement
    on the reference type tuples that we saw at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`if` and `switch` statements when we check whether an object has some value
    and then proceed to extract information from it. However, this is a rudimentary
    form of pattern matching.'
  prefs: []
  type: TYPE_NORMAL
- en: In C# 7, new capabilities are added to `is` and `switch` statements to enable
    pattern matching capabilities that drive a better separation of data and code
    and lead to more concise and readable code. The pattern matching capabilities
    are extended with new features in C# 8\. You will learn about these in [*Chapter
    15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271), *New Features of C# 8*.
  prefs: []
  type: TYPE_NORMAL
- en: The is expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At runtime, the `is` operator checks that an object is compatible with a given
    type (the general form, `expr is type`). However, in C# 7, this was extended to
    include several forms of pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expr is type varname` form, checks whether an expression can be converted
    to the specified type and, if so, casts it to a variable of that specified type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expr is constant` form, checks whether the expression evaluates to a specified
    constant. A particular constant is `null`, for which the pattern is `expr is null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expr is var varname` form, that always succeeds and binds the value to a new
    local variable. A key difference from the type pattern is that `null` is always
    matched and the new variable is assigned `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how these work, we will use several classes representing vehicles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These vehicle classes are not a part of a hierarchy of classes, but they have
    public methods that set the vehicle in motion, according to its type. For example,
    the airplane flies, the bike rides, and the car drives. The next code listing
    shows a function that uses several forms of pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function sets the vehicle in motion according to its specific way of doing
    so. A statement like `if(vehicle is Airplane a)` tests whether the variable vehicle
    can be converted to the `Airplane` type, and if that is true, then it assigns
    it to a new variable of the `Airplane` type (in this example, `a`). This works
    with both value types and reference types.
  prefs: []
  type: TYPE_NORMAL
- en: The variables seen here—`a`, `b`, and `c`—have a local scope to the `if` or
    `else` statement. However, these variables are in scope and definitely assigned
    only when the match was successful. This prevents you from accessing the result
    of a pattern-matching expression when the pattern was not matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as the type pattern, a constant pattern is also used here. The `if
    (vehicle is null)` statement is a test to see whether the reference is actually
    set to the instance of an object or not; if not, an exception is thrown. However,
    as already mentioned, constant pattern matching can be used with anything that
    is a constant—a literal value, a variable declared with the const specifier, or
    an enumeration value. The way constant expressions are evaluated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If both `expr` and constant are of integral types, it basically evaluates the
    `expr == constant` expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it invokes the static method, `Object.Equals(expr, constant)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following function shows more examples of constant pattern matching. The
    `IsTrue()` function converts the supplied argument to a Boolean value. The Boolean
    value (`true`), the integral value (`1`), the string (`"1"`), and the string (`"true"`)
    are converted to `true`; everything else including `null` is converted to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The switch expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more patterns you need to check, the more cumbersome it is to write these
    sorts of `if-else` statements. Naturally, you would want to replace them with
    a `switch`. Pattern matching of the same nature is supported for `switch` statements
    with a similar syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Until C# 7.0, the `switch` statement supported constant pattern matching with
    integral types and strings. Since C# 7.0, the type pattern seen earlier is also
    supported in a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SetInMotion()` function shown in the previous section can be modified
    as follows using a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statements that use constant pattern matching can only have one
    case label that matches the value of the `switch` expressions. Moreover, `switch`
    sections must not fall through the next section but must end with `break`, `return`,
    or `goto`. However, they can be arranged in any order without affecting the behavior
    of the program semantics and execution.
  prefs: []
  type: TYPE_NORMAL
- en: With type pattern matching, the rules change. The `switch` section can fall
    through the next and `goto` is no longer supported as a jump mechanism. The case
    label expressions are evaluated in the order they appear in the text and the default
    case is only executed if none of the case labels match the pattern. The default
    case can appear anywhere in `switch` but it is always evaluated last.
  prefs: []
  type: TYPE_NORMAL
- en: If a default case is missing and none of the existing case labels match the
    pattern, the execution continues after the `switch` statement without any code
    in any case label executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of type pattern matching with the `switch` expression is the
    support for `when` clauses. The following example shows another version of the
    `SetInMotion()` method that uses two case labels to match the `Car` type, but
    one of them with a condition—that the `HasAutoDrive` property of the `Car` object
    is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that matching a type pattern guarantees a *non-null
    value*, so there is no need for further tests for `null`. There are special rules
    for matching `null` in the language. A `null` value does not match a type pattern,
    regardless of the type of the variable. A case label with a pattern matching for
    `null` can be added in a switch expression with a type pattern matching to specifically
    handle `null` values. Such an example is seen in the preceding implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A special form of type pattern matching is using `var`. The rules are similar
    to `is` expressions—the type is inferred from the static type of the switch expression
    and a `null` value always matches. Therefore, when using the `var` pattern, you
    must add an explicit `null` check because the value may actually be `null`. A
    `var` declaration may match the same condition as the default case; in this situation,
    a default case, even if present, would never execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following function that executes a command received as a
    string argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function tries to match the `add`, `del`, and `exit` commands and execute
    them appropriately. However, if the argument is `null` or empty or has only white
    spaces, it will do nothing. But this is a different case than an actual command
    that is either not supported or not recognized. The `var` pattern match helps
    to differentiate between the two in a simple and elegant manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key takeaways for you for this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching functionalities added in C# 7.0 are an incremental update of
    already existing simple pattern matching capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new supported patterns are the constant pattern, the type pattern, and the
    `var` pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching works with `is` expressions and case blocks in `switch` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` expression pattern matching supports `where` clauses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `var` pattern always matches any value including `null` and, therefore,
    a test for `null` is necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C# 8.0 has introduced even more capabilities to the switch expression pattern
    matching: property patterns, tuple patterns, and positional patterns. You can
    learn about these in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features on C# 8*.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another form of pattern matching is represented by regular expressions. A `System.Text.RegularExpressions`
    namespace. In the following pages, we will look at how you can use this class
    to match an input text, find parts of it, or replace portions of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are composed of constants (that represent sets of strings)
    and operator symbols (that represent operations on these sets). The actual language
    for building regular expressions is more complex than what can be described in
    the scope of this chapter. If you are not familiar with regular expressions, we
    recommend using additional resources for learning them. You can also build and
    test your regul[ar expressions using](https://regex101.com/) onli[ne tools such
    as ht](https://regexr.com/)tps://regex101.com/ or https://regexr.com/.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions in .NET are built based on the Perl 5 regular expressions.
    As such, most of Perl 5 regular expressions are compatible with .NET regular expressions.
    On the other hand, the framework supports another flavor of expressions, called
    **ECMAScript**, which is basically another name for JavaScript (**ECMAScript**
    is actually an ECMA standard for scripting-languages, and JavaScript is its best-known
    implementation). However, when using regular expressions, you must explicitly
    specify this flavor instead. The implementation of the .NET regular expressions
    has remained the same since .NET 2.0 and is the same in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the features supported by this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Case-insensitive matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-to-left searching (for languages such as Arabic, Hebrew, or Persian that
    have a right-to-left writing system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-line or single-line searching modes that change the meaning of some symbols,
    such as `ˆ`, `$` or `.` (dot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to compile a regular expression to an assembly and to increase
    performance when a pattern is used to search a large number of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinite-width look-behind that enables us to step back to any length and check
    in the string whether the text inside the look-behind can be matched there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character class subtraction that allows you to specify one character class to
    subtract from another character class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing groups that allow you to ensure that a subexpression is matched to
    an equal number of types as another one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these functionalities are enabled with a flag provided as an argument
    to the constructor of the `Regex` class. The `RegexOptions` enumeration provides
    the following flags, which can be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_8_Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move to the next section to look at how to actually use regular expressions
    in C#, there are two more important things to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: First, regular expressions have a set of special characters. One of them is
    `\` (backslash). In combination with another literal character, this creates a
    new token with a special meaning. For instance, `\d` matches any single digit
    from 0 to 9\. Since the backslash is also a special character in C# used for introducing
    character escape sequences, when you write a regular expression in a string, you
    need to use double backslashes, such as `"(\\d+)"`. However, you can use verbatim
    strings to avoid this and keep the regular expression in its natural form. The
    previous example can be written as `@"(\d+)"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other important thing to notice is that the `Regex` class implicitly assumes
    UTF-8 encoding of the string to match. That means the `\w`, `\d`, and `\s` tokens
    match any UTF-8 codepoint that is a valid character, digit, or whitespace character
    in any language. As an example, if you use `\d+` to match any positive number
    of digits, you might be surprised to discover that it will match not just 0-9
    but also the following characters:![](img/Figure_8.1_B12346.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to restrict matching to English digits for `\d`, English digits
    and letters and underscore for `\w`, and standard whitespace characters for `\s`,
    then you need to use the `RegexOptions.ECMAScript` option.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to define regular expressions and use them to figure out whether
    some text matches an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Matching input text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest functionality that regular expressions provide is checking whether
    an input string has a required format. This is useful for performing validation
    such as checking whether a string is a valid email address, IP address, date,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, we will validate whether an input text is a valid
    ISO 8061 date. For simplicity, we will only consider the form *YYYY-MM-DD*, but
    as an exercise, you can extend this to support other formats. The regular expression
    we will use for this is `(\d{4})-(1[0-2]|0[1-9]|[0-9]{1})-(3[01]|[12][0-9]|0[1-9]|[1-9]{1})`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broken down into parts, the sub-expressions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_8_Table_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following two examples are equivalent. The `Regex` class has both static
    and non-static overloads for `IsMatch()`, and you can use any of the two with
    the same results. This is also the case for other methods, which we will see in
    the following sections, such as `Match()`, `Matches()`, `Replace()`, and `Split()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you need to match a pattern only once or a few times, then you could use
    the static methods as they are simpler. However, if you match the same pattern
    tens of thousands of times or more, using an instance of the class and calling
    the non-static members is potentially faster. For most common usage, this is not
    the case. In the following examples, we will only use the static methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IsMatch()` method has overloads that enable us to specify options for
    the regular expression and a timeout interval. This is useful when the regular
    expression is too complicated, or the input text is too long, and the parsing
    takes more than the desired amount of time. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we enable ECMAScript-compliant behavior of the regular expression and
    set a timeout value of one millisecond.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to match text, let's learn how you can search for substrings
    and multiple occurrences of a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finding substrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples so far, we only checked whether the input text was of a specific
    pattern. But it is also possible to get information about the result. This includes,
    for instance, the text matched in each caption group, the entire matched value,
    the position in the input text, and so on. To do this, another set of overloads
    must be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Match()` methods check an input string for substrings that match a regular
    expression and return the first match. The `Matches()` methods do the same search
    but return all of the matches. The return type is `System.Text.RegularExpressions.Match`
    (that represents a single match) for the former and `System.Text.RegularExpressions.MatchCollection`
    (that represents a collection of matches) for the latter. Let''s consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first value printed to the console is `2019-12-25` because that is the value
    of the entire match. The second is a value composed of the individual values of
    each capture group, but with a dot (`.`) as the separator. Consequently, the output
    text is `2019.12.25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture groups may have names; the form is `(?<name>...)`. In the following
    example, we call the three capture groups of the regular expression, `year`, `month`,
    and `day`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Should the input text have multiple substrings that match the pattern, we can
    get all of them using the `Matches()` function. In the following example, dates
    are provided one per line, but the last two are not valid (`2019-13-21` and `2019-1-32`);
    therefore, these are not found in the results. To parse the string, we use the
    multiline option, so that `^` and `$` refer to the beginning and the end of each
    line and not to the entire string, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we don't just want to find substrings of an input text; we also want
    to replace them with something else. This topic is discussed in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing parts of a text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions can also be used to replace parts of a string that match
    the regular expression with another string. The `Replace()` method has a set of
    overloads, and you can specify either a string or a so-called `Match` argument
    and returns a string. In the following example, we will use this to change the
    format of date from *YYYY-MM-DD* to *MM/DD/YYYY*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As a further exercise, you can write a program that converts an input date of
    the form 2019-12-25 to the form Dec 25, 2019.
  prefs: []
  type: TYPE_NORMAL
- en: As a conclusion to this section, regular expressions offer rich pattern matching
    capabilities. .NET provides the `Regex` class that represents a regular expression
    engine with plenty of functionalities. In this section, we have seen how to match,
    search, and replace texts based on a pattern. These are common operations that
    you will encounter in a large variety of applications. You can choose between
    static and instance overloads of these methods and customize the way they work
    with various options.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is sometimes useful to add functionality to a type without changing the
    implementation, creating a derived type, or recompiling code in general. We can
    do that by creating methods in helper classes. Let''s say we want to have a function
    that reverses the content of a string because `System.String` does not have one.
    Such a function can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The C# language allows us to define this function in a way that enables us
    to call it as if it was an actual member of `System.String`. Such functions are
    called `Reverse()` method to make it an extension method. The new implementation
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the only change to the implementation is the `this` keyword in
    front of the function parameter. With these changes, the function can be invoked
    as if it was part of the string class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following rules apply to the definition and the behavior of extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: They can extend classes, structures, and enumerations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They must be declared as a static method of a static, non-nested, non-generic
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their first parameter is the type they add functionality to. This parameter
    is preceded by the `this` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only invoke public members of the type they extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are only available when the namespace in which they are declared is brought
    into the current scope with a `using` directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an extension method (that is available in the current scope) has the same
    signature as an instance method of the class, the compiler will always prefer
    the instance member and the extension method will never be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows an extension method called `AllMessages()` that
    extends the functionality of the `System.Exception` type. This represents an exception
    and has a message but can also contain an inner exception. This extension method
    returns a string composed by concatenating all of the messages of all of the nested
    exceptions. The Boolean argument indicates whether the messages should be concatenated
    from the main exception to the most inner one or in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The extension method can be then invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The most common extension methods from .NET are the LINQ standard operators
    that extend the `IEnumerable` and `IEnumerable<T>` types. We will explore LINQ
    in [*Chapter 10*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184), *Lambdas, LINQ,
    and Functional Programming*. If you implement extension methods to extend a type
    you cannot change, you must keep in mind that future changes to the type may break
    the extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we addressed a series of advanced language features. We started
    with delegates and events that implement callbacks in a strongly-typed manner.
    We continued anonymous types and with tuples, which are lightweight types that
    can hold any value and help us to avoid defining new explicit types. We then looked
    at pattern matching, which is the process of checking whether a value has a particular
    shape as well as extracting information about it. We continued with regular expressions,
    which are patterns with a well-defined grammar that can be matched against a text.
    Lastly, we learned about extension methods that make it possible to add functionality
    to types without changing their implementation, such as when we don't own the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss garbage collection and resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are callbacks and how are these related to delegates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define delegates? What about events?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many types of tuples exist? What are the key differences between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are named tuples and how do you create them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is pattern matching and what statements can it be used with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the rules for pattern matching null?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What class implements regular expressions and what encoding does it use by default?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Match()` and `Matches()` methods of this
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are extension methods and why are they helpful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define an extension method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

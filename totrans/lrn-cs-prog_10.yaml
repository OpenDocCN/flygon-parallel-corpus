- en: '*Chapter 10*: Lambdas, LINQ, and Functional Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although C# is an object-oriented programming language at its core, it is actually
    a *multi-paradigm language*. So far in this book, we have discussed imperative
    programming, object-oriented programming, and generic programming. However, C#
    also supports functional programming features. Throughout [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*, and [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154),
    *Advanced Topics*, we have already used some of these, such as lambdas and **Language-Integrated
    Query (LINQ)**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at these in detail from the perspective of functional
    programming. Learning functional programming techniques will help you to write
    code in a declarative manner that is often simpler and easier to understand than
    the equivalent imperative code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More functional programming concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand lambda expressions
    in detail and will be able to use them together with LINQ to query data from a
    variety of sources. Moreover, you will be familiarized with functional programming
    concepts and techniques, such as higher-order functions, closures, monads, and
    monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start this chapter with an overview of functional programming and its
    core principles.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a general-purpose and multi-paradigm programming language. Yet, so far
    in this book, we have only covered the imperative programming paradigm, which
    uses statements to change the program state and is focused on describing how a
    program operates. In imperative programming, functions may have side effects,
    thus changing the program state when they execute. Alternatively, the execution
    of a function may depend on the program state.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite paradigm is functional programming, which is concerned with describing
    *what* a program does and not *how* it does it. Functional programming treats
    computation as the evaluation of functions; it uses immutable data and avoids
    changing states. Functional programming is a declarative programming paradigm
    where expressions are used instead of statements. Functions no longer have side
    effects but are idempotent. This means that calling a function with the same arguments
    produces the same results every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming provides several advantages, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is easier to understand and maintain because functions don't change
    states and only depend on the arguments they receive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is easier to test for the same reason.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is simpler and more efficient to implement concurrency because data is immutable
    and functions don't have side effects, which avoids data races.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rectangle` (this could also be a class) that represents a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate this type and alter its properties. For instance, if we
    want to inflate the width of the rectangle with 10 units, equally in each direction,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write a function that we could invoke. This could be a *member
    function*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be a *non-member function*, as shown in the following code. The
    difference between the two is only a matter of design. Writing it as an extension
    method is the only choice if we cannot modify the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Rectangle` data type is mutable because its state can be changed. The
    `Inflate()` method has side effects because it changes the state of a rectangle.
    In functional programming, `Rectangle` should be immutable. A possible implementation
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The pure function version of the `Inflate()` method would not have side effects.
    Its behavior would depend solely on the arguments and the result would be the
    same, no matter how many times it is called with the same arguments. An example
    of such an implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These can now be used as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Functional programming stems from lambda calculus (developed by Alonzo Church),
    which is a framework, or mathematical system, for expressing computations based
    on function abstractions and applications using variable binding and substitution.
    Some programming languages, such as Haskell, are purely functional. Others, such
    as C#, support multiple paradigms and are not purely functional.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example showed a variable, `r`, that was initialized to a value
    and then changed. In pure functional programming, this is not possible. A variable,
    once initialized, cannot change value; instead, a new variable must be assigned.
    This enables expressions to be replaced with their values, a property known as
    **referential transparency**.
  prefs: []
  type: TYPE_NORMAL
- en: C# enables us to write code using functional programming concepts and idioms.
    At the core of all these are lambda expressions, which we will look at in depth
    shortly. Before that, we need to explore another functional programming pillar,
    and that is treating functions as *first-class citizens*.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154), *Advanced
    Topics*, we learned about delegates and events. A delegate looks like a function
    but is a type that holds references to functions whose signatures match the definition
    of the delegate. Delegate instances can be passed as objects for function arguments.
    Let''s look at an example where we have a delegate that takes two `int` parameters
    and returns an `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have different functions, such as `Add()`, which adds two integers
    and returns the sum, `Sub()`, which subtracts two integers and returns their difference,
    or `Mul()`, which multiplies two integers and returns their product. Their signature
    matches the delegate, so an instance of the `Combine` delegate can hold references
    to all these functions. These functions are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write a general function that can apply one of these functions to two
    arguments. Such a function may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking it is simple—we pass the arguments and a reference to the actual function
    that we want to invoke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, .NET defines a set of generic delegates called `Func` to avoid
    defining your own delegates all the time. These are defined in the `System` namespace
    and look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a set of 17 overloads that take either 0, 1, or up to 16 arguments
    (of potentially different types) and return a value. Using these system delegates,
    we can rewrite the `Apply` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This version of the function is generic so that it can be invoked with other
    types of arguments, not just integers. The way the function is invoked in the
    preceding examples does not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'These delegates return a value, so they cannot be used for functions that don''t
    have a return value. There is a similar set of overloads in the `System` namespace
    called `Action` that is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These delegates are very similar to the `Func` delegates we saw earlier. The
    only difference is that they do not return a value. There are still 17 overloads
    that take 0, 1, or up to 16 input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Apply` function is overloaded so that it also
    takes a parameter of the `Action<string>` type, which is a function that has a
    single parameter of the `string` type and returns nothing. After applying the
    function, but before returning the result, this action is invoked with a string
    that describes the actual operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke this new overload by passing `Console.WriteLine` for the last
    argument, which results in the operations being logged to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Apply` function is called a *higher-order function*. A higher-order function
    is a function that takes one or more functions as arguments, returns a function,
    or both. All the other functions are called *first-order functions*.
  prefs: []
  type: TYPE_NORMAL
- en: There are many higher-order functions that you might be using without any realization.
    For instance, `List<T>.Sort (Comparison<T> comparison)` is such a function. Most
    query predicates from LINQ (which we will explore later in this chapter in the
    *LINQ* section) are higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a higher-order function is a function that returns another function,
    as shown in the following snippet. `ApplyReverse()` takes a function as argument
    and returns another function that invokes the argument function with two arguments,
    but in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we have seen so far is the possibility in C# to pass functions as arguments,
    return functions from functions, assign functions to variables, store them in
    data structures, or define anonymous functions (that is, functions without a name).
    It's also possible to nest functions and test references to functions for equality.
    A programming language that does these things is said to treat functions as first-class
    citizens and its functions are first-class. C# is, therefore, such a language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to the previous examples, an alternative and simpler way of invoking
    the `Apply()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the methods from the `Math` class have been replaced with lambda expressions
    such as `(a, b) => a + b`. We can even define the `Apply()` function as a lambda
    expression and invoke it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at lambda expressions in depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions are a convenient way to write anonymous functions. They are
    a block of code, either an expression or one or more statements, that behaves
    like a function and can be assigned to a delegate. As a result, a lambda expression
    can be passed as an argument to a function or returned from a function. They are
    a convenient way to write LINQ queries, pass functions to higher-order functions
    (including code that should be executed asynchronously by `Task.Run()`), and create
    expression trees.
  prefs: []
  type: TYPE_NORMAL
- en: An expression tree is a way to represent code in a tree-like data structure,
    with nodes as expressions (such as method calls or binary operations). These expression
    trees can be compiled and executed, which enables dynamic changes to be performed
    on executable code. Expression trees are used to implement LINQ providers for
    various data sources and in the DLR to provide interoperability between .NET Framework
    and a dynamic language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example where we have a list of integers and we
    want to remove all the odd numbers from it. It can be written as follows (notice
    that the `IsOdd()` function can be either a class method or a local function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can actually be simplified with anonymous methods that allow us to
    pass code to a delegate without defining the separate `IsOdd()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions allow us to simplify the code even further with a simpler
    syntax that the compiler transforms into something similar to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda expression that we can see here (`n => n % 2 == 1`) has two parts
    separated by `=>`, which is the **lambda declaration operator**:'
  prefs: []
  type: TYPE_NORMAL
- en: The left part of the expression is the *list of parameters* (separated by a
    comma and enclosed in parentheses if there is more than one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right part of the expression is either an *expression or a statement*. If
    the right part is an expression (such as in the preceding example), the lambda
    is called an **expression lambda**. If the right part is a statement, the lambda
    is called a **statement lambda**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Statements are always enclosed in curly braces `{}`. Any expression lambda
    can actually be written as a statement lambda. Expression lambdas are a simplified
    version of statement lambdas. The previous example with an expression lambda can
    be written as follows using a statement lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several examples of lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_10_Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A lambda does not have a type of its own. Instead, its type is either the type
    of delegate that it is assigned to or the `System.Expression` type when lambdas
    are used to build expression trees. A lambda that does not return a value corresponds
    to a `System.Action` delegate (and can be assigned to one). A lambda that does
    return a value corresponds to a `System.Func` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write a lambda expression, you do not need to write the type of the
    parameters as these are inferred by the compiler. The rules for type inference
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda must have the same number of parameters as the delegate it is assigned
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each parameter of a lambda must be implicitly converted to the corresponding
    parameter of the delegate it is assigned to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the lambda has a return value, its type must be implicitly converted to the
    return type of the delegate it is assigned to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lambda expressions can be asynchronous. Such a lambda is preceded by the `async`
    keyword and must contain at least an `await` expression. The following example
    shows an asynchronous handler for the `Click` event for a button on a Windows
    Forms form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `MyForm` is a form class and, in its constructor, we register
    a handler for the `Click` event. This is done using a lambda expression, but the
    lambda is asynchronous (it calls an asynchronous function) and therefore needs
    to be preceded with `async`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas may use variables that are in the scope of the method or the type that
    contains the lambda expression. When a variable is used in a lambda, it is captured
    so that it can be used even if it goes out of scope. These variables must be definitely
    assigned before they are used in the lambda. In the following example, the lambda
    expression is capturing two variables—the `value` function parameter and the `Data`
    class member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the rules that apply to the scope of variables in lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: The variables that are introduced in a lambda expression are not visible outside
    the lambda (for instance, in the enclosing method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lambda cannot capture `in`, `ref`, or `out` parameters from the enclosing
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that are captured by a lambda expression are not garbage collected,
    even if they would otherwise go out of scope until the delegate that the lambda
    is assigned to is garbage collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A return statement of a lambda expression refers solely to the anonymous method
    that the lambda represents and does not cause the enclosing method to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common use case for lambda expressions is writing LINQ query expressions.
    We will look at this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ is a set of technologies that enable developers to query a multitude of
    data sources in a consistent manner. Typically, you would use different languages
    and technologies to query different types of data, such as SQL for relational
    databases, and XPath for XML. SQL queries are written as strings, which makes
    them impossible to verify at compile time and increase the chances of having runtime
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ defines a set of operators and a built-in language syntax for querying
    data. LINQ queries are strongly typed and therefore verified at compile time.
    LINQ also provides a framework for building your own LINQ providers, which are
    components that transform a query into APIs that are specific to a particular
    data source. The framework provides built-in support for querying objects (anything
    that is a collection in .NET), relational databases, and XML. Third parties have
    written LINQ providers for many data sources, such as web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'LINQ enables developers to focus on what to do and be less concerned with how
    to do things. To better understand how this works, let''s look at an example where
    we have an array of integers and we want to find the sum of all the odd numbers.
    Typically, you''d write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With LINQ, it is possible to reduce all this verbose code to the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the LINQ standard query operators, which are extension methods
    that operate on sequences and provide query capabilities, including filtering,
    projection, aggregation, sorting, and more. Many of these query operators, however,
    have direct support in the LINQ query syntax, which is a query language very similar
    to SQL. Using the query language, the solution to the problem can be written as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, not every query operator has an equivalent in
    query syntax. `Sum()` and all the other aggregation operators do not have an equivalent.
    In the following sections, we will look at these two flavors of LINQ in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Standard query operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LINQ standard query operators are a set of extension methods that operate
    on sequences that implement either `IEnumerable<T>` or `IQueryable<T>`. The former
    exports an enumerator that enables iteration over a sequence. The latter is a
    LINQ-specific interface that inherits from `IEnumerable<T>` and provides us with
    the functionality to evaluate queries against a specific data source. The standard
    query operators are defined as extension methods to either the `Enumerable` or
    the `Queryable` class, depending on the type of sequence they operate on. Being
    extension methods, they can be called either using static method syntax or instance
    method syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the query operators may return more than one value. These methods return
    `IEnumerable<T>` or `IQueryable<T>`, which makes it possible to chain them together.
    The actual query on the data source is deferred until the enumerable object they
    return is iterated on. On the other hand, standard query operators that return
    a single value (such as `Sum()` or `Count()`) do not defer execution and execute
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains the names of all the LINQ standard query operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_10_Table_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a large number of standard query operators. Discussing every one of
    them is beyond the scope of this book. You should read the official documentation
    or additional resources to get familiar with all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To familiarize ourselves more with LINQ, we will look at several examples.
    In the first example, we want to count the number of words in a sentence. We consider
    dot (`.`), comma (`,`), and space as delimiters. We split the string into parts,
    and then filter all those that are not empty and count them. With LINQ, this is
    as simple as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we want to group all the words based on their length and print
    them to the console, the problem becomes a little bit more complicated. We need
    to create groups with the word length as the key and the word itself as the element,
    filter out the groups that have the length zero, and order the remaining in ascending
    order based on the word length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: While the previous query was executed when `Count()` was called, the execution
    of this query is deferred until we actually iterate over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples we''ve looked at so far haven''t been too complicated. Using LINQ,
    however, you can build queries of higher complexity. To illustrate this, let''s
    consider a system that deals with orders for customers. The system works with
    entities such as `Customer`, `Article`, `OrderLine`, and `Order`, which, in a
    very simplistic form, are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also consider that we have sequences of these types, as follows (for
    simplicity, only a couple of records are shown for each type, but you can find
    the full example in the source code that accompanies this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The question we want to find the answer to is, *what are the names of all the
    articles that a particular customer has bought since a given day?* It can be cumbersome
    to write this using an imperative approach, but using LINQ, this can be expressed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we joined the orders with order lines and customers and the
    order lines with articles and kept only the orders made after April 1, 2020 for
    the customer whose first name was John. Then, we ordered them lexicographically
    by the article name and selected only the article name to project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several `Join()` operations and the syntax may look harder to understand.
    Let''s explain it using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `orders` is called the *outer sequence*, and `orderlines` is called the
    *inner sequence*. The second argument of `Join()`, which is `o => o.Id`, is called
    the *key selector for the outer sequence*. We use this to select the orders. The
    third argument of `Join()`, which is `ol => ol.OrderId`, is called the *key selector
    of the inner sequence*. We use this to select order lines.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, these two lambda expressions help matching order lines that have
    `OrderId` equal to an order ID. The last argument, `(o, ol) => new { Order = o,
    Line = ol }`, is the projection of the join operation. We are creating a new object
    with two properties called `Order` and `Line`.
  prefs: []
  type: TYPE_NORMAL
- en: Some standard query operators are simpler to use, while others are more complicated
    and may require a bit of practice to comprehend well. However, for many of them,
    a simpler alternative exists—the LINQ query syntax, which we will explore in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Query syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ query syntax is basically syntactic sugar (that is, a simplified syntax
    designed to make things easier to write and understand) for the standard query
    operators. The compiler transforms queries written in query syntax into queries
    using the standard query operators. Query syntax is simpler and easier to read
    than the standard query operators, but they are semantically equivalent. However,
    as mentioned previously, not all the standard query operators have an equivalent
    in query syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the method syntax of the standard query operators and the query syntax
    compare, let's rewrite the examples from the previous section using query syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the problem where we counted the words in a piece of
    text. With query syntax, the query changes to the following. Notice that `Count()`
    does not have an equivalent in query syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The second problem, on the other hand, can be entirely written using query
    syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the text is a little bit different. Words are displayed on a single
    line, separated by a comma. To compose the text of comma-separated words, we used
    the `string.Join()` static method, which takes a separator and a sequence of values
    and joins them into a single string. The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last problem that we will rewrite is the example with the customer orders.
    This query can be expressed very succinctly, as shown in the following code. This
    code resembles SQL and the `join` operations are definitely simpler to write,
    read, and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from these examples, LINQ helps build queries in a much simpler
    way than using traditional imperative programming. Data sources of different natures
    can be queried in a consistent way with a language that looks like SQL. Queries
    are strongly typed and are verified at compile time, which helps to solve many
    potential bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at some more functional programming concepts: partial
    function application, currying, closures, monoids, and monads.'
  prefs: []
  type: TYPE_NORMAL
- en: More functional programming concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we looked at general functional programming
    concepts, mainly higher-order functions and immutability. In this section, we
    will explore several more functional programming concepts and techniques—partial
    function application, currying, closures, monoids, and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Partial function application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial function application is the process of taking a function with *N parameters*
    and *one argument* and returning another function with *N-1 parameters* after
    fixing the argument into one of the function's parameters. It is, of course, possible
    that the invocation is done with more than just one argument, say, *M*, in which
    case the returned function will have *N-M* parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let''s start with a function that has several
    parameters and is returning a string (containing the value of the arguments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke this function as `AsString(42, 43.5, "44")`, the result is the
    string `"a=42, b=43.5, c=44"`. However, if we had a function (let''s call it `Apply()`)
    that would bind an argument to the first parameter of this function, then we could
    invoke it as follows with the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of such an `Apply()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This higher-order function takes another function and a value as parameters
    and returns another higher function with one parameter less. This function resolves
    to invoke the `f` argument function with the `arg` argument value and additional
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible that we continue this process of reducing functions to
    another function with one less parameter until we have a function with no parameters,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to make this possible, we need additional overloads of the `Apply()`
    function, with the appropriate number of arguments. For the case shown here, we
    need the following (in practice, if you have functions with more than three arguments,
    you need more overloads to account for all possible numbers of arguments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it is important to note that the actual invocation of the `AsString()`
    function only happens when all the arguments are supplied; that is, the moment
    we invoke `f3()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering when partial function application is useful. The typical
    case is when you invoke a function several (or many) times and some arguments
    are the same. In this case, there are several alternatives, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide defaults for the function parameters, when you define it. However, this
    might not be possible for different reasons. Perhaps the defaults only make sense
    in some context, or maybe you do not actually own the code, so you cannot provide
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the class where you invoke the function multiple times, you can write a `helper`
    function with fewer arguments that invoke the function with the right defaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial function application may be (in many of these cases) the simpler solution
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Currying** is the process of taking a function with *N* arguments and decomposing
    it into *N* functions that take *one* argument. This technique takes its name
    from the mathematician and logician Haskell Curry, after whom the functional programming
    language **Haskell** is also named.'
  prefs: []
  type: TYPE_NORMAL
- en: Currying enables working with functions that have multiple arguments in contexts
    where only functions with one argument could be used. An example of this is analytical
    techniques in mathematics that can only be applied to functions with a single
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the `AsString()` function from the previous section, currying this
    function would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a function, `f1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When invoked with an argument, `a`, it would return a function, `f2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When invoked with an argument, `b`, it would return a function, `f3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When invoked with an argument, `c`, it would invoke `AsString(a, b, c)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These, when put in code, would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic `Curry()` function seen here is similar to the `Apply()` function
    from the previous section. However, instead of returning a function with *N-1*
    arguments, it returns a function with a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This function can be used to curry functions with exactly three parameters.
    Should you need to do that with functions that have another number of parameters,
    then you need appropriate overloads for it (just as in the case of `Apply()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should note that you do not necessarily need to decompose the `AsString()`
    function three different times, as seen earlier with `f1`, `f2`, and `f3`. You
    can skip intermediate functions and achieve the same result by invoking the function
    appropriately, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Another important concept in function programming is closures. We'll learn about
    closures in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Closures** are defined as a technique to implement lexically scoped name-binding
    in a language with first-class functions. Lexical or static scoping is the setting
    of the scope of a variable to the block in which it was defined, so it may only
    be referred to by its name from within that scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: Scopes in C# are called **static** or **lexical** and can be viewed at compile
    time. The opposite is *dynamic scopes*, which are only resolved at runtime, but
    these are not supported in C#.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in this chapter, C# is a language that has first-class functions
    because you can assign functions to variables, pass them around, and invoke them.
    However, this definition of a closure is probably harder to comprehend, so we
    will explain it step by step using an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a function called `Increment()` that is returning another function
    that increments its argument with a value. However, that value is neither passed
    as an argument to the lambda nor defined as a local variable in the lambda. Instead,
    it is captured from the outer scope. For this reason, the step variable is called
    a `step` variable in the scope of the lambda; if it's not found, it looks to the
    enclosing scope, which, in this case, is the `Increment()` function. If it wasn't
    there either, it would have looked further in the class scope, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What happens next is that we assign the value returned from the `Increment()`
    function, which is another function, to the `inc` variable and then invoke it
    with the value `42`. The result is that the value `43` is printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, *how does this work?* The `step` variable is actually a local
    function variable and should go out of scope as soon as `Increment()` is called.
    Yet, its value is known at the time of invoking the function returned from `Increment()`.
    This is because the lambda expression, `x => x + step`, is said to *close* over
    the free variable, `step`, thus defining a closure. Both the lambda expression
    and `step` are passed together (as part of the closure) so that the variable that
    would normally go out of scope still lives at the time the closure is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures are used all the time without us even realizing it. Consider the following
    example, where we have a list of engines and we want to search for an engine with
    minimum power and capacity. You would typically write something as follows using
    a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is actually creating a closure because the lambda closes over the
    `minp` and `minc` free variables. Without support for closure in the language,
    it would be cumbersome to write code that does the same. You would basically have
    to write a class that is capturing the value of these variables and has a method
    that takes an `Engine` object and compares its properties to these values. In
    this case, the code could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is quite similar to what the compiler does when encountering a closure,
    but it's the kind of detail you do not have to concern yourself with.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also notice that the free variables that are captured by a lambda
    in a closure can change value. We exemplify this with the following sample where
    the `GetNextId()` function defines a closure that increments the value of the
    captured free variable, `id`, with each call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn about monoids in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **monoid** is an algebraic structure with a single associative binary operation
    and an identity element. Any C# type that has those two elements is a monoid.
    Monoids are useful for defining concepts and reusing code. They help us build
    complex behavior out of simple components without the need to introduce new concepts
    in our code. Let's look at how we can create and use monoids in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define a generic interface in C# to represent a monoid as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The monoid ensures associativity and left and right identity so that for any
    values, `a`, `b`, and `c`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Combine((Combine(a, b), c) == Combine(a, Combine(b, c))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combine(Identify, a) == a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combine(a, Identity) == a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concatenating strings or a list is an example of an associative binary operation.
    A type that provides that function, together with an identity element (an empty
    string or an empty list in these cases), is a monoid. So, we can actually implement
    these in C# as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `ConcatList` and `ConcatString` are examples of monoids. The latter could
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This would print `Learning C# 8` to the console. However, this code is a little
    bit cumbersome to use. We can simplify it by creating a helper class with a static
    method called `Concat()` that takes a monoid and a sequence of elements and combines
    them together using the monoids binary operation and its identity for the initial
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this helper class available, we can write the following simplified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of this example, we concatenated a list of strings into a
    single string and printed it to the console. In the second part, we concatenated
    a list of lists of integers into a single list of integers, which are later also
    printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at monads.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a concept that is usually harder to explain and, perhaps, also harder
    to understand, although a lot of literature has been written about it. In this
    book, we will try to explain it in simple terms, but we recommend that you read
    additional resources.
  prefs: []
  type: TYPE_NORMAL
- en: In a few words, a monad is a container that encapsulates some functionality
    on top of the value that it wraps. We often work with monads in C# without realizing
    it. `Nullable<T>` is a monad that defines a special functionality that is *nullability*,
    which means a value may be present or not. `Task<T>` with `await` is a monad that
    defines a special functionality that is *asynchronicity*, which means a value
    can be used before it's actually computed. `IEnumerable<T>` with the LINQ query
    `SelectMany()` operator is also a monad.
  prefs: []
  type: TYPE_NORMAL
- en: 'A monad has two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: One that *transforms* a value, `v`, into a container that wraps it (`v -> C(v)`).
    In functional programming, this function is called **return**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that *flattens* two containers into a single container (`C(C(v)) -> C(v)`).
    In functional programming, this is called **bind**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, `numbers` is an array of arrays of integers. `SelectMany()` is used to
    select subsequences of odd numbers. However, this flattens the result into `IEnumerable<int>`
    instead of `IEnumerable<IEnumerable<int>>`. As we mentioned earlier, `IEnumerable<T>`
    with `SelectMany()` is a monad.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can you implement a monad in C#? The simplest form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually called the `x => x`, you will get the initial monad back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of how this monad can be used is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `m` is a monad that wraps the integer value `21`. We bind with
    a function that returns a new monad that has a value that is double the initial
    one. We can again bind on this monad with a function that transforms the integer
    into a string.
  prefs: []
  type: TYPE_NORMAL
- en: From this example, you can see that those binding operations can be chained
    together. This is what fluent interfaces provide—a mechanism to write code that
    looks like written prose by chaining methods. This can be further exemplified
    using the following example—given a system where a business has customers, customers
    place orders, and an order can contain one or more articles, you are required
    to find all the distinct articles bought by all the customers of a particular
    business.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, let''s consider the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In a typical imperative style, you could implement the solution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this can be simplified more by using LINQ and the `IEnumerable<T>`
    and `SelectMany()` monad. The functional programming style implementation could
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This uses the fluent interface pattern and the result is more concise code that
    is also simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was a departure from the imperative programming traits of C# since
    we explored functional programming concepts and techniques built into the language.
    We looked at higher-order functions, lambda expressions, partial function applications,
    currying, closures, monoids, and monads. We also had an introduction to LINQ with
    its two flavors: the method syntax and the query syntax. Most of these topics
    are complex and more advanced than the proposed scope of this book. Therefore,
    we recommend that you use other resources in order to master them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the reflection services that are available
    with .NET and the dynamic programming capabilities of C#.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the main characteristics of functional programming? What advantages
    does it provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a higher-order function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes functions first-class citizens in the C# language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a lambda expression? What is the syntax for writing lambda expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the rules that apply to variables' scope in lambda expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is LINQ? What are the standard query operators and what is the query syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `Select()` and `SelectMany()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a partial function application and how does it differ from currying?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a monoid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a monad?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

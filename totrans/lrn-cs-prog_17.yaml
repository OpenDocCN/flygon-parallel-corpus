- en: '*Chapter 17*: Unit Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, you have learned all you need to know to be able to program
    using the C# language—from statements to classes, from generics to functional
    programming, from reflection to concurrency, and many others. We also covered
    many topics related to .NET Framework and .NET Core, including collections, regular
    expressions, files and streams, resource management, and **Language Integrated
    Query** (**LINQ**).
  prefs: []
  type: TYPE_NORMAL
- en: However, a key aspect of programming is making sure that code behaves as intended.
    Code that is not properly tested is prone to unexpected bugs. There are various
    types and levels of testing, but the one typically performed by developers while
    developing is *unit testing*. This is the topic covered in this final chapter
    of this book. In this chapter, you will learn what unit testing is and what are
    the built-in tools available to write unit tests for C#. Then, we will look in
    detail at how we can leverage these tools to unit test our C# code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Microsoft tools for unit testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C# unit testing project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data-driven unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with an overview of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a type of software testing where individual units of code are
    tested to validate whether they are working as they were designed. Unit testing
    is the first level of software testing, the others being integration testing,
    system testing, and acceptance testing. A discussion of these types of testing
    is beyond the scope of this book. Unit testing is typically performed by software
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing unit testing has important benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to identify and fix bugs earlier in the development cycle, thereby
    helping to save time and money.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps developers to better understand the code and allows them to make quick
    changes to the code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps with code reuse by requiring it to be more modular to test it better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can act as project documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps to speed up development because the effort of identifying bugs using
    various methods of manual testing done by developers is greater than the time
    spent writing unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies debugging because when tests fail, only the latest changes need
    to be looked at and debugged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit of testing may differ. It can be a *function* (as it typically is in
    imperative programming) or a *class* (in object-oriented programming). Units are
    tested individually and in isolation from other units. This requires that units
    are designed to be loosely coupled but also employs the use of substitutes such
    as stubs, mocks, and fakes. Although the definition of these concepts may vary,
    stubs are functions that stand in as replacements for other functions, simulating
    their behavior. Examples could include stubs for functions that retrieve data
    from a web service or temporary substitutes for functionalities that will be added
    at a later time. Mocks are objects that simulate the behavior of other objects,
    usually complex, that are impractical to use for a unit test. The term **fake**
    may refer either to a *stub* or a *mock* and is used to indicate an entity that
    is not real.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using substitutes, unit testing often requires the use of test harnesses.
    A test harness is an automated testing framework that allows testing to be automated
    by supporting the creation of tests, executing the tests, and generating reports.
  prefs: []
  type: TYPE_NORMAL
- en: The measure of how much of the code base is covered by unit tests is called
    **code coverage**. Code coverage offers an indication of the degree a code base
    has been tested by providing a quantitative measure. Code coverage helps us to
    identify the parts of a program that are not well covered by test cases and allows
    us to create more tests to increase coverage.
  prefs: []
  type: TYPE_NORMAL
- en: What are Microsoft tools for unit testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are working with Visual Studio, several tools help you to write unit
    tests for your C# code. These tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Explorer**: This is a component of the IDE that allows you to view the
    unit tests, run them, and see their results. The **Test Explorer** does not work
    solely with MSTest (Microsoft''s testing unit framework). It has an extensible
    API that allows developing adapters for third-party frameworks. Some of the frameworks
    that provide adapters for **Test Explorer** are **NUnit** and **xUnit**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft unit test framework for managed code or MSTest**: This is installed
    with Visual Studio but is also available as a NuGet package. There is also a unit
    testing framework for native code with similar functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code coverage tools**: They allow you to determine the amount of code that
    unit tests are covering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Fakes isolation framework**: This allows you to create substitutes
    for classes and methods. Currently, this only works for .NET Framework and with
    Visual Studio Enterprise. At this time, .NET standard projects are not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The experience of working with the Microsoft testing framework for .NET Framework
    and .NET Core is a bit different at the time of writing this book because there
    are no unit testing templates for .NET Core test projects. This means that you
    need to manually create test classes and methods and decorate them with the proper
    attributes, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C# unit testing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look together at how you can create a unit testing
    project in Visual Studio 2019\. When you open the **File** | **New Project** menu,
    you can choose between various testing projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 - Visual Studio 2019 unit-testing project templates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 - Visual Studio 2019 unit testing project templates
  prefs: []
  type: TYPE_NORMAL
- en: If you need to test a .NET Framework project, then you select **Unit Test Project
    (.NET Framework)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A project is created for you with a single unit testing file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `UnitTest1` is a class containing test methods. This class is marked
    with the `TestClassAttribute` attribute. Another attribute, `TestMethodAttribute`,
    is used to mark the `TestMethod1()` method. These attributes are used by the testing
    framework to identify classes and methods that contain tests. These are then shown
    in **Test Explorer,** where you can run or debug them and view their results,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 - The Test Explorer in Visual Studio showing the result of executing
    the empty unit test created from the selected template.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 - Test Explorer in Visual Studio showing the result of executing
    the empty unit test created from the selected template
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add more unit testing classes either by hand or by using the test templates
    available in Visual Studio, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 - The Add New Item dialog in Visual Studio with a selection of
    unit test items.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 - The Add New Item dialog in Visual Studio with a selection of unit
    test items
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing a .NET Core project, then you should select the template
    called **MSTest Test Project (.NET Core)** when creating the test project (refer
    to the screenshot at the beginning of this section). The result is a project with
    a single file and the same content shown earlier. However, adding more unit testing
    items is not possible using the wizards, and you must create everything manually.
    At this point, there are no item templates available for MSTest for .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will focus on testing .NET Core projects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how you can write unit tests for your C# code.
    To do so, we will consider the following implementation of a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation should be straightforward and not require further explanations.
    This is a simple class that does not offer too many functionalities concerning
    rectangles. We can provide more in the form of extension methods. The following
    listing shows extensions for increasing and decreasing the size of a rectangle,
    as well as checking whether two rectangles intersect, and determining the resulting
    rectangle of their intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by testing the `Rectangle` structure and to do so, we will have
    to create a unit testing project as described in the previous section. After the
    project is created, we can edit the generated stub with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this listing, we have a test class, called `RectangleTests`, that contains
    several testing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestEmpty()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestConstructor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestProperties()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestPropertiesMore()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these methods tests some part of the `Rectangle` class. To do so, we
    are using the `Assert` class from `Microsoft.VisualStudio.TestTools.UnitTesting`.
    This class contains a collection of static methods that help us to perform tests.
    When a test fails, an exception is thrown and the execution of the test method
    stops and continues with the next testing method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the results of executing the test methods
    we wrote earlier. You can see that all of the tests have executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 - The Test Explorer showing the successful execution of the test
    methods written earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 - Test Explorer showing successful execution of the test methods
    written earlier
  prefs: []
  type: TYPE_NORMAL
- en: 'When a test fails, it will be shown with a red bullet and you can check in
    the `TestProperties()` method to have the following incorrect test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the `TestProperties()` test method fail, as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 - The Test Explorer showing the execution of the test methods
    with the TestProperties() method failed.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 - Test Explorer showing the execution of test methods with the TestProperties()
    method having failed
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the failure is detailed in the **Test Detail Summary** pane,
    as shown in the following screenshot. This pane is displayed when you click on
    a failed test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 - The Test Detail Summary pane of the Test Explorer showing details
    about the failed test.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.6 - Test Detail Summary pane of Test Explorer showing details regarding
    the failed test
  prefs: []
  type: TYPE_NORMAL
- en: 'From the report in this pane, we can see that `Assert.AreEqual()` at `line
    30` in `RectangleTests.cs` failed because the expected result was `6,` but the
    actual value was `4`. We also got the message that we supplied to the `Assert.AreEqual()`
    method. The entire text message from the previous screenshot is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test code written so far, we have used several asserting methods—`AreEqual()`,
    `IsTrue()`, and `IsFalse()`. These, however, are not the only assertion methods
    available; there is a long list of them. Some of the most frequently used assertion
    methods are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_17_Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All of the methods listed in this table are actually overloaded methods. You
    can get the complete reference by checking the documentation available online.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we created the `Rectangle` class, we also created several extension methods
    for it, so we should be writing more unit tests to cover these two. We could put
    these tests into another test class. Although the source code accompanying this
    book contains more unit tests, for brevity, we only list some of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling the unit testing project, the new unit test class and methods
    will appear in **Test Explorer,** so you can run or debug them. The following
    screenshot shows the successful execution of all of the test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 - The Test Explorer window showing the successful execution of
    all the unit tests, including the ones written for the Rectangle extension methods.](img/Figure_17.7_B12346.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.7 - The Test Explorer window showing the successful execution of all
    the unit tests, including the ones written for the Rectangle extension methods
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get code coverage for your code based on the unit tests you have
    written. You can trigger the code coverage either from **Test Explorer** or from
    the **Test** top-level menu. Based on the unit test we have seen so far, we get
    the following coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.8 - The Code Coverage Results pane in Visual Studio showing the
    code coverage of our unit tests.](img/Figure_17.8_B12346.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.8 - The Code Coverage Results pane in Visual Studio showing the code
    coverage of our unit tests
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `Rectangle` class is completely covered by unit tests.
    However, the static class containing extensions is only covered `IntersectsWith()`,
    has one block out of eight that is not covered by the unit tests we have written.
    We can use this report to identify the parts of the code that are not covered
    by tests so that you can write more.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the tests we have written so far, we have seen test classes and test methods.
    However, there are other methods that a test class may have that are executed
    at different stages. A complete example is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of these methods are irrelevant. What is important here are the attributes
    used to mark them. These are reflected by the testing framework and determine
    the order in which the methods are invoked. For this particular example, this
    order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes used to mark these methods are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_17_Table_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you want to do multiple tests for the same function with different sets
    of data, you can resort to retrieving them from a data source. The unit testing
    framework for managed code makes this possible in the ways we will see in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data-driven unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a second look at the previous tests, such as the `TestIntersectsWith()`
    test method, you will see that we tried testing various cases, such as the intersection
    of one rectangle with several others, some that intersect, and some that don't.
    This was a simple example, and in practice, there should be many more rectangles
    that we should test with to cover all of the possible cases of rectangle intersection.
  prefs: []
  type: TYPE_NORMAL
- en: In general, as code evolves, so do the tests and you often have to add more
    to the testing datasets. Rather than writing explicitly the data in the test method,
    as in our previous example, you can fetch it from a data source. The test method
    is then executed once for each row in the data source. The unit testing framework
    for managed code supports three different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Data from attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first option is to provide the data in code but through an attribute called
    `DataRowAttribute`. This attribute has a constructor that allows us to specify
    any number of arguments. These arguments are then forwarded, in the same order,
    to the parameters of the test method it is used on. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are several things to notice in this example. First, the attribute used
    to indicate that this is a data-driven test method is `DataTestMethodAttribute`.
    However, for compatibility of legacy code, `TestMethodAttribute` is also supported,
    although not encouraged. The second thing to notice is the use of `DataRowAttribute`.
    We used it to provide the data for several rectangles as well as the expected
    result of the intersection with the reference rectangle from the test method.
    As mentioned before, the method is executed for each row in the data source, which,
    in this case, is each occurrence of the `DataRow` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows the output of executing the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If a row in the data source makes the test fail, it is reported as such, but
    the execution of the method is repeated for the next row in the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of the `DataRow` attribute is an improvement, since it makes the testing
    code simpler, but it is not the best alternative. A slightly better option is
    fetching data, dynamically, from a method or property of the class. This is possible
    using another attribute called `DynamicDataAttribute`. You must specify the name
    and the type of the source of data (method or property). An example is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a method called `GetData()` that returns an enumerable
    sequence of arrays of objects. We fill these arrays with the rectangle bounds
    and the result of the intersection with the reference rectangle. Then, on the
    test method, we use the `DynamicData` attribute and provide it with the name of
    the method that supplies the data and the type of data source (`DynamicDataSourceType.Method`).
    The actual test code is no different than the one from the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: However, this alternative also relies on hardcoded data. The most desirable
    solution is to read it from an external data source.
  prefs: []
  type: TYPE_NORMAL
- en: Data from external sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test data can be fetched from an external source, such as a SQL Server database,
    a CSV file, an Excel document, or XML. For this purpose, we must use another attribute,
    called `DataSourceAttribute`. This attribute has several constructors that allow
    you to specify the connection string to the source and other necessary parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, this solution and this attribute are only
    available for .NET Framework and are not yet supported for .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a test method that gets data from an external source, you need to
    be able to access information about this data source. This is possible with the
    help of a `TestContext` object that the framework is passing as an argument to
    the methods marked with either the `AssemblyInitialize` or `ClassInitialize` attributes.
    A simpler solution to get a reference to that object is to provide in the test
    class a public property called `TestContext` with the `TestContext` type as shown
    in the following code. The framework will automatically set it with a reference
    to the test context object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the context to access data source information. In the example
    that follows, we rewrite the test method to fetch data from a CSV file called
    `TestData.csv` that resides in the same folder as the test application. The content
    of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first column is the expected result of the intersection with the reference
    rectangle, and the other values on each line are the bounds of the rectangle.
    The test method that executes with data fetched from this CSV file is listed in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this method, unlike the previous ones, has no parameters. Data
    is available through the `DataRow` property of the `TestContext` object and this
    method is invoked once for each row in the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want data source information, such as the connection string,
    to be specified in the source code, you can use the application configuration
    file to provide it. To do so, you must add a custom section and then define a
    connection string (with name, string, and provider name) and data source (with
    name, connection string name, table name, and data access method). For the CSV
    file we used in the previous example, the `App.config` file would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this defined, the only change we have to make to the test method is to
    change the `DataSource` attribute, specifying the name of the data source from
    the `.config` file (`MyCSVDataSource` in our example). This is shown in the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To get more information about how to provide connection strings for various
    types of data sources, you should read the online documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last chapter of this book was dedicated to unit testing, which is essential
    for writing quality code. We started with a basic introduction to unit testing
    and learned about the Microsoft tools for writing unit tests, including the unit
    testing framework for managed code. We have seen how to create unit testing projects
    using this framework, both for .NET Framework and .NET Core. We then looked at
    the most important features of the unit testing framework and learned how to write
    unit tests. In the last section, we learned about data-driven tests and saw how
    to write tests with data from various data sources.
  prefs: []
  type: TYPE_NORMAL
- en: As this book concludes here, we, the authors, would like to thank you for taking
    the time to read it. By writing this book, we tried to provide you with everything
    that was essential for you to become proficient in the C# language. We hope this
    book proves a valuable resource for you in learning and mastering the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is unit testing and what are its most important benefits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What tools does Visual Studio offer to help writing unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functionalities does Test Explorer in Visual Studio provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you specify that a class in a unit testing project contains unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What class and methods can you use to perform assertions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you check the code coverage of your unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write test fixtures that execute once per test class? What about
    test fixtures for each method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is data-driven unit testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `DynamicDataAttribute` do? And what about `DataSourceAttribute`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the supported external sources for test data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

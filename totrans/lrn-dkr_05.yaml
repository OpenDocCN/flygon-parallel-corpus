- en: Mastering Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to optimally prepare your working
    environment for the productive and frictionless use of Docker. In this chapter,
    we are going to get our hands dirty and learn everything that is important to
    know when working with containers. Here are the topics we''re going to cover in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Running the first container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting, stopping, and removing containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exec into a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching to a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving container logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After finishing this chapter, you will be able to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Run, stop, and delete a container based on an existing image, such as Nginx,
    BusyBox, or Alpine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all containers on the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the metadata of a running or stopped container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the logs produced by an application running inside a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a process such as `/bin/sh` in an already-running container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a Terminal to an already-running container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain in your own words to an interested lay person the underpinnings of a
    container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you should have installed Docker for Desktop on your macOS
    or Windows PC. If you are on an older version of Windows or are using Windows
    10 Home Edition, then you should have Docker Toolbox installed and ready to use.
    On macOS, use the Terminal application, and on Windows, a PowerShell or Bash console,
    to try out the commands you will be learning.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we want to make sure that Docker is installed correctly on
    your system and ready to accept your commands. Open a new Terminal window and
    type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Docker Toolbox then use the Docker Quickstart Terminal that
    has been installed with the Toolbox, instead of the Terminal on macOS or Powershell
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works correctly, you should see the version of Docker client
    and server installed on your laptop output in the Terminal. At the time of writing,
    it looks like this (shortened for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I have `beta3` of version `19.03.0` installed on my macOS.
  prefs: []
  type: TYPE_NORMAL
- en: If this doesn't work for you, then something with your installation is not right.
    Please make sure that you have followed the instructions in the previous chapter
    on how to install Docker for Desktop or Docker Toolbox on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you''re ready to see some action. Please type the following command into
    your Terminal window and hit *Return*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding command the first time, you should see an output
    in your Terminal window similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that was easy! Let''s try to run the very same command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second, third, or *n*^(th) time you run the preceding command, you should
    see only this output in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Try to reason about why the first time you run a command you see a different
    output than all of the subsequent times. But don't worry if you can't figure it
    out; we will explain the reasons in detail in the following sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Starting, stopping, and removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have successfully run a container in the previous section. Now, we want
    to investigate in detail what exactly happened and why. Let''s look again at the
    command we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command contains multiple parts. First and foremost, we have the word `docker`.
    This is the name of the Docker **Command-Line Interface** (**CLI**) tool, which
    we are using to interact with the Docker engine that is responsible to run containers.
    Next, we have the word `container`, which indicates the context we are working
    with. As we want to run a container, our context is the word `container`. Next
    is the actual command we want to execute in the given context, which is `run`.
  prefs: []
  type: TYPE_NORMAL
- en: Let me recap—so far, we have `docker container run`, which means, *Hey Docker,
    we want to run a container.*
  prefs: []
  type: TYPE_NORMAL
- en: Now we also need to tell Docker which container to run. In this case, this is
    the so-called `alpine` container.
  prefs: []
  type: TYPE_NORMAL
- en: '`alpine` is a minimal Docker image based on Alpine Linux with a complete package
    index and is only 5 MB in size.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to define what kind of process or task shall be executed inside
    the container when it is running. In our case, this is the last part of the command, `echo
    "Hello World"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe the following screenshot can help you to get a better idea of the whole
    thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png)'
  prefs: []
  type: TYPE_IMG
- en: Anatomy of the docker container run expression
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have understood the various parts of a command to run a container,
    let''s try to run another container with a different process running inside it.
    Type the following command into your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output in your Terminal window similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What changed is that this time, the container image we're using is `centos` and
    the process we're executing inside the `centos` container is `ping -c 5 127.0.0.1`,
    which pings the loopback address five times until it stops.
  prefs: []
  type: TYPE_NORMAL
- en: '`centos` is the official Docker image for CentOS Linux, which is a community-supported
    distribution derived from sources freely provided to the public by **Red Hat**for
    **Red Hat Enterprise Linux** (**RHEL**).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze the output in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that Docker didn''t find an image named `centos:latest` in the
    local cache of the system. So, Docker knows that it has to pull the image from
    some registry where container images are stored. By default, your Docker environment
    is configured so that images are pulled from Docker Hub at `docker.io`. This is
    expressed by the second line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three lines of output are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that Docker has successfully pulled the `centos:latest` image from
    Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: All of the subsequent lines of the output are generated by the process we ran
    inside the container, which is the Ping tool in this case. If you have been attentive
    so far, then you might have noticed the `latest` keyword occurring a few times.
    Each image has a version (also called `tag`), and if we don't specify a version
    explicitly, then Docker automatically assumes it is `latest`.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding container again on our system, the first five lines
    of the output will be missing since, this time, Docker will find the container
    image cached locally and hence won't have to download it first. Try it out and
    verify what I just told you.
  prefs: []
  type: TYPE_NORMAL
- en: Running a random trivia question container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the subsequent sections of this chapter, we need a container that runs continuously
    in the background and produces some interesting output. That's why we have chosen
    an algorithm that produces random trivia questions. The API that produces that
    free random trivia can be found at [http://jservice.io/](http://jservice.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the goal is to have a process running inside a container that produces
    a new random trivia question every five seconds and outputs the question to `STDOUT`.
    The following script will do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it in a Terminal window. Stop the script by pressing *Ctrl *+ *C*. The
    output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each response is a different trivia question.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to install `jq` first on your macOS or Windows computer. `jq` is
    a handy tool often used to nicely filter and format JSON output, which increases
    the readability of it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this logic in an `alpine` container. Since this is not just
    a simple command, we want to wrap the preceding script in a script file and execute
    that one. To make things simpler, I have created a Docker image called `fundamentalsofdocker/trivia`
    that contains all of the necessary logic, so that we can just use it here. Later
    on, once we have introduced Docker images, we will analyze this container image
    further. For the moment, let''s just use it as is. Execute the following command
    to run the container as a background service. In Linux, a background service is
    also called a daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding expression, we have used two new command-line parameters, `-d` and `--name`.
    Now, `-d` tells Docker to run the process running in the container as a Linux
    daemon. The `--name` parameter, in turn, can be used to give the container an
    explicit name. In the preceding sample, the name we chose is `trivia`.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't specify an explicit container name when we run a container, then
    Docker will automatically assign the container a random but unique name. This
    name will be composed of the name of a famous scientist and an adjective. Such
    names could be `boring_borg` or `angry_goldberg`. They're quite humorous, our
    Docker engineers, *aren't they?*
  prefs: []
  type: TYPE_NORMAL
- en: We are also using the tag `ed2` for the container. This tag just tells us that
    this image has been created for the second edition of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important takeaway is that the container name has to be unique on the system.
    Let''s make sure that the trivia container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us something like this (shortened for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The important part of the preceding output is the `STATUS` column, which in
    this case is `Up 9 seconds`. That is, the container has been up and running for
    9 seconds now.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if the last Docker command is not yet familiar to you, we will come
    back to it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this section, let''s stop and remove the `trivia` container with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to learn how to list containers running or dangling on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Listing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we continue to run containers over time, we get a lot of them in our system.
    To find out what is currently running on our host, we can use the `container ls` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all currently running containers. Such a list might look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/068c2859-04d5-43a4-9e16-e1326761f468.png)List of all containers
    running on the system'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Docker outputs seven columns with the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  **Column**  |  **Description**  |'
  prefs: []
  type: TYPE_TB
- en: '| `Container ID` | This is the unique ID of the container. It is an SHA-256.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Image` | This is the name of the container image from which this container
    is instantiated. |'
  prefs: []
  type: TYPE_TB
- en: '| `Command` | This is the command that is used to run the main process in the
    container. |'
  prefs: []
  type: TYPE_TB
- en: '| `Created` | This is the date and time when the container was created. |'
  prefs: []
  type: TYPE_TB
- en: '| `Status` | This is the status of the container (created, restarting, running,
    removing, paused, exited, or dead). |'
  prefs: []
  type: TYPE_TB
- en: '| `Ports` | This is the list of container ports that have been mapped to the
    host. |'
  prefs: []
  type: TYPE_TB
- en: '| `Names` | This is the name assigned to this container (multiple names are
    possible). |'
  prefs: []
  type: TYPE_TB
- en: 'If we want to list not only the currently running containers but all containers
    that are defined on our system, then we can use the command-line parameter `-a` or `--all`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will list containers in any state, such as `created`, `running`, or `exited`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to just list the IDs of all containers. For this, we have
    the `-q` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You might wonder where this is useful. I will show you a command where it is
    very helpful right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Lean back and take a deep breath. Then, try to find out what the preceding command
    does. Don't read any further until you find the answer or give up.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command deletes all containers that are currently defined on the
    system, including the stopped ones. The `rm` command stands for remove, and it
    will be explained soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used the `-l` parameter in the list command. Try
    to use Docker help to find out what the `-l` parameter stands for. You can invoke
    help for the list command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's learn how to stop and restart containers.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and starting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to (temporarily) stop a running container. Let''s try this
    out with the trivia container we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the container again with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to stop this container, then we can do so by issuing this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you try to stop the trivia container, you will probably note that it takes
    a while until this command is executed. To be precise, it takes about 10 seconds. *Why
    is this the case?*
  prefs: []
  type: TYPE_NORMAL
- en: Docker sends a Linux `SIGTERM` signal to the main process running inside the
    container. If the process doesn't react to this signal and terminate itself, Docker
    waits for 10 seconds and then sends `SIGKILL`, which will kill the process forcefully
    and terminate the container.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding command, we have used the name of the container to specify
    which container we want to stop. But we could have also used the container ID
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '*How do we get the ID of a container?* There are several ways of doing so.
    The manual approach is to list all running containers and find the one that we''re
    looking for in the list. From there, we copy its ID. A more automated way is to
    use some shell scripting and environment variables. If, for example, we want to
    get the ID of the trivia container, we can use this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `-a` parameter with the Docker `container ls` command to list
    all containers, even the stopped ones. This is necessary in this case since we
    stopped the trivia container a moment ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of using the container name, we can use the `$CONTAINER_ID` variable in
    our expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we have stopped the container, its status changes to `Exited`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a container is stopped, it can be started again using the `docker container
    start` command. Let''s do this with our trivia container. It is good to have it
    running again, as we''ll need it in the subsequent sections of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is now time to discuss what to do with stopped containers that we don't need
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run the `docker container ls -a` command, we can see quite a few containers
    that are in the `Exited` status. If we don''t need these containers anymore, then
    it is a good thing to remove them from memory; otherwise, they unnecessarily occupy
    precious resources. The command to remove a container is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another command to remove a container is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Try to remove one of your exited containers using its ID.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, removing a container will not work as it is still running. If we
    want to force a removal, no matter what the condition of the container currently
    is, we can use the command-line parameter `-f` or `--force`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers are runtime instances of an image and have a lot of associated data
    that characterizes their behavior. To get more information about a specific container,
    we can use the `inspect` command. As usual, we have to provide either the container
    ID or name to identify the container of which we want to obtain the data. So,
    let''s inspect our sample container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is a big JSON object full of details. It looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output has been shortened for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please take a moment to analyze what you got. You should see information such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ID of the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation date and time of the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image from which the container is built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many sections of the output, such as `Mounts` or `NetworkSettings`, don't make
    much sense right now, but we will certainly discuss those in the upcoming chapters
    of this book. The data you're seeing here is also named the metadata of a container.
    We will be using the `inspect` command quite often in the remainder of this book
    as a source of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need just a tiny bit of the overall information, and to achieve
    this, we can either use the grep tool or a filter. The former method does not
    always result in the expected answer, so let''s look into the latter approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `-f` or `--filter` parameter is used to define the filter. The filter expression itself
    uses the Go template syntax. In this example, we only want to see the state part
    of the whole output in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To nicely format the output, we pipe the result into the `jq` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After we have learned how to retrieve loads of important and useful meta information
    about a container, we now want to investigate how we can execute it in a running
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Exec into a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to run another process inside an already-running container.
    A typical reason could be to try to debug a misbehaving container. *How can we
    do this?* First, we need to know either the ID or the name of the container, and
    then we can define which process we want to run and how we want it to run. Once
    again, we use our currently running trivia container and we run a shell interactively
    inside it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` flag signifies that we want to run the additional process interactively,
    and `-t` tells Docker that we want it to provide us with a TTY (a Terminal emulator)
    for the command. Finally, the process we run is `/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding command in our Terminal, then we will be presented
    with a new prompt, `/app #`. We''re now in a shell inside the trivia container.
    We can easily prove that by, for example, executing the `ps` command, which will
    list all running processes in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look somewhat similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png)'
  prefs: []
  type: TYPE_IMG
- en: List of processes running inside the trivia container
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the process with `PID 1` is the command that we have
    defined to run inside the trivia container. The process with `PID 1` is also named
    the main process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the container by pressing *Ctrl *+ *D*. We cannot only execute additional
    processes interactive in a container. Please consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output evidently looks very similar to the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/484111d6-69b2-44fc-9529-4d42a780eecc.png)'
  prefs: []
  type: TYPE_IMG
- en: List of processes running inside the trivia container
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even run processes as a daemon using the `-d` flag and define environment
    variables using the `-e` flag variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Great, we have learned how to execute into a running container and run additional
    processes. But there is another important way to mingle with a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `attach` command to attach our Terminal''s standard input, output,
    and error (or any combination of the three) to a running container using the ID
    or name of the container. Let''s do this for our trivia container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will see every five seconds or so a new quote appearing in
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: To quit the container without stopping or killing it, we can press the key combination *Ctrl *+ *P*+
    *Ctrl *+ *Q*. This detaches us from the container while leaving it running in
    the background. On the other hand, if we want to detach and stop the container
    at the same time, we can just press *Ctrl* + *C.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run another container, this time an Nginx web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we run the Alpine version of Nginx as a daemon in a container named `nginx`.
    The `-p 8080:80` command-line parameter opens port `8080` on the host for access
    to the Nginx web server running inside the container. Don''t worry about the syntax
    here as we will explain this feature in more detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *S**ingle-Host
    Networking*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether we can access Nginx using the `curl` tool and running this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If all works correctly, you should be greeted by the welcome page of Nginx
    (shortened for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s attach our Terminal to the `nginx` container to observe what''s
    happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are attached to the container, you first will not see anything. But
    now open another Terminal, and in this new Terminal window, repeat the `curl` command
    a few times, for example, using the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the logging output of Nginx, which looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Quit the container by pressing *Ctrl *+ *C*. This will detach your Terminal
    and, at the same time, stop the `nginx` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To clean up, remove the `nginx` container with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we're going to learn how to work with container logs.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving container logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a best practice for any good application to generate some logging information
    that developers and operators alike can use to find out what the application is
    doing at a given time, and whether there are any problems to help to pinpoint
    the root cause of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running inside a container, the application should preferably output the
    log items to `STDOUT` and `STDERR` and not into a file. If the logging output
    is directed to `STDOUT` and `STDERR`, then Docker can collect this information
    and keep it ready for consumption by a user or any other external system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the logs of a given container, we can use the `docker container logs` command.
    If, for example, we want to retrieve the logs of our `trivia` container, we can
    use the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will retrieve the whole log produced by the application from the very beginning
    of its existence.
  prefs: []
  type: TYPE_NORMAL
- en: Stop, wait a second—this is not quite true, what I just said. By default, Docker
    uses the so-called `json-file` logging driver. This driver stores the logging
    information in a file. And if there is a file rolling policy defined, then `docker
    container logs` only retrieves what is in the current active log file and not
    what is in previous rolled files that might still be available on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to only get a few of the latest entries, we can use the `-t` or `--tail` parameter,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will retrieve only the last five items the process running inside the container
    produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to follow the log that is produced by a container. This
    is possible when using the `-f` or `--follow` parameter. The following expression
    will output the last five log items and then follow the log as it is produced
    by the containerized process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Often using the default mechanism for container logging is not enough. We need
    a different way of logging. This is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Logging drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker includes multiple logging mechanisms to help us to get information from
    running containers. These mechanisms are named** logging drivers**. Which logging
    driver is used can be configured at the Docker daemon level. The default logging
    driver is `json-file`. Some of the drivers that are currently supported natively
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Driver**  | **Description**  |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | No log output for the specific container is produced. |'
  prefs: []
  type: TYPE_TB
- en: '| `json-file` | This is the default driver. The logging information is stored
    in files, formatted as JSON. |'
  prefs: []
  type: TYPE_TB
- en: '| `journald` | If the journals daemon is running on the host machine, we can
    use this driver. It forwards logging to the `journald` daemon. |'
  prefs: []
  type: TYPE_TB
- en: '| `syslog` | If the `syslog` daemon is running on the host machine, we can
    configure this driver, which will forward the log messages to the `syslog` daemon.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gelf` | When using this driver, log messages are written to a **Graylog
    Extended Log Format** (**GELF**) endpoint. Popular examples of such endpoints
    are Graylog and Logstash. |'
  prefs: []
  type: TYPE_TB
- en: '| `fluentd` | Assuming that the `fluentd` daemon is installed on the host system,
    this driver writes log messages to it. |'
  prefs: []
  type: TYPE_TB
- en: If you change the logging driver, please be aware that the `docker container
    logs` command is only available for the `json-file` and `journald` drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Using a container-specific logging driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen that the logging driver can be set globally in the Docker daemon
    configuration file. But we can also define the logging driver on a container by
    container basis. In the following example, we are running a `busybox` container
    and use the `--log-driver` parameter to configure the `none` logging driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to get the logs of the preceding container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to be expected since the `none` driver does not produce any logging
    output. Let''s clean up and remove the `test` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Advanced topic – changing the default logging driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change the default logging driver of a Linux host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this is on a real Linux host. For this purpose, we''re
    going to use Vagrant with an Ubuntu image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Vagrant** is an open source tool developed by Hashicorp that is often used
    for building and maintaining portable virtual software development environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inside the Ubuntu VM, we want to edit the Docker daemon configuration
    file. Navigate to the `/etc/docker` folder and run `vi` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Save and exit `vi` by first pressing *Esc*and then typing `:w:q` and finally
    hitting the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding definition tells the Docker daemon to use the `json-log` driver
    with a maximum log file size of 10 MB before it is rolled, and the maximum number
    of log files that can be present on the system is `3` before the oldest file gets
    purged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to send a `SIGHUP` signal to the Docker daemon so that it picks
    up the changes in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding command only reloads the config file and does not restart
    the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many people wrongly compare containers to VMs. However, this is a questionable
    comparison. Containers are not just lightweight VMs. OK then, *what is the correct
    description of a container?*
  prefs: []
  type: TYPE_NORMAL
- en: Containers are specially encapsulated and secured processes running on the host
    system. Containers leverage a lot of features and primitives available in the Linux
    OS. The most important ones are *namespaces *and *cgroups*. All processes running
    in containers only share the same Linux kernel of the underlying host operating
    system. This is fundamentally different compared with VMs, as each VM contains
    its own full-blown operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The startup times of a typical container can be measured in milliseconds, while
    a VM normally needs several seconds to minutes to start up. VMs are meant to be
    long-living. It is a primary goal of each operations engineer to maximize the
    uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They
    come and go relatively quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first get a high-level overview of the architecture that enables us to
    run containers.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we have an architectural diagram on how this all fits together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png)'
  prefs: []
  type: TYPE_IMG
- en: High-level architecture of Docker
  prefs: []
  type: TYPE_NORMAL
- en: In the lower part of the preceding diagram, we have the Linux operating system
    with its **cgroups**, **Namespaces**, and **Layer** **Capabilities** as well as
    **Other OS Functionality** that we do not need to explicitly mention here. Then,
    there is an intermediary layer composed of **containerd** and **runc**. On top
    of all that now sits the **Docker engine**. The **Docker engine** offers a RESTful
    interface to the outside world that can be accessed by any tool, such as the Docker
    CLI, Docker for macOS, and Docker for Windows or Kubernetes to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now describe the main building blocks in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux namespaces had been around for years before they were leveraged by Docker
    for their containers. A namespace is an abstraction of global resources such as
    filesystems, network access, and process trees (also named PID namespaces) or
    the system group IDs and user IDs. A Linux system is initialized with a single
    instance of each namespace type. After initialization, additional namespaces can
    be created or joined.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version
    3.8, user namespaces were introduced and with it, namespaces were ready to be
    used by containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wrap a running process, say, in a filesystem namespace, then this process
    has the illusion that it owns its own complete filesystem. This, of course, is
    not true; it is only a virtual filesystem. From the perspective of the host, the
    contained process gets a shielded subsection of the overall filesystem. It is
    like a filesystem in a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png)Filesystem namespaces on
    Linux'
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to all of the other global resources for which namespaces exist.
    The user ID namespace is another example. Having a user namespace, we can now
    define a `jdoe `user many times on the system as long as it is living in its own
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PID namespace is what keeps processes in one container from seeing or interacting
    with processes in another container. A process might have the apparent PID **1** inside
    a container, but if we examine it from the host system, it would have an ordinary
    PID, say **334**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png)Process tree on a Docker
    host'
  prefs: []
  type: TYPE_NORMAL
- en: In a given namespace, we can run one to many processes. That is important when
    we talk about containers, and we have experienced that already when we executed
    another process in an already-running container.
  prefs: []
  type: TYPE_NORMAL
- en: Control groups (cgroups)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux cgroups are used to limit, manage, and isolate resource usage of collections
    of processes running on a system. Resources are CPU time, system memory, network
    bandwidth, or combinations of these resources, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers at Google originally implemented this feature in 2006\. The cgroups
    functionality was merged into the Linux kernel mainline in kernel version 2.6.24,
    which was released in January 2008.
  prefs: []
  type: TYPE_NORMAL
- en: Using cgroups, administrators can limit the resources that containers can consume.
    With this, we can avoid, for example, the classical *noisy neighbor* problem,
    where a rogue process running in a container consumes all CPU time or reserves
    massive amounts of RAM and, as such, starves all of the other processes running
    on the host, whether they're containerized or not.
  prefs: []
  type: TYPE_NORMAL
- en: Union filesystem (Unionfs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unionfs forms the backbone of what is known as container images. We will discuss
    container images in detail in the next chapter. At this time, we want to just
    understand a bit better what Unionfs is, and how it works. Unionfs is mainly used
    on Linux and allows files and directories of distinct filesystems to be overlaid
    to form a single coherent filesystem. In this context, the individual filesystems
    are called branches. Contents of directories that have the same path within the
    merged branches will be seen together in a single merged directory, within the
    new virtual filesystem. When merging branches, the priority between the branches
    is specified. In that way, when two branches contain the same file, the one with
    the higher priority is seen in the final filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Container plumbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basement on top of which the Docker engine is built; is the **container
    plumbing** and is formed by two components, **runc** and **containerd**.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, Docker was built in a monolithic way and contained all of the functionality
    necessary to run containers. Over time, this became too rigid and Docker started
    to break out parts of the functionality into their own components. Two important
    components are runc and containerd.
  prefs: []
  type: TYPE_NORMAL
- en: runC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: runC is a lightweight, portable container runtime. It provides full support
    for Linux namespaces as well as native support for all security features available
    on Linux, such as SELinux, AppArmor, seccomp, and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: runC is a tool for spawning and running containers according to the **Open Container
    Initiative** (**OCI**) specification. It is a formally specified configuration format,
    governed by the **Open Container Project** (**OCP**) under the auspices of the
    Linux Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Containerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: runC is a low-level implementation of a container runtime; containerd builds
    on top of it and adds higher-level features, such as image transfer and storage,
    container execution, and supervision as well as network and storage attachments.
    With this, it manages the complete life cycle of containers. Containerd is the
    reference implementation of the OCI specifications and is by far the most popular
    and widely used container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Containerd was donated to and accepted by the CNCF in 2017\. There exist alternative
    implementations of the OCI specification. Some of them are rkt by CoreOS, CRI-O
    by RedHat, and LXD by Linux Containers. However, containerd at this time is by
    far the most popular container runtime and is the default runtime of Kubernetes
    1.8 or later and the Docker platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with containers that are based on existing
    images. We showed how to run, stop, start, and remove a container. Then, we inspected
    the metadata of a container, extracted the logs of it, and learned how to run
    an arbitrary process in an already-running container. Last but not least, we dug
    a bit deeper and investigated how containers work and what features of the underlying
    Linux operating system they leverage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you're going to learn what container images are and how
    we can build and share our own custom images. We'll also be discussing the best
    practices commonly used when building custom images, such as minimizing their
    size and leveraging the image cache. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assess your learning progress, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the states of a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command helps us to find out what is currently running on our Docker host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to list the IDs of all containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers at [http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with containers at [http://dockr.ly/2gmxKWB](http://dockr.ly/2gmxKWB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating containers with a user namespace at [http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting a container's resources at [http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

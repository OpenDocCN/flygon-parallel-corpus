- en: Creating and Managing Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will be familiarizing ourselves with
    these container images. We will learn in detail what they are, how to create them,
    and how to distribute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are images?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lift and shift: Containerizing a legacy app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing or shipping images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name three of the most important characteristics of a container image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a custom image by interactively changing the container layer and committing
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author a simple `Dockerfile` to generate a custom image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker image load`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are images?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, everything is a file. The whole operating system is basically a filesystem
    with files and folders stored on the local disk. This is an important fact to
    remember when looking at what container images are. As we will see, an image is
    basically a big tarball containing a filesystem. More specifically, it contains
    a layered filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The layered filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Container images are templates from which containers are created. These images are
    not made up of just one monolithic block but are composed of many layers. The
    first layer in the image is also called the base layer. We can see this in the
    following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f648f501-f54d-4794-ae3f-c17ec8f78b6c.png)'
  prefs: []
  type: TYPE_IMG
- en: The image as a stack of layers
  prefs: []
  type: TYPE_NORMAL
- en: Each individual layer contains files and folders. Each layer only contains the
    changes to the filesystem with respect to the underlying layers. Docker uses a
    Union filesystem—as discussed in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering
    Containers — *to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous amount of opportunities, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48c83b9e-fef1-45d9-a084-c1076f3e396d.png)'
  prefs: []
  type: TYPE_IMG
- en: A sample custom image based on Alpine and Nginx
  prefs: []
  type: TYPE_NORMAL
- en: Our base layer here consists of the **Alpine Linux** distribution. Then, on
    top of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer only contains the delta of changes in regard to the previous set
    of layers. The content of each layer is mapped to a special folder on the host
    system, which is usually a subfolder of `/var/lib/docker/`.
  prefs: []
  type: TYPE_NORMAL
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: The writable container layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When the Docker Engine creates a container from such an image,
    it adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/35fc8834-7fa6-42ad-bdd6-7979a1878438.png)'
  prefs: []
  type: TYPE_IMG
- en: The writable container layer
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Container Layer** is marked as read/write. Another advantage of the immutability
    of image layers is that they can be shared among many containers created from
    this image. All that is needed is a thin, writable container layer for each container,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0e32cfeb-d02b-4397-8ead-f1e066194ef3.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple containers sharing the same image layers
  prefs: []
  type: TYPE_NORMAL
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps to decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following screenshot, we can see a glimpse of what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7129ffa2-5290-455b-847a-1ae41c2aee0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker image using copy-on-write
  prefs: []
  type: TYPE_NORMAL
- en: The second layer wants to modify **File 2**, which is present in the **Base
    Layer**. Thus, it copies it up and then modifies it. Now, let's say that we're sitting in
    the top layer of the preceding screenshot. This layer will use **File 1** from
    the **Base Layer** and **File 2** and **File 3** from the second layer.
  prefs: []
  type: TYPE_NORMAL
- en: Graph drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is `overlay2`, followed by `overlay`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes one desires, and then committing those changes into a new image. The second,
    and most important, way is to use a `Dockerfile` to describe what's in the new
    image, and then build the image using that `Dockerfile` as a manifest. Finally,
    the third way of creating an image is by importing it into the system from a tarball.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at these three ways in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive image creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let's say that this is the Alpine image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interactively create an image follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to run the container would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs a container based on the `alpine:3.10` image.
  prefs: []
  type: TYPE_NORMAL
- en: We run the container interactively with an attached **teletypewriter** (**TTY**)
    using the `-it` parameter, name it `sample` with the `--name` parameter, and—finally—run
    a shell inside the container using `/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal window where you run the preceding command, you should see
    something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `alpine` container does not have the `ping` tool installed.
    Let's assume we want to create a new custom image that has `ping` installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, we can then run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `apk` Alpine package manager to install the `iputils` library,
    of which `ping` is a part. The output of the preceding command should look approximately
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7095041c-9ad2-4bfc-bc0e-940fd1351b23.png)Installing `ping` on Alpine'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can indeed use `ping`, as the following code snippet shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/914c8ee9-964b-49b0-afe2-e1b0dd28d57b.png)Using ping from within
    the container'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished our customization, we can quit the container by typing `exit` at
    the prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we now list all containers with the `ls -a` Docker container, we can see
    that our sample container has a status of `Exited`, but still exists on the system,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to see what has changed in our container in relation to the base
    image, we can use the `docker container diff` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have shortened the preceding output for better readability. In the list, `A` stands
    for *added*, and `C` stands for *changed*. If we had any deleted files, then those
    would be prefixed with a **`D`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, we have specified that the new image will be called `my-alpine`.
    The output generated by the preceding command corresponds to the ID of the newly
    generated image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by listing all images on our system, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this image ID (shortened) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the image named `my-alpine` has the expected ID of `44bca4141130` and
    automatically got a `latest` tag assigned. This happens since we did not explicitly
    define a tag ourselves. In this case, Docker always defaults to the `latest` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see how our custom image has been built, we can use the `history `command
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print a list of the layers our image consists of, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c399a38d-20a1-48b9-8210-4831f035b78e.png)History of the my-alpine Docker
    image'
  prefs: []
  type: TYPE_NORMAL
- en: The first layer in the preceding output is the one that we just created by adding
    the `iputils` package.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dockerfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also as error-prone as any other task executed manually
    by humans. There must be a better way.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the so-called `Dockerfile` comes into play. A `Dockerfile` is
    a text file that is usually literally called `Dockerfile`. It contains instructions
    on how to build a custom container image. It is a declarative way of building
    images.
  prefs: []
  type: TYPE_NORMAL
- en: '**De****clarative versus imperative**:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, in general, and with Docker specifically, one often uses
    a declarative way of defining a task. One describes the expected outcome and lets
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a sample `Dockerfile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a `Dockerfile` as it is used to containerize a Python 2.7 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`, `RUN`,
    or `COPY`. It is a convention to write the keywords in all caps, but that is not
    a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of the `Dockerfile` results in a layer in the resulting image. In
    the following screenshot, the image is drawn upside down compared to the previous
    illustrations in this chapter, showing an image as a stack of layers. Here, the
    **Base Layer** is shown on top. Don''t let yourself be confused by this. In reality,
    the base layer is always the lowest layer in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f4c11dd-4fed-478b-b229-cdc834633c62.png)'
  prefs: []
  type: TYPE_IMG
- en: The relation of Dockerfile and layers in an image
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the individual keywords in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every `Dockerfile` starts with the `FROM` keyword. With it, we define which
    base image we want to start building our custom image from. If we want to build
    starting with CentOS 7, for example, we would have the following line in the `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I want to containerize a Python 3.7 application, I might want
    to select the relevant official `python:3.7` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we really want to start from scratch, we can also use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful in the context of building super-minimal images that only—for
    example—contain a single binary: the actual statically linked executable, such
    as `Hello-World`. The `scratch` image is literally an empty base image.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM scratch` is a `no-op` in the `Dockerfile`, and as such does not generate
    a layer in the resulting container image.'
  prefs: []
  type: TYPE_NORMAL
- en: The RUN keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter untars a file to a given location. It is completely fine, and even recommended,
    for you to format a Linux command using more than one physical line, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Try to find out what the preceding command does.
  prefs: []
  type: TYPE_NORMAL
- en: The COPY and ADD keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want to
    add some content to an existing base image to make it a custom image. Most of
    the time, these are a few source files of—say—a web application, or a few binaries
    of a compiled application.
  prefs: []
  type: TYPE_NORMAL
- en: These two keywords are used to copy files and folders from the host into the
    image that we're building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack TAR files, as well as providing
    a URL as a source for the files and folders to copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples of how these two keywords can be used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines of code, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line copies everything in the `web` subfolder to the target folder, `/app/web`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it to `my-sample.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth statement unpacks the `sample.tar `file into the target folder, `/app/bin`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a **user ID** (**UID**) and a **group
    ID** (**GID**) of `0`. The good thing is that for both `ADD` and `COPY`, we can
    change the ownership that the files will have inside the image using the optional `--chown` flag,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement will copy all files starting with the name `web` and
    put them into the `/app/data` folder in the image, and at the same time assign
    user `11` and group `22` to these files.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of numbers, one could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group` respectively; otherwise, the build of
    the image would fail.
  prefs: []
  type: TYPE_NORMAL
- en: The WORKDIR keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the `Dockerfile` would
    have to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a `Dockerfile` are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the preceding code with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The `cd` command
    alone is not persisted across layers.
  prefs: []
  type: TYPE_NORMAL
- en: The CMD and ENTRYPOINT keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined for
    a `Dockerfile` are executed at the time the image is built by the Docker builder,
    these two are actually definitions of what will happen when a container is started
    from the image we define. When the container runtime starts a container, it needs
    to know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for—to tell Docker what the
    start process is and how to start that process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don't fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it's just
    the handling of it that is not as straightforward as it could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how to use the two keywords, let''s analyze what a typical
    Linux command or expression looks like. Let''s take the `ping` utility as an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding expression, `ping` is the command and `-c 3 8.8.8.8` are the
    parameters to this command. Let''s look at another expression here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Again, in the preceding expression, `wget` is the command and `-O - http://example.com/downloads/script.sh `are
    the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`. `ENTRYPOINT` is
    used to define the command of the expression, while `CMD` is used to define the
    parameters for the command. Thus, a `Dockerfile` using Alpine as the base image
    and defining `ping` as the process to run in the container could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD` and `ENTRYPOINT`.
    It is also called the *exec* form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, one can also use what''s called the shell form, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now build an image called `pinger` from the preceding `Dockerfile`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run a container from the `pinger` image we just created, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of this is that I can now override the `CMD` part that I have defined
    in the `Dockerfile` (remember, it was `["-c", "3","8.8.8.8"]`) when I create a
    new container by adding the new values at the end of the `docker container run` expression,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will now cause the container to ping the loopback for 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to override what''s defined in the `ENTRYPOINT` in the `Dockerfile`,
    we need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let''s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We will then find ourselves inside the container. Type `exit` to leave the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    we can instead enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I have even used the shell form to define the `CMD`. But what does really
    happen in this situation where `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined,
    then it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  prefs: []
  type: TYPE_NORMAL
- en: A complex Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed the most important keywords commonly used in Dockerfiles.
    Let''s look at a realistic, and somewhat complex example of a `Dockerfile`. The
    interested reader might note that it looks very similar to the first `Dockerfile`
    that we presented in this chapter. Here is the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: OK; so, what is happening here? Evidently, this is a `Dockerfile` that is used
    to build an image for a Node.js application; we can deduce this from the fact
    that the `node:12.5-stretch` base image is used. Then, the second line is an instruction
    to create an `/app` folder in the filesystem of the image. The third line defines
    the working directory or context in the image to be this new `/app` folder. Then,
    on line four, we copy a `package.json` file into the `/app` folder inside the
    image. After this, on line five, we execute the `npm install` command inside the
    container; remember, our context is the `/app` folder, and thus, `npm` will find
    the `package.json` file there that we copied on line four.
  prefs: []
  type: TYPE_NORMAL
- en: After all the Node.js dependencies are installed, we copy the rest of the application
    files from the current folder of the host into the `/app` folder of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a concrete example and build a simple Docker image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your home directory, create a `fod `folder (short for **Fundamentals of
    Docker**) with a  `ch04` subfolder in it, and navigate to this folder, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Save the file and exit your editor.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Back in the Terminal window, we can now build a new container image using
    the preceding `Dockerfile` as a manifest or construction plan, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that there is a period at the end of the preceding command. This
    command means that the Docker builder is creating a new image called `my-centos` using
    the `Dockerfile` that is present in the current directory. Here, the period at
    the end of the command stands for *current directory*. We could also write the
    preceding command as follows, with the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: But we can omit the `-f ` parameter, since the builder assumes that the `Dockerfile`
    is literally called `Dockerfile`. We only ever need the `-f` parameter if our
    `Dockerfile` has a different name or is not located in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command gives us this (shortened) output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the builder does is package the files in the current build context,
    excluding the files and folder mentioned in the `.dockerignore` file (if present),
    and sends the resulting `.tar` file to the `Docker daemon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first line tells us which step of the `Dockerfile` the builder is currently
    executing. Here, we only have two statements in the `Dockerfile`, and we are on
    S*tep 1* of *2*. We can also see what the content of that section is. Here, it
    is the declaration of the base image, on top of which we want to build our custom
    image. What the builder then does is pull this image from Docker Hub, if it is
    not already available in the local cache. The last line of the preceding code
    snippet indicates which ID the just-built image layer gets assigned by the builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, again, the first line indicates to us that we are in S*tep 2* of *2*.
    It also shows us the respective entry from the `Dockerfile`. On line two, we can
    see `Running in bb726903820c`, which tells us that the builder has created a container
    with ID `bb726903820c`, inside which it executes the `RUN `command.
  prefs: []
  type: TYPE_NORMAL
- en: We have omitted the output of the `yum install -y wget `command in the snippet
    since it is not important in this section. When the command is finished, the builder
    stops the container, commits it to a new layer, and then removes the container.
    The new layer has ID `bc070cc81b87`, in this particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very end of the output, we encounter the following two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that the resulting custom image has been given the ID `bc070cc81b87`,
    and has been tagged with the name `my-centos:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does the builder work, exactly? It starts with the base image. From
    this base image, once downloaded into the local cache, the builder creates a container
    and runs the first statement of the `Dockerfile` inside this container. Then,
    it stops the container and persists the changes made in the container into a new
    image layer. The builder then creates a new container from the base image and the
    new layer and runs the second statement inside this new container. Once again,
    the result is committed to a new layer. This process is repeated until the very
    last statement in the `Dockerfile` is encountered. After having committed the
    last layer of the new image, the builder creates an ID for this image and tags
    the image with the name we provided in the `build `command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13c9e699-35e5-40dc-b064-d64472d15f03.png)'
  prefs: []
  type: TYPE_IMG
- en: The image build process visualized
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let's talk about how to further improve this by introducing
    multi-step builds.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-step builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate why a `Dockerfile` with multiple build steps is useful, let''s
    make an example `Dockerfile`. Let''s take a Hello World application written in
    C. Here is the code found inside the `hello.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow along to experience the advantages of a multi-step build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To containerize this application we first write a `Dockerfile` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build this image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is done, we can list the image and see its size shown, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With a size of 176 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is really not desirable when
    running the application, say, in production. Ideally, we only want to have the
    resulting binary in the image and not a whole SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Have a look at this revised `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the first stage with a `build` alias that is used to compile
    the application, and then the second stage uses the same `alpine:3.7` base image
    but does not install the SDK, and only copies the binary from the `build` stage,
    using the `--from` parameter, into this final image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the image again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compare the sizes of the images, we get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have been able to reduce the size from 176 MB down to 4 MB. This is a reduction
    in size by a factor of 40\. A smaller image has many advantages, such as a smaller
    attack surface area for hackers, reduced memory and disk consumption, faster startup
    times of the corresponding containers, and a reduction of the bandwidth needed
    to download the image from a registry, such as Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few recommended best practices to consider when authoring a `Dockerfile`,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with an absolute minimum of setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice tells us that we should order the individual commands
    in the `Dockerfile` so that we leverage caching as much as possible. Building
    a layer of an image can take a considerable amount of time—sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we''re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `npm install` command on line five of the `Dockerfile`
    usually takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. This can take minutes
    until it is done. Therefore, we want to avoid running `npm install `each time
    we rebuild the image, but a developer changes their source code all the time during
    the development of an application. That means that line four, the result of the `COPY `command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which—in
    this case—includes the `npm install` command. To avoid this, we can slightly modify
    the `Dockerfile` and have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is, on line four, we only copied the single file that
    the `npm install` command needs as a source, which is the `package.json `file.
    This file rarely changes in a typical development process. As a consequence, the `npm
    install `command also has to be executed only when the `package.json` file changes.
    All the remaining, frequently changed content is added to the image after the `npm
    install` command.
  prefs: []
  type: TYPE_NORMAL
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But how can we keep our number of layers low? Remember that in a `Dockerfile`,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We could combine these into a single concatenated expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The former will generate three layers in the resulting image, while the latter
    only creates a single layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: The first best practice that helps to reduce the image size is to use a `.dockerignore` file.
    We want to avoid copying unnecessary files and folders into an image, to keep
    it as lean as possible. A `.dockerignore` file works in exactly the same way as
    a `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save ` command to export an existing image
    to a tarball, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command takes our `my-alpine` image that we previously built and
    exports it into a file called  `./backup/my-alpine.tar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container, and profit from this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lift and shift: Containerizing a legacy app'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't always start from scratch and develop a brand new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody really wants to touch
    such an application. Often, the saying *Never touch a running system* applies.
    Yet, market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from benefits introduced by containers?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers to take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion's share
    of the traditional applications in a typical enterprise. But the same is possible
    for any application that was written in—say—C, C++, Python, Node.js, Ruby, PHP,
    or Go, to just name a few other languages and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine such a legacy application for a moment. Assume we have an old
    Java application written 10 years ago, and continuously updated during the following
    5 years. The application is based on Java SE 6, which came out in December 2006\.
    It uses environment variables and property files for configuration. Secrets such
    as username and passwords used in the database connection strings are pulled from
    a secrets keystore, such as HashiCorp's Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of external dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to ask ourselves questions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it use a database? If yes, which one? What does the connection string look
    like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it consuming from or publishing to an **Enterprise Service Bus** (**ESB**)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Source code and build instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  prefs: []
  type: TYPE_NORMAL
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are aware of all the parts that are contributing to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using Maven. Maven is the most popular build automation
    tool for Java, and has been—and still is—used in most enterprises that are developing
    Java applications. In the case of a legacy .NET application, it is most probably
    done by using the MSBuild tool; and in the case of a C/C++ application, Make would
    most likely be used.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, let's extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications need to be configured. Information provided during configuration
    can be—for example— the type of application logging to use, connection strings
    to databases, hostnames to services such as ESBs or URIs to external APIs, to
    name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can differentiate a few types of configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: This is configuration information that varies with the environment
    in which the application is running—for example, DEVELOPMENT versus STAGING or
    PRODUCTION. This kind of configuration is applied to the application when a container
    with the app starts—for example, in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secrets store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer Security** (**TLS**).
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we need to create an inventory of all secrets that our application
    uses and the way it procures them. Is it through environment variable or configuration
    files, or is it by accessing an external keystore, such as HashiCorp's Vault?
  prefs: []
  type: TYPE_NORMAL
- en: Authoring the Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have a complete inventory of all the items discussed in the previous
    few sections, we are ready to author our `Dockerfile`. But I want to warn you:
    don''t expect this to be a one-shot-and-go task. You may need several iterations
    until you have crafted your final `Dockerfile`. The `Dockerfile` may be rather
    long and ugly-looking, but that''s not a problem, as long as we get a working
    Docker image. We can always fine-tune the `Dockerfile` once we have a working
    version.'
  prefs: []
  type: TYPE_NORMAL
- en: The base image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our imaginary application is based on Java SE 6\. If such a base
    image is available, then let's use that one. Otherwise, we want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we use the `RUN` keyword
    in the `Dockerfile`. Remember, `RUN` gives us the possibility to execute any valid
    Linux command in the image during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, we make sure all source files and other artifacts needed to successfully
    build the application are part of the image. Here, we mainly use the two keywords
    of the `Dockerfile`: `COPY` and `ADD`. Initially, the structure of the source
    inside the image should look exactly the same as on the host, to avoid any build
    problems. Ideally, you would have a single `COPY` command that copies all of the
    root project folder from the host into the image. The corresponding `Dockerfile`
    snippet could then look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to also provide a `.dockerignore` file located in the project root
    folder, which lists all the files and (sub-) folders of the project root folder
    that should not be part of the build context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This would create a `foobar` folder in the image's working folder and copy all
    the contents from the URI.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a JAR or WAR file, with or without some satellite
    JARs. This part of the `Dockerfile` should exactly mimic the way you traditionally
    used to build an application before containerizing them. Thus, if using Maven
    as the build automation tool, the corresponding snippet of the `Dockerfile` could
    look as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we may also want to list the environment variables the application
    uses, and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Defining the start command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, a Java application is started with a command such as `java -jar <main
    application jar>` if it is a standalone application. If it is a WAR file, then
    the start command may look a bit different. We can thus either define the `ENTRYPOINT`
    or the `CMD` to use this command. Thus, the final statement in our `Dockerfile`
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint.sh`, but you are free to name it however
    you want. Make sure the file is executable— for example, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of the `Dockerfile` would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves: *Is it really worth the whole effort?*'
  prefs: []
  type: TYPE_NORMAL
- en: Why bother?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, I can see you scratching your head and asking yourself: *Why
    bother?* Why should you take on all this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: More than a 50% saving in maintenance costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to a 90% reduction in the time between the deployments of new releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed at length how to build Docker images, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing or shipping images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to ship our custom image to other environments, we need to first
    give it a globally unique name. This action is often called *tagging* an image.
    We then need to publish the image to a central location from which other interested
    or entitled parties can pull it. These central locations are called *image registries*.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each image has a so-called *tag*. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we''re
    referring to the `latest` tag. This is relevant when pulling an image from Docker
    Hub, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This will now pull the `alpine `image that has been tagged with `3.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Image namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been pulling various images and haven't been worrying so much
    about where those images originated from. Your Docker environment is configured
    so that, by default, all images are pulled from Docker Hub. We also only pulled
    so-called official images from Docker Hub, such as `alpine` or `busybox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to widen our horizon a bit and learn about how images are namespaced.
    The most generic way to define an image is by its fully qualified name, which
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this in a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<registry URL>`: This is the URL to the registry from which we want to pull
    the image. By default, this is `docker.io`. More generally, this could be `https://registry.acme.com`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other than Docker Hub, there are quite a few public registries out there that
    you could pull images from. The following is a list of some of them, in no particular
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon AWS **Amazon Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artifactory, at [https://jfrog.com/integration/artifactory-docker-registry/](https://jfrog.com/integration/artifactory-docker-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<User or Org>`: This is the private Docker ID of either an individual or an
    organization defined on Docker Hub—or any other registry, for that matter—such
    as `microsoft` or `oracle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name>`: This is the name of the image, which is often also called a repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tag>`: This is the tag of the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are some special conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: If we omit the registry URL, then Docker Hub is automatically taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we omit the tag, then `latest` is taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few samples in tabular form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Image** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `alpine` | Official alpine image on Docker Hub with the latest tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `ubuntu:19.04` | Official `ubuntu` image on Docker Hub with the `19.04` tag
    or version. |'
  prefs: []
  type: TYPE_TB
- en: '| `microsoft/nanoserver` | `nanoserver` image of Microsoft on Docker Hub with
    the `latest` tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `acme/web-api:12.0` | `web-api` image version `12.0` associated with the `acme` org.
    The image is on Docker Hub. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcr.io/gnschenker/sample-app:1.1` | `sample-app` image with the `1.1` tag belonging
    to an individual with the `gnschenker` ID on Google''s container registry. |'
  prefs: []
  type: TYPE_TB
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let's talk about some special images we can find on Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Official images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding table, we mentioned *official image* a few times. This needs an
    explanation. Images are stored in repositories on the Docker Hub registry. Official
    repositories are a set of repositories hosted on Docker Hub that are curated by
    individuals or organizations that are also responsible for the software packaged
    inside the image. Let's look at an example of what that means. There is an official
    organization behind the Ubuntu Linux distro. This team also provides official
    versions of Docker images that contain their Ubuntu distros.
  prefs: []
  type: TYPE_NORMAL
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  prefs: []
  type: TYPE_NORMAL
- en: Docker sponsors a team whose task it is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to a registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating custom images is all well and good, but at some point, we want to actually
    share or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular and public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  prefs: []
  type: TYPE_NORMAL
- en: On a registry, one can usually create personal or organizational accounts. For
    example, my personal account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we'll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to push an image to my personal account on Docker Hub, I need to
    tag it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say I want to push the latest version of Alpine to my account and give
    it a tag of `1.0`. I can do this in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful login, I can then push the image, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'I will see something similar to this in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if one is logged
    in to the registry and has the necessary permissions configured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed in detail what container images are and how
    we can build and ship them. As we have seen, there are three different ways that
    an image can be created—either manually, automatically, or by importing a tarball
    into the system. We also learned some of the best practices commonly used when
    building custom images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to introduce Docker volumes that can be used
    to persist the state of a container. We'll also show how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a Dockerfile that inherits from Ubuntu version `19.04`,
    and that installs `ping` and runs `ping` when a container starts? The default
    address to `ping` will be `127.0.0.1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you create a new container image that uses `alpine:latest` and installs `curl`?
    Name the new image `my-alpine:1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Dockerfile` that uses multiple steps to create an image of a Hello
    World app of minimal size, written in C or Go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name three essential characteristics of a Docker container image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `$ docker container push foo:1.0` B. `$ docker image tag foo:1.0 jdoe/foo:1.0`
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker image push jdoe/foo:1.0` C. `$ docker login -u jdoe -p <your password>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker image tag foo:1.0 jdoe/foo:1.0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker image push jdoe/foo:1.0` D. `$ docker login -u jdoe -p <your password>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker container tag foo:1.0 jdoe/foo:1.0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker container push jdoe/foo:1.0` E. `$ docker login -u jdoe -p <your
    password>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker image push foo:1.0 jdoe/foo:1.0`'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list of references gives you some material that dives more deeply
    into the topic of authoring and building container images:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for writing Dockerfiles, at[http://dockr.ly/22WiJiO](http://dockr.ly/22WiJiO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multi-stage builds, at[http://dockr.ly/2ewcUY3](http://dockr.ly/2ewcUY3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About storage drivers, at[http://dockr.ly/1TuWndC](http://dockr.ly/1TuWndC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphdriver plugins, at[http://dockr.ly/2eIVCab](http://dockr.ly/2eIVCab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-guided caching in Docker for Mac, at[http://dockr.ly/2xKafPf](http://dockr.ly/2xKafPf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

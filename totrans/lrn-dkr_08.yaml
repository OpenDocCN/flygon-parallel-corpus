- en: Debugging Code Running in Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行的代码调试
- en: In the previous chapter, we learned how to work with stateful containers, that
    is, containers that consume and produce data. We also learned how to configure
    our containers at runtime and at image build time using environment variables
    and config files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何处理有状态的容器，即消耗和产生数据的容器。我们还学习了如何使用环境变量和配置文件在运行时和镜像构建时配置我们的容器。
- en: In this chapter, we're going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
    With these techniques at hand, you will enjoy a frictionless development process
    for applications running in a container, similar to what you experience when developing
    applications that run natively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍常用的技术，允许开发人员在容器中运行时演变、修改、调试和测试他们的代码。有了这些技术，您将享受到在容器中运行应用程序时无摩擦的开发过程，类似于开发本地运行的应用程序时的体验。
- en: 'Here is a list of the topics we''re going to discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将讨论的主题列表：
- en: Evolving and testing code running in a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行的代码进行演变和测试
- en: Auto restarting code upon changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更改后自动重新启动代码
- en: Line-by-line code debugging inside a container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内逐行调试代码
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的代码添加仪表，以产生有意义的日志信息
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jaeger进行监控和故障排除
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够做到以下事情：
- en: Mount source code residing on the host in a running container
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码挂载到运行中的容器中
- en: Configure an application running in a container to auto-restart after a code
    change
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置在容器中运行的应用程序在代码更改后自动重新启动
- en: Configure Visual Studio Code to debug applications written in Java, Node.js,
    Python, or .NET running inside a container line by line
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Visual Studio Code以逐行调试在容器内运行的Java、Node.js、Python或.NET编写的应用程序
- en: Log important events from your application code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序代码中记录重要事件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on macOS or Windows and a code editor—preferably Visual Studio Code.
    The sample will also work on a Linux machine with Docker and VS Code installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您想跟着代码进行操作，您需要在macOS或Windows上安装Docker for Desktop和一个代码编辑器——最好是Visual
    Studio Code。该示例也适用于安装了Docker和VS Code的Linux机器。
- en: Evolving and testing code running in a container
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行的代码进行演变和测试
- en: 'When developing code that will eventually be running in a container, it is
    often the best approach to run the code in the container from the very beginning,
    to make sure there will be no unexpected surprises. But, we have to do this in
    the right way in order not to introduce any unnecessary friction into our development
    process. Let''s first look at a naive way that we could run and test code in a
    container:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发最终将在容器中运行的代码时，通常最好的方法是从一开始就在容器中运行代码，以确保不会出现意外的情况。但是，我们必须以正确的方式来做这件事，以免在开发过程中引入不必要的摩擦。让我们首先看一下我们可以在容器中运行和测试代码的天真方式：
- en: 'Create a new project folder and navigate to it:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹并导航到它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s use `npm` to create a new Node.js project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`npm`来创建一个新的Node.js项目：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Accept all the defaults. Notice that a `package.json` file is created with
    the following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受所有默认设置。请注意，将创建一个`package.json`文件，内容如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to use the Express.js library in our Node application; thus, use `npm`
    to install it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在我们的Node应用程序中使用Express.js库；因此，使用`npm`来安装它：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will install the newest version of Express.js on our machine and, because
    of the `--save` parameter, add a reference to our `package.json` file that looks
    similar to this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的机器上安装最新版本的Express.js，并且由于`--save`参数，会向我们的`package.json`文件添加一个类似于这样的引用：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start VS Code from within this folder:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该文件夹中启动VS Code：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In VS Code, create a new `index.js` file and add this code snippet to it. Do
    not forget to save:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中，创建一个新的`index.js`文件，并将以下代码片段添加到其中。不要忘记保存：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From back within your terminal window, start the application:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端窗口中再次启动应用程序：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see this as the output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that the application is running and ready to listen at `0.0.0.0:3000`.
    You may ask yourself what the meaning of the host address `0.0.0.0` is and why
    we have chosen it. We will come back to that later, when we run the application
    inside a container. For the moment, just know that `0.0.0.0` is a reserved IP
    address with a special meaning, similar to the loopback address `127.0.0.1`. The `0.0.0.0` address
    simply means *all IPv4 addresses on the local machine*. If a host has two IP addresses,
    say `52.11.32.13` and `10.11.0.1`, and a server running on the host listens on
    `0.0.0.0`, it will be reachable at both of those IPs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序正在运行并准备在`0.0.0.0:3000`上监听。您可能会问自己主机地址`0.0.0.0`的含义是什么，为什么我们选择了它。稍后我们会回到这个问题，当我们在容器内运行应用程序时。暂时只需知道`0.0.0.0`是一个具有特殊含义的保留IP地址，类似于环回地址`127.0.0.1`。`0.0.0.0`地址简单地意味着*本地机器上的所有IPv4地址*。如果主机有两个IP地址，比如`52.11.32.13`和`10.11.0.1`，并且在主机上运行的服务器监听`0.0.0.0`，它将在这两个IP上可达。
- en: 'Now open a new tab in your favorite browser and navigate to `localhost:3000`.
    You should see this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在您喜欢的浏览器中打开一个新标签，并导航到`localhost:3000`。您应该看到这个：
- en: '![](assets/90516b3c-77d7-4443-9850-c5483270a0ea.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90516b3c-77d7-4443-9850-c5483270a0ea.png)'
- en: Sample Node.js app running in a browser
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的示例Node.js应用程序
- en: Great—our Node.js application is running on our developer machine. Stop the
    application by pressing *Ctrl* + *C* in the terminal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们的Node.js应用程序正在我们的开发者机器上运行。在终端中按*Ctrl* + *C*停止应用程序。
- en: 'Now we want to test the application we have developed so far by running it
    inside a container. To do this, we have to create a `Dockerfile` first, so that
    we can build a container image, from which we can then run a container. Let''s
    use VS Code again to add a file called `Dockerfile` to our project folder and
    give it the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想通过在容器内运行来测试我们迄今为止开发的应用程序。为此，我们首先必须创建一个`Dockerfile`，以便我们可以构建一个容器镜像，然后从中运行一个容器。让我们再次使用VS
    Code将一个名为`Dockerfile`的文件添加到我们的项目文件夹中，并给它以下内容：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then use this `Dockerfile` to build an image called `sample-app` as
    follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个`Dockerfile`来构建一个名为`sample-app`的镜像，如下所示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After building, run the application in the container with this command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建后，使用以下命令在容器中运行应用程序：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command runs a container with the name `my-sample-app` from the
    container image `sample-app` and maps the container port `3000` to the equivalent
    host port. The port mapping is necessary; otherwise, we could not access the application
    running inside the container from outside the container. We will learn more about
    port mapping in *[Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)*, *Single-Host
    Networking*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令从容器镜像`sample-app`运行一个名为`my-sample-app`的容器，并将容器端口`3000`映射到等效的主机端口。端口映射是必要的；否则，我们无法从容器外部访问在容器内运行的应用程序。我们将在*[第10章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)*，*单主机网络*中学到更多关于端口映射的知识。
- en: 'Similar to when we ran the application directly on our host, the output is
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在主机上直接运行应用程序时类似，输出如下：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Refresh the browser tab from before (or open a new browser tab and navigate
    to `localhost:3000`, if you closed it). You should see that the application still
    runs and produces the same output as when running natively. This is good. We have
    just shown that our application not only runs on our host but also inside a container.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新之前的浏览器标签（或者打开一个新的浏览器标签并导航到`localhost:3000`，如果你关闭了它）。你应该看到应用程序仍然运行，并产生与本地运行时相同的输出。这很好。我们刚刚证明了我们的应用不仅在我们的主机上运行，而且在容器内部也可以运行。
- en: Stop and remove the container by pressing *Ctrl* + *C* in the terminal.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中按*Ctrl* + *C*停止和删除容器。
- en: 'Now let''s modify our code and add some additional functionality. We will define
    another `HTTP GET` endpoint at `/hobbies`. Please add the following code snippet
    to your `index.js` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的代码并添加一些额外的功能。我们将在`/hobbies`处定义另一个`HTTP GET`端点。请将以下代码片段添加到您的`index.js`文件中：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can first test the new functionality on our host by running the app with
    `node index.js` and navigating to `localhost:3000/hobbies` in the browser. We
    should see the expected output in the browser window. Don't forget to stop the
    application with *Ctrl* + *C* when done testing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先在主机上运行应用程序，通过`node index.js`运行应用程序，并在浏览器中导航到`localhost:3000/hobbies`。我们应该在浏览器窗口中看到预期的输出。测试完成后，不要忘记使用*Ctrl* + *C*停止应用程序。
- en: 'Next, we need to test the code when it runs inside the container. Thus, first,
    we create a new version of the container image:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要测试代码在容器内运行时的情况。因此，首先，我们创建一个新版本的容器映像：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we run a container from this new image:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从这个新映像运行一个容器：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we can navigate to `localhost:3000/hobbies` in our browser and confirm
    that the application works as expected inside the container too. Once again, don't
    forget to stop the container when done by pressing *Ctrl* + *C*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中导航到`localhost:3000/hobbies`，并确认应用程序在容器内部也按预期工作。再次强调，测试完成后，请不要忘记通过按*Ctrl* + *C*停止容器。
- en: We can repeat this sequence of tasks over and over again for each feature we
    add or any existing features we improve. It turns out that this is a lot of added
    friction compared to times when all the applications we developed always ran directly
    on the host.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一遍又一遍地重复这一系列任务，为我们添加的每个功能或改进的现有功能。事实证明，与我们开发的所有应用程序都直接在主机上运行的时候相比，这增加了很多摩擦。
- en: However, we can do better. In the next section, we will look at a technique
    that allows us to remove most of the friction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好。在下一节中，我们将看一种技术，它允许我们消除大部分摩擦。
- en: Mounting evolving code into the running container
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将不断发展的代码装载到正在运行的容器中
- en: What if, after a code change, we do not have to rebuild the container image
    and rerun a container? Wouldn't it be great if the changes would immediately,
    as we save them in an editor such as VS Code, be available inside the container
    too? Well, exactly that is possible with volume mapping. In the last chapter,
    we learned how to map an arbitrary host folder into an arbitrary location inside
    a container. We want to leverage exactly that in this section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码更改后，我们不必重新构建容器映像并重新运行容器呢？如果我们在编辑器（如VS Code）中保存更改后，更改立即在容器内部可用，这不是很好吗？好吧，使用卷映射确实可以做到这一点。在上一章中，我们学习了如何将任意主机文件夹映射到容器内的任意位置。我们想要在本节中利用这一点。
- en: 'We saw in [*Chapter 5*](f3a48b12-d541-467b-aeb3-df014e60da6b.xhtml), *Data
    Volumes and Configuration*, how we can map host folders as volumes in a container.
    If I want, for example, to mount a host folder, `/projects/sample-app`, into a
    container at `/app`, the syntax for this looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](f3a48b12-d541-467b-aeb3-df014e60da6b.xhtml)中，*数据卷和配置*，我们看到了如何将主机文件夹映射为容器中的卷。例如，如果我想要将主机文件夹`/projects/sample-app`挂载到容器中的`/app`，则其语法如下：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the line `--volume <host-folder>:<container-folder>`. The path to the
    host folder needs to be an absolute path, as in the example, `/projects/sample-app`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意行`--volume <host-folder>:<container-folder>`。主机文件夹的路径需要是绝对路径，就像示例中的`/projects/sample-app`一样。
- en: 'If we now want to run a container from our `sample-app` container image, and,
    if we do that from the project folder, then we can map the current folder into
    the `/app` folder of the container as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想要从我们的`sample-app`容器映像运行一个容器，并且如果我们从项目文件夹中这样做，那么我们可以将当前文件夹映射到容器的`/app`文件夹中，如下所示：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note the `$(pwd)` in place of the host folder path. `$(pwd)` evaluates
    to the absolute path of the current folder, which comes in very handy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`$(pwd)`代替主机文件夹路径。`$(pwd)`会计算为当前文件夹的绝对路径，这非常方便。
- en: Now, if we do mount the current folder into the container as described above,
    then whatever was in the `/app` folder of the `sample-app` container image will
    be overridden by the content of the mapped host folder, that is, in our case,
    the current folder. That's exactly what we want—we want the current source to
    be mapped from the host in the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们按照上述描述将当前文件夹挂载到容器中，那么`sample-app`容器映像的`/app`文件夹中的内容将被映射主机文件夹的内容覆盖，也就是在我们的情况下是当前文件夹。这正是我们想要的
    - 我们希望将主机中的当前源映射到容器中。
- en: 'Let''s test whether it works:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下是否有效：
- en: Stop the container if you have started it by pressing *Ctrl* + *C.*
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经启动了容器，请按*Ctrl* + *C*停止它。
- en: 'Then add the following snippet to the end of the `index.js` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将以下代码片段添加到`index.js`文件的末尾：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Do not forget to save.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记保存。
- en: 'Then run the container again – this time without rebuilding the image first
    – to see what happens:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后再次运行容器 - 这次不需要先重新构建镜像 - 看看会发生什么：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In your browser, navigate to `localhost:3000/status` and expect to see the `OK`
    output in the browser window. Alternatively, you could use `curl` in another terminal
    window:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，导航到`localhost:3000/status`，并期望在浏览器窗口中看到`OK`输出。或者，您可以在另一个终端窗口中使用`curl`。
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For all those working on Windows and/or Docker for Windows, you can use the
    PowerShell command `Invoke-WebRequest` or `iwr` for short instead of `curl`. The
    equivalent to the preceding command would then be `iwr -Url localhost:3000/status`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有在Windows和/或Docker for Windows上工作的人，您可以使用PowerShell命令`Invoke-WebRequest`或`iwr`代替`curl`。然后，前面命令的等效命令将是`iwr
    -Url localhost:3000/status`。
- en: Leave the application in the container running for the moment and make yet another
    change. Instead of just returning `OK` when navigating to `/status`, we want the
    message `OK, all good` to be returned. Make your modification and save the changes.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时让容器中的应用程序继续运行，并进行另一个更改。我们不仅希望在导航到“/status”时返回“OK”，还希望返回消息“OK，一切正常”。进行修改并保存更改。
- en: Then execute the `curl` command again or, if you did use the browser, refresh
    the page. What do you see? Right—nothing happened. The change we made is not reflected
    in the running application.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后再次执行`curl`命令，或者如果您使用了浏览器，请刷新页面。你看到了什么？没错 - 什么也没发生。我们所做的更改没有反映在运行的应用程序中。
- en: 'Well, let''s double-check whether the change has been propagated in the running
    container. To do this, let''s execute the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，让我们再次仔细检查更改是否已在运行的容器中传播。为此，让我们执行以下命令：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should see something like this—I have shortened the output for readability:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似这样的东西 - 我已经缩短了输出以便阅读：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Evidently, our changes have been propagated into the container as expected.
    Why, then, are the changes not reflected in the running application? Well, the
    answer is simple: for changes to be applied to the application, the application
    has to be restarted.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的更改已经按预期传播到容器中。那么，为什么更改没有反映在运行的应用程序中呢？嗯，答案很简单：要应用更改到应用程序，必须重新启动应用程序。
- en: 'Let''s try that. Stop the container with the application running by pressing
    *Ctrl* + *C*. Then re-execute the preceding `docker container run` command and
    use `curl` to probe the endpoint `localhost:3000/status`. Now, the following new
    message should be displayed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试看。通过按*Ctrl* + *C*停止运行应用程序的容器。然后重新执行前面的`docker container run`命令，并使用`curl`来探测端点`localhost:3000/status`。现在，应该显示以下新消息：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we have achieved a significant reduction in the friction in the development
    process by mapping the source code in the running container. We can now add new
    or modify existing code and test it without having to build the container image
    first. Yet, there is still a bit of friction left in play. We have to manually
    restart the container every time we want to test some new or modified code. Can
    we automate this? The answer is yes! We will demonstrate exactly this in the next
    section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在运行的容器中映射源代码，我们在开发过程中实现了摩擦的显著减少。现在，我们可以添加新的或修改现有的代码并进行测试，而无需首先构建容器镜像。然而，仍然存在一些摩擦。每次想要测试一些新的或修改过的代码时，我们必须手动重新启动容器。我们能自动化这个过程吗？答案是肯定的！我们将在下一节中具体演示这一点。
- en: Auto restarting code upon changes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在更改后自动重启代码
- en: Cool—in the last section, we showed how we can massively reduce friction by
    volume mapping the source code folder in the container, thus avoiding having to
    rebuild the container image and rerun the container over and over again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，在上一节中，我们展示了如何通过在容器中进行源代码文件的卷映射来大大减少摩擦，从而避免不断重建容器镜像和重新运行容器。
- en: Yet we still feel some remaining friction. The application running inside the
    container does not automatically restart when a code change happens. Thus, we
    have to manually stop and restart the container to pick up the new changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然感到一些摩擦。容器内运行的应用程序在代码更改发生时不会自动重启。因此，我们必须手动停止和重新启动容器才能应用新的更改。
- en: Auto-restarting for Node.js
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的自动重启
- en: 'If you have been coding for a while, you will certainly have heard about helpful
    tools that can run your applications and restart them automatically whenever they
    discover a change in the code base. For Node.js applications, the most popular
    such tool is `nodemon`. We can install `nodemon` globally on our system with the
    following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编程一段时间了，肯定听说过一些有用的工具，可以在发现代码库中的更改时运行应用程序并自动重启它们。对于Node.js应用程序，最流行的工具就是`nodemon`。我们可以使用以下命令在系统上全局安装`nodemon`：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, having `nodemon` available, instead of starting our application (for example,
    on the host) with `node index.js`, we can just execute `nodemon` and we should
    see the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了`nodemon`，我们可以不再用`node index.js`在主机上启动应用程序，而是直接执行`nodemon`，我们应该会看到以下内容：
- en: '![](assets/22d2758a-af1d-4dde-8ad2-130203229506.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22d2758a-af1d-4dde-8ad2-130203229506.png)'
- en: Using nodemon to run a Node.js application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nodemon运行Node.js应用程序
- en: Evidently, `nodemon` has recognized, from parsing our `package.json` file, that
    it should use `node index.js` as the start command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`nodemon`已经从解析我们的`package.json`文件中认识到，它应该使用`node index.js`作为启动命令。
- en: 'Now try to change some code, for example, add the following code snippet at
    the end of `index.js` and then save the file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试更改一些代码，例如，在`index.js`的末尾添加以下代码片段，然后保存文件：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Look at the terminal window. Did you see something happening? You should see
    this additional output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下终端窗口。你看到有什么发生了吗？你应该看到这个额外的输出：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This clearly indicates that `nodemon` has recognized some changes and automatically
    restarted the application. Try it out with your browser by navigating to `localhost:3000/colors`.
    You should see the following expected output in the browser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明`nodemon`已经认识到了一些更改，并自动重新启动了应用程序。通过浏览器尝试一下，导航到`localhost:3000/colors`。你应该在浏览器中看到以下预期的输出：
- en: '![](assets/83c6ee39-05cc-4c27-a7d2-c609feb6f425.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83c6ee39-05cc-4c27-a7d2-c609feb6f425.png)'
- en: Getting colors
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 获取颜色
- en: 'This is cool—you got this result without having to manually restart the application.
    This makes us yet another bit more productive. Now, can we do the same within
    the container? Yes, we can. We won''t use the start command `node index.js`, as
    defined in the last line of our `Dockerfile`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷——你得到了这个结果，而不必手动重新启动应用程序。这使我们又多了一点生产力。现在，我们能在容器内做同样的事情吗？是的，我们可以。我们不会使用在我们的`Dockerfile`的最后一行中定义的启动命令`node
    index.js`：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will use `nodemon` instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nodemon`代替。
- en: Do we have to modify our `Dockerfile`? Or do we need two different `Dockerfiles`,
    one for development and one for production?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们的`Dockerfile`吗？还是我们需要两个不同的`Dockerfiles`，一个用于开发，一个用于生产？
- en: 'Our original `Dockerfile` creates an image that unfortunately does not contain
    `nodemon`. Thus, we need to create a new `Dockerfile`. Let''s call it `Dockerfile-dev`.
    It should look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始`Dockerfile`创建了一个不幸不包含`nodemon`的镜像。因此，我们需要创建一个新的`Dockerfile`。让我们称之为`Dockerfile-dev`。它应该是这样的：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Comparing with our original Dockerfile, we have added line 2 where we install
    `nodemon`. We have also changed the last line and are now using `nodemon` as our
    start command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的原始Dockerfile相比，我们添加了第2行，安装了`nodemon`。我们还改变了最后一行，现在使用`nodemon`作为我们的启动命令。
- en: 'Let''s build our development image as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式构建我们的开发镜像：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll run a container like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样运行一个容器：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, while the application is running in the container, change some code, save,
    and notice that the application inside the container is automatically restarted.
    Thus, we have achieved the same reduction in friction running in a container as
    we did when running directly on the host.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当应用程序在容器中运行时，改变一些代码，保存，并注意到容器内的应用程序会自动重新启动。因此，我们在容器中运行时实现了与直接在主机上运行时相同的减少摩擦。
- en: You may ask, does this only apply to Node.js? No, fortunately many of the popular
    languages support similar concepts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这只适用于Node.js吗？不，幸运的是，许多流行的语言支持类似的概念。
- en: Auto-restarting for Python
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的自动重启
- en: 'Let''s look at how the same thing works for Python:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看同样的东西在Python中是如何工作的：
- en: 'First, create a new project folder for our sample Python application and navigate
    to it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们的示例Python应用程序创建一个新的项目文件夹，并导航到它：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Open VS Code from within this folder with the command `code .`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令`code .`从这个文件夹中打开VS Code。
- en: We will create a sample Python application that uses the popular Flask library.
    Thus, add a `requirements.txt` file with the `flask` content to this folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个使用流行的Flask库的示例Python应用程序。因此，向这个文件夹添加一个`requirements.txt`文件，其中包含`flask`的内容。
- en: 'Next, add a `main.py` file and give it this content:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`main.py`文件，并给它这个内容：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a simple **Hello World** type app that implements a single RESTful endpoint
    at `localhost:5000/`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的**Hello World**类型的应用程序，在`localhost:5000/`上实现了一个RESTful端点。
- en: 'Before we can run and test this application, we need to install the dependencies—Flask
    in our case. In the terminal, run the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以运行和测试这个应用程序之前，我们需要安装依赖项——在我们的情况下是Flask。在终端中运行以下命令：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This should install Flask on your host. We are now ready to go.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在你的主机上安装Flask。我们现在准备好了。
- en: 'When using Python, we can also use `nodemon` to have our application auto restart
    upon any changes to the code. For example, assume that your command to start the
    Python application is `python main.py`. Then you would just use `nodemon` as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Python时，我们也可以使用`nodemon`来在代码发生任何更改时自动重新启动我们的应用程序。例如，假设你的启动Python应用程序的命令是`python
    main.py`。那么你只需要像下面这样使用`nodemon`：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个：
- en: '![](assets/ad1953cc-ef81-47b5-98a3-f1e499a79d2e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ad1953cc-ef81-47b5-98a3-f1e499a79d2e.png)'
- en: 'Using `nodemon` to start and monitor a Python application, we can test the
    application by using `curl` and should see this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nodemon`启动和监视Python应用程序，我们可以使用`curl`测试该应用程序，并应该看到这个：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now modify the code by adding this snippet to `main.py`, right after
    the definition of the `/` endpoint, and save:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过将此片段添加到`main.py`中的`/`端点的定义之后，并保存来修改代码：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`nodemon` will discover the changes and restart the Python app, as we can see
    in the output produced in the terminal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodemon`将发现更改并重新启动Python应用程序，正如我们可以在终端产生的输出中看到的那样：'
- en: '![](assets/4a5a9882-9ffa-4e7c-b3f4-96291e0a18a8.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a5a9882-9ffa-4e7c-b3f4-96291e0a18a8.png)'
- en: nodemon discovering a change in the Python code
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: nodemon发现Python代码的更改
- en: 'Once again, believing is good, testing is better. Thus, let''s use our friend
    `curl` once again to probe the new endpoint and see what we get:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，相信是好的，测试更好。因此，让我们再次使用我们的朋友`curl`来探测新的端点，看看我们得到了什么：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nice—it works! With that, we have covered Python. .NET is another popular platform.
    Let's see if we can do something similar to this when developing a C# application
    on .NET.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 很好-它有效！有了这个，我们已经涵盖了Python。.NET是另一个流行的平台。让我们看看在.NET上开发C#应用程序时是否可以做类似的事情。
- en: Auto-restarting for .NET
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的自动重启
- en: Our next candidate is a .NET application written in C#. Let's look at how auto-restart
    works in .NET.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个候选者是用C#编写的.NET应用程序。让我们看看.NET中的自动重启是如何工作的。
- en: 'First, create a new project folder for our sample C# application and navigate
    to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们的示例C#应用程序创建一个新的项目文件夹并导航到它：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you have not done so before, please install .NET Core on your laptop or workstation.
    You can get it at [https://dotnet.microsoft.com/download/dotnet-core](https://dotnet.microsoft.com/download/dotnet-core).
    At the time of writing, version 2.2 is the current stable version. Once it's installed,
    check the version with `dotnet --version`. It is `2.2.401` for me.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有这样做，请在您的笔记本电脑或工作站上安装.NET Core。您可以在[https://dotnet.microsoft.com/download/dotnet-core](https://dotnet.microsoft.com/download/dotnet-core)上获取它。在撰写本文时，版本2.2是当前稳定版本。安装完成后，使用`dotnet
    --version`检查版本。对我来说是`2.2.401`。
- en: 'Navigate to the source folder for this chapter:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到本章的源文件夹：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From within this folder, use the `dotnet` tool to create a new Web API and
    have it placed in the `dotnet` subfolder:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个文件夹内，使用`dotnet`工具创建一个新的Web API，并将其放在`dotnet`子文件夹中：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Navigate to this new project folder:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到这个新项目文件夹：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again, use the `code .` command to open VS Code from within the `dotnet` folder.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`code .`命令从`dotnet`文件夹内打开VS Code。
- en: If this is the first time you have opened a .NET Core 2.2 project with VS Code,
    then the editor will start to download some C# dependencies. Wait until all dependencies
    have been downloaded. The editor may also display a popup asking you to add the
    missing dependencies for our `dotnet` project. Click the `Yes` button in this
    case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用VS Code打开.NET Core 2.2项目，那么编辑器将开始下载一些C#依赖项。等到所有依赖项都下载完成。编辑器可能还会显示一个弹出窗口，询问您是否要为我们的`dotnet`项目添加缺少的依赖项。在这种情况下点击“是”按钮。
- en: 'In the project explorer of VS Code, you should see this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code的项目资源管理器中，您应该看到这个：
- en: '![](assets/e3bc6adf-1a8c-47a6-abaa-c82a45273bf6.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3bc6adf-1a8c-47a6-abaa-c82a45273bf6.png)'
- en: DotNet Web API project in the VS Code Project Explorer
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code项目资源管理器中的DotNet Web API项目
- en: Please note the `Controllers` folder with the `ValuesController.cs` file in
    it. Open this file and analyze its content. It contains the definition for a `ValuesController` class,
    which implements a simple RESTful controller with `GET`, `PUT`, `POST`, and `DELETE`
    endpoints at `api/values`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意`Controllers`文件夹中的`ValuesController.cs`文件。打开此文件并分析其内容。它包含了`ValuesController`类的定义，该类实现了一个简单的RESTful控制器，其中包含`GET`、`PUT`、`POST`和`DELETE`端点在`api/values`。
- en: 'From your terminal, run the application with `dotnet run`. You should see something
    like this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端运行应用程序使用 `dotnet run`。您应该会看到类似以下内容：
- en: '![](assets/ce9234ee-0777-4f2a-b923-096fa5eed231.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce9234ee-0777-4f2a-b923-096fa5eed231.png)'
- en: Running the .NET sample Web API on the host
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上运行.NET示例Web API
- en: 'We can use `curl` to test the application as follows, for example:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 测试应用程序，例如：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The application runs and returns the expected result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行并返回了预期的结果。
- en: Please note that the application is configured to redirect `http://localhost:5000`
    to `https://localhost:5001` by default. But, this is an insecure endpoint and
    to suppress the warning, we use the `--insecure` switch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，该应用程序配置为将 `http://localhost:5000` 重定向到 `https://localhost:5001`。但是，这是一个不安全的端点，为了抑制警告，我们使用
    `--insecure` 开关。
- en: 'We can now try to modify the code in `ValuesController.cs` and return, say,
    three items instead of two from the first `GET` endpoint:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试修改 `ValuesController.cs` 中的代码，并从第一个 `GET` 端点返回三个项目而不是两个。
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save your changes and rerun the `curl` command. Notice how the result does not
    contain the new added value. It is the same problem as we observed for Node.js
    and Python. To see the new updated return value, we need to (manually) restart
    the application.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改并重新运行 `curl` 命令。注意结果不包含新添加的值。这与我们观察到的Node.js和Python的问题相同。要查看新更新的返回值，我们需要（手动）重新启动应用程序。
- en: Thus, in your terminal, stop the application with *Ctrl* + *C *and restart it
    with `dotnet run`. Try the `curl` command again. The result should now reflect
    your changes.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在您的终端中，使用 *Ctrl* + *C* 停止应用程序，并使用 `dotnet run` 重新启动。再次尝试 `curl` 命令。结果现在应该反映您的更改。
- en: 'Luckily for us, the `dotnet` tool has the `watch` command. Stop the application
    by pressing *Ctrl* + *C* and execute `dotnet watch run`. You should see output
    resembling the following:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，`dotnet` 工具有 `watch` 命令。通过按 *Ctrl* + *C* 停止应用程序并执行 `dotnet watch run`。您应该会看到类似以下内容的输出：
- en: '![](assets/301a815c-a80b-481b-9dc9-62e4c3c3b1c4.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/301a815c-a80b-481b-9dc9-62e4c3c3b1c4.png)'
- en: Running the .NET sample application with the watch task
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 watch 任务运行.NET示例应用程序
- en: Notice the second line in the preceding output, which states that the running
    application is now watched for changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面输出的第二行，指出正在运行的应用程序现在正在监视更改。
- en: 'Make another change in `ValuesController.cs`; for example, add a fourth item
    to the return value of the first `GET` endpoint and save. Observe the output in
    the terminal. It should look something like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ValuesController.cs` 中进行另一个更改；例如，在第一个 `GET` 端点的返回值中添加第四个项目并保存。观察终端中的输出。它应该看起来像这样：
- en: '![](assets/9fba6353-e07a-4a10-b126-527c6a8db185.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9fba6353-e07a-4a10-b126-527c6a8db185.png)'
- en: Auto restarting the running sample .NET Core application
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重新启动正在运行的.NET Core示例应用程序
- en: 'With that automatic restart of the application upon changes to the code, the
    result is immediately available to us and we can easily test it by running the `curl`
    command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对代码进行更改，应用程序会自动重新启动，结果立即对我们可用，并且我们可以通过运行 `curl` 命令轻松测试它：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have auto restart working on the host, we can author a Dockerfile
    that does the same for the application running inside a container. In VS Code,
    add a new file called `Dockerfile-dev` to the project and add the following content
    to it:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在主机上有自动重启工作，我们可以编写一个Dockerfile，在容器内运行的应用程序也可以实现相同的功能。在VS Code中，向项目添加一个名为
    `Dockerfile-dev` 的新文件，并向其中添加以下内容：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we can continue and build the container image, we need to add a slight
    modification to the startup configuration of the .NET application, such that the
    web server (Kestrel in this case) listens, for example, at `0.0.0.0:3000` and
    will thus be able to run inside a container and be accessible from outside of
    the container. Open the `Program.cs` file and make the following modification
    to the `CreateWebHostBuilder` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续构建容器镜像之前，我们需要对.NET应用程序的启动配置进行轻微修改，使得Web服务器（在这种情况下是Kestrel）监听，例如，`0.0.0.0:3000`，因此能够在容器内运行并且能够从容器外部访问。打开`Program.cs`文件，并对`CreateWebHostBuilder`方法进行以下修改：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the `UseUrls` method, we tell the web server to listen to the desired endpoints.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`UseUrls`方法，我们告诉Web服务器监听所需的端点。
- en: 'Now we''re ready to build the container image:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备构建容器镜像：
- en: 'To build the image use the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建镜像：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once the image is built, we can run a container from it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，我们就可以从中运行一个容器：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We should see a similar output to that seen when running natively:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似于本地运行时看到的输出：
- en: '![](assets/4b6f2740-1d2a-41ce-9da3-757f75512528.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b6f2740-1d2a-41ce-9da3-757f75512528.png)'
- en: A .NET sample application running in a container
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行的.NET示例应用程序
- en: 'Let''s test the application with our friend `curl`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用我们的朋友`curl`来测试应用程序：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: No surprises here—it works as expected.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外——它按预期工作。
- en: 'Now let''s do a code change in the controller and then save. Observe what''s
    happening in the terminal window. We should see an output similar to this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在控制器中进行代码更改，然后保存。观察终端窗口中发生的情况。我们应该看到类似于这样的输出：
- en: '![](assets/7f7041fc-6e7e-4f62-b663-1f828997d1fa.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7f7041fc-6e7e-4f62-b663-1f828997d1fa.png)'
- en: Auto restart happening to the .NET sample application running inside the container
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的.NET示例应用程序的自动重启
- en: Well, that's exactly what we expected. With this, we have removed most of the
    friction introduced by using containers when developing a .NET application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这正是我们所期望的。通过这样做，我们已经消除了在开发.NET应用程序时使用容器引入的大部分摩擦。
- en: Line-by-line code debugging inside a container
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内逐行代码调试
- en: Before we dive into this section about the line-by-line debugging of code running
    inside a container, let me make a disclaimer. What you will learn here should
    usually be your last resort, if nothing else works. Ideally, when following a
    test-driven approach when developing your application, the code is mostly guaranteed
    to work due to the fact that you have written unit and integration tests for it
    and run them against your code, which also runs in a container. Alternatively,
    if unit or integration tests don't provide you with enough insight and you really
    need to debug your code line by line, you can do so having your code running directly
    on your host, thus leveraging the support of development environments such as
    Visual Studio, Eclipse, or IntelliJ, to name just a few IDEs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论容器内运行代码的逐行调试之前，让我先做一个声明。你将在这里学到的东西通常应该是你最后的选择，如果其他方法都不起作用的话。理想情况下，在开发应用程序时遵循测试驱动的方法，由于你已经为它编写了单元测试和集成测试，并对代码进行了测试，所以代码大部分是可以保证工作的，这些测试也是在容器中运行的。或者，如果单元测试或集成测试不能为你提供足够的洞察力，你确实需要逐行调试你的代码，你可以在主机上直接运行你的代码，从而利用开发环境的支持，比如Visual
    Studio、Eclipse或IntelliJ等IDE。
- en: With all this preparation, you should rarely need to have to manually debug
    your code as it is running inside a container. That said, let's see how you can
    do it!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一切准备，你应该很少需要手动调试你的代码，因为它是在容器内运行的。也就是说，让我们看看你如何做到这一点！
- en: In this section, we are going to concentrate exclusively on how to debug when
    using Visual Studio Code. Other editors and IDEs may or may not offer similar
    capabilities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于如何在使用Visual Studio Code时进行调试。其他编辑器和IDE可能或可能不提供类似的功能。
- en: Debugging a Node.js application
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Node.js应用程序
- en: 'We''ll start with the easiest one—a Node.js application. We will use our sample
    application in folder `~/fod/ch06/node`, which we worked with earlier in this
    chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的开始——一个Node.js应用程序。我们将使用我们在本章早些时候使用过的`~/fod/ch06/node`文件夹中的示例应用程序：
- en: 'Make sure that you navigate to this project folder and open VS Code from within
    it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您导航到此项目文件夹并从其中打开VS Code：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the terminal window, from within the project folder, run a container with
    our sample Node.js application:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，从项目文件夹内部，运行一个带有我们示例Node.js应用程序的容器：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note how I map port `9229` to the host. This port is used by the debugger, and
    VS Studio will communicate with our Node application via this port. Thus it is
    important that you open this port—but only during a debugging session! Also note
    that we override the standard start command defined in the Dockerfile (`node index.js`)
    with `node --inspect=0.0.0.0 index.js`. `--inspect=0.0.0.0` tells Node to run
    in debug mode and listen on all IP4 addresses in the container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我是如何将端口`9229`映射到主机的。这个端口是调试器使用的，VS Studio将通过这个端口与我们的Node应用程序通信。因此，重要的是您打开这个端口——但只在调试会话期间！还要注意，我们用`node
    --inspect=0.0.0.0 index.js`覆盖了Dockerfile中定义的标准启动命令（`node index.js`）。`--inspect=0.0.0.0`告诉Node以调试模式运行，并在容器中监听所有IP4地址。
- en: 'Now we are ready to define a VS Code launch task for the scenario at hand,
    that is, our code running inside a container:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备为手头的场景定义一个VS Code启动任务，也就是我们的代码在容器内运行：
- en: To open the`launch.json` file, press *Ctrl*+*Shift*+*P*(or *Ctrl*+*Shift*+*P*
    on Windows) to open the command palette and look for `Debug:Open launch.json`
    and select it. The `launch.json` file should open in the editor.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开`launch.json`文件，按*Ctrl*+*Shift*+*P*（或在Windows上按*Ctrl*+*Shift*+*P*）打开命令面板，然后搜索`Debug:Open
    launch.json`并选择它。`launch.json`文件应该在编辑器中打开。
- en: Click the blue Add Configuration... button to add the new configuration we need
    to debug inside the container.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色的“Add Configuration...”按钮，添加我们需要在容器内调试的新配置。
- en: 'From the options, select `Docker: Attach to Node`. A new entry will be added
    to the configurations list in the `launch.json` file. It should look similar to
    this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从选项中选择`Docker: Attach to Node`。新条目将被添加到`launch.json`文件的配置列表中。它应该看起来类似于这样：'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since we have our code in the `/app` folder, inside the container, we need to
    change the value of `remoteRoot` accordingly. Change the `/usr/src/app` value
    to just `/app`. Do not forget to save your change. That's it, we are ready to
    roll.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码在`/app`文件夹中，容器内部，我们需要相应地更改`remoteRoot`的值。将`/usr/src/app`的值更改为`/app`。不要忘记保存您的更改。就是这样，我们已经准备好了。
- en: Open the Debug view in VS Code by pressing c*ommand* + S*hift* + *D* (*Ctrl *+
    *Shift *+ *D* on Windows).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*command* + *Shift* + *D*（在Windows上为*Ctrl* + *Shift* + *D*）来打开VS Code中的调试视图。
- en: 'Make sure you select the correct launch task in the dropdown right next to
    the green start button at the top of the view. Select `Docker: Attach to Node`
    as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '确保您在视图顶部的绿色启动按钮旁边的下拉菜单中选择正确的启动任务。选择`Docker: Attach to Node`如下所示：'
- en: '![](assets/b1ea1249-cad6-4c9a-86af-5fc24de37ce6.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b1ea1249-cad6-4c9a-86af-5fc24de37ce6.png)'
- en: Selecting the correct launch task for debugging in VS Code
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code中选择正确的启动任务进行调试
- en: Next click on the green start button to attach VS Code to the Node application
    running in the container.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击绿色的启动按钮，将VS Code连接到运行在容器中的Node应用程序。
- en: 'Open `index.js` in the editor and put a breakpoint on the line that returns
    the message `"Sample Application: Hello World!"` when calling the endpoint `''/''`.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在编辑器中打开`index.js`，并在调用端点''/''时在返回消息`"Sample Application: Hello World!"`的行上设置断点。'
- en: 'In another terminal window, use `curl` to navigate to `localhost:3000/` and
    observe that the code execution stops at the breakpoint:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用`curl`导航到`localhost:3000/`，并观察代码执行是否在断点处停止：
- en: '![](assets/65e22b06-430b-48ec-ab33-d522d29b3480.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65e22b06-430b-48ec-ab33-d522d29b3480.png)'
- en: The code execution stops at the breakpoint
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行在断点处停止
- en: In the preceding screenshot, we can see the yellow bar indicating that the code
    execution has stopped at the breakpoint. In the upper-right corner, we have a
    toolbar that allows us to navigate through the code, for example, step by step.
    On the left-hand side, we see the `VARIABLES`, `WATCH`, and `CALL STACK` windows,
    which we can use to observe the details of our running application. The fact that
    we are really debugging the code running inside the container can be verified
    by the fact that in the terminal windows where we started the container, we see
    the output `Debugger attached.`, which was generated the moment we started debugging
    inside VS Code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到黄色条表示代码执行已在断点处停止。在右上角，我们有一个工具栏，允许我们浏览代码，例如，逐步执行。在左侧，我们看到`VARIABLES`，`WATCH`和`CALL
    STACK`窗口，我们可以使用它们来观察我们运行的应用程序的细节。我们真正调试运行在容器内的代码的事实可以通过在启动容器的终端窗口中看到输出`Debugger
    attached.`来验证，这是我们在VS Code中开始调试时生成的。
- en: 'Let''s look how we can further improve the debugging experience:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何进一步改进调试体验：
- en: 'To stop the container, enter the following command in the terminal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止容器，请在终端中输入以下命令：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we want to use `nodemon` for even more flexibility, then we have to change
    the `container run` command slightly:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要使用`nodemon`来获得更大的灵活性，那么我们必须稍微改变`container run`命令：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note how we use the start command, `nodemon --inspect=0.0.0.0 index.js`. This
    will have the benefit that, upon any code changes, the application running inside
    the container will restart automatically, as we learned earlier in this chapter.
    You should see the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用启动命令`nodemon --inspect=0.0.0.0 index.js`。这将带来一个好处，即在任何代码更改时，容器内运行的应用程序将自动重新启动，就像我们在本章前面学到的那样。您应该看到以下内容：
- en: '![](assets/8379cd11-64ae-4823-b772-f879d145b95a.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8379cd11-64ae-4823-b772-f879d145b95a.png)'
- en: Starting the Node.js application with nodemon and debugging turned on
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nodemon启动Node.js应用程序并打开调试功能
- en: 'Unfortunately, the consequence of an application restart is that the debugger
    loses the connection with VS Code. But no worries—we can mitigate this by adding
    `"restart": true` to our launch task in the `launch.json` file. Modify the task
    such that it looks like this:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '不幸的是，应用程序重新启动的后果是调试器与VS Code失去了连接。但别担心，我们可以通过在`launch.json`文件中的启动任务中添加`"restart":
    true`来减轻这一点。修改任务，使其看起来像这样：'
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After saving your changes, start the debugger in VS Code by clicking the green
    start button in the debug window. In the terminal, you should again see that the `Debugger
    attached.` message is output. In addition to that, VS Code shows an orange status
    bar at the bottom, indicating that the editor is in debug mode.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，通过单击调试窗口中的绿色启动按钮在VS Code中启动调试器。在终端中，您应该再次看到输出`Debugger attached.`。除此之外，VS
    Code在底部显示一个橙色状态栏，指示编辑器处于调试模式。
- en: In a different terminal window, use `curl` and try to navigate to `localhost:3000/`
    to test that line-by-line debugging still works. Make sure code execution stops
    at any breakpoint you have set in the code.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用`curl`并尝试导航到`localhost:3000/`，以测试逐行调试是否仍然有效。确保代码执行在代码中设置的任何断点处停止。
- en: 'Once you have verified that debugging still works, try to modify some code;
    for example, change the message `"Sample Application: Hello World!"` to `"Sample
    Application: Message from within container"` and save your changes. Observe how
    `nodemon` restarts the application and the debugger is automatically re-attached
    to the application running inside the container:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2786f876-ec6c-47de-b54a-79dc3cde1e03.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: nodemon restarting the application and the debugger automatically re-attaching
    to application
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have everything assembled and can now work with code running inside
    a container as if the same code were running natively on the host. We have removed
    pretty much all of the friction that the introduction of containers brought into
    the development process. We can now just enjoy the benefits of deploying our code
    in containers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To clean up, stop the container by pressing *Ctrl* + *C*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a .NET application
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to give a quick run-through on how you can debug a .NET application
    line-by-line. We will use the sample .NET application that we created earlier
    in this chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project folder and open VS Code from within there:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To work with the debugger, we need to first install the debugger in the container.
    Thus, let''s create a new `Dockerfile` in the project directory. Call it `Dockerfile-debug`
    and add the following content:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Please note the second line of the `Dockerfile`, which uses `apt-get` to install
    the `unzip` tool and then uses `curl` to download and install the debugger.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build an image called `sample-app-dotnet-debug` from this `Dockerfile`
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command can take a moment to execute since, among other things, the debugger
    has to be downloaded and installed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we can run a container from this image interactively:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will see something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eecd50e0-5674-474a-b60d-600c956d815a.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Sample .NET application started interactively inside the SDK container
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'In VS Code, open the `launch.json` file and add the following launch task:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Save your changes and switch to the debug window of VS Code (use *command*
    + *Shift* + *D* or *Ctrl* + *Shift* + *D *to open it). Make sure you have selected
    the correct debug launch task—its name is `.NET Core Docker Attach`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f4744775-bcb8-4275-add7-0236bbcf96c1.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Select the correct debug launch task in VS Code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click the green start button to start the debugger. As a consequence, the
    popup to select the process shows up with the list of potential processes to attach
    to. Select the process that looks like the one marked in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在单击绿色的启动按钮启动调试器。因此，弹出窗口显示了要附加到的潜在进程列表。选择看起来像下面截图中标记的进程。
- en: '![](assets/d80edd11-6973-4b92-a886-569ddbd47bda.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d80edd11-6973-4b92-a886-569ddbd47bda.png)'
- en: Select the process to attach the debugger to
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要附加调试器的进程
- en: 'Let''s put a breakpoint in the first `GET` request of the `ValuesController.cs` file
    and then execute a `curl` command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ValuesController.cs`文件的第一个`GET`请求中设置一个断点，然后执行一个`curl`命令：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The code execution should stop at the breakpoint, as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行应该在断点处停止，如下所示：
- en: '![](assets/86642156-418e-4b9a-a322-7638e3970993.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86642156-418e-4b9a-a322-7638e3970993.png)'
- en: Line-by-line debugging a .NET Core application running inside a container
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的.NET Core应用程序进行逐行调试
- en: We can now step through the code, define watches, or analyze the call stack
    of the application, similar to what we did with the sample Node.js application.
    Hit the Continue button on the debug toolbar or press *F5* to continue the code
    execution.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以逐步执行代码，定义观察点，或者分析应用程序的调用堆栈，类似于我们在示例Node.js应用程序中所做的。单击调试工具栏上的“继续”按钮或按*F5*继续执行代码。
- en: Now change some code and save the changes. Observe in the terminal window how
    the application is automatically restarted.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改一些代码并保存更改。观察终端窗口中应用程序如何自动重新启动。
- en: Use `curl` again to test whether your changes are visible to the application.
    Indeed, the changes are available, but have you noticed something? Yes—the code
    execution did not start at the breakpoint. Unfortunately, restarting the application
    caused the debugger to disconnect. You have to re-attach the debugger afresh by
    clicking the start button in the debug view of VS Code and selecting the right
    process.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`curl`测试您的更改是否对应用程序可见。确实，更改是可用的，但您是否注意到了什么？是的，代码执行没有从断点开始。不幸的是，重新启动应用程序会导致调试器断开连接。您必须通过单击VS
    Code调试视图中的启动按钮并选择正确的进程来重新附加调试器。
- en: To stop the application, press *Ctrl* + *C* in the terminal window where you
    started the container.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止应用程序，请在启动容器的终端窗口中按*Ctrl* + *C*。
- en: Now that we know how to debug code running in a container line by line, it is
    time to instrument our code such that it produces meaningful logging information.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何逐行调试容器中运行的代码，是时候为我们的代码添加有意义的日志信息了。
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的代码添加有意义的日志信息
- en: Once an application is running in production, it is impossible or strongly discouraged
    to interactively debug the application. Thus, we need to come up with other ways
    to find the root cause when the system is behaving unexpectedly or causing errors.
    The best way is to have the application generate detailed logging information
    that can then be used by the developers that need to track down any errors. Since
    logging is such a common task, all relevant programming languages or frameworks
    offer libraries that make the task of producing logging information inside an
    application straightforward.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在生产环境中运行，就不可能或者强烈不建议交互式调试应用程序。因此，当系统行为异常或引起错误时，我们需要想出其他方法来找到根本原因。最好的方法是让应用程序生成详细的日志信息，然后开发人员可以使用这些信息来跟踪任何错误。由于日志记录是如此常见的任务，所有相关的编程语言或框架都提供了使应用程序内部生成日志信息的库。
- en: 'It is common to categorize the information output by an application as logs
    into so-called severity levels. Here is the list of those severity levels with
    a short description of each:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序输出的信息分类为日志，并称为严重级别是很常见的。以下是这些严重级别的列表，以及每个的简短描述：
- en: '| **Security levels** | **Explanation** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **安全级别** | **解释** |'
- en: '| TRACE | Very fine-grained information. At this level, you are looking at
    capturing every detail possible about your application''s behavior. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| TRACE | 非常精细的信息。在这个级别，您正在捕获关于应用程序行为的每一个可能的细节。 |'
- en: '| DEBUG | Relatively granular and mostly diagnostic information helping to
    pin down potential problems if they occur. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| DEBUG | 相对细粒度和大多数诊断信息，有助于确定潜在问题。 |'
- en: '| INFO | Normal application behavior or milestones. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| INFO | 正常的应用程序行为或里程碑。 |'
- en: '| WARN | The application might have encountered a problem or you detected an
    unusual situation. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| WARN | 应用程序可能遇到问题，或者您检测到异常情况。 |'
- en: '| ERROR | The application encountered a serious issue. This most probably represents
    the failure of an important application task. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| ERROR | 应用程序遇到严重问题。这很可能代表了重要应用程序任务的失败。 |'
- en: '| FATAL | The catastrophic failure of your application. The immediate shutdown
    of the application is advised. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| FATAL | 应用程序的灾难性失败。建议立即关闭应用程序。 |'
- en: List of the severity levels used when generating logging information
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 生成日志信息时使用的严重级别列表
- en: Logging libraries usually allow a developer to define different log sinks, that
    is, destinations for the logging information. Popular sinks are file sinks or
    a stream to the console. When working with containerized applications, it is strongly
    recommended to always direct logging output to the console or `STDOUT`. Docker
    will then make this information available to you via the `docker container logs`
    command. Other log collectors, such as Prometheus, can also be used to scrape
    this information.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库通常允许开发人员定义不同的日志接收器，即日志信息的目的地。常见的接收器是文件接收器或控制台流。在使用容器化应用程序时，强烈建议始终将日志输出定向到控制台或`STDOUT`。然后Docker将通过`docker
    container logs`命令向您提供此信息。还可以使用其他日志收集器，如Prometheus，来抓取此信息。
- en: Instrumenting a Python application
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Python应用程序进行仪器化
- en: 'Let''s now try to instrument our existing Python sample application:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试为我们现有的Python示例应用程序进行仪器化：
- en: 'First, in your terminal, navigate to the project folder and open VS Code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的终端中，导航到项目文件夹并打开VS Code：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open the `main.py` file and add the following code snippet to the top of it:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.py`文件，并在顶部添加以下代码片段：
- en: '![](assets/871e4924-7ec2-432a-a734-32236d84e6dd.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/871e4924-7ec2-432a-a734-32236d84e6dd.png)'
- en: Defining a logger for our Python sample application
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的Python示例应用程序定义一个记录器
- en: On line `1`, we import the standard `logging` library. We then define a `logger`
    for our sample application of line `3`. On line `4`, we define the filter for
    logging to be used. In this case, we set it to `WARN`. That means that all logging
    messages produced by the application with a severity equal to or higher than `WARN`
    will be output to the defined `logging` handlers or sinks as we called them at
    the beginning of this section. In our case, only log messages with a log level
    of `WARN`, `ERROR`, or `FATAL` will be output.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`1`行，我们导入标准的`logging`库。然后我们在第`3`行为我们的示例应用程序定义一个`logger`。在第`4`行，我们定义要使用的日志过滤器。在这种情况下，我们将其设置为`WARN`。这意味着应用程序产生的所有日志消息，其严重程度等于或高于`WARN`，将被输出到在本节开头称为`logging`处理程序或接收器的定义。在我们的情况下，只有具有`WARN`、`ERROR`或`FATAL`日志级别的日志消息将被输出。
- en: On line `6`, we create a logging sink or handler. In our case, it is `StreamHandler`,
    which outputs to `STDOUT`. Then, on line `8`, we define how we want the `logger`
    to format the messages it outputs. Here, the format that we chose will output
    the time and date, the application (or `logger`) name, the log severity level,
    and finally, the actual message that we developers define in code. On line `9`,
    we add the formatter to the log handler, and, on line `10`, we add the handler
    to the `logger`. Note that we can define more than one handler per logger. Now
    we are ready to use the `logger`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`6`行，我们创建了一个日志接收器或处理程序。在我们的情况下，它是`StreamHandler`，输出到`STDOUT`。然后，在第`8`行，我们定义了我们希望`logger`如何格式化输出的消息。在这里，我们选择的格式将输出时间和日期、应用程序（或`logger`）名称、日志严重级别，最后是我们开发人员在代码中定义的实际消息。在第`9`行，我们将格式化程序添加到日志处理程序中，在第`10`行，我们将处理程序添加到`logger`中。请注意，我们可以为每个logger定义多个处理程序。现在我们准备使用`logger`了。
- en: 'Let''s instrument the `hello` function, which is called when we navigate to
    the endpoint `/`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来对`hello`函数进行仪器化，当我们导航到端点`/`时会调用该函数：
- en: '![](assets/fd0e1528-73d0-4dc2-9f33-1b788f7a9049.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fd0e1528-73d0-4dc2-9f33-1b788f7a9049.png)'
- en: Instrumenting a method with logging
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志记录对方法进行仪器化
- en: 'As you can see in the preceding screenshot, we have added line `17`, where
    we use the `logger` object to produce a logging message with log level `INFO`.
    The message is: `"Accessing endpoint ''/''"`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上面的截图中所见，我们在第`17`行添加了一行，我们在那里使用`logger`对象生成了一个日志级别为`INFO`的日志消息。消息是："访问端点'/'"。
- en: 'Let''s instrument another function and output a message with the log level
    `WARN`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对另一个函数进行仪器化，并输出一个日志级别为`WARN`的消息：
- en: '![](assets/2e8a0fd1-181f-42ac-9222-60b87d106f48.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2e8a0fd1-181f-42ac-9222-60b87d106f48.png)'
- en: Generating a warning
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个警告
- en: This time, we produce a message with the log level `WARN` on line `24` in the
    `colors` function. So far, so good—that wasn't hard!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们在`colors`函数的第`24`行以`WARN`日志级别生成了一条消息。到目前为止，一切都很顺利——这并不难！
- en: 'Let''s now run the application and see what output we get:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行应用程序，看看我们得到什么输出：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in your browser, navigate to `localhost:5000/` first and then to `localhost:5000/colors`.
    You should see an output similar to this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在浏览器中，首先导航到`localhost:5000/`，然后导航到`localhost:5000/colors`。您应该看到类似于这样的输出：
- en: '![](assets/94cb7b3f-8a45-4b3d-a3ee-4888acffcac0.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94cb7b3f-8a45-4b3d-a3ee-4888acffcac0.png)'
- en: Running the instrumented sample Python application
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 运行经过仪器化的示例Python应用程序
- en: As you can see, only the warning is output to the console; the `INFO` message
    is not. This is due to the filter we set when defining the logger. Also note how
    our logging message is formatted with the date and time at the beginning, then
    the name of the logger, the log level, and finally, our actual message defined
    on line `24` of our application. When done, please stop the application by pressing
    *Ctrl* + *C*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只有警告被输出到控制台；`INFO`消息没有。这是由于我们在定义logger时设置的过滤器。还请注意，我们的日志消息是如何以日期和时间开头，然后是logger的名称，日志级别，最后是我们在应用程序的第`24`行定义的实际消息。完成后，请按*Ctrl*
    + *C*停止应用程序。
- en: Instrumenting a .NET C# application
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对.NET C#应用程序进行仪器化
- en: 'Let''s now instrument our sample C# application:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对我们的示例C#应用程序进行仪器化：
- en: 'First, navigate to the project folder, from where you''ll open VS Code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到项目文件夹，从那里您将打开VS Code：
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to add a NuGet package containing the logging library to the
    project:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要向项目添加一个包含日志库的NuGet包：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should add the following line to your `dotnet.csproj` project file:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将以下行添加到您的`dotnet.csproj`项目文件中：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open the `Program.cs` class and notice that we call the `CreateDefaultBuilder(args)` method
    on line `21`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`类，并注意我们在第`21`行调用了`CreateDefaultBuilder(args)`方法。
- en: '![](assets/cc3af0cf-28b2-4e96-a70e-738c8e871f1b.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc3af0cf-28b2-4e96-a70e-738c8e871f1b.png)'
- en: Configuring logging in ASP.NET Core 2.2
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 2.2中配置日志记录
- en: This method, by default, adds a few logging providers to the application, among
    them the console logging provider. This comes in very handy and frees us from
    having to do any complicated configuration first. You can, of course, override
    the default setting any time with your own settings.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此方法向应用程序添加了一些日志提供程序，其中包括控制台日志提供程序。这非常方便，使我们无需进行任何复杂的配置。当然，您可以随时使用自己的设置覆盖默认设置。
- en: 'Next, open the `ValuesController.cs` file in the `Controllers` folder and add
    the following `using` statement to the top of the file:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在“Controllers”文件夹中打开“ValuesController.cs”文件，并在文件顶部添加以下“using”语句：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, in the class body, add an instance variable, `_logger`, of type `ILogger`
    and add a constructor that has a parameter of type `ILogger<T>`. Assign this parameter
    to the instance variable `_logger`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类主体中，添加一个名为“_logger”的实例变量，类型为“ILogger”，并添加一个具有类型为“ILogger<T>”的参数的构造函数。将此参数分配给实例变量“_logger”：
- en: '![](assets/114ba9e1-3443-46be-8da0-70cb5f48bde9.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/114ba9e1-3443-46be-8da0-70cb5f48bde9.png)'
- en: Defining a logger for the Web API controller
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为Web API控制器定义一个记录器
- en: 'Now we''re ready to use the logger in the controller methods. Let''s instrument
    the `Get` method with an `INFO` message:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备在控制器方法中使用记录器。让我们使用“INFO”消息对“Get”方法进行调试：
- en: '![](assets/98f9a43a-89d6-4850-993c-3d1f0253e917.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98f9a43a-89d6-4850-993c-3d1f0253e917.png)'
- en: Logging an INFO message from the API controller
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从API控制器记录INFO消息
- en: 'Let''s now instrument the `Get(int id)` method:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们对“Get(int id)”方法进行一些调试：
- en: '![](assets/161ac8ba-ad9b-43a9-9cbe-b3151ddf2062.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/161ac8ba-ad9b-43a9-9cbe-b3151ddf2062.png)'
- en: Logging messages with log levels WARN and ERROR
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志级别WARN和ERROR记录消息
- en: On line `31`, we have the logger generate a `DEBUG` message and then we have
    some logic on line `32` to catch unexpected values for `id` and producing `ERROR`
    messages and returning an HTTP response status of `404` (not found).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在第31行，我们让记录器生成一个DEBUG消息，然后在第32行对“id”的意外值进行一些逻辑处理，并生成ERROR消息并返回HTTP响应状态404（未找到）。
- en: 'Let''s run the application with the following:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下内容运行应用程序：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We should see this when navigating to `localhost:3000/api/values`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当导航到“localhost:3000/api/values”时，我们应该看到这个：
- en: '![](assets/7b90f29e-efdc-4077-ba5e-40260a5a84ad.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7b90f29e-efdc-4077-ba5e-40260a5a84ad.png)'
- en: Log of our sample .NET application when accessing endpoint `/api/values`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 访问端点“/api/values”时我们示例.NET应用程序的日志
- en: We can see the output of our log message of type `INFO`. All the other log items
    have been produced by the ASP.NET Core library. You can see that there is a lot
    of helpful information available if you need to debug the application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的INFO类型的日志消息输出。所有其他日志项都是由ASP.NET Core库生成的。您可以看到如果需要调试应用程序，则有大量有用的信息可用。
- en: 'Now let''s try to access the endpoint `/api/values/{id}` with an invalid value
    for `{id}`. We should see something along the lines of this:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用无效的“{id}”值访问端点“/api/values/{id}”。我们应该看到类似于以下内容：
- en: '![](assets/872f1f7b-a2ac-4fd4-9fd1-f40e69862d30.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/872f1f7b-a2ac-4fd4-9fd1-f40e69862d30.png)'
- en: Debug and error log items generated by our .NET sample application
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的.NET示例应用程序生成的调试和错误日志项
- en: We can clearly first see the log item with the level `DEBUG` and then the one
    with the level `ERROR`. The latter in the output is marked in red as `fail`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先可以清楚地看到级别为“DEBUG”的日志项，然后是级别为“ERROR”的日志项。输出中后者标记为“fail”并以红色显示。
- en: When done, please end the application with *Ctrl +* C.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，请使用*Ctrl +* C结束应用程序。
- en: Now that we have learned about instrumenting, we will look at Jaeger in the
    next section.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何进行调试，接下来我们将在下一节中学习Jaeger。
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jaeger进行监视和故障排除
- en: When we want to monitor and troubleshoot transactions in a complex distributed
    system, we need something a bit more powerful than what we have just learned.
    Of course, we can and should continue to instrument our code with meaningful logging
    messages, yet we need something more on top of that. This *more* is the capability
    to trace a single request or transaction end to end, as it flows through the system
    consisting of many application services. Ideally, we would also want to capture
    other interesting metrics such as the time spent on each component versus the
    total time that the request took.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要监视和排查复杂分布式系统中的事务时，我们需要比我们刚刚学到的更强大的东西。当然，我们可以并且应该继续用有意义的日志消息来仪器化我们的代码，但我们需要更多的东西。这*更多*是追踪单个请求或事务的能力，从而使其在由许多应用服务组成的系统中流动时，我们可以端到端地追踪它。理想情况下，我们还希望捕获其他有趣的指标，比如在每个组件上花费的时间与请求所花费的总时间。
- en: Luckily, we do not have to reinvent the wheel. There is battle-tested open source
    software out there that helps us to achieve exactly the aforementioned goals.
    One example of such an infrastructure component or software is Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)).
    When using Jaeger, you run a central Jaeger server component and each application
    component uses a Jaeger client that will forward debug and tracing information
    transparently to the Jaeger server component. There are Jaeger clients for all
    major programming languages and frameworks, such as Node.js, Python, Java, and
    .NET.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必重新发明轮子。有经过实战考验的开源软件可以帮助我们实现上述目标。这样一个基础设施组件或软件的例子就是Jaeger（[https://www.jaegertracing.io/](https://www.jaegertracing.io/)）。使用Jaeger时，您运行一个中央Jaeger服务器组件，每个应用组件都使用一个Jaeger客户端，该客户端会将调试和跟踪信息透明地转发到Jaeger服务器组件。对于所有主要的编程语言和框架，如Node.js、Python、Java和.NET，都有Jaeger客户端。
- en: 'We will not go into all the intimate details of how to use Jaeger in this book,
    but will give a high-level overview of how it works conceptually:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中详细介绍如何使用Jaeger的所有细节，但会对其工作原理进行高层次的概述：
- en: First, we define a Jaeger `tracer` object. This object basically coordinates
    the whole process of tracing a request through our distributed application. We
    can use this `tracer` object and also create a `logger` object from it, which
    our application code can use to generate log items, similar to what we did in
    the previous Python and .NET examples.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个Jaeger`tracer`对象。这个对象基本上协调了我们的分布式应用程序中追踪请求的整个过程。我们可以使用这个`tracer`对象，还可以从中创建一个`logger`对象，我们的应用代码可以使用它来生成日志项，类似于我们在之前的Python和.NET示例中所做的。
- en: 'Next, we have to wrap each method in the code that we want to trace with what
    Jaeger calls a `span`. The `span` has a name and provides us with a `scope` object.
    Let''s look at some C# pseudo-code that illustrates that:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要用Jaeger称为`span`的代码来包装每个方法。`span`有一个名称，并为我们提供一个`scope`对象。让我们看一些C#伪代码，以说明这一点：
- en: '[PRE69]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, we're instrumenting the `SayHello` method. With a `using` statement
    creating a span, we're wrapping the whole application code of this method. We
    call the span `"say-hello"`, and this will be the ID with which we can identify
    the method in the trace log produced by Jaeger.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在为`SayHello`方法进行仪器化。通过使用`using`语句创建一个span，我们将整个该方法的应用代码进行包装。我们将span命名为`"say-hello"`，这将是我们在Jaeger生成的跟踪日志中用来识别该方法的ID。
- en: 'Note that the method calls another nested method, `FormatString`. This method
    will look quite similar in regard to the code needed for instrumenting it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该方法调用另一个嵌套方法`FormatString`。就需要为其进行仪器化所需的代码而言，这个方法看起来会非常相似：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The span that our `tracer` object builds in this method will be a child span
    of the calling method. This child span here is called `"format-string"`. Also
    note that we are using the `logger` object in the preceding method to explicitly
    generate a log item of level `INFO`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tracer`对象在此方法中构建的span将是调用方法的子span。这里的子span称为`"format-string"`。还要注意，我们在前面的方法中使用`logger`对象显式生成了一个级别为`INFO`的日志项。
- en: In the code included with this chapter, you can find a complete sample application
    written in C# consisting of a Jaeger server container and two application containers
    called client and library that use the Jaeger client library to instrument the
    code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章附带的代码中，您可以找到一个完整的C#示例应用程序，其中包括一个Jaeger服务器容器和两个应用程序容器，称为客户端和库，它们使用Jaeger客户端库来对代码进行仪器化。
- en: 'Navigate to the project folder:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到项目文件夹：
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, start the Jaeger server container:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动Jaeger服务器容器：
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we need to run the API, which is implemented as an ASP.NET Core 2.2 Web
    API component. Navigate to the `api` folder and start the component:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行API，它是作为ASP.NET Core 2.2 Web API组件实现的。转到`api`文件夹并启动组件：
- en: '![](assets/94b336c6-7649-43d3-8dc2-7687bf922446.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94b336c6-7649-43d3-8dc2-7687bf922446.png)'
- en: Starting the API component of the Jaeger sample
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Jaeger示例的API组件
- en: 'Now open a new terminal window and navigate into the `client` subfolder and
    then run the application:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开一个新的终端窗口，然后进入`client`子文件夹，然后运行应用程序：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Please note the two parameters I am passing—`Gabriel` and `Bonjour`—which correspond
    with `<name>` and `<greeting>`. You should see something along the lines of this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我传递的两个参数—`Gabriel`和`Bonjour`—它们对应于`<name>`和`<greeting>`。您应该看到类似于这样的内容：
- en: '![](assets/8eccae4c-eeaa-4704-9253-17e52bb39e7a.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8eccae4c-eeaa-4704-9253-17e52bb39e7a.png)'
- en: Running the client component of the Jaeger sample application
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Jaeger示例应用程序的客户端组件
- en: 'In the preceding output, you can see the three spans marked with red arrows,
    starting from the innermost to the outermost span. We can also use the graphical
    UI of Jaeger to see more details:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您可以看到用红色箭头标记的三个span，从最内部到最外部的span。我们还可以使用Jaeger的图形界面来查看更多细节：
- en: In your browser, navigate to `http://localhost:16686` to access the Jaeger UI.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，转到`http://localhost:16686`以访问Jaeger UI。
- en: 'In the Search panel, make sure the `hello-world` service is selected. Leave
    Operation as `all` and click the Find Traces button. You should see the following:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索面板中，确保选择了`hello-world`服务。将操作保留为`all`，然后点击`Find Traces`按钮。您应该看到以下内容：
- en: '![](assets/7824fa13-dd4b-4f0e-94aa-b0c6e6f15989.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7824fa13-dd4b-4f0e-94aa-b0c6e6f15989.png)'
- en: The Search view of the Jaeger UI
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger UI的搜索视图
- en: 'Now click on the (only) entry `hello-world: say-hello` to see the details of
    that request:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击（唯一的）条目`hello-world: say-hello`以查看该请求的详细信息：'
- en: '![](assets/4832a62b-7d0c-473f-b4a5-079070ae44f2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4832a62b-7d0c-473f-b4a5-079070ae44f2.png)'
- en: Details of the request as reported by Jaeger
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger报告的请求细节
- en: In the preceding screenshot, we can see how the request starts in the `hello-world` component
    in the `say-hello` method, then navigates to the `format-string` method in the
    same component, which, in turn, calls an endpoint in `Webservice`, whose logic
    is implemented in the `FormatController` controller. For each and every step,
    we see the exact timings as well as other interesting information. You can drill
    down in this view to see even more details.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到请求是如何从`hello-world`组件的`say-hello`方法开始，然后导航到同一组件中的`format-string`方法，然后调用`Webservice`中的一个端点，其逻辑是在`FormatController`控制器中实现的。对于每一步，我们都可以看到确切的时间以及其他有趣的信息。您可以在此视图中深入了解更多细节。
- en: Before you continue, you may want to take some time and browse through the code
    of the API and the `client` component that we just used for this demo.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能想花些时间浏览一下我们刚刚用于此演示的API和“client”组件的代码。
- en: 'To clean up, stop the Jaeger server container:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理时，请停止Jaeger服务器容器：
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Also stop the API with *Ctrl* + *C*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 同时停止API，使用*Ctrl* + *C*。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to debug Node.js, Python, Java, and .NET
    code running inside a container. We first started by mounting the source code
    from the host into the container to avoid a rebuild of the container image each
    time the code changes. Then, we smoothed out the development process further by
    enabling automatic application restart inside the container upon code changes.
    Next, we learned how to configure Visual Studio Code to enable the full interactive
    debugging of code running inside a container. Finally, we learned how we can instrument
    our applications such that they generate logging information that can help us
    to do root cause analysis on failures or misbehaving applications or application
    services running in production.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何调试在容器内运行的Node.js、Python、Java和.NET代码。我们首先通过将主机的源代码挂载到容器中，以避免每次代码更改时重新构建容器映像。然后，我们进一步简化了开发过程，通过在代码更改时在容器内启用自动应用程序重启。接下来，我们学习了如何配置Visual
    Studio Code以启用在容器内运行的代码的完全交互式调试。最后，我们学习了如何对我们的应用程序进行配置，使其生成日志信息，这些信息可以帮助我们对在生产环境中运行的失败或行为不端的应用程序或应用程序服务进行根本原因分析。
- en: In the next chapter, we are going to show how using Docker containers can super-charge
    your automation, from running a simple automation task in a container, to using
    containers to build up CI/CD pipelines.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示如何使用Docker容器可以加速您的自动化，从在容器中运行简单的自动化任务，到使用容器构建CI/CD流水线。
- en: Questions
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估您的学习进度：
- en: Name two methods that help to reduce the friction in the development process
    introduced by the use of containers.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举两种有助于减少容器使用引入的开发过程中的摩擦的方法。
- en: How can you achieve a live update of code inside a container?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何实现容器内代码的实时更新？
- en: When and why would you use the line-by-line debugging of code running inside
    a container?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在何时以及为什么会使用在容器内运行的代码的逐行调试？
- en: Why is instrumenting code with good debugging information paramount?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在代码中加入良好的调试信息至关重要？
- en: Further reading
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Live debugging with Docker: [https://www.docker.com/blog/live-debugging-docker/](https://www.docker.com/blog/live-debugging-docker/)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker进行实时调试：[https://www.docker.com/blog/live-debugging-docker/](https://www.docker.com/blog/live-debugging-docker/)
- en: Debug apps in a local Docker container:[https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019)
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地Docker容器中调试应用程序：[https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019)
- en: Debug your java applications in Docker using IntelliJ IDEA*: *[https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/](https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/)
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IntelliJ IDEA*在Docker中调试您的Java应用程序：[https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/](https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/)

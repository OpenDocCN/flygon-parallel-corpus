- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned a lot about how container networking works
    on a single Docker host. We introduced the **Container Network Model** (**CNM**),
    which forms the basis of all networking between Docker containers, and then we
    dove deep into different implementations of the CNM, specifically the bridge network. Finally,
    we introduced Traefik, a reverse proxy, to enable sophisticated HTTP application-level
    routing between containers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the concept of an application consisting of multiple
    services, each running in a container, and how Docker Compose allows us to easily
    build, run, and scale such an application using a declarative approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying declarative versus imperative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a multi-service application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and pushing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose overrides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, the reader will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain in a few short sentences the main differences between an imperative
    and declarative approach for defining and running an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe in their own words the difference between a container and a Docker
    Compose service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author a Docker Compose YAML file for a simple multi-service application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build, push, deploy, and tear down a simple multi-service application using
    Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker Compose to scale an application service up and down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define environment-specific Docker Compose files using overrides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code accompanying this chapter can be found at [https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch11](https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: You need to have `docker-compose` installed on your system. This is automatically
    the case if you have installed Docker for Desktop or Docker Toolbox on your Windows
    or macOS computer. Otherwise, you can find detailed installation instructions
    here: [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying declarative versus imperative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose is a tool provided by Docker that is mainly used where you need
    to run and orchestrate containers running on a single Docker host. This includes,
    but is not limited to, development, **continuous integration** (**CI**), automated
    testing, manual QA, or demos.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose uses files formatted in YAML as input. By default, Docker Compose
    expects these files to be called `docker-compose.yml`, but other names are possible.
    The content of a `docker-compose.yml` is said to be a *declarative* way of describing
    and running a containerized application potentially consisting of more than a
    single container.
  prefs: []
  type: TYPE_NORMAL
- en: So, *what is the meaning of declarative?*
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, *declarative* is the antonym of *imperative*. Well, that doesn''t
    help much. Now that I have introduced another definition, I need to explain both
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative: **This is a way in which we can solve problems by specifying
    the exact procedure that has to be followed by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I tell a system such as the Docker daemon imperatively how to run an application,
    then that means that I have to describe step by step what the system has to do
    and how it has to react if some unexpected situation occurs. I have to be very
    explicit and precise in my instructions. I need to cover all edge cases and how
    they need to be treated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative:** This is a way in which we can solve problems without requiring
    the programmer to specify an exact procedure to be followed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declarative approach means that I tell the Docker engine what my desired state
    for an application is and it has to figure out on its own how to achieve this
    desired state and how to reconcile it if the system deviates from it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker clearly recommends the declarative approach when dealing with containerized
    applications. Consequently, the Docker Compose tool uses this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Running a multi-service app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, applications do not consist of only one monolithic block, but rather
    of several application services that work together. When using Docker containers,
    each application service runs in its own container. When we want to run such a
    multi-service application, we can, of course, start all the participating containers
    with the well-known `docker container run` command, and we have done this in previous
    chapters. But this is inefficient at best. With the Docker Compose tool, we are
    given a way to define the application in a declarative way in a file that uses
    the YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the content of a simple `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines in the file are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`version`: In this line, we specify the version of the Docker Compose format
    we want to use. At the time of writing, this is version 2.4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`: In this section, we specify the services that make up our application
    in the `services` block. In our sample, we have two application services and we
    call them `web` and `db`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web`: The `web` service is using an image called `fundamentalsofdocker/ch11-web:2.0`, which,
    if not already in the image cache, is built from the `Dockerfile` found in the `web`
    folder . The service is also publishing container port `3000` to the host port `80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db`: The `db` service, on the other hand, is using the image name `fundamentalsofdocker/ch11-db:2.0`,
    which is a customized PostgreSQL database. Once again, if the image is not already
    in the cache, it is built from the `Dockerfile` found in the `db` folder . We
    are mounting a volume called `pets-data` into the container of the `db` service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: The volumes used by any of the services have to be declared in this
    section. In our sample, this is the last section of the file. The first time the
    application is run, a volume called `pets-data` will be created by Docker and
    then, in subsequent runs, if the volume is still there, it will be reused. This
    could be important when the application, for some reason, crashes and has to be
    restarted. Then, the previous data is still around and ready to be used by the
    restarted database service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we are using version 2.x of the Docker Compose file syntax. This is
    the one targeted toward deployments on a single Docker host. There exists also
    a version 3.x of the Docker Compose file syntax. This version is used when you
    want to define an application that is targeted either at Docker Swarm or Kubernetes.
    We will discuss this in more detail starting with [Chapter 12](27c0d9ce-fab6-4ce9-9034-4f2fb62931e8.xhtml), *Orchestrators*.
  prefs: []
  type: TYPE_NORMAL
- en: Building images with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the `ch11` subfolder of the `fods` folder and then build the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we enter the preceding command, then the tool will assume that there must
    be a file in the current directory called `docker-compose.yml` and it will use
    that one to run. In our case, this is indeed the case and the tool will build
    the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Terminal window, you should see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c627297-4997-47b2-804b-19cc63213e24.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the Docker image for the web service
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see that `docker-compose` first downloads
    the base image `node:12.12-alpine`, for the web image we''re building from Docker
    Hub. Subsequently, it uses the `Dockerfile` found in the `web` folder to build
    the image and names it `fundamentalsofdocker/ch11-web:2.0`. But this is only the
    first part; the second part of the output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fe4b4e5-ab79-4dbe-ae7a-46388ff69cd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the Docker image for the db service
  prefs: []
  type: TYPE_NORMAL
- en: Here, once again, `docker-compose` pulls the base image, `postgres:12.0-alpine`,
    from Docker Hub and then uses the `Dockerfile` found in the `db` folder to build
    the image we call `fundamentalsofdocker/ch11-db:2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Running an application with Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have built our images, we can start the application using Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show us the application starting. We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ac776f44-7157-4362-afa0-9cc470ee5b4b.png)Running the sample application,
    part 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first part of the output, we see how Docker Compose does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a bridge network called `ch11_default`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a volume called `ch11_pets-data`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates the two services, `ch11_web_1` and `ch11_db_1`, and attaches them to
    the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose then also shows log output generated by the database (blue) and
    by the web service (yellow) that are both stating up. The third last line in the
    output shows us that the web service is ready and listens at port `3000`. Remember
    though that this is the container port and not the host port. We have mapped container
    port `3000` to host port `80`, and that is the port we will be accessing later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the second part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7d558d6-4970-4696-a92c-6bd8fc46128e.png)Running the sample application,
    part 2'
  prefs: []
  type: TYPE_NORMAL
- en: We have shortened the second part of the output a bit. It shows us how the database
    finalizes its initialization. We can specifically see how our initialization script, `init-db.sql`,
    is applied, which defines a database and seeds it with some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now open a browser tab and navigate to `localhost/animal`. We should
    be greeted by a wild animal whose picture I took at the Masai Mara national park
    in Kenya:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fa80d99d-40f4-45af-99d6-ec013f32cdba.png)'
  prefs: []
  type: TYPE_IMG
- en: The sample application in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the browser a few times to see other cat images. The application selects
    the current image randomly from a set of 12 images whose URLs are stored in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the application is running in interactive mode and, thus, the Terminal where
    we ran Docker Compose is blocked, we can cancel the application by pressing *Ctrl *+ *C*.
    If we do so, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will notice that the database and the web services stop immediately. Sometimes,
    though, some services will take about 10 seconds to do so. The reason for this
    is that the database and the web service listen to, and react to, the `SIGTERM` signal
    sent by Docker while other services might not, and so Docker kills them after
    a predefined timeout interval of 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application again with `docker-compose up`, the output will be
    much shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24c4d502-363e-4c41-a0c7-f441ac0e6cee.png)Output of docker-compose
    up'
  prefs: []
  type: TYPE_NORMAL
- en: This time, we didn't have to download the images and the database didn't have
    to initialize from scratch, but it was just reusing the data that was already
    present in the `pets-data` volume from the previous run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run the application in the background. All containers will run
    as daemons. For this, we just need to use the `-d` parameter, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Compose offers us many more commands than just `up`. We can use the
    tool to list all services that are part of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4de77740-ac1d-4bb2-9f8f-0c0b203897d4.png)Output of docker-compose
    ps'
  prefs: []
  type: TYPE_NORMAL
- en: This command is similar to `docker container ls`, with the only difference being
    that `docker-compose` only lists containers or services that are part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop and clean up the application, we use the `docker-compose down` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we also want to remove the volume for the database, then we can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, instead of using the two commands, `docker-compose down` and
    `docker volume rm <volume name>`, we can combine them into a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the argument `-v` (or `--volumes`) removes named volumes declared in the
    `volumes` section of the `compose` file and anonymous volumes attached to containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is there a `ch11` prefix in the name of the volume? In the `docker-compose.yml` file,
    we have called the volume to use `pets-data`. But, as we have already mentioned,
    Docker Compose prefixes all names with the name of the parent folder of the `docker-compose.yml` file
    plus an underscore. In this case, the parent folder is called `ch11`. If you don''t
    like this approach, you can define a project name explicitly, for example, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: which uses a project name my-app for the application to run under.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's, for a moment, assume that our sample application has been live on
    the web and become very successful. Loads of people want to see our cute animal
    images. So now we're facing a problem, since our application has started to slow
    down. To counteract this problem, we want to run multiple instances of the web
    service. With Docker Compose, this is readily done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running more instances is also called scaling up. We can use this tool to scale
    our `web` service up to, say, three instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, we are in for a surprise. The output will look similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c367f83-aae2-4c84-b5bb-6547f80846ae.png)Output of docker-compose
    --scale'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and third instances of the web service fail to start. The error
    message tells us why: we cannot use the same host port `80` more than once. When
    instances 2 and 3 try to start, Docker realizes that port `80` is already taken
    by the first instance. *What can we do?* Well, we can just let Docker decide which
    host port to use for each instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, in the `ports` section of the `compose` file, we only specify the container
    port and leave out the host port, then Docker automatically selects an ephemeral
    port. Let''s do exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s tear down the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we modify the `docker-compose.yml` file to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the application again and scale it up immediately after that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now do `docker-compose ps`, we should see the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/608fb23b-b615-4b34-b389-37d014004c77.png)Output of docker-compose
    ps'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, each service has been associated to a different host port. We
    can try to see whether they work, for example, using `curl`. Let''s test the third
    instance, `ch11_web_3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The answer, `Pets Demo Application`, tells us that, indeed, our application
    is still working as expected. Try it out for the other two instances to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: Building and pushing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen earlier that we can also use the `docker-compose build` command to just
    build the images of an application defined in the underlying `docker-compose` file.
    But to make this work, we''ll have to add the build information to the `docker-compose` file.
    In the folder, we have a file, `docker-compose.dev.yml`, which has those instructions
    already added. It is basically a copy of the `docker-compose.yml` file we have
    used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the `build` key for each service. The value of that key indicates
    the context or folder where Docker is expecting to find the `Dockerfile` to build
    the corresponding image. If we wanted to use a `Dockerfile` that is named differently,
    say `Dockerfile-dev`, for the `web` service, then the `build` block in the `docker-compose`
    file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use that alternative `docker-compose-dev.yml` file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `-f` parameter will tell the Docker Compose application which `compose`
    file to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push all images to Docker Hub, we can use `docker-compose push`. We need
    to be logged in to Docker Hub so that this succeeds, otherwise we get an authentication
    error while pushing. Thus, in my case, I do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the login succeeds, I can then push the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This may take a while, depending on the bandwidth of your internet connection.
    While pushing, your screen may look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3add68f8-5a90-4edb-96a4-68743bff811b.png)'
  prefs: []
  type: TYPE_IMG
- en: Pushing images with docker-compose to Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command pushes the two images to the `fundamentalsofdocker` account on
    Docker Hub. You can find these two images at the following URL: [https://hub.docker.com/u/fundamentalsofdocker/](https://hub.docker.com/u/fundamentalsofdocker/)
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to run our applications in different environments that need
    specific configuration settings. Docker Compose provides a handy capability to
    address exactly this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a specific sample. We can define a base Docker Compose file and
    then define environment-specific overrides. Let''s assume we have a file called
    `docker-compose.base.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This only defines the part that should be the same in all environments. All
    specific settings have been taken out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume for a moment that we want to run our sample application on a
    CI system, but there we want to use different settings for the database. The `Dockerfile`
    we used to create the database image looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the three environment variables we define on lines 3 through 5\. The
    `Dockerfile` of the `web` service has similar definitions. Let''s say that on
    the CI system, we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the images from code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `POSTGRES_PASSWORD` as `ci-pass`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map container port `3000` of the web service to host port `5000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the corresponding override file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can run this application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that with the first `-f` parameter, we provide the base Docker Compose
    file, and with the second one, we provide the override. The `--build` parameter
    is used to force `docker-compose` to rebuild the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using environment variables, note the following precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring them in the Docker file defines a default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring the same variable in the Docker Compose file overrides the value from
    the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Had we followed the standard naming convention and called the base file just
    `docker-compose.yml` and the override file `docker-compose.override.yml` instead,
    then we could have started the application with `docker-compose up -d` without
    explicitly naming the compose files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the `docker-compose` tool. This tool is mostly
    used to run and scale multi-service applications on a single Docker host. Typically,
    developers and CI servers work with single hosts and those two are the main users
    of Docker Compose. The tool is using YAML files as input that contain the description
    of the application in a declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: The tool can also be used to build and push images, among many other helpful
    tasks. The code accompanying this chapter can be found in `fod/ch11`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce **orchestrators**. An orchestrator is
    an infrastructure software that is used to run and manage containerized applications
    in a cluster while making sure that these applications are in their desired state
    at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assess your learning progress, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How will you use `docker-compose` to run an application in daemon mode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will you use `docker-compose` to display the details of the running service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will you scale up a particular web service to, say, three instances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links provide additional information on the topics discussed
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The official YAML website: [http://www.yaml.org/](http://www.yaml.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose documentation: [http://dockr.ly/1FL2VQ6](http://dockr.ly/1FL2VQ6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose file version 2 reference: [http://dohttps://docs.docker.com/compose/compose-file/compose-file-v2/](https://docs.docker.com/compose/compose-file/compose-file-v2/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share Compose configurations between files and projects: [https://docs.docker.com/compose/extends/](https://docs.docker.com/compose/extends/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

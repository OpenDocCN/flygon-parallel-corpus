- en: Chapter 1\. What Is eBPF, and Why Is It Important?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。什么是eBPF，它为什么重要？
- en: eBPF is a revolutionary kernel technology that allows developers to write custom
    code that can be loaded into the kernel dynamically, changing the way the kernel
    behaves. (Don’t worry if you’re not confident about what the kernel is—we’ll come
    to that shortly in this chapter.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF是一种革命性的内核技术，允许开发人员编写自定义代码，可以动态加载到内核中，改变内核的行为方式。（如果你对内核不太了解，不用担心，我们很快就会在本章中讨论到。）
- en: This enables a new generation of highly performant networking, observability,
    and security tools. And as you’ll see, if you want to instrument an app with these
    eBPF-based tools, you don’t need to modify or reconfigure the app in any way,
    thanks to eBPF’s vantage point within the kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得一代新的高性能网络、可观察性和安全工具得以实现。正如你将看到的，如果你想要用这些基于eBPF的工具来对一个应用进行仪器化，你不需要以任何方式修改或重新配置应用，这要归功于eBPF在内核中的优势位置。
- en: 'Just a few of the things you can do with eBPF include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF可以做的一些事情包括：
- en: Performance tracing of pretty much any aspect of a system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对系统的几乎任何方面进行性能跟踪
- en: High-performance networking, with built-in visibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能网络，内置可见性
- en: Detecting and (optionally) preventing malicious activity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和（可选地）防止恶意活动
- en: Let’s take a brief journey through eBPF’s history, starting with the Berkeley
    Packet Filter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地回顾一下eBPF的历史，从伯克利数据包过滤器开始。
- en: 'eBPF’s Roots: The Berkeley Packet Filter'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF的起源：伯克利数据包过滤器
- en: 'What we call “eBPF” today has its roots in the BSD Packet Filter, first described
    in 1993 in a paper^([1](ch01.html#ch01fn4)) written by Lawrence Berkeley National
    Laboratory’s Steven McCanne and Van Jacobson. This paper discusses a pseudomachine
    that can run *filters*, which are programs written to determine whether to accept
    or reject a network packet. These programs were written in the BPF instruction
    set, a general-purpose set of 32-bit instructions that closely resembles assembly
    language. Here’s an example taken directly from that paper:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所说的“eBPF”在1993年由劳伦斯伯克利国家实验室的Steven McCanne和Van Jacobson撰写的一篇论文^([1](ch01.html#ch01fn4))中首次提出。这篇论文讨论了一个伪机器，可以运行*过滤器*，这些过滤器是用来确定是否接受或拒绝网络数据包的程序。这些程序是用BPF指令集编写的，这是一个类似汇编语言的通用32位指令集。以下是直接从那篇论文中摘取的一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tiny piece of code filters out packets that aren’t Internet Protocol (IP)
    packets. The input to this filter is an Ethernet packet, and the first instruction
    (`ldh`) loads a 2-byte value starting at byte 12 in this packet. In the next instruction
    (`jeq`) that value is compared with the value that represents an IP packet. If
    it matches, execution jumps to the instruction labeled `L1`, and the packet is
    accepted by returning a nonzero value (identified here as `#TRUE`). If it doesn’t
    match, the packet is not an IP packet and is rejected by returning `0`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码过滤掉不是互联网协议（IP）数据包的数据包。这个过滤器的输入是一个以太网数据包，第一条指令（`ldh`）加载了这个数据包中从第12个字节开始的一个2字节值。在下一条指令（`jeq`）中，这个值与代表IP数据包的值进行比较。如果匹配，执行跳转到标记为`L1`的指令，并且通过返回一个非零值（这里标识为`#TRUE`）来接受数据包。如果不匹配，数据包不是IP数据包，并且通过返回`0`来拒绝。
- en: You can imagine (or, indeed, refer to the paper to find examples of) more complex
    filter programs that make decisions based on other aspects of the packet. Importantly,
    the author of the filter can write their own custom programs to be executed within
    the kernel, and this is the heart of what eBPF enables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象（或者确实参考论文找到更复杂的过滤程序的例子），更复杂的过滤程序可以根据数据包的其他方面做出决定。重要的是，过滤器的作者可以编写自己的自定义程序在内核中执行，这是eBPF所能实现的核心。
- en: BPF came to stand for “Berkeley Packet Filter,” and it was first introduced
    to Linux in 1997, in kernel version 2.1.75,^([2](ch01.html#ch01fn5)) where it
    was used in the tcpdump utility as an efficient way to capture the packets to
    be traced out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: BPF最初代表“伯克利数据包过滤器”，它首次出现在1997年的Linux内核版本2.1.75中，^([2](ch01.html#ch01fn5))，它在tcpdump实用程序中被用作捕获要被跟踪的数据包的高效方式。
- en: Fast-forward to 2012, when seccomp-bpf was introduced in version 3.5 of the
    kernel. This enabled the use of BPF programs to make decisions about whether to
    allow or deny user space applications from making system calls. We’ll explore
    this in more detail in [Chapter 10](ch10.html#ebpf_programming). This was the
    first step in evolving BPF from the narrow scope of packet filtering to the general-purpose
    platform it is today. From this point on, the words *packet filter* in the name
    started to make less sense!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2012年，seccomp-bpf在内核版本3.5中被引入。这使得可以使用BPF程序来决定是否允许或拒绝用户空间应用程序进行系统调用。我们将在[第10章](ch10.html#ebpf_programming)中更详细地探讨这一点。这是将BPF从数据包过滤的狭窄范围发展为今天的通用平台的第一步。从这一点开始，名称中的*数据包过滤器*开始变得不那么合理了！
- en: From BPF to eBPF
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从BPF到eBPF
- en: 'BPF evolved to what we call “extended BPF” or “eBPF” starting in kernel version
    3.18 in 2014\. This involved several significant changes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BPF在2014年的内核版本3.18中演变为我们今天所说的“扩展BPF”或“eBPF”。这涉及到了一些重大的改变：
- en: The BPF instruction set was completely overhauled to be more efficient on 64-bit
    machines, and the interpreter was entirely rewritten.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPF指令集被彻底改写，以在64位机器上更加高效，并且解释器被完全重写。
- en: eBPF *maps* were introduced, which are data structures that can be accessed
    by BPF programs and by user space applications, allowing information to be shared
    between them. You’ll learn about maps in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eBPF *映射*被引入，这是可以被BPF程序和用户空间应用程序访问的数据结构，允许它们之间共享信息。你将在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中了解到映射。
- en: The `bpf()` system call was added so that user space programs can interact with
    eBPF programs in the kernel. You’ll read about this system call in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpf()`系统调用被添加，以便用户空间程序可以与内核中的eBPF程序进行交互。你将在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中了解到这个系统调用。'
- en: Several BPF helper functions were added. You’ll see a few examples in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    and some more details in [Chapter 6](ch06.html#the_ebpf_verifier).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增了几个BPF辅助函数。您将在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中看到一些示例，并在[第6章](ch06.html#the_ebpf_verifier)中看到更多细节。
- en: The eBPF verifier was added to ensure that eBPF programs are safe to run. This
    is discussed in [Chapter 6](ch06.html#the_ebpf_verifier).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eBPF验证器被添加以确保eBPF程序的安全运行。这在[第6章](ch06.html#the_ebpf_verifier)中讨论。
- en: This put the basis for eBPF in place, but development did not slow down! Since
    then, eBPF has evolved significantly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这为eBPF奠定了基础，但开发并没有放缓！从那时起，eBPF已经显著发展。
- en: The Evolution of eBPF to Production Systems
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF演变为生产系统
- en: A feature called *kprobes* (kernel probes) had existed in the Linux kernel since
    2005, allowing for traps to be set on almost any instruction in the kernel code.
    Developers could write kernel modules that attached functions to kprobes for debugging
    or performance measurement purposes.^([3](ch01.html#ch01fn6))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自2005年以来，Linux内核中存在一种称为*kprobes*（内核探针）的功能，允许在内核代码中的几乎任何指令上设置陷阱。开发人员可以编写附加到kprobes的内核模块，用于调试或性能测量目的。^([3](ch01.html#ch01fn6))
- en: The ability to attach eBPF programs to kprobes was added in 2015, and this was
    the starting point for a revolution in the way tracing is done across Linux systems.
    At the same time, hooks started to be added within the kernel’s networking stack,
    allowing eBPF programs to take care of more aspects of networking functionality.
    We’ll see more of this in [Chapter 8](ch08.html#ebpf_for_networking).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年添加了将eBPF程序附加到kprobes的功能，这是Linux系统跟踪方式革命的起点。与此同时，内核的网络堆栈中开始添加钩子，允许eBPF程序处理网络功能的更多方面。我们将在[第8章](ch08.html#ebpf_for_networking)中看到更多内容。
- en: By 2016, eBPF-based tools were being used in production systems. [Brendan Gregg’s](https://www.brendangregg.com)
    work on tracing at Netflix became widely known in infrastructure and operations
    circles, as did [his statement](https://oreil.ly/stV6v) that eBPF “brings superpowers
    to Linux.” In the same year, the Cilium project was announced, being the first
    networking project to use eBPF to replace the entire datapath in container environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到2016年，基于eBPF的工具已经在生产系统中使用。[Brendan Gregg](https://www.brendangregg.com)在Netflix上的跟踪工作在基础设施和运维领域广为人知，以及[他的声明](https://oreil.ly/stV6v)称eBPF“为Linux带来了超能力”。同年，Cilium项目宣布成立，成为第一个使用eBPF来替换容器环境中整个数据路径的网络项目。
- en: The following year Facebook (now Meta) made [Katran](https://oreil.ly/X-WsL)
    an open source project. Katran, a layer 4 load balancer, met Facebook’s need for
    a [highly scalable and fast solution](https://oreil.ly/zl4yX). Every single packet
    to [Facebook.com](http://Facebook.com) since 2017 has passed through eBPF/XDP.^([4](ch01.html#ch01fn7))
    For me personally, this was the year that ignited my excitement about the possibilities
    enabled by this technology, after seeing [Thomas Graf’s talk](https://oreil.ly/g9ya0)
    about eBPF and the [Cilium project](https://oreil.ly/doKbd) at DockerCon in Austin,
    Texas.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 次年，Facebook（现在的Meta）开源了[Katran](https://oreil.ly/X-WsL)项目。Katran是一个第4层负载均衡器，满足了Facebook对[高可扩展和快速解决方案](https://oreil.ly/zl4yX)的需求。自2017年以来，每个发送到[Facebook.com](http://Facebook.com)的数据包都经过了eBPF/XDP。^([4](ch01.html#ch01fn7))
    对我个人来说，这一年点燃了我对这项技术所带来的可能性的兴奋，因为我在德克萨斯州奥斯汀的DockerCon上看到了[Thomas Graf的演讲](https://oreil.ly/g9ya0)关于eBPF和[Cilium项目](https://oreil.ly/doKbd)。
- en: In 2018, eBPF became a separate subsystem within the Linux kernel, with [Daniel
    Borkmann](http://borkmann.ch) from Isovalent and [Alexei Starovoitov](https://oreil.ly/K8nXI)
    from Meta as its maintainers (they were later joined by [Andrii Nakryiko](https://nakryiko.com),
    also from Meta). The same year saw the introduction of BPF Type Format (BTF),
    which makes eBPF programs much more portable. We’ll explore this in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，eBPF成为Linux内核中的一个独立子系统，由Isovalent的[Daniel Borkmann](http://borkmann.ch)和Meta的[Alexei
    Starovoitov](https://oreil.ly/K8nXI)担任维护者（后来他们又加入了来自Meta的[Andrii Nakryiko](https://nakryiko.com)）。同年，引入了BPF类型格式（BTF），使eBPF程序更具可移植性。我们将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中探讨这一点。
- en: 'The year 2020 saw the introduction of LSM BPF, allowing eBPF programs to be
    attached to the Linux Security Module (LSM) kernel interface. This indicated that
    a third major use case for eBPF had been identified: it became clear that eBPF
    is a great platform for security tooling, in addition to networking and observability.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年引入了LSM BPF，允许将eBPF程序附加到Linux安全模块（LSM）内核接口。这表明已经确定了eBPF的第三个主要用途：除了网络和可观察性外，eBPF还是一个出色的安全工具平台。
- en: Over the years, eBPF’s capabilities have grown substantially, thanks to the
    work of more than 300 kernel developers and many contributors to the associated
    user space tools (such as `bpftool`, which we’ll meet in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)),
    compilers, and programming language libraries. Programs were once limited to 4,096
    instructions, but that limit has grown to 1 million verified instructions^([5](ch01.html#ch01fn9))
    and has effectively been rendered irrelevant by support for tail calls and function
    calls (which you’ll see in Chapters [2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    and [3](ch03.html#anatomy_of_an_ebpf_program)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，由于300多名内核开发人员的工作以及许多相关用户空间工具（如`bpftool`）的贡献者，编译器和编程语言库，eBPF的功能大大增强。程序曾经限制在4,096条指令，但这个限制已经增长到了100万条经过验证的指令^([5](ch01.html#ch01fn9))，并且通过对尾调用和函数调用的支持，这个限制已经变得无关紧要（您将在第[2](ch02.html#ebpfapostrophes_quotation_markhello_wor)和第[3](ch03.html#anatomy_of_an_ebpf_program)章中看到）。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For deeper insight into the history of eBPF, who better to refer to than the
    maintainers who have been working on it from the beginning?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解eBPF的历史，最好向从一开始就一直在开发它的维护者们咨询。
- en: Alexei Starovoitov gave a fascinating presentation about the [history of BPF](https://youtu.be/DAvZH13725I)
    from its roots in software-defined networking (SDN). In this talk, he discusses
    the strategies used to get the early eBPF patches accepted into the kernel and
    reveals that the official birthday of eBPF is September 26, 2014, which marked
    the acceptance of the first set of patches covering the verifier, BPF system call,
    and maps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Alexei Starovoitov就BPF的历史做了一次引人入胜的演讲，从软件定义网络（SDN）的根源开始。在这次演讲中，他讨论了用于使早期eBPF补丁被内核接受的策略，并透露了eBPF的官方生日是2014年9月26日，这标志着第一批覆盖验证器、BPF系统调用和映射的补丁被接受。
- en: 'Daniel Borkmann has also discussed the history of BPF and its evolution to
    support networking and tracing functionality. I highly recommend his talk [“eBPF
    and Kubernetes: Little Helper Minions for Scaling Microservices”](https://youtu.be/99jUcLt3rSk),
    which is full of interesting nuggets of information.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Daniel Borkmann还讨论了BPF的历史及其演变以支持网络和跟踪功能。我强烈推荐他的演讲[“eBPF和Kubernetes：扩展微服务的小助手”](https://youtu.be/99jUcLt3rSk)，其中充满了有趣的信息。
- en: Naming Is Hard
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名很难
- en: eBPF’s applications range so far beyond packet filtering that the acronym is
    essentially meaningless now, and it has become a standalone term. And since the
    Linux kernels in widespread use these days all have support for the “extended”
    parts, the terms *eBPF* and *BPF* are largely used interchangeably. In the kernel
    source code and in eBPF programming, the common terminology is *BPF*. For example,
    as we’ll see in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    the system call for interacting with eBPF is `bpf()`, helper functions start with
    `bpf_`, and the different types of (e)BPF programs are identified with names that
    start with `BPF_PROG_TYPE`. Outside the kernel community, the name “eBPF” seems
    to have stuck, for example, in the community site [ebpf.io](https://ebpf.io) and
    in the name of the [eBPF Foundation](http://ebpf.foundation).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF的应用范围远远超出了数据包过滤，因此这个首字母缩略词现在基本上没有意义，它已经成为一个独立的术语。由于当今广泛使用的Linux内核都支持“扩展”部分，因此术语*eBPF*和*BPF*基本上是可以互换使用的。在内核源代码和eBPF编程中，常用的术语是*BPF*。例如，正如我们将在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的，与eBPF交互的系统调用是`bpf()`，辅助函数以`bpf_`开头，不同类型的(e)BPF程序的标识名称以`BPF_PROG_TYPE`开头。在内核社区之外，“eBPF”这个名字似乎已经流行起来，例如在社区网站[ebpf.io](https://ebpf.io)和[eBPF
    Foundation](http://ebpf.foundation)的名字中。
- en: The Linux Kernel
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核
- en: To understand eBPF you’ll need a solid grasp of the difference between the kernel
    and user space in Linux. I covered this in my report “What Is eBPF?”^([6](ch01.html#ch01fn10))
    and I’ve adapted some of that content for the next few paragraphs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解eBPF，您需要对Linux中内核和用户空间之间的区别有一个扎实的理解。我在我的报告“什么是eBPF？”^([6](ch01.html#ch01fn10))中涵盖了这一点，并且我已经为接下来的几段内容调整了一些内容。
- en: The Linux kernel is the software layer between your applications and the hardware
    they’re running on. Applications run in an unprivileged layer called *user space*,
    which can’t access hardware directly. Instead, an application makes requests using
    the system call (syscall) interface to request the kernel to act on its behalf.
    That hardware access can involve reading and writing to files, sending or receiving
    network traffic, or even just accessing memory. The kernel is also responsible
    for coordinating concurrent processes, enabling many applications to run at once.
    This is illustrated in [Figure 1-1](#applications_in_user_space_use_the_sysc).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是应用程序和它们运行的硬件之间的软件层。应用程序在一个称为*用户空间*的非特权层中运行，无法直接访问硬件。相反，应用程序使用系统调用（syscall）接口发出请求，请求内核代表其采取行动。硬件访问可能涉及读写文件，发送或接收网络流量，甚至只是访问内存。内核还负责协调并发进程，使许多应用程序可以同时运行。这在[图1-1](#applications_in_user_space_use_the_sysc)中有所体现。
- en: As application developers, we typically don’t use the system call interface
    directly, because programming languages give us high-level abstractions and standard
    libraries that are easier interfaces to program. As a result, a lot of people
    are blissfully unaware of how much the kernel is doing while our programs run.
    If you want to get a sense of how often the kernel is invoked, you can use the
    `strace` utility to show all the system calls an application makes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发人员，我们通常不直接使用系统调用接口，因为编程语言为我们提供了高级抽象和标准库，这些是更容易编程的接口。因此，很多人对内核在我们程序运行时所做的工作一无所知。如果您想了解内核被调用的频率，您可以使用`strace`实用程序来显示应用程序所做的所有系统调用。
- en: '![Applications in user space use the syscall interface to make requests to
    the kernel](assets/lebp_0101.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![用户空间中的应用程序使用系统调用接口向内核发出请求](assets/lebp_0101.png)'
- en: Figure 1-1\. Applications in user space use the syscall interface to make requests
    to the kernel
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. 用户空间中的应用程序使用系统调用接口向内核发出请求
- en: 'Here’s an example, where using `cat` to echo the word *hello* to the screen
    involves more than 100 system calls:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，使用`cat`来将单词*hello*回显到屏幕上涉及超过100个系统调用：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because applications rely so heavily on the kernel, it means we can learn a
    lot about how an application behaves if we can observe its interactions with the
    kernel. With eBPF we can add instrumentation into the kernel to get these insights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序如此严重依赖内核，这意味着如果我们能观察应用程序与内核的交互，我们就可以了解应用程序的行为。使用eBPF，我们可以在内核中添加仪器来获得这些见解。
- en: For example, if you are able to intercept the system call for opening files,
    you can see exactly which files any application accesses. But how could you do
    that interception? Let’s consider what would be involved if we wanted to modify
    the kernel, adding new code to create some kind of output whenever that system
    call is invoked.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您能拦截打开文件的系统调用，您可以准确地看到任何应用程序访问的文件。但是如何进行拦截呢？让我们考虑一下，如果我们想要修改内核，添加新的代码来在调用该系统调用时创建某种输出，会涉及什么。
- en: Adding New Functionality to the Kernel
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内核添加新功能
- en: The Linux kernel is complex, with around 30 million lines of code at the time
    of this writing.^([7](ch01.html#ch01fn11)) Making a change to any codebase requires
    some familiarity with the existing code, so unless you’re a kernel developer already,
    this is likely to present a challenge.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Linux内核非常复杂，大约有3000万行代码。^([7](ch01.html#ch01fn11))对任何代码库进行更改都需要对现有代码有一定的了解，因此，除非您已经是内核开发人员，否则这可能会带来挑战。
- en: Additionally, if you want to contribute your change upstream, you’ll be facing
    a challenge that isn’t purely technical. Linux is a general-purpose operating
    system, used in all manner of environments and circumstances. This means that
    if you want your change to become part of an official Linux release, it’s not
    simply a matter of writing code that works. The code has to be accepted by the
    community (and more specifically by Linus Torvalds, creator and main developer
    of Linux) as a change that will be for the greater good of all. This isn’t a given—only
    one-third of submitted kernel patches are accepted.^([8](ch01.html#ch01fn12))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想向上游贡献您的更改，您将面临的挑战不仅仅是技术上的。Linux是一个通用操作系统，用于各种环境和情况。这意味着，如果您希望您的更改成为官方Linux发布的一部分，这不仅仅是编写可工作的代码的问题。代码必须被社区（更具体地说是Linux的创始人和主要开发者Linus
    Torvalds）接受为对所有人都有益的更改。这并非是一定会发生的事情——只有三分之一的提交的内核补丁被接受。^([8](ch01.html#ch01fn12))
- en: Let’s suppose you’ve figured out a good technical approach for intercepting
    the system call for opening files. After some months of discussion and some hard
    development work on your part, let’s imagine the change is accepted into the kernel.
    Great! But how long will it be until it arrives on everyone’s machines?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经找到了拦截打开文件系统调用的良好技术方法。经过几个月的讨论和您的一些艰苦开发工作，让我们假设更改已经被内核接受。太好了！但是它会在每个人的机器上到达需要多长时间？
- en: There’s a new release of the Linux kernel every two or three months, but even
    when a change has made it into one of these releases, it’s still some time away
    from being available in most people’s production environments. This is because
    most of us don’t just use the Linux kernel directly—we use Linux distributions
    like Debian, Red Hat, Alpine, and Ubuntu that package up a version of the Linux
    kernel with various other components. You may well find that your favorite distribution
    is using a kernel release that’s several years old.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核每两三个月就会有一个新版本，但即使更改已经包含在其中一个版本中，它距离在大多数人的生产环境中可用还需要一些时间。这是因为我们大多数人不仅仅直接使用Linux内核——我们使用像Debian、Red
    Hat、Alpine和Ubuntu这样的Linux发行版，它们会打包一个版本的Linux内核和各种其他组件。您可能会发现您喜欢的发行版使用的内核版本已经过去了好几年。
- en: For example, a lot of enterprise users employ Red Hat Enterprise Linux (RHEL).
    At the time of this writing, the current release is RHEL 8.5, dated November 2021,
    and it uses version 4.18 of the Linux kernel. This kernel was released in August
    2018.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多企业用户使用Red Hat Enterprise Linux（RHEL）。在撰写本文时，当前版本是RHEL 8.5，日期为2021年11月，它使用Linux内核的4.18版本。这个内核是在2018年8月发布的。
- en: As illustrated in the cartoon in [Figure 1-2](#adding_features_to_the_kernel_left_pare),
    it takes literally years to get new functionality from the idea stage into a production
    environment Linux kernel.^([9](ch01.html#ch01fn13))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[图1-2](#adding_features_to_the_kernel_left_pare)中的漫画所示，从想法阶段到生产环境的Linux内核中获得新功能实际上需要数年的时间。^([9](ch01.html#ch01fn13))
- en: '![Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)](assets/lebp_0102.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![向内核添加功能（由Vadim Shchekoldin，Isovalent绘制的漫画）](assets/lebp_0102.png)'
- en: Figure 1-2\. Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2。向内核添加功能（由Vadim Shchekoldin，Isovalent绘制的漫画）
- en: Kernel Modules
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you don’t want to wait years for your change to make it into the kernel,
    there is another option. The Linux kernel was designed to accept kernel modules,
    which can be loaded and unloaded on demand. If you want to change or extend kernel
    behavior, writing a module is certainly one way to do it. A kernel module can
    be distributed for others to use independent of the official Linux kernel release,
    so it doesn’t have to be accepted into the main upstream codebase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想等待多年才能使您的更改进入内核，还有另一种选择。Linux内核被设计为接受内核模块，这些模块可以根据需要加载和卸载。如果您想更改或扩展内核行为，编写一个模块当然是一种方法。内核模块可以被分发供其他人使用，而不必被接受为主要上游代码库的一部分。
- en: 'The biggest challenge here is that this is still full-on kernel programming.
    Users have historically been very cautious about using kernel modules, for one
    simple reason: if kernel code crashes, it takes down the machine and everything
    running on it. How can a user be confident that a kernel module is safe to run?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的挑战是这仍然是全面的内核编程。用户一直对使用内核模块非常谨慎，一个简单的原因是：如果内核代码崩溃，它会导致机器和其中运行的所有内容都崩溃。用户如何能确信内核模块是安全的？
- en: Being “safe to run” doesn’t just mean not crashing—the user wants to know that
    a kernel module is safe from a security perspective. Does it include vulnerabilities
    that an attacker could exploit? Do we trust the authors of the module not to put
    malicious code in it? Because the kernel is privileged code, it has access to
    everything on the machine, including all the data, so malicious code in the kernel
    would be a serious cause for concern. This applies to kernel modules too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “安全运行”不仅意味着不崩溃——用户还想知道内核模块在安全方面是安全的。它是否包含攻击者可以利用的漏洞？我们是否相信模块的作者不会在其中放入恶意代码？因为内核是特权代码，它可以访问机器上的所有内容，包括所有数据，所以内核中的恶意代码将是一个严重的问题。这也适用于内核模块。
- en: The safety of the kernel is one important reason why Linux distributions take
    so long to incorporate new releases. If other people have been running a kernel
    version in a variety of circumstances for months or years, this should have flushed
    out issues. The distribution maintainers can have some confidence that the kernel
    they ship to their users/customers is *hardened*—that is, it is safe to run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的安全性是Linux发行版需要很长时间才能合并新版本的一个重要原因。如果其他人在各种情况下运行了一个内核版本数月甚至数年，这应该已经解决了问题。发行版维护者可以相当有信心他们向用户/客户提供的内核是*经过加固*的-也就是说，它是安全的。
- en: 'eBPF offers a very different approach to safety: the *eBPF verifier*, which
    ensures that an eBPF program is loaded only if it’s safe to run—it won’t crash
    the machine or lock it up in a hard loop, and it won’t allow data to be compromised.
    We’ll discuss the verification process in more detail in [Chapter 6](ch06.html#the_ebpf_verifier).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF提供了一种非常不同的安全方法：*eBPF验证器*，它确保只有在安全运行时才加载eBPF程序-它不会使机器崩溃或陷入死循环，并且不会允许数据被泄露。我们将在[第6章](ch06.html#the_ebpf_verifier)中更详细地讨论验证过程。
- en: Dynamic Loading of eBPF Programs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF程序的动态加载
- en: eBPF programs can be loaded into and removed from the kernel dynamically. Once
    they are attached to an event, they’ll be triggered by that event regardless of
    what caused that event to occur. For example, if you attach a program to the syscall
    for opening files, it will be triggered whenever any process tries to open a file.
    It doesn’t matter whether that process was already running when the program was
    loaded. This is a huge advantage compared to upgrading the kernel and then having
    to reboot the machine to use its new functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序可以动态加载到内核中，并且可以从内核中移除。一旦它们附加到一个事件上，它们将被该事件触发，无论是什么导致了该事件的发生。例如，如果您将程序附加到打开文件的系统调用上，那么每当任何进程尝试打开文件时，它都会被触发。无论在加载程序时该进程是否已经运行，都不重要。这与升级内核然后必须重新启动机器以使用其新功能相比是一个巨大的优势。
- en: This leads to one of the great strengths of observability or security tooling
    that uses eBPF—it instantly gets visibility over everything that’s happening on
    the machine. In environments running containers, that includes visibility over
    all processes running inside those containers as well as on the host machine.
    I’ll dig into the consequences of this for cloud native deployments later in this
    chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了使用eBPF的可观察性或安全工具的一个巨大优势-它立即获得对机器上发生的一切的可见性。在运行容器的环境中，这包括对容器内运行的所有进程以及主机机器上发生的所有进程的可见性。我将在本章后面更详细地探讨这对云原生部署的影响。
- en: Additionally, as illustrated in [Figure 1-3](#adding_kernel_features_with_ebpf_left_p),
    people can create new kernel functionality very quickly through eBPF without requiring
    every other Linux user to accept the same changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如[图1-3](#adding_kernel_features_with_ebpf_left_p)所示，人们可以通过eBPF非常快速地创建新的内核功能，而无需要求其他Linux用户接受相同的更改。
- en: '![Adding kernel features with eBPF (cartoon by Vadim Shchekoldin, Isovalent)](assets/lebp_0103.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用eBPF添加内核功能（Vadim Shchekoldin，Isovalent绘制的漫画）](assets/lebp_0103.png)'
- en: Figure 1-3\. Adding kernel features with eBPF (cartoon by Vadim Shchekoldin,
    Isovalent)
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 使用eBPF添加内核功能（Vadim Shchekoldin，Isovalent绘制的漫画）
- en: High Performance of eBPF Programs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF程序的高性能
- en: eBPF programs are a very efficient way to add instrumentation. Once loaded and
    JIT-compiled (which you’ll see in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)),
    the program runs as native machine instructions on the CPU. Additionally, there’s
    no need to incur the cost of transitioning between kernel and user space (which
    is an expensive operation) to handle each event.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序是一种非常高效的添加仪器的方法。一旦加载并进行即时编译（您将在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到），程序将作为CPU上的本机机器指令运行。此外，无需承担在内核和用户空间之间转换的成本（这是一项昂贵的操作）来处理每个事件。
- en: The 2018 paper^([10](ch01.html#ch01fn14)) that describes the eXpress Data Path
    (XDP) includes some illustrations of the kinds of performance improvements eBPF
    enables in networking. For example, implementing routing in XDP “improves performance
    with a factor of 2.5” compared to the regular Linux kernel implementation, and
    “XDP offers a performance gain of 4.3x over IPVS” for load balancing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 描述eXpress数据路径（XDP）的2018年论文^([10](ch01.html#ch01fn14))包括一些说明eBPF在网络中实现的性能改进的示例。例如，在XDP中实现路由“性能提高了2.5倍”，与常规Linux内核实现相比，“XDP在负载均衡方面提供了4.3倍的性能增益”。
- en: For performance tracing and security observability, another advantage of eBPF
    is that relevant events can be filtered within the kernel before incurring the
    costs of sending them to user space. Filtering only certain network packets was,
    after all, the point of the original BPF implementation. Today eBPF programs can
    collect information about all manner of events across a system, and they can use
    complex, customized programmatic filters to send only the relevant subset of information
    to user space.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能跟踪和安全可观察性，eBPF的另一个优势是在产生成本之前可以在内核内部对相关事件进行过滤。毕竟，原始BPF实现的目的就是仅过滤特定的网络数据包。今天，eBPF程序可以收集有关系统各种事件的信息，并且它们可以使用复杂的、定制的程序过滤器，仅将相关信息的子集发送到用户空间。
- en: eBPF in Cloud Native Environments
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生环境中的eBPF
- en: 'These days lots of organizations choose not to run applications by executing
    programs directly on servers. Instead, many use cloud native approaches: containers,
    orchestrators such as Kubernetes or ECS, or serverless approaches like Lambda,
    cloud functions, Fargate, and so on. These approaches all use automation to choose
    the server where each workload will run; in serverless, we’re not even aware what
    server is running each workload.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，许多组织选择不直接在服务器上执行程序来运行应用程序。相反，许多人使用云原生方法：容器，编排器（如Kubernetes或ECS），或无服务器方法，如Lambda，云函数，Fargate等。这些方法都使用自动化来选择每个工作负载将在哪台服务器上运行；在无服务器中，我们甚至不知道哪台服务器正在运行每个工作负载。
- en: Nevertheless, there are servers involved, and each of those servers (whether
    it’s a virtual machine or bare-metal machine) runs a kernel. Where applications
    run in a container, if they’re running on the same (virtual) machine, they share
    the same kernel. In a Kubernetes environment, this means all the containers in
    all the pods on a given node are using the same kernel. When we instrument that
    kernel with eBPF programs, all the containerized workloads on that node are visible
    to those eBPF programs, as illustrated in [Figure 1-4](#ebpf_programs_in_the_kernel_have_visibi).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，涉及到服务器，每台服务器（无论是虚拟机还是裸机）都运行着一个内核。在容器中运行应用程序时，如果它们运行在同一（虚拟）机器上，它们将共享相同的内核。在Kubernetes环境中，这意味着给定节点上所有Pod中的所有容器都使用相同的内核。当我们用eBPF程序装备该内核时，所有该节点上的容器化工作负载对这些eBPF程序都是可见的，如[图1-4](#ebpf_programs_in_the_kernel_have_visibi)所示。
- en: '![eBPF programs in the kernel have visibility of all applications running on
    a Kubernetes node](assets/lebp_0104.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![eBPF programs in the kernel have visibility of all applications running on
    a Kubernetes node](assets/lebp_0104.png)'
- en: Figure 1-4\. eBPF programs in the kernel have visibility of all applications
    running on a Kubernetes node
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4。内核中的eBPF程序可以看到在Kubernetes节点上运行的所有应用程序
- en: 'Visibility of all the processes on the node, combined with the ability to load
    eBPF programs dynamically, gives us the real superpowers of eBPF-based tooling
    in cloud native computing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中的eBPF程序可以看到在Kubernetes节点上运行的所有应用程序
- en: We don’t need to change our applications, or even the way they are configured,
    to instrument them with eBPF tooling.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要改变我们的应用程序，甚至不需要改变它们的配置方式，就可以用eBPF工具装备它们。
- en: As soon as it’s loaded into the kernel and attached to an event, an eBPF program
    can start observing preexisting application processes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦加载到内核并附加到事件，eBPF程序就可以开始观察现有的应用程序进程。
- en: 'Contrast this with the *sidecar model*, which has been used to add functionality
    like logging, tracing, security, and service mesh functionality into Kubernetes
    apps. In the sidecar approach, the instrumentation runs as a container that is
    “injected” into each application pod. This process involves modifying the YAML
    that defines the application pods, adding in the definition of the sidecar container.
    This approach is certainly more convenient than adding the instrumentation into
    the source code of the application (which is what we had to do before the sidecar
    approach; for example, including a logging library in our application and making
    calls into that library at appropriate points in the code). Nevertheless, the
    sidecar approach has a few downsides:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与*边车模型*相比，边车模型已被用于将日志记录、跟踪、安全和服务网格功能添加到Kubernetes应用程序中。在边车方法中，仪器运行为一个“注入”到每个应用程序Pod中的容器。这个过程涉及修改定义应用程序Pod的YAML，添加边车容器的定义。这种方法当然比将仪器添加到应用程序源代码中更方便（这是我们在边车方法之前必须做的事情；例如，在我们的应用程序中包含一个日志库，并在代码中的适当位置调用该库）。然而，边车方法也有一些缺点：
- en: The application pod has to be restarted for the sidecar to be added.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序Pod必须重新启动才能添加边车。
- en: Something has to modify the application YAML. This is generally an automated
    process, but if something goes wrong, the sidecar won’t be added, which means
    the pod doesn’t get instrumented. For example, a deployment might be annotated
    to indicate that an admission controller should add the sidecar YAML to the pod
    spec for that deployment. But if the deployment isn’t labeled correctly, the sidecar
    won’t get added, and it’s therefore not visible to the instrumentation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有东西来修改应用程序的YAML。这通常是一个自动化的过程，但如果出了问题，边车就不会被添加，这意味着Pod不会被装备。例如，一个部署可能被注释，指示准入控制器应该向该部署的Pod规范添加边车YAML。但如果部署没有正确标记，边车就不会被添加，因此也不会被仪器所看到。
- en: When there are multiple containers within a pod, they might reach readiness
    at different times, the ordering of which may not be predictable. Pod start-up
    time can be significantly slowed by the injection of sidecars, or worse, it can
    cause race conditions or other instabilities. For example, the [Open Service Mesh
    documentation](https://oreil.ly/z80Q5) describes how application containers have
    to be resilient to all traffic being dropped until the Envoy proxy container is
    ready.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个Pod中有多个容器时，它们可能在不同的时间达到就绪状态，其顺序可能是不可预测的。边车的注入可能会显著减慢Pod的启动时间，或者更糟糕的是，可能会导致竞争条件或其他不稳定性。例如，[Open
    Service Mesh文档](https://oreil.ly/z80Q5)描述了应用程序容器必须对所有流量被丢弃直到Envoy代理容器准备就绪的情况具有韧性。
- en: Where networking functionality such as service mesh is implemented as a sidecar,
    it necessarily means that all traffic to and from the application container has
    to travel through the network stack in the kernel to reach a network proxy container,
    adding latency to that traffic; this is illustrated in [Figure 1-5](#path_of_a_network_packet_using_a_networ).
    We’ll talk about improving network efficiency with eBPF in [Chapter 9](ch09.html#ebpf_for_security).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当网络功能（如服务网格）作为边车实现时，这必然意味着所有进出应用程序容器的流量都必须通过内核中的网络堆栈到达网络代理容器，从而增加了流量的延迟；这在[图1-5](#path_of_a_network_packet_using_a_networ)中有所说明。我们将在[第9章](ch09.html#ebpf_for_security)中讨论如何使用eBPF来提高网络效率。
- en: '![Path of a network packet using a service mesh proxy sidecar container](assets/lebp_0105.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用服务网格代理边车容器的网络数据包路径](assets/lebp_0105.png)'
- en: Figure 1-5\. Path of a network packet using a service mesh proxy sidecar container
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5。使用服务网格代理边车容器的网络数据包路径
- en: All these issues are inherent problems with the sidecar model. Fortunately,
    now that eBPF is available as a platform, we have a new model that can avoid these
    issues. Additionally, because eBPF-based tools can see everything that’s happening
    on a (virtual) machine, they are harder for bad actors to sidestep. For example,
    if an attacker manages to deploy a cryptocurrency mining app on one of your hosts,
    they probably won’t do you the courtesy of instrumenting it with the sidecars
    you’re using on your application workloads. If you’re relying on a sidecar-based
    security tool to prevent apps from making unexpected network connections, that
    tool isn’t going to spot the mining app connecting to its mining pool if the sidecar
    isn’t injected. In contrast, network security implemented in eBPF can police all
    traffic on the host machine, so this cryptocurrency mining operation could easily
    be stopped. The ability to drop network packets for security reasons is something
    we’ll come back to in [Chapter 8](ch08.html#ebpf_for_networking).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都是侧车模型固有的问题。 幸运的是，现在eBPF作为一个平台可用，我们有了一个可以避免这些问题的新模型。此外，由于基于eBPF的工具可以看到（虚拟）机器上发生的一切，因此对于坏人来说更难以规避。
    例如，如果攻击者设法在您的主机上部署加密货币挖矿应用程序，他们可能不会给您一个礼貌，让您在应用程序工作负载上使用的侧车上进行仪器化。 如果您依赖基于侧车的安全工具来防止应用程序进行意外的网络连接，那么如果未注入侧车，该工具将无法发现挖矿应用程序连接到其挖矿池。
    相反，eBPF中实施的网络安全可以监管主机上的所有流量，因此可以轻松地停止这种加密货币挖矿操作。出于安全原因丢弃网络数据包的能力是我们将在[第8章](ch08.html#ebpf_for_networking)中回顾的内容。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope this chapter has given you some insight into why eBPF as a platform is
    so powerful. It allows us to change the behavior of the kernel, providing us the
    flexibility to build bespoke tools or customized policies. eBPF-based tools can
    observe any event across the kernel, and hence across all applications running
    on a (virtual) machine, whether they are containerized or not. eBPF programs can
    also be deployed dynamically, allowing behavior to be changed on the fly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章让您对eBPF作为一个平台为何如此强大有所了解。 它使我们能够改变内核的行为，为我们提供了构建定制工具或自定义策略的灵活性。 基于eBPF的工具可以观察内核中的任何事件，因此可以观察（虚拟）机器上运行的所有应用程序，无论它们是否被容器化。
    eBPF程序也可以动态部署，允许在运行时更改行为。
- en: So far we’ve discussed eBPF at a relatively conceptual level. In the next chapter
    we’ll make it more concrete and explore the constituent parts of an eBPF-based
    application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在相对概念水平上讨论了eBPF。在下一章中，我们将使其更加具体，并探讨基于eBPF的应用程序的组成部分。
- en: '^([1](ch01.html#ch01fn4-marker)) [“The BSD Packet Filter: A New Architecture
    for User-level Packet Capture”](https://oreil.ly/4GpgQ) by Steven McCanne and
    Van Jacobson.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch01.html#ch01fn4-marker)) [“The BSD Packet Filter: A New Architecture
    for User-level Packet Capture”](https://oreil.ly/4GpgQ) 由Steven McCanne和Van Jacobson。'
- en: ^([2](ch01.html#ch01fn5-marker)) These and other details come from Alexei Starovoitov’s
    2015 NetDev presentation, [“BPF – in-kernel virtual machine”](https://oreil.ly/hISe1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#ch01fn5-marker)) 这些和其他细节来自Alexei Starovoitov的2015年NetDev演示，题为[“BPF
    – in-kernel virtual machine”](https://oreil.ly/hISe1)。
- en: ^([3](ch01.html#ch01fn6-marker)) There is a good description of how kprobes
    work in [the kernel documentation](https://oreil.ly/Ue6Ii).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#ch01fn6-marker)) 在[内核文档](https://oreil.ly/Ue6Ii)中有关kprobes工作原理的良好描述。
- en: '^([4](ch01.html#ch01fn7-marker)) This wonderful fact comes from Daniel Borkmann’s
    KubeCon 2020 talk titled [“eBPF and Kubernetes: Little Helper Minions for Scaling
    Microservices”](https://oreil.ly/tIR9o).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch01.html#ch01fn7-marker)) 这个精彩的事实来自Daniel Borkmann的KubeCon 2020演讲，题为[“eBPF
    and Kubernetes: Little Helper Minions for Scaling Microservices”](https://oreil.ly/tIR9o)。'
- en: ^([5](ch01.html#ch01fn9-marker)) For more details on the instruction limit and
    “complexity limit,” see [*https://oreil.ly/0iVer*](https://oreil.ly/0iVer).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#ch01fn9-marker)) 有关指令限制和“复杂性限制”的更多详细信息，请参阅[*https://oreil.ly/0iVer*](https://oreil.ly/0iVer)。
- en: ^([6](ch01.html#ch01fn10-marker)) Extract from “What Is eBPF?” by Liz Rice.
    Copyright © 2022 O’Reilly Media. Used with permission.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#ch01fn10-marker)) 从Liz Rice的“What Is eBPF?”中提取。 版权所有 © 2022
    O’Reilly Media。经许可使用。
- en: ^([7](ch01.html#ch01fn11-marker)) [“Linux 5.12 Coming In At Around 28.8 Million
    Lines”](https://oreil.ly/9zJP2). Phoronix, March 2021.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01.html#ch01fn11-marker)) [“Linux 5.12 Coming In At Around 28.8 Million
    Lines”](https://oreil.ly/9zJP2). Phoronix, March 2021.
- en: ^([8](ch01.html#ch01fn12-marker)) Jiang Y, Adams B, German DM. 2013\. [“Will
    My Patch Make It? And How Fast?”](https://oreil.ly/rj2P4) (2013). According to
    this research paper, 33% of patches are accepted, and most take three to six months.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01.html#ch01fn12-marker)) Jiang Y, Adams B, German DM. 2013。[“Will My
    Patch Make It? And How Fast?”](https://oreil.ly/rj2P4) (2013)。根据这篇研究论文，33%的补丁被接受，大多数需要三到六个月。
- en: ^([9](ch01.html#ch01fn13-marker)) Thankfully, security patches to existing functionality
    are made available more quickly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch01.html#ch01fn13-marker)) 幸运的是，对现有功能的安全补丁更快地提供。
- en: '^([10](ch01.html#ch01fn14-marker)) Høiland-Jørgensen T, Brouer JD, Borkmann
    D, et al. [“The eXpress data path: fast programmable packet processing in the
    operating system kernel”](https://oreil.ly/qyhLK). *Proceedings of the 14th International
    Conference on emerging Networking EXperiments and Technologies* (CoNEXT ’18).
    Association for Computing Machinery; 2018:54–66.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '^([10](ch01.html#ch01fn14-marker)) Høiland-Jørgensen T, Brouer JD, Borkmann
    D, 等。[“The eXpress data path: fast programmable packet processing in the operating
    system kernel”](https://oreil.ly/qyhLK)。 *第14届新兴网络实验和技术国际会议* (CoNEXT ’18)。 计算机协会;
    2018:54–66。'

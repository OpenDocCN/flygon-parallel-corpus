["```cpp\n\n#!/usr/bin/python \nfrom bcc import BPF\n\nprogram = r\"\"\"\nint hello(void *ctx) {\n bpf_trace_printk(\"Hello World!\");\n return 0;\n}\n\"\"\"\n\nb = BPF(text=program)\nsyscall = b.get_syscall_fnname(\"execve\")\nb.attach_kprobe(event=syscall, fn_name=\"hello\")\n\nb.trace_print()\n```", "```cpp\n\ninthello(void*ctx){ `bpf_trace_printk``(``\"Hello World!\"``);` ``return``0``;` ``}```", "```cpp\n\n ```", "```cpp\n\nb = BPF(text=program)\n```", "```cpp\n\nsyscall = b.get_syscall_fnname(\"execve\")\n```", "```cpp\n\nb.attach_kprobe(event=syscall, fn_name=\"hello\")\n```", "```cpp\n\nb.trace_print()\n```", "```cpp  ```", "```cpp\n\n$ hello.py\nb'     bash-5412    [001] .... 90432.904952: 0: bpf_trace_printk: Hello World'\n```", "```cpp\n\nBPF_HASH(counter_table);![1](assets/1.png)inthello(void*ctx){u64uid;u64counter=0;u64*p;uid=bpf_get_current_uid_gid()&0xFFFFFFFF;![2](assets/2.png)p=counter_table.lookup(&uid);![3](assets/3.png)if(p!=0){![4](assets/4.png)counter=*p;}counter++;![5](assets/5.png)counter_table.update(&uid,&counter);![6](assets/6.png)return0;}\n```", "```cpp\n\np=counter_table.lookup(&uid);\n```", "```cpp\n\ncounter_table.update(&uid,&counter);\n```", "```cpp\n\nb = BPF(text=program)\nsyscall = b.get_syscall_fnname(\"execve\")\nb.attach_kprobe(event=syscall, fn_name=\"hello\")\n```", "```cpp\n\nwhileTrue:![1](assets/1.png)sleep(2)s=\"\"fork,vinb[\"counter_table\"].items():![2](assets/2.png)s+=f\"ID {k.value}: {v.value}\\t\"print(s)\n```", "```cpp\n\nTerminal 1                          Terminal 2\n$ ./hello-map.py \n                                    [blank line(s) until I run something]\nID 501: 1                           ls \nID 501: 1\nID 501: 2                           ls\nID 501: 3       ID 0: 1             sudo ls\nID 501: 4       ID 0: 1             ls\nID 501: 4       ID 0: 1\nID 501: 5       ID 0: 2             sudo ls\n```", "```cpp\n\nBPF_PERF_OUTPUT(output);![1](assets/1.png)structdata_t{![2](assets/2.png)intpid;intuid;charcommand[16];charmessage[12];};inthello(void*ctx){structdata_tdata={};![3](assets/3.png)charmessage[12]=\"Hello World\";data.pid=bpf_get_current_pid_tgid()>>32;![4](assets/4.png)data.uid=bpf_get_current_uid_gid()&0xFFFFFFFF;![5](assets/5.png)bpf_get_current_comm(&data.command,sizeof(data.command));![6](assets/6.png)bpf_probe_read_kernel(&data.message,sizeof(data.message),message);![7](assets/7.png)output.perf_submit(ctx,&data,sizeof(data));![8](assets/8.png)return0;}\n```", "```cpp\n\nb=BPF(text=program)![1](assets/1.png)syscall=b.get_syscall_fnname(\"execve\")b.attach_kprobe(event=syscall,fn_name=\"hello\")defprint_event(cpu,data,size):![2](assets/2.png)data=b[\"output\"].event(data)print(f\"{data.pid}{data.uid}{data.command.decode()}\"+\\\nf\"{data.message.decode()}\")b[\"output\"].open_perf_buffer(print_event)![3](assets/3.png)whileTrue:![4](assets/4.png)b.perf_buffer_poll()\n```", "```cpp\n\n$ sudo ./hello-buffer.py\n11654 node Hello World\n11655 sh Hello World\n...\n```", "```cpp\n\nstatic__always_inlinevoidmy_function(void*ctx,intval)\n```", "```cpp\n\nlongbpf_tail_call(void**`ctx`*,structbpf_map**`prog_array_map`*,u32*`index`*)\n```", "```cpp\n\nprog_array_map.call(ctx,index)\n```", "```cpp\n\nbpf_tail_call(ctx,prog_array_map,index)\n```", "```cpp\n\nBPF_PROG_ARRAY(syscall,300);![1](assets/1.png)inthello(structbpf_raw_tracepoint_args*ctx){![2](assets/2.png)intopcode=ctx->args[1];![3](assets/3.png)syscall.call(ctx,opcode);![4](assets/4.png)bpf_trace_printk(\"Another syscall: %d\",opcode);![5](assets/5.png)return0;}inthello_execve(void*ctx){![6](assets/6.png)bpf_trace_printk(\"Executing a program\");return0;}inthello_timer(structbpf_raw_tracepoint_args*ctx){![7](assets/7.png)if(ctx->args[1]==222){bpf_trace_printk(\"Creating a timer\");}elseif(ctx->args[1]==226){bpf_trace_printk(\"Deleting a timer\");}else{bpf_trace_printk(\"Some other timer operation\");}return0;}intignore_opcode(void*ctx){![8](assets/8.png)return0;}\n```", "```cpp\n\nb=BPF(text=program)b.attach_raw_tracepoint(tp=\"sys_enter\",fn_name=\"hello\")![1](assets/1.png)ignore_fn=b.load_func(\"ignore_opcode\",BPF.RAW_TRACEPOINT)![2](assets/2.png)exec_fn=b.load_func(\"hello_exec\",BPF.RAW_TRACEPOINT)timer_fn=b.load_func(\"hello_timer\",BPF.RAW_TRACEPOINT)prog_array=b.get_table(\"syscall\")![3](assets/3.png)prog_array[ct.c_int(59)]=ct.c_int(exec_fn.fd)prog_array[ct.c_int(222)]=ct.c_int(timer_fn.fd)prog_array[ct.c_int(223)]=ct.c_int(timer_fn.fd)prog_array[ct.c_int(224)]=ct.c_int(timer_fn.fd)prog_array[ct.c_int(225)]=ct.c_int(timer_fn.fd)prog_array[ct.c_int(226)]=ct.c_int(timer_fn.fd)# Ignore some syscalls that come up a lot ![4](assets/4.png)prog_array[ct.c_int(21)]=ct.c_int(ignore_fn.fd)prog_array[ct.c_int(22)]=ct.c_int(ignore_fn.fd)prog_array[ct.c_int(25)]=ct.c_int(ignore_fn.fd)...b.trace_print()![5](assets/5.png)\n```", "```cpp\n\n./hello-tail.py \nb'   hello-tail.py-2767    ... Another syscall: 62'\nb'   hello-tail.py-2767    ... Another syscall: 62'\n...\nb'            bash-2626    ... Executing a program'\nb'            bash-2626    ... Another syscall: 220'\n...\nb'           <...>-2774    ... Creating a timer'\nb'           <...>-2774    ... Another syscall: 48'\nb'           <...>-2774    ... Deleting a timer'\n...\nb'              ls-2774    ... Another syscall: 61'\nb'              ls-2774    ... Another syscall: 61'\n...\n```", "```cpp``  ``# Summary\n\nI hope that by showing some concrete examples of an eBPF program, this chapter helped you consolidate your mental model of eBPF code running in the kernel, triggered by events. You\u2019ve also seen examples of data being passed from the kernel to user space using BPF maps.\n\nUsing the BCC framework hides many of the details of how the program is built, loaded into the kernel, and attached to events. In the next chapter I\u2019ll show you a different approach to writing \u201cHello World,\u201d and we\u2019ll dive deeper into those hidden details.\n\n# Exercises\n\nHere are some optional activities you might like to try (or think about) if you want to explore \u201cHello World\u201d a bit further:\n\n1.  Adapt the *hello-buffer.py* eBPF program to output different trace messages for odd and even process IDs.\n\n2.  Modify *hello-map.py* so that the eBPF code gets triggered by more than one syscall. For example, `openat()` is commonly called to open files, and `write()` is called to write data to a file. You can start by attaching the *hello* eBPF program to multiple syscall kprobes. Then try having modified versions of the *hello* eBPF program for different syscalls, demonstrating that you can access the same map from multiple different programs.\n\n3.  The *hello-tail.py* eBPF program is an example of a program that attaches to the `sys_enter` raw tracepoint that is hit whenever *any* syscall is called. Change *hello-map.py* to show the total number of syscalls made by each user ID, by attaching it to that same `sys_enter` raw tracepoint.\n\n    Here\u2019s some example output I got after making that change:\n\n    ```", "```cpp\n\n4.  The [`RAW_TRACEPOINT_PROBE` macro provided by BCC](https://oreil.ly/kh-j4) simplifies attaching to raw tracepoints, telling the user space BCC code to automatically attach it to a specified tracepoint. Try it in *hello-tail.py*, like this:\n\n    *   Replace the definition of the `hello()` function with `RAW_TRACEPOINT_PROBE(sys_enter)`.\n\n    *   Remove the explicit attachment call `b.attach_raw_tracepoint()` from the Python code.\n\n    You should see that BCC automatically creates the attachment and the program works exactly the same. This is an example of the many convenient macros that BCC provides.\n\n5.  You could further adapt *hello_map.py* so that the key in the hash table identifies a particular syscall (rather than a particular user). The output will show how many times that syscall has been called across the whole system.\n\n^([1](ch02.html#ch02fn1-marker)) I originally wrote this for a talk titled \u201cThe Beginner\u2019s Guide to eBPF Programming.\u201d You can find the original code along with links to the slides and video at [*https://github.com/lizrice/ebpf-beginners*](https://github.com/lizrice/ebpf-beginners).\n\n^([2](ch02.html#ch02fn2-marker)) There is a more performant way to attach eBPF programs to functions, available from kernel version 5.5 onward, that uses fentry (and the corresponding fexit instead of kretprobe for the exit from a function). I\u2019ll discuss this later in the book, but for now I\u2019m using kprobe to keep the example in this chapter as simple as possible.\n\n^([3](ch02.html#ch02fn3-marker)) I quite often use VScode remote to connect to a virtual machine in the cloud. This runs lots of node scripts on the virtual machine, which generates lots of tracing from this \u201cHello World\u201d app.\n\n^([4](ch02.html#ch02fn4-marker)) Some commands (`echo` is a common example) might be shell built-ins that run as part of the shell process, rather than executing a new program. These won\u2019t trigger the `execve()` event, so no trace will be generated.\n\n^([5](ch02.html#ch02fn5-marker)) C++ does, but not C.\n\n^([6](ch02.html#ch02fn6-marker)) The lower 32 bits are the *thread group ID*. For a single-threaded process, this is the same as the process ID, but additional threads for the process would be given different IDs. The docs for the GNU C library have a good description of the difference between [process and thread group IDs](https://oreil.ly/Wo9k3).\n\n^([7](ch02.html#ch02fn7-marker)) This is just example code, so I\u2019m not worrying about cleaning up on keyboard interrupt or any other niceties!\n\n^([8](ch02.html#ch02fn8-marker)) This principle is often called \u201cDRY\u201d (\u201cDon\u2019t Repeat Yourself\u201d), as popularized by [The Pragmatic Programmer](https://oreil.ly/QFich).\n\n^([9](ch02.html#ch02fn9-marker)) There are some 300 syscalls in Linux, and since I\u2019m not using any recently added syscalls for this example, this is good enough.\n\n^([10](ch02.html#ch02fn10-marker)) Making tail calls from a BPF subprogram requires support from the JIT compiler, which you\u2019ll meet in the next chapter. In the kernel version I used to write the examples in this book, only the JIT compiler on x86 has this support, although [support has been added to ARM in kernel 6.0](https://oreil.ly/KYUYS).```"]
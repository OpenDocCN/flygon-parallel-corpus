- en: Chapter 2\. eBPF’s “Hello World”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter I discussed why eBPF is so powerful, but it’s OK if
    you don’t yet feel you have a concrete grasp of what it really means to run eBPF
    programs. In this chapter I’ll use a simple “Hello World” example to give you
    a better feel for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll learn while you read through this book, there are several different
    libraries and frameworks for writing eBPF applications. As a warm-up, I’ll show
    you what is probably the most accessible approach from a programming point of
    view: the [BCC Python framework](https://github.com/iovisor/bcc). This offers
    a very easy way to write basic eBPF programs. For reasons that I’ll cover in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    it’s not necessarily an approach I would recommend these days for production apps
    that you’re intending to distribute to other users, but it’s great for taking
    your first steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to try this code for yourself, it is available at [*https://github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    in the *chapter2* directory.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the BCC project at [*https://github.com/iovisor/bcc*](https://github.com/iovisor/bcc),
    and the instructions for installing BCC are at [*https://github.com/iovisor/bcc/blob/master/INSTALL.md*](https://github.com/iovisor/bcc/blob/master/INSTALL.md).
  prefs: []
  type: TYPE_NORMAL
- en: BCC’s “Hello World”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the full source code of *hello.py*, an eBPF “Hello World”
    application^([1](ch02.html#ch02fn1)) written using BCC’s Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code consists of two parts: the eBPF program itself that will run in the
    kernel, and some user space code that loads the eBPF program into the kernel and
    reads out the trace that it generates. As you can see in [Figure 2-1](#the_user_space_and_kernel_components_of),
    *hello.py* is the user space part of this application, and `hello()` is the eBPF
    program that runs in the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user space and kernel components of “Hello World”](assets/lebp_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. The user space and kernel components of “Hello World”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s dig into each line of the source code to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: The first line tells you this is Python code, and the program that can run it
    is the Python interpreter (*/usr/bin/python*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The eBPF program itself is written in C code, and it’s this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]All the eBPF program does is use a helper function, `bpf_trace_printk()`,
    to write a message. Helper functions are another feature that distinguishes “extended”
    BPF from its “classic” predecessor. They are a set of functions that eBPF programs
    can call to interact with the system; I’ll discuss them further in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
    For now you can just think of this as printing a line of text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire eBPF program is defined as a string called `program` in the Python
    code. This C program needs to be compiled before it can be executed, but BCC takes
    care of that for you. (You’ll see how to compile eBPF programs yourself in the
    next chapter.) All you need to do is pass this string as a parameter when creating
    a BPF object, as in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'eBPF programs need to be attached to an event, and for this example I’ve chosen
    to attach to the system call `execve`, which is the syscall used to execute a
    program. Whenever anything or anyone starts a new program executing on this machine,
    that will call `execve()`, which will trigger the eBPF program. Although the “execve()”
    name is a standard interface in Linux, the name of the function that implements
    it in the kernel depends on the chip architecture, but BCC gives us a convenient
    way to look up the function name for the machine we’re running on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `syscall` represents the name of the kernel function I’m going to attach
    to, using a kprobe (you were introduced to the concept of kprobes in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque)).^([2](ch02.html#ch02fn2))
    You can attach the `hello` function to that event, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the eBPF program is loaded into the kernel and attached to an
    event, so the program will be triggered whenever a new executable gets launched
    on the machine. All that’s left to do in the Python code is to read the tracing
    that is output by the kernel and write it on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `trace_print()` function will loop indefinitely (until you stop the program,
    perhaps with Ctrl+C), displaying any trace.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](#quotation_markhello_worldquotation_mark) illustrates this code.
    The Python program compiles the C code, loads it into the kernel, and attaches
    it to the `execve` syscall kprobe. Whenever any application on this (virtual)
    machine calls `execve()`, it triggers the eBPF `hello()` program, which writes
    a line of trace into a specific pseudofile. (I’ll cover where that pseudofile
    is later in this chapter.) The Python program reads the trace message from the
    pseudofile and displays it to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '![“Hello World” in operation](assets/lebp_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. “Hello World” in operation[PRE7]# Running “Hello World”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Run this program, and depending on what is happening on the (virtual) machine
    you’re using, you might see tracing being generated straightaway, because other
    processes could be executing programs^([3](ch02.html#ch02fn3)) with the `execve`
    syscall. If you don’t see anything, open a second terminal and execute any commands
    you like,^([4](ch02.html#ch02fn4)) and you’ll see the corresponding trace generated
    by “Hello World”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since eBPF is so powerful, it requires special privileges to use it. Privileges
    are automatically assigned to the root user, so the easiest way to run eBPF programs
    is as root, perhaps by using `sudo`. For clarity I won’t include `sudo` in the
    example commands in this book, but if you ever see an “Operation not permitted”
    error, the first thing to check is whether you’re trying to run eBPF programs
    as an unprivileged user.
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_BPF` was introduced in kernel version 5.8, and it gives sufficient privilege
    to perform some eBPF operations like creating certain types of map. However, you
    will probably need additional capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_PERFMON` and `CAP_BPF` are both required to load tracing programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_ADMIN` and `CAP_BPF` are both required for loading networking programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot more detail on this in the blog post [“Introduction to CAP_BPF”](https://oreil.ly/G2zFO)
    by Milan Landaverde.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the *hello* eBPF program is loaded and attached to an event, it
    gets triggered by events that are being generated from preexisting processes.
    This should reinforce a couple of points that you learned in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque):'
  prefs: []
  type: TYPE_NORMAL
- en: eBPF programs can be used to dynamically change the behavior of the system.
    There’s no need to reboot the machine or restart existing processes. eBPF code
    starts taking effect as soon as it is attached to an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no need to change anything about other applications for them to be visible
    to eBPF. Wherever you have terminal access on that machine, if you run an executable
    in it, that will use the `execve()` syscall, and if you have the *hello* program
    attached to that syscall, it will be triggered to generate tracing output. Likewise,
    if you have a script that runs executables, that will also trigger the *hello*
    eBPF program. You don’t need to change anything about the terminal’s shell, the
    script, or the executables you’re running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trace output shows not only the `"Hello World`" string, but also some additional
    contextual information about the event that triggered the *hello* eBPF program
    to run. In the example output shown at the beginning of this section, the process
    that made the `execve` system call had a process ID of 5412, and it was running
    the command `bash`. For trace messages, this contextual information is added as
    part of the kernel tracing infrastructure (which isn’t specific to eBPF), but
    as you’ll see later in this chapter, it’s also possible to retrieve contextual
    information like this within the eBPF program itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering how the Python code knows where to read the tracing
    output from. The answer is not very sophisticated—the `bpf_trace_printk()` helper
    function in the kernel always sends output to the same predefined pseudofile location:
    */sys/kernel/debug/tracing/trace_pipe*. You can confirm this by using `cat` to
    view its contents; you’ll need root privileges to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: A single trace pipe location is fine for a simple “Hello World” example or for
    basic debugging purposes, but it’s very limited. There is very little flexibility
    in the format of the output, and it only supports the output of strings, so it’s
    not terribly useful for passing structured information. Perhaps most importantly,
    there is just this one location on the (virtual) machine. If you had multiple
    eBPF programs running simultaneously, they would all write trace output to the
    same trace pipe, which could get very confusing for a human operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a much better way to get information out of an eBPF program: use an
    eBPF map.'
  prefs: []
  type: TYPE_NORMAL
- en: BPF Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *map* is a data structure that can be accessed from an eBPF program and from
    user space. Maps are one of the really significant features that distinguish extended
    BPF from its classic predecessor. (You might think this would mean they are commonly
    referred to as “eBPF maps,” but you’ll frequently see “BPF maps.” As is generally
    the case, both terms are used interchangeably.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Maps can be used to share data among multiple eBPF programs or to communicate
    between a user space application and eBPF code running in the kernel. Typical
    uses include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User space writing configuration information to be retrieved by an eBPF program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An eBPF program storing state, for later retrieval by another eBPF program (or
    a future run of the same program)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An eBPF program writing results or metrics into a map, for retrieval by the
    user space app that will present results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various types of BPF maps defined in Linux’s [*uapi/linux/bpf.h* file](https://oreil.ly/1s1GM),
    and there is some information about them in the [kernel docs](https://oreil.ly/5oUW7).
    In general they are all key–value stores, and in this chapter you’ll see examples
    of maps for hash tables, perf and ring buffers, and arrays of eBPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: Some map types are defined as arrays, which always have a 4-byte index as the
    key type; other maps are hash tables that can use some arbitrary data type as
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: There are map types that are optimized for particular types of operations, such
    as [first-in-first-out queues](https://oreil.ly/VSoEp), [first-in-last-out stacks](https://oreil.ly/VSoEp),
    [least-recently-used data storage](https://oreil.ly/vpsun), [longest-prefix matching](https://oreil.ly/hZ5aM),
    and [Bloom filters](https://oreil.ly/DzCTK) (a probabilistic data structure designed
    to provide very fast results on whether an element exists).
  prefs: []
  type: TYPE_NORMAL
- en: Some eBPF map types hold information about specific types of objects. For example,
    [sockmaps](https://oreil.ly/UUTHO) and [devmaps](https://oreil.ly/jzKYh) hold
    information about sockets and network devices and are used by network-related
    eBPF programs to redirect traffic. A program array map stores a set of indexed
    eBPF programs, and (as you’ll see later in this chapter) this is used to implement
    tail calls, where one program can call another. There’s even a [map-of-maps type](https://oreil.ly/038tN)
    to support storing information about maps.
  prefs: []
  type: TYPE_NORMAL
- en: Some map types have per-CPU variants, which is to say that the kernel uses a
    different block of memory for each CPU core’s version of that map. This might
    have you wondering about concurrency concerns for maps that are *not* per-CPU,
    where multiple CPU cores could be accessing the same map simultaneously. Spin
    lock support for (some) maps was added in kernel version 5.1, and we’ll return
    to this subject in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  prefs: []
  type: TYPE_NORMAL
- en: The next example (*chapter2/hello-map.py* in the [GitHub repository](https://github.com/lizrice/learning-ebpf))
    shows some basic operations using a hash table map. It also demonstrates some
    of BCC’s convenient abstractions that make it very easy to use maps.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Table Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the previous example in this chapter, this eBPF program will be attached
    to a kprobe at the entry to the `execve` system call. It’s going to populate a
    hash table with key–value pairs, where the key is a user ID and the value is a
    counter for the number of times `execve` is called by a process running under
    that user ID. In practice, this example will show how many times each different
    user has run programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the C code for the eBPF program itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_HASH()` is a BCC macro that defines a hash table map.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpf_get_current_uid_gid()` is a helper function used to obtain the user ID
    that is running the process that triggered this kprobe event. The user ID is held
    in the lowest 32 bits of the 64-bit value that gets returned. (The top 32 bits
    hold the group ID, but that part is masked out.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_2_3)'
  prefs: []
  type: TYPE_NORMAL
- en: Look for an entry in the hash table with a key matching the user ID. It returns
    a pointer to the corresponding value in the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_2_4)'
  prefs: []
  type: TYPE_NORMAL
- en: If there is an entry for this user ID, set the `counter` variable to the current
    value in the hash table (pointed to by `p`). If there is no entry for this user
    ID in the hash table, the pointer will be `0`, and the counter value will be left
    at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_2_5)'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the current counter value is, it gets incremented by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_2_6)'
  prefs: []
  type: TYPE_NORMAL
- en: Update the hash table with the new counter value for this user ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a closer look at the lines of code that access the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`And later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`If you’re thinking “that’s not proper C code!” you’re absolutely right. C
    doesn’t support defining methods on structures like that.^([5](ch02.html#ch02fn5))
    This is a great example where BCC’s version of C is very loosely a C-like language
    that BCC rewrites before it sends the code to the compiler. BCC offers some convenient
    shortcuts and macros that it converts into “proper” C.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous example, the C code is defined as a string called
    `program`. The program is compiled, loaded into the kernel, and attached to the
    `execve` kprobe, in exactly the same way as the previous “Hello World” example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This time a little more work is required on the Python side to read the information
    out of the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_7)'
  prefs: []
  type: TYPE_NORMAL
- en: This part of the code loops indefinitely, looking for output to display every
    two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_8)'
  prefs: []
  type: TYPE_NORMAL
- en: BCC automatically creates a Python object to represent the hash table. This
    code loops through any values and prints them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this example, you’ll want a second terminal window where you can
    run some commands. Here’s some example output I obtained, annotated on the right
    side with the commands I ran in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This example generates a line of output every two seconds, whether anything
    has happened or not. At the end of this output, the hash table contains two entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key=501, value=5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key=0, value=2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second terminal, I have the user ID of 501\. Running the `ls` command
    with this user ID increments the `execve` counter. When I run `sudo ls`, this
    results in two calls to `execve`: one is the execution of `sudo`, under user ID
    501; the other is the execution of `ls`, under root’s user ID of 0.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I used a hash table to convey data from the eBPF program to
    user space. (I could also have used an array type of map here, since the key was
    an integer; hash tables let you use an arbitrary type as the key.) Hash tables
    are very convenient when the data is naturally in key–value pairs, but the user
    space code has to keep polling the table on a regular basis. The Linux kernel
    already supported the [perf subsystem](https://oreil.ly/nTvvH) for sending data
    from the kernel to user space, and eBPF includes support for using perf buffers
    and their successor, BPF ring buffers. Let’s take a look.``  ``## Perf and Ring
    Buffer Maps
  prefs: []
  type: TYPE_NORMAL
- en: In this section I’m going to describe a slightly more sophisticated version
    of “Hello World” that uses BCC’s `BPF_PERF_OUTPUT` capabilities, which let you
    write data in a structure of your choosing into a perf ring buffer map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a newer construct called “BPF ring buffers” that are now generally
    preferred over BPF perf buffers, if you have a kernel of version 5.8 or above.
    Andrii Nakryiko discusses the difference in his [BPF ring buffer](https://oreil.ly/ARRyV)
    blog post. You’ll see an example of BCC’s `BPF_RINGBUF_OUTPUT` in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the source code for this example in *chapter2/hello-buffer.py* in
    the *Learning eBPF* [GitHub repository](http://github.com/lizrice/learning-ebpf).
    As in the first “Hello World” example you saw early in this chapter, this version
    will write the string `"Hello World"` to the screen every time the `execve()`
    syscall is used. It will also look up the process ID and the name of the command
    that makes each `execve()` call so that you’ll get similar output to the first
    example. This gives me the opportunity to show you a couple more examples of BPF
    helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the eBPF program that will be loaded into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_9)'
  prefs: []
  type: TYPE_NORMAL
- en: BCC defines the macro `BPF_PERF_OUTPUT` for creating a map that will be used
    to pass messages from the kernel to user space. I’ve called this map `output`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_10)'
  prefs: []
  type: TYPE_NORMAL
- en: Every time `hello()` is run, the code will write a structure’s worth of data.
    This is the definition of that structure, which has fields for the process ID,
    the name of the currently running command, and a text message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_2_11)'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` is a local variable that holds the data structure to be submitted, and
    `message` holds the `"Hello World"` string.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_2_12)'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpf_get_current_pid_tgid()` is a helper function that gets the ID of the process
    that triggered this eBPF program to run. It returns a 64-bit value with the process
    ID in the top 32 bits.^([6](ch02.html#ch02fn6))'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_2_13)'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpf_get_current_uid_gid()` is the helper function you saw in the previous
    example for obtaining the user ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_2_14)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `bpf_get_current_comm()` is a helper function for getting the name
    of the executable (or “command”) that’s running in the process that made the `execve`
    syscall. This is a string, not a numeric value like the process and user IDs,
    and in C you can’t simply assign a string using `=`. You have to pass the address
    of the field where the string should be written, `&data.command`, as an argument
    to the helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#code_id_2_15)'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, the message is `"Hello World"` every time. `bpf_probe_read_kernel()`
    copies it into the right place in the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#code_id_2_16)'
  prefs: []
  type: TYPE_NORMAL
- en: At this point the data structure is populated with the process ID, command name,
    and message. This call to `output.perf_submit()` puts that data into the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as in the first “Hello World” example, this C program is assigned to a
    string called `program` in the Python code. What follows is the rest of the Python
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_17)'
  prefs: []
  type: TYPE_NORMAL
- en: The lines that compile the C code, load it into the kernel, and attach it to
    the syscall event are unchanged from the version of “Hello World” you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_18)'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_event` is a callback function that will output a line of data to the
    screen. BCC does some heavy lifting so that I can refer to the map simply as `b["output"]`
    and grab data from it using `b["output"].event()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_2_19)'
  prefs: []
  type: TYPE_NORMAL
- en: '`b["output"].open_perf_buffer()` opens the perf ring buffer. The function takes
    `print_event` as an argument to define that this is the callback function to be
    used whenever there is data to read from the buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_2_20)'
  prefs: []
  type: TYPE_NORMAL
- en: The program will now loop indefinitely,^([7](ch02.html#ch02fn7)) polling the
    perf ring buffer. If there is any data available, `print_event` will get called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code gives us output that’s fairly similar to the original “Hello
    World”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As before, you might need to open a second terminal to the same (virtual) machine
    and run some commands to trigger some output.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between this and the original “Hello World” example is that
    instead of using a single, central trace pipe, the data is now being passed via
    a ring buffer map called `output` that was created by this program for its own
    use, as shown in [Figure 2-4](#using_a_perf_ring_buffer_for_passing_da).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a perf ring buffer for passing data from the kernel to user space](assets/lebp_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Using a perf ring buffer for passing data from the kernel to user
    space
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can verify that the information isn’t going to the trace pipe by using `cat
    /sys/kernel/debug/tracing/trace_pipe`.
  prefs: []
  type: TYPE_NORMAL
- en: As well as demonstrating the use of a ring buffer map, this example shows some
    eBPF helper functions for retrieving contextual information about the event that
    triggered the eBPF program to run. Here you’ve seen helper functions getting the
    user ID, the process ID, and the name of the current command. As you’ll see in
    [Chapter 7](ch07.html#ebpf_program_and_attachment_types), the set of contextual
    information that’s available and the set of valid helper functions that can be
    used to retrieve it depend on what type of program it is and what event triggered
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that contextual information like this is available to the eBPF code
    is what makes it so valuable for observability. Whenever an event occurs, an eBPF
    program can report not only the fact that the event happened but also relevant
    information about what happened to trigger the event. It’s also highly performant,
    since all this information can be gathered within the kernel, without the need
    for any synchronous context switching to user space.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see further examples in this book where eBPF helper functions are used
    to gather other contextual data, as well as examples where eBPF programs change
    the contextual data or even block events from happening altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Function Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen that eBPF programs can call helper functions provided by the kernel,
    but what if you want to split the code you’re writing into functions? Generally,
    in software development it’s considered good practice^([8](ch02.html#ch02fn8))
    to pull common code into a function that you can call from multiple places, rather
    than duplicating the same lines over and over again. But in the early days, eBPF
    programs were not permitted to call functions other than helper functions. To
    work around this, programmers have directed the compiler to “always inline” their
    functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Generally, a function in source code results in the compiler emitting a jump
    instruction, which causes execution to jump to the set of instructions that make
    up the called function (and then to jump back again when that function has completed).
    You can see this illustrated on the left side of [Figure 2-5](#layout_of_noninlined_and_inlined_functi).
    The right side shows what happens when a function is inlined: there is no jump
    instruction; instead, a copy of the function’s instructions is emitted directly
    within the calling function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of noninlined and inlined function instructions](assets/lebp_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Layout of noninlined and inlined function instructions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the function is called from multiple places, that results in multiple copies
    of that function’s instructions in the compiled executable. (Sometimes the compiler
    might choose to inline a function for optimization purposes, and that is one reason
    why you might not be able to attach a kprobe to certain kernel functions. I’ll
    come back to this in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).)
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Linux kernel 4.16 and LLVM 6.0, the restriction requiring functions
    to be inlined was lifted so that eBPF programmers could write function calls more
    naturally. However, this feature, called “BPF to BPF function calls” or “BPF subprograms,”
    isn’t currently supported by the BCC framework, so let’s come back to it in the
    next chapter. (You can, of course, continue to use functions with BCC if they
    are inlined.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another mechanism for decomposing complex functionality into smaller
    parts in eBPF: tail calls.`  `## Tail Calls'
  prefs: []
  type: TYPE_NORMAL
- en: As described at [ebpf.io](https://oreil.ly/Loyuz), “tail calls can call and
    execute another eBPF program and replace the execution context, similar to how
    the `execve()` system call operates for regular processes.” In other words, execution
    doesn’t return to the caller after a tail call completes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Tail calls](https://oreil.ly/cOA1r) are by no means exclusive to eBPF programming.
    The general motivation behind tail calls is to avoid adding frames to the stack
    over and over again as a function is called recursively, which can eventually
    lead to stack overflow errors. If you can arrange your code to call a recursive
    function as the last thing it does, the stack frame associated with the calling
    function isn’t really doing anything useful. Tail calls allow for calling a series
    of functions without growing the stack. This is particularly useful in eBPF where
    the [stack is limited to 512 bytes](https://oreil.ly/SZmkd).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tail calls are made using the `bpf_tail_call()` helper function, which has
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The three arguments to this function have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ctx` allows passing the context from the calling eBPF program to the callee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prog_array_map` is an eBPF map of type `BPF_MAP_TYPE_PROG_ARRAY`, which holds
    a set of file descriptors that identify eBPF programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` indicates which of that set of eBPF programs should be invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This helper is somewhat unusual in that if it succeeds, it never returns. The
    currently running eBPF program is replaced on the stack by the program being called.
    The helper could fail, for example, if the indicated program doesn’t exist in
    the map, in which case the calling program carries on executing.
  prefs: []
  type: TYPE_NORMAL
- en: User space code has to load all the eBPF programs into the kernel (as usual),
    and it also sets up the program array map.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example written in Python using BCC; you’ll find the
    code in the [GitHub repo](http://github.com/lizrice/learning-ebpf) as *chapter2/hello-tail.py*.
    The main eBPF program is attached to a tracepoint at the common entry point for
    all syscalls. This program uses tail calls to trace out specific messages for
    certain syscall opcodes. If there isn’t a tail call for a given opcode, the program
    traces out a generic message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using the BCC framework, to make a [tail call](https://oreil.ly/rT9e1)
    you can use a line of the slightly simpler form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Before passing the code to the compilation step, BCC will rewrite the preceding
    line to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`Here is the source code for the eBPF program and its tail calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_21)'
  prefs: []
  type: TYPE_NORMAL
- en: BCC provides a `BPF_PROG_ARRAY` macro for easily defining maps of type `BPF_MAP_TYPE_PROG_ARRAY`.
    I have called the map `syscall` and allowed for 300 entries,^([9](ch02.html#ch02fn9))
    which is going to be sufficient for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_22)'
  prefs: []
  type: TYPE_NORMAL
- en: In the user space code that you’ll see shortly, I’m going to attach this eBPF
    program to the `sys_enter` raw tracepoint, which gets hit whenever any syscall
    is made. The context passed to an eBPF program attached to a raw tracepoint takes
    the form of this `bpf_raw_tracepoint_args` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_2_23)'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `sys_enter`, the raw tracepoint arguments include the opcode
    identifying which syscall is being made.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_2_24)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we make a tail call to the entry in the program array whose key matches
    the opcode. This line of code will be rewritten by BCC to a call to the `bpf_tail_call()`
    helper function before it passes the source code to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_2_25)'
  prefs: []
  type: TYPE_NORMAL
- en: If the tail call succeeds, this line tracing out the opcode value will never
    be hit. I’ve used this to provide a default line of trace for opcodes for which
    there isn’t a program entry in the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_2_26)'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello_exec()` is a program that will be loaded into the syscall program array
    map, to be executed as a tail call when the opcode indicates it’s an `execve()`
    syscall. It’s just going to generate a line of trace to tell the user a new program
    is being executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#code_id_2_27)'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello_timer()` is another program that will be loaded into the syscall program
    array. In this case it’s going to be referred to by more than one entry in the
    program array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#code_id_2_28)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ignore_opcode()` is a tail call program that does nothing. I’ll use this for
    syscalls where I don’t want any trace to be generated at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the user space code that loads and manages this set of eBPF
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_2_29)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of attaching to a kprobe, as you saw earlier, this time the user space
    code attaches the main eBPF program to the `sys_enter` tracepoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_2_30)'
  prefs: []
  type: TYPE_NORMAL
- en: These calls to `b.load_func()` return a file descriptor for each tail call program.
    Notice that tail calls need to have the same program type as their parent—`BPF.RAW_TRACEPOINT`
    in this case. Also, it bears pointing out that each tail call program is an eBPF
    program in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_2_31)'
  prefs: []
  type: TYPE_NORMAL
- en: The user space code creates entries in the `syscall` map. The map doesn’t have
    to be fully populated for every possible opcode; if there is no entry for a particular
    opcode, it simply means no tail call will be executed. Also, it’s perfectly fine
    to have multiple entries that point to the same eBPF program. In this case, I
    want the `hello_timer()` tail call to be executed for any of a set of timer-related
    syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_2_32)'
  prefs: []
  type: TYPE_NORMAL
- en: Some syscalls get run so frequently by the system that a line of trace for each
    of them clutters up the trace output to the point of unreadability. I’ve used
    the `ignore_opcode()` tail call for several syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_2_33)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the trace output to the screen, until the user terminates the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program generates trace output for every syscall that runs on
    the (virtual) machine, unless the opcode has an entry that links it to the `ignore_opcode()`
    tail call. Here’s some example output from running `ls` in another terminal (some
    details have been omitted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The particular syscalls being executed are beside the point, but you can see
    that the different tail calls are getting called and are generating trace messages.
    You can also see the default message `Another syscall` for opcodes that don’t
    have an entry in the tail call program map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Check out Paul Chaignon’s blog post about the [cost of BPF tail calls](https://oreil.ly/jTxcb)
    on various different kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: Tail calls have been supported in eBPF since kernel version 4.2, but for a long
    time they were incompatible with making BPF to BPF function calls. This restriction
    was lifted in kernel 5.10.^([10](ch02.html#ch02fn10))
  prefs: []
  type: TYPE_NORMAL
- en: The fact that you can chain up to 33 tail calls together, combined with the
    instruction complexity limit per eBPF program of 1 million instructions, means
    that today’s eBPF programmers have a lot of leeway to write very complex code
    to run entirely in the kernel.[PRE25]
  prefs: []
  type: TYPE_NORMAL
- en: $ ./hello-map.py
  prefs: []
  type: TYPE_NORMAL
- en: 'ID 104: 6     ID 0: 225'
  prefs: []
  type: TYPE_NORMAL
- en: 'ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 332     ID 501: 19'
  prefs: []
  type: TYPE_NORMAL
- en: 'ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 368     ID 501: 38'
  prefs: []
  type: TYPE_NORMAL
- en: 'ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 533     ID 501: 57'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]``'
  prefs: []
  type: TYPE_NORMAL

["```cpp\nstruct`bpf_insn`{`__u8``code`;/* opcode */![1](assets/1.png)`__u8``dst_reg`:4;/* dest register */![2](assets/2.png)`__u8``src_reg`:4;/* source register */`__s16``off`;/* signed offset */![3](assets/3.png)`__s32``imm`;/* signed immediate constant */};\n```", "```cpp\n#include<linux/bpf.h>![1](assets/1.png)#include<bpf/bpf_helpers.h>intcounter=0;![2](assets/2.png)SEC(\"xdp\")![3](assets/3.png)inthello(void*ctx){![4](assets/4.png)bpf_printk(\"Hello World %d\",counter);counter++;returnXDP_PASS;}charLICENSE[]SEC(\"license\")=\"Dual BSD/GPL\";![5](assets/5.png)\n```", "```cpp\nhello.bpf.o: %.o: %.c\n   clang \\ -target bpf \\ `-I/usr/include/`$(``shell` `uname` -`m``)`-linux-gnu \\ `-g \\ `-O2 -c `$<` -o `$@```", "```cpp\n\n ```", "```cpp  ```", "```cpp\n$ file hello.bpf.o\nhello.bpf.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), with debug_info,\nnot stripped\n```", "```cpp\n$ llvm-objdump -S hello.bpf.o\n```", "```cpp\nhello.bpf.o:    file format elf64-bpf               ![1](assets/1.png)\n\nDisassembly of section xdp:                         ![2](assets/2.png)\n\n0000000000000000 <hello>:                           ![3](assets/3.png)\n;  bpf_printk(\"Hello World %d\", counter\");          ![4](assets/4.png) \n    0:   18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r6 = 0 ll\n    2:   61 63 00 00 00 00 00 00 r3 = *(u32 *)(r6 + 0)\n    3:   18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0 ll\n    5:   b7 02 00 00 0f 00 00 00 r2 = 15\n    6:   85 00 00 00 06 00 00 00 call 6\n;  counter++;                                       ![5](assets/5.png)\n    7:   61 61 00 00 00 00 00 00 r1 = *(u32 *)(r6 + 0)\n    8:   07 01 00 00 01 00 00 00 r1 += 1\n    9:   63 16 00 00 00 00 00 00 *(u32 *)(r6 + 0) = r1\n;  return XDP_PASS;                                 ![6](assets/6.png)\n   10:   b7 00 00 00 02 00 00 00 r0 = 2\n   11:   95 00 00 00 00 00 00 00 exit\n```", "```cpp\n    5:   b7 02 00 00 0f 00 00 00 r2 = 15\n```", "```cpp\n   10:   b7 00 00 00 02 00 00 00 r0 = 2\n```", "```cpp\n$ bpftool prog load hello.bpf.o /sys/fs/bpf/hello\n```", "```cpp\n$ ls /sys/fs/bpf\nhello\n```", "```cpp\n$ bpftool prog list \n...\n540: xdp  name hello  tag d35b94b4c0c10efb  gpl\n        loaded_at 2022-08-02T17:39:47+0000  uid 0\n        xlated 96B  jited 148B  memlock 4096B  map_ids 165,166\n        btf_id 254\n```", "```cpp\n$ bpftool prog show id 540 --pretty\n{\n    \"id\": 540,\n    \"type\": \"xdp\",\n    \"name\": \"hello\",\n    \"tag\": \"d35b94b4c0c10efb\",\n    \"gpl_compatible\": true,\n    \"loaded_at\": 1659461987,\n    \"uid\": 0,\n    \"bytes_xlated\": 96,\n    \"jited\": true,\n    \"bytes_jited\": 148,\n    \"bytes_memlock\": 4096,\n    \"map_ids\": [165,166\n    ],\n    \"btf_id\": 254\n}\n```", "```cpp\n$ bpftool prog dump xlated name hello \nint hello(struct xdp_md * ctx):\n; bpf_printk(\"Hello World %d\", counter);\n   0: (18) r6 = map[id:165][0]+0\n   2: (61) r3 = *(u32 *)(r6 +0)\n   3: (18) r1 = map[id:166][0]+0\n   5: (b7) r2 = 15\n   6: (85) call bpf_trace_printk#-78032\n; counter++; \n   7: (61) r1 = *(u32 *)(r6 +0)\n   8: (07) r1 += 1\n   9: (63) *(u32 *)(r6 +0) = r1\n; return XDP_PASS;\n  10: (b7) r0 = 2\n  11: (95) exit\n```", "```cpp\n$ bpftool prog dump jited name hello \nint hello(struct xdp_md * ctx):\nbpf_prog_d35b94b4c0c10efb_hello:\n; bpf_printk(\"Hello World %d\", counter);\n   0:   hint    #34\n   4:   stp     x29, x30, [sp, #-16]!\n   8:   mov     x29, sp\n   c:   stp     x19, x20, [sp, #-16]!\n  10:   stp     x21, x22, [sp, #-16]!\n  14:   stp     x25, x26, [sp, #-16]!\n  18:   mov     x25, sp\n  1c:   mov     x26, #0\n  20:   hint    #36\n  24:   sub     sp, sp, #0\n  28:   mov     x19, #-140733193388033\n  2c:   movk    x19, #2190, lsl #16\n  30:   movk    x19, #49152\n  34:   mov     x10, #0\n  38:   ldr     w2, [x19, x10]\n  3c:   mov     x0, #-205419695833089\n  40:   movk    x0, #709, lsl #16\n  44:   movk    x0, #5904\n  48:   mov     x1, #15\n  4c:   mov     x10, #-6992\n  50:   movk    x10, #29844, lsl #16\n  54:   movk    x10, #56832, lsl #32\n  58:   blr     x10\n  5c:   add     x7, x0, #0\n; counter++; \n  60:   mov     x10, #0\n  64:   ldr     w0, [x19, x10]\n  68:   add     x0, x0, #1\n  6c:   mov     x10, #0\n  70:   str     w0, [x19, x10]\n; return XDP_PASS;\n  74:   mov     x7, #2\n  78:   mov     sp, sp\n  7c:   ldp     x25, x26, [sp], #16\n  80:   ldp     x21, x22, [sp], #16\n  84:   ldp     x19, x20, [sp], #16\n  88:   ldp     x29, x30, [sp], #16\n  8c:   add     x0, x7, #0\n  90:   ret\n```", "```cpp\n$ bpftool net attach xdp id 540 dev eth0\n```", "```cpp\n$ bpftool net list \nxdp:\neth0(2) driver id 540\n\ntc:\n\nflow_dissector:\n```", "```cpp\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT\ngroup default qlen 1000\n    ...\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdp qdisc fq_codel state UP\nmode DEFAULT group default qlen 1000\n    ...\n    prog/xdp id 540 tag 9d0e949f89f1a82c jited \n    ...\n```", "```cpp\n<idle>-0       [003] d.s.. 655370.944105: bpf_trace_printk: Hello World 4531\n<idle>-0       [003] d.s.. 655370.944587: bpf_trace_printk: Hello World 4532\n<idle>-0       [003] d.s.. 655370.944896: bpf_trace_printk: Hello World 4533\n```", "```cpp\n$ bpftool map list\n165: array  name hello.bss  flags 0x400\n        key 4B  value 4B  max_entries 1  memlock 4096B\n        btf_id 254\n166: array  name hello.rodata  flags 0x80\n        key 4B  value 15B  max_entries 1  memlock 4096B\n        btf_id 254  frozen\n```", "```cpp\n$ bpftool map dump name hello.bss\n[{\n        \"value\": {\n            \".bss\": [{\n                    \"counter\": 11127\n                }\n            ]\n        }\n    }\n]\n```", "```cpp\n$ bpftool map dump name hello.bss\nkey: 00 00 00 00  value: 19 01 00 00\nFound 1 element\n```", "```cpp\n$ bpftool map dump name hello.rodata\n[{\n        \"value\": {\n            \".rodata\": [{\n                    \"hello.____fmt\": \"Hello World %d\"\n                }\n            ]\n        }\n    }\n]\n```", "```cpp\n$ bpftool map dump id 166\nkey: 00 00 00 00  value: 48 65 6c 6c 6f 20 57 6f  72 6c 64 20 25 64 00\nFound 1 element\n```", "```cpp\n$ bpftool net detach xdp dev eth0\n```", "```cpp\n$ bpftool net list \nxdp:\n\ntc:\n\nflow_dissector:\n```", "```cpp\n$ bpftool prog show name hello \n395: xdp  name hello  tag 9d0e949f89f1a82c  gpl\n        loaded_at 2022-12-19T18:20:32+0000  uid 0\n        xlated 48B  jited 108B  memlock 4096B  map_ids 4\n```", "```cpp\n$ rm /sys/fs/bpf/hello\n$ bpftool prog show name hello\n```", "```cpp\nstatic__attribute((noinline))intget_opcode(structbpf_raw_tracepoint_args\n*ctx){ `return``ctx``->``args``[``1``];` ``}``\n```", "```cppGiven the choice, the compiler would probably inline this very simple function that I\u2019m only going to call from one place. Since that would defeat the point of this example, I have added `__attribute((noinline))` to force the compiler\u2019s hand. In normal circumstances you should probably omit this and allow the compiler to optimize as it sees fit.\n\nThe eBPF function that calls this function looks like this:\n\n```", "```cpp``\n```", "```cppAfter compiling this to an eBPF object file, you can load it into the kernel and confirm that it is loaded with `bpftool`:\n\n```", "```cpp\n\nThe interesting part of this exercise is inspecting the eBPF bytecode to see the `get_opcode()` function:\n\n```", "```cpp\n\n[![1](assets/1.png)](#code_id_3_15)\n\nHere you can see the `hello()` eBPF program making a call to `get_opcode()`. The eBPF instruction at offset `0` is `0x85`, which from the instruction set documentation corresponds to \u201cFunction call.\u201d Instead of executing the next instruction, which would be at offset 1, execution will jump seven instructions ahead (`pc+7`), which means the instruction at offset `8`.\n\n[![2](assets/2.png)](#code_id_3_16)\n\nHere\u2019s the bytecode for `get_opcode()`, and as you might hope, the first instruction is at offset `8`.\n\nThe function call instruction necessitates putting the current state on the eBPF virtual machine\u2019s stack so that when the called function exits, execution can continue in the calling function. Since the stack size is limited to 512 bytes, BPF to BPF calls can\u2019t be very deeply nested.\n\n###### Note\n\nFor a lot more detail on tail calls and BPF to BPF calls, there\u2019s an excellent post by Jakub Sitnicki on Cloudflare\u2019s blog: [\u201cAssembly within! BPF tail calls on x86 and ARM\u201d](https://oreil.ly/6kOp3).```", "```cpp  ```", "```cpp\n    $ ip link set dev eth0 xdp obj hello.bpf.o sec xdp\n    $ ip link set dev eth0 xdp off\n    ```", "```cpp\n    $ bpftool prog show name hello \n    197: kprobe  name hello  tag ba73a317e9480a37  gpl\n            loaded_at 2022-08-22T08:46:22+0000  uid 0\n            xlated 296B  jited 328B  memlock 4096B  map_ids 65\n            btf_id 179\n            pids hello-map.py(2785)\n    ```", "```cpp\n    $ bpftool prog list \n    ...\n    120: raw_tracepoint  name hello  tag b6bfd0e76e7f9aac  gpl\n            loaded_at 2023-01-05T14:35:32+0000  uid 0\n            xlated 160B  jited 272B  memlock 4096B  map_ids 29\n            btf_id 124\n            pids hello-tail.py(3590)\n    121: raw_tracepoint  name ignore_opcode  tag a04f5eef06a7f555  gpl\n            loaded_at 2023-01-05T14:35:32+0000  uid 0\n            xlated 16B  jited 72B  memlock 4096B\n            btf_id 124\n            pids hello-tail.py(3590)\n    122: raw_tracepoint  name hello_exec  tag 931f578bd09da154  gpl\n            loaded_at 2023-01-05T14:35:32+0000  uid 0\n            xlated 112B  jited 168B  memlock 4096B\n            btf_id 124\n            pids hello-tail.py(3590)\n    123: raw_tracepoint  name hello_timer  tag 6c3378ebb7d3a617  gpl\n            loaded_at 2023-01-05T14:35:32+0000  uid 0\n            xlated 336B  jited 356B  memlock 4096B\n            btf_id 124\n            pids hello-tail.py(3590)\n    ```"]
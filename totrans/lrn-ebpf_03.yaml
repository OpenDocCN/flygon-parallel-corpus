- en: Chapter 3\. Anatomy of an eBPF Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you saw a simple eBPF “Hello World” program written
    using the BCC framework. In this chapter there’s an example version of a “Hello
    World” program written entirely in C so that you can see some of the details BCC
    took care of behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also shows you the stages an eBPF program goes through on its journey
    from source code to execution, as illustrated in [Figure 3-1](#c_left_parenthesisor_rustright_parenthe).
  prefs: []
  type: TYPE_NORMAL
- en: '![C (or Rust) source code is compiled into eBPF bytecode, which is either JIT-compiled
    or interpreted into native machine code instructions](assets/lebp_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. C (or Rust) source code is compiled into eBPF bytecode, which is
    either JIT-compiled or interpreted into native machine code instructions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An eBPF program is a set of eBPF bytecode instructions. It’s possible to write
    eBPF code directly in this bytecode, much as it’s possible to program in assembly
    language. Humans typically find a higher-level programming language easier to
    deal with, and at least at the time of this writing, I’d say the vast majority
    of eBPF code is written in C^([1](ch03.html#ch03fn1)) and then compiled to eBPF
    bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, this bytecode runs in an eBPF virtual machine within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: The eBPF Virtual Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The eBPF virtual machine, like any virtual machine, is a software implementation
    of a computer. It takes in a program in the form of eBPF bytecode instructions,
    and these have to be converted to native machine instructions that run on the
    CPU.
  prefs: []
  type: TYPE_NORMAL
- en: In early implementations of eBPF, the bytecode instructions were interpreted
    within the kernel—that is, every time an eBPF program runs, the kernel examines
    the instructions and converts them into machine code, which it then executes.
    Interpreting has since been largely replaced by JIT (just-in-time) compilation
    for performance reasons and to avoid the possibility of some Spectre-related vulnerabilities
    in the eBPF interpreter. *Compilation* means the conversion to native machine
    instructions happens just once, when the program is loaded into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF bytecode consists of a set of instructions, and those instructions act
    on (virtual) eBPF registers. The eBPF instruction set and register model were
    designed to map neatly to common CPU architectures so that the step of compiling
    or interpreting from bytecode to machine code is reasonably straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The eBPF virtual machine uses 10 general-purpose registers, numbered 0 to 9\.
    Additionally, Register 10 is used as a stack frame pointer (and can only be read,
    but not written). As a BPF program is executed, values get stored in these registers
    to keep track of state.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that these eBPF registers in the eBPF virtual machine
    are implemented in software. You can see them enumerated from `BPF_REG_0` to `BPF_REG_10`
    in the [*include/uapi/linux/bpf.h* header file](https://oreil.ly/_ZhU2) of the
    Linux kernel’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: The context argument to an eBPF program is loaded into Register 1 before its
    execution begins. The return value from the function is stored in Register 0.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling a function from eBPF code, the arguments to that function are
    placed in Register 1 through Register 5 (not all the registers are used if there
    are fewer than five arguments).
  prefs: []
  type: TYPE_NORMAL
- en: eBPF Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same [*linux/bpf.h* header file](https://oreil.ly/_ZhU2) defines a structure
    called `bpf_insn`, which represents a BPF instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_3_1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instruction has an opcode, which defines what operation the instruction
    is to perform: for example, adding a value to the contents of a register, or jumping
    to a different instruction in the program.^([2](ch03.html#ch03fn2)) The Iovisor
    project’s [“Unofficial eBPF spec”](https://oreil.ly/FXcPu) has a list of the valid
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_3_2)'
  prefs: []
  type: TYPE_NORMAL
- en: Different operations might involve up to two registers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_3_3)'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the operation, there might be an offset value and/or an “immediate”
    integer value.
  prefs: []
  type: TYPE_NORMAL
- en: This `bpf_insn` structure is 64 bits (or 8 bytes) long. However, sometimes an
    instruction might need to span more than 8 bytes. If you want to set a register
    to a 64-bit value, you can’t somehow squeeze all 64 bits of that value into the
    structure, along with the opcode and register information. In these cases, the
    instruction uses *wide instruction encoding* that is 16 bytes long in total. You’ll
    see an example of this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When loaded into the kernel, the bytecode of an eBPF program is represented
    by a series of these `bpf_insn` structures. The verifier performs several checks
    on this information to ensure that the code is safe to run. You’ll learn more
    about the verification process in [Chapter 6](ch06.html#the_ebpf_verifier).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the different opcodes fall into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a value into a register (either an immediate value or a value read from
    memory or from another register)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing a value from a register into memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing arithmetic operations such as adding a value to the contents of a
    register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping to a different instruction if a particular condition is satisfied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For an overview of eBPF architecture, I recommend the [BPF and XDP Reference
    Guide](https://oreil.ly/rvm1i) that’s included as part of the Cilium project’s
    documentation. If you’d like more details, the [kernel documentation](https://oreil.ly/_2XDT)
    describes the eBPF instructions and encoding quite clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use another simple example of an eBPF program and follow its journey from
    C source code, through eBPF bytecode, to machine code instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to build and run this code yourself, you’ll find the code along
    with instructions for setting up an environment to do so at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter3* directory.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter are written in C using a library called *libbpf*.
    You’ll learn more about this library in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  prefs: []
  type: TYPE_NORMAL
- en: eBPF “Hello World” for a Network Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples in the previous chapter emitted the trace “Hello World” triggered
    by a system call kprobe; this time I’m going to show an eBPF program that writes
    a line of trace when triggered by the arrival of a network packet.
  prefs: []
  type: TYPE_NORMAL
- en: Packet processing is a very common application of eBPF. I’ll cover this in a
    lot more detail in [Chapter 8](ch08.html#ebpf_for_networking), but for now it
    might be helpful to be aware of the basic idea of an eBPF program that is triggered
    for every packet of data that arrives on a network interface. The program can
    inspect and even modify the contents of that packet, and it makes a decision (or
    *verdict*) on what the kernel should do with that packet. The verdict could tell
    the kernel to carry on processing it as usual, drop it, or redirect it elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: In the simple example I’m showing here, the program doesn’t do anything with
    the network packet; it simply writes out the words *Hello World* and a counter
    to the trace pipe every time a network packet is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example program is in *chapter3/hello.bpf.c*. It’s a fairly common convention
    to put eBPF programs into filenames ending with *bpf.c* to distinguish them from
    user space C code that might live in the same source code directory. Here’s the
    entire program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_3_4)'
  prefs: []
  type: TYPE_NORMAL
- en: This example starts by including some header files. Just in case you’re not
    familiar with C coding, every program has to include the header files that define
    any structures or functions the program is going to use. You can guess from the
    names that these header files are related to BPF.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_3_5)'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how eBPF programs can use global variables. This counter
    will get incremented every time the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_3_6)'
  prefs: []
  type: TYPE_NORMAL
- en: The macro `SEC()` defines a section called `xdp` that you’ll be able to see
    in the compiled object file. I’ll come back to how the section name is used in
    [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), but for now you can simply
    think of it as defining that it’s an eXpress Data Path (XDP) type of eBPF program.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_3_7)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the actual eBPF program. In eBPF, the program name is the function
    name, so this program is called `hello`. It uses a helper function, `bpf_printk`,
    to write a string of text, increments the global variable `counter`, and then
    returns the value `XDP_PASS`. This is the verdict indicating to the kernel that
    it should process this network packet as normal.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_3_8)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally there is another `SEC()` macro that defines a license string, and this
    is a crucial requirement for eBPF programs. Some of the BPF helper functions in
    the kernel are defined as “GPL only.” If you want to use any of these functions,
    your BPF code has to be declared as having a GPL-compatible license. The verifier
    (which we will discuss in [Chapter 6](ch06.html#the_ebpf_verifier)) will object
    if the declared license is not compatible with the functions a program uses. Certain
    eBPF program types, including those that use BPF LSM (which you’ll learn about
    in [Chapter 9](ch09.html#ebpf_for_security)), are also [required to be GPL compatible](https://oreil.ly/ItahV).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might be wondering why the previous chapter used `bpf_trace_printk()` and
    this version uses `bpf_printk()`. The short answer is that BCC’s version is called
    `bpf_trace_printk()` and *libbpf*’s version is `bpf_printk()`, but both of those
    are wrappers around the kernel function `bpf_trace_printk()`. Andrii Nakryiko
    wrote a [good post](https://oreil.ly/9mNSY) on this on his blog.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an eBPF program that attaches to the XDP hook point on
    a network interface. You can think of the XDP event being triggered the moment
    a network packet arrives inbound on a (physical or virtual) network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some network cards support offloading XDP programs so that they can be executed
    on the network card itself. This means each network packet that arrives can be
    processed on the card, before it gets anywhere near the machine’s CPU. XDP programs
    can inspect and even modify each network packet, so this is very useful for doing
    things like DDoS protection, firewalling, or load balancing in a highly performant
    way. You’ll learn more about this in [Chapter 8](ch08.html#ebpf_for_networking).
  prefs: []
  type: TYPE_NORMAL
- en: You have seen the C source code, so the next step is to compile it into an object
    the kernel can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling an eBPF Object File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our eBPF source code needs to be compiled into the machine instructions that
    the eBPF virtual machine can understand: eBPF bytecode. The Clang compiler from
    the [LLVM project](https://llvm.org) will do this if you specify `-target bpf`.
    The following is an extract from a Makefile that will do the compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]This generates an object file called *hello.bpf.o* from the source code
    in *hello.bpf.c*. The `-g` flag is optional here,^([3](ch03.html#ch03fn3)) but
    it generates debug information so that you can see the source code alongside the
    bytecode when you inspect the object file. Let’s inspect this object file to better
    understand the eBPF code it contains.[PRE4]# Inspecting an eBPF Object File'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file utility is commonly used to determine the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This shows it’s an ELF (Executable and Linkable Format) file, containing eBPF
    code, for a 64-bit platform with LSB (least significant bit) architecture. It
    includes debug information if you used the `-g` flag at the compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect this object further with `llvm-objdump` to see the eBPF instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if you’re not familiar with disassembly, the output from this command
    isn’t too hard to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_3_9)'
  prefs: []
  type: TYPE_NORMAL
- en: The first line gives further confirmation that *hello.bpf.o* is a 64-bit ELF
    file with eBPF code (there’s no particular rhyme or reason why some tools use
    the term *BPF* and others *eBPF*; as I said earlier, these terms are now practically
    interchangeable).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_3_10)'
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the disassembly of the section labeled `xdp`, which matches the `SEC()`
    definition in the C source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_3_11)'
  prefs: []
  type: TYPE_NORMAL
- en: This section is a function called `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_3_12)'
  prefs: []
  type: TYPE_NORMAL
- en: There are five lines of eBPF bytecode instructions that correspond to the source
    line `bpf_printk("Hello World %d", counter");`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_3_13)'
  prefs: []
  type: TYPE_NORMAL
- en: Three lines of eBPF bytecode instructions increment the `counter` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_3_14)'
  prefs: []
  type: TYPE_NORMAL
- en: And another two lines of bytecode are generated from the source code `return
    XDP_PASS;`.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’re particularly keen to do so, there’s no real need to understand
    exactly how each line of bytecode relates to the source. The compiler takes care
    of generating the bytecode so that you don’t have to think about it! But let’s
    examine the output in a little more detail so you can get a feel for how this
    output relates to the eBPF instructions and registers you learned about earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To the left of each line of bytecode you can see the offset of that instruction
    from wherever `hello` is located in memory. As described earlier in this chapter,
    eBPF instructions are generally 8 bytes long, and since on a 64-bit platform each
    memory location can hold 8 bytes, the offset is usually incremented by one for
    each instruction. However, the first instruction in this program happens to be
    a wide instruction encoding that requires 16 bytes in order to set Register 6
    to a 64-bit value of `0`. That places the instruction in the second line of output
    at offset `2`. After that there is another 16-byte instruction, setting Register
    1 to a 64-bit value of `0`. And after that, the remaining instructions each fit
    in 8 bytes, so the offset increments by one in each line.
  prefs: []
  type: TYPE_NORMAL
- en: The first byte of each line is the opcode that tells the kernel what operation
    to perform, and on the right side of each instruction line is the human-readable
    interpretation of the instruction. At the time of this writing, the Iovisor project
    has the most complete [documentation](https://oreil.ly/nLbLp) of the eBPF opcodes,
    but the official [Linux kernel documentation](https://oreil.ly/yp-jW) is catching
    up, and the eBPF Foundation is working on [standard documentation](https://oreil.ly/7ZWzj)
    that is not tied to a specific operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s take the instruction at offset `5`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The opcode is `0xb7`, and the documentation tells us the pseudocode corresponding
    to this is `dst = imm`, which can be read as “Set the destination to the immediate
    value.” The destination is defined by the second byte, `0x02`, which means “Register
    2.” The “immediate” (or literal) value here is `0x0f`, which is 15 in decimal.
    So we can understand that this instruction tells the kernel to “set Register 2
    to value 15.” This corresponds to the output we see on the right side of the instruction:
    `r2 = 15`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The instruction at offset `10` is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This line also has opcode `0xb7`, and this time it’s setting the value of Register
    0 to `2`. When an eBPF program finishes running, Register 0 holds the return code,
    and `XDP_PASS` has the value `2`. This matches the source code, which always returns
    `XDP_PASS`.
  prefs: []
  type: TYPE_NORMAL
- en: You now know that *hello.bpf.o* contains an eBPF program in bytecode. The next
    step is to load it into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the Program into the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example we’ll use a utility called `bpftool`. You can also load programs
    programmatically, and you’ll see examples of that later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some Linux distributions provide a package that includes `bpftool`, or you can
    [compile it from source code](https://github.com/libbpf/bpftool). You can find
    more details about installing or building this tool on [Quentin Monnet’s blog](https://oreil.ly/Yqepv),
    as well as additional documentation and usage on the [Cilium site](https://oreil.ly/rnTIg).
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of using `bpftool` to load a program into the kernel.
    Note that you’ll likely need to be root (or use `sudo`) to get the BPF privileges
    that `bpftool` requires.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This loads the eBPF program from our compiled object file and “pins” it to
    the location */sys/fs/bpf/hello*.^([4](ch03.html#ch03fn4)) No output response
    to this command indicates success, but you can confirm that the program is in
    place using `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The eBPF program has been successfully loaded. Let’s use the `bpftool` utility
    to find out more about the program and its status within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Loaded Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bpftool` utility can list all the programs that are loaded into the kernel.
    If you try this yourself you’ll probably see several preexisting eBPF programs
    in this output, but for clarity I will just show the lines that relate to our
    “Hello World” example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The program has been assigned the ID 540\. This identity is a number assigned
    to each program as it’s loaded. Knowing the ID, you can ask `bpftool` to show
    more information about this program. This time, let’s get the output in prettified
    JSON format so that the field names are visible, as well as the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the field names, a lot of this is straightforward to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: The program’s ID is 540.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` field tells us this program can be attached to a network interface
    using the XDP event. Several other types of BPF programs can be attached to different
    sorts of events, and we’ll discuss this more in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the program is `hello`, which is the function name from the source
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tag` is another identifier for this program, which I’ll describe in more
    detail shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program is defined with a GPL-compatible license.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a timestamp showing when the program was loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User ID 0 (which is root) loaded the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are 96 bytes of translated eBPF bytecode in this program, which I’ll show
    you shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program has been JIT-compiled, and the compilation resulted in 148 bytes
    of machine code. I’ll cover this shortly too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bytes _memlock` field tells us this program reserves 4,096 bytes of memory
    that won’t be paged out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program refers to BPF maps with IDs 165 and 166\. This might seem surprising,
    since there is no obvious reference to maps in the source code. You’ll see later
    in this chapter how map semantics are used to handle global data in eBPF programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll learn about BTF in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    but for now just know that `btf_id` indicates there is a block of BTF information
    for this program. This information is included in the object file only if you
    compile with the `-g` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BPF Program Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tag` is a SHA (Secure Hashing Algorithm) sum of the program’s instructions,
    which can be used as another identifier for the program. The ID can vary every
    time you load or unload the program, but the tag will remain the same. The `bpftool`
    utility accepts references to a BPF program by ID, name, tag, or pinned path,
    so in the example here, all of the following would give the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpftool prog show id 540`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpftool prog show name hello`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpftool prog show tag d35b94b4c0c10efb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpftool prog show pinned /sys/fs/bpf/hello`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could have multiple programs with the same name, and even multiple instances
    of programs with the same tag, but the ID and pinned path will always be unique.
  prefs: []
  type: TYPE_NORMAL
- en: The Translated Bytecode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bytes_xlated` field tells us how many bytes of “translated” eBPF code there
    are. This is the eBPF bytecode after it has passed through the verifier (and possibly
    been modified by the kernel for reasons I’ll discuss later in this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `bpftool` to show this translated version of our “Hello World” code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This looks very similar to the disassembled code you saw earlier in the output
    from `llvm-objdump`. The offset addresses are the same, and the instructions look
    similar—for example, we can see the instruction at offset `5` is `r2=15`.
  prefs: []
  type: TYPE_NORMAL
- en: The JIT-Compiled Machine Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The translated bytecode is pretty low level, but it’s not quite machine code
    yet. eBPF uses a JIT compiler to convert eBPF bytecode to machine code that runs
    natively on the target CPU. The `bytes_jited` field shows that after this conversation
    the program is 108 bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For higher performance, eBPF programs are generally JIT-compiled. The alternative
    is to interpret the eBPF bytecode at runtime. The eBPF instruction set and registers
    were designed to map fairly closely to native machine instructions to make this
    interpretation straightforward and therefore relatively fast, but compiled programs
    will be faster, and most architectures now support JIT.^([5](ch03.html#ch03fn5))
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bpftool` utility can generate a dump of this JITed code in assembly language.
    Don’t worry if you’re not familiar with assembly language and this looks entirely
    incomprehensible! I have included it only to illustrate all the transformations
    the eBPF code goes through from source code to the executable machine instructions.
    Here is the command and its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some packaged distributions of `bpftool` don’t yet include support for dumping
    the JITed output, and if that’s the case, you’ll see “Error: No libbfd support.”
    You can build `bpftool` for yourself by following the instructions at [*https://github.com/libbpf/bpftool*](https://github.com/libbpf/bpftool).'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen that the “Hello World” program has been loaded into the kernel,
    but at this point it’s not yet associated with an event, so nothing will trigger
    it to run. It needs to be attached to an event.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to an Event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program type has to match the type of event it’s being attached to; you’ll
    learn more about this in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
    In this case it’s an XDP program, and you can use `bpftool` to attach the example
    eBPF program to the XDP event on a network interface, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of this writing, the `bpftool` utility doesn’t support the ability
    to attach all program types, but it has [recently been extended](https://oreil.ly/Tt99p)
    to auto-attach k(ret)probes, u(ret)probes, and tracepoints.
  prefs: []
  type: TYPE_NORMAL
- en: Here I have used the program’s ID of 540, but you can also use the name (provided
    it is unique) or tag to identify the program being attached. In this example,
    I have attached the program to the network interface `eth0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view all the network-attached eBPF programs using `bpftool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The program with ID 540 is attached to the XDP event on the `eth0` interface.
    This output also gives some clues about some other potential events in the network
    stack that you can attach eBPF programs to: `tc` and `flow_dissector`. More on
    this in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also inspect the network interfaces using `ip link`, and you’ll see
    output that looks something like this (some details have been removed for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example there are two interfaces: the loopback interface `lo`, which
    is used to send traffic to processes on this machine; and the `eth0` interface,
    which connects this machine to the outside world. This output also shows that
    `eth0` has a JIT-compiled eBPF program, with identity `540` and tag `9d0e949f89f1a82c`,
    attached to its XDP hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use `ip link` to attach and detach XDP programs to a network interface.
    I have included this as an exercise at the end of this chapter, and there are
    further examples in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the *hello* eBPF program should be producing trace output every
    time a network packet is received. You can check this out by running `cat /sys/kernel/debug/tracing/trace_pipe`.
    This should show a lot of output that looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you’re struggling to remember the location of the trace pipe, you can get
    the same output using the command `bpftool prog tracelog`.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the output you saw in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    this time there is no command or process ID associated with each of these events;
    instead, you see `<idle>-0` at the start of each line of trace. In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    each syscall event happened because a process executing a command in user space
    made a call to the syscall API. That process ID and command are part of the context
    in which the eBPF program was executed. But in the example here, the XDP event
    happens due to the arrival of a network packet. There is no user space process
    associated with this packet—at the point the *hello* eBPF program is triggered,
    the system hasn’t done anything with the packet other than receive it in memory,
    and it has no idea what the packet is or where it’s going.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the counter value that is traced out is being incremented by
    one each time, as expected. In the source code, `counter` is a global variable.
    Let’s see how that is implemented in eBPF using a map.
  prefs: []
  type: TYPE_NORMAL
- en: Global Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in the previous chapter, an eBPF map is a data structure that
    can be accessed from an eBPF program or from user space. Since the same map can
    be accessed repeatedly by different runs of the same program, it can be used to
    hold state from one execution to the next. Multiple programs can also access the
    same map. Because of these characteristics, map semantics can be repurposed for
    use as global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before support for [global variables was added in 2019](https://oreil.ly/IDftt),
    eBPF programmers had to write maps explicitly to perform the same task.
  prefs: []
  type: TYPE_NORMAL
- en: You saw earlier that `bpftool` shows this example program using two maps with
    the identities 165 and 166\. (You will probably see different identities if you
    try this for yourself, as the identities are assigned when the maps are created
    in the kernel.) Let’s explore what is in those maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bpftool` utility can show the maps loaded into the kernel. For clarity
    I will only show the entries 165 and 166 that relate to the example “Hello World”
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A bss^([6](ch03.html#ch03fn6)) section in an object file compiled from a C
    program typically holds global variables, and you can use `bpftool` to inspect
    its contents, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I could also have used `bpftool map dump id 165` to retrieve the same information.
    If I run either of these commands again, I’ll see that the counter has increased,
    as the program has been run every time a network packet is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll learn in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), `bpftool`
    is able to pretty-print the field names from a map (here, the variable name `counter`)
    only if BTF information is available, and that information is included only if
    you compile with the `-g` flag. If you omitted that flag during the compilation
    step, you’d see something that looks more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Without BTF information, `bpftool` has no way of knowing what variable name
    was used in the source code. You can infer that since there is only one item in
    this map, the hex value `19 01 00 00` must be the current value of `counter` (281
    in decimal, since the bytes are ordered starting with the least significant byte).
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen here that the eBPF program uses the semantics of a map to read and
    write to a global variable. Maps are also used to hold static data, as you can
    see by inspecting the other map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the other map is named `hello.rodata` gives a hint that this
    could be read-only data related to our *hello* program. You can dump the contents
    of this map to see that it holds the string used by the eBPF program for tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you didn’t compile the object with the `-g` flag, you’ll see output that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is one key–value pair in this map, and the value contains 12 bytes of
    data ending with a 0\. It probably won’t surprise you that those bytes are the
    ASCII representation of the string `"Hello World %d"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished inspecting this program and its maps, it’s time to clean
    it up. We’ll start by detaching it from the event that triggers it.
  prefs: []
  type: TYPE_NORMAL
- en: Detaching the Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can detach the program from the network interface like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no output if this command runs successfully, but you can confirm that
    the program is no longer attached by the lack of XDP entries in the output from
    `bpftool net list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the program is still loaded into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unloading the Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s no inverse of `bpftool prog load` (at least not at the time of this
    writing), but you can remove the program from the kernel by deleting the pinned
    pseudofile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is no output from this `bpftool` command because the program is no longer
    loaded in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: BPF to BPF Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you saw tail calls in action, and I mentioned that now
    there is also the ability to call functions from within an eBPF program. Let’s
    take a look at a simple example, which, like the tail call example, can be attached
    to the `sys_enter` tracepoint, except this time it will trace out the opcode for
    the syscall. You’ll find the code in *chapter3/hello-func.bpf.c*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustrative purposes I have written a very simple function that extracts
    the syscall opcode from the tracepoint arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'SEC("raw_tp") `int``hello``(``struct``bpf_raw_tracepoint_args``*``ctx``)``{`
    ``int``opcode``=``get_opcode``(``ctx``);` ``bpf_printk``(``"Syscall: %d"``,``opcode``);`
    ``return``0``;` ``}[PRE31]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello
  prefs: []
  type: TYPE_NORMAL
- en: $ bpftool prog list name hello
  prefs: []
  type: TYPE_NORMAL
- en: '893: raw_tracepoint  name hello  tag 3d9eb0c23d4ab186  gpl'
  prefs: []
  type: TYPE_NORMAL
- en: loaded_at 2023-01-05T18:57:31+0000  uid 0
  prefs: []
  type: TYPE_NORMAL
- en: xlated 80B  jited 208B  memlock 4096B  map_ids 204
  prefs: []
  type: TYPE_NORMAL
- en: btf_id 302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: $ bpftool prog dump xlated name hello
  prefs: []
  type: TYPE_NORMAL
- en: 'int hello(struct bpf_raw_tracepoint_args * ctx):'
  prefs: []
  type: TYPE_NORMAL
- en: ; int opcode = get_opcode(ctx);                            ![1](assets/1.png)
  prefs: []
  type: TYPE_NORMAL
- en: '0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode'
  prefs: []
  type: TYPE_NORMAL
- en: '; bpf_printk("Syscall: %d", opcode);'
  prefs: []
  type: TYPE_NORMAL
- en: '1: (18) r1 = map[id:193][0]+0'
  prefs: []
  type: TYPE_NORMAL
- en: '3: (b7) r2 = 12'
  prefs: []
  type: TYPE_NORMAL
- en: '4: (bf) r3 = r0'
  prefs: []
  type: TYPE_NORMAL
- en: '5: (85) call bpf_trace_printk#-73584'
  prefs: []
  type: TYPE_NORMAL
- en: ; return 0;
  prefs: []
  type: TYPE_NORMAL
- en: '6: (b7) r0 = 0'
  prefs: []
  type: TYPE_NORMAL
- en: '7: (95) exit'
  prefs: []
  type: TYPE_NORMAL
- en: 'int get_opcode(struct bpf_raw_tracepoint_args * ctx):      ![2](assets/2.png)'
  prefs: []
  type: TYPE_NORMAL
- en: ; return ctx->args[1];
  prefs: []
  type: TYPE_NORMAL
- en: '8: (79) r0 = *(u64 *)(r1 +8)'
  prefs: []
  type: TYPE_NORMAL
- en: ; return ctx->args[1];
  prefs: []
  type: TYPE_NORMAL
- en: '9: (95) exit'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34][PRE35]# Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you saw some example C source code transformed into eBPF bytecode
    and then compiled to machine code so that it’s ready to be executed in the kernel.
    You also learned how to use `bpftool` to inspect programs and maps loaded into
    the kernel, and to attach to XDP events.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you saw examples of different types of eBPF programs triggered
    by different kinds of events. An XDP event is triggered by the arrival of a packet
    of data on a network interface, whereas kprobe and tracepoint events are triggered
    by hitting some particular point in kernel code. I’ll discuss some other eBPF
    program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how maps are used to implement global variables for eBPF programs,
    and you saw BPF to BPF function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter goes into another level of detail as I show you what’s happening
    at the system call level when `bpftool`—or any other user space code—loads programs
    and attaches them to events.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few things to try if you want to explore BPF programs further:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try using `ip link` commands like the following to attach and detach the XDP
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run any of the BCC examples from [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    While the program is running, use a second terminal window to inspect the loaded
    program using `bpftool`. Here’s an example of what I saw by running the *hello-map.py*
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `bpftool prog dump` commands to see the bytecode and machine
    code versions of those programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *hello-tail.py* from the *chapter2* directory, and while it’s running,
    take a look at the programs it loaded. You’ll see that each tail call program
    is listed individually, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You could also use `bpftool prog dump xlated` to look at the bytecode instructions
    and compare them to what you saw in [“BPF to BPF Calls”](#bpf_to_bpf_calls).
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful with this one, as it may be best to simply think about why this
    happens rather than trying it!* If you return a `0` value from an XDP program,
    this corresponds to `XDP_ABORTED`, which tells the kernel to abort any further
    processing of this packet. This might seem a bit counterintuitive given that the
    `0` value usually indicates success in C, but that’s how it is. So, if you try
    modifying the program to return `0` and attach it to a virtual machine’s `eth0`
    interface, all network packets will get dropped. This will be somewhat unfortunate
    if you’re using SSH to attach to that machine, and you’ll likely have to reboot
    the machine to regain access!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could run the program within a container so that the XDP program is attached
    to a virtual Ethernet interface that only affects that container and not the whole
    virtual machine. There’s an example of doing this at [*https://github.com/lizrice/lb-from-scratch*](https://github.com/lizrice/lb-from-scratch).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#ch03fn1-marker)) Increasingly, eBPF programs are also being
    written in Rust, since the Rust compiler supports eBPF bytecode as a target.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#ch03fn2-marker)) There are a few instructions where the operation
    is “modified” by the value of other fields in the instruction. For example, there
    are a set of [atomic instructions](https://oreil.ly/oyTI7) introduced in kernel
    5.12 that include an arithmetic operation (`ADD`, `AND`, `OR`, `XOR`) that is
    specified in the `imm` field.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.html#ch03fn3-marker)) The `-g` flag is required to generate BTF information
    that you’ll need for CO-RE eBPF programs, which I’ll cover in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.html#ch03fn4-marker)) In general, this is optional—eBPF programs
    can be loaded into the kernel without being pinned to a file location—but it’s
    not optional for `bpftool`, which always has to pin the programs it loads. The
    reason for this is covered further in [“BPF Program and Map References”](ch04.html#bpf_program_and_map_references).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.html#ch03fn5-marker)) The kernel setting `CONFIG_BPF_JIT` needs to
    be enabled to take advantage of JIT compilation, and it can be enabled or disabled
    at runtime with the `net.core.bpf_jit_enable sysctl` setting. See [the docs](https://oreil.ly/4-xi6)
    for more information on JIT support on different chip architectures.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch03.html#ch03fn6-marker)) Here, *bss* stands for “block started by symbol.”``````
  prefs: []
  type: TYPE_NORMAL

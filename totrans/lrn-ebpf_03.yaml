- en: Chapter 3\. Anatomy of an eBPF Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。eBPF程序的解剖
- en: In the previous chapter you saw a simple eBPF “Hello World” program written
    using the BCC framework. In this chapter there’s an example version of a “Hello
    World” program written entirely in C so that you can see some of the details BCC
    took care of behind the scenes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了使用BCC框架编写的简单eBPF“Hello World”程序。在本章中，有一个完全用C编写的“Hello World”程序的示例版本，以便您可以看到BCC在幕后处理的一些细节。
- en: This chapter also shows you the stages an eBPF program goes through on its journey
    from source code to execution, as illustrated in [Figure 3-1](#c_left_parenthesisor_rustright_parenthe).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向您展示了eBPF程序从源代码到执行的过程，如[图3-1](#c_left_parenthesisor_rustright_parenthe)所示。
- en: '![C (or Rust) source code is compiled into eBPF bytecode, which is either JIT-compiled
    or interpreted into native machine code instructions](assets/lebp_0301.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![C（或Rust）源代码被编译成eBPF字节码，然后被即时编译或解释成本机机器代码指令](assets/lebp_0301.png)'
- en: Figure 3-1\. C (or Rust) source code is compiled into eBPF bytecode, which is
    either JIT-compiled or interpreted into native machine code instructions
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1。C（或Rust）源代码被编译成eBPF字节码，然后被即时编译或解释成本机机器代码指令
- en: An eBPF program is a set of eBPF bytecode instructions. It’s possible to write
    eBPF code directly in this bytecode, much as it’s possible to program in assembly
    language. Humans typically find a higher-level programming language easier to
    deal with, and at least at the time of this writing, I’d say the vast majority
    of eBPF code is written in C^([1](ch03.html#ch03fn1)) and then compiled to eBPF
    bytecode.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序是一组eBPF字节码指令。可以直接在这个字节码中编写eBPF代码，就像可以用汇编语言编程一样。人们通常发现使用高级编程语言更容易处理，至少在撰写本文时，我会说绝大多数eBPF代码是用C编写的^([1](ch03.html#ch03fn1))，然后编译成eBPF字节码。
- en: Conceptually, this bytecode runs in an eBPF virtual machine within the kernel.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这个字节码在内核中的eBPF虚拟机中运行。
- en: The eBPF Virtual Machine
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF虚拟机
- en: The eBPF virtual machine, like any virtual machine, is a software implementation
    of a computer. It takes in a program in the form of eBPF bytecode instructions,
    and these have to be converted to native machine instructions that run on the
    CPU.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF虚拟机，像任何虚拟机一样，是计算机的软件实现。它接收以eBPF字节码指令形式的程序，并且这些指令必须转换为在CPU上运行的本机机器指令。
- en: In early implementations of eBPF, the bytecode instructions were interpreted
    within the kernel—that is, every time an eBPF program runs, the kernel examines
    the instructions and converts them into machine code, which it then executes.
    Interpreting has since been largely replaced by JIT (just-in-time) compilation
    for performance reasons and to avoid the possibility of some Spectre-related vulnerabilities
    in the eBPF interpreter. *Compilation* means the conversion to native machine
    instructions happens just once, when the program is loaded into the kernel.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的eBPF实现中，字节码指令在内核中被解释执行 - 也就是说，每次eBPF程序运行时，内核都会检查指令并将其转换为机器代码，然后执行。出于性能原因和避免eBPF解释器中一些Spectre相关漏洞的可能性，解释已经在很大程度上被JIT（即时）编译所取代。*编译*意味着将转换为本机机器指令的过程只发生一次，当程序加载到内核时。
- en: eBPF bytecode consists of a set of instructions, and those instructions act
    on (virtual) eBPF registers. The eBPF instruction set and register model were
    designed to map neatly to common CPU architectures so that the step of compiling
    or interpreting from bytecode to machine code is reasonably straightforward.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF字节码由一组指令组成，这些指令作用于（虚拟）eBPF寄存器。eBPF指令集和寄存器模型的设计旨在与常见的CPU体系结构相匹配，以便从字节码到机器代码的编译或解释步骤相对简单。
- en: eBPF Registers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: eBPF寄存器
- en: The eBPF virtual machine uses 10 general-purpose registers, numbered 0 to 9\.
    Additionally, Register 10 is used as a stack frame pointer (and can only be read,
    but not written). As a BPF program is executed, values get stored in these registers
    to keep track of state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF虚拟机使用10个通用寄存器，编号从0到9。此外，寄存器10用作堆栈帧指针（只能读取，不能写入）。随着BPF程序的执行，值被存储在这些寄存器中以跟踪状态。
- en: It’s important to understand that these eBPF registers in the eBPF virtual machine
    are implemented in software. You can see them enumerated from `BPF_REG_0` to `BPF_REG_10`
    in the [*include/uapi/linux/bpf.h* header file](https://oreil.ly/_ZhU2) of the
    Linux kernel’s source code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，eBPF虚拟机中的这些eBPF寄存器是在软件中实现的。您可以在Linux内核源代码的[*include/uapi/linux/bpf.h*头文件](https://oreil.ly/_ZhU2)中从`BPF_REG_0`到`BPF_REG_10`中看到它们的枚举。
- en: The context argument to an eBPF program is loaded into Register 1 before its
    execution begins. The return value from the function is stored in Register 0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在eBPF程序的执行开始之前，上下文参数被加载到寄存器1中。函数的返回值存储在寄存器0中。
- en: Before calling a function from eBPF code, the arguments to that function are
    placed in Register 1 through Register 5 (not all the registers are used if there
    are fewer than five arguments).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在从eBPF代码调用函数之前，该函数的参数被放置在寄存器1到寄存器5中（如果参数少于五个，则不会使用所有寄存器）。
- en: eBPF Instructions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: eBPF指令
- en: 'The same [*linux/bpf.h* header file](https://oreil.ly/_ZhU2) defines a structure
    called `bpf_insn`, which represents a BPF instruction:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的[*linux/bpf.h*头文件](https://oreil.ly/_ZhU2)定义了一个称为`bpf_insn`的结构，它表示一个BPF指令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#code_id_3_1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_3_1)'
- en: 'Each instruction has an opcode, which defines what operation the instruction
    is to perform: for example, adding a value to the contents of a register, or jumping
    to a different instruction in the program.^([2](ch03.html#ch03fn2)) The Iovisor
    project’s [“Unofficial eBPF spec”](https://oreil.ly/FXcPu) has a list of the valid
    instructions.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令都有一个操作码，它定义了指令要执行的操作：例如，将一个值添加到寄存器的内容中，或者跳转到程序中的另一个指令。^([2](ch03.html#ch03fn2))
    Iovisor项目的[“非官方eBPF规范”](https://oreil.ly/FXcPu)中列出了有效指令的列表。
- en: '[![2](assets/2.png)](#code_id_3_2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_3_2)'
- en: Different operations might involve up to two registers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作可能涉及最多两个寄存器。
- en: '[![3](assets/3.png)](#code_id_3_3)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_3_3)'
- en: Depending on the operation, there might be an offset value and/or an “immediate”
    integer value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作的不同，可能会有一个偏移值和/或一个“立即”整数值。
- en: This `bpf_insn` structure is 64 bits (or 8 bytes) long. However, sometimes an
    instruction might need to span more than 8 bytes. If you want to set a register
    to a 64-bit value, you can’t somehow squeeze all 64 bits of that value into the
    structure, along with the opcode and register information. In these cases, the
    instruction uses *wide instruction encoding* that is 16 bytes long in total. You’ll
    see an example of this in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`bpf_insn`结构是64位（或8字节）长。然而，有时一条指令可能需要跨越超过8个字节。如果你想将一个寄存器设置为64位值，你不能以某种方式将该值的所有64位挤入结构中，同时还包括操作码和寄存器信息。在这些情况下，指令使用总长度为16字节的*宽指令编码*。您将在本章中看到一个例子。
- en: When loaded into the kernel, the bytecode of an eBPF program is represented
    by a series of these `bpf_insn` structures. The verifier performs several checks
    on this information to ensure that the code is safe to run. You’ll learn more
    about the verification process in [Chapter 6](ch06.html#the_ebpf_verifier).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载到内核中时，eBPF程序的字节码由一系列这些`bpf_insn`结构表示。验证器对这些信息执行几项检查，以确保代码可以安全运行。您将在[第6章](ch06.html#the_ebpf_verifier)中了解更多关于验证过程的信息。
- en: 'Most of the different opcodes fall into the following categories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不同的操作码属于以下类别：
- en: Loading a value into a register (either an immediate value or a value read from
    memory or from another register)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个值加载到寄存器中（可以是立即值，也可以是从内存或另一个寄存器中读取的值）
- en: Storing a value from a register into memory
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将寄存器中的值存储到内存中
- en: Performing arithmetic operations such as adding a value to the contents of a
    register
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行算术运算，例如将一个值添加到寄存器的内容中
- en: Jumping to a different instruction if a particular condition is satisfied
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果满足特定条件，跳转到不同的指令
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For an overview of eBPF architecture, I recommend the [BPF and XDP Reference
    Guide](https://oreil.ly/rvm1i) that’s included as part of the Cilium project’s
    documentation. If you’d like more details, the [kernel documentation](https://oreil.ly/_2XDT)
    describes the eBPF instructions and encoding quite clearly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于eBPF架构的概述，我推荐[BPF和XDP参考指南](https://oreil.ly/rvm1i)，这是Cilium项目文档的一部分。如果您想了解更多细节，[内核文档](https://oreil.ly/_2XDT)清楚地描述了eBPF指令和编码。
- en: Let’s use another simple example of an eBPF program and follow its journey from
    C source code, through eBPF bytecode, to machine code instructions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用另一个eBPF程序的简单示例，并跟随它从C源代码到eBPF字节码再到机器代码指令的过程。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to build and run this code yourself, you’ll find the code along
    with instructions for setting up an environment to do so at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter3* directory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己构建和运行这段代码，您将在[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)找到代码以及设置环境的说明。本章的代码在*chapter3*目录中。
- en: The examples in this chapter are written in C using a library called *libbpf*.
    You’ll learn more about this library in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例是使用一个名为*libbpf*的库以C语言编写的。您将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中了解更多关于这个库的信息。
- en: eBPF “Hello World” for a Network Interface
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF“Hello World”用于网络接口
- en: The examples in the previous chapter emitted the trace “Hello World” triggered
    by a system call kprobe; this time I’m going to show an eBPF program that writes
    a line of trace when triggered by the arrival of a network packet.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的示例通过系统调用kprobe触发了跟踪“Hello World”；这次我将展示一个eBPF程序，当网络数据包到达时触发时，它会写出一行跟踪。
- en: Packet processing is a very common application of eBPF. I’ll cover this in a
    lot more detail in [Chapter 8](ch08.html#ebpf_for_networking), but for now it
    might be helpful to be aware of the basic idea of an eBPF program that is triggered
    for every packet of data that arrives on a network interface. The program can
    inspect and even modify the contents of that packet, and it makes a decision (or
    *verdict*) on what the kernel should do with that packet. The verdict could tell
    the kernel to carry on processing it as usual, drop it, or redirect it elsewhere.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包处理是eBPF的一个非常常见的应用。我将在[第8章](ch08.html#ebpf_for_networking)中更详细地介绍这一点，但现在了解每个数据包到达网络接口时都会触发的eBPF程序的基本思想可能会有所帮助。该程序可以检查甚至修改数据包的内容，并对内核应该如何处理该数据包做出决定（或*verdict*）。裁决可以告诉内核继续像往常一样处理它，丢弃它，或者将其重定向到其他地方。
- en: In the simple example I’m showing here, the program doesn’t do anything with
    the network packet; it simply writes out the words *Hello World* and a counter
    to the trace pipe every time a network packet is received.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我这里展示的简单示例中，程序不对网络数据包进行任何操作；它只是在每次接收到网络数据包时向跟踪管道写出*Hello World*和一个计数器。
- en: 'The example program is in *chapter3/hello.bpf.c*. It’s a fairly common convention
    to put eBPF programs into filenames ending with *bpf.c* to distinguish them from
    user space C code that might live in the same source code directory. Here’s the
    entire program:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序在*chapter3/hello.bpf.c*中。将eBPF程序放入以*bpf.c*结尾的文件名中是一个相当常见的约定，以区分它们与可能存在于同一源代码目录中的用户空间C代码。这是整个程序：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#code_id_3_4)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_3_4)'
- en: This example starts by including some header files. Just in case you’re not
    familiar with C coding, every program has to include the header files that define
    any structures or functions the program is going to use. You can guess from the
    names that these header files are related to BPF.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先包括一些头文件。以防您不熟悉C编码，每个程序都必须包括定义程序将使用的任何结构或函数的头文件。您可以从这些头文件的名称猜出，这些头文件与BPF相关。
- en: '[![2](assets/2.png)](#code_id_3_5)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_3_5)'
- en: This example shows how eBPF programs can use global variables. This counter
    will get incremented every time the program runs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了eBPF程序如何使用全局变量。每次程序运行时，这个计数器都会增加。
- en: '[![3](assets/3.png)](#code_id_3_6)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_3_6)'
- en: The macro `SEC()` defines a section called `xdp` that you’ll be able to see
    in the compiled object file. I’ll come back to how the section name is used in
    [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), but for now you can simply
    think of it as defining that it’s an eXpress Data Path (XDP) type of eBPF program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 宏`SEC()`定义了一个名为`xdp`的部分，您将能够在编译后的对象文件中看到它。我将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中回到部分名称的用法，但现在您可以简单地将其视为定义为eXpress
    Data Path (XDP)类型的eBPF程序。
- en: '[![4](assets/4.png)](#code_id_3_7)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_3_7)'
- en: Here you can see the actual eBPF program. In eBPF, the program name is the function
    name, so this program is called `hello`. It uses a helper function, `bpf_printk`,
    to write a string of text, increments the global variable `counter`, and then
    returns the value `XDP_PASS`. This is the verdict indicating to the kernel that
    it should process this network packet as normal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到实际的eBPF程序。在eBPF中，程序名称是函数名称，因此此程序称为`hello`。它使用一个辅助函数`bpf_printk`来写入一串文本，增加全局变量`counter`，然后返回值`XDP_PASS`。这是向内核指示应像通常一样处理此网络数据包的判决。
- en: '[![5](assets/5.png)](#code_id_3_8)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_3_8)'
- en: Finally there is another `SEC()` macro that defines a license string, and this
    is a crucial requirement for eBPF programs. Some of the BPF helper functions in
    the kernel are defined as “GPL only.” If you want to use any of these functions,
    your BPF code has to be declared as having a GPL-compatible license. The verifier
    (which we will discuss in [Chapter 6](ch06.html#the_ebpf_verifier)) will object
    if the declared license is not compatible with the functions a program uses. Certain
    eBPF program types, including those that use BPF LSM (which you’ll learn about
    in [Chapter 9](ch09.html#ebpf_for_security)), are also [required to be GPL compatible](https://oreil.ly/ItahV).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有另一个`SEC()`宏，它定义了一个许可字符串，这是eBPF程序的一个关键要求。内核中的一些BPF辅助函数被定义为“仅限GPL”。如果您想使用这些函数中的任何一个，您的BPF代码必须声明为具有GPL兼容许可。验证器（我们将在[第6章](ch06.html#the_ebpf_verifier)中讨论）将在声明的许可与程序使用的函数不兼容时提出异议。某些eBPF程序类型，包括使用BPF
    LSM的程序（您将在[第9章](ch09.html#ebpf_for_security)中了解），也需要[兼容GPL](https://oreil.ly/ItahV)。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why the previous chapter used `bpf_trace_printk()` and
    this version uses `bpf_printk()`. The short answer is that BCC’s version is called
    `bpf_trace_printk()` and *libbpf*’s version is `bpf_printk()`, but both of those
    are wrappers around the kernel function `bpf_trace_printk()`. Andrii Nakryiko
    wrote a [good post](https://oreil.ly/9mNSY) on this on his blog.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会想为什么上一章使用了`bpf_trace_printk()`，而这个版本使用了`bpf_printk()`。简短的答案是BCC的版本称为`bpf_trace_printk()`，而*libbpf*的版本称为`bpf_printk()`，但这两者都是内核函数`bpf_trace_printk()`的包装器。Andrii
    Nakryiko在他的博客上写了一篇[很好的文章](https://oreil.ly/9mNSY)。
- en: This is an example of an eBPF program that attaches to the XDP hook point on
    a network interface. You can think of the XDP event being triggered the moment
    a network packet arrives inbound on a (physical or virtual) network interface.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个附加到网络接口上的XDP挂钩点的eBPF程序示例。您可以将XDP事件视为在（物理或虚拟）网络接口上入站到达网络数据包的瞬间触发。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some network cards support offloading XDP programs so that they can be executed
    on the network card itself. This means each network packet that arrives can be
    processed on the card, before it gets anywhere near the machine’s CPU. XDP programs
    can inspect and even modify each network packet, so this is very useful for doing
    things like DDoS protection, firewalling, or load balancing in a highly performant
    way. You’ll learn more about this in [Chapter 8](ch08.html#ebpf_for_networking).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络卡支持卸载XDP程序，以便它们可以在网络卡上执行。这意味着每个到达的网络数据包都可以在接近机器CPU之前在卡上处理。XDP程序可以检查甚至修改每个网络数据包，因此这对于执行诸如DDoS保护、防火墙或负载平衡等操作非常有用。您将在[第8章](ch08.html#ebpf_for_networking)中了解更多信息。
- en: You have seen the C source code, so the next step is to compile it into an object
    the kernel can understand.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了C源代码，所以下一步是将其编译成内核可以理解的对象。
- en: Compiling an eBPF Object File
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译eBPF对象文件
- en: 'Our eBPF source code needs to be compiled into the machine instructions that
    the eBPF virtual machine can understand: eBPF bytecode. The Clang compiler from
    the [LLVM project](https://llvm.org) will do this if you specify `-target bpf`.
    The following is an extract from a Makefile that will do the compilation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的eBPF源代码需要编译成eBPF虚拟机可以理解的机器指令：eBPF字节码。如果您指定了`-target bpf`，则来自[LLVM项目](https://llvm.org)的Clang编译器将执行此操作。以下是一个Makefile的摘录，它将执行编译：
- en: '[PRE2]`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]`'
- en: '[PRE3]This generates an object file called *hello.bpf.o* from the source code
    in *hello.bpf.c*. The `-g` flag is optional here,^([3](ch03.html#ch03fn3)) but
    it generates debug information so that you can see the source code alongside the
    bytecode when you inspect the object file. Let’s inspect this object file to better
    understand the eBPF code it contains.[PRE4]# Inspecting an eBPF Object File'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]这将从*hello.bpf.c*中的源代码生成一个名为*hello.bpf.o*的对象文件。这里的`-g`标志是可选的，但它会生成调试信息，这样当您检查对象文件时，您可以看到源代码和字节码。让我们检查一下这个对象文件，以更好地理解它包含的eBPF代码。[PRE4]#检查eBPF对象文件'
- en: 'The file utility is commonly used to determine the contents of a file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文件实用程序通常用于确定文件的内容：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shows it’s an ELF (Executable and Linkable Format) file, containing eBPF
    code, for a 64-bit platform with LSB (least significant bit) architecture. It
    includes debug information if you used the `-g` flag at the compilation step.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示它是一个ELF（可执行和可链接格式）文件，包含64位平台的eBPF代码，具有LSB（最低有效位）架构。如果您在编译步骤中使用了`-g`标志，则包括调试信息。
- en: 'You can inspect this object further with `llvm-objdump` to see the eBPF instructions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`llvm-objdump`进一步检查此对象，以查看eBPF指令：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Even if you’re not familiar with disassembly, the output from this command
    isn’t too hard to understand:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不熟悉反汇编，此命令的输出也不难理解：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#code_id_3_9)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_3_9)'
- en: The first line gives further confirmation that *hello.bpf.o* is a 64-bit ELF
    file with eBPF code (there’s no particular rhyme or reason why some tools use
    the term *BPF* and others *eBPF*; as I said earlier, these terms are now practically
    interchangeable).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行进一步确认*hello.bpf.o*是一个包含eBPF代码的64位ELF文件（一些工具使用术语*BPF*，而另一些使用*eBPF*并没有特定的原因；正如我之前所说，这些术语现在几乎可以互换使用）。
- en: '[![2](assets/2.png)](#code_id_3_10)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_3_10)'
- en: Next comes the disassembly of the section labeled `xdp`, which matches the `SEC()`
    definition in the C source code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是标记为`xdp`的部分的反汇编，与C源代码中的`SEC()`定义相匹配。
- en: '[![3](assets/3.png)](#code_id_3_11)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_3_11)'
- en: This section is a function called `hello`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是一个名为`hello`的函数。
- en: '[![4](assets/4.png)](#code_id_3_12)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_3_12)'
- en: There are five lines of eBPF bytecode instructions that correspond to the source
    line `bpf_printk("Hello World %d", counter");`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有五行eBPF字节码指令对应于源代码行`bpf_printk("Hello World %d", counter");`。
- en: '[![5](assets/5.png)](#code_id_3_13)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_3_13)'
- en: Three lines of eBPF bytecode instructions increment the `counter` variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 三行eBPF字节码指令增加了`counter`变量。
- en: '[![6](assets/6.png)](#code_id_3_14)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_3_14)'
- en: And another two lines of bytecode are generated from the source code `return
    XDP_PASS;`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两行字节码是从源代码`return XDP_PASS;`生成的。
- en: Unless you’re particularly keen to do so, there’s no real need to understand
    exactly how each line of bytecode relates to the source. The compiler takes care
    of generating the bytecode so that you don’t have to think about it! But let’s
    examine the output in a little more detail so you can get a feel for how this
    output relates to the eBPF instructions and registers you learned about earlier
    in this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你特别想这样做，否则没有真正的必要去理解每一行字节码与源代码的关系。编译器负责生成字节码，这样你就不必考虑它！但让我们更详细地检查输出，这样你就可以感受到这个输出与本章前面学到的eBPF指令和寄存器的关系。
- en: To the left of each line of bytecode you can see the offset of that instruction
    from wherever `hello` is located in memory. As described earlier in this chapter,
    eBPF instructions are generally 8 bytes long, and since on a 64-bit platform each
    memory location can hold 8 bytes, the offset is usually incremented by one for
    each instruction. However, the first instruction in this program happens to be
    a wide instruction encoding that requires 16 bytes in order to set Register 6
    to a 64-bit value of `0`. That places the instruction in the second line of output
    at offset `2`. After that there is another 16-byte instruction, setting Register
    1 to a 64-bit value of `0`. And after that, the remaining instructions each fit
    in 8 bytes, so the offset increments by one in each line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在每行字节码的左侧，你可以看到该指令与内存中`hello`的偏移量。正如本章前面描述的那样，eBPF指令通常是8个字节长，在64位平台上，每个内存位置可以容纳8个字节，因此每条指令的偏移量通常会递增1。然而，这个程序中的第一条指令恰好是一个宽指令编码，需要16个字节来将寄存器6设置为64位值`0`。这将该指令放在输出的第二行，偏移量为`2`。之后是另一条16字节的指令，将寄存器1设置为64位值`0`。之后，剩下的指令每条都占8个字节，因此偏移量在每行递增1。
- en: The first byte of each line is the opcode that tells the kernel what operation
    to perform, and on the right side of each instruction line is the human-readable
    interpretation of the instruction. At the time of this writing, the Iovisor project
    has the most complete [documentation](https://oreil.ly/nLbLp) of the eBPF opcodes,
    but the official [Linux kernel documentation](https://oreil.ly/yp-jW) is catching
    up, and the eBPF Foundation is working on [standard documentation](https://oreil.ly/7ZWzj)
    that is not tied to a specific operating system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的第一个字节是操作码，告诉内核要执行什么操作，而指令行的右侧是指令的人类可读解释。在撰写本文时，Iovisor项目拥有最完整的[eBPF操作码文档](https://oreil.ly/nLbLp)，但官方的[Linux内核文档](https://oreil.ly/yp-jW)正在迎头赶上，而eBPF基金会正在制定[标准文档](https://oreil.ly/7ZWzj)，这些文档不与特定操作系统绑定。
- en: 'For example, let’s take the instruction at offset `5`, which looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看偏移量为`5`的指令，看起来是这样的：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The opcode is `0xb7`, and the documentation tells us the pseudocode corresponding
    to this is `dst = imm`, which can be read as “Set the destination to the immediate
    value.” The destination is defined by the second byte, `0x02`, which means “Register
    2.” The “immediate” (or literal) value here is `0x0f`, which is 15 in decimal.
    So we can understand that this instruction tells the kernel to “set Register 2
    to value 15.” This corresponds to the output we see on the right side of the instruction:
    `r2 = 15`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码是`0xb7`，文档告诉我们对应的伪代码是`dst = imm`，可以理解为“将目的地设置为立即值”。目的地由第二个字节定义，为`0x02`，意思是“寄存器2”。这里的“立即”（或文字）值是`0x0f`，在十进制中是15。所以我们可以理解这个指令告诉内核“将寄存器2设置为值15”。这对应于我们在指令右侧看到的输出：`r2
    = 15`。
- en: 'The instruction at offset `10` is similar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为`10`的指令类似：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line also has opcode `0xb7`, and this time it’s setting the value of Register
    0 to `2`. When an eBPF program finishes running, Register 0 holds the return code,
    and `XDP_PASS` has the value `2`. This matches the source code, which always returns
    `XDP_PASS`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这行指令的操作码也是`0xb7`，这次是将寄存器0的值设置为`2`。当一个eBPF程序运行结束时，寄存器0保存返回码，而`XDP_PASS`的值为`2`。这与源代码相匹配，源代码总是返回`XDP_PASS`。
- en: You now know that *hello.bpf.o* contains an eBPF program in bytecode. The next
    step is to load it into the kernel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道*hello.bpf.o*包含了一个字节码的eBPF程序。下一步是将它加载到内核中。
- en: Loading the Program into the Kernel
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将程序加载到内核中
- en: For this example we’ll use a utility called `bpftool`. You can also load programs
    programmatically, and you’ll see examples of that later in the book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个叫做`bpftool`的实用工具。你也可以以编程方式加载程序，你将在本书的后面看到相关示例。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some Linux distributions provide a package that includes `bpftool`, or you can
    [compile it from source code](https://github.com/libbpf/bpftool). You can find
    more details about installing or building this tool on [Quentin Monnet’s blog](https://oreil.ly/Yqepv),
    as well as additional documentation and usage on the [Cilium site](https://oreil.ly/rnTIg).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Linux发行版提供了包含`bpftool`的软件包，或者您可以[从源代码编译](https://github.com/libbpf/bpftool)。您可以在[Quentin
    Monnet的博客](https://oreil.ly/Yqepv)上找到有关安装或构建此工具的更多详细信息，以及[Cilium网站](https://oreil.ly/rnTIg)上的其他文档和用法。
- en: The following is an example of using `bpftool` to load a program into the kernel.
    Note that you’ll likely need to be root (or use `sudo`) to get the BPF privileges
    that `bpftool` requires.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`bpftool`将程序加载到内核的示例。请注意，您可能需要root权限（或使用`sudo`）来获取`bpftool`所需的BPF权限。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This loads the eBPF program from our compiled object file and “pins” it to
    the location */sys/fs/bpf/hello*.^([4](ch03.html#ch03fn4)) No output response
    to this command indicates success, but you can confirm that the program is in
    place using `ls`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从我们编译的对象文件中加载eBPF程序，并将其“固定”到位置*/sys/fs/bpf/hello*。^([4](ch03.html#ch03fn4))此命令没有输出响应表示成功，但您可以使用`ls`确认程序已经就位：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The eBPF program has been successfully loaded. Let’s use the `bpftool` utility
    to find out more about the program and its status within the kernel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序已成功加载。让我们使用`bpftool`实用程序来了解更多关于程序及其在内核中的状态的信息。
- en: Inspecting the Loaded Program
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查已加载的程序
- en: 'The `bpftool` utility can list all the programs that are loaded into the kernel.
    If you try this yourself you’ll probably see several preexisting eBPF programs
    in this output, but for clarity I will just show the lines that relate to our
    “Hello World” example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool`实用程序可以列出加载到内核中的所有程序。如果您自己尝试这样做，您可能会在输出中看到几个预先存在的eBPF程序，但为了清晰起见，我只会显示与我们的“Hello
    World”示例相关的行：'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program has been assigned the ID 540\. This identity is a number assigned
    to each program as it’s loaded. Knowing the ID, you can ask `bpftool` to show
    more information about this program. This time, let’s get the output in prettified
    JSON format so that the field names are visible, as well as the values:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序已被分配ID 540。这个标识是在加载每个程序时分配的一个数字。知道了ID，您可以要求`bpftool`显示有关该程序的更多信息。这一次，让我们以美化的JSON格式获取输出，以便字段名称和值都是可见的：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Given the field names, a lot of this is straightforward to understand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于字段名称，这些内容大部分都很容易理解：
- en: The program’s ID is 540.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的ID是540。
- en: The `type` field tells us this program can be attached to a network interface
    using the XDP event. Several other types of BPF programs can be attached to different
    sorts of events, and we’ll discuss this more in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`字段告诉我们，该程序可以使用XDP事件附加到网络接口。还有其他几种类型的BPF程序可以附加到不同类型的事件上，我们将在[第7章](ch07.html#ebpf_program_and_attachment_types)中更详细地讨论这一点。'
- en: The name of the program is `hello`, which is the function name from the source
    code.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的名称是`hello`，这是源代码中的函数名。
- en: The `tag` is another identifier for this program, which I’ll describe in more
    detail shortly.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag`是这个程序的另一个标识符，我将在稍后更详细地描述。'
- en: The program is defined with a GPL-compatible license.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序是使用GPL兼容许可证定义的。
- en: There’s a timestamp showing when the program was loaded.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个时间戳显示程序加载的时间。
- en: User ID 0 (which is root) loaded the program.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户ID 0（即root）加载了该程序。
- en: There are 96 bytes of translated eBPF bytecode in this program, which I’ll show
    you shortly.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序中有96字节的已翻译的eBPF字节码，我马上会向您展示。
- en: This program has been JIT-compiled, and the compilation resulted in 148 bytes
    of machine code. I’ll cover this shortly too.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序已经进行了JIT编译，编译结果是148字节的机器代码。我稍后也会介绍这个。
- en: The `bytes _memlock` field tells us this program reserves 4,096 bytes of memory
    that won’t be paged out.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes _memlock`字段告诉我们，该程序保留了4096字节的内存，不会被分页出去。'
- en: This program refers to BPF maps with IDs 165 and 166\. This might seem surprising,
    since there is no obvious reference to maps in the source code. You’ll see later
    in this chapter how map semantics are used to handle global data in eBPF programs.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序引用了ID为165和166的BPF映射。这可能令人惊讶，因为源代码中并没有明显的映射引用。稍后在本章中，您将看到如何使用映射语义来处理eBPF程序中的全局数据。
- en: You’ll learn about BTF in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    but for now just know that `btf_id` indicates there is a block of BTF information
    for this program. This information is included in the object file only if you
    compile with the `-g` flag.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中了解BTF，但现在只需知道`btf_id`表示该程序有一块BTF信息。只有在使用`-g`标志进行编译时，此信息才包含在对象文件中。
- en: The BPF Program Tag
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPF程序标签
- en: 'The `tag` is a SHA (Secure Hashing Algorithm) sum of the program’s instructions,
    which can be used as another identifier for the program. The ID can vary every
    time you load or unload the program, but the tag will remain the same. The `bpftool`
    utility accepts references to a BPF program by ID, name, tag, or pinned path,
    so in the example here, all of the following would give the same output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`是程序指令的SHA（安全哈希算法）总和，可以用作程序的另一个标识符。ID每次加载或卸载程序时都可能会有所变化，但标签将保持不变。`bpftool`实用程序接受对BPF程序的引用，可以通过ID、名称、标签或固定路径进行引用，因此在这个例子中，以下所有内容都将给出相同的输出：'
- en: '`bpftool prog show id 540`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpftool prog show id 540`'
- en: '`bpftool prog show name hello`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpftool prog show name hello`'
- en: '`bpftool prog show tag d35b94b4c0c10efb`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpftool prog show tag d35b94b4c0c10efb`'
- en: '`bpftool prog show pinned /sys/fs/bpf/hello`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpftool prog show pinned /sys/fs/bpf/hello`'
- en: You could have multiple programs with the same name, and even multiple instances
    of programs with the same tag, but the ID and pinned path will always be unique.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以拥有多个具有相同名称的程序，甚至可以拥有具有相同标签的程序的多个实例，但ID和固定路径将始终是唯一的。
- en: The Translated Bytecode
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已翻译的字节码
- en: The `bytes_xlated` field tells us how many bytes of “translated” eBPF code there
    are. This is the eBPF bytecode after it has passed through the verifier (and possibly
    been modified by the kernel for reasons I’ll discuss later in this book).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes_xlated`字段告诉我们“翻译”eBPF代码有多少字节。这是通过验证器后的eBPF字节码（可能已经被内核修改，我将在本书后面讨论原因）。'
- en: 'Let’s use `bpftool` to show this translated version of our “Hello World” code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`bpftool`来显示我们的“Hello World”代码的翻译版本：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks very similar to the disassembled code you saw earlier in the output
    from `llvm-objdump`. The offset addresses are the same, and the instructions look
    similar—for example, we can see the instruction at offset `5` is `r2=15`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与您之前从`llvm-objdump`的输出中看到的反汇编代码非常相似。偏移地址相同，指令看起来相似——例如，我们可以看到偏移`5`处的指令是`r2=15`。
- en: The JIT-Compiled Machine Code
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JIT编译的机器码
- en: The translated bytecode is pretty low level, but it’s not quite machine code
    yet. eBPF uses a JIT compiler to convert eBPF bytecode to machine code that runs
    natively on the target CPU. The `bytes_jited` field shows that after this conversation
    the program is 108 bytes long.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的字节码非常低级，但还不是机器码。eBPF使用JIT编译器将eBPF字节码转换为在目标CPU上本地运行的机器码。`bytes_jited`字段显示，在此转换后，程序长度为108字节。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For higher performance, eBPF programs are generally JIT-compiled. The alternative
    is to interpret the eBPF bytecode at runtime. The eBPF instruction set and registers
    were designed to map fairly closely to native machine instructions to make this
    interpretation straightforward and therefore relatively fast, but compiled programs
    will be faster, and most architectures now support JIT.^([5](ch03.html#ch03fn5))
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更高的性能，eBPF程序通常是JIT编译的。另一种选择是在运行时解释eBPF字节码。eBPF指令集和寄存器设计得相当接近本机机器指令，使得这种解释相对简单且相对快速，但编译的程序将更快，大多数架构现在都支持JIT。
- en: 'The `bpftool` utility can generate a dump of this JITed code in assembly language.
    Don’t worry if you’re not familiar with assembly language and this looks entirely
    incomprehensible! I have included it only to illustrate all the transformations
    the eBPF code goes through from source code to the executable machine instructions.
    Here is the command and its output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool`实用程序可以生成汇编语言中的JIT代码转储。如果您对汇编语言不熟悉，这看起来可能完全难以理解！我只是为了说明eBPF代码从源代码到可执行机器指令经历的所有转换。以下是命令及其输出：'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some packaged distributions of `bpftool` don’t yet include support for dumping
    the JITed output, and if that’s the case, you’ll see “Error: No libbfd support.”
    You can build `bpftool` for yourself by following the instructions at [*https://github.com/libbpf/bpftool*](https://github.com/libbpf/bpftool).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些打包的`bpftool`发行版尚未包含支持转储JIT输出的功能，如果是这种情况，您将看到“错误：没有libbfd支持”。您可以按照[*https://github.com/libbpf/bpftool*](https://github.com/libbpf/bpftool)上的说明自行构建`bpftool`。
- en: You’ve seen that the “Hello World” program has been loaded into the kernel,
    but at this point it’s not yet associated with an event, so nothing will trigger
    it to run. It needs to be attached to an event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到“Hello World”程序已加载到内核中，但此时它尚未与事件关联，因此不会触发运行。它需要附加到一个事件上。
- en: Attaching to an Event
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加到事件
- en: 'The program type has to match the type of event it’s being attached to; you’ll
    learn more about this in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
    In this case it’s an XDP program, and you can use `bpftool` to attach the example
    eBPF program to the XDP event on a network interface, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序类型必须与其附加的事件类型匹配；您将在[第7章](ch07.html#ebpf_program_and_attachment_types)中了解更多信息。在本例中，这是一个XDP程序，您可以使用`bpftool`将示例eBPF程序附加到网络接口上的XDP事件，如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, the `bpftool` utility doesn’t support the ability
    to attach all program types, but it has [recently been extended](https://oreil.ly/Tt99p)
    to auto-attach k(ret)probes, u(ret)probes, and tracepoints.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`bpftool`实用程序不支持附加所有程序类型的能力，但它已经[最近扩展](https://oreil.ly/Tt99p)以自动附加k(ret)probes、u(ret)probes和tracepoints。
- en: Here I have used the program’s ID of 540, but you can also use the name (provided
    it is unique) or tag to identify the program being attached. In this example,
    I have attached the program to the network interface `eth0`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了ID为540的程序，但您也可以使用名称（前提是唯一的）或标签来标识要附加的程序。在此示例中，我已将程序附加到网络接口`eth0`。
- en: 'You can view all the network-attached eBPF programs using `bpftool`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`bpftool`查看所有网络连接的eBPF程序：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The program with ID 540 is attached to the XDP event on the `eth0` interface.
    This output also gives some clues about some other potential events in the network
    stack that you can attach eBPF programs to: `tc` and `flow_dissector`. More on
    this in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ID为540的程序附加到`eth0`接口的XDP事件上。此输出还提供了有关网络堆栈中其他一些潜在事件的一些线索，您可以将eBPF程序附加到`tc`和`flow_dissector`上。在[第7章](ch07.html#ebpf_program_and_attachment_types)中会详细介绍。
- en: 'You can also inspect the network interfaces using `ip link`, and you’ll see
    output that looks something like this (some details have been removed for clarity):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`ip link`检查网络接口，您将看到类似以下内容的输出（为了清晰起见，已删除了一些细节）：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example there are two interfaces: the loopback interface `lo`, which
    is used to send traffic to processes on this machine; and the `eth0` interface,
    which connects this machine to the outside world. This output also shows that
    `eth0` has a JIT-compiled eBPF program, with identity `540` and tag `9d0e949f89f1a82c`,
    attached to its XDP hook.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中有两个接口：用于将流量发送到此计算机上的进程的环回接口`lo`；以及连接此计算机与外部世界的`eth0`接口。此输出还显示`eth0`有一个JIT编译的eBPF程序，其标识为`540`，标签为`9d0e949f89f1a82c`，附加到其XDP挂钩上。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use `ip link` to attach and detach XDP programs to a network interface.
    I have included this as an exercise at the end of this chapter, and there are
    further examples in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`ip link`将XDP程序附加到网络接口并将其分离。我已经在本章末尾包括了这个作为一个练习，并且在[第7章](ch07.html#ebpf_program_and_attachment_types)中还有更多的例子。
- en: 'At this point, the *hello* eBPF program should be producing trace output every
    time a network packet is received. You can check this out by running `cat /sys/kernel/debug/tracing/trace_pipe`.
    This should show a lot of output that looks similar to this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，*hello* eBPF程序应该在每次接收到网络数据包时产生跟踪输出。您可以通过运行`cat /sys/kernel/debug/tracing/trace_pipe`来检查这一点。这应该显示很多类似于这样的输出：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re struggling to remember the location of the trace pipe, you can get
    the same output using the command `bpftool prog tracelog`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记了跟踪管道的位置，您可以使用命令`bpftool prog tracelog`来获得相同的输出。
- en: In comparison to the output you saw in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    this time there is no command or process ID associated with each of these events;
    instead, you see `<idle>-0` at the start of each line of trace. In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    each syscall event happened because a process executing a command in user space
    made a call to the syscall API. That process ID and command are part of the context
    in which the eBPF program was executed. But in the example here, the XDP event
    happens due to the arrival of a network packet. There is no user space process
    associated with this packet—at the point the *hello* eBPF program is triggered,
    the system hasn’t done anything with the packet other than receive it in memory,
    and it has no idea what the packet is or where it’s going.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中看到的输出相比，这一次没有与每个事件相关的命令或进程ID；相反，您在跟踪的每一行开头看到`<idle>-0`。在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中，每个系统调用事件发生是因为一个在用户空间执行命令的进程调用了系统调用API。该进程ID和命令是eBPF程序执行的上下文的一部分。但在这个例子中，XDP事件是由网络数据包的到达引起的。与这个数据包相关的没有用户空间进程—在触发*hello*
    eBPF程序时，系统对数据包除了在内存中接收它之外还没有做任何事情，也不知道数据包是什么或者它要去哪里。
- en: You can see that the counter value that is traced out is being incremented by
    one each time, as expected. In the source code, `counter` is a global variable.
    Let’s see how that is implemented in eBPF using a map.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到被跟踪的计数器值每次增加1，这是预期的。在源代码中，`counter`是一个全局变量。让我们看看在eBPF中如何实现这一点。
- en: Global Variables
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: As you learned in the previous chapter, an eBPF map is a data structure that
    can be accessed from an eBPF program or from user space. Since the same map can
    be accessed repeatedly by different runs of the same program, it can be used to
    hold state from one execution to the next. Multiple programs can also access the
    same map. Because of these characteristics, map semantics can be repurposed for
    use as global variables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中学到的，eBPF映射是一种数据结构，可以从eBPF程序或用户空间访问。由于同一个映射可以被同一个程序的不同运行重复访问，因此它可以用于保存从一次执行到下一次执行的状态。多个程序也可以访问同一个映射。由于这些特性，映射语义可以被重新用作全局变量。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Before support for [global variables was added in 2019](https://oreil.ly/IDftt),
    eBPF programmers had to write maps explicitly to perform the same task.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[2019年添加对全局变量的支持之前](https://oreil.ly/IDftt)，eBPF程序员必须显式编写映射来执行相同的任务。
- en: You saw earlier that `bpftool` shows this example program using two maps with
    the identities 165 and 166\. (You will probably see different identities if you
    try this for yourself, as the identities are assigned when the maps are created
    in the kernel.) Let’s explore what is in those maps.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前看到`bpftool`显示了这个示例程序，使用了两个具有标识符165和166的映射。(如果您自己尝试，可能会看到不同的标识符，因为这些标识符是在内核中创建映射时分配的。)
    让我们来探索这些映射中的内容。
- en: 'The `bpftool` utility can show the maps loaded into the kernel. For clarity
    I will only show the entries 165 and 166 that relate to the example “Hello World”
    program:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool`实用程序可以显示加载到内核中的映射。为了清晰起见，我只会显示与示例“Hello World”程序相关的条目165和166：'
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A bss^([6](ch03.html#ch03fn6)) section in an object file compiled from a C
    program typically holds global variables, and you can use `bpftool` to inspect
    its contents, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从C程序编译的对象文件中的bss^([6](ch03.html#ch03fn6))部分通常保存全局变量，您可以使用`bpftool`来检查其内容，就像这样：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I could also have used `bpftool map dump id 165` to retrieve the same information.
    If I run either of these commands again, I’ll see that the counter has increased,
    as the program has been run every time a network packet is received.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用`bpftool map dump id 165`来检索相同的信息。如果我再次运行这些命令中的任何一个，我会看到计数器已经增加，因为每次接收到网络数据包时程序都会运行。
- en: 'As you’ll learn in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), `bpftool`
    is able to pretty-print the field names from a map (here, the variable name `counter`)
    only if BTF information is available, and that information is included only if
    you compile with the `-g` flag. If you omitted that flag during the compilation
    step, you’d see something that looks more like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中了解到的，`bpftool`能够在映射中漂亮地打印字段名称(这里是变量名`counter`)，只有在BTF信息可用时才能打印出来，而这些信息只有在使用`-g`标志进行编译时才包含在内。如果在编译步骤中省略了该标志，您将看到更像这样的东西：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Without BTF information, `bpftool` has no way of knowing what variable name
    was used in the source code. You can infer that since there is only one item in
    this map, the hex value `19 01 00 00` must be the current value of `counter` (281
    in decimal, since the bytes are ordered starting with the least significant byte).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 没有BTF信息，`bpftool`无法知道源代码中使用的变量名。您可以推断，由于这个映射中只有一个项目，十六进制值`19 01 00 00`必须是`counter`的当前值(281的十进制，因为字节是从最不重要的字节开始排序的)。
- en: You’ve seen here that the eBPF program uses the semantics of a map to read and
    write to a global variable. Maps are also used to hold static data, as you can
    see by inspecting the other map.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: You’ve seen here that the eBPF program uses the semantics of a map to read and
    write to a global variable. Maps are also used to hold static data, as you can
    see by inspecting the other map.
- en: 'The fact that the other map is named `hello.rodata` gives a hint that this
    could be read-only data related to our *hello* program. You can dump the contents
    of this map to see that it holds the string used by the eBPF program for tracing:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'The fact that the other map is named `hello.rodata` gives a hint that this
    could be read-only data related to our *hello* program. You can dump the contents
    of this map to see that it holds the string used by the eBPF program for tracing:'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you didn’t compile the object with the `-g` flag, you’ll see output that
    looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'If you didn’t compile the object with the `-g` flag, you’ll see output that
    looks like this:'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is one key–value pair in this map, and the value contains 12 bytes of
    data ending with a 0\. It probably won’t surprise you that those bytes are the
    ASCII representation of the string `"Hello World %d"`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: There is one key–value pair in this map, and the value contains 12 bytes of
    data ending with a 0\. It probably won’t surprise you that those bytes are the
    ASCII representation of the string `"Hello World %d"`.
- en: Now that we’ve finished inspecting this program and its maps, it’s time to clean
    it up. We’ll start by detaching it from the event that triggers it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Now that we’ve finished inspecting this program and its maps, it’s time to clean
    it up. We’ll start by detaching it from the event that triggers it.
- en: Detaching the Program
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Detaching the Program
- en: 'You can detach the program from the network interface like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can detach the program from the network interface like this:'
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is no output if this command runs successfully, but you can confirm that
    the program is no longer attached by the lack of XDP entries in the output from
    `bpftool net list`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'There is no output if this command runs successfully, but you can confirm that
    the program is no longer attached by the lack of XDP entries in the output from
    `bpftool net list`:'
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, the program is still loaded into the kernel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'However, the program is still loaded into the kernel:'
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unloading the Program
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unloading the Program
- en: 'There’s no inverse of `bpftool prog load` (at least not at the time of this
    writing), but you can remove the program from the kernel by deleting the pinned
    pseudofile:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'There’s no inverse of `bpftool prog load` (at least not at the time of this
    writing), but you can remove the program from the kernel by deleting the pinned
    pseudofile:'
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is no output from this `bpftool` command because the program is no longer
    loaded in the kernel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: There is no output from this `bpftool` command because the program is no longer
    loaded in the kernel.
- en: BPF to BPF Calls
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF to BPF Calls
- en: In the previous chapter you saw tail calls in action, and I mentioned that now
    there is also the ability to call functions from within an eBPF program. Let’s
    take a look at a simple example, which, like the tail call example, can be attached
    to the `sys_enter` tracepoint, except this time it will trace out the opcode for
    the syscall. You’ll find the code in *chapter3/hello-func.bpf.c*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: In the previous chapter you saw tail calls in action, and I mentioned that now
    there is also the ability to call functions from within an eBPF program. Let’s
    take a look at a simple example, which, like the tail call example, can be attached
    to the `sys_enter` tracepoint, except this time it will trace out the opcode for
    the syscall. You’ll find the code in *chapter3/hello-func.bpf.c*.
- en: 'For illustrative purposes I have written a very simple function that extracts
    the syscall opcode from the tracepoint arguments:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'For illustrative purposes I have written a very simple function that extracts
    the syscall opcode from the tracepoint arguments:'
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'SEC("raw_tp") `int``hello``(``struct``bpf_raw_tracepoint_args``*``ctx``)``{`
    ``int``opcode``=``get_opcode``(``ctx``);` ``bpf_printk``(``"Syscall: %d"``,``opcode``);`
    ``return``0``;` ``}[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'SEC("raw_tp") `int``hello``(``struct``bpf_raw_tracepoint_args``*``ctx``)``{`
    ``int``opcode``=``get_opcode``(``ctx``);` ``bpf_printk``(``"Syscall: %d"``,``opcode``);`
    ``return``0``;` ``}[PRE31]'
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: $ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello
- en: $ bpftool prog list name hello
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: $ bpftool prog list name hello
- en: '893: raw_tracepoint  name hello  tag 3d9eb0c23d4ab186  gpl'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '893: raw_tracepoint  name hello  tag 3d9eb0c23d4ab186  gpl'
- en: loaded_at 2023-01-05T18:57:31+0000  uid 0
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: loaded_at 2023-01-05T18:57:31+0000  uid 0
- en: xlated 80B  jited 208B  memlock 4096B  map_ids 204
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: xlated 80B  jited 208B  memlock 4096B  map_ids 204
- en: btf_id 302
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: btf_id 302
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: $ bpftool prog dump xlated name hello
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: $ bpftool prog dump xlated name hello
- en: 'int hello(struct bpf_raw_tracepoint_args * ctx):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'int hello(struct bpf_raw_tracepoint_args * ctx):'
- en: ; int opcode = get_opcode(ctx);                            ![1](assets/1.png)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ; int opcode = get_opcode(ctx);                            ![1](assets/1.png)
- en: '0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode'
- en: '; bpf_printk("Syscall: %d", opcode);'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '; bpf_printk("Syscall: %d", opcode);'
- en: '1: (18) r1 = map[id:193][0]+0'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '1: (18) r1 = map[id:193][0]+0'
- en: '3: (b7) r2 = 12'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '3: (b7) r2 = 12'
- en: '4: (bf) r3 = r0'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '4: (bf) r3 = r0'
- en: '5: (85) call bpf_trace_printk#-73584'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '5: (85) call bpf_trace_printk#-73584'
- en: ; return 0;
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ; return 0;
- en: '6: (b7) r0 = 0'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '6: (b7) r0 = 0'
- en: '7: (95) exit'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '7: (95) exit'
- en: 'int get_opcode(struct bpf_raw_tracepoint_args * ctx):      ![2](assets/2.png)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'int get_opcode(struct bpf_raw_tracepoint_args * ctx):      ![2](assets/2.png)'
- en: ; return ctx->args[1];
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ; return ctx->args[1];
- en: '8: (79) r0 = *(u64 *)(r1 +8)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '8: (79) r0 = *(u64 *)(r1 +8)'
- en: ; return ctx->args[1];
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ; return ctx->args[1];
- en: '9: (95) exit'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '9: (95) exit'
- en: '[PRE34][PRE35]# Summary'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34][PRE35]# Summary'
- en: In this chapter you saw some example C source code transformed into eBPF bytecode
    and then compiled to machine code so that it’s ready to be executed in the kernel.
    You also learned how to use `bpftool` to inspect programs and maps loaded into
    the kernel, and to attach to XDP events.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: In this chapter you saw some example C source code transformed into eBPF bytecode
    and then compiled to machine code so that it’s ready to be executed in the kernel.
    You also learned how to use `bpftool` to inspect programs and maps loaded into
    the kernel, and to attach to XDP events.
- en: In addition, you saw examples of different types of eBPF programs triggered
    by different kinds of events. An XDP event is triggered by the arrival of a packet
    of data on a network interface, whereas kprobe and tracepoint events are triggered
    by hitting some particular point in kernel code. I’ll discuss some other eBPF
    program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: In addition, you saw examples of different types of eBPF programs triggered
    by different kinds of events. An XDP event is triggered by the arrival of a packet
    of data on a network interface, whereas kprobe and tracepoint events are triggered
    by hitting some particular point in kernel code. I’ll discuss some other eBPF
    program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
- en: You also learned how maps are used to implement global variables for eBPF programs,
    and you saw BPF to BPF function calls.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: You also learned how maps are used to implement global variables for eBPF programs,
    and you saw BPF to BPF function calls.
- en: The next chapter goes into another level of detail as I show you what’s happening
    at the system call level when `bpftool`—or any other user space code—loads programs
    and attaches them to events.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更详细地介绍当`bpftool`—或任何其他用户空间代码—加载程序并将其附加到事件时，在系统调用级别发生了什么。
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are a few things to try if you want to explore BPF programs further:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索BPF程序，可以尝试以下几种方法：
- en: 'Try using `ip link` commands like the following to attach and detach the XDP
    program:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用类似以下的`ip link`命令来附加和分离XDP程序：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run any of the BCC examples from [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    While the program is running, use a second terminal window to inspect the loaded
    program using `bpftool`. Here’s an example of what I saw by running the *hello-map.py*
    example:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中的任何BCC示例。在程序运行时，使用第二个终端窗口使用`bpftool`检查加载的程序。以下是我通过运行*hello-map.py*示例看到的示例：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also use `bpftool prog dump` commands to see the bytecode and machine
    code versions of those programs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`bpftool prog dump`命令来查看这些程序的字节码和机器码版本。
- en: 'Run *hello-tail.py* from the *chapter2* directory, and while it’s running,
    take a look at the programs it loaded. You’ll see that each tail call program
    is listed individually, like this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行*chapter2*目录中的*hello-tail.py*，在其运行时，查看它加载的程序。您会看到每个尾调用程序都单独列出，就像这样：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You could also use `bpftool prog dump xlated` to look at the bytecode instructions
    and compare them to what you saw in [“BPF to BPF Calls”](#bpf_to_bpf_calls).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`bpftool prog dump xlated`来查看字节码指令，并将其与[“BPF to BPF Calls”](#bpf_to_bpf_calls)中所见的进行比较。
- en: '*Be careful with this one, as it may be best to simply think about why this
    happens rather than trying it!* If you return a `0` value from an XDP program,
    this corresponds to `XDP_ABORTED`, which tells the kernel to abort any further
    processing of this packet. This might seem a bit counterintuitive given that the
    `0` value usually indicates success in C, but that’s how it is. So, if you try
    modifying the program to return `0` and attach it to a virtual machine’s `eth0`
    interface, all network packets will get dropped. This will be somewhat unfortunate
    if you’re using SSH to attach to that machine, and you’ll likely have to reboot
    the machine to regain access!'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*小心使用这个，最好只是考虑为什么会发生这种情况而不是尝试它！*如果从XDP程序返回`0`值，则对应于`XDP_ABORTED`，这告诉内核中止对此数据包的任何进一步处理。这可能看起来有点违反直觉，因为在C中`0`值通常表示成功，但事实就是如此。因此，如果尝试修改程序以返回`0`并将其附加到虚拟机的`eth0`接口，所有网络数据包都将被丢弃。如果您正在使用SSH连接到该机器，这将有些不幸，您可能需要重新启动机器才能恢复访问！'
- en: You could run the program within a container so that the XDP program is attached
    to a virtual Ethernet interface that only affects that container and not the whole
    virtual machine. There’s an example of doing this at [*https://github.com/lizrice/lb-from-scratch*](https://github.com/lizrice/lb-from-scratch).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在容器中运行程序，以便XDP程序附加到仅影响该容器而不是整个虚拟机的虚拟以太网接口。在[*https://github.com/lizrice/lb-from-scratch*](https://github.com/lizrice/lb-from-scratch)中有一个示例。
- en: ^([1](ch03.html#ch03fn1-marker)) Increasingly, eBPF programs are also being
    written in Rust, since the Rust compiler supports eBPF bytecode as a target.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#ch03fn1-marker))随着Rust编译器支持eBPF字节码作为目标，越来越多的eBPF程序也是用Rust编写的。
- en: ^([2](ch03.html#ch03fn2-marker)) There are a few instructions where the operation
    is “modified” by the value of other fields in the instruction. For example, there
    are a set of [atomic instructions](https://oreil.ly/oyTI7) introduced in kernel
    5.12 that include an arithmetic operation (`ADD`, `AND`, `OR`, `XOR`) that is
    specified in the `imm` field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#ch03fn2-marker))有一些指令的操作会受到指令中其他字段值的“修改”的影响。例如，在内核5.12中引入了一组[原子指令](https://oreil.ly/oyTI7)，其中包括一个在`imm`字段中指定的算术操作（`ADD`、`AND`、`OR`、`XOR）。
- en: ^([3](ch03.html#ch03fn3-marker)) The `-g` flag is required to generate BTF information
    that you’ll need for CO-RE eBPF programs, which I’ll cover in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#ch03fn3-marker))使用`-g`标志是为了生成CO-RE eBPF程序所需的BTF信息，我将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中介绍。
- en: ^([4](ch03.html#ch03fn4-marker)) In general, this is optional—eBPF programs
    can be loaded into the kernel without being pinned to a file location—but it’s
    not optional for `bpftool`, which always has to pin the programs it loads. The
    reason for this is covered further in [“BPF Program and Map References”](ch04.html#bpf_program_and_map_references).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#ch03fn4-marker))一般来说，这是可选的——eBPF程序可以加载到内核中而不被固定到文件位置，但对于`bpftool`来说是不可选的，它总是必须固定它加载的程序。这样做的原因在[“BPF
    Program and Map References”](ch04.html#bpf_program_and_map_references)中有进一步介绍。
- en: ^([5](ch03.html#ch03fn5-marker)) The kernel setting `CONFIG_BPF_JIT` needs to
    be enabled to take advantage of JIT compilation, and it can be enabled or disabled
    at runtime with the `net.core.bpf_jit_enable sysctl` setting. See [the docs](https://oreil.ly/4-xi6)
    for more information on JIT support on different chip architectures.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#ch03fn5-marker))内核设置`CONFIG_BPF_JIT`需要启用JIT编译才能发挥作用，并且可以使用`net.core.bpf_jit_enable
    sysctl`设置在运行时启用或禁用。有关不同芯片架构上JIT支持的更多信息，请参见[文档](https://oreil.ly/4-xi6)。
- en: ^([6](ch03.html#ch03fn6-marker)) Here, *bss* stands for “block started by symbol.”``````
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#ch03fn6-marker))这里，“bss”代表“由符号开始的块”。

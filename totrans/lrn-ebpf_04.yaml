- en: Chapter 4\. The bpf() System Call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when user space applications want the kernel to do something on their behalf,
    they make requests using the system call API. It therefore makes sense that if
    a user space application wants to load an eBPF program into the kernel, there
    must be some system calls involved. In fact, there’s a system call named `bpf()`,
    and in this chapter I’ll show you how it’s used to load and interact with eBPF
    programs and maps.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the eBPF code running in the kernel does not use syscalls
    to access maps. The syscall interface is only used by user space applications.
    Instead, eBPF programs use helper functions to read and write to maps; you already
    saw examples of this in the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you go on to write eBPF programs yourself, there’s a good chance you won’t
    directly call these `bpf()` system calls yourself. There are libraries that I’ll
    discuss later in the book that offer higher-level abstractions to make things
    easier. That said, those abstractions generally map pretty directly to the underlying
    syscall commands you’ll see in this chapter. Whatever library you’re using, you’ll
    need a grasp of the underlying operations—loading a program, creating and accessing
    maps, and so on—that you’ll see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I show you examples of `bpf()` system calls, let’s consider what the
    [manpage for `bpf()` says](https://oreil.ly/NJdIM), which is that `bpf()` is used
    to “perform a command on an extended BPF map or program.” It also tells us that
    `bpf()`’s signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`The first argument to `bpf()`, `cmd`, specifies which command to perform.
    The `bpf()` syscall doesn’t just do one thing—there are lots of different commands
    that can be used to manipulate eBPF programs and maps. [Figure 4-1](#a_userspace_program_interacts_with_ebpf)
    shows an overview of some of the common commands the user space code might use
    to load eBPF programs, create maps, attach programs to events, and access the
    key–value pairs in a map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A user space program interacts with eBPF programs and maps in the kernel
    using syscalls](assets/lebp_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. A userspace program interacts with eBPF programs and maps in the
    kernel using syscalls
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `attr` argument to the `bpf()` syscall holds whatever data is needed to
    specify the parameters for the command, and `size` indicates how many bytes of
    data there are in `attr`.
  prefs: []
  type: TYPE_NORMAL
- en: You already met `strace` in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when I used it to show how user space code makes many requests across the syscall
    API. In this chapter I’ll use it to demonstrate how the `bpf()` syscall is used.
    The output from `strace` includes the arguments to each syscall, but to keep the
    example output in this chapter from being too cluttered, I’ll omit lots of the
    details from the `attr` arguments unless they are particularly interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll find the code, along with instructions for setting up an environment
    to run it in, at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter4* directory.
  prefs: []
  type: TYPE_NORMAL
- en: For this example I’m going to use a BCC program called *hello-buffer-config.py*,
    which builds on the examples you saw in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    Like the *hello-buffer.py* example, this program sends a message to the perf buffer
    whenever it runs, conveying information from the kernel to user space about `execve()`
    syscall events. What’s new in this version is that it allows for different messages
    to be configured for each user ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the eBPF source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_4_1)'
  prefs: []
  type: TYPE_NORMAL
- en: This line indicates that there’s a structure definition, `user_msg_t`, for holding
    a 12-character message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_4_2)'
  prefs: []
  type: TYPE_NORMAL
- en: The BCC macro `BPF_HASH` is used to define a hash table map called `config`.
    It will hold values of type `user_msg_t`, indexed by keys of type `u32`, which
    is the right size for a user ID. (If you don’t specify the types for the keys
    and values, BCC defaults to `u64` for both.)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_4_3)'
  prefs: []
  type: TYPE_NORMAL
- en: The perf buffer output is defined in exactly the same way as in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    You can submit arbitrary data to a buffer, so there’s no need to specify any data
    types here…
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_4_4)'
  prefs: []
  type: TYPE_NORMAL
- en: …although in practice, in this example the program always submits a `data_t`
    structure. This is also unchanged from the [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_4_5)'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the rest of the eBPF program is unchanged from the `hello()` version
    you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_4_6)'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that having used a helper function to get the user ID,
    the code looks for an entry in the `config` hash map with that user ID as the
    key. If there is a matching entry, the value contains a message that gets used
    instead of the default “Hello World.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code has two additional lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These define messages in the `config` hash table for user IDs 0 and 501, which
    correspond to the root user and my user ID on this virtual machine. This code
    uses Python’s `ctypes` package to ensure that the key and value have the same
    types as those used in the C definition of `user_msg_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some illustrative output from this example, along with the commands
    I ran in a second terminal to obtain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you’ve got an idea of what this program does, I’d like to show you
    the `bpf()` system calls that are used when it runs. I’ll run it again using `strace`,
    specifying `-e bpf` to indicate that I am only interested in seeing the `bpf()`
    syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you’ll see if you try this yourself shows several calls to this
    syscall. For each, you’ll see the command indicating what the `bpf()` syscall
    should do. The broad outline looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine them one by one. Neither you, the reader, nor I have infinite
    patience, so I won’t discuss every single argument to every single call! I’ll
    focus on the parts that I think really help to tell the story of what’s happening
    when a user space program interacts with an eBPF program.
  prefs: []
  type: TYPE_NORMAL
- en: Loading BTF Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first call to `bpf()` that I see looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case the command you can see in the output is `BPF_BTF_LOAD`. This is
    just one of a set of valid commands that are (at least at the time of this writing)
    most comprehensively documented within the kernel source code.^([1](ch04.html#ch04fn1))
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that you won’t see a call with this command if you’re using a
    relatively old Linux kernel, as it relates to BTF, or BPF Type Format.^([2](ch04.html#ch04fn2))
    BTF allows eBPF programs to be portable across different kernel versions so that
    you can compile a program on one machine and use it on another, which might be
    using a different kernel version and hence have different kernel data structures.
    I’ll discuss this in more detail in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  prefs: []
  type: TYPE_NORMAL
- en: This call to `bpf()` is loading a blob of BTF data into the kernel, and the
    return code from the `bpf()` system call (`3` in my example) is a file descriptor
    that refers to that data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *file descriptor* is an identifier for an open file (or file-like object).
    If you open a file (with the `open()` or `openat()` system call) the return code
    is a file descriptor, which is then passed as an argument to other syscalls such
    as `read()` or `write()` to perform operations on that file. Here the blob of
    data isn’t exactly a file, but it is given a file descriptor as an identifier
    that can be used for future operations that refer to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next `bpf()` creates the `output` perf buffer map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can probably guess from the command name `BPF_MAP_CREATE` that this call
    creates an eBPF map. You can see that the type of this map is `PERF_EVENT_ARRAY`
    and it is called `output`. The keys and values in this perf event map are 4 bytes
    long. There’s also a limit of four key–value pairs that can be held in this map,
    defined by the field `max_entries`; I’ll explain why there are four entries in
    this map later in this chapter. The return value of `4` is the file descriptor
    for the user space code to access the `output` map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `bpf()` system call in the output creates the `config` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This map is defined to be a hash table map, with keys that are 4 bytes long
    (which corresponds to a 32-bit integer that can be used to hold a user ID) and
    values that are 12 bytes long (which matches the length of the `msg_t` structure).
    I didn’t specify the size of the table, so it has been given BCC’s default size
    of 10,240 entries.
  prefs: []
  type: TYPE_NORMAL
- en: This `bpf()` system call also returns a file descriptor, `5`, which will be
    used to refer to this `config` map in future syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see the field `btf_fd=3`, which tells the kernel to use the BTF
    file descriptor `3` that was obtained earlier. As you’ll see in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    BTF information describes the layout of data structures, and including this in
    the definition of the map means there’s information about the layout of the key
    and value types used in this map. This is used by tools like `bpftool` to pretty-print
    map dumps, making them human readable—you saw an example of this in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
  prefs: []
  type: TYPE_NORMAL
- en: Loading a Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far you have seen the example program using syscalls to load BTF data into
    the kernel and create some eBPF maps. The next thing it does is load the eBPF
    program being loaded into the kernel with the following `bpf()` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite a few of the fields here are interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: The `prog_type` field describes the program type, which here indicates that
    it’s intended to be attached to a kprobe. You’ll learn more about program types
    in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `insn_cnt` field means “instruction count.” This is the number of bytecode
    instructions in the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bytecode instructions that make up this eBPF program are held in memory
    at the address specified in the `insns` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program was specified as GPL licensed so that it can use GPL-licensed BPF
    helper functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program name is `hello`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `expected_attach_type` of `BPF_CGROUP_INET_INGRESS` might seem surprising,
    because that sounds like something to do with ingress network traffic, but you
    know this eBPF program is going to be attached to a kprobe. In fact, the `expected_attach_type`
    field is only used for some program types, and `BPF_PROG_TYPE_KPROBE` isn’t one
    of them. `BPF_CGROUP_INET_INGRESS` just happens to be the first in the list of
    BPF attachment types,^([3](ch04.html#ch04fn3)) so it has the value `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prog_btf_fd` field tells the kernel which blob of previously loaded BTF
    data to use with this program. The value `3` here corresponds to the file descriptor
    you saw returned from the `BPF_BTF_LOAD` syscall (and it’s the same blob of BTF
    data used for the `config` map).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the program had failed verification (which I’ll discuss in [Chapter 6](ch06.html#the_ebpf_verifier)),
    this syscall would have returned a negative value, but here you can see it returned
    the file descriptor 6\. To recap, at this point the file descriptors have the
    meanings shown in [Table 4-1](#file_descriptors_when_running_hello_buf).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. File descriptors when running hello-buffer-config.py after loading
    the program
  prefs: []
  type: TYPE_NORMAL
- en: '| File descriptor | Represents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | BTF data |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `output` perf buffer map |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `config` hash table map |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | `hello` eBPF program |'
  prefs: []
  type: TYPE_TB
- en: Modifying a Map from User Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You already saw the line in the Python user space source code that configures
    special messages that will be displayed for the root user with user ID 0, and
    for the user with ID 501:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see these entries being defined in the map through syscalls like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `BPF_MAP_UPDATE_ELEM` command updates the key–value pair in a map. The `BPF_ANY`
    flag indicates that if the key doesn’t already exist in this map, it should be
    created. There are two of these calls, corresponding to the two entries configured
    for two different user IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The `map_fd` field identifies which map is being operated on. You can see that
    in this case it’s `5`, which is the file descriptor value returned earlier when
    the `config` map was created.
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors are assigned by the kernel for a particular process, so this
    value of `5` is only valid for this particular user space process in which the
    Python program is running. However, multiple user space programs (and multiple
    eBPF programs in the kernel) can all access the same map. Two user space programs
    that access the same map structure in the kernel might very well be assigned different
    file descriptor values; equally, two user space programs might have the same file
    descriptor value for entirely different maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the key and the value are pointers, so you can’t tell the numeric value
    of either the key or the value from this `strace` output. You could, however,
    use `bpftool` to view the map’s contents and see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How does `bpftool` know how to format this output? For example, how does it
    know the value is a structure, with a field called `message` that contains a string?
    The answer is that it uses the definitions in the BTF information included on
    the `BPF_MAP_CREATE` syscall that defined this map. You’ll see more details on
    how BTF conveys this information in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now seen how user space interacts with the kernel to load programs and
    maps and to update the information in a map. In the sequence of syscalls you have
    seen up to this point, the program hasn’t yet been attached to an event. This
    step has to happen; otherwise, the program will never be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fair warning: different types of eBPF programs get attached to different events
    in a variety of different ways! Later in this chapter I’ll show you the syscalls
    used in this example to attach to the kprobe event, and in this case it doesn’t
    involve `bpf()`. In contrast, in the exercises at the end of this chapter I will
    show you another example where a `bpf()` syscall is used to attach a program to
    a raw tracepoint event.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to those details, I’d like to discuss what happens when you quit
    running the program. You’ll find that the program and maps are automatically unloaded,
    and this happens because the kernel is keeping track of them using *reference
    counts*.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Program and Map References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know that loading a BPF program into the kernel with the `bpf()` syscall
    returns a file descriptor. Within the kernel, this file descriptor is a *reference*
    to the program. The user space process that made the syscall owns this file descriptor;
    when that process exits, the file descriptor gets released, and the reference
    count to the program is decremented. When there are no references left to a BPF
    program, the kernel removes the program.
  prefs: []
  type: TYPE_NORMAL
- en: An additional reference is created when you *pin* a program to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Pinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already saw pinning in action in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These pinned objects aren’t real files persisted to disk. They are created on
    a *pseudo filesystem*, which behaves like a regular disk-based filesystem with
    directories and files. But they are held in memory, which means they will not
    remain in place over a system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: If `bpftool` were to allow you to load the program without pinning it, that
    would be pointless, because the file descriptor gets released when `bpftool` exits,
    and if there are zero references, the program would get deleted, so nothing useful
    would have been achieved. But pinning it to the filesystem means there is an additional
    reference to the program, so the program remains loaded after the command completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference counter also gets incremented when a BPF program is attached
    to a hook that will trigger it. The behavior of these reference counts depends
    on the BPF program type. You’ll learn more about these program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types),
    but there are some that relate to tracing (like kprobes and tracepoints) and are
    always associated with a user space process; for these types of eBPF programs,
    the kernel’s reference count gets decremented when that process exits. Programs
    that are attached within the network stack or cgroups (short for “control groups”)
    aren’t associated with any user space process, so they stay in place even after
    the user space program that loads them exits. You already saw an example of this
    when loading an XDP program with the `ip link` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ip` command has completed, and there is no definition of a pinned location,
    but nevertheless, `bpftool` will show you that the XDP program is loaded in the
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The reference count for this program is nonzero, because of the attachment to
    the XDP hook that persisted after the `ip link` command completed.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF maps also have reference counters, and they get cleaned up when their reference
    count drops to zero. Each eBPF program that uses a map increments the counter,
    as does each file descriptor that user space programs might hold to the map.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that the source code for an eBPF program might define a map that
    the program doesn’t actually reference. Suppose you wanted to store some metadata
    about a program; you could define it as a global variable, and as you saw in the
    previous chapter, this information gets stored in a map. If the eBPF program doesn’t
    do anything with that map, there won’t automatically be a reference count from
    the program to the map. There’s a `BPF(BPF_PROG_BIND_MAP)` syscall that associates
    a map with a program so that the map doesn’t get cleaned up as soon as the user
    space loader program exits and is no longer holding a file descriptor reference
    to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Maps can also be pinned to the filesystem, and user space programs can gain
    access to the map by knowing the path to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alexei Starovoitov wrote a good description of BPF reference counters and file
    descriptors in his blog post [“Lifetime of BPF Objects”](https://oreil.ly/vofxH).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create a reference to a BPF program is with a BPF link.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BPF links provide a layer of abstraction between an eBPF program and the event
    it’s attached to. A BPF link itself can be pinned to the filesystem, which creates
    an additional reference to the program. This means the user space process that
    loaded the program into the kernel can terminate, leaving the program loaded.
    The file descriptor for the user space loader program gets freed up, decreasing
    the count of references to the program, but the reference count will be nonzero
    because of the BPF link.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get an opportunity to see BPF links in action if you follow the exercises
    at the end of this chapter. For now, let’s get back to the sequence of `bpf()`
    syscalls used by *hello-buffer-config.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Syscalls Involved in eBPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap, so far you have seen `bpf()` syscalls that add the BTF data, program
    and maps, and map data to the kernel. The next thing the `strace` output shows
    relates to setting up the perf buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rest of this chapter dives relatively deeply into the syscall sequences
    involved when using perf buffers, ring buffers, kprobes, and map iterations. Not
    all eBPF programs need to do these things, so if you’re in a hurry or you’re finding
    it a bit too detailed, feel free to skip to the chapter summary. I won’t be offended!
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Perf Buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen the `bpf(BPF_MAP_UPDATE_ELEM)` calls that add entries into the
    `config` map. Next, the output shows some calls that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These look very similar to the calls that defined the `config` map entries,
    except in this case the map’s file descriptor is `4`, which represents the `output`
    perf buffer map.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the key and the value are pointers, so you can’t tell the numeric
    value of either the key or the value from this `strace` output. I see this syscall
    repeated four times with identical values for all the parameters, though there’s
    no way of knowing whether the values the pointers hold have changed between each
    call. Looking at these `BPF_MAP_UPDATE_ELEM bpf()` calls leaves some unanswered
    questions about how the buffer is set up and used:'
  prefs: []
  type: TYPE_NORMAL
- en: Why are there four calls to `BPF_MAP_UPDATE_ELEM`? Does this relate to the fact
    that the `output` map was created with a maximum of four entries?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After these four instances of `BPF_MAP_UPDATE_ELEM`, no more `bpf()` syscalls
    appear in the `strace` output. That might seem a little odd, because the map is
    there so that the eBPF program can write data every time it is triggered, and
    you’ve seen data being displayed by the user space code. That data is clearly
    not being retrieved from the map with `bpf()` syscalls, so how is it obtained?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You’ve also yet to see any evidence of how the eBPF program is getting attached
    to the kprobe event that triggers it. To get the explanation for all these concerns,
    I need `strace` to show a few more syscalls when running this example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, I’m going to ignore calls to `ioctl()` that aren’t specifically
    related to the eBPF functionality of this example.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to Kprobe Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen that file descriptor 6 was assigned to represent the eBPF program
    *hello* once it was loaded into the kernel. To attach the eBPF program to an event,
    you also need a file descriptor representing that particular event. The following
    line from the `strace` output shows the creation of the file descriptor for the
    `execve()` kprobe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the [manpage for the `perf_event_open()` syscall](https://oreil.ly/xpRJs),
    it “creates a file descriptor that allows measuring performance information.”
    You can see from the output that `strace` doesn’t know how to interpret the type
    parameter with the value `6`, but if you examine that manpage further, it describes
    how Linux supports dynamic types of Performance Measurement Unit:'
  prefs: []
  type: TYPE_NORMAL
- en: …there is a subdirectory per PMU instance under */sys/bus/event_source/devices*.
    In each subdirectory there is a type file whose content is an integer that can
    be used in the type field.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sure enough, if you look under that directory, you’ll find a *kprobe/type*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From this, you can see that the call to `perf_event_open()` has a type set to
    the value `6` to indicate that it’s a kprobe type of perf event.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `strace` doesn’t output the details that would conclusively show
    that the kprobe is attached to the `execve()` syscall, but I hope there is enough
    evidence here to convince you that that’s what the file descriptor returned here
    represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return code from `perf_event_open()` is `7`, and this represents the file
    descriptor for the kprobe’s perf event, and you know that file descriptor `6`
    represents the *hello* eBPF program. The manpage for `perf_event_open()` also
    explains how to use `ioctl()` to create the attachment between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PERF_EVENT_IOC_SET_BPF` [...] allows attaching a Berkeley Packet Filter (BPF)
    program to an existing kprobe tracepoint event. The argument is a BPF program
    file descriptor that was created by a previous `bpf(2)` system call.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This explains the following `ioctl()` syscall that you’ll see in the `strace`
    output, with arguments referring to the two file descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also another `ioctl()` call that turns the kprobe event on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the eBPF program should be triggered whenever `execve()`
    is run on this machine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up and Reading Perf Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I already mentioned that I see four calls to `bpf(BPF_MAP_UPDATE_ELEM)` related
    to the output perf buffer. With the additional syscalls being traced, the `strace`
    output shows four sequences, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve used `X` to indicate where the output shows values `0`, `1`, `2`, and
    `3` in the four instances of this call. Referring to the manpage for the `perf_event_open()`
    syscall, you’ll see that this is the `cpu`, and the field before it is `pid` or
    process ID. From the manpage:'
  prefs: []
  type: TYPE_NORMAL
- en: pid == -1 and cpu >= 0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: This measures all processes/threads on the specified CPU.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The fact that this sequence happens four times corresponds to there being four
    CPU cores in my laptop. This, at last, is the explanation for why there are four
    entries in the “output” perf buffer map: there is one for each CPU core. It also
    explains the “array” part of the map type name `BPF_MAP_TYPE_PERF_EVENT_ARRAY`,
    as the map doesn’t just represent one perf ring buffer but an array of buffers,
    one for each core.'
  prefs: []
  type: TYPE_NORMAL
- en: If you write eBPF programs, you won’t need to worry about details like handling
    the number of cores, as this will be taken care of for you by any of the eBPF
    libraries discussed in [Chapter 10](ch10.html#ebpf_programming), but I think it’s
    an interesting aspect of the syscalls you see when you use `strace` on this program.
  prefs: []
  type: TYPE_NORMAL
- en: The `perf_event_open()` calls each return a file descriptor, which I’ve represented
    as `Y`; these have the values `8`, `9`, `10`, and `11`. The `ioctl()` syscalls
    enable the perf output for each of these file descriptors. The `BPF_MAP_UPDATE_ELEM
    bpf()` syscalls set the map entry to point to the perf ring buffer for each CPU
    core to indicate where it can submit data.
  prefs: []
  type: TYPE_NORMAL
- en: 'User space code can then use `ppoll()` on all four of these output stream file
    descriptors so that it can get the data output, whichever core happens to run
    the eBPF program *hello* for any given `execve()` kprobe event. Here’s the syscall
    to `ppoll()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you’ll see if you try running the example program yourself, these `ppoll()`
    calls block until there is something to read from one of the file descriptors.
    You won’t see the return code written to the screen until something triggers `execve()`,
    which causes the eBPF program to write data that user space retrieves using this
    `ppoll()` call.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I mentioned
    that if you have a kernel of version 5.8 or above, BPF ring buffers are now preferred
    over perf buffers.^([4](ch04.html#ch04fn4)) Let’s take a look at a modified version
    of the same example code that uses a ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Ring Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the [kernel documentation](https://oreil.ly/RN_RA), ring buffers
    are preferred over perf buffers partly for performance reasons, but also to ensure
    that the ordering of data is preserved, even if the data is submitted by different
    CPU cores. There is just one buffer, shared across all cores.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t many changes needed to convert *hello-buffer-config.py* to use
    a ring buffer. In the accompanying GitHub repo you’ll find this example as *chapter4/hello-ring-buffer-config.py*.
    [Table 4-2](#differences_between_example_bcc_code_us) shows the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Differences between example BCC code using a perf buffer and a ring
    buffer
  prefs: []
  type: TYPE_NORMAL
- en: '| *hello-buffer-config.py* | *hello-ring-buffer-config.py* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BPF_PERF_OUTPUT(output);` | `BPF_RINGBUF_OUTPUT(output, 1);` |'
  prefs: []
  type: TYPE_TB
- en: '| `output.perf_submit(ctx, &data, sizeof(data));` | `output.ringbuf_output(&data,
    sizeof(data), 0);` |'
  prefs: []
  type: TYPE_TB
- en: '| `b["output"]. open_perf_buffer(print_event)` | `b["output"]. open_ring_buffer(print_event)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `b.perf_buffer_poll()` | `b.ring_buffer_poll()` |'
  prefs: []
  type: TYPE_TB
- en: As you’d expect, since these changes relate only to the `output` buffer, the
    syscalls related to loading the program and the `config` map and attaching the
    program to the kprobe event all remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bpf()` syscall that creates the `output` ring buffer map looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The major difference in the `strace` output is that there is no sign of the
    series of four different `perf_event_open()`, `ioctl()`, and `bpf(BPF_MAP_UPDATE_ELEM)`
    system calls that you observed during the setup of a perf buffer. For a ring buffer,
    there’s just the one file descriptor shared across all CPU cores.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, BCC is using the `ppoll` mechanism I showed earlier
    for perf buffers, but it uses the newer `epoll` mechanism to wait for data from
    the ring buffer. Let’s use this as an opportunity to understand the difference
    between `ppoll` and `epoll`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the perf buffer example, I showed *hello-buffer-config.py* generating a
    `ppoll()` syscall, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this passes in the set of file descriptors `8`, `9`, `10`, and `11`
    from which the user space process wants to retrieve data. Every time this poll
    event returns data, another call has to be made to `ppoll()` to set up the same
    set of file descriptors all over again. When using `epoll`, the file descriptor
    set is managed in a kernel object.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this in the following sequence of `epoll`-related system calls made
    when *hello-ring-buffer-config.py* is setting up access to the `output` ring buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the user space program asks for a new `epoll` instance to be created
    in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns file descriptor `8`. Then there is a call to `epoll_ctl()`, which
    tells the kernel to add file descriptor `4` (the `output` buffer) to the set of
    file descriptors in that `epoll` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The user space program uses `epoll_pwait()` to wait until data is available
    in the ring buffer. This call only returns when data is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you’re writing code using a framework like BCC (or *libbpf* or
    any of the other libraries I’ll describe later in this book), you really don’t
    need to know these underlying details about how your user space application gets
    information from the kernel via perf or ring buffers. I hope you’ve found it interesting
    to get a peek under the covers to see how these things work.
  prefs: []
  type: TYPE_NORMAL
- en: However, you might well find yourself writing code that accesses a map from
    user space, and it might be helpful to see an example of how this is achieved.
    Earlier in this chapter, I used `bpftool` to examine the contents of the `config`
    map. Since it’s a utility that runs in user space, let’s use `strace` to see what
    syscalls it’s making to retrieve this information.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Information from a Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command shows an extract of the `bpf()` syscalls that `bpftool`
    makes while reading the contents of the `config` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ll see, the sequence consists of two main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through all the maps, looking for any with the name `config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a matching map is found, iterate through all the elements in that map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output starts with a repeated sequence of similar calls, as `bpftool` walks
    through all the maps looking for any with the name `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_4_7)'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_MAP_GET_NEXT_ID` gets the ID of the next map after the value specified
    in `start_id`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_4_8)'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_MAP_GET_FD_BY_ID` returns the file descriptor for the specified map ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_4_9)'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_OBJ_GET_INFO_BY_FD` retrieves information about the object (in this case,
    the map) referred to by the file descriptor. This information includes its name
    so `bpftool` can check whether this is the map it is looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_4_10)'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence repeats, getting the ID of the next map after the one in step 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a group of these three syscalls for each map loaded into the kernel,
    and you should also see that the values used for `start_id` and `map_id` match
    the IDs of those maps. The repeated pattern ends when there are no more maps left
    to look at, which results in `BPF_MAP_GET_NEXT_ID` returning a value of `ENOENT`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If a matching map has been found, `bpftool` holds its file descriptor so that
    it can read the elements out of that map.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Map Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point `bpftool` has a file descriptor reference to the map(s) it’s
    going to read from. Let’s look at the syscall sequence for reading that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_4_11)'
  prefs: []
  type: TYPE_NORMAL
- en: First, the application needs to find a valid key that is present in the map.
    It does this with the `BPF_MAP_GET_NEXT_KEY` flavor of the `bpf()` syscall. The
    `key` argument is a pointer to a key, and the syscall will return the next valid
    key *after* this one. By passing in a NULL pointer, the application is requesting
    the first valid key in the map. The kernel writes the key into the location specified
    by the `next_key` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_4_12)'
  prefs: []
  type: TYPE_NORMAL
- en: Given a key, the application requests the associated value, which gets written
    to the memory location specified by `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_4_13)'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `bpftool` has the contents of the first key–value pair, and it
    writes this information to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_4_14)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `bpftool` moves on to the next key in the map, retrieves its value, and
    writes out this key–value pair to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_4_15)'
  prefs: []
  type: TYPE_NORMAL
- en: The next call to `BPF_MAP_GET_NEXT_KEY` returns `ENOENT` to indicate that there
    are no more entries in the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_4_16)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `bpftool` finalizes the output written to screen and exits.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that here, `bpftool` has been assigned file descriptor `3` to correspond
    to the `config` map. This is the same map that *hello-buffer-config.py* refers
    to with file descriptor `4`. As I’ve mentioned already, file descriptors are process
    specific.
  prefs: []
  type: TYPE_NORMAL
- en: This analysis of how `bpftool` behaves shows how a user space program can iterate
    through the available maps and through the key–value pairs stored in a map.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you saw how user space code uses the `bpf()` syscall to load
    eBPF programs and maps. You saw programs and maps being created using the `BPF_PROG_LOAD`
    and `BPF_MAP_CREATE` commands.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that the kernel keeps track of the number of references to eBPF
    programs and maps, releasing them when the reference count drops to zero. You
    were also introduced to the concepts of pinning BPF objects to a filesystem and
    using BPF links to create additional references.
  prefs: []
  type: TYPE_NORMAL
- en: You saw an example of `BPF_MAP_UPDATE_ELEM` being used to create entries in
    a map from user space. There are similar commands—`BPF_MAP_LOOKUP_ELEM` and `BPF_MAP_DELETE_ELEM`—for
    retrieving and deleting values from a map. There is also the command `BPF_MAP_GET_NEXT_KEY`
    for finding the next key that’s present in a map. You can use this to iterate
    through all the valid entries.
  prefs: []
  type: TYPE_NORMAL
- en: You saw examples of user space programs making use of `perf_event_open()` and
    `ioctl()` for attaching eBPF programs to kprobe events. The attachment method
    can be very different for other types of eBPF programs, and some of them even
    use the `bpf()` system call. For example, there’s a `bpf(BPF_PROG_ATTACH)` syscall
    that can be used to attach cgroup programs, and `bpf(BPF_RAW_TRACEPOINT_OPEN)`
    for raw tracepoints (see Exercise 5 at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: I also showed how you can use `BPF_MAP_GET_NEXT_ID`, `BPF_MAP_GET_FD_BY_ID`,
    and `BPF_OBJ_GET_INFO_BY_FD` to locate map (and other) objects held by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other `bpf()` commands that I haven’t covered in this chapter,
    but what you have seen here is enough to get a good overview.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw some BTF data being loaded into the kernel, and I mentioned that
    `bpftool` uses this information to understand the format of data structures so
    that it can print them out nicely. I didn’t explain yet what BTF data looks like
    or how it’s used to make eBPF programs portable across kernel versions. That’s
    coming up in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few things you can try if you’d like to explore the `bpf()` syscall
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the `insn_cnt` field from a `BPF_PROG_LOAD` system call corresponds
    to the number of instructions that are output if you dump the translated eBPF
    bytecode for that program using `bpftool`. (This is as documented on the [manpage
    for the `bpf()` system call](https://oreil.ly/NJdIM).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run two instances of the example program so that there are two maps called `config`.
    If you run `bpftool map dump name config`, the output will include information
    about the two different maps as well as their contents. Run this under `strace`,
    and follow the use of different file descriptors through the syscall output. Can
    you see where it’s retrieving information about a map and where it’s retrieving
    the key–value pairs stored within it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `bpftool map update` to modify the `config` map while one of the example
    programs is running. Use `sudo -u username` to check that these configuration
    changes are picked up by the eBPF program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While *hello-buffer-config.py* is running, use `bpftool` to pin the program
    to the BPF filesystem, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Quit the running program, and check that the *hello* program is still loaded
    in the kernel using `bpftool prog list`. You can clean up the link by removing
    the pin with `rm /sys/fs/bpf/hi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching to a raw tracepoint is considerably more straightforward at the syscall
    level than attaching to a kprobe, as it simply involves a `bpf()` syscall. Try
    converting *hello-buffer-config.py* to attach to the raw tracepoint for `sys_enter`,
    using BCC’s `RAW_TRACEPOINT_PROBE` macro (if you did the exercises in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    you’ll already have a suitable program you can use). You won’t need to explicitly
    attach the program in the Python code, as BCC will take care of it for you. Running
    this under `strace`, you should see a syscall similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The tracepoint in the kernel has the name `sys_enter`, and the eBPF program
    with file descriptor `6` is being attached to it. From now on, whenever execution
    in the kernel reaches that tracepoint, it will trigger the eBPF program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the opensnoop application from [BCC’s set of *libbpf tools*](https://oreil.ly/D31R4).
    This tool sets up some BPF links that you can see with `bpftool`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the program IDs (1849 and 1851 in my example output here) match
    the output from listing the loaded eBPF programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While opensnoop is running, try pinning one of these links with `bpftool link
    pin id 116 /sys/fs/bpf/mylink` (using one of the link IDs you see output from
    `bpftool link list`). You should see that even after you terminate opensnoop,
    both the link and the corresponding program remain loaded in the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you skip ahead to the example code for [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    you’ll find a version of *hello-buffer-config.py* written using the *libbpf* library.
    This library automatically sets up a BPF link to the program that it loads into
    the kernel. Use `strace` to inspect the `bpf()` system calls that it makes, and
    see `bpf(BPF_LINK_CREATE)` system calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ^([1](ch04.html#ch04fn1-marker)) If you want to see the full set of BPF commands,
    they’re documented in the [*linux/bpf.h*](https://oreil.ly/Pyy7U) header file.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#ch04fn2-marker)) BTF was introduced upstream in the 5.1 kernel,
    but it has been back-ported on some Linux distributions, as you can see from [this
    discussion](https://oreil.ly/LjcPN).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.html#ch04fn3-marker)) These are defined in the `bpf_attach_type`
    enumerator in [*linux/bpf.h*](https://oreil.ly/AO1rc)*.*
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch04.html#ch04fn4-marker)) A reminder that for more information on the
    difference, read Andrii Nakryiko’s [“BPF ring buffer”](https://oreil.ly/XkpUF)
    blog post.`
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 4\. The bpf() System Call
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。bpf()系统调用
- en: As you saw in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when user space applications want the kernel to do something on their behalf,
    they make requests using the system call API. It therefore makes sense that if
    a user space application wants to load an eBPF program into the kernel, there
    must be some system calls involved. In fact, there’s a system call named `bpf()`,
    and in this chapter I’ll show you how it’s used to load and interact with eBPF
    programs and maps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](ch01.html#what_is_ebpf_and_why_is_it_importantque)中看到的，当用户空间应用程序希望内核代表它们执行某些操作时，它们会使用系统调用API发出请求。因此，如果用户空间应用程序希望将eBPF程序加载到内核中，必须涉及一些系统调用。实际上，有一个名为`bpf()`的系统调用，在本章中我将向您展示如何使用它来加载和与eBPF程序和映射进行交互。
- en: It’s worth noting that the eBPF code running in the kernel does not use syscalls
    to access maps. The syscall interface is only used by user space applications.
    Instead, eBPF programs use helper functions to read and write to maps; you already
    saw examples of this in the previous two chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，运行在内核中的eBPF代码不使用系统调用来访问映射。系统调用接口仅由用户空间应用程序使用。相反，eBPF程序使用辅助函数来读取和写入映射；您在前两章中已经看到了这方面的示例。
- en: If you go on to write eBPF programs yourself, there’s a good chance you won’t
    directly call these `bpf()` system calls yourself. There are libraries that I’ll
    discuss later in the book that offer higher-level abstractions to make things
    easier. That said, those abstractions generally map pretty directly to the underlying
    syscall commands you’ll see in this chapter. Whatever library you’re using, you’ll
    need a grasp of the underlying operations—loading a program, creating and accessing
    maps, and so on—that you’ll see in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您继续自己编写eBPF程序，您很有可能不会直接调用这些`bpf()`系统调用。本书后面将讨论的库提供了更高级的抽象，使事情变得更容易。也就是说，这些抽象通常与您在本章中看到的底层系统调用命令相当直接地对应。无论您使用哪个库，您都需要掌握底层操作——加载程序，创建和访问映射等——这些操作您将在本章中看到。
- en: 'Before I show you examples of `bpf()` system calls, let’s consider what the
    [manpage for `bpf()` says](https://oreil.ly/NJdIM), which is that `bpf()` is used
    to “perform a command on an extended BPF map or program.” It also tells us that
    `bpf()`’s signature is as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示`bpf()`系统调用的示例之前，让我们考虑一下[`bpf()`的manpage](https://oreil.ly/NJdIM)所说的，即`bpf()`用于“对扩展BPF映射或程序执行命令”。它还告诉我们，`bpf()`的签名如下：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`The first argument to `bpf()`, `cmd`, specifies which command to perform.
    The `bpf()` syscall doesn’t just do one thing—there are lots of different commands
    that can be used to manipulate eBPF programs and maps. [Figure 4-1](#a_userspace_program_interacts_with_ebpf)
    shows an overview of some of the common commands the user space code might use
    to load eBPF programs, create maps, attach programs to events, and access the
    key–value pairs in a map.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpf()`的第一个参数`cmd`指定要执行的命令。`bpf()`系统调用不仅仅执行一项任务——有许多不同的命令可用于操作eBPF程序和映射。[图4-1](#a_userspace_program_interacts_with_ebpf)概述了用户空间代码可能用于加载eBPF程序、创建映射、将程序附加到事件以及访问映射中键-值对的一些常见命令。'
- en: '![A user space program interacts with eBPF programs and maps in the kernel
    using syscalls](assets/lebp_0401.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![用户空间程序使用syscalls与内核中的eBPF程序和映射进行交互](assets/lebp_0401.png)'
- en: Figure 4-1\. A userspace program interacts with eBPF programs and maps in the
    kernel using syscalls
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。用户空间程序使用syscalls与内核中的eBPF程序和映射进行交互
- en: The `attr` argument to the `bpf()` syscall holds whatever data is needed to
    specify the parameters for the command, and `size` indicates how many bytes of
    data there are in `attr`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpf()`系统调用的`attr`参数保存着指定命令参数所需的任何数据，`size`指示`attr`中有多少字节的数据。'
- en: You already met `strace` in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    when I used it to show how user space code makes many requests across the syscall
    API. In this chapter I’ll use it to demonstrate how the `bpf()` syscall is used.
    The output from `strace` includes the arguments to each syscall, but to keep the
    example output in this chapter from being too cluttered, I’ll omit lots of the
    details from the `attr` arguments unless they are particularly interesting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第1章](ch01.html#what_is_ebpf_and_why_is_it_importantque)中已经遇到了`strace`，当时我用它来展示用户空间代码如何通过系统调用API发出许多请求。在本章中，我将使用它来演示`bpf()`系统调用的使用。`strace`的输出包括每个系统调用的参数，但为了避免本章中的示例输出过于混乱，我将省略`attr`参数中的许多细节，除非它们特别有趣。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the code, along with instructions for setting up an environment
    to run it in, at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter4* directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)找到代码，以及设置运行环境的说明。本章的代码位于*chapter4*目录中。
- en: For this example I’m going to use a BCC program called *hello-buffer-config.py*,
    which builds on the examples you saw in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    Like the *hello-buffer.py* example, this program sends a message to the perf buffer
    whenever it runs, conveying information from the kernel to user space about `execve()`
    syscall events. What’s new in this version is that it allows for different messages
    to be configured for each user ID.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我将使用一个名为*hello-buffer-config.py*的BCC程序，它在您在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中看到的示例基础上进行了扩展。与*hello-buffer.py*示例一样，该程序在每次运行时都向perf缓冲区发送消息，将内核中关于`execve()`系统调用事件的信息传递给用户空间。这个版本的新功能是允许为每个用户ID配置不同的消息。
- en: 'Here’s the eBPF source code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是eBPF源代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#code_id_4_1)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_1)'
- en: This line indicates that there’s a structure definition, `user_msg_t`, for holding
    a 12-character message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行表明有一个结构定义`user_msg_t`，用于保存一个12字符的消息。
- en: '[![2](assets/2.png)](#code_id_4_2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_2)'
- en: The BCC macro `BPF_HASH` is used to define a hash table map called `config`.
    It will hold values of type `user_msg_t`, indexed by keys of type `u32`, which
    is the right size for a user ID. (If you don’t specify the types for the keys
    and values, BCC defaults to `u64` for both.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: BCC宏`BPF_HASH`用于定义一个名为`config`的哈希表映射。它将保存`user_msg_t`类型的值，由`u32`类型的键索引，这是一个合适的用户ID大小。（如果您不指定键和值的类型，BCC默认为两者都是`u64`。）
- en: '[![3](assets/3.png)](#code_id_4_3)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_3)'
- en: The perf buffer output is defined in exactly the same way as in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor).
    You can submit arbitrary data to a buffer, so there’s no need to specify any data
    types here…
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 性能缓冲区输出的定义方式与[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中完全相同。您可以向缓冲区提交任意数据，因此这里不需要指定任何数据类型...
- en: '[![4](assets/4.png)](#code_id_4_4)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_4)'
- en: …although in practice, in this example the program always submits a `data_t`
    structure. This is also unchanged from the [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor)
    example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '...尽管在实践中，在这个例子中程序总是提交一个`data_t`结构。这也与[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)的例子没有变化。'
- en: '[![5](assets/5.png)](#code_id_4_5)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_4_5)'
- en: Most of the rest of the eBPF program is unchanged from the `hello()` version
    you saw earlier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分其他的eBPF程序与您之前看到的`hello()`版本没有变化。
- en: '[![6](assets/6.png)](#code_id_4_6)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_4_6)'
- en: The only difference is that having used a helper function to get the user ID,
    the code looks for an entry in the `config` hash map with that user ID as the
    key. If there is a matching entry, the value contains a message that gets used
    instead of the default “Hello World.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，使用了一个辅助函数来获取用户ID后，代码会查找`config`哈希映射中具有该用户ID的条目。如果有匹配的条目，该值包含一个消息，该消息将用于替代默认的“Hello
    World”。
- en: 'The Python code has two additional lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码还有两行额外的内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These define messages in the `config` hash table for user IDs 0 and 501, which
    correspond to the root user and my user ID on this virtual machine. This code
    uses Python’s `ctypes` package to ensure that the key and value have the same
    types as those used in the C definition of `user_msg_t`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义了`config`哈希表中用户ID为0和501的消息，对应于根用户和我在这个虚拟机上的用户ID。这段代码使用Python的`ctypes`包来确保键和值与`user_msg_t`的C定义中使用的类型相同。
- en: 'Here’s some illustrative output from this example, along with the commands
    I ran in a second terminal to obtain it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个例子的一些说明性输出，以及我在第二个终端中运行的命令来获取它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you’ve got an idea of what this program does, I’d like to show you
    the `bpf()` system calls that are used when it runs. I’ll run it again using `strace`,
    specifying `-e bpf` to indicate that I am only interested in seeing the `bpf()`
    syscall:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对这个程序做了解，我想向您展示运行时使用的`bpf()`系统调用。我将再次使用`strace`运行它，指定`-e bpf`以指示我只对`bpf()`系统调用感兴趣：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output you’ll see if you try this yourself shows several calls to this
    syscall. For each, you’ll see the command indicating what the `bpf()` syscall
    should do. The broad outline looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己尝试这个例子，您将看到几次对这个系统调用的调用。对于每个调用，您将看到指示`bpf()`系统调用应该执行什么的命令。大致轮廓如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s examine them one by one. Neither you, the reader, nor I have infinite
    patience, so I won’t discuss every single argument to every single call! I’ll
    focus on the parts that I think really help to tell the story of what’s happening
    when a user space program interacts with an eBPF program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查它们。你，读者，我都没有无限的耐心，所以我不会讨论每次调用的每个参数！我会专注于我认为真正有助于讲述用户空间程序与eBPF程序交互时发生的事情的部分。
- en: Loading BTF Data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载BTF数据
- en: 'The first call to `bpf()` that I see looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的第一个`bpf()`调用看起来像这样：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case the command you can see in the output is `BPF_BTF_LOAD`. This is
    just one of a set of valid commands that are (at least at the time of this writing)
    most comprehensively documented within the kernel source code.^([1](ch04.html#ch04fn1))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您在输出中看到的命令是`BPF_BTF_LOAD`。这只是一组有效命令中的一个（至少在我写作时是如此），最全面的文档在内核源代码中进行了记录。^([1](ch04.html#ch04fn1))
- en: It’s possible that you won’t see a call with this command if you’re using a
    relatively old Linux kernel, as it relates to BTF, or BPF Type Format.^([2](ch04.html#ch04fn2))
    BTF allows eBPF programs to be portable across different kernel versions so that
    you can compile a program on one machine and use it on another, which might be
    using a different kernel version and hence have different kernel data structures.
    I’ll discuss this in more detail in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是相对较旧的Linux内核，可能不会看到带有这个命令的调用，因为它涉及到BTF或BPF类型格式。^([2](ch04.html#ch04fn2))
    BTF允许eBPF程序在不同的内核版本之间可移植，这样您就可以在一台机器上编译程序，并在另一台机器上使用它，后者可能使用不同的内核版本，因此具有不同的内核数据结构。我将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中更详细地讨论这一点。
- en: This call to `bpf()` is loading a blob of BTF data into the kernel, and the
    return code from the `bpf()` system call (`3` in my example) is a file descriptor
    that refers to that data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`bpf()`调用正在将一块BTF数据加载到内核中，`bpf()`系统调用的返回代码（在我的例子中是3）是一个引用该数据的文件描述符。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *file descriptor* is an identifier for an open file (or file-like object).
    If you open a file (with the `open()` or `openat()` system call) the return code
    is a file descriptor, which is then passed as an argument to other syscalls such
    as `read()` or `write()` to perform operations on that file. Here the blob of
    data isn’t exactly a file, but it is given a file descriptor as an identifier
    that can be used for future operations that refer to it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件描述符*是打开文件（或类似文件对象）的标识符。如果您打开一个文件（使用`open()`或`openat()`系统调用），返回的代码是一个文件描述符，然后将其作为参数传递给其他系统调用，如`read()`或`write()`，以执行对该文件的操作。这里的数据块并不完全是一个文件，但它被赋予了一个文件描述符作为标识符，可以用于将来引用它的操作。'
- en: Creating Maps
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建映射
- en: 'The next `bpf()` creates the `output` perf buffer map:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`bpf()`创建`output`性能缓冲区映射：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can probably guess from the command name `BPF_MAP_CREATE` that this call
    creates an eBPF map. You can see that the type of this map is `PERF_EVENT_ARRAY`
    and it is called `output`. The keys and values in this perf event map are 4 bytes
    long. There’s also a limit of four key–value pairs that can be held in this map,
    defined by the field `max_entries`; I’ll explain why there are four entries in
    this map later in this chapter. The return value of `4` is the file descriptor
    for the user space code to access the `output` map.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以从命令名称`BPF_MAP_CREATE`猜到，这个调用创建了一个eBPF映射。您可以看到这个映射的类型是`PERF_EVENT_ARRAY`，它被称为`output`。这个perf事件映射中的键和值都是4个字节长。这个映射中还有一个限制，最多可以容纳四对键值对，由字段`max_entries`定义；我将在本章后面解释为什么这个映射中有四个条目。返回值`4`是用户空间代码访问`output`映射的文件描述符。
- en: 'The next `bpf()` system call in the output creates the `config` map:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的下一个`bpf()`系统调用创建了`config`映射：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This map is defined to be a hash table map, with keys that are 4 bytes long
    (which corresponds to a 32-bit integer that can be used to hold a user ID) and
    values that are 12 bytes long (which matches the length of the `msg_t` structure).
    I didn’t specify the size of the table, so it has been given BCC’s default size
    of 10,240 entries.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射被定义为一个哈希表映射，其键长为4个字节（对应于可以用于保存用户ID的32位整数），值长为12个字节（与`msg_t`结构的长度相匹配）。我没有指定表的大小，所以它被赋予了BCC的默认大小，即10240个条目。
- en: This `bpf()` system call also returns a file descriptor, `5`, which will be
    used to refer to this `config` map in future syscalls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`bpf()`系统调用还返回一个文件描述符`5`，将用于将来的系统调用中引用这个`config`映射。
- en: You can also see the field `btf_fd=3`, which tells the kernel to use the BTF
    file descriptor `3` that was obtained earlier. As you’ll see in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    BTF information describes the layout of data structures, and including this in
    the definition of the map means there’s information about the layout of the key
    and value types used in this map. This is used by tools like `bpftool` to pretty-print
    map dumps, making them human readable—you saw an example of this in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到字段`btf_fd=3`，它告诉内核使用之前获取的BTF文件描述符`3`。正如您将在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的，BTF信息描述了数据结构的布局，并且在映射的定义中包含这些信息意味着有关该映射中使用的键和值类型的布局信息。这被像`bpftool`这样的工具用来漂亮地打印映射转储，使它们可读性强——您在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到了一个例子。
- en: Loading a Program
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载程序
- en: 'So far you have seen the example program using syscalls to load BTF data into
    the kernel and create some eBPF maps. The next thing it does is load the eBPF
    program being loaded into the kernel with the following `bpf()` syscall:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了使用系统调用将BTF数据加载到内核并创建一些eBPF映射的示例程序。它接下来要做的是使用以下`bpf()`系统调用将要加载到内核中的eBPF程序加载到内核中：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Quite a few of the fields here are interesting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的字段：
- en: The `prog_type` field describes the program type, which here indicates that
    it’s intended to be attached to a kprobe. You’ll learn more about program types
    in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog_type`字段描述了程序类型，这里表示它是要附加到kprobe上的。您将在[第7章](ch07.html#ebpf_program_and_attachment_types)中了解更多关于程序类型的信息。'
- en: The `insn_cnt` field means “instruction count.” This is the number of bytecode
    instructions in the program.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insn_cnt`字段表示“指令计数”。这是程序中字节码指令的数量。'
- en: The bytecode instructions that make up this eBPF program are held in memory
    at the address specified in the `insns` field.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成这个eBPF程序的字节码指令保存在`insns`字段中指定的地址中。
- en: This program was specified as GPL licensed so that it can use GPL-licensed BPF
    helper functions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个程序被指定为GPL许可，以便可以使用GPL许可的BPF辅助函数。
- en: The program name is `hello`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序名称是`hello`。
- en: The `expected_attach_type` of `BPF_CGROUP_INET_INGRESS` might seem surprising,
    because that sounds like something to do with ingress network traffic, but you
    know this eBPF program is going to be attached to a kprobe. In fact, the `expected_attach_type`
    field is only used for some program types, and `BPF_PROG_TYPE_KPROBE` isn’t one
    of them. `BPF_CGROUP_INET_INGRESS` just happens to be the first in the list of
    BPF attachment types,^([3](ch04.html#ch04fn3)) so it has the value `0`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expected_attach_type`为`BPF_CGROUP_INET_INGRESS`可能看起来令人惊讶，因为这听起来像是与入口网络流量有关的事情，但是您知道这个eBPF程序将被附加到一个kprobe上。实际上，`expected_attach_type`字段只用于一些程序类型，而`BPF_PROG_TYPE_KPROBE`不是其中之一。`BPF_CGROUP_INET_INGRESS`只是BPF附加类型列表中的第一个，^([3](ch04.html#ch04fn3))所以它的值为`0`。'
- en: The `prog_btf_fd` field tells the kernel which blob of previously loaded BTF
    data to use with this program. The value `3` here corresponds to the file descriptor
    you saw returned from the `BPF_BTF_LOAD` syscall (and it’s the same blob of BTF
    data used for the `config` map).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog_btf_fd`字段告诉内核使用先前加载的BTF数据块与这个程序一起使用。这里的值`3`对应于您从`BPF_BTF_LOAD`系统调用中看到的文件描述符（它是用于`config`映射的相同BTF数据块）。'
- en: If the program had failed verification (which I’ll discuss in [Chapter 6](ch06.html#the_ebpf_verifier)),
    this syscall would have returned a negative value, but here you can see it returned
    the file descriptor 6\. To recap, at this point the file descriptors have the
    meanings shown in [Table 4-1](#file_descriptors_when_running_hello_buf).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序未能通过验证（我将在[第6章](ch06.html#the_ebpf_verifier)中讨论），这个系统调用将返回一个负值，但在这里您可以看到它返回了文件描述符6。回顾一下，在这一点上，文件描述符具有[表4-1](#file_descriptors_when_running_hello_buf)中显示的含义。
- en: Table 4-1\. File descriptors when running hello-buffer-config.py after loading
    the program
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1。加载程序后运行hello-buffer-config.py时的文件描述符
- en: '| File descriptor | Represents |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 文件描述符 | 表示 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `3` | BTF data |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `3` | BTF数据 |'
- en: '| `4` | `output` perf buffer map |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `output` perf缓冲区映射 |'
- en: '| `5` | `config` hash table map |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `config`哈希表映射 |'
- en: '| `6` | `hello` eBPF program |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `hello` eBPF程序 |'
- en: Modifying a Map from User Space
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户空间修改映射
- en: 'You already saw the line in the Python user space source code that configures
    special messages that will be displayed for the root user with user ID 0, and
    for the user with ID 501:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在 Python 用户空间源代码中看到了配置特殊消息的行，这些消息将显示给用户 ID 0 的根用户和用户 ID 501 的用户：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see these entries being defined in the map through syscalls like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过这样的系统调用看到映射中定义的这些条目：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `BPF_MAP_UPDATE_ELEM` command updates the key–value pair in a map. The `BPF_ANY`
    flag indicates that if the key doesn’t already exist in this map, it should be
    created. There are two of these calls, corresponding to the two entries configured
    for two different user IDs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_UPDATE_ELEM` 命令更新映射中的键值对。`BPF_ANY` 标志表示，如果键在此映射中不存在，它将被创建。有两个这样的调用，对应于为两个不同的用户
    ID 配置的两个条目。'
- en: The `map_fd` field identifies which map is being operated on. You can see that
    in this case it’s `5`, which is the file descriptor value returned earlier when
    the `config` map was created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`map_fd` 字段标识正在操作的映射。您可以看到在这种情况下它是 `5`，这是之前创建 `config` 映射时返回的文件描述符值。'
- en: File descriptors are assigned by the kernel for a particular process, so this
    value of `5` is only valid for this particular user space process in which the
    Python program is running. However, multiple user space programs (and multiple
    eBPF programs in the kernel) can all access the same map. Two user space programs
    that access the same map structure in the kernel might very well be assigned different
    file descriptor values; equally, two user space programs might have the same file
    descriptor value for entirely different maps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符由内核为特定进程分配，因此 `5` 的值仅对 Python 程序运行的特定用户空间进程有效。然而，多个用户空间程序（和内核中的多个 eBPF
    程序）都可以访问同一个映射。访问内核中相同映射结构的两个用户空间程序可能会被分配不同的文件描述符值；同样，两个用户空间程序可能对完全不同的映射具有相同的文件描述符值。
- en: 'Both the key and the value are pointers, so you can’t tell the numeric value
    of either the key or the value from this `strace` output. You could, however,
    use `bpftool` to view the map’s contents and see something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值都是指针，因此您无法从这个 `strace` 输出中得知键或值的数值。但是，您可以使用 `bpftool` 查看映射的内容，并看到类似这样的内容：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How does `bpftool` know how to format this output? For example, how does it
    know the value is a structure, with a field called `message` that contains a string?
    The answer is that it uses the definitions in the BTF information included on
    the `BPF_MAP_CREATE` syscall that defined this map. You’ll see more details on
    how BTF conveys this information in the next chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool` 如何知道如何格式化这个输出？例如，它如何知道值是一个包含字符串的结构，名为 `message`？答案是它使用了在 `BPF_MAP_CREATE`
    系统调用中包含的 BTF 信息中的定义来传达这些信息。您将在下一章中看到有关 BTF 如何传达这些信息的更多细节。'
- en: You’ve now seen how user space interacts with the kernel to load programs and
    maps and to update the information in a map. In the sequence of syscalls you have
    seen up to this point, the program hasn’t yet been attached to an event. This
    step has to happen; otherwise, the program will never be triggered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了用户空间如何与内核交互以加载程序和映射，并更新映射中的信息。在您到目前为止看到的系统调用序列中，程序尚未附加到事件上。这一步必须发生；否则，程序将永远不会被触发。
- en: 'Fair warning: different types of eBPF programs get attached to different events
    in a variety of different ways! Later in this chapter I’ll show you the syscalls
    used in this example to attach to the kprobe event, and in this case it doesn’t
    involve `bpf()`. In contrast, in the exercises at the end of this chapter I will
    show you another example where a `bpf()` syscall is used to attach a program to
    a raw tracepoint event.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 公平警告：不同类型的 eBPF 程序以各种不同的方式附加到不同的事件上！本章后面我会向您展示在此示例中用于附加到 kprobe 事件的系统调用，而在这种情况下不涉及
    `bpf()`。相比之下，在本章末尾的练习中，我将向您展示另一个示例，其中使用 `bpf()` 系统调用将程序附加到原始 tracepoint 事件。
- en: Before we get to those details, I’d like to discuss what happens when you quit
    running the program. You’ll find that the program and maps are automatically unloaded,
    and this happens because the kernel is keeping track of them using *reference
    counts*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论这些细节之前，我想讨论一下当您停止运行程序时会发生什么。您会发现程序和映射会自动卸载，这是因为内核使用*引用计数*来跟踪它们。
- en: BPF Program and Map References
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF 程序和映射引用
- en: You know that loading a BPF program into the kernel with the `bpf()` syscall
    returns a file descriptor. Within the kernel, this file descriptor is a *reference*
    to the program. The user space process that made the syscall owns this file descriptor;
    when that process exits, the file descriptor gets released, and the reference
    count to the program is decremented. When there are no references left to a BPF
    program, the kernel removes the program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道使用 `bpf()` 系统调用将 BPF 程序加载到内核会返回一个文件描述符。在内核中，这个文件描述符是对程序的*引用*。进行系统调用的用户空间进程拥有这个文件描述符；当该进程退出时，文件描述符被释放，对程序的引用计数减少。当没有对
    BPF 程序的引用时，内核会移除该程序。
- en: An additional reference is created when you *pin* a program to the filesystem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序*固定*到文件系统时会创建额外的引用。
- en: Pinning
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定
- en: 'You already saw pinning in action in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到了固定的实际操作，使用以下命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These pinned objects aren’t real files persisted to disk. They are created on
    a *pseudo filesystem*, which behaves like a regular disk-based filesystem with
    directories and files. But they are held in memory, which means they will not
    remain in place over a system reboot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些固定的对象并不是持久保存到磁盘的真实文件。它们是在*伪文件系统*上创建的，它的行为类似于常规的基于磁盘的文件系统，具有目录和文件。但它们保存在内存中，这意味着它们在系统重启后不会保留在原地。
- en: If `bpftool` were to allow you to load the program without pinning it, that
    would be pointless, because the file descriptor gets released when `bpftool` exits,
    and if there are zero references, the program would get deleted, so nothing useful
    would have been achieved. But pinning it to the filesystem means there is an additional
    reference to the program, so the program remains loaded after the command completes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bpftool`允许您加载程序而不将其固定，那将是没有意义的，因为当`bpftool`退出时，文件描述符会被释放，如果引用计数为零，则程序将被删除，因此将无法实现任何有用的功能。但是将其固定到文件系统意味着程序有了额外的引用，因此在命令完成后程序仍然保持加载状态。
- en: 'The reference counter also gets incremented when a BPF program is attached
    to a hook that will trigger it. The behavior of these reference counts depends
    on the BPF program type. You’ll learn more about these program types in [Chapter 7](ch07.html#ebpf_program_and_attachment_types),
    but there are some that relate to tracing (like kprobes and tracepoints) and are
    always associated with a user space process; for these types of eBPF programs,
    the kernel’s reference count gets decremented when that process exits. Programs
    that are attached within the network stack or cgroups (short for “control groups”)
    aren’t associated with any user space process, so they stay in place even after
    the user space program that loads them exits. You already saw an example of this
    when loading an XDP program with the `ip link` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当将BPF程序附加到将触发它的钩子时，引用计数器也会递增。这些引用计数的行为取决于BPF程序类型。您将在[第7章](ch07.html#ebpf_program_and_attachment_types)中了解更多关于这些程序类型的信息，但其中一些与跟踪相关（如kprobes和tracepoints），并且始终与用户空间进程相关联；对于这些类型的eBPF程序，当该进程退出时，内核的引用计数会递减。在网络堆栈或cgroups（“控制组”的缩写）中附加的程序不与任何用户空间进程相关联，因此即使加载它们的用户空间程序退出，它们也会保持在原地。当使用`ip
    link`命令加载XDP程序时，您已经看到了这种情况的一个示例：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ip` command has completed, and there is no definition of a pinned location,
    but nevertheless, `bpftool` will show you that the XDP program is loaded in the
    kernel:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip`命令已经完成，并且没有固定位置的定义，但是`bpftool`将向您显示XDP程序已加载到内核中：'
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The reference count for this program is nonzero, because of the attachment to
    the XDP hook that persisted after the `ip link` command completed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的引用计数为非零，因为它附加到`ip link`命令完成后仍然存在的XDP钩子上。
- en: eBPF maps also have reference counters, and they get cleaned up when their reference
    count drops to zero. Each eBPF program that uses a map increments the counter,
    as does each file descriptor that user space programs might hold to the map.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF映射也有引用计数器，当引用计数降至零时，它们将被清除。每个使用映射的eBPF程序都会增加计数器，用户空间程序可能持有的每个文件描述符也会增加计数器。
- en: It’s possible that the source code for an eBPF program might define a map that
    the program doesn’t actually reference. Suppose you wanted to store some metadata
    about a program; you could define it as a global variable, and as you saw in the
    previous chapter, this information gets stored in a map. If the eBPF program doesn’t
    do anything with that map, there won’t automatically be a reference count from
    the program to the map. There’s a `BPF(BPF_PROG_BIND_MAP)` syscall that associates
    a map with a program so that the map doesn’t get cleaned up as soon as the user
    space loader program exits and is no longer holding a file descriptor reference
    to the map.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序的源代码可能定义一个映射，该程序实际上并不引用。假设您想要存储有关程序的一些元数据；您可以将其定义为全局变量，并且正如您在上一章中看到的那样，这些信息将存储在映射中。如果eBPF程序对该映射不执行任何操作，则程序到映射的引用计数不会自动增加。有一个`BPF(BPF_PROG_BIND_MAP)`系统调用，它将映射与程序关联起来，以便在用户空间加载程序退出并不再持有映射的文件描述符引用时，映射不会立即被清除。
- en: Maps can also be pinned to the filesystem, and user space programs can gain
    access to the map by knowing the path to the map.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 映射也可以固定到文件系统，用户空间程序可以通过知道映射的路径来访问映射。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Alexei Starovoitov wrote a good description of BPF reference counters and file
    descriptors in his blog post [“Lifetime of BPF Objects”](https://oreil.ly/vofxH).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Alexei Starovoitov在他的博客文章[“BPF对象的生命周期”](https://oreil.ly/vofxH)中对BPF引用计数和文件描述符进行了很好的描述。
- en: Another way to create a reference to a BPF program is with a BPF link.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对BPF程序的引用的另一种方法是使用BPF链接。
- en: BPF Links
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPF链接
- en: BPF links provide a layer of abstraction between an eBPF program and the event
    it’s attached to. A BPF link itself can be pinned to the filesystem, which creates
    an additional reference to the program. This means the user space process that
    loaded the program into the kernel can terminate, leaving the program loaded.
    The file descriptor for the user space loader program gets freed up, decreasing
    the count of references to the program, but the reference count will be nonzero
    because of the BPF link.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: BPF链接为eBPF程序和其附加的事件之间提供了一层抽象。BPF链接本身可以固定到文件系统，这会为程序创建一个额外的引用。这意味着将程序加载到内核中的用户空间进程可以终止，而程序仍然保持加载状态。用户空间加载程序的文件描述符被释放，减少了对程序的引用计数，但由于BPF链接的存在，引用计数仍将为非零。
- en: You’ll get an opportunity to see BPF links in action if you follow the exercises
    at the end of this chapter. For now, let’s get back to the sequence of `bpf()`
    syscalls used by *hello-buffer-config.py*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照本章末尾的练习，您将有机会看到BPF链接的实际应用。现在，让我们回到*hello-buffer-config.py*使用的`bpf()`系统调用序列。
- en: Additional Syscalls Involved in eBPF
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eBPF中涉及的其他系统调用
- en: To recap, so far you have seen `bpf()` syscalls that add the BTF data, program
    and maps, and map data to the kernel. The next thing the `strace` output shows
    relates to setting up the perf buffer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，您已经看到了`bpf()`系统调用，该调用将BTF数据、程序和映射数据添加到内核中。`strace`输出显示的下一步是设置perf缓冲区。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The rest of this chapter dives relatively deeply into the syscall sequences
    involved when using perf buffers, ring buffers, kprobes, and map iterations. Not
    all eBPF programs need to do these things, so if you’re in a hurry or you’re finding
    it a bit too detailed, feel free to skip to the chapter summary. I won’t be offended!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分相对深入地介绍了使用性能缓冲区、环形缓冲区、kprobes和映射迭代时涉及的系统调用序列。并非所有的eBPF程序都需要执行这些操作，因此如果您赶时间或者觉得太详细，可以随意跳到章节摘要。我不会生气的！
- en: Initializing the Perf Buffer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化性能缓冲区
- en: 'You have seen the `bpf(BPF_MAP_UPDATE_ELEM)` calls that add entries into the
    `config` map. Next, the output shows some calls that look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了将条目添加到“config”映射的“bpf（BPF_MAP_UPDATE_ELEM）”调用。接下来，输出显示了一些看起来像这样的调用：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These look very similar to the calls that defined the `config` map entries,
    except in this case the map’s file descriptor is `4`, which represents the `output`
    perf buffer map.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来与定义“config”映射条目的调用非常相似，只是在这种情况下，映射的文件描述符是“4”，代表“output”性能缓冲区映射。
- en: 'As before, the key and the value are pointers, so you can’t tell the numeric
    value of either the key or the value from this `strace` output. I see this syscall
    repeated four times with identical values for all the parameters, though there’s
    no way of knowing whether the values the pointers hold have changed between each
    call. Looking at these `BPF_MAP_UPDATE_ELEM bpf()` calls leaves some unanswered
    questions about how the buffer is set up and used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，键和值都是指针，因此您无法从这个“strace”输出中知道键或值的数值。我看到这个系统调用重复了四次，所有参数的值都相同，尽管无法知道指针保存的值在每次调用之间是否发生了变化。查看这些“BPF_MAP_UPDATE_ELEM
    bpf（）”调用留下了一些关于如何设置和使用缓冲区的未解答问题：
- en: Why are there four calls to `BPF_MAP_UPDATE_ELEM`? Does this relate to the fact
    that the `output` map was created with a maximum of four entries?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有四次调用“BPF_MAP_UPDATE_ELEM”？这是否与“output”映射创建了最多四个条目有关？
- en: After these four instances of `BPF_MAP_UPDATE_ELEM`, no more `bpf()` syscalls
    appear in the `strace` output. That might seem a little odd, because the map is
    there so that the eBPF program can write data every time it is triggered, and
    you’ve seen data being displayed by the user space code. That data is clearly
    not being retrieved from the map with `bpf()` syscalls, so how is it obtained?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这四个“BPF_MAP_UPDATE_ELEM”实例之后，“strace”输出中不再出现“bpf（）”系统调用。这可能看起来有点奇怪，因为映射是为了让eBPF程序在每次触发时写入数据，而您已经看到用户空间代码显示了数据。显然，这些数据并不是通过“bpf（）”系统调用从映射中获取的，那么它是如何获取的呢？
- en: 'You’ve also yet to see any evidence of how the eBPF program is getting attached
    to the kprobe event that triggers it. To get the explanation for all these concerns,
    I need `strace` to show a few more syscalls when running this example, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您还没有看到任何证据表明eBPF程序是如何附加到触发它的kprobe事件的。为了解释所有这些问题，我需要“strace”在运行此示例时显示更多的系统调用，就像这样：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For brevity, I’m going to ignore calls to `ioctl()` that aren’t specifically
    related to the eBPF functionality of this example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，我将忽略与本示例的eBPF功能无关的“ioctl（）”调用。
- en: Attaching to Kprobe Events
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到Kprobe事件
- en: 'You’ve seen that file descriptor 6 was assigned to represent the eBPF program
    *hello* once it was loaded into the kernel. To attach the eBPF program to an event,
    you also need a file descriptor representing that particular event. The following
    line from the `strace` output shows the creation of the file descriptor for the
    `execve()` kprobe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到文件描述符6被分配为表示eBPF程序* hello*一旦加载到内核中。要将eBPF程序附加到事件，您还需要一个表示特定事件的文件描述符。来自“strace”输出的以下行显示了为“execve（）”kprobe创建文件描述符：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'According to the [manpage for the `perf_event_open()` syscall](https://oreil.ly/xpRJs),
    it “creates a file descriptor that allows measuring performance information.”
    You can see from the output that `strace` doesn’t know how to interpret the type
    parameter with the value `6`, but if you examine that manpage further, it describes
    how Linux supports dynamic types of Performance Measurement Unit:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[“perf_event_open（）系统调用的manpage”](https://oreil.ly/xpRJs)，它“创建一个允许测量性能信息的文件描述符。”您可以从输出中看到，“strace”不知道如何解释值为“6”的类型参数，但是如果您进一步查看该manpage，它描述了Linux如何支持动态类型的性能测量单元：
- en: …there is a subdirectory per PMU instance under */sys/bus/event_source/devices*.
    In each subdirectory there is a type file whose content is an integer that can
    be used in the type field.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …在*/sys/bus/event_source/devices*下每个PMU实例都有一个子目录。在每个子目录中，都有一个类型文件，其内容是可以在类型字段中使用的整数。
- en: 'Sure enough, if you look under that directory, you’ll find a *kprobe/type*
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看该目录，您会发现一个*kprobe/type*文件：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From this, you can see that the call to `perf_event_open()` has a type set to
    the value `6` to indicate that it’s a kprobe type of perf event.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，“perf_event_open（）”的调用类型设置为值“6”，表示这是一种kprobe类型的性能事件。
- en: Unfortunately, `strace` doesn’t output the details that would conclusively show
    that the kprobe is attached to the `execve()` syscall, but I hope there is enough
    evidence here to convince you that that’s what the file descriptor returned here
    represents.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，“strace”没有输出细节，可以明确显示kprobe是否附加到“execve（）”系统调用，但我希望这里有足够的证据来说服你，这就是这里返回的文件描述符代表的内容。
- en: 'The return code from `perf_event_open()` is `7`, and this represents the file
    descriptor for the kprobe’s perf event, and you know that file descriptor `6`
    represents the *hello* eBPF program. The manpage for `perf_event_open()` also
    explains how to use `ioctl()` to create the attachment between the two:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “perf_event_open（）”的返回代码是“7”，这代表了kprobe的性能事件的文件描述符，您知道文件描述符“6”代表了*hello* eBPF程序。
    “perf_event_open（）”的manpage还解释了如何使用“ioctl（）”在两者之间创建附件：
- en: '`PERF_EVENT_IOC_SET_BPF` [...] allows attaching a Berkeley Packet Filter (BPF)
    program to an existing kprobe tracepoint event. The argument is a BPF program
    file descriptor that was created by a previous `bpf(2)` system call.'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`PERF_EVENT_IOC_SET_BPF` [...] 允许将伯克利数据包过滤器（BPF）程序附加到现有的kprobe跟踪点事件上。参数是之前由`bpf(2)`系统调用创建的BPF程序文件描述符。'
- en: 'This explains the following `ioctl()` syscall that you’ll see in the `strace`
    output, with arguments referring to the two file descriptors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了您在`strace`输出中看到的以下`ioctl()`系统调用，其参数指的是两个文件描述符：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is also another `ioctl()` call that turns the kprobe event on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个`ioctl()`调用，用于打开kprobe事件：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this in place, the eBPF program should be triggered whenever `execve()`
    is run on this machine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，只要在这台机器上运行`execve()`，eBPF程序就会被触发。
- en: Setting Up and Reading Perf Events
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和读取性能事件
- en: 'I already mentioned that I see four calls to `bpf(BPF_MAP_UPDATE_ELEM)` related
    to the output perf buffer. With the additional syscalls being traced, the `strace`
    output shows four sequences, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到我看到了四次与输出性能缓冲区相关的`bpf(BPF_MAP_UPDATE_ELEM)`调用。随着额外的系统调用被跟踪，`strace`输出显示了四个类似这样的序列：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I’ve used `X` to indicate where the output shows values `0`, `1`, `2`, and
    `3` in the four instances of this call. Referring to the manpage for the `perf_event_open()`
    syscall, you’ll see that this is the `cpu`, and the field before it is `pid` or
    process ID. From the manpage:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`X`表示输出中的四个实例中的值`0`，`1`，`2`和`3`。参考`perf_event_open()`系统调用的manpage，您会发现这是`cpu`，在它之前的字段是`pid`或进程ID。来自manpage的内容：
- en: pid == -1 and cpu >= 0
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pid == -1 and cpu >= 0
- en: '>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: This measures all processes/threads on the specified CPU.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这会测量指定CPU上的所有进程/线程。
- en: 'The fact that this sequence happens four times corresponds to there being four
    CPU cores in my laptop. This, at last, is the explanation for why there are four
    entries in the “output” perf buffer map: there is one for each CPU core. It also
    explains the “array” part of the map type name `BPF_MAP_TYPE_PERF_EVENT_ARRAY`,
    as the map doesn’t just represent one perf ring buffer but an array of buffers,
    one for each core.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列发生四次的事实对应于我的笔记本电脑上有四个CPU核心。这最终解释了“输出”性能缓冲区映射中有四个条目的原因：每个CPU核心都有一个。这也解释了映射类型名称`BPF_MAP_TYPE_PERF_EVENT_ARRAY`中的“数组”部分，因为该映射不仅代表一个性能环形缓冲区，还代表一个缓冲区数组，每个核心一个。
- en: If you write eBPF programs, you won’t need to worry about details like handling
    the number of cores, as this will be taken care of for you by any of the eBPF
    libraries discussed in [Chapter 10](ch10.html#ebpf_programming), but I think it’s
    an interesting aspect of the syscalls you see when you use `strace` on this program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写eBPF程序，您不需要担心处理核心数量等细节，因为这将由[第10章](ch10.html#ebpf_programming)中讨论的任何eBPF库为您处理，但我认为这是您在使用`strace`时看到的系统调用的一个有趣方面。
- en: The `perf_event_open()` calls each return a file descriptor, which I’ve represented
    as `Y`; these have the values `8`, `9`, `10`, and `11`. The `ioctl()` syscalls
    enable the perf output for each of these file descriptors. The `BPF_MAP_UPDATE_ELEM
    bpf()` syscalls set the map entry to point to the perf ring buffer for each CPU
    core to indicate where it can submit data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`perf_event_open()`调用都会返回一个文件描述符，我用`Y`表示；这些值分别为`8`，`9`，`10`和`11`。`ioctl()`系统调用为这些文件描述符中的每一个启用了性能输出。`BPF_MAP_UPDATE_ELEM
    bpf()`系统调用设置了映射条目，指向每个CPU核心的性能环形缓冲区，以指示它可以提交数据的位置。
- en: 'User space code can then use `ppoll()` on all four of these output stream file
    descriptors so that it can get the data output, whichever core happens to run
    the eBPF program *hello* for any given `execve()` kprobe event. Here’s the syscall
    to `ppoll()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间代码可以在所有四个输出流文件描述符上使用`ppoll()`，以便它可以获取数据输出，无论哪个核心运行eBPF程序*hello*来执行任何给定的`execve()`
    kprobe事件。这是对`ppoll()`的系统调用：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you’ll see if you try running the example program yourself, these `ppoll()`
    calls block until there is something to read from one of the file descriptors.
    You won’t see the return code written to the screen until something triggers `execve()`,
    which causes the eBPF program to write data that user space retrieves using this
    `ppoll()` call.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试自己运行示例程序，您会发现这些`ppoll()`调用会阻塞，直到有数据从其中一个文件描述符中读取出来。直到触发`execve()`，才会看到返回代码写入屏幕，这会导致eBPF程序写入数据，用户空间使用`ppoll()`调用检索数据。
- en: In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I mentioned
    that if you have a kernel of version 5.8 or above, BPF ring buffers are now preferred
    over perf buffers.^([4](ch04.html#ch04fn4)) Let’s take a look at a modified version
    of the same example code that uses a ring buffer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中，我提到如果您的内核版本为5.8或更高，现在更倾向于使用BPF环形缓冲区而不是性能缓冲区。^([4](ch04.html#ch04fn4))
    让我们看一下使用环形缓冲区的相同示例代码的修改版本。
- en: Ring Buffers
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环形缓冲区
- en: As discussed in the [kernel documentation](https://oreil.ly/RN_RA), ring buffers
    are preferred over perf buffers partly for performance reasons, but also to ensure
    that the ordering of data is preserved, even if the data is submitted by different
    CPU cores. There is just one buffer, shared across all cores.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如[内核文档](https://oreil.ly/RN_RA)中所讨论的，环形缓冲区比性能缓冲区更受欢迎，部分原因是性能，但也是为了确保数据的顺序被保留，即使数据由不同的CPU核心提交。只有一个缓冲区，跨所有核心共享。
- en: There aren’t many changes needed to convert *hello-buffer-config.py* to use
    a ring buffer. In the accompanying GitHub repo you’ll find this example as *chapter4/hello-ring-buffer-config.py*.
    [Table 4-2](#differences_between_example_bcc_code_us) shows the differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将*hello-buffer-config.py*转换为使用环形缓冲区并不需要太多更改。在附带的GitHub存储库中，您会发现这个示例作为*chapter4/hello-ring-buffer-config.py*。[表4-2](#differences_between_example_bcc_code_us)显示了差异。
- en: Table 4-2\. Differences between example BCC code using a perf buffer and a ring
    buffer
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2。使用性能缓冲区和环形缓冲区的示例BCC代码之间的差异
- en: '| *hello-buffer-config.py* | *hello-ring-buffer-config.py* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| *hello-buffer-config.py* | *hello-ring-buffer-config.py* |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BPF_PERF_OUTPUT(output);` | `BPF_RINGBUF_OUTPUT(output, 1);` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `BPF_PERF_OUTPUT(output);` | `BPF_RINGBUF_OUTPUT(output, 1);` |'
- en: '| `output.perf_submit(ctx, &data, sizeof(data));` | `output.ringbuf_output(&data,
    sizeof(data), 0);` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `output.perf_submit(ctx, &data, sizeof(data));` | `output.ringbuf_output(&data,
    sizeof(data), 0);` |'
- en: '| `b["output"]. open_perf_buffer(print_event)` | `b["output"]. open_ring_buffer(print_event)`
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `b["output"]. open_perf_buffer(print_event)` | `b["output"]. open_ring_buffer(print_event)`
    |'
- en: '| `b.perf_buffer_poll()` | `b.ring_buffer_poll()` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `b.perf_buffer_poll()` | `b.ring_buffer_poll()` |'
- en: As you’d expect, since these changes relate only to the `output` buffer, the
    syscalls related to loading the program and the `config` map and attaching the
    program to the kprobe event all remain unchanged.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，由于这些更改仅涉及 `output` 缓冲区，因此与加载程序和 `config` 映射以及将程序附加到 kprobe 事件相关的系统调保持不变。
- en: 'The `bpf()` syscall that creates the `output` ring buffer map looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `output` 环形缓冲映射的 `bpf()` 系统调看起来是这样的：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The major difference in the `strace` output is that there is no sign of the
    series of four different `perf_event_open()`, `ioctl()`, and `bpf(BPF_MAP_UPDATE_ELEM)`
    system calls that you observed during the setup of a perf buffer. For a ring buffer,
    there’s just the one file descriptor shared across all CPU cores.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 输出中的主要差异在于，在设置 perf 缓冲区时，没有出现您在一系列四个不同的 `perf_event_open()`、`ioctl()`
    和 `bpf(BPF_MAP_UPDATE_ELEM)` 系统调期间观察到的情况。对于环形缓冲区，只有一个文件描述符在所有 CPU 核心之间共享。'
- en: At the time of this writing, BCC is using the `ppoll` mechanism I showed earlier
    for perf buffers, but it uses the newer `epoll` mechanism to wait for data from
    the ring buffer. Let’s use this as an opportunity to understand the difference
    between `ppoll` and `epoll`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，BCC 使用了我之前展示的 perf 缓冲区的 `ppoll` 机制，但它使用了更新的 `epoll` 机制来等待环形缓冲区中的数据。让我们利用这个机会来了解
    `ppoll` 和 `epoll` 之间的区别。
- en: 'In the perf buffer example, I showed *hello-buffer-config.py* generating a
    `ppoll()` syscall, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '在 perf 缓冲区示例中，我展示了 *hello-buffer-config.py* 生成了一个 `ppoll()` 系统调，如下所示： '
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that this passes in the set of file descriptors `8`, `9`, `10`, and `11`
    from which the user space process wants to retrieve data. Every time this poll
    event returns data, another call has to be made to `ppoll()` to set up the same
    set of file descriptors all over again. When using `epoll`, the file descriptor
    set is managed in a kernel object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会传入文件描述符集 `8`、`9`、`10` 和 `11`，用户空间进程希望从中检索数据。每次此轮询事件返回数据时，都必须再次调用 `ppoll()`
    来设置相同的文件描述符集。使用 `epoll` 时，文件描述符集在内核对象中进行管理。
- en: You can see this in the following sequence of `epoll`-related system calls made
    when *hello-ring-buffer-config.py* is setting up access to the `output` ring buffer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *hello-ring-buffer-config.py* 设置对 `output` 环形缓冲区的访问时所做的一系列 `epoll` 相关系统调中看到这一点。
- en: 'First, the user space program asks for a new `epoll` instance to be created
    in the kernel:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户空间程序要求在内核中创建一个新的 `epoll` 实例：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This returns file descriptor `8`. Then there is a call to `epoll_ctl()`, which
    tells the kernel to add file descriptor `4` (the `output` buffer) to the set of
    file descriptors in that `epoll` instance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回文件描述符 `8`。然后调用 `epoll_ctl()`，告诉内核将文件描述符 `4`（`output` 缓冲区）添加到该 `epoll` 实例的文件描述符集中：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The user space program uses `epoll_pwait()` to wait until data is available
    in the ring buffer. This call only returns when data is available:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序使用 `epoll_pwait()` 等待环形缓冲区中有数据可用。只有在有数据可用时，此调用才会返回：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, if you’re writing code using a framework like BCC (or *libbpf* or
    any of the other libraries I’ll describe later in this book), you really don’t
    need to know these underlying details about how your user space application gets
    information from the kernel via perf or ring buffers. I hope you’ve found it interesting
    to get a peek under the covers to see how these things work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您正在使用像 BCC（或 *libbpf* 或我稍后在本书中描述的任何其他库）这样的框架编写代码，您实际上不需要了解有关用户空间应用程序如何通过
    perf 或环形缓冲区从内核获取信息的这些基础细节。我希望您发现了解这些工作原理的底层细节很有趣。
- en: However, you might well find yourself writing code that accesses a map from
    user space, and it might be helpful to see an example of how this is achieved.
    Earlier in this chapter, I used `bpftool` to examine the contents of the `config`
    map. Since it’s a utility that runs in user space, let’s use `strace` to see what
    syscalls it’s making to retrieve this information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会发现自己编写的代码访问了用户空间的映射，并且看到如何实现这一点可能会有所帮助。在本章的前面，我使用 `bpftool` 检查了 `config`
    映射的内容。由于它是在用户空间运行的实用程序，让我们使用 `strace` 来查看它用于检索此信息的系统调用。
- en: Reading Information from a Map
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从映射中读取信息
- en: 'The following command shows an extract of the `bpf()` syscalls that `bpftool`
    makes while reading the contents of the `config` map:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了 `bpftool` 在读取 `config` 映射内容时所做的 `bpf()` 系统调的摘录：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you’ll see, the sequence consists of two main steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，该序列由两个主要步骤组成：
- en: Iterate through all the maps, looking for any with the name `config`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历所有映射，查找其中名称为 `config` 的映射。
- en: If a matching map is found, iterate through all the elements in that map.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配的映射，则遍历该映射中的所有元素。
- en: Finding a Map
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找映射
- en: 'The output starts with a repeated sequence of similar calls, as `bpftool` walks
    through all the maps looking for any with the name `config`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以重复的类似调用序列开始，因为 `bpftool` 遍历所有映射，查找其中名称为 `config` 的映射：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#code_id_4_7)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_7)'
- en: '`BPF_MAP_GET_NEXT_ID` gets the ID of the next map after the value specified
    in `start_id`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_GET_NEXT_ID` 获取指定 `start_id` 后的下一个映射的 ID。'
- en: '[![2](assets/2.png)](#code_id_4_8)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_8)'
- en: '`BPF_MAP_GET_FD_BY_ID` returns the file descriptor for the specified map ID.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_MAP_GET_FD_BY_ID` 返回指定映射 ID 的文件描述符。'
- en: '[![3](assets/3.png)](#code_id_4_9)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_9)'
- en: '`BPF_OBJ_GET_INFO_BY_FD` retrieves information about the object (in this case,
    the map) referred to by the file descriptor. This information includes its name
    so `bpftool` can check whether this is the map it is looking for.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_OBJ_GET_INFO_BY_FD` 通过文件描述符检索有关对象（在本例中为映射）的信息。此信息包括其名称，因此 `bpftool` 可以检查这是否是它正在寻找的映射。'
- en: '[![4](assets/4.png)](#code_id_4_10)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_10)'
- en: The sequence repeats, getting the ID of the next map after the one in step 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列重复，获取步骤1中的映射之后的下一个映射的ID。
- en: 'There’s a group of these three syscalls for each map loaded into the kernel,
    and you should also see that the values used for `start_id` and `map_id` match
    the IDs of those maps. The repeated pattern ends when there are no more maps left
    to look at, which results in `BPF_MAP_GET_NEXT_ID` returning a value of `ENOENT`,
    like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加载到内核中的每个映射，都有一组这三个系统调用，您还应该看到`start_id`和`map_id`的值与这些映射的ID匹配。当没有更多的映射可供查看时，重复的模式结束，导致`BPF_MAP_GET_NEXT_ID`返回`ENOENT`的值，如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If a matching map has been found, `bpftool` holds its file descriptor so that
    it can read the elements out of that map.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到匹配的映射，`bpftool`将保持其文件描述符，以便可以从该映射中读取元素。
- en: Reading Map Elements
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取映射元素
- en: 'At this point `bpftool` has a file descriptor reference to the map(s) it’s
    going to read from. Let’s look at the syscall sequence for reading that information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`bpftool`具有对要从中读取的映射的文件描述符引用。让我们看一下读取该信息的系统调用序列：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#code_id_4_11)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_4_11)'
- en: First, the application needs to find a valid key that is present in the map.
    It does this with the `BPF_MAP_GET_NEXT_KEY` flavor of the `bpf()` syscall. The
    `key` argument is a pointer to a key, and the syscall will return the next valid
    key *after* this one. By passing in a NULL pointer, the application is requesting
    the first valid key in the map. The kernel writes the key into the location specified
    by the `next_key` pointer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应用程序需要找到映射中存在的有效键。它使用`bpf()`系统调用的`BPF_MAP_GET_NEXT_KEY`来实现这一点。`key`参数是一个指向键的指针，系统调用将返回此键之后的下一个有效键。通过传递一个空指针，应用程序请求映射中的第一个有效键。内核将键写入`next_key`指针指定的位置。
- en: '[![2](assets/2.png)](#code_id_4_12)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_4_12)'
- en: Given a key, the application requests the associated value, which gets written
    to the memory location specified by `value`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个键，应用程序请求关联的值，该值被写入由`value`指定的内存位置。
- en: '[![3](assets/3.png)](#code_id_4_13)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_4_13)'
- en: At this point, `bpftool` has the contents of the first key–value pair, and it
    writes this information to the screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`bpftool`具有第一个键-值对的内容，并将此信息写入屏幕。
- en: '[![4](assets/4.png)](#code_id_4_14)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_4_14)'
- en: Here, `bpftool` moves on to the next key in the map, retrieves its value, and
    writes out this key–value pair to the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bpftool`继续到映射中的下一个键，检索其值，并将此键-值对写入屏幕。
- en: '[![5](assets/5.png)](#code_id_4_15)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_4_15)'
- en: The next call to `BPF_MAP_GET_NEXT_KEY` returns `ENOENT` to indicate that there
    are no more entries in the map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对`BPF_MAP_GET_NEXT_KEY`的下一次调用返回`ENOENT`，表示映射中没有更多的条目。
- en: '[![6](assets/6.png)](#code_id_4_16)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_4_16)'
- en: Here, `bpftool` finalizes the output written to screen and exits.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bpftool`完成了写入屏幕的输出并退出。
- en: Notice that here, `bpftool` has been assigned file descriptor `3` to correspond
    to the `config` map. This is the same map that *hello-buffer-config.py* refers
    to with file descriptor `4`. As I’ve mentioned already, file descriptors are process
    specific.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里`bpftool`已被分配文件描述符`3`，以对应`config`映射。这与*hello-buffer-config.py*中使用文件描述符`4`引用的相同映射。正如我已经提到的，文件描述符是进程特定的。
- en: This analysis of how `bpftool` behaves shows how a user space program can iterate
    through the available maps and through the key–value pairs stored in a map.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对`bpftool`行为的分析显示了用户空间程序如何遍历可用的映射和存储在映射中的键-值对。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you saw how user space code uses the `bpf()` syscall to load
    eBPF programs and maps. You saw programs and maps being created using the `BPF_PROG_LOAD`
    and `BPF_MAP_CREATE` commands.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了用户空间代码如何使用`bpf()`系统调用来加载eBPF程序和映射。您看到了使用`BPF_PROG_LOAD`和`BPF_MAP_CREATE`命令创建程序和映射。
- en: You learned that the kernel keeps track of the number of references to eBPF
    programs and maps, releasing them when the reference count drops to zero. You
    were also introduced to the concepts of pinning BPF objects to a filesystem and
    using BPF links to create additional references.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解到内核跟踪对eBPF程序和映射的引用计数，并在引用计数降至零时释放它们。您还介绍了将BPF对象固定到文件系统并使用BPF链接创建附加引用的概念。
- en: You saw an example of `BPF_MAP_UPDATE_ELEM` being used to create entries in
    a map from user space. There are similar commands—`BPF_MAP_LOOKUP_ELEM` and `BPF_MAP_DELETE_ELEM`—for
    retrieving and deleting values from a map. There is also the command `BPF_MAP_GET_NEXT_KEY`
    for finding the next key that’s present in a map. You can use this to iterate
    through all the valid entries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了`BPF_MAP_UPDATE_ELEM`的一个示例，用于从用户空间创建映射中的条目。还有类似的命令——`BPF_MAP_LOOKUP_ELEM`和`BPF_MAP_DELETE_ELEM`——用于从映射中检索和删除值。还有一个命令`BPF_MAP_GET_NEXT_KEY`，用于查找映射中存在的下一个键。您可以使用此命令来遍历所有有效的条目。
- en: You saw examples of user space programs making use of `perf_event_open()` and
    `ioctl()` for attaching eBPF programs to kprobe events. The attachment method
    can be very different for other types of eBPF programs, and some of them even
    use the `bpf()` system call. For example, there’s a `bpf(BPF_PROG_ATTACH)` syscall
    that can be used to attach cgroup programs, and `bpf(BPF_RAW_TRACEPOINT_OPEN)`
    for raw tracepoints (see Exercise 5 at the end of this chapter).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了用户空间程序如何使用`perf_event_open()`和`ioctl()`来将eBPF程序附加到kprobe事件。对于其他类型的eBPF程序，附加方法可能会有很大不同，其中一些甚至使用`bpf()`系统调用。例如，有一个`bpf(BPF_PROG_ATTACH)`系统调用，可用于附加cgroup程序，以及`bpf(BPF_RAW_TRACEPOINT_OPEN)`用于原始跟踪点（请参见本章末尾的练习5）。
- en: I also showed how you can use `BPF_MAP_GET_NEXT_ID`, `BPF_MAP_GET_FD_BY_ID`,
    and `BPF_OBJ_GET_INFO_BY_FD` to locate map (and other) objects held by the kernel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我还展示了如何使用`BPF_MAP_GET_NEXT_ID`、`BPF_MAP_GET_FD_BY_ID`和`BPF_OBJ_GET_INFO_BY_FD`来定位内核中保存的映射（和其他）对象。
- en: There are some other `bpf()` commands that I haven’t covered in this chapter,
    but what you have seen here is enough to get a good overview.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他`bpf()`命令我在本章中没有涵盖，但是您在这里看到的已经足够了解一个好的概述。
- en: You also saw some BTF data being loaded into the kernel, and I mentioned that
    `bpftool` uses this information to understand the format of data structures so
    that it can print them out nicely. I didn’t explain yet what BTF data looks like
    or how it’s used to make eBPF programs portable across kernel versions. That’s
    coming up in the next chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到一些BTF数据被加载到内核中，并且我提到`bpftool`使用此信息来了解数据结构的格式，以便可以将其打印出来。我还没有解释BTF数据的外观以及如何使用它使eBPF程序在内核版本之间可移植。这将在下一章中介绍。
- en: Exercises
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are a few things you can try if you’d like to explore the `bpf()` syscall
    further:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索`bpf()`系统调用，可以尝试以下几件事：
- en: Confirm that the `insn_cnt` field from a `BPF_PROG_LOAD` system call corresponds
    to the number of instructions that are output if you dump the translated eBPF
    bytecode for that program using `bpftool`. (This is as documented on the [manpage
    for the `bpf()` system call](https://oreil.ly/NJdIM).)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认`BPF_PROG_LOAD`系统调用的`insn_cnt`字段是否对应于使用`bpftool`转储该程序的翻译eBPF字节码的指令数量。（这在[“bpf()”系统调用的manpage](https://oreil.ly/NJdIM)中有记录。）
- en: Run two instances of the example program so that there are two maps called `config`.
    If you run `bpftool map dump name config`, the output will include information
    about the two different maps as well as their contents. Run this under `strace`,
    and follow the use of different file descriptors through the syscall output. Can
    you see where it’s retrieving information about a map and where it’s retrieving
    the key–value pairs stored within it?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行两个示例程序的实例，以便有两个名为`config`的映射。如果运行`bpftool map dump name config`，输出将包括有关两个不同映射以及其内容的信息。在`strace`下运行此命令，并通过系统调用输出跟踪不同文件描述符的使用。您能看到它在哪里检索有关映射的信息以及在哪里检索其中存储的键-值对吗？
- en: Use `bpftool map update` to modify the `config` map while one of the example
    programs is running. Use `sudo -u username` to check that these configuration
    changes are picked up by the eBPF program.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行示例程序之一时使用`bpftool map update`修改`config`映射。使用`sudo -u username`检查eBPF程序是否捕获到这些配置更改。
- en: 'While *hello-buffer-config.py* is running, use `bpftool` to pin the program
    to the BPF filesystem, like this:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*hello-buffer-config.py*运行时，使用`bpftool`将程序固定到BPF文件系统，如下所示：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Quit the running program, and check that the *hello* program is still loaded
    in the kernel using `bpftool prog list`. You can clean up the link by removing
    the pin with `rm /sys/fs/bpf/hi`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 退出运行的程序，并使用`bpftool prog list`检查内核中是否仍然加载了*hello*程序。您可以通过使用`rm /sys/fs/bpf/hi`删除引脚来清理链接。
- en: 'Attaching to a raw tracepoint is considerably more straightforward at the syscall
    level than attaching to a kprobe, as it simply involves a `bpf()` syscall. Try
    converting *hello-buffer-config.py* to attach to the raw tracepoint for `sys_enter`,
    using BCC’s `RAW_TRACEPOINT_PROBE` macro (if you did the exercises in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor),
    you’ll already have a suitable program you can use). You won’t need to explicitly
    attach the program in the Python code, as BCC will take care of it for you. Running
    this under `strace`, you should see a syscall similar to this:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统调用级别，与附加到kprobe相比，附加到原始跟踪点要简单得多，因为它只涉及一个`bpf()`系统调用。尝试将*hello-buffer-config.py*转换为附加到`sys_enter`的原始跟踪点，使用BCC的`RAW_TRACEPOINT_PROBE`宏（如果您在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中做了练习，您已经有一个适合的程序可以使用）。您不需要在Python代码中显式附加程序，因为BCC会为您处理。在`strace`下运行此命令，您应该会看到类似于这样的系统调用：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The tracepoint in the kernel has the name `sys_enter`, and the eBPF program
    with file descriptor `6` is being attached to it. From now on, whenever execution
    in the kernel reaches that tracepoint, it will trigger the eBPF program.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中的跟踪点的名称为`sys_enter`，并且具有文件描述符`6`的eBPF程序被附加到其中。从现在开始，每当内核中的执行到达该跟踪点时，它将触发eBPF程序。
- en: 'Run the opensnoop application from [BCC’s set of *libbpf tools*](https://oreil.ly/D31R4).
    This tool sets up some BPF links that you can see with `bpftool`, like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[BCC的*libbpf工具*](https://oreil.ly/D31R4)中运行opensnoop应用程序。此工具设置了一些BPF链接，您可以使用`bpftool`查看，如下所示：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Confirm that the program IDs (1849 and 1851 in my example output here) match
    the output from listing the loaded eBPF programs:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 确认程序ID（在我的示例输出中为1849和1851）是否与列出的已加载eBPF程序的输出匹配：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While opensnoop is running, try pinning one of these links with `bpftool link
    pin id 116 /sys/fs/bpf/mylink` (using one of the link IDs you see output from
    `bpftool link list`). You should see that even after you terminate opensnoop,
    both the link and the corresponding program remain loaded in the kernel.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在opensnoop运行时，尝试使用`bpftool link pin id 116 /sys/fs/bpf/mylink`固定其中一个链接（使用您从`bpftool
    link list`输出的链接ID之一）。您应该看到即使在终止opensnoop之后，链接和相应的程序仍然加载在内核中。
- en: If you skip ahead to the example code for [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    you’ll find a version of *hello-buffer-config.py* written using the *libbpf* library.
    This library automatically sets up a BPF link to the program that it loads into
    the kernel. Use `strace` to inspect the `bpf()` system calls that it makes, and
    see `bpf(BPF_LINK_CREATE)` system calls.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您跳到[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)的示例代码，您将找到使用*libbpf*库编写的*hello-buffer-config.py*的版本。此库会自动设置BPF链接到加载到内核中的程序。使用`strace`检查它所做的`bpf()`系统调用，并查看`bpf(BPF_LINK_CREATE)`系统调用。
- en: ^([1](ch04.html#ch04fn1-marker)) If you want to see the full set of BPF commands,
    they’re documented in the [*linux/bpf.h*](https://oreil.ly/Pyy7U) header file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 1 如果您想查看完整的BPF命令集，可以在*linux/bpf.h*头文件中找到文档。
- en: ^([2](ch04.html#ch04fn2-marker)) BTF was introduced upstream in the 5.1 kernel,
    but it has been back-ported on some Linux distributions, as you can see from [this
    discussion](https://oreil.ly/LjcPN).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 2 BTF在5.1内核中引入，但已经在一些Linux发行版上进行了回溯，您可以从[此讨论](https://oreil.ly/LjcPN)中看到。
- en: ^([3](ch04.html#ch04fn3-marker)) These are defined in the `bpf_attach_type`
    enumerator in [*linux/bpf.h*](https://oreil.ly/AO1rc)*.*
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#ch04fn3-marker)) 这些在*linux/bpf.h*中的`bpf_attach_type`枚举器中定义。
- en: ^([4](ch04.html#ch04fn4-marker)) A reminder that for more information on the
    difference, read Andrii Nakryiko’s [“BPF ring buffer”](https://oreil.ly/XkpUF)
    blog post.`
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.html#ch04fn4-marker)) 提醒您，要了解更多关于差异的信息，请阅读Andrii Nakryiko的“BPF环形缓冲区”博客文章。

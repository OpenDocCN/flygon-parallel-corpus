["```cpp\nstruct my_value {\n     ... <other fields>\n     struct bpf_spin_lock lock;\n... <other fields>\n};\n```", "```cpp\nbpftool btf list\n1: name [vmlinux]  size 5843164B\n2: name [aes_ce_cipher]  size 407B\n3: name [cryptd]  size 3372B\n...\n149: name <anon>  size 4372B  prog_ids 319  map_ids 103\n        pids hello-buffer-co(7660)\n155: name <anon>  size 37100B\n        pids bpftool(7784)\n```", "```cpp\n149: name <anon>  size 4372B  prog_ids 319  map_ids 103\n        pids hello-buffer-co(7660)\n```", "```cpp\nbpftool prog show name hello\n319: kprobe  name hello  tag a94092da317ac9ba  gpl\n        loaded_at 2022-08-28T14:13:35+0000  uid 0\n        xlated 400B  jited 428B  memlock 4096B  map_ids 103,104\n        btf_id 149\n        pids hello-buffer-co(7660)\n```", "```cpp\nstructuser_msg_t{ `char``message``[``12``];` ``};` ``BPF_HASH``(``config``,``u32``,``struct``user_msg_t``);```", "```cpp\n\n ```", "```cpp\n[1] TYPEDEF 'u32' type_id=2\n[2] TYPEDEF '__u32' type_id=3\n[3] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n```", "```cpp\n[4] STRUCT 'user_msg_t' size=12 vlen=1\n        'message' type_id=6 bits_offset=0\n[5] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=(none)\n[6] ARRAY '(anon)' type_id=5 index_type_id=7 nr_elems=12\n[7] INT '__ARRAY_SIZE_TYPE__' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n```", "```cpp\n[8] STRUCT '____btf_map_config' size=16 vlen=2\n        'key' type_id=1 bits_offset=0\n        'value' type_id=4 bits_offset=32\n```", "```cpp\nstructsomething{ `char``letter``;`\n`u64``number``;` ``}``\n```", "```cppThere would be 7 bytes of unused memory after the field called `letter` before the `number` field so that the 64-bit number can be aligned to a memory location divisible by 8.\n\nIt\u2019s possible in some circumstances to turn on compiler packing to avoid this unused space, but it generally results in lower performance and\u2014at least in my experience\u2014it\u2019s unusual to do so. More often, C programmers will design structures by hand to make efficient use of space.```", "```cpp  ```", "```cpp\nstruct{/* anonymous struct used by BPF_MAP_CREATE command */`__u32``map_type`;/* one of enum bpf_map_type */`__u32``key_size`;/* size of key in bytes */`__u32``value_size`;/* size of value in bytes */`__u32``max_entries`;/* max number of entries in a map */...char`map_name`[`BPF_OBJ_NAME_LEN`];...`__u32``btf_fd`;/* fd pointing to a BTF type data */`__u32``btf_key_type_id`;/* BTF type_id of the key */`__u32``btf_value_type_id`;/* BTF type_id of the value */...};\n```", "```cpp\n[31] FUNC_PROTO '(anon)' ret_type_id=23 vlen=1\n        'ctx' type_id=10\n[32] FUNC 'hello' type_id=31 linkage=static\n```", "```cpp\n[10] PTR '(anon)' type_id=0\n\n[23] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\n```", "```cpp\ninthello(void*ctx)\n```", "```cpp\nbpftool btf dump map name config\n[1] TYPEDEF 'u32' type_id=2\n[4] STRUCT 'user_msg_t' size=12 vlen=1\n        'message' type_id=6 bits_offset=0\n```", "```cpp`  ```", "```cpp\n$ bpftool btf list\n1: name [vmlinux]  size 5842973B\n2: name [aes_ce_cipher]  size 407B\n3: name [cryptd]  size 3372B\n...\n```", "```cpp\nbpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h\n```", "```cpp\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n#include \"hello-buffer-config.h\"\n```", "```cpp\nstructdata_t{ `int``pid``;` ``int``uid``;` ``char``command``[``16``];` ``char``message``[``12``];` ``char``path``[``16``];` ``};```", "```cpp\n```", "```cppThe only difference from the version you saw before is that I have added a field called `path`.\n\nThe reason to pull this structure definition into a separate header file is that I will also refer to it from the user space code in *hello-buffer-config.c*. In the BCC version, the kernel and user space code were both defined in a single file, and BCC did some work behind the scenes to make the structure available to the Python user space code.```", "```cpp## Defining Maps\n\nAfter including the header files, the next few lines of the source code in *hello-buffer-config.bpf.c* define the structures used for maps, like this:\n\n```", "```cpp```", "````cpp```\n```\n\n ```cppThis requires more lines of code than I needed in the equivalent BCC example! With BCC, the map called `config` was created with the following macro:\n\n```\nBPF_HASH(config,u64,structuser_msg_t);\n```cpp\n\n `This macro isn\u2019t available when you\u2019re not using BCC, so in C you have to write it out longhand. You\u2019ll see that I have used `__uint` and `__type`. These are defined in [*bpf/bpf_helpers_def.h*](https://oreil.ly/2FgjB) along with `__array`, like this:\n\n```\n#define `__uint`(name, val) int (*name)[val]#define `__type`(name, val) `typeof`(val) *name#define `__array`(name, val) `typeof`(val) *name[]\n```cpp\n\nThese macros generally seem to be used by convention in *libbpf*-based programs, and I think they make the map definitions a little easier to read.\n\n###### Note\n\nThe name \u201cconfig\u201d clashed with a definition in *vmlinux.h*, so I renamed the map \u201cmy_config\u201d for this example.````", "```cpp## eBPF Program Sections\n\nUse of *libbpf* requires each eBPF program to be marked with a `SEC()` macro that defines the program type, like this:\n\n```", "```cpp\n\n `This results in a section called `kprobe` in the compiled ELF object, so *libbpf* knows to load this as a `BPF_PROG_TYPE_KPROBE`. We\u2019ll discuss different program types further in [Chapter\u00a07](ch07.html#ebpf_program_and_attachment_types).\n\nDepending on the program type, you can also use the section name to specify what event the program will be attached to. The *libbpf* library will use this information to set up the attachment automatically, rather than leaving you to do it explicitly in your user space code. So, for example, to auto-attach to the kprobe for the `execve` syscall on an ARM-based machine, you could specify the section like this:\n\n```", "```cpp\n\n `This requires you to know the function name for the syscall on that architecture (or figure it out, perhaps by looking at the */proc/kallsyms* file on your target machine, which lists all the kernel symbols, including its function names). But *libbpf* can make life even easier for you with the `k(ret)syscall` section name, which tells the loader to attach to the kprobe in the architecture-specific function automatically:\n\n```", "```cpp\n\n `###### Note\n\nThe valid section names and formats are listed in the [*libbpf* documentation](https://oreil.ly/FhHrm). In the past, the requirements for section names were much looser, so you may come across eBPF programs written before *libbpf 1.0* with section names that don\u2019t match the valid set. Don\u2019t let them confuse you!\n\nThe section definition declares where the eBPF program should be attached, and then the program itself follows. As before, the eBPF program itself is written as a C function. In the example code it\u2019s called `hello()`, and it\u2019s extremely similar to the `hello()` function you saw in [Chapter\u00a04](ch04.html#the_bpfleft_parenthesisright_parenthesi). Let\u2019s consider the differences between that previous version and the version here:\n\n```", "```cpp\n\n[![1](assets/1.png)](#code_id_5_1)\n\nI\u2019ve taken advantage of a [`BPF_KPROBE_SYSCALL`](https://oreil.ly/pgI1B) macro defined in *libbpf* that makes it easy to access the arguments to a syscall by name. For `execve()`, the first argument is the pathname for the program that\u2019s going to be executed. The eBPF program name is `hello`.\n\n[![2](assets/2.png)](#code_id_5_2)\n\nSince the macro has made it so easy to access that pathname argument to `execve()`, I\u2019m including it in the data sent to the perf buffer output. Notice that copying memory requires the use of a BPF helper function.\n\n[![3](assets/3.png)](#code_id_5_3)\n\nHere, `bpf_map_lookup_elem()` is the BPF helper function for looking up values in a map, given a key. BCC\u2019s equivalent of this would be `p = my_config.lookup(&data.uid)`. BCC rewrites this to use the underlying `bpf_map_lookup_elem()` function before it passes the C code to the compiler. When you\u2019re using *libbpf*, there is no rewriting of the code before compilation,^([7](ch05.html#ch05fn7)) so you have to write directly to the helper functions.\n\n[![4](assets/4.png)](#code_id_5_4)\n\nHere\u2019s another similar example where I have written directly to the helper function `bpf_perf_event_output()`, where BCC gave me the convenient equivalent `output.perf_submit(ctx, &data, sizeof(data))`.\n\nThe only other difference is that in the BCC version, I defined the message string as a local variable within the `hello()` function. BCC doesn\u2019t (at least at the time of this writing) support global variables. In this version I have defined it as a global variable, like this:\n\n```", "```cpp\n\n `In *chapter4/hello-buffer-config.py* the `hello` function was defined rather differently, like this:\n\n```", "```cpp\n\n `The `BPF_KPROBE_SYSCALL` macro is one of the convenient additions from *libbpf* that I mentioned. You\u2019re not required to use the macro, but it makes life easier. It does all the heavy lifting to provide named arguments for all the parameters passed to a syscall. In this case, it supplies a `pathname` argument that points to a string holding the path of the executable that is about to be run, which is the first argument to the `execve()` syscall.\n\nIf you\u2019re paying very close attention you might notice that the `ctx` variable isn\u2019t visibly defined in my source code for *hello-buffer-config.bpf.c*, but nevertheless, I\u2019ve been able to use it when submitting data to the output perf buffer, like this:\n\n```", "```cpp\n\n `The `ctx` variable does exist, hidden within the `BPF_KPROBE_SYSCALL` macro definition inside [*bpf/bpf_tracing.h*](https://oreil.ly/pgI1B), in *libbpf*, where you\u2019ll also find some commentary about this. It can be slightly confusing to use a variable that\u2019s not visibly defined, but it\u2019s very helpful that it can be accessed.```", "```cpp  ```", "```cpp\n#define bpf_core_read(dst, sz, src)                        \\\n bpf_probe_read_kernel(dst, sz,                         \\\n (const void *)__builtin_preserve_access_index(src))\n```", "```cpp\nstructb_t*b; `struct``c_t``*``c``;` ``bpf_core_read``(``&``b``,``8``,``&``a``->``b``);` ``bpf_core_read``(``&``c``,``8``,``&``b``->``c``);` ``bpf_core_read``(``&``d``,``8``,``&``c``->``d``);```", "```cpp\n\n ```", "```cpp\nd=BPF_CORE_READ(a,b,c,d);\n```", "```cpp`  ```", "```cpp\ncharLICENSE[]SEC(\"license\")=\"Dual BSD/GPL\";\n```", "```cpp```", "````cpp```  ```# Compiling eBPF Programs for CO-RE\n\nIn [Chapter\u00a03](ch03.html#anatomy_of_an_ebpf_program) you saw an extract from a Makefile that compiles C to eBPF bytecode. Let\u2019s dig into the options used and see why they are necessary for CO-RE/*libbpf* programs.\n\n## Debug Information\n\nYou have to pass the `-g` flag to Clang so that it includes debug information, which is necessary for BTF. However, the `-g` flag also adds DWARF debugging information to the output object file, but that\u2019s not needed by eBPF programs, so you can reduce the size of the object by running the following command to strip it out:\n\n```cpp\nllvm-strip -g <object file>\n```\n\n## Optimization\n\nThe `-O2` optimization flag (level 2 or higher) is required for Clang to produce BPF bytecode that will pass the verifier. One example of this being necessary is that, by default, Clang will output `callx <register>` to call helper functions, but eBPF doesn\u2019t support calling addresses from registers.\n\n## Target Architecture\n\nIf you\u2019re using certain macros defined by *libbpf*, you\u2019ll need to specify the target architecture at compile time. The *libbpf* header file *bpf/bpf_tracing.h* defines several macros that are platform specific, such as `BPF_KPROBE` and `BPF_KPROBE_SYSCALL` that I\u2019ve used in this example. The `BPF_KPROBE` macro can be used for eBPF programs that are being attached to kprobes, and `BPF_KPROBE_SYSCALL` is a variant specifically for syscall kprobes.\n\nThe argument to a kprobe is a `pt_regs` structure that holds a copy of the contents of the CPU registers. Since registers are architecture specific, the `pt_regs` structure definition depends on the architecture you\u2019re running on. This means that if you want to use these macros, you\u2019ll need to also tell the compiler what the target architecture is. You can do this by setting `-D __TARGET_ARCH_($ARCH)` where `$ARCH` is an architecture name like arm64, amd64, and so on.\n\nAlso note that if you didn\u2019t use the macro, you\u2019d need architecture-specific code to access the register information anyway for a kprobe.\n\nPerhaps \u201ccompile once *per architecture*, run everywhere\u201d would have been a bit of a mouthful!\n\n## Makefile\n\nThe following is an example Makefile instruction for compiling CO-RE objects (taken from the Makefile in the *chapter5* directory of the GitHub repo for this book):\n\n```cpp\nhello-buffer-config.bpf.o: %.o: %.c\n   clang \\ -target bpf \\ `-D __TARGET_ARCH_`$(``ARCH``)` \\ `-I/usr/include/`$(``shell` `uname` -`m``)`-linux-gnu \\ `-Wall \\ `-O2 -g \\ `-c `$<` -o `$@` `llvm-strip -g `$@````", "```\n\n ```", "```  ```", "```\n$ readelf -S hello-buffer-config.bpf.o | grep BTF\n  [10] .BTF              PROGBITS         0000000000000000  000002c0\n  [11] .rel.BTF          REL              0000000000000000  00000e50\n  [12] .BTF.ext          PROGBITS         0000000000000000  00000b18\n  [13] .rel.BTF.ext      REL              0000000000000000  00000ea0\n```", "```\nbpftool btf dump file hello-buffer-config.bpf.o\n```", "```  ```", "```\nstruct`bpf_core_relo`{`__u32``insn_off`;`__u32``type_id`;`__u32``access_str_off`;enum`bpf_core_relo_kind``kind`;};\n```", "```\n#pragma clang attribute push (__attribute__((preserve_access_index)), \\\n apply_to = record)\n```", "```\nbpftool -d prog load hello.bpf.o /sys/fs/bpf/hello\n```", "```\nlibbpf: CO-RE relocating [24] struct user_pt_regs: found target candidate [205]\nstruct user_pt_regs in [vmlinux]\nlibbpf: prog 'hello': relo #0: <byte_off> [24] struct user_pt_regs.regs[0]\n(0:0:0 @ offset 0)\nlibbpf: prog 'hello': relo #0: matching candidate #0 <byte_off> [205] struct\nuser_pt_regs.regs[0] (0:0:0 @ offset 0)\nlibbpf: prog 'hello': relo #0: patched insn #1 (LDX/ST/STX) off 0 -> 0\n```", "```\nbpftool gen skeleton hello-buffer-config.bpf.o > hello-buffer-config.skel.h\n```", "```\n...[other#includes]#include\"hello-buffer-config.h\"![1](assets/1.png)#include\"hello-buffer-config.skel.h\"...[somecallbackfunctions]intmain(){structhello_buffer_config_bpf*skel;structperf_buffer*pb=NULL;interr;libbpf_set_print(libbpf_print_fn);![2](assets/2.png)skel=hello_buffer_config_bpf__open_and_load();![3](assets/3.png)...err=hello_buffer_config_bpf__attach(skel);![4](assets/4.png)...pb=perf_buffer__new(bpf_map__fd(skel->maps.output),8,handle_event,lost_event,NULL,NULL);![5](assets/5.png)...while(true){![6](assets/6.png)err=perf_buffer__poll(pb,100);...}perf_buffer__free(pb);![7](assets/7.png)hello_buffer_config_bpf__destroy(skel);return-err;}\n```", "```\nskel=hello_buffer_config_bpf__open_and_load();\n```", "```\nskel=hello_buffer_config_bpf__open(); `if``(``!``skel``)``{` ``// Error ...`\n`}`\n`skel``->``data``->``c``=``10``;` ``err``=``hello_buffer_config_bpf__load``(``skel``);```", "```\n\n ```", "````  ```cpp### Accessing existing maps\n\nBy default, *libbpf* will also create any maps that are defined in the ELF bytes, but sometimes you might want to write an eBPF program that reuses an existing map. You already saw an example of this in the previous chapter, where you saw `bpftool` iterating through all the maps, looking for the one that matched a specified name. Another common reason to use a map is to share information between two different eBPF programs, so only one program should create the map. The `bpf_map__set_autocreate()` function allows you to override *libbpf*\u2019s auto-creation.\n\nSo how do you access an existing map? Maps can be pinned, and if you know the pinned path, you can get a file descriptor to an existing map with `bpf_obj_get()`. Here\u2019s a very simple example (available in the GitHub repository as *chapter5/find-map.c*):\n\n```\nstructbpf_map_infoinfo={}; `unsigned``int``len``=``sizeof``(``info``);` ``int``findme``=``bpf_obj_get``(``\"/sys/fs/bpf/findme\"``);` ``if``(``findme``<=``0``)``{` ``printf``(``\"No FD``\\n``\"``);` ``}``else``{` ``bpf_obj_get_info_by_fd``(``findme``,``&``info``,``&``len``);` ``printf``(``\"Name: %s``\\n``\"``,``info``.``name``);` ``}```cpp````", "```cpp\n\n ```", "```cpp\n$ bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4\nname findme\n```", "```cpp\nName: findme\n```", "```cpp  ```", "```cpp\nerr=hello_buffer_config_bpf__attach(skel);\n```", "```cpp\npb=perf_buffer__new(bpf_map__fd(skel->maps.output),8,handle_event, `lost_event``,``NULL``,``NULL``);`\n```", "```cpp\nwhile(true){ `err``=``perf_buffer__poll``(``pb``,``100``);` ``...` ``}```", "```cpp\n\n ```", "```cpp\nperf_buffer__free(pb); `hello_buffer_config_bpf__destroy``(``skel``);`\n```", "```cpp\n23664  501    bash             Hello World\n23665  501    bash             Hello World\n23667  0      cron             Hello World\n23668  0      sh               Hello World\n```", "```cpp```", "````cpp````", "```cpp## Libbpf Code Examples\n\nThere are lots of great examples of *libbpf*-based eBPF programs available that you can use as inspiration and guidance for writing your own:\n\n*   The [*libbpf-bootstrap*](https://oreil.ly/zB0Co) project is intended to help you get off the ground with a set of example programs.\n\n*   The BCC project has many of the original BCC-based tools migrated to a *libbpf* version. You\u2019ll find them in the [*libbpf-tools* directory](https://oreil.ly/Z9xDX).```", "```cpp# Summary\n\nCO-RE enables eBPF programs that can run on kernel versions different from the versions on which they were built. This massively improves the portability of eBPF and makes life much easier for tool developers who want to deliver production-ready tooling to their users and customers.\n\nIn this chapter you saw how CO-RE achieves this by encoding type information into the compiled object file and using relocations to rewrite instructions as they are loaded into the kernel. You also had an introduction to writing code in C that uses *libbpf*: both the eBPF programs that run in the kernel and the user space programs that manage the lifecycle of those programs, based on auto-generated BPF skeleton code. In the next chapter you\u2019ll learn how the kernel verifies that eBPF programs are safe to run.\n\n# Exercises\n\nHere are a few things you can do to further explore BTF, CO-RE, and *libbpf*:\n\n1.  Experiment with `bpftool btf dump map` and `bpftool btf dump prog` to see the BTF information associated with maps and programs, respectively. Remember that you can specify individual maps and programs in more than one way.\n\n2.  Compare the output from `bpftool btf dump file` and `bpftool btf dump prog` for the same program in its ELF object file form and after it has been loaded into the kernel. They should be identical.\n\n3.  Examine the debug output from *bpftool -d prog load hello-buffer-config.bpf.o /sys/fs/bpf/hello*. You\u2019ll see each section being loaded, checks on the license, and relocations taking place, as well as output describing each BPF program instruction.\n\n4.  Try building a BPF program against a different *vmlinux* header file from BTFHub, and look in the debug output from `bpftool` for relocations that change offsets.\n\n5.  Modify the *hello-buffer-config.c* program so that you can configure different messages for different user IDs using the map (similar to the *hello-buffer-config.py* example in [Chapter\u00a04](ch04.html#the_bpfleft_parenthesisright_parenthesi)).\n\n6.  Try changing the section name in the `SEC();`, perhaps to your own name. When you come to load the program into the kernel you should see an error because *libbpf* doesn\u2019t recognize the section name. This illustrates how *libbpf* uses the section name to work out what kind of BPF program this is. You could try writing your own attachment code to explicitly attach to an event of your choice rather than relying on *libbpf*\u2019s auto-attachment.\n\n^([1](ch05.html#ch05fn1-marker)) Strictly speaking, the data structure definitions come from kernel header files, and you could choose to compile based on a set of these header files that is different from what was used to build the kernel running on that machine. To work correctly (without the CO-RE mechanisms described in this chapter), the kernel headers have to be compatible with the kernel on the target machine where the eBPF program will run.\n\n^([2](ch05.html#ch05fn2-marker)) Part of this section is adapted from \u201cWhat Is eBPF?\u201d by Liz Rice. Copyright \u00a9 2022 O\u2019Reilly Media. Used with permission.\n\n^([3](ch05.html#ch05fn3-marker)) A small and unscientific survey suggests that most people pronounce this the same as the word *core* rather than in two syllables.\n\n^([4](ch05.html#ch05fn4-marker)) See the kernel documentation at [*https://docs.kernel.org/bpf/btf.html#type-encoding*](https://docs.kernel.org/bpf/btf.html#type-encoding).\n\n^([5](ch05.html#ch05fn5-marker)) The kernel needs to have been built with the `CONFIG_DEBUG_INFO_BTF` option enabled.\n\n^([6](ch05.html#ch05fn6-marker)) Which is the oldest Linux kernel version that can support BTF? See [*https://oreil.ly/HML9m*](https://oreil.ly/HML9m).\n\n^([7](ch05.html#ch05fn7-marker)) Well, normal C preprocessing applies so that you can do things like `#define`. But there\u2019s no *special* rewriting like there is when you use BCC.\n\n^([8](ch05.html#ch05fn8-marker)) eBPF programs handling network packets don\u2019t get to use this helper function and can only access the network packet memory.\n\n^([9](ch05.html#ch05fn9-marker)) It is permitted in certain BTF-enabled program types such as `tp_btf`, `fentry`, and `fexit`.```", "```cpp```"]
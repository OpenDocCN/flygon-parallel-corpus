- en: Chapter 5\. CO-RE, BTF, and Libbpf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you encountered BTF (BPF Type Format) for the first
    time. This chapter discusses why it exists and how it’s used to make eBPF programs
    portable across different versions of the kernel. It’s a key part of BPF’s compile
    once, run everywhere (CO-RE) approach, which solves the problem of making eBPF
    programs portable across different kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: Many eBPF programs access kernel data structures, and an eBPF programmer would
    need to include relevant Linux header files so that their eBPF code can correctly
    locate fields within those data structures. However, the Linux kernel is under
    continuous development, which means internal data structures can change between
    different kernel versions. If you were to take an eBPF object file compiled on
    one machine^([1](ch05.html#ch05fn1)) and load it onto a machine with a different
    kernel version, there would be no guarantee that the data structures would be
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: The CO-RE approach is a huge step forward in addressing this portability issue
    in an efficient way. It allows eBPF programs to include information about the
    data structure layouts they were compiled with, and it provides a mechanism for
    adjusting how fields are accessed if the data structure layout is different on
    the target machine where they run. Provided the program doesn’t want to access
    a field or data structure that simply doesn’t exist in the target machine’s kernel,
    the program is portable across different kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: But before we dive into the details of how CO-RE works, let’s discuss why it
    was so desirable, by looking at the previous approach to kernel portability as
    originally implemented in the BCC project.
  prefs: []
  type: TYPE_NORMAL
- en: BCC’s Approach to Portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I used [BCC](https://oreil.ly/ReUtn)
    to show a basic “Hello World” example of an eBPF program. The BCC project was
    the first popular project for implementing eBPF programs, providing a framework
    for both the user space and kernel aspects that’s relatively accessible to programmers
    without much kernel experience. To address portability across kernels, BCC took
    the approach of compiling eBPF code at runtime, in situ on the destination machine.
    There are a number of issues with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: The compilation toolchain needs to be installed on every destination machine
    where you want the code to run, as well as the kernel header files (which aren’t
    always present by default).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to wait for the compilation to complete before the tool starts, which
    could mean a delay of several seconds, every time the tool is launched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re running the tool on a large fleet of identical machines, repeating
    the compilation on each machine is a waste of compute resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some BCC-based projects package their eBPF source code and the toolchain into
    a container image, which makes distribution to each machine easier. But it doesn’t
    solve the problem of ensuring that the kernel headers are present, and it can
    even mean more duplication if several of these BCC containers are installed on
    each machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded devices might not have sufficient memory resources to run the compilation
    step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these issues, if you’re planning to embark on developing a significant
    new eBPF project, I would not recommend using this legacy BCC approach for it,
    especially if you’re planning to distribute it for others to use. In this book
    I’ve given some examples based on BCC because it’s a good approach for learning
    about the basic concepts of eBPF, particularly because the Python user space code
    is so compact and easy to read. It’s also a perfectly good choice if you’re more
    comfortable with it and you want to put something together quickly. But it’s not
    the best approach for serious modern eBPF development.
  prefs: []
  type: TYPE_NORMAL
- en: The CO-RE approach offers a much better solution to the problem of cross-kernel
    portability for eBPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The BCC project at [*github.com/iovisor/bcc*](https://oreil.ly/ReUtn) includes
    a wide range of command-line tools for observing all sorts of information about
    how a Linux machine is behaving. The original versions located in the [*tools*](https://oreil.ly/fI4w_)
    directory are mostly implemented in Python using this legacy approach to portability
    that I have described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: In BCC’s [*libbpf-tools*](https://oreil.ly/ke7yq) directory, you’ll find updated
    versions of these tools written in C that take advantage of *libbpf* and CO-RE
    and that don’t suffer from the problems I’ve just listed. They are an incredibly
    useful set of utilities!
  prefs: []
  type: TYPE_NORMAL
- en: CO-RE Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CO-RE approach consists of a few elements:^([2](ch05.html#ch05fn2))^,^([3](ch05.html#ch05fn3))
  prefs: []
  type: TYPE_NORMAL
- en: BTF
  prefs: []
  type: TYPE_NORMAL
- en: '[BTF](https://oreil.ly/iRCuI) is a format for expressing the layout of data
    structures and function signatures. In CO-RE it’s used to determine any differences
    between the structures used at compilation time and at runtime. BTF is also used
    by tools like `bpftool` to dump data structures in human-readable formats. Linux
    kernels from 5.4 onward support BTF.'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel headers
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel source code includes header files that describe the data structures
    it uses, and these headers can change between versions of Linux. eBPF programmers
    can choose to include individual header files, or, as you’ll see in this chapter,
    you can use `bpftool` to generate a header file called *vmlinux.h* from a running
    system, containing all the data structure information about a kernel that a BPF
    program might need.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler support
  prefs: []
  type: TYPE_NORMAL
- en: The [Clang compiler was enhanced](https://oreil.ly/6xFJm) so that when it compiles
    eBPF programs with the `-g` flag, it includes what are known as *CO-RE relocations*,
    derived from the BTF information describing the kernel data structures. The GCC
    compiler also added CO-RE support for BPF targets in [version 12](https://oreil.ly/_6PEE).
  prefs: []
  type: TYPE_NORMAL
- en: Library support for data structure relocations
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point where a user space program loads an eBPF program into the kernel,
    the CO-RE approach requires the bytecode to be adjusted to compensate for any
    differences between the data structures present when it was compiled, and what’s
    on the destination machine where it’s about to run, based on the CO-RE relocation
    information compiled into the object. There are a few libraries that will take
    care of this: [*libbpf*](https://oreil.ly/E742u) was the original C library that
    includes this relocation capability, the Cilium eBPF library provides the same
    capability for Go programmers, and Aya does it for Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, a BPF skeleton
  prefs: []
  type: TYPE_NORMAL
- en: A skeleton can be auto-generated from a compiled BPF object file, containing
    handy functions that user space code can call to manage the lifecycle of BPF programs—loading
    them into the kernel, attaching them to events, and so on. If you’re writing the
    user space code in C, you can generate the skeleton with `bpftool gen skeleton`.
    These functions are higher-level abstractions that can be more convenient for
    the developer than using the underlying library (*libbpf*, *cilium/ebpf*, etc.)
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Andrii Nakryiko wrote an [excellent blog post](https://oreil.ly/aeQJo) that
    describes the background of CO-RE, as well as laying out how it works and how
    to use it. He also wrote the canonical [BPF CO-RE Reference Guide](https://oreil.ly/lbW_T),
    so please do read that if you’re embarking on writing code yourself. His [*libbpf-bootstrap*
    guide](https://oreil.ly/_jet-) to building an eBPF app from scratch with CO-RE
    + *libbpf* + skeletons is another must-read.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an overview of the elements of CO-RE, let’s dig in to see
    how they work, starting with an exploration of BTF.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Type Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BTF information describes how data structures and code are laid out in memory.
    This information can be put to a variety of different uses.
  prefs: []
  type: TYPE_NORMAL
- en: BTF Use Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason for discussing BTF in this chapter on CO-RE is that knowing
    the differences between a structure’s layout where an eBPF program was compiled
    and where it is about to run allows for the appropriate adjustments to be made
    as the program is loaded into the kernel. I’ll discuss the relocation process
    later in this chapter, but for now, let’s also consider some of the other uses
    to which BTF information can be put.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how a structure is laid out, and the type of every field in that structure,
    makes it possible to pretty-print a structure’s contents in human-readable form.
    For example, a string is just a series of bytes from the computer’s point of view,
    but converting those bytes into characters makes the string much easier for humans
    to understand. You already saw an example of this in the previous chapter, where
    `bpftool` used BTF information to format the output of map dumps.
  prefs: []
  type: TYPE_NORMAL
- en: BTF information also includes the line and function information that enables
    `bpftool` to interleave source code within the output from translated or JITed
    program dumps, as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    When you come to [Chapter 6](ch06.html#the_ebpf_verifier), you’ll also see the
    source code information interleaved with the verifier log output, and again this
    comes from the BTF information.
  prefs: []
  type: TYPE_NORMAL
- en: 'BTF information is also required for BPF spin locks. *Spin locks* are used
    to stop two CPU cores from simultaneously accessing the same map values. The lock
    has to be part of the map’s value structure, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Within the kernel, eBPF programs use `bpf_spin_lock()` and `bpf_spin_unlock()`
    helper functions to acquire and release a lock. These helpers can be used only
    if BTF information is available to describe where the lock field is within the
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Spin lock support was added in kernel version 5.1\. There are lots of restrictions
    on the use of spin locks: they can only be used on hash or array map types, and
    they can’t be used in tracing or socket filter type eBPF programs. Read more about
    spin locks in the [lwn.net article on concurrency management in BPF](https://oreil.ly/kAyAU).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why BTF information is useful, let’s make it more concrete
    by looking at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Listing BTF Information with bpftool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with programs and maps, you can use the `bpftool` utility to show BTF information.
    The following command lists all the BTF data loaded into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (I’ve omitted many entries from the results for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: The first entry in the list is `vmlinux`, and it corresponds to the *vmlinux*
    file I mentioned earlier that holds the BTF information about the currently running
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some of the examples early in this chapter reuse the programs from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    and then later in this chapter you’ll find new examples for which the source is
    in the *chapter5* directory at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain this example output I ran this command while the `hello-buffer-config`
    example from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) was
    running. You can see the entry describing the BTF information that this process
    is using, on the line that starts with `149:`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what that line is telling us:'
  prefs: []
  type: TYPE_NORMAL
- en: This chunk of BTF information has ID 149.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s an anonymous blob of around 4 KB of BTF information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s used by the BPF program with `prog_id 319` and the BPF map with `map_id
    103`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also used by the process with ID 7660 (shown within parentheses) running
    the `hello-buffer-config` executable (whose name has been truncated to 15 characters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These program, map, and BTF identifiers match with the following output that
    `bpftool` shows about `hello-buffer-config`’s program called `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that doesn’t appear to match completely between these two sets
    of information is that the program refers to an extra `map_id`, `104`. That’s
    the perf event buffer map, and it doesn’t use BTF information; hence, it doesn’t
    appear in the BTF-related output.
  prefs: []
  type: TYPE_NORMAL
- en: Much like `bpftool` can dump the contents of programs and maps, it can also
    be used to view the BTF type information contained in a blob of data.
  prefs: []
  type: TYPE_NORMAL
- en: BTF Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knowing the ID of the BTF information, you can inspect its contents with the
    command `bpftool btf dump id <id>`. When I ran this using the ID 149 that I obtained
    earlier, I got 69 lines of output, each of which is a type definition. I’ll just
    describe the first few lines, which should give you a good idea of how to interpret
    the rest. The BTF information from these first few lines relates to the `config`
    hash map, which was defined in the source code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]This hash table has keys of type `u32` and values of type `struct user_msg_t`.
    That structure holds a 12-byte `message` field. Let’s see how these types are
    defined in the corresponding BTF information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three lines of the BTF output are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The number in square brackets at the start of each line is the type ID (so
    the first line, starting with `[1]`, defines `type_id 1`, etc.). Let’s dive into
    these three types in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Type 1 defines a type named `u32` and its type, defined by `type_id 2`, that
    is, the type defined in the line that starts with `[2]`. As you know, the keys
    in the hash table have this type `u32`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type 2 has the name `__u32` and the type defined by `type_id 3`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type 3 is an integer type with the name `unsigned int`, which is 4 bytes long.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three of these types are synonyms for a 32-bit unsigned integer type. In
    C, the lengths of integers are platform dependent, so Linux defines types like
    `u32` to explicitly define integers of specific lengths. On this machine, `u32`
    corresponds to an unsigned integer. User space code that refers to these should
    use the synonym prefixed with underscores, as in `__u32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few types in the BTF output look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These relate to the `user_msg_t` structure used for values in the `config`
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: Type 4 is the `user_msg_t` structure itself, and in total it is 12 bytes long.
    It contains one field named `message`, which is defined by type 6\. The `vlen`
    field indicates how many fields there are in this definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type 5 is named `char` and is a 1-byte integer—exactly the definition a C programmer
    would expect for a type called “char.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type 6 defines the type for that `message` field as an array with 12 elements.
    Each element has type 5 (it’s a `char`), and the array is indexed by type 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type 7 is a 4-byte integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these definitions, you can build a complete picture of how the `user_msg_t`
    structure is laid out in memory, as illustrated in [Figure 5-1](#a_user_msg_t_structure_takes_onetwo_byt).
  prefs: []
  type: TYPE_NORMAL
- en: '![A user_msg_t structure takes 12 bytes of memory](assets/lebp_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. A `user_msg_t` structure takes 12 bytes of memory
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So far, all the entries have `bits_offset` set to `0`, but the next line of
    output has a structure with more than one field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a structure definition for the key–value pairs stored in the map called
    `config`. I didn’t define this `____btf_map_config` type myself in the source
    code, but it has been generated by BCC. The key is of type `u32`, and the value
    is the `user_msg_t` structure. These correspond to the types 1 and 4 that you
    saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The other important part of the BTF information about this structure is that
    the `value` field starts 32 bits after the start of the structure. That completely
    makes sense because the first 32 bits are needed to hold the `key` field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In C, structure fields get automatically aligned to boundaries, so you can’t
    simply assume that one field always follows directly after the previous one in
    memory. For example, consider a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10][PRE11]## Maps with BTF Information'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just seen the BTF information associated with a map. Now let’s see how
    this BTF data is passed to the kernel when the map is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) that
    maps are created using the `bpf(BPF_MAP_CREATE)` syscall. This takes a `bpf_attr`
    structure as a parameter, [defined in the kernel](https://oreil.ly/PLrYG) like
    this (some details omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before the introduction of BTF, the `btf_*` fields weren’t present in this `bpf_attr`
    structure, and the kernel had no knowledge of the structure of keys or values.
    The `key_size` and `value_size` fields defined how much memory was required for
    them, but they were just treated as so many bytes. By additionally passing in
    the BTF information defining the types of the keys and values, the kernel can
    introspect them, and utilities like `bpftool` can retrieve the type information
    for pretty-printing, as discussed earlier. However, it’s interesting to note that
    separate BTF `type _id`s are passed in for the key and the value. The `____btf_map_config`
    structure that you just saw defined isn’t used by the kernel for the map definition;
    it’s just used by BCC on the user space side.
  prefs: []
  type: TYPE_NORMAL
- en: BTF Data for Functions and Function Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far the BTF data in this example output has related to data types, but the
    BTF data also contains information about functions and function prototypes. Here’s
    the information from the same BTF data blob that describes the `hello` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In type 32 you can see the function named `hello` is defined as having the
    type defined in the previous line. That’s a *function prototype*, which returns
    a value of type ID `23` and takes a single parameter (`vlen=1`) called `ctx` with
    type ID `10`. For completeness, here are the definitions of those types from earlier
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Type 10 is an anonymous pointer with the default type of `0`, which isn’t explicitly
    included in the BTF output but is defined as a void pointer.^([4](ch05.html#ch05fn4))
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value with type 23 is a 4-byte integer, and `encoding=SIGNED` indicates
    that it’s a signed integer; that is, it can have either a positive or negative
    value. This corresponds to the function definition in the source code of *hello-buffer-config.py*,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`The example BTF information I’ve shown so far comes from listing the contents
    of a blob of BTF data. Let’s see how to obtain just the BTF information that relates
    to a particular map or program.`  `## Inspecting BTF Data for Maps and Programs'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to inspect the BTF types associated with a particular map, `bpftool`
    makes that easy. For example, here’s the output for the `config` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can inspect the BTF information related to a particular program
    with `bpftool btf dump prog <prog identity>`. I’ll leave you to check out the
    [manpage](https://oreil.ly/lCoV5) for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’d like to better understand how the BTF type data is generated and de-duplicated,
    there is another [excellent blog post from Andrii Nakryiko](https://oreil.ly/0-a9g)
    on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: By this stage you should have an understanding of how BTF describes the format
    of data structures and functions. An eBPF program written in C needs header files
    that define the types and structures. Let’s see how easy it is to generate a header
    file for any kernel data types that an eBPF program might need.[PRE17]# Generating
    a Kernel Header File
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `bpftool btf list` on a BTF-enabled kernel, you’ll see lots of preexisting
    blobs of BTF data that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first item in this list, with ID 1 and named `vmlinux`, is the BTF information
    about all the data types, structures, and function definitions used by the kernel
    that’s running on this (virtual) machine.^([5](ch05.html#ch05fn5))
  prefs: []
  type: TYPE_NORMAL
- en: An eBPF program needs the definitions of any kernel data structures and types
    that it is going to refer to. Before the days of CO-RE, you’d typically have to
    figure out which of the many individual header files in the Linux kernel source
    held the definition for the structures you were interested in, but now there is
    a much easier way, as BTF-enabled tools can generate an appropriate header file
    from the BTF information included with the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This header file is conventionally called *vmlinux.h*, and you can generate
    it with `bpftool` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This file defines all the kernel’s data types, so including this generated *vmlinux.h*
    file in your eBPF program source supplies the definitions of any Linux data structures
    you might need. When you compile the source into an eBPF object file, that object
    will include BTF information that matches the definitions used in this header
    file. Later, when the program is run on a target machine, the user space program
    that loads it into the kernel will make adjustments to account for differences
    between this build-time BTF information and the BTF information for the kernel
    that’s running on that target machine.
  prefs: []
  type: TYPE_NORMAL
- en: BTF information in the form of the */sys/kernel/btf/vmlinux* file has been included
    in the Linux kernel since version 5.4,^([6](ch05.html#ch05fn6)) but raw BTF data
    that *libbpf* can make use of can also be generated for older kernels. In other
    words, if you want to run a CO-RE–enabled eBPF program on a target machine that
    doesn’t have BTF information already, you might be able to provide the BTF data
    for that target yourself. There’s information on how to generate BTF files, and
    an archive of files for a variety of Linux distributions, on the [BTFHub](https://oreil.ly/mPSO0).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The BTFHub repo also includes further reading about [BTF internals](https://oreil.ly/CfyQh)
    should you want to dive deeper into this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how this and other tactics are used to write eBPF programs
    to be portable across kernels using CO-RE.
  prefs: []
  type: TYPE_NORMAL
- en: CO-RE eBPF Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll recall that eBPF programs run in the kernel. Later in this chapter I’ll
    show some user space code that will interact with the code running in the kernel,
    but in this section I’m concentrating on the kernel side.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve already seen, eBPF programs are compiled to eBPF bytecode, and (at
    least at the time of this writing) the compilers that support this are Clang or
    gcc for compiling C code, and the Rust compiler. I’ll discuss some of your options
    for using Rust in [Chapter 10](ch10.html#ebpf_programming), but for the purposes
    of this chapter I’ll assume you’re writing in C and using Clang, along with the
    *libbpf* library.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, let’s consider an example application called
    *hello-buffer-config*. It’s very similar to the *hello-buffer-config.py* example
    from the previous chapter that used the BCC framework, but this version is written
    in C to use *libbpf* and CO-RE.
  prefs: []
  type: TYPE_NORMAL
- en: If you have BCC-based eBPF code that you want to migrate to *libbpf*, check
    out the excellent and comprehensive [guide by Andrii Nakryiko on his website](https://oreil.ly/iWDcv).
    BCC provides some convenient shortcuts that aren’t handled in quite the same way
    using *libbpf*; conversely, *libbpf* provides its own set of macros and library
    functions to make life easier for the eBPF programmer. As I walk through the example,
    I will point out a few differences between the BCC and *libbpf* approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll find the example C eBPF program to accompany this section in the *chapter5*
    directory of the [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: First let’s look at *hello-buffer-config.bpf.c*, which implements the eBPF program
    that runs in the kernel. Later in the chapter I’ll show you the user space code
    in *hello-buffer-config.c* that loads the program and displays output, much as
    the Python code did in the BCC implementation of this example in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  prefs: []
  type: TYPE_NORMAL
- en: Like any C program, an eBPF program will need to include some header files.
  prefs: []
  type: TYPE_NORMAL
- en: Header Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first few lines of *hello-buffer-config.bpf.c* specify the header files
    that it needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These five files are the *vmlinux.h* file, a few headers from *libbpf*, and
    an application-specific header file that I wrote myself. Let’s see why this is
    a typical pattern for the header files needed for a *libbpf* program.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel header information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re writing an eBPF program that refers to any kernel data structures
    or types, the easiest option is to include the *vmlinux.h* file described earlier
    in this chapter. Alternatively, it’s possible to include individual header files
    from the Linux source, or to define the types by hand in your own code if you
    really want to go to that trouble. If you’re going to use any BPF helper functions
    from *libbpf*, you’ll need to include either *vmlinux.h* or *linux/types.h* to
    get the definitions for types like `u32`, `u64`, and so on, that the BPF helper
    source refers to.
  prefs: []
  type: TYPE_NORMAL
- en: The *vmlinux.h* file is derived from the kernel source headers, but it doesn’t
    include `#define`’d values from them. For example, if your eBPF program parses
    Ethernet packets, you’ll probably need the constant definitions that tell you
    what protocol the packet contains (such as `0x0800` to indicate that it’s an IP
    packet, or `0x0806` for an ARP packet). There is a series of constant values that
    you’ll need to duplicate in your own code, if you don’t include the [*if_ether.h*
    file](https://oreil.ly/hoZzP) that defines these values for the kernel. I didn’t
    need any of these value definitions for *hello-buffer-config*, but you’ll see
    another example in [Chapter 8](ch08.html#ebpf_for_networking) where this is relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Headers from libbpf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use any BPF helper functions in your eBPF code, you’ll need to include the
    header files from *libbpf* that give you their definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One thing that can be slightly confusing about *libbpf* is that it’s not just
    a user space library. You’ll find yourself including header files from *libbpf*
    in both user space and eBPF C code.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, it is common to see eBPF projects including *libbpf*
    as a submodule and building/installing from source—this is what I have done in
    the example repository for this book. If you include it as a submodule, you’ll
    simply need to run `make install` from the *libbpf/src* directory. I don’t think
    it will be long before it’s more common to see *libbpf* widely available as a
    package on common Linux distributions, particularly since *libbpf* has now passed
    the milestone of a [version 1.0 release](https://oreil.ly/8BFq6).
  prefs: []
  type: TYPE_NORMAL
- en: Application-specific headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s very common to have an application-specific header file that defines any
    structures that are used by both the user space and eBPF parts of your app. In
    my example, the *hello-buffer-config.h* header file defines the `data_t` structure
    that I’m using to pass event data from the eBPF program to user space. It’s almost
    the same structure you saw in the BCC version of this code, and it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21][PRE22]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]  [PRE24]'
  prefs: []
  type: TYPE_NORMAL
- en: struct{ `__uint``(``type``,``BPF_MAP_TYPE_PERF_EVENT_ARRAY``);` ``__uint``(``key_size``,``sizeof``(``u32``));`
    ``__uint``(``value_size``,``sizeof``(``u32``));` ``}``output``SEC``(``".maps"``);`
    ``struct``user_msg_t``{` ``char``message``[``12``];` ``};` ``struct``{` ``__uint``(``type``,``BPF_MAP_TYPE_HASH``);`
    ``__uint``(``max_entries``,``10240``);` ``__type``(``key``,``u32``);` ``__type``(``value``,``struct``user_msg_t``);`
    ``}``my_config``SEC``(``".maps"``);[PRE25][PRE26]  [PRE27]
  prefs: []
  type: TYPE_NORMAL
- en: SEC("kprobe")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: SEC("kprobe/__arm64_sys_execve")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: SEC("ksyscall/execve")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: SEC("ksyscall/execve")intBPF_KPROBE_SYSCALL(hello,constchar*pathname)![1](assets/1.png){structdata_tdata={};structuser_msg_t*p;data.pid=bpf_get_current_pid_tgid()>>32;data.uid=bpf_get_current_uid_gid()&0xFFFFFFFF;bpf_get_current_comm(&data.command,sizeof(data.command));bpf_probe_read_user_str(&data.path,sizeof(data.path),pathname);![2](assets/2.png)p=bpf_map_lookup_elem(&my_config,&data.uid);![3](assets/3.png)if(p!=0){bpf_probe_read_kernel(&data.message,sizeof(data.message),p->message);}else{bpf_probe_read_kernel(&data.message,sizeof(data.message),message);}bpf_perf_event_output(ctx,&output,BPF_F_CURRENT_CPU,![4](assets/4.png)&data,sizeof(data));return0;}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: charmessage[12]="Hello World";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: inthello(void*ctx)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: bpf_perf_event_output(ctx,&output,BPF_F_CURRENT_CPU,&data,sizeof(data));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34][PRE35]## Memory Access with CO-RE'
  prefs: []
  type: TYPE_NORMAL
- en: eBPF programs for tracing have restricted access to memory, via a BPF helper
    function from the `bpf_probe_read_*()` family.^([8](ch05.html#ch05fn8)) (There
    is also a `bpf_probe_write_user()` helper function, but it’s only [“meant for
    experiments”](https://oreil.ly/ibcy1)). The problem is that, as you’ll see in
    the next chapter, the eBPF verifier generally won’t let you simply read memory
    through a pointer as you usually can in C (e.g., `x = p->y`).^([9](ch05.html#ch05fn9))
  prefs: []
  type: TYPE_NORMAL
- en: 'The *libbpf* library provides CO-RE wrappers around the `bpf_probe_read_*()`
    helpers to take advantage of the BTF information and make memory access calls
    portable across different kernel versions. Here’s an example of one of those wrappers,
    as defined in the [*bpf_core_read.h* header file](https://oreil.ly/XWWyc):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `bpf_core_read()` calls directly to `bpf_probe_read_kernel()`,
    the only difference being that it wraps the `src` field with `__builtin_preserve_access_index()`.
    This tells Clang to emit a CO-RE relocation entry along with the eBPF instruction
    that accesses this address in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This `__builtin_preserve_access_index()` instruction is an extension to “regular”
    C code, and adding it to eBPF also required changes to the Clang compiler to support
    it and emit these CO-RE relocation entries. Extensions like these are examples
    of why some C compilers cannot (today, at least) generate eBPF bytecode. Read
    more about the Clang changes required for eBPF CO-RE support on the [LLVM mailing
    list](https://oreil.ly/jHTHE).
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see later in this chapter, the CO-RE relocation entry tells *libbpf*
    to rewrite the address, as it’s loading the eBPF program into the kernel, to take
    account of any BTF differences. If the offset of `src` within its containing structure
    is different on the target kernel, the rewritten instruction will take that into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *libbpf* library provides a `BPF_CORE_READ()` macro so that you can write
    several `bpf_core_read()` calls in a single line rather than needing a separate
    helper function call for every pointer dereference. For example, if you wanted
    to do something like `d = a->b->c->d`, you could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]But it’s much more compact to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`You can then read from point `d` using the `bpf_probe_read_kernel()` helper
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a good description of this in Andrii’s [guide](https://oreil.ly/tU0Gb).[PRE40]##
    License Definition
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    the eBPF program has to declare its license. The example code does it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`You’ve now seen all the code in the *hello-buffer-config.bpf.c* example. Now
    let’s compile it into an object file.[PRE42][PRE43]``cpp`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]cppIf you’re using the example code, you should be able to build the
    eBPF object file *hello-buffer-config.bpf.o* (and its companion user space executable
    that I’ll describe shortly) by running `make` in the *chapter5* directory. Let’s
    inspect that object file to see that it includes BTF information.[PRE45]cpp##
    BTF Information in the Object File'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [kernel documentation for BTF](https://oreil.ly/5QrBy) describes how BTF
    data is encoded in an ELF object file in two sections: *.BTF*, which contains
    the data and string information, and *.BTF.ext*, which covers function and line
    information. You can use `readelf` to see that these sections have been added
    to the object file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bpftool` utility lets us examine the BTF data from an object file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The output looks just like the output you get from dumping BTF info from loaded
    programs and maps, as you saw earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this BTF information can be used to allow the program to run on
    another machine with a different kernel version and different data structures.[PRE48]cpp#
    BPF Relocations
  prefs: []
  type: TYPE_NORMAL
- en: The *libbpf* library adapts eBPF programs to work with the data structure layout
    on the target kernel where they run, even if this layout is different from the
    kernel where the code was compiled. To do this, *libbpf* needs the BPF CO-RE relocation
    information generated by Clang as part of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about how the relocations work from the definition of `struct
    bpf_core_relo` in the [*linux/bpf.h*](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711)
    header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The CO-RE relocation data for an eBPF program consists of one of these structures
    for each instruction that needs relocation. Suppose the instruction is setting
    a register to the value of a field within a structure. The `bpf_core_relo` structure
    for that instruction (identified by the `insn_off` field) encodes the BTF type
    of that structure (the `type_id` field) and also indicates how the field is accessed
    relative to that structure (`access_str_off`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve just seen, the relocation data for the kernel data structures is
    generated automatically by Clang and encoded in the ELF object file. It’s the
    following line, which you’ll find near the start of the *vmlinux.h* file, that
    causes Clang to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The `preserve_access_index` attribute tells Clang to generate BPF CO-RE relocations
    for a type definition. The `clang attribute push` part says that this attribute
    should be applied to all definitions until a `clang attribute pop`, which appears
    at the end of the file. That means Clang generates the relocation information
    for all the types defined in *vmlinux.h*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the relocations taking place when you load a BPF program, by using
    `bpftool` and turning on the debug information with the `-d` flag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates a lot of output, but the parts relating to relocation look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example you can see that type ID 24 from the `hello` program’s BTF
    information refers to the structure called `user_pt_regs`. The *libbpf* library
    has matched this against a kernel structure, also called `user_pt_regs`, that
    has type ID 205 in the *vmlinux* BTF data set. In practice, because I compiled
    and loaded the program on the same machine, the type definitions are identical,
    so in this example the offset of 0 from the start of the structure remains unchanged,
    and the “patch” to instruction #1 leaves it unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: In many applications you won’t want to ask users to run `bpftool` to load an
    eBPF program. Instead, you’ll want to build this functionality into a dedicated
    user space program that you supply as an executable. Let’s consider how to write
    this user space code.
  prefs: []
  type: TYPE_NORMAL
- en: CO-RE User Space Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different frameworks in different programming languages that
    support CO-RE by implementing the relocations as they load eBPF programs into
    the kernel. In this chapter I’ll show C code that uses *libbpf*; other options
    include the Go packages *cilium/ebpf* and *libbpfgo*, and Aya for Rust. I’ll discuss
    those options further in [Chapter 10](ch10.html#ebpf_programming).
  prefs: []
  type: TYPE_NORMAL
- en: The Libbpf Library for User Space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *libbpf* library is a user space library you can use directly if you’re
    writing the user space part of your application in C. If you want to, you can
    use this library without using CO-RE. There’s an example of this in [Andrii Nakryiko’s
    excellent blog post on *libbpf-bootstrap*](https://oreil.ly/b3v7B).
  prefs: []
  type: TYPE_NORMAL
- en: This library provides functions that wrap the `bpf()` and related syscalls that
    you met in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) to perform
    operations like loading programs into the kernel and attaching them to events,
    or accessing map information from user space. The conventional and easiest way
    to use these abstractions is through auto-generated BPF skeleton code.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Skeletons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `bpftool` to auto-generate this skeleton code from existing eBPF
    objects in ELF file format, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: Look into this skeleton header and you’ll see that it contains structure definitions
    for the eBPF programs and maps, as well as several functions that all start with
    the name `hello_buffer_config_bpf__` (based on the name of the object file). These
    functions manage the lifecycle of the eBPF programs and maps. You don’t have to
    use the skeleton code—you can make calls to *libbpf* directly if you prefer—but
    the auto-generated code will typically save you some typing.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the generated skeleton file you’ll see a function called `hello_buffer_config_bpf__elf_bytes`
    that returns the byte contents of the ELF object file *hello-buffer-config.bpf.o*.
    Once the skeleton has been generated, we don’t really need that object file anymore.
    You can test this by running `make` to generate the `hello-buffer-config` executable
    and then deleting the *.o* file; the executable has the eBPF bytecode contained
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you prefer, you can use the *libbpf* function `bpf_object__open_file` to
    load the eBPF programs and maps from an ELF file rather than using the bytes from
    a skeleton file.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the outline of the user space code that manages the lifecycle of the
    eBPF program and maps for this example, using the generated skeleton code. I have
    omitted some of the details and error handling for clarity, but you’ll find the
    full source code in *chapter5/hello-buffer-config.c*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#code_id_5_5)'
  prefs: []
  type: TYPE_NORMAL
- en: This file includes the auto-generated skeleton header, as well as the header
    file I wrote manually for data structures shared between the user space and kernel
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_5_6)'
  prefs: []
  type: TYPE_NORMAL
- en: This code sets a callback function that will print any log messages generated
    by *libbpf*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_5_7)'
  prefs: []
  type: TYPE_NORMAL
- en: Here a `skel` structure is created that represents all the maps and programs
    defined in the ELF bytes and loads them into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_5_8)'
  prefs: []
  type: TYPE_NORMAL
- en: Programs are auto-attached to the appropriate events.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_5_9)'
  prefs: []
  type: TYPE_NORMAL
- en: This function creates a structure for handling the perf buffer output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_5_10)'
  prefs: []
  type: TYPE_NORMAL
- en: Here that perf buffer is continuously polled.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#code_id_5_11)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the clean-up code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into some of those steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Loading programs and maps into the kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first call to an auto-generated function is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '`As its name suggests, this function covers two phases: opening and loading.
    The “open” phase involves reading the ELF data and converting its sections into
    structures that represent eBPF programs and maps. The “load” phase loads those
    maps and programs into the kernel, performing any CO-RE fixups as necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two phases can easily be handled separately, as the skeleton code provides
    separate `name__open()` and `name__load()` functions. This gives you the option
    to manipulate the eBPF information before loading it. This is commonly done to
    configure a program before loading it. For example, I could initialize a counter
    global variable `c` to some value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]cppThe data type returned by `hello_buffer_config_bpf__open()`, and
    also by `hello_buffer_config_bpf__load()`, is a structure called `hello_buffer_config_bpf`
    defined in the skeleton header to include information about all the maps, programs,
    and data defined in the object file.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The skeleton object (`hello_buffer_config_bpf` in this example) is just a user
    space representation of information from the ELF bytes. Once it has been loaded
    into the kernel, if you change a value in the object, it won’t have any effect
    on the kernel-side data. So, for example, changing `skel->data->c` after loading
    will not have any effect.[PRE58]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]To try this out you can create a map using `bpftool`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the find-map executable will print out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Let’s get back to the *hello-buffer-config* example and the skeleton code.[PRE62]###
    Attaching to events
  prefs: []
  type: TYPE_NORMAL
- en: 'The next skeleton function in the example attaches the program to the `execve`
    syscall function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`The *libbpf* library automatically takes the attachment point from the `SEC()`
    definition for this program. If you didn’t define the attachment point fully,
    there are a whole series of *libbpf* functions, such as `bpf_program__attach_kprobe`,
    `bpf_program__attach_xdp`, and so on, for attaching different program types.`  `###
    Managing an event buffer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the perf buffer uses a function defined in *libbpf* itself, rather
    than in the skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '``You can see the `perf_buffer__new()` function takes the file descriptor for
    the “output” map as the first argument. The `handle_event` argument is a callback
    function that gets called when new data arrives in the perf buffer, and `lost_event`
    gets called if there isn’t enough room in the perf buffer for the kernel to write
    a data entry. In my example these functions just write messages to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the program has to poll the perf buffer repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]The 100 is a timeout in milliseconds. The callback functions previously
    set up will get called as appropriate when data arrives or when the buffer is
    full.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to clean up I free the perf buffer and destroy the eBPF programs and
    maps in the kernel, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '``There are a whole set of `perf_buffer_*`- and `ring_buffer_*`-related functions
    in *libbpf* to help you manage event buffers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make and run this example `hello-buffer-config` program, you’ll see
    the following output (that’s very similar to what you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68][PRE69][PRE70]  [PRE71]  [PRE72][PRE73]```'
  prefs: []
  type: TYPE_NORMAL

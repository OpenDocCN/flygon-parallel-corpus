- en: Chapter 5\. CO-RE, BTF, and Libbpf
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 CO-RE、BTF和Libbpf
- en: In the previous chapter you encountered BTF (BPF Type Format) for the first
    time. This chapter discusses why it exists and how it’s used to make eBPF programs
    portable across different versions of the kernel. It’s a key part of BPF’s compile
    once, run everywhere (CO-RE) approach, which solves the problem of making eBPF
    programs portable across different kernel versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您第一次遇到了BTF（BPF类型格式）。本章讨论了它存在的原因以及它如何用于使eBPF程序在不同版本的内核之间可移植。这是BPF“编译一次，到处运行”（CO-RE）方法的关键部分，它解决了使eBPF程序在不同内核版本之间可移植的问题。
- en: Many eBPF programs access kernel data structures, and an eBPF programmer would
    need to include relevant Linux header files so that their eBPF code can correctly
    locate fields within those data structures. However, the Linux kernel is under
    continuous development, which means internal data structures can change between
    different kernel versions. If you were to take an eBPF object file compiled on
    one machine^([1](ch05.html#ch05fn1)) and load it onto a machine with a different
    kernel version, there would be no guarantee that the data structures would be
    the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多eBPF程序访问内核数据结构，eBPF程序员需要包含相关的Linux头文件，以便他们的eBPF代码可以正确地定位这些数据结构中的字段。然而，Linux内核正在不断发展，这意味着在不同的内核版本之间内部数据结构可能会发生变化。如果您将在一台机器上编译的eBPF对象文件^([1](ch05.html#ch05fn1))加载到具有不同内核版本的机器上，就无法保证数据结构会相同。
- en: The CO-RE approach is a huge step forward in addressing this portability issue
    in an efficient way. It allows eBPF programs to include information about the
    data structure layouts they were compiled with, and it provides a mechanism for
    adjusting how fields are accessed if the data structure layout is different on
    the target machine where they run. Provided the program doesn’t want to access
    a field or data structure that simply doesn’t exist in the target machine’s kernel,
    the program is portable across different kernel versions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法在以高效的方式解决这个可移植性问题方面迈出了重要的一步。它允许eBPF程序包含有关它们编译时使用的数据结构布局的信息，并提供了一种机制，用于在目标机器上运行时调整字段的访问方式，如果数据结构布局在目标机器上是不同的。只要程序不想访问目标机器内核中根本不存在的字段或数据结构，程序就可以在不同的内核版本之间进行移植。
- en: But before we dive into the details of how CO-RE works, let’s discuss why it
    was so desirable, by looking at the previous approach to kernel portability as
    originally implemented in the BCC project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入讨论CO-RE的工作原理之前，让我们通过查看BCC项目最初实施的内核可移植性的先前方法，来讨论为什么它是如此令人向往的。
- en: BCC’s Approach to Portability
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BCC的可移植性方法
- en: 'In [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor) I used [BCC](https://oreil.ly/ReUtn)
    to show a basic “Hello World” example of an eBPF program. The BCC project was
    the first popular project for implementing eBPF programs, providing a framework
    for both the user space and kernel aspects that’s relatively accessible to programmers
    without much kernel experience. To address portability across kernels, BCC took
    the approach of compiling eBPF code at runtime, in situ on the destination machine.
    There are a number of issues with this approach:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)中，我使用[BCC](https://oreil.ly/ReUtn)展示了一个基本的“Hello
    World”eBPF程序示例。BCC项目是第一个流行的实现eBPF程序的项目，为具有较少内核经验的程序员提供了相对易于访问的用户空间和内核方面的框架。为了解决跨内核的可移植性问题，BCC采取了在目标机器上即时编译eBPF代码的方法。这种方法存在一些问题：
- en: The compilation toolchain needs to be installed on every destination machine
    where you want the code to run, as well as the kernel header files (which aren’t
    always present by default).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译工具链需要安装在您希望代码运行的每台目标机器上，以及内核头文件（这并不总是默认存在的）。
- en: You have to wait for the compilation to complete before the tool starts, which
    could mean a delay of several seconds, every time the tool is launched.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具启动之前，您必须等待编译完成，这可能意味着每次启动工具都会有几秒钟的延迟。
- en: If you’re running the tool on a large fleet of identical machines, repeating
    the compilation on each machine is a waste of compute resources.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在大量相同的机器上运行工具，那么在每台机器上重复编译是一种计算资源的浪费。
- en: Some BCC-based projects package their eBPF source code and the toolchain into
    a container image, which makes distribution to each machine easier. But it doesn’t
    solve the problem of ensuring that the kernel headers are present, and it can
    even mean more duplication if several of these BCC containers are installed on
    each machine.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基于BCC的项目将它们的eBPF源代码和工具链打包到一个容器映像中，这样可以更容易地将其分发到每台机器上。但这并不能解决确保内核头文件存在的问题，甚至可能意味着更多的重复，如果这些BCC容器中的几个安装在每台机器上。
- en: Embedded devices might not have sufficient memory resources to run the compilation
    step.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式设备可能没有足够的内存资源来运行编译步骤。
- en: Because of these issues, if you’re planning to embark on developing a significant
    new eBPF project, I would not recommend using this legacy BCC approach for it,
    especially if you’re planning to distribute it for others to use. In this book
    I’ve given some examples based on BCC because it’s a good approach for learning
    about the basic concepts of eBPF, particularly because the Python user space code
    is so compact and easy to read. It’s also a perfectly good choice if you’re more
    comfortable with it and you want to put something together quickly. But it’s not
    the best approach for serious modern eBPF development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，如果您计划着手开发一个重要的新的eBPF项目，我不建议使用这种传统的BCC方法，特别是如果您计划将其分发给其他人使用。在本书中，我给出了一些基于BCC的例子，因为它是学习eBPF基本概念的一个很好的方法，特别是因为Python用户空间代码如此紧凑且易于阅读。如果您更喜欢它并且想快速地组合一些东西，那么它也是一个完全不错的选择。但对于严肃的现代eBPF开发来说，这并不是最佳的方法。
- en: The CO-RE approach offers a much better solution to the problem of cross-kernel
    portability for eBPF programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法为eBPF程序的跨内核可移植性问题提供了一个更好的解决方案。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The BCC project at [*github.com/iovisor/bcc*](https://oreil.ly/ReUtn) includes
    a wide range of command-line tools for observing all sorts of information about
    how a Linux machine is behaving. The original versions located in the [*tools*](https://oreil.ly/fI4w_)
    directory are mostly implemented in Python using this legacy approach to portability
    that I have described in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[*github.com/iovisor/bcc*](https://oreil.ly/ReUtn)上的BCC项目包括一系列用于观察Linux机器行为的命令行工具。位于[*tools*](https://oreil.ly/fI4w_)目录中的原始版本大多使用Python实现，使用了我在本节中描述的传统可移植性方法。'
- en: In BCC’s [*libbpf-tools*](https://oreil.ly/ke7yq) directory, you’ll find updated
    versions of these tools written in C that take advantage of *libbpf* and CO-RE
    and that don’t suffer from the problems I’ve just listed. They are an incredibly
    useful set of utilities!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在BCC的[*libbpf-tools*](https://oreil.ly/ke7yq)目录中，您将找到用C编写的这些工具的更新版本，它们利用了*libbpf*和CO-RE，并且不会遇到我刚列出的问题。它们是一组非常有用的实用程序！
- en: CO-RE Overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE概述
- en: The CO-RE approach consists of a few elements:^([2](ch05.html#ch05fn2))^,^([3](ch05.html#ch05fn3))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CO-RE方法包括几个元素：^([2](ch05.html#ch05fn2))^,^([3](ch05.html#ch05fn3))
- en: BTF
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: BTF
- en: '[BTF](https://oreil.ly/iRCuI) is a format for expressing the layout of data
    structures and function signatures. In CO-RE it’s used to determine any differences
    between the structures used at compilation time and at runtime. BTF is also used
    by tools like `bpftool` to dump data structures in human-readable formats. Linux
    kernels from 5.4 onward support BTF.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[BTF](https://oreil.ly/iRCuI)是一种用于表达数据结构和函数签名布局的格式。在CO-RE中，它用于确定编译时和运行时结构之间的任何差异。BTF也被`bpftool`等工具用于以人类可读的格式转储数据结构。从5.4版本开始的Linux内核支持BTF。'
- en: Kernel headers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核头文件
- en: The Linux kernel source code includes header files that describe the data structures
    it uses, and these headers can change between versions of Linux. eBPF programmers
    can choose to include individual header files, or, as you’ll see in this chapter,
    you can use `bpftool` to generate a header file called *vmlinux.h* from a running
    system, containing all the data structure information about a kernel that a BPF
    program might need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核源代码包括描述其使用的数据结构的头文件，这些头文件在不同版本的Linux之间可能会发生变化。eBPF程序员可以选择包含单个头文件，或者，正如您将在本章中看到的，您可以使用`bpftool`从运行中的系统生成一个名为*vmlinux.h*的头文件，其中包含BPF程序可能需要的有关内核的所有数据结构信息。
- en: Compiler support
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器支持
- en: The [Clang compiler was enhanced](https://oreil.ly/6xFJm) so that when it compiles
    eBPF programs with the `-g` flag, it includes what are known as *CO-RE relocations*,
    derived from the BTF information describing the kernel data structures. The GCC
    compiler also added CO-RE support for BPF targets in [version 12](https://oreil.ly/_6PEE).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clang编译器进行了增强](https://oreil.ly/6xFJm)，以便在使用`-g`标志编译eBPF程序时，包含所谓的*CO-RE重定位*，这些重定位来自描述内核数据结构的BTF信息。GCC编译器在[12版本](https://oreil.ly/_6PEE)中还为BPF目标添加了CO-RE支持。'
- en: Library support for data structure relocations
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构重定位的库支持
- en: 'At the point where a user space program loads an eBPF program into the kernel,
    the CO-RE approach requires the bytecode to be adjusted to compensate for any
    differences between the data structures present when it was compiled, and what’s
    on the destination machine where it’s about to run, based on the CO-RE relocation
    information compiled into the object. There are a few libraries that will take
    care of this: [*libbpf*](https://oreil.ly/E742u) was the original C library that
    includes this relocation capability, the Cilium eBPF library provides the same
    capability for Go programmers, and Aya does it for Rust.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间程序加载eBPF程序到内核时，CO-RE方法要求调整字节码以补偿编译时存在的数据结构与即将运行的目标机器上的数据结构之间的任何差异，这是基于编译到对象中的CO-RE重定位信息。有几个库可以处理这个问题：[*libbpf*](https://oreil.ly/E742u)是最初包含此重定位功能的C库，Cilium
    eBPF库为Go程序员提供了相同的功能，Aya则为Rust提供了这个功能。
- en: Optionally, a BPF skeleton
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，BPF骨架
- en: A skeleton can be auto-generated from a compiled BPF object file, containing
    handy functions that user space code can call to manage the lifecycle of BPF programs—loading
    them into the kernel, attaching them to events, and so on. If you’re writing the
    user space code in C, you can generate the skeleton with `bpftool gen skeleton`.
    These functions are higher-level abstractions that can be more convenient for
    the developer than using the underlying library (*libbpf*, *cilium/ebpf*, etc.)
    directly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架可以从编译的BPF对象文件中自动生成，其中包含方便的函数，用户空间代码可以调用这些函数来管理BPF程序的生命周期——将它们加载到内核中，将它们附加到事件等等。如果您用C编写用户空间代码，可以使用`bpftool
    gen skeleton`生成骨架。这些函数是更高级的抽象，对于开发人员来说可能比直接使用底层库（*libbpf*、*cilium/ebpf*等）更方便。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Andrii Nakryiko wrote an [excellent blog post](https://oreil.ly/aeQJo) that
    describes the background of CO-RE, as well as laying out how it works and how
    to use it. He also wrote the canonical [BPF CO-RE Reference Guide](https://oreil.ly/lbW_T),
    so please do read that if you’re embarking on writing code yourself. His [*libbpf-bootstrap*
    guide](https://oreil.ly/_jet-) to building an eBPF app from scratch with CO-RE
    + *libbpf* + skeletons is another must-read.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Andrii Nakryiko写了一篇[优秀的博客文章](https://oreil.ly/aeQJo)，描述了CO-RE的背景，以及它的工作原理和如何使用它。他还写了权威的[BPF
    CO-RE参考指南](https://oreil.ly/lbW_T)，所以如果您要开始编写代码，请务必阅读。他的[*libbpf-bootstrap*指南](https://oreil.ly/_jet-)介绍了如何使用CO-RE
    + *libbpf* +骨架从头开始构建eBPF应用程序，也是必读之物。
- en: Now that you have an overview of the elements of CO-RE, let’s dig in to see
    how they work, starting with an exploration of BTF.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了CO-RE的元素，让我们深入了解它们的工作原理，从探索BTF开始。
- en: BPF Type Format
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BPF类型格式
- en: BTF information describes how data structures and code are laid out in memory.
    This information can be put to a variety of different uses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: BTF信息描述了数据结构和代码在内存中的布局。这些信息可以用于各种不同的用途。
- en: BTF Use Cases
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BTF用例
- en: The main reason for discussing BTF in this chapter on CO-RE is that knowing
    the differences between a structure’s layout where an eBPF program was compiled
    and where it is about to run allows for the appropriate adjustments to be made
    as the program is loaded into the kernel. I’ll discuss the relocation process
    later in this chapter, but for now, let’s also consider some of the other uses
    to which BTF information can be put.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在CO-RE章节中讨论BTF的主要原因是，了解eBPF程序编译的结构布局与即将运行的结构布局之间的差异，可以在程序加载到内核时进行适当的调整。我将在本章后面讨论重定位过程，但现在，让我们也考虑一下BTF信息可以用于的其他一些用途。
- en: Knowing how a structure is laid out, and the type of every field in that structure,
    makes it possible to pretty-print a structure’s contents in human-readable form.
    For example, a string is just a series of bytes from the computer’s point of view,
    but converting those bytes into characters makes the string much easier for humans
    to understand. You already saw an example of this in the previous chapter, where
    `bpftool` used BTF information to format the output of map dumps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 了解结构的布局方式以及结构中每个字段的类型，可以使得以人类可读的形式打印结构的内容成为可能。例如，从计算机的角度来看，字符串只是一系列字节，但将这些字节转换为字符使得字符串对人类来说更容易理解。在上一章中，您已经看到了这方面的一个例子，`bpftool`使用BTF信息来格式化映射转储的输出。
- en: BTF information also includes the line and function information that enables
    `bpftool` to interleave source code within the output from translated or JITed
    program dumps, as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    When you come to [Chapter 6](ch06.html#the_ebpf_verifier), you’ll also see the
    source code information interleaved with the verifier log output, and again this
    comes from the BTF information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: BTF信息还包括行和函数信息，使得`bpftool`能够在翻译或JIT程序转储的输出中交错源代码，就像您在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到的那样。当您来到[第6章](ch06.html#the_ebpf_verifier)时，您还将看到源代码信息与验证器日志输出交错，这同样来自BTF信息。
- en: 'BTF information is also required for BPF spin locks. *Spin locks* are used
    to stop two CPU cores from simultaneously accessing the same map values. The lock
    has to be part of the map’s value structure, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BTF信息也是BPF自旋锁所必需的。*自旋锁*用于阻止两个CPU核同时访问相同的映射值。锁必须是映射值结构的一部分，就像这样：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Within the kernel, eBPF programs use `bpf_spin_lock()` and `bpf_spin_unlock()`
    helper functions to acquire and release a lock. These helpers can be used only
    if BTF information is available to describe where the lock field is within the
    structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，eBPF程序使用`bpf_spin_lock()`和`bpf_spin_unlock()`辅助函数来获取和释放锁。只有在BTF信息可用以描述结构中锁字段的位置时，才能使用这些辅助函数。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Spin lock support was added in kernel version 5.1\. There are lots of restrictions
    on the use of spin locks: they can only be used on hash or array map types, and
    they can’t be used in tracing or socket filter type eBPF programs. Read more about
    spin locks in the [lwn.net article on concurrency management in BPF](https://oreil.ly/kAyAU).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自旋锁支持是在内核版本5.1中添加的。对自旋锁的使用有很多限制：它们只能用于哈希或数组映射类型，并且不能用于跟踪或套接字过滤类型的eBPF程序。在[lwn.net关于BPF并发管理的文章](https://oreil.ly/kAyAU)中了解更多关于自旋锁的信息。
- en: Now that you know why BTF information is useful, let’s make it more concrete
    by looking at some examples.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道BTF信息的用途，让我们通过查看一些示例来使其更具体。
- en: Listing BTF Information with bpftool
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bpftool列出BTF信息
- en: 'As with programs and maps, you can use the `bpftool` utility to show BTF information.
    The following command lists all the BTF data loaded into the kernel:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序和映射一样，您可以使用`bpftool`实用程序显示BTF信息。以下命令列出了加载到内核中的所有BTF数据：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: (I’ve omitted many entries from the results for brevity.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: （出于简洁起见，我省略了许多条目。）
- en: The first entry in the list is `vmlinux`, and it corresponds to the *vmlinux*
    file I mentioned earlier that holds the BTF information about the currently running
    kernel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个条目是`vmlinux`，它对应于我之前提到的*vmlinux*文件，该文件保存了有关当前运行内核的BTF信息。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the examples early in this chapter reuse the programs from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    and then later in this chapter you’ll find new examples for which the source is
    in the *chapter5* directory at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早期的一些示例重用了[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中的程序，然后在本章后期，您将找到新的示例，其源代码位于[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)的*chapter5*目录中。
- en: 'To obtain this example output I ran this command while the `hello-buffer-config`
    example from [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) was
    running. You can see the entry describing the BTF information that this process
    is using, on the line that starts with `149:`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得此示例输出，我在运行[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中的`hello-buffer-config`示例时运行了此命令。您可以在以`149:`开头的行上看到描述此进程正在使用的BTF信息的条目：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s what that line is telling us:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这行告诉我们的是：
- en: This chunk of BTF information has ID 149.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个BTF信息块的ID是149。
- en: It’s an anonymous blob of around 4 KB of BTF information.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个大约4KB的BTF信息的匿名blob。
- en: It’s used by the BPF program with `prog_id 319` and the BPF map with `map_id
    103`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被具有`prog_id 319`的BPF程序和具有`map_id 103`的BPF映射使用。
- en: It’s also used by the process with ID 7660 (shown within parentheses) running
    the `hello-buffer-config` executable (whose name has been truncated to 15 characters).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还被ID为7660的进程（括号内显示）使用，运行名为`hello-buffer-config`的可执行文件（其名称已被截断为15个字符）。
- en: 'These program, map, and BTF identifiers match with the following output that
    `bpftool` shows about `hello-buffer-config`’s program called `hello`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序、映射和BTF标识符与`bpftool`显示的有关`hello-buffer-config`的名为`hello`的程序的输出相匹配：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only thing that doesn’t appear to match completely between these two sets
    of information is that the program refers to an extra `map_id`, `104`. That’s
    the perf event buffer map, and it doesn’t use BTF information; hence, it doesn’t
    appear in the BTF-related output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一似乎不完全匹配的是程序引用了额外的`map_id`，`104`。那是性能事件缓冲区映射，它不使用BTF信息；因此，它不会出现在与BTF相关的输出中。
- en: Much like `bpftool` can dump the contents of programs and maps, it can also
    be used to view the BTF type information contained in a blob of data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`bpftool`可以转储程序和映射的内容一样，它也可以用来查看包含在数据块中的BTF类型信息。
- en: BTF Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BTF类型
- en: 'Knowing the ID of the BTF information, you can inspect its contents with the
    command `bpftool btf dump id <id>`. When I ran this using the ID 149 that I obtained
    earlier, I got 69 lines of output, each of which is a type definition. I’ll just
    describe the first few lines, which should give you a good idea of how to interpret
    the rest. The BTF information from these first few lines relates to the `config`
    hash map, which was defined in the source code like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 知道BTF信息的ID后，可以使用命令`bpftool btf dump id <id>`来检查其内容。当我使用之前获得的ID 149运行时，我得到了69行输出，每行都是一个类型定义。我只描述前几行，这应该能让你很好地理解如何解释其余部分。这些前几行的BTF信息与在源代码中定义的`config`哈希映射相关：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]This hash table has keys of type `u32` and values of type `struct user_msg_t`.
    That structure holds a 12-byte `message` field. Let’s see how these types are
    defined in the corresponding BTF information.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]这个哈希表的键的类型是`u32`，值的类型是`struct user_msg_t`。该结构包含一个12字节的`message`字段。让我们看看这些类型在相应的BTF信息中是如何定义的。'
- en: 'The first three lines of the BTF output are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: BTF输出的前三行如下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The number in square brackets at the start of each line is the type ID (so
    the first line, starting with `[1]`, defines `type_id 1`, etc.). Let’s dive into
    these three types in more detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每行开头的方括号中的数字是类型ID（因此第一行，以`[1]`开头，定义了`type_id 1`，依此类推）。让我们更详细地了解这三种类型：
- en: Type 1 defines a type named `u32` and its type, defined by `type_id 2`, that
    is, the type defined in the line that starts with `[2]`. As you know, the keys
    in the hash table have this type `u32`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型1定义了一个名为`u32`的类型及其类型，由`type_id 2`定义，即在以`[2]`开头的行中定义的类型。你知道，哈希表中的键具有这种类型`u32`。
- en: Type 2 has the name `__u32` and the type defined by `type_id 3`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型2的名称是`__u32`，由`type_id 3`定义的类型。
- en: Type 3 is an integer type with the name `unsigned int`, which is 4 bytes long.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型3是一个名为`unsigned int`的整数类型，长度为4字节。
- en: All three of these types are synonyms for a 32-bit unsigned integer type. In
    C, the lengths of integers are platform dependent, so Linux defines types like
    `u32` to explicitly define integers of specific lengths. On this machine, `u32`
    corresponds to an unsigned integer. User space code that refers to these should
    use the synonym prefixed with underscores, as in `__u32`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型都是32位无符号整数类型的同义词。在C中，整数的长度取决于平台，因此Linux定义了像`u32`这样的类型，以明确定义特定长度的整数。在这台机器上，`u32`对应于无符号整数。引用这些的用户空间代码应该使用带下划线前缀的同义词，如`__u32`。
- en: 'The next few types in the BTF output look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BTF输出中的接下来几种类型如下：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These relate to the `user_msg_t` structure used for values in the `config`
    map:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与`config`映射中的值使用的`user_msg_t`结构相关：
- en: Type 4 is the `user_msg_t` structure itself, and in total it is 12 bytes long.
    It contains one field named `message`, which is defined by type 6\. The `vlen`
    field indicates how many fields there are in this definition.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型4是`user_msg_t`结构本身，总共有12个字节长。它包含一个名为`message`的字段，由类型6定义。`vlen`字段指示了这个定义中有多少个字段。
- en: Type 5 is named `char` and is a 1-byte integer—exactly the definition a C programmer
    would expect for a type called “char.”
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型5的名称是`char`，是一个1字节的整数——这正是C程序员对名为“char”的类型所期望的定义。
- en: Type 6 defines the type for that `message` field as an array with 12 elements.
    Each element has type 5 (it’s a `char`), and the array is indexed by type 7.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型6将`message`字段定义为一个具有12个元素的数组。每个元素的类型为5（它是一个`char`），并且该数组由类型7索引。
- en: Type 7 is a 4-byte integer.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型7是一个4字节的整数。
- en: With these definitions, you can build a complete picture of how the `user_msg_t`
    structure is laid out in memory, as illustrated in [Figure 5-1](#a_user_msg_t_structure_takes_onetwo_byt).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，你可以完整地了解`user_msg_t`结构在内存中的布局，就像[图5-1](#a_user_msg_t_structure_takes_onetwo_byt)中所示的那样。
- en: '![A user_msg_t structure takes 12 bytes of memory](assets/lebp_0501.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![user_msg_t结构占用12字节内存](assets/lebp_0501.png)'
- en: Figure 5-1\. A `user_msg_t` structure takes 12 bytes of memory
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. `user_msg_t`结构占用12字节内存
- en: 'So far, all the entries have `bits_offset` set to `0`, but the next line of
    output has a structure with more than one field:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有条目的`bits_offset`都设置为`0`，但是输出的下一行有一个具有多个字段的结构：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a structure definition for the key–value pairs stored in the map called
    `config`. I didn’t define this `____btf_map_config` type myself in the source
    code, but it has been generated by BCC. The key is of type `u32`, and the value
    is the `user_msg_t` structure. These correspond to the types 1 and 4 that you
    saw earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于存储名为`config`的映射中的键值对的结构定义。我没有在源代码中定义这个`____btf_map_config`类型，但它是由BCC生成的。键的类型是`u32`，值是`user_msg_t`结构。这些对应于之前看到的类型1和4。
- en: The other important part of the BTF information about this structure is that
    the `value` field starts 32 bits after the start of the structure. That completely
    makes sense because the first 32 bits are needed to hold the `key` field.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个结构的BTF信息的另一个重要部分是`value`字段在结构开始后32位开始。这完全合理，因为前32位需要保存`key`字段。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In C, structure fields get automatically aligned to boundaries, so you can’t
    simply assume that one field always follows directly after the previous one in
    memory. For example, consider a structure like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，结构字段会自动对齐到边界，因此不能简单地假设一个字段总是直接跟在前一个字段的内存中。例如，考虑这样一个结构：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10][PRE11]## Maps with BTF Information'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10][PRE11]## 带有BTF信息的映射'
- en: You’ve just seen the BTF information associated with a map. Now let’s see how
    this BTF data is passed to the kernel when the map is created.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了与映射相关的BTF信息。现在让我们看看在创建映射时内核如何传递此BTF数据。
- en: 'You saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) that
    maps are created using the `bpf(BPF_MAP_CREATE)` syscall. This takes a `bpf_attr`
    structure as a parameter, [defined in the kernel](https://oreil.ly/PLrYG) like
    this (some details omitted):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到，映射是使用`bpf(BPF_MAP_CREATE)`系统调用创建的。这需要一个`bpf_attr`结构作为参数，[在内核中定义](https://oreil.ly/PLrYG)如下（一些细节被省略）：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before the introduction of BTF, the `btf_*` fields weren’t present in this `bpf_attr`
    structure, and the kernel had no knowledge of the structure of keys or values.
    The `key_size` and `value_size` fields defined how much memory was required for
    them, but they were just treated as so many bytes. By additionally passing in
    the BTF information defining the types of the keys and values, the kernel can
    introspect them, and utilities like `bpftool` can retrieve the type information
    for pretty-printing, as discussed earlier. However, it’s interesting to note that
    separate BTF `type _id`s are passed in for the key and the value. The `____btf_map_config`
    structure that you just saw defined isn’t used by the kernel for the map definition;
    it’s just used by BCC on the user space side.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入BTF之前，`btf_*`字段不存在于`bpf_attr`结构中，内核对键或值的结构一无所知。`key_size`和`value_size`字段定义了它们所需的内存量，但它们只是被视为一些字节。通过另外传递定义键和值类型的BTF信息，内核可以内省它们，而像`bpftool`这样的实用程序可以检索类型信息以进行漂亮的打印，如前面讨论的那样。但是，有趣的是要注意为键和值分别传递了单独的BTF
    `type _id`。您刚刚看到的`____btf_map_config`结构并未被内核用于映射定义；它只是由用户空间的BCC使用。
- en: BTF Data for Functions and Function Prototypes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和函数原型的BTF数据
- en: 'So far the BTF data in this example output has related to data types, but the
    BTF data also contains information about functions and function prototypes. Here’s
    the information from the same BTF data blob that describes the `hello` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，此示例输出中的BTF数据与数据类型有关，但BTF数据还包含有关函数和函数原型的信息。以下是描述`hello`函数的相同BTF数据块中的信息：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In type 32 you can see the function named `hello` is defined as having the
    type defined in the previous line. That’s a *function prototype*, which returns
    a value of type ID `23` and takes a single parameter (`vlen=1`) called `ctx` with
    type ID `10`. For completeness, here are the definitions of those types from earlier
    in the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型32中，您可以看到名为`hello`的函数被定义为具有前一行中定义的类型。这是一个*函数原型*，它返回类型ID `23`的值，并带有一个名为`ctx`的单个参数（`vlen=1`），其类型ID为`10`。为了完整起见，这里是输出中较早时那些类型的定义：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Type 10 is an anonymous pointer with the default type of `0`, which isn’t explicitly
    included in the BTF output but is defined as a void pointer.^([4](ch05.html#ch05fn4))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类型10是一个匿名指针，其默认类型为`0`，在BTF输出中没有明确包含，但被定义为void指针。^([4](ch05.html#ch05fn4))
- en: 'The return value with type 23 is a 4-byte integer, and `encoding=SIGNED` indicates
    that it’s a signed integer; that is, it can have either a positive or negative
    value. This corresponds to the function definition in the source code of *hello-buffer-config.py*,
    which looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类型23的返回值是一个4字节整数，`encoding=SIGNED`表示它是一个有符号整数；也就是说，它可以具有正值或负值。这对应于*hello-buffer-config.py*源代码中的函数定义，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`The example BTF information I’ve shown so far comes from listing the contents
    of a blob of BTF data. Let’s see how to obtain just the BTF information that relates
    to a particular map or program.`  `## Inspecting BTF Data for Maps and Programs'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的示例BTF信息来自于列出BTF数据块的内容。让我们看看如何仅获取与特定映射或程序相关的BTF信息。## 检查映射和程序的BTF数据
- en: 'If you want to inspect the BTF types associated with a particular map, `bpftool`
    makes that easy. For example, here’s the output for the `config` map:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查与特定映射相关的BTF类型，`bpftool`可以轻松实现。例如，这是`config`映射的输出：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similarly, you can inspect the BTF information related to a particular program
    with `bpftool btf dump prog <prog identity>`. I’ll leave you to check out the
    [manpage](https://oreil.ly/lCoV5) for additional details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`bpftool btf dump prog <prog identity>`检查与特定程序相关的BTF信息。我会让您查看[manpage](https://oreil.ly/lCoV5)以获取更多详细信息。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’d like to better understand how the BTF type data is generated and de-duplicated,
    there is another [excellent blog post from Andrii Nakryiko](https://oreil.ly/0-a9g)
    on the subject.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更好地了解BTF类型数据是如何生成和去重的，还有另一篇[Andrii Nakryiko的博客文章](https://oreil.ly/0-a9g)可以参考。
- en: By this stage you should have an understanding of how BTF describes the format
    of data structures and functions. An eBPF program written in C needs header files
    that define the types and structures. Let’s see how easy it is to generate a header
    file for any kernel data types that an eBPF program might need.[PRE17]# Generating
    a Kernel Header File
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经了解了BTF如何描述数据结构和函数的格式。用C编写的eBPF程序需要定义类型和结构的头文件。让我们看看为eBPF程序可能需要的任何内核数据类型生成头文件有多容易。[PRE17]#
    生成内核头文件
- en: 'If you run `bpftool btf list` on a BTF-enabled kernel, you’ll see lots of preexisting
    blobs of BTF data that look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启用了BTF的内核上运行`bpftool btf list`，您将看到许多预先存在的BTF数据块，看起来像这样：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first item in this list, with ID 1 and named `vmlinux`, is the BTF information
    about all the data types, structures, and function definitions used by the kernel
    that’s running on this (virtual) machine.^([5](ch05.html#ch05fn5))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的第一项，ID为1，名称为`vmlinux`，是有关运行在此（虚拟）机器上的内核使用的所有数据类型、结构和函数定义的BTF信息。^([5](ch05.html#ch05fn5))
- en: An eBPF program needs the definitions of any kernel data structures and types
    that it is going to refer to. Before the days of CO-RE, you’d typically have to
    figure out which of the many individual header files in the Linux kernel source
    held the definition for the structures you were interested in, but now there is
    a much easier way, as BTF-enabled tools can generate an appropriate header file
    from the BTF information included with the kernel.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序需要它将要引用的任何内核数据结构和类型的定义。在CO-RE出现之前，您通常需要弄清楚Linux内核源代码中的许多个别头文件中哪一个包含了您感兴趣的结构的定义，但现在有了一个更简单的方法，因为启用了BTF的工具可以从内核中包含的BTF信息生成一个适当的头文件。
- en: 'This header file is conventionally called *vmlinux.h*, and you can generate
    it with `bpftool` like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件通常被称为*vmlinux.h*，您可以使用`bpftool`生成它，就像这样：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This file defines all the kernel’s data types, so including this generated *vmlinux.h*
    file in your eBPF program source supplies the definitions of any Linux data structures
    you might need. When you compile the source into an eBPF object file, that object
    will include BTF information that matches the definitions used in this header
    file. Later, when the program is run on a target machine, the user space program
    that loads it into the kernel will make adjustments to account for differences
    between this build-time BTF information and the BTF information for the kernel
    that’s running on that target machine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了所有内核的数据类型，因此在您的eBPF程序源代码中包含这个生成的*vmlinux.h*文件会提供您可能需要的任何Linux数据结构的定义。当您将源代码编译成eBPF对象文件时，该对象将包含与此头文件中使用的定义相匹配的BTF信息。稍后，在目标机器上运行程序时，将加载它到内核中的用户空间程序将对构建时的BTF信息和在目标机器上运行的内核的BTF信息之间的差异进行调整。
- en: BTF information in the form of the */sys/kernel/btf/vmlinux* file has been included
    in the Linux kernel since version 5.4,^([6](ch05.html#ch05fn6)) but raw BTF data
    that *libbpf* can make use of can also be generated for older kernels. In other
    words, if you want to run a CO-RE–enabled eBPF program on a target machine that
    doesn’t have BTF information already, you might be able to provide the BTF data
    for that target yourself. There’s information on how to generate BTF files, and
    an archive of files for a variety of Linux distributions, on the [BTFHub](https://oreil.ly/mPSO0).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux内核5.4版本以来，以*/sys/kernel/btf/vmlinux*文件的形式包含的BTF信息，^([6](ch05.html#ch05fn6))，但*libbpf*可以利用的原始BTF数据也可以为较旧的内核生成。换句话说，如果您想在目标机器上运行一个启用了CO-RE的eBPF程序，而该目标机器尚未具有BTF信息，您可能可以自己提供该目标的BTF数据。有关如何生成BTF文件以及各种Linux发行版的文件存档的信息，请访问[BTFHub](https://oreil.ly/mPSO0)。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The BTFHub repo also includes further reading about [BTF internals](https://oreil.ly/CfyQh)
    should you want to dive deeper into this topic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: BTFHub存储库还包括有关[BTF内部](https://oreil.ly/CfyQh)的进一步阅读，如果您想深入了解这个主题。
- en: Next, let’s look at how this and other tactics are used to write eBPF programs
    to be portable across kernels using CO-RE.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用这种和其他策略来编写可在使用CO-RE的内核之间移植的eBPF程序。
- en: CO-RE eBPF Programs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE eBPF程序
- en: You’ll recall that eBPF programs run in the kernel. Later in this chapter I’ll
    show some user space code that will interact with the code running in the kernel,
    but in this section I’m concentrating on the kernel side.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得eBPF程序在内核中运行。在本章的后面，我将展示一些用户空间代码，这些代码将与内核中运行的代码进行交互，但在本节中，我集中讨论内核方面。
- en: As you’ve already seen, eBPF programs are compiled to eBPF bytecode, and (at
    least at the time of this writing) the compilers that support this are Clang or
    gcc for compiling C code, and the Rust compiler. I’ll discuss some of your options
    for using Rust in [Chapter 10](ch10.html#ebpf_programming), but for the purposes
    of this chapter I’ll assume you’re writing in C and using Clang, along with the
    *libbpf* library.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，eBPF程序被编译成eBPF字节码，而（至少在撰写本文时）支持此功能的编译器是Clang或gcc用于编译C代码，以及Rust编译器。我将在[第10章](ch10.html#ebpf_programming)中讨论一些您在使用Rust时的选择，但在本章中，我将假设您是用C语言编写的，并使用Clang，以及*libbpf*库。
- en: For the remainder of this chapter, let’s consider an example application called
    *hello-buffer-config*. It’s very similar to the *hello-buffer-config.py* example
    from the previous chapter that used the BCC framework, but this version is written
    in C to use *libbpf* and CO-RE.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，让我们考虑一个名为*hello-buffer-config*的示例应用程序。它与上一章中使用BCC框架的*hello-buffer-config.py*示例非常相似，但这个版本是用C语言编写的，以使用*libbpf*和CO-RE。
- en: If you have BCC-based eBPF code that you want to migrate to *libbpf*, check
    out the excellent and comprehensive [guide by Andrii Nakryiko on his website](https://oreil.ly/iWDcv).
    BCC provides some convenient shortcuts that aren’t handled in quite the same way
    using *libbpf*; conversely, *libbpf* provides its own set of macros and library
    functions to make life easier for the eBPF programmer. As I walk through the example,
    I will point out a few differences between the BCC and *libbpf* approaches.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有基于BCC的eBPF代码，想要迁移到*libbpf*，请查看Andrii Nakryiko在他的网站上的优秀而全面的[指南](https://oreil.ly/iWDcv)。BCC提供了一些方便的快捷方式，使用*libbpf*的方式并不完全相同；相反，*libbpf*提供了一套宏和库函数，以使eBPF程序员的生活更加轻松。当我演示示例时，我将指出BCC和*libbpf*方法之间的一些差异。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll find the example C eBPF program to accompany this section in the *chapter5*
    directory of the [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)
    repo.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)存储库的*chapter5*目录中找到本节的示例C
    eBPF程序。
- en: First let’s look at *hello-buffer-config.bpf.c*, which implements the eBPF program
    that runs in the kernel. Later in the chapter I’ll show you the user space code
    in *hello-buffer-config.c* that loads the program and displays output, much as
    the Python code did in the BCC implementation of this example in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下*hello-buffer-config.bpf.c*，它实现了在内核中运行的eBPF程序。本章后面我将向您展示*hello-buffer-config.c*中的用户空间代码，该代码加载程序并显示输出，就像Python代码在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中对此示例的BCC实现所做的那样。
- en: Like any C program, an eBPF program will need to include some header files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何C程序一样，eBPF程序将需要包含一些头文件。
- en: Header Files
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'The first few lines of *hello-buffer-config.bpf.c* specify the header files
    that it needs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello-buffer-config.bpf.c*的前几行指定了它需要的头文件：'
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These five files are the *vmlinux.h* file, a few headers from *libbpf*, and
    an application-specific header file that I wrote myself. Let’s see why this is
    a typical pattern for the header files needed for a *libbpf* program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个文件是*vmlinux.h*文件，*libbpf*的一些头文件和我自己编写的特定于应用程序的头文件。让我们看看为*libbpf*程序所需的头文件为什么是典型的模式。
- en: Kernel header information
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核头信息
- en: If you’re writing an eBPF program that refers to any kernel data structures
    or types, the easiest option is to include the *vmlinux.h* file described earlier
    in this chapter. Alternatively, it’s possible to include individual header files
    from the Linux source, or to define the types by hand in your own code if you
    really want to go to that trouble. If you’re going to use any BPF helper functions
    from *libbpf*, you’ll need to include either *vmlinux.h* or *linux/types.h* to
    get the definitions for types like `u32`, `u64`, and so on, that the BPF helper
    source refers to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写引用任何内核数据结构或类型的eBPF程序，最简单的选择是包含本章前面描述的*vmlinux.h*文件。或者，也可以从Linux源中包含单个头文件，或者在自己的代码中手动定义类型，如果您真的想要这样做的话。如果要使用*libbpf*中的任何BPF辅助函数，您需要包含*vmlinux.h*或*linux/types.h*，以获取BPF辅助源引用的`u32`、`u64`等类型的定义。
- en: The *vmlinux.h* file is derived from the kernel source headers, but it doesn’t
    include `#define`’d values from them. For example, if your eBPF program parses
    Ethernet packets, you’ll probably need the constant definitions that tell you
    what protocol the packet contains (such as `0x0800` to indicate that it’s an IP
    packet, or `0x0806` for an ARP packet). There is a series of constant values that
    you’ll need to duplicate in your own code, if you don’t include the [*if_ether.h*
    file](https://oreil.ly/hoZzP) that defines these values for the kernel. I didn’t
    need any of these value definitions for *hello-buffer-config*, but you’ll see
    another example in [Chapter 8](ch08.html#ebpf_for_networking) where this is relevant.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*vmlinux.h*文件源自内核源头文件，但不包括其中的`#define`值。例如，如果您的eBPF程序解析以太网数据包，则可能需要告诉您数据包包含的协议的常量定义（例如`0x0800`表示它是IP数据包，或`0x0806`表示ARP数据包）。如果您不包括定义这些值的[*if_ether.h*文件](https://oreil.ly/hoZzP)，则需要在自己的代码中复制一系列常量值。对于*hello-buffer-config*，我不需要这些值定义，但您将在[第8章](ch08.html#ebpf_for_networking)中看到另一个示例，其中这是相关的。'
- en: Headers from libbpf
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自libbpf的头文件
- en: To use any BPF helper functions in your eBPF code, you’ll need to include the
    header files from *libbpf* that give you their definitions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要在eBPF代码中使用任何BPF辅助函数，您需要包含*libbpf*中给出其定义的头文件。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One thing that can be slightly confusing about *libbpf* is that it’s not just
    a user space library. You’ll find yourself including header files from *libbpf*
    in both user space and eBPF C code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*libbpf*可能会让人稍微困惑的一件事是，它不仅仅是一个用户空间库。您将发现自己在用户空间和eBPF C代码中都包含*libbpf*的头文件。
- en: At the time of this writing, it is common to see eBPF projects including *libbpf*
    as a submodule and building/installing from source—this is what I have done in
    the example repository for this book. If you include it as a submodule, you’ll
    simply need to run `make install` from the *libbpf/src* directory. I don’t think
    it will be long before it’s more common to see *libbpf* widely available as a
    package on common Linux distributions, particularly since *libbpf* has now passed
    the milestone of a [version 1.0 release](https://oreil.ly/8BFq6).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，通常会看到eBPF项目将*libbpf*作为子模块包含并从源代码构建/安装-这是我在本书示例存储库中所做的。如果将其包含为子模块，则只需从*libbpf/src*目录运行`make
    install`。我认为不久之后，*libbpf*将更常见地作为常见Linux发行版上的软件包提供，特别是自从*libbpf*现在已经通过了[1.0版本发布](https://oreil.ly/8BFq6)的里程碑。
- en: Application-specific headers
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于应用程序的头文件
- en: 'It’s very common to have an application-specific header file that defines any
    structures that are used by both the user space and eBPF parts of your app. In
    my example, the *hello-buffer-config.h* header file defines the `data_t` structure
    that I’m using to pass event data from the eBPF program to user space. It’s almost
    the same structure you saw in the BCC version of this code, and it looks like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有一个特定于应用程序的头文件，定义了用户空间和eBPF应用程序的共同使用的任何结构。在我的示例中，*hello-buffer-config.h*头文件定义了`data_t`结构，我用它来从eBPF程序传递事件数据到用户空间。它几乎与您在此代码的BCC版本中看到的结构相同，看起来是这样的：
- en: '[PRE21][PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21][PRE22]'
- en: '[PRE23]  [PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]  [PRE24]'
- en: struct{ `__uint``(``type``,``BPF_MAP_TYPE_PERF_EVENT_ARRAY``);` ``__uint``(``key_size``,``sizeof``(``u32``));`
    ``__uint``(``value_size``,``sizeof``(``u32``));` ``}``output``SEC``(``".maps"``);`
    ``struct``user_msg_t``{` ``char``message``[``12``];` ``};` ``struct``{` ``__uint``(``type``,``BPF_MAP_TYPE_HASH``);`
    ``__uint``(``max_entries``,``10240``);` ``__type``(``key``,``u32``);` ``__type``(``value``,``struct``user_msg_t``);`
    ``}``my_config``SEC``(``".maps"``);[PRE25][PRE26]  [PRE27]
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: struct{ `__uint``(``type``,``BPF_MAP_TYPE_PERF_EVENT_ARRAY``);` ``__uint``(``key_size``,``sizeof``(``u32``));`
    ``__uint``(``value_size``,``sizeof``(``u32``));` ``}``output``SEC``(``".maps"``);`
    ``struct``user_msg_t``{` ``char``message``[``12``];` ``};` ``struct``{` ``__uint``(``type``,``BPF_MAP_TYPE_HASH``);`
    ``__uint``(``max_entries``,``10240``);` ``__type``(``key``,``u32``);` ``__type``(``value``,``struct``user_msg_t``);`
    ``}``my_config``SEC``(``".maps"``);[PRE25][PRE26]  [PRE27]
- en: SEC("kprobe")
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SEC（“kprobe”）
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: SEC("kprobe/__arm64_sys_execve")
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SEC("ksyscall/execve")
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: SEC("ksyscall/execve")
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`__builtin_preserve_access_index()`指令是对“常规”C代码的扩展，将其添加到eBPF还需要对Clang编译器进行更改以支持它并发出这些CO-RE重定位条目。这些扩展是一些C编译器今天（至少）无法生成eBPF字节码的原因的例子。在[LLVM邮件列表](https://oreil.ly/jHTHE)上阅读有关Clang对eBPF
    CO-RE支持所需的更改的更多信息。
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: SEC("ksyscall/execve")intBPF_KPROBE_SYSCALL(hello,constchar*pathname)![1](assets/1.png){structdata_tdata={};structuser_msg_t*p;data.pid=bpf_get_current_pid_tgid()>>32;data.uid=bpf_get_current_uid_gid()&0xFFFFFFFF;bpf_get_current_comm(&data.command,sizeof(data.command));bpf_probe_read_user_str(&data.path,sizeof(data.path),pathname);![2](assets/2.png)p=bpf_map_lookup_elem(&my_config,&data.uid);![3](assets/3.png)if(p!=0){bpf_probe_read_kernel(&data.message,sizeof(data.message),p->message);}else{bpf_probe_read_kernel(&data.message,sizeof(data.message),message);}bpf_perf_event_output(ctx,&output,BPF_F_CURRENT_CPU,![4](assets/4.png)&data,sizeof(data));return0;}
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE45]cpp## 对象文件中的BTF信息'
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: charmessage[12]="Hello World";
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您稍后在本章中将看到的，CO-RE重定位条目告诉*libbpf*在将eBPF程序加载到内核时重新编写地址，以考虑任何BTF差异。如果`src`在其包含结构中的偏移在目标内核上不同，重新编写的指令将考虑到这一点。
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: inthello(void*ctx)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到的`bpf_core_read()`中，直接调用`bpf_probe_read_kernel()`，唯一的区别是它用`__builtin_preserve_access_index()`包装了`src`字段。这告诉Clang在访问内存中的这个地址时发出CO-RE重定位条目以及eBPF指令。
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: bpf_perf_event_output(ctx,&output,BPF_F_CURRENT_CPU,&data,sizeof(data));
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`然后您可以使用`bpf_probe_read_kernel()`辅助函数从点`d`读取。'
- en: '[PRE34][PRE35]## Memory Access with CO-RE'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Andrii的[指南](https://oreil.ly/tU0Gb)中有一个很好的描述。
- en: eBPF programs for tracing have restricted access to memory, via a BPF helper
    function from the `bpf_probe_read_*()` family.^([8](ch05.html#ch05fn8)) (There
    is also a `bpf_probe_write_user()` helper function, but it’s only [“meant for
    experiments”](https://oreil.ly/ibcy1)). The problem is that, as you’ll see in
    the next chapter, the eBPF verifier generally won’t let you simply read memory
    through a pointer as you usually can in C (e.g., `x = p->y`).^([9](ch05.html#ch05fn9))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]`'
- en: 'The *libbpf* library provides CO-RE wrappers around the `bpf_probe_read_*()`
    helpers to take advantage of the BTF information and make memory access calls
    portable across different kernel versions. Here’s an example of one of those wrappers,
    as defined in the [*bpf_core_read.h* header file](https://oreil.ly/XWWyc):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: charmessage[12]="Hello World";
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, `bpf_core_read()` calls directly to `bpf_probe_read_kernel()`,
    the only difference being that it wraps the `src` field with `__builtin_preserve_access_index()`.
    This tells Clang to emit a CO-RE relocation entry along with the eBPF instruction
    that accesses this address in memory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34][PRE35]## CO-RE内存访问'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '*libbpf*库提供了围绕`bpf_probe_read_*()`辅助函数的CO-RE包装，以利用BTF信息并使内存访问调用在不同的内核版本中可移植。以下是其中一个这些包装的示例，定义在[*bpf_core_read.h*头文件](https://oreil.ly/XWWyc)中。'
- en: This `__builtin_preserve_access_index()` instruction is an extension to “regular”
    C code, and adding it to eBPF also required changes to the Clang compiler to support
    it and emit these CO-RE relocation entries. Extensions like these are examples
    of why some C compilers cannot (today, at least) generate eBPF bytecode. Read
    more about the Clang changes required for eBPF CO-RE support on the [LLVM mailing
    list](https://oreil.ly/jHTHE).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SEC("ksyscall/execve")intBPF_KPROBE_SYSCALL(hello,constchar*pathname)![1](assets/1.png){structdata_tdata={};structuser_msg_t*p;data.pid=bpf_get_current_pid_tgid()>>32;data.uid=bpf_get_current_uid_gid()&0xFFFFFFFF;bpf_get_current_comm(&data.command,sizeof(data.command));bpf_probe_read_user_str(&data.path,sizeof(data.path),pathname);![2](assets/2.png)p=bpf_map_lookup_elem(&my_config,&data.uid);![3](assets/3.png)if(p!=0){bpf_probe_read_kernel(&data.message,sizeof(data.message),p->message);}else{bpf_probe_read_kernel(&data.message,sizeof(data.message),message);}bpf_perf_event_output(ctx,&output,BPF_F_CURRENT_CPU,![4](assets/4.png)&data,sizeof(data));return0;}
- en: As you’ll see later in this chapter, the CO-RE relocation entry tells *libbpf*
    to rewrite the address, as it’s loading the eBPF program into the kernel, to take
    account of any BTF differences. If the offset of `src` within its containing structure
    is different on the target kernel, the rewritten instruction will take that into
    account.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库提供了`BPF_CORE_READ()`宏，以便您可以在一行中写入多个`bpf_core_read()`调用，而不需要为每个指针解引用调用一个单独的辅助函数。例如，如果您想要做类似`d
    = a->b->c->d`的事情，您可以编写以下代码：'
- en: 'The *libbpf* library provides a `BPF_CORE_READ()` macro so that you can write
    several `bpf_core_read()` calls in a single line rather than needing a separate
    helper function call for every pointer dereference. For example, if you wanted
    to do something like `d = a->b->c->d`, you could write the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`您现在已经看到了*hello-buffer-config.bpf.c*示例中的所有代码。现在让我们将其编译成一个对象文件。'
- en: '[PRE37]`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42][PRE43]``cpp`'
- en: '[PRE38]But it’s much more compact to use:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]但使用起来更紧凑：'
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`You can then read from point `d` using the `bpf_probe_read_kernel()` helper
    function.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪的eBPF程序通过`bpf_probe_read_*()`家族的BPF辅助函数对内存的访问受到限制。^([8](ch05.html#ch05fn8))（还有一个`bpf_probe_write_user()`辅助函数，但它只是[“用于实验”](https://oreil.ly/ibcy1)）。问题在于，正如您将在下一章中看到的，eBPF验证器通常不会让您像在C中那样简单地通过指针读取内存（例如，`x
    = p->y`）。^([9](ch05.html#ch05fn9))
- en: There’s a good description of this in Andrii’s [guide](https://oreil.ly/tU0Gb).[PRE40]##
    License Definition
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE40]## 许可证定义'
- en: 'As you already know from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    the eBPF program has to declare its license. The example code does it like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SEC("kprobe/__arm64_sys_execve")
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`You’ve now seen all the code in the *hello-buffer-config.bpf.c* example. Now
    let’s compile it into an object file.[PRE42][PRE43]``cpp`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第3章](ch03.html#anatomy_of_an_ebpf_program)中已经知道的，eBPF程序必须声明其许可证。示例代码是这样做的：
- en: '[PRE44]cppIf you’re using the example code, you should be able to build the
    eBPF object file *hello-buffer-config.bpf.o* (and its companion user space executable
    that I’ll describe shortly) by running `make` in the *chapter5* directory. Let’s
    inspect that object file to see that it includes BTF information.[PRE45]cpp##
    BTF Information in the Object File'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]cpp如果您使用示例代码，应该能够通过在*chapter5*目录中运行`make`来构建eBPF对象文件*hello-buffer-config.bpf.o*（以及我将很快描述的伴随的用户空间可执行文件）。让我们检查该对象文件，看看它是否包含BTF信息。'
- en: 'The [kernel documentation for BTF](https://oreil.ly/5QrBy) describes how BTF
    data is encoded in an ELF object file in two sections: *.BTF*, which contains
    the data and string information, and *.BTF.ext*, which covers function and line
    information. You can use `readelf` to see that these sections have been added
    to the object file, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[BTF的内核文档](https://oreil.ly/5QrBy)描述了BTF数据如何在ELF对象文件中以两个部分进行编码：*.BTF*，其中包含数据和字符串信息，以及*.BTF.ext*，其中包含函数和行信息。您可以使用`readelf`来查看这些部分是否已添加到对象文件中，就像这样：'
- en: '[PRE46]cpp'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]cpp'
- en: 'The `bpftool` utility lets us examine the BTF data from an object file, like
    this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftool`实用程序允许我们检查对象文件中的BTF数据，就像这样：'
- en: '[PRE47]cpp'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]cpp'
- en: The output looks just like the output you get from dumping BTF info from loaded
    programs and maps, as you saw earlier in this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来就像您从加载的程序和映射中转储BTF信息时获得的输出，就像您在本章前面看到的那样。
- en: Let’s see how this BTF information can be used to allow the program to run on
    another machine with a different kernel version and different data structures.[PRE48]cpp#
    BPF Relocations
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些BTF信息来允许程序在具有不同内核版本和不同数据结构的另一台机器上运行。[PRE48]cpp# BPF重定位
- en: The *libbpf* library adapts eBPF programs to work with the data structure layout
    on the target kernel where they run, even if this layout is different from the
    kernel where the code was compiled. To do this, *libbpf* needs the BPF CO-RE relocation
    information generated by Clang as part of the compilation process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库将eBPF程序适配到目标内核上的数据结构布局，即使此布局与编译代码的内核不同。为此，*libbpf*需要Clang在编译过程中生成的BPF
    CO-RE重定位信息。'
- en: 'You can learn more about how the relocations work from the definition of `struct
    bpf_core_relo` in the [*linux/bpf.h*](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711)
    header file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[*linux/bpf.h*](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711)头文件中`struct
    bpf_core_relo`的定义中了解有关重定位工作原理的更多信息：
- en: '[PRE49]cpp'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE49]cpp'
- en: The CO-RE relocation data for an eBPF program consists of one of these structures
    for each instruction that needs relocation. Suppose the instruction is setting
    a register to the value of a field within a structure. The `bpf_core_relo` structure
    for that instruction (identified by the `insn_off` field) encodes the BTF type
    of that structure (the `type_id` field) and also indicates how the field is accessed
    relative to that structure (`access_str_off`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序的CO-RE重定位数据由每个需要重定位的指令的这些结构之一组成。假设该指令正在将寄存器设置为结构中字段的值。该指令的`bpf_core_relo`结构（由`insn_off`字段标识）对该结构的BTF类型（`type_id`字段）进行编码，并且还指示相对于该结构的字段如何被访问（`access_str_off`）。
- en: 'As you’ve just seen, the relocation data for the kernel data structures is
    generated automatically by Clang and encoded in the ELF object file. It’s the
    following line, which you’ll find near the start of the *vmlinux.h* file, that
    causes Clang to do this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚刚看到的，Clang会自动生成内核数据结构的重定位数据，并将其编码到ELF对象文件中。就是下面这行，您会在*vmlinux.h*文件的开头附近找到，它导致Clang执行此操作：
- en: '[PRE50]cpp'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE50]cpp'
- en: The `preserve_access_index` attribute tells Clang to generate BPF CO-RE relocations
    for a type definition. The `clang attribute push` part says that this attribute
    should be applied to all definitions until a `clang attribute pop`, which appears
    at the end of the file. That means Clang generates the relocation information
    for all the types defined in *vmlinux.h*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`preserve_access_index`属性告诉Clang为类型定义生成BPF CO-RE重定位。`clang attribute push`部分表示该属性应应用于所有定义，直到出现`clang
    attribute pop`，该语句出现在文件末尾。这意味着Clang为*vmlinux.h*中定义的所有类型生成重定位信息。'
- en: 'You can see the relocations taking place when you load a BPF program, by using
    `bpftool` and turning on the debug information with the `-d` flag, like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`bpftool`加载BPF程序并使用`-d`标志打开调试信息时，您可以看到重定位正在进行：
- en: '[PRE51]cpp'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE51]cpp'
- en: 'This generates a lot of output, but the parts relating to relocation look like
    this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成大量输出，但与重定位相关的部分看起来像这样：
- en: '[PRE52]cpp'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE52]cpp'
- en: 'In this example you can see that type ID 24 from the `hello` program’s BTF
    information refers to the structure called `user_pt_regs`. The *libbpf* library
    has matched this against a kernel structure, also called `user_pt_regs`, that
    has type ID 205 in the *vmlinux* BTF data set. In practice, because I compiled
    and loaded the program on the same machine, the type definitions are identical,
    so in this example the offset of 0 from the start of the structure remains unchanged,
    and the “patch” to instruction #1 leaves it unchanged.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到`hello`程序的BTF信息中的类型ID 24指的是名为`user_pt_regs`的结构。*libbpf*库已将此与内核结构匹配，该结构也称为`user_pt_regs`，在*vmlinux*
    BTF数据集中的类型ID为205。实际上，因为我在同一台机器上编译和加载了程序，所以类型定义是相同的，因此在这个例子中，从结构开始的偏移量仍然保持不变，并且对指令#1的“修补”也保持不变。
- en: In many applications you won’t want to ask users to run `bpftool` to load an
    eBPF program. Instead, you’ll want to build this functionality into a dedicated
    user space program that you supply as an executable. Let’s consider how to write
    this user space code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，您不希望要求用户运行`bpftool`来加载eBPF程序。相反，您希望将此功能构建到一个专用的用户空间程序中，该程序作为可执行文件提供。让我们考虑如何编写这个用户空间代码。
- en: CO-RE User Space Code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CO-RE用户空间代码
- en: There are a few different frameworks in different programming languages that
    support CO-RE by implementing the relocations as they load eBPF programs into
    the kernel. In this chapter I’ll show C code that uses *libbpf*; other options
    include the Go packages *cilium/ebpf* and *libbpfgo*, and Aya for Rust. I’ll discuss
    those options further in [Chapter 10](ch10.html#ebpf_programming).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不同编程语言中有一些不同的框架支持CO-RE，它们通过在将eBPF程序加载到内核时实现重定位来支持CO-RE。在本章中，我将展示使用*libbpf*的C代码；其他选项包括Go包*cilium/ebpf*和*libbpfgo*，以及Rust的Aya。我将在[第10章](ch10.html#ebpf_programming)中进一步讨论这些选项。
- en: The Libbpf Library for User Space
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间的Libbpf库
- en: The *libbpf* library is a user space library you can use directly if you’re
    writing the user space part of your application in C. If you want to, you can
    use this library without using CO-RE. There’s an example of this in [Andrii Nakryiko’s
    excellent blog post on *libbpf-bootstrap*](https://oreil.ly/b3v7B).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*libbpf*库是一个用户空间库，如果你的应用程序的用户空间部分是用C编写的，你可以直接使用它。如果愿意，你可以在不使用CO-RE的情况下使用这个库。在[Andrii
    Nakryiko的*libbpf-bootstrap*博客文章](https://oreil.ly/b3v7B)中有一个例子。'
- en: This library provides functions that wrap the `bpf()` and related syscalls that
    you met in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi) to perform
    operations like loading programs into the kernel and attaching them to events,
    or accessing map information from user space. The conventional and easiest way
    to use these abstractions is through auto-generated BPF skeleton code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库提供了包装`bpf()`和相关系统调用的函数，你在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中遇到过，用于执行加载程序到内核并将其附加到事件，或者从用户空间访问映射信息。使用这些抽象的传统和最简单的方法是通过自动生成的BPF骨架代码。
- en: BPF Skeletons
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BPF骨架
- en: 'You can use `bpftool` to auto-generate this skeleton code from existing eBPF
    objects in ELF file format, like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`bpftool`从现有的以ELF文件格式存在的eBPF对象自动生成这个骨架代码，就像这样：
- en: '[PRE53]cpp'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE53]cpp'
- en: Look into this skeleton header and you’ll see that it contains structure definitions
    for the eBPF programs and maps, as well as several functions that all start with
    the name `hello_buffer_config_bpf__` (based on the name of the object file). These
    functions manage the lifecycle of the eBPF programs and maps. You don’t have to
    use the skeleton code—you can make calls to *libbpf* directly if you prefer—but
    the auto-generated code will typically save you some typing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个骨架头文件，你会发现它包含了eBPF程序和映射的结构定义，以及一些以`hello_buffer_config_bpf__`开头的函数（根据对象文件的名称）。这些函数管理eBPF程序和映射的生命周期。你不一定要使用骨架代码，如果愿意，你可以直接调用*libbpf*，但是自动生成的代码通常会节省一些输入。
- en: Toward the end of the generated skeleton file you’ll see a function called `hello_buffer_config_bpf__elf_bytes`
    that returns the byte contents of the ELF object file *hello-buffer-config.bpf.o*.
    Once the skeleton has been generated, we don’t really need that object file anymore.
    You can test this by running `make` to generate the `hello-buffer-config` executable
    and then deleting the *.o* file; the executable has the eBPF bytecode contained
    within it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的骨架文件的末尾，你会看到一个名为`hello_buffer_config_bpf__elf_bytes`的函数，它返回*hello-buffer-config.bpf.o*的ELF对象文件的字节内容。一旦骨架被生成，我们实际上不再需要那个对象文件。你可以通过运行`make`来生成`hello-buffer-config`可执行文件，然后删除*.o*文件来测试；可执行文件中包含了eBPF字节码。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer, you can use the *libbpf* function `bpf_object__open_file` to
    load the eBPF programs and maps from an ELF file rather than using the bytes from
    a skeleton file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，你可以使用*libbpf*函数`bpf_object__open_file`从ELF文件中加载eBPF程序和映射，而不是使用骨架文件中的字节。
- en: Here’s the outline of the user space code that manages the lifecycle of the
    eBPF program and maps for this example, using the generated skeleton code. I have
    omitted some of the details and error handling for clarity, but you’ll find the
    full source code in *chapter5/hello-buffer-config.c*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理本示例中eBPF程序和映射生命周期的用户空间代码的概要，使用了生成的骨架代码。为了清晰起见，我省略了一些细节和错误处理，但你可以在*chapter5/hello-buffer-config.c*中找到完整的源代码。
- en: '[PRE54]cpp'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]cpp'
- en: '[![1](assets/1.png)](#code_id_5_5)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_5_5)'
- en: This file includes the auto-generated skeleton header, as well as the header
    file I wrote manually for data structures shared between the user space and kernel
    code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包括了自动生成的骨架头文件，以及我手动编写的用于用户空间和内核代码之间共享的数据结构的头文件。
- en: '[![2](assets/2.png)](#code_id_5_6)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_5_6)'
- en: This code sets a callback function that will print any log messages generated
    by *libbpf*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个回调函数，用于打印*libbpf*生成的任何日志消息。
- en: '[![3](assets/3.png)](#code_id_5_7)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_5_7)'
- en: Here a `skel` structure is created that represents all the maps and programs
    defined in the ELF bytes and loads them into the kernel.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建了一个`skel`结构，代表了ELF字节中定义的所有映射和程序，并将它们加载到内核中。
- en: '[![4](assets/4.png)](#code_id_5_8)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_5_8)'
- en: Programs are auto-attached to the appropriate events.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会自动附加到适当的事件上。
- en: '[![5](assets/5.png)](#code_id_5_9)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_5_9)'
- en: This function creates a structure for handling the perf buffer output.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个用于处理perf缓冲区输出的结构。
- en: '[![6](assets/6.png)](#code_id_5_10)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_5_10)'
- en: Here that perf buffer is continuously polled.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里perf缓冲区被持续轮询。
- en: '[![7](assets/7.png)](#code_id_5_11)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#code_id_5_11)'
- en: This is the clean-up code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清理代码。
- en: Let’s dive into some of those steps in more detail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解其中的一些步骤。
- en: Loading programs and maps into the kernel
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将程序和映射加载到内核中
- en: 'The first call to an auto-generated function is this one:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用自动生成的函数是这个：
- en: '[PRE55]cpp'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE55]cpp'
- en: '`As its name suggests, this function covers two phases: opening and loading.
    The “open” phase involves reading the ELF data and converting its sections into
    structures that represent eBPF programs and maps. The “load” phase loads those
    maps and programs into the kernel, performing any CO-RE fixups as necessary.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`正如其名称所示，这个函数涵盖了两个阶段：打开和加载。 “打开”阶段涉及读取ELF数据并将其部分转换为代表eBPF程序和映射的结构。 “加载”阶段将这些映射和程序加载到内核中，并在必要时执行任何CO-RE修复。'
- en: 'These two phases can easily be handled separately, as the skeleton code provides
    separate `name__open()` and `name__load()` functions. This gives you the option
    to manipulate the eBPF information before loading it. This is commonly done to
    configure a program before loading it. For example, I could initialize a counter
    global variable `c` to some value, like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个阶段可以很容易地分开处理，因为骨架代码提供了单独的`name__open()`和`name__load()`函数。这样你就有选择在加载之前操作eBPF信息的选项。这通常用于在加载之前配置程序。例如，我可以将计数器全局变量`c`初始化为某个值，就像这样：
- en: '[PRE56]cpp'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE56]cpp'
- en: '[PRE57]cppThe data type returned by `hello_buffer_config_bpf__open()`, and
    also by `hello_buffer_config_bpf__load()`, is a structure called `hello_buffer_config_bpf`
    defined in the skeleton header to include information about all the maps, programs,
    and data defined in the object file.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE57]由`hello_buffer_config_bpf__open()`和`hello_buffer_config_bpf__load()`返回的数据类型是一个名为`hello_buffer_config_bpf`的结构，在骨架头文件中定义，包括有关对象文件中定义的所有映射、程序和数据的信息。'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The skeleton object (`hello_buffer_config_bpf` in this example) is just a user
    space representation of information from the ELF bytes. Once it has been loaded
    into the kernel, if you change a value in the object, it won’t have any effect
    on the kernel-side data. So, for example, changing `skel->data->c` after loading
    will not have any effect.[PRE58]`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，骨架对象（例如`hello_buffer_config_bpf`）只是来自ELF字节的用户空间表示。一旦它被加载到内核中，如果你在对象中更改一个值，它不会对内核端的数据产生任何影响。所以，例如，在加载后更改`skel->data->c`将不会产生任何影响。[PRE58]
- en: '[PRE59]To try this out you can create a map using `bpftool`, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE59]你可以使用`bpftool`创建一个映射，就像这样：'
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running the find-map executable will print out:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`find-map`可执行文件将打印出：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let’s get back to the *hello-buffer-config* example and the skeleton code.[PRE62]###
    Attaching to events
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`hello-buffer-config`示例和骨架代码。[PRE62]### 附着到事件
- en: 'The next skeleton function in the example attaches the program to the `execve`
    syscall function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的下一个骨架函数将程序附着到`execve`系统调用函数：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`The *libbpf* library automatically takes the attachment point from the `SEC()`
    definition for this program. If you didn’t define the attachment point fully,
    there are a whole series of *libbpf* functions, such as `bpf_program__attach_kprobe`,
    `bpf_program__attach_xdp`, and so on, for attaching different program types.`  `###
    Managing an event buffer'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`libbpf`库会自动从`SEC()`定义中获取程序的附着点。如果你没有完全定义附着点，那么有一系列`libbpf`函数，比如`bpf_program__attach_kprobe`，`bpf_program__attach_xdp`等，用于附着不同类型的程序。###
    管理事件缓冲区'
- en: 'Setting up the perf buffer uses a function defined in *libbpf* itself, rather
    than in the skeleton:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 设置性能缓冲区使用的是`libbpf`中定义的函数，而不是在骨架中定义的函数。
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '``You can see the `perf_buffer__new()` function takes the file descriptor for
    the “output” map as the first argument. The `handle_event` argument is a callback
    function that gets called when new data arrives in the perf buffer, and `lost_event`
    gets called if there isn’t enough room in the perf buffer for the kernel to write
    a data entry. In my example these functions just write messages to the screen.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`perf_buffer__new()`函数将“输出”映射的文件描述符作为第一个参数。`handle_event`参数是一个回调函数，当新数据到达性能缓冲区时会被调用，`lost_event`在性能缓冲区没有足够的空间让内核写入数据条目时会被调用。在我的示例中，这些函数只是将消息写入屏幕。
- en: 'Finally, the program has to poll the perf buffer repeatedly:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序必须重复轮询性能缓冲区：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]The 100 is a timeout in milliseconds. The callback functions previously
    set up will get called as appropriate when data arrives or when the buffer is
    full.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE66]100是毫秒级的超时时间。之前设置的回调函数在数据到达或缓冲区满时会被调用。'
- en: 'Finally, to clean up I free the perf buffer and destroy the eBPF programs and
    maps in the kernel, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了清理，我释放了性能缓冲区，并在内核中销毁了eBPF程序和映射，就像这样：
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '``There are a whole set of `perf_buffer_*`- and `ring_buffer_*`-related functions
    in *libbpf* to help you manage event buffers.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '``libbpf`中有一整套与`perf_buffer_*`和`ring_buffer_*`相关的函数，帮助你管理事件缓冲区。'
- en: 'If you make and run this example `hello-buffer-config` program, you’ll see
    the following output (that’s very similar to what you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi)):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你制作并运行这个`hello-buffer-config`示例程序，你会看到以下输出（与[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的非常相似）：
- en: '[PRE68][PRE69][PRE70]  [PRE71]  [PRE72][PRE73]```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE68][PRE69][PRE70]  [PRE71]  [PRE72][PRE73]'

["```cpp\nprocessed 61 insns (limit 1000000) max_states_per_insn 0 total_states 4\npeak_states 4 mark_read 3\n```", "```cpp\n0: (bf) r6 = r1\n; data.counter = c;                                              ![1](assets/1.png)\n1: (18) r1 = 0xffff800008178000\n3: (61) r2 = *(u32 *)(r1 +0)\n R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=ctx(id=0,off=0,imm=0) \n R10=fp0                                                         ![2](assets/2.png)\n; c++; \n4: (bf) r3 = r2\n5: (07) r3 += 1\n6: (63) *(u32 *)(r1 +0) = r3\n R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R2_w=inv(id=1,umax_value=4294967295,\n var_off=(0x0; 0xffffffff)) R3_w=inv(id=0,umin_value=1,umax_value=4294967296,\n var_off=(0x0; 0x1ffffffff)) R6_w=ctx(id=0,off=0,imm=0) R10=fp0  ![3](assets/3.png)\n```", "```cpp\nR2_w=inv(id=1,umax_value=4294967295,var_off=(0x0; 0xffffffff))\nR3_w=inv(id=0,umin_value=1,umax_value=4294967296,var_off=(0x0; 0x1ffffffff))\n```", "```cpp\n$ bpftool prog dump xlated name kprobe_exec visual > out.dot\n$ dot -Tpng out.dot > out.png\n```", "```cpp\n...\n16: (85) call bpf_get_current_pid_tgid#14\nunknown func bpf_get_current_pid_tgid#14\n```", "```cpp\nconststruct`bpf_func_proto``bpf_map_lookup_elem_proto`={.`func`=`bpf_map_lookup_elem`,.`gpl_only`=`false`,.`pkt_access`=`true`,.`ret_type`=`RET_PTR_TO_MAP_VALUE_OR_NULL`,.`arg1_type`=`ARG_CONST_MAP_PTR`,.`arg2_type`=`ARG_PTR_TO_MAP_KEY`,};\n```", "```cpp\np=bpf_map_lookup_elem(&data,&uid);\n```", "```cpp\n27: (85) call bpf_map_lookup_elem#1\nR1 type=fp expected=map_ptr\n```", "```cpp\n...\n37: (85) call bpf_probe_read_kernel#113\ncannot call GPL-restricted function from non-GPL compatible program\n```", "```cpp\nSEC(\"xdp\") `int``xdp_load_balancer``(``struct``xdp_md``*``ctx``)` ``{` ``void``*``data``=``(``void``*``)(``long``)``ctx``->``data``;` ``void``*``data_end``=``(``void``*``)(``long``)``ctx``->``data_end``;` ``...```", "```cpp\n\n ```", "```cpp\nSEC(\"xdp\") `int``xdp_hello``(``struct``xdp_md``*``ctx``)``{` ``void``*``data``=``(``void``*``)(``long``)``ctx``->``data``;` ``void``*``data_end``=``(``void``*``)(``long``)``ctx``->``data_end``;` ``bpf_printk``(``\"%x\"``,``data_end``);` ``return``XDP_PASS``;` ``}```", "```cpp\n```", "```cppThe variables `data` and `data_end` are very similar, but the verifier is smart enough to recognize that `data_end` relates to the end of a packet. Your program is required to check that any values read from the packet aren\u2019t from beyond that location, and it won\u2019t let you \u201ccheat\u201d by modifying the `data_end` value. Try adding the following line just before the `bpf_printk()` call:\n\n```", "```cpp\n\n `The verifier will complain, like this:\n\n```", "```cpp\n\nIn another example, when accessing an array you need to make sure there\u2019s no possibility of accessing an index that is beyond the bounds of that array. In the example code there is a section that reads a character out of the `message` array, like this:\n\n```", "```cpp\n```", "```cppThis is fine because of the explicit check to ensure that the counter variable `c` is no bigger than the size of the message array. Making a simple \u201coff by one\u201d error like the following renders it invalid:\n\n```", "```cpp\n```", "```cppThe verifier will fail this with an error message similar to this:\n\n```", "```cpp\n\nIt\u2019s fairly clear from this message that there is an invalid access to a map value because Register 2 might hold a value that\u2019s too large for indexing the map. If you were debugging this error, you\u2019d want to dig into the log to see what line in the source code was responsible. The log ends like this just before emitting the error message (I have removed some of the state information for clarity):\n\n```", "```cpp\n\n[![1](assets/1.png)](#code_id_6_6)\n\nWorking backward from the error, the last register state information shows that Register 2 could have a maximum value of `12`.\n\n[![2](assets/2.png)](#code_id_6_5)\n\nAt instruction 31, Register 2 is set to an address in memory and then is incremented by the value of Register 1\\. The output shows that this corresponds to the line of code accessing `message[c]`, so it stands to reason that Register 2 is set to point to the message array and then to be incremented by the value of `c`, which is held in the Register 1 register.\n\n[![3](assets/3.png)](#code_id_6_4)\n\nWorking further back to find the value of Register 1, the log shows that it has a maximum value of `12` (which is hex 0x0c). However, `message` is defined as a 12-byte character array, so only indexes 0 through 11 are within its bounds. From this, you can see that the error springs from the source code testing for `c <= sizeof(message)`.\n\nAt step 2, I have inferred the relationship between some registers and the source code variables they represent, from the lines of source code the verifier has helpfully included in the log. You could work back through the verifier log to check that this is true, and indeed you might have to if the code was compiled without debug information. Given the debug information is present, it makes sense to use it.\n\nThe `message` array is declared as a global variable, and you might recall from [Chapter\u00a03](ch03.html#anatomy_of_an_ebpf_program) that global variables are implemented using maps. This explains why the error message talks about \u201cinvalid access to a map value.\u201d```", "```cpp```", "````cpp  ```# Checking Pointers Before Dereferencing Them\n\nOne easy way to make a C program crash is to dereference a pointer when the pointer has a zero value (also known as *null*). Pointers indicate where in memory a value is being held, and zero is not a valid memory location. The eBPF verifier requires all pointers to be checked before they are dereferenced so that this type of crash can\u2019t happen.\n\nThe example code in *hello-verifier.bpf.c* looks for a custom message that might exist in the `my_config` hash table map for a user, with the following line:\n\n```cpp\np=bpf_map_lookup_elem(&my_config,&uid);\n```\n\n `If there\u2019s no entry in this map corresponding to `uid`, this will set `p` (which is a pointer to the message structure `msg_t`) to zero. Here\u2019s a little bit of additional code that attempts to dereference this potentially null pointer:\n\n```cpp\nchara=p->message[0]; `bpf_printk``(``\"%c\"``,``a``);`\n```\n\n ``This compiles fine, but the verifier rejects it as follows:\n\n```cpp\n; p = bpf_map_lookup_elem(&my_config, &uid); \n25: (18) r1 = 0xffff263ec2fe5000\n27: (85) call bpf_map_lookup_elem#1\n28: (bf) r7 = r0                                ![1](assets/1.png)\n; char a = p->message[0];\n29: (71) r3 = *(u8 *)(r7 +0)                    ![2](assets/2.png)\nR7 invalid mem access 'map_value_or_null'\n```\n\n[![1](assets/1.png)](#code_id_6_7)\n\nThe return value from a helper function call gets stored in Register 0\\. Here, that value is being stored in Register 7\\. This means Register 7 now holds the value of the local variable `p`.\n\n[![2](assets/2.png)](#code_id_6_8)\n\nThis instruction attempts to dereference the pointer value `p`. The verifier has been keeping track of the state of Register 7 and knows that it may hold a pointer to a map value, or it might be null.\n\nThe verifier rejects this attempt to dereference a null pointer, but the program will pass if there is an explicit check, like this:\n\n```cpp\nif(p!=0){ `char``a``=``p``->``message``[``0``];` ``bpf_printk``(``\"%d\"``,``cc``);` ``}```\n```cpp\n\n ```Some helper functions incorporate the pointer check for you. For example, if you look at the manpage for bpf-helpers, you\u2019ll find the function signature for `bpf_probe_read_kernel()` is as follows:\n\n```cpp\nlongbpf_probe_read_kernel(void**`dst`*,u32*`size`*,constvoid**`unsafe_ptr`*)\n```\n\nThe third argument to this function is called `unsafe_ptr`. This is an example of a BPF helper function that helps programmers write safe code by handling checks for you. You\u2019re allowed to pass a potentially null pointer\u2014but only as the third argument called `unsafe_ptr`\u2014and the helper function will check that it\u2019s not null before attempting to deference it.```cpp```  ``# Accessing Context\n\nEvery eBPF program is passed some context information as an argument, but depending on the program and attachment type, it may be allowed to access only some of that context information. For example, [tracepoint programs](https://oreil.ly/6RFFI) receive a pointer to some tracepoint data. The format of that data depends on the particular tracepoint, but they all start with some common fields\u2014yet those common fields are not accessible to eBPF programs. Only the tracepoint-specific fields that follow can be accessed. Attempting to read or write the wrong fields leads to an `invalid bpf_context access` error. There is an example of this in the exercises at the end of this chapter.\n\n# Running to Completion\n\nThe verifier ensures that the eBPF program will run to completion; otherwise, there is a risk that it might consume resources indefinitely. It does this by having a limit on the total number of instructions that it will process, which, as I mentioned earlier, is set at one million instructions at the time of this writing. That limit is [hard-coded into the kernel](https://oreil.ly/IucYm); it\u2019s not a configurable option. If the verifier hasn\u2019t reached the end of the BPF program before it has processed this many instructions, it rejects the program.\n\nOne easy way to create a program that never completes is to write a loop that never ends. Let\u2019s see how loops can be created in eBPF programs.\n\n# Loops\n\nTo guarantee completion, until kernel version 5.3 there was a restriction on loops.^([3](ch06.html#ch06fn3)) Looping through the same instructions requires a jump backward to earlier instructions, and it used to be the case that the verifier would not permit this. eBPF programmers worked around this by using the `#pragma unroll` compiler directive to tell the compiler to write out a set of identical (or very similar) bytecode instructions for each time around the loop. This saved the programmer typing in the same lines many times, but you would see repeated instructions in the emitted bytecode.\n\nFrom version 5.3 onward the verifier follows branches backward as well as forward as part of its process of checking all the possible execution paths. This means it can accept some loops, provided the execution path remains within the limit of one million instructions.\n\nYou can see an example of a loop in the example *xdp_hello* program. A version of the loop that passes verification looks like this:\n\n```\nfor(inti=0;i<10;i++){ `bpf_printk``(``\"Looping %d\"``,``i``);` ``}``\n```cpp\n\n ```The (successful) verifier log will show that it has followed the execution path around this loop 10 times. In doing so, it doesn\u2019t hit the complexity limit of one million instructions. In the exercises for this chapter, there\u2019s another version of this loop that will hit that limit and will fail verification.\n\nIn version 5.17 a new helper function, `bpf_loop()`, was introduced that makes it much easier for the verifier not only to accept loops but also to do it in a much more efficient way. This helper takes the maximum number of iterations as its first argument, and it is also passed a function that is called for each iteration. The verifier only has to validate the BPF instructions in that function once, however many times it might be called. That function can return a nonzero value to indicate that there is no need to call it again, which is used to terminate a loop early once the desired result is achieved.\n\nThere\u2019s also a helper function [`bpf_for_each_map_elem()`](https://oreil.ly/Yg_oQ) that calls a provided callback function for each item in a map.```cpp  ```# Checking the Return Code\n\nThe return code from an eBPF program is stored in Register 0 (`R0`). If the program leaves `R0` uninitialized, the verifier will fail, like this:\n\n```cpp\nR0 !read_ok\n```\n\nYou can try this by commenting out all the code in a function; for example, modify the `xdp_hello` example to be like this:\n\n```cpp\nSEC(\"xdp\") `int``xdp_hello``(``struct``xdp_md``*``ctx``)``{` ``void``*``data``=``(``void``*``)(``long``)``ctx``->``data``;` ``void``*``data_end``=``(``void``*``)(``long``)``ctx``->``data_end``;` ``// bpf_printk(\"%x\", data_end);`\n`// return XDP_PASS;`\n`}````", "```cpp\n\n ```", "```cpp  ```", "```cpp\n    if(c<sizeof(data.message)){ `char``a``=``data``.``message``[``c``];` ``bpf_printk``(``\"%c\"``,``a``);` ``}```", "```cpp\n\n     ```", "```cpp \n```", "```cpp\n    for(inti=0;i<10;i++){ `bpf_printk``(``\"Looping %d\"``,``i``);` ``}``\n    ```", "```cppYou should see in the verifier log a repeated series of lines that look something like this:\n\n    ```", "```cpp\n\n    From the log, work out which register is tracking the loop variable `i`.```", "```cpp*   Now try adding in a loop that will fail, which looks like this:\n\n    ```", "```cpp\n\n     ```", "```cpp ```", "```cpp\n    unsignedshortcommon_type; `unsigned``char``common_flags``;` ``unsigned``char``common_preempt_count``;` ``int``common_pid``;```", "```cpp\n\n     ```", "```cpp```", "````cpp`` \n\n ```^([1](ch06.html#ch06fn1-marker)) For a long time the limit was 4,096 instructions, which imposed significant restrictions on the complexity of eBPF programs. This limit still applies to unprivileged users running BPF programs.\n\n^([2](ch06.html#ch06fn2-marker)) Helper functions are also defined in some other places in the source code, for example, [*kernel/trace/bpf_trace.c*](https://oreil.ly/cY8y9) and [*net/core/filter.c*](https://oreil.ly/qww-b).\n\n^([3](ch06.html#ch06fn3-marker)) This release brought a number of significant optimizations and improvements to the BPF verifier, which are summarized nicely in the LWN article [\u201cBounded loops in BPF for the 5.3 kernel\u201d](https://oreil.ly/50BoD).```cpp````", "```cpp```"]
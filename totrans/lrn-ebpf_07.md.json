["```cpp\n$ sudo bpftool perf show\npid 232272  fd 16: prog_id 392  kprobe  func __x64_sys_execve  offset 0\npid 232272  fd 17: prog_id 394  kprobe  func do_execve  offset 0\npid 232272  fd 19: prog_id 396  tracepoint  sys_enter_execve\npid 232272  fd 20: prog_id 397  raw_tracepoint  sched_process_exec\npid 232272  fd 21: prog_id 398  raw_tracepoint  sched_process_exec\n```", "```cpp\nSEC(\"ksyscall/execve\") `int``BPF_KPROBE_SYSCALL``(``kprobe_sys_execve``,``char``*``pathname``)`\n```", "```cpp\nSEC(\"kprobe/do_execve\") `int``BPF_KPROBE``(``kprobe_do_execve``,``struct``filename``*``filename``)`\n```", "```cpp\nint`do_execve`(struct`filename`*`filename`,constchar`__user`*const`__user`*__argv,constchar`__user`*const`__user`*__envp)\n```", "```cpp\nconstchar*name=BPF_CORE_READ(filename,name); `bpf_probe_read_kernel``(``&``data``.``command``,``sizeof``(``data``.``command``),``name``);`\n```", "```cpp```", "```## Fentry/Fexit\n\nA more efficient mechanism for tracing the entry to and exit from kernel functions was introduced along with the idea of *BPF trampoline* in kernel version 5.5 (on x86 processors; BPF trampoline support doesn\u2019t arrive for [ARM processors until Linux 6.0](https://oreil.ly/ccuz1)). If you\u2019re using a recent enough kernel, fentry/fexit is now the preferred method for tracing the entry to or exit from a kernel function. You can write the same code inside a kprobe or fentry type program.\n\nThere\u2019s an example fentry program called `fentry_execve()` in *chapter7/hello.bpf.c*. I declared the eBPF program for this kprobe using *libbpf*\u2019s macro `BPF_PROG`, which is another convenient wrapper giving access to typed parameters rather than the generic context pointer, but this version is used for fentry, fexit, and tracepoint program types. The definition looks like this:\n\n```", "```\n\n ``The section name tells *libbpf* to attach to the fentry hook at the start of the `d\u2060o\u2060_\u200be\u2060x\u2060e\u2060c\u2060v\u2060e\u2060(\u2060)` kernel function. Just as in the kprobe example, the context parameters reflect the parameters passed to the kernel function where you want to attach this eBPF program.\n\nFentry and fexit attachment points were designed to be more efficient than kprobes, but there\u2019s another advantage when you want to generate an event at the end of a function: the fexit hook has access to the input parameters to the function, which kretprobe does not. You can see an example of this in [*libbpf-bootstrap*\u2019s examples](https://oreil.ly/6HDh_). Both *kprobe.bpf.c* and *fentry.bpf.c* are equivalent examples that hook into the `do_unlinkat()` kernel function. The eBPF program attached to the kretprobe has the following signature:\n\n```", "```\n\n ``The `BPF_KRETPROBE` macro expands to make this a kretprobe program on exit from `do_unlinkat()`. The only parameter the eBPF program receives is `ret`, which holds the return value from `do_unlinkat()`. Compare this to the fexit version:\n\n```", "```\n\n ``In this version the program gets access not just to the return value `ret`, but also to the input parameters to `do_unlinkat()`, which are `dfd` and `name`.```", "```  ```", "```cpp\n$ cat /sys/kernel/tracing/available_events \ntls:tls_device_offload_set\ntls:tls_device_decrypted\n...\nsyscalls:sys_exit_execveat\nsyscalls:sys_enter_execveat\nsyscalls:sys_exit_execve\nsyscalls:sys_enter_execve\n...\n```", "```cpp\nSEC(\"tp/syscalls/sys_enter_execve\")\n```", "```cpp\n$ cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format\nname: sys_enter_execve\nID: 622\nformat:\n  field:unsigned short common_type;         offset:0;  size:2; signed:0;\n  field:unsigned char common_flags;         offset:2;  size:1; signed:0;\n  field:unsigned char common_preempt_count; offset:3;  size:1; signed:0;\n  field:int common_pid;                     offset:4;  size:4; signed:1;\n\n  field:int __syscall_nr;                   offset:8;  size:4; signed:1;\n  field:const char * filename;              offset:16; size:8; signed:0;\n  field:const char *const * argv;           offset:24; size:8; signed:0;\n  field:const char *const * envp;           offset:32; size:8; signed:0;\n\nprint fmt: \"filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx\", \n((unsigned long)(REC->filename)), ((unsigned long)(REC->argv)), \n((unsigned long)(REC->envp))\n```", "```cpp\nstructmy_syscalls_enter_execve{ `unsigned``short``common_type``;` ``unsigned``char``common_flags``;` ``unsigned``char``common_preempt_count``;` ``int``common_pid``;` ``long``syscall_nr``;` ``long``filename_ptr``;` ``long``argv_ptr``;` ``long``envp_ptr``;` ``};```", "```cpp```", "```\n\n ```", "```\ninttp_sys_enter_execve(structmy_syscalls_enter_execve*ctx){\n```", "```\nbpf_probe_read_user_str(&data.command,sizeof(data.command),ctx->filename_ptr);\n```", "``````cpp  ```## BTF-Enabled Tracepoints\n\nIn the previous example I wrote a structure called `my_syscalls_enter_execve` to define the context parameter for my eBPF program. But when you define a structure in your eBPF code or parse the raw arguments, there\u2019s a risk that your code might not match the kernel it\u2019s running on. The good news is that BTF, which you met in [Chapter\u00a05](ch05.html#co_recomma_btfcomma_and_libbpf), also solves this problem.\n\nWith BTF support, there will be a structure defined in *vmlinux.h* that matches the context structure passed to a tracepoint eBPF program. Your eBPF program should use the section definition `SEC(\"tp_btf/*tracepoint name*\")` where the tracepoint name is one of the available events listed in */sys/kernel/tracing/available_events*. The example program in *chapter7/hello.bpf.c* looks like this:\n\n```cpp\nSEC(\"tp_btf/sched_process_exec\") `int``handle_exec``(``struct``trace_event_raw_sched_process_exec``*``ctx``)`\n```\n\n ``As you can see, the structure name matches the tracepoint name, prefixed with `trace_event_raw_`.``  ``## User Space Attachments\n\nSo far I have shown examples of eBPF programs attaching to events defined within the kernel\u2019s source code. There are similar attachment points within user space code: uprobes and uretprobes for attaching to the entry and exit of user space functions, and user statically defined tracepoints (USDTs) for attaching to specified tracepoints within application code or user space libraries. These all use the `BPF_PROG_TYPE_KPROBE` program type.\n\n###### Note\n\nThere are lots of public examples of programs attached to user space events. Here are a few from the BCC project:\n\n*   The [bashreadline](https://oreil.ly/gDkaQ) and [funclatency tools](https://oreil.ly/zLT54) attach to u(ret)probe.\n\n*   [USDT sample](https://oreil.ly/o894f) in BCC.\n\nIf you\u2019re using *libbpf*, the `SEC()` macro lets you define the auto-attachment point for these user space probes. You\u2019ll find the format required for the section name in the [*libbpf* documentation](https://oreil.ly/o0CBQ). For example, to attach a uprobe to the start of the `SSL_write()` function in OpenSSL, you would define the section for the eBPF program with the following:\n\n```cpp\nSEC(\"uprobe/usr/lib/aarch64-linux-gnu/libssl.so.3/SSL_write\")\n```\n\n `There are a few gotchas to be aware of when instrumenting user space code:\n\n*   Notice that the path to this shared library in this example is architecture specific, so you may need corresponding architecture-specific definitions.\n\n*   Unless you control the machine you\u2019re running the code on, you can\u2019t know what user space libraries and applications will be installed.\n\n*   An application might be built as a standalone binary, so it won\u2019t hit any probes you might attach within shared libraries.\n\n*   Containers typically run with their own copy of a filesystem, with their own set of dependencies installed in it. The path to a shared library used by a container won\u2019t be the same as the path to a shared library on the host machine.\n\n*   Your eBPF program might need to be aware of the language in which an application was written. For example, in C the arguments to a function are generally passed using registers, but in Go they are passed using the stack,^([3](ch07.html#ch07fn3)) so the `pt_args` structure holding register information may be of less use.\n\nThat said, there are lots of useful tools that instrument user space applications with eBPF. For example, you can hook into the SSL library to trace out decrypted versions of encrypted information\u2014we\u2019ll explore this in more detail in the next chapter. Another example is continuous profiling of your applications, using tools such as [Parca](https://www.parca.dev).`  `## LSM\n\n`BPF_PROG_TYPE_LSM` programs are attached to the *Linux Security Module (LSM) API*, which is a stable interface within the kernel originally intended for kernel modules to use to enforce security policies. As you\u2019ll see in [Chapter\u00a09](ch09.html#ebpf_for_security), where I\u2019ll discuss this in more detail, eBPF security tooling can now use this interface too.\n\n`BPF_PROG_TYPE_LSM` programs are attached using `bpf(BPF_RAW_TRACEPOINT_OPEN)`, and in many ways they are treated like tracing programs. One interesting characteristic of `BPF_PROG_TYPE_LSM` programs is that the return value affects the way the kernel behaves. A nonzero return code indicates that the security check wasn\u2019t passed, so the kernel won\u2019t proceed with whatever operation it was asked to complete. This is a significant difference from perf-related program types where the return code is ignored.\n\n###### Note\n\nThe Linux kernel documentation covers [LSM BPF programs](https://oreil.ly/vcPHY).\n\nThe LSM program type isn\u2019t the only one with a role to play in security. Many of the networking-related program types that you\u2019ll see in the next section can be used for network security to permit or deny networking traffic or networking-related operations. You\u2019ll also see more about eBPF being used for security purposes in [Chapter\u00a09](ch09.html#ebpf_for_security).\n\nSo far in this chapter you have seen how a set of kernel and user space tracing program types enable visibility over the whole system. The next set of eBPF program types to consider are those that let us hook into the network stack, with the option not merely to observe but also to affect how it handles data being sent and received.```cpp``````", "```# Networking\n\nThere are lots of different eBPF program types intended to process network messages as they pass through various points in the network stack. [Figure\u00a07-1](#bpf_program_types_hook_into_various_poi) shows where some of the commonly used program types attach. These program types all require `CAP_NET_ADMIN` and `CAP_BPF`, or `CAP_SYS_ADMIN`, capabilities to be permitted.\n\nThe context passed to these types of programs is the network message in question, although the type of structure depends on the data the kernel has at the relevant point in the network stack. At the bottom of the stack, data is held in the form of Layer 2 network packets, which are essentially a series of bytes that have been or are ready to be transmitted \u201con the wire.\u201d At the top of the stack, applications use sockets, and the kernel creates socket buffers to handle data being sent and received from these sockets.\n\n![BPF program types hook into various points in the network stack](assets/lebp_0701.png)\n\n###### Figure 7-1\\. BPF program types hook into various points in the network stack\n\n###### Note\n\nThe network layer model is beyond the scope of this book, but it\u2019s covered in many other books, posts, and training courses. I discussed it in [Chapter\u00a010](ch10.html#ebpf_programming) of [*Container Security*](https://www.oreilly.com/library/view/container-security/9781492056690/) (O\u2019Reilly). For the purposes of this book, it\u2019s sufficient to know that Layer 7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC; TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2\\. One of the roles of the networking stack is to convert messages between these different formats.\n\nOne big difference between the networking program types and the tracing-related types you saw earlier in this chapter is that they are generally intended to allow for the customization of networking behaviors. That involves two main characteristics:\n\n1.  Using a return code from the eBPF program to tell the kernel what to do with a network packet\u2014which could involve processing it as usual, dropping it, or redirecting it to a different destination\n\n2.  Allowing the eBPF program to modify network packets, socket configuration parameters, and so on\n\nYou\u2019ll see some examples of how these characteristics are used to build powerful networking capabilities in the next chapter, but for now, here\u2019s an overview of the eBPF program types.\n\n## Sockets\n\nAt the top of the stack, a subset of these network-related program types relates to sockets and socket operations:\n\n*   `BPF_PROG_TYPE_SOCKET_FILTER` was the first program type to be added to the kernel. You probably guessed from the name that this is used for socket filtering, but what\u2019s less obvious is that this doesn\u2019t mean filtering data being sent to or from an application. It\u2019s used to filter a *copy* of socket data that can be sent to an observability tool such as tcpdump.\n\n*   A socket is specific to a Layer 4 (TCP) connection. `BPF_PROG_TYPE_SOCK_OPS` allows eBPF programs to intercept various operations and actions that take place on a socket, and to set for that socket parameters such as TCP timeout values. Sockets only exist at the endpoints for a connection, and not on any middleboxes that they might pass through.\n\n*   `BPF_PROG_TYPE_SK_SKB` programs are used in conjunction with a special map type that holds a set of references to sockets to provide what\u2019s known as [*sockmap* operations](https://oreil.ly/0Enuo): redirecting traffic to different destinations at the socket layer.\n\n## Traffic Control\n\nFurther down the network stack comes \u201cTC\u201d or traffic control. There is a whole subsystem in the Linux kernel related to TC, and a glance at the [manpage for the `tc` command](https://oreil.ly/kfyg5) will give you an idea of how complex it is and how important it is to computing in general to have deep levels of flexibility and configuration over the way network packets are handled.\n\neBPF programs can be attached to provide custom filters and classifiers for network packets for both ingress and egress traffic. This is one of the building blocks of the Cilium project, and I\u2019ll cover some examples in the next chapter. If you can\u2019t wait until then, there are some good examples on [Quentin Monnet\u2019s blog](https://oreil.ly/heQ2D). This can be done programmatically, but you also have the option to use the `tc` command to manipulate these kinds of eBPF programs.\n\n## XDP\n\nYou briefly met XDP (eXpress Data Path) eBPF programs in [Chapter\u00a03](ch03.html#anatomy_of_an_ebpf_program). In that example I loaded the eBPF program and attached it to the `eth0` interface using the following commands:\n\n```", "```\n\nIt\u2019s worth noting that XDP programs attach to a specific interface (or virtual interface), and you may very well have different XDP programs attached to different interfaces. In [Chapter\u00a08](ch08.html#ebpf_for_networking) you\u2019ll learn more about how XDP programs can be offloaded to network cards or executed by network drivers.\n\nXDP programs are another example of programs that can be managed using Linux network utilities\u2014in this case, the `link` subcommand of [iproute2\u2019s ip](https://oreil.ly/8Isau). The roughly equivalent command for loading and attaching the program to `eth0` would be this:\n\n```", "```\n\nThis command reads the eBPF program marked as section `xdp` from the `hello.bpf.o` object and attaches it to the `eth0` network interface. The `ip link show` command for this interface now includes some information about the XDP program that\u2019s attached to it:\n\n```", "```\n\nRemoving the XDP program with `ip link` can be done like this:\n\n```", "```\n\nYou\u2019ll see a lot more about XDP programs and their applications in the next chapter.\n\n## Flow Dissector\n\nA flow dissector is used at various points in the network stack to extract details from a packet\u2019s headers. eBPF programs of type `BPF_PROG_TYPE_FLOW_DISSECTOR` can implement custom packet dissection. There\u2019s a nice write-up in this LWN article on [writing network flow dissectors in BPF](https://oreil.ly/nFKLV).\n\n## Lightweight Tunnels\n\nThe family of `BPF_PROG_TYPE_LWT_*` program types can be used to implement network encapsulation in eBPF programs. These program types can also be manipulated using the `ip` command, but this time it\u2019s the `route` subcommand that\u2019s involved. In practice, these are used infrequently.\n\n## Cgroups\n\neBPF programs can be attached to cgroups (short for \u201ccontrol groups\u201d). *Cgroups* are a concept in the Linux kernel that restricts the set of resources a given process or group of processes can have access to. Cgroups are one of the mechanisms that isolate one container (or one Kubernetes pod) from another. Attaching eBPF programs to a cgroup allows for custom behavior that only applies to that cgroup\u2019s processes. All processes are associated with a cgroup, including processes that are not running inside a container.\n\nThere are several cgroup-related program types, and even more hooks where they can be attached. At least at the time of this writing, they are nearly all networking related, although there is also a `BPF_CGROUP_SYSCTL` program type that can be attached to sysctl commands affecting a particular cgroup.\n\nAs an example, there are socket-related program types specific to cgroups `BPF_PROG_TYPE_CGROUP_SOCK` and `BPF_PROG_TYPE_CGROUP_SKB`. eBPF programs can determine whether a given cgroup is permitted to perform a requested socket operation or data transmission. This is useful for network security policy enforcement (which I\u2019ll cover in the next chapter). Socket programs can also trick the calling process into thinking they are connecting to a particular destination address.\n\n## Infrared Controllers\n\nPrograms of type [BPF_PROG_TYPE_LIRC_MODE2](https://oreil.ly/AwG1C) can be attached to the file descriptor for an infrared controller device to provide decoding for infrared protocols. At the time of this writing, this program type requires `CAP_NET_ADMIN`, but I think this illustrates that the division of program types into tracing related and networking related doesn\u2019t fully express the range of different applications that eBPF can address.\n\n# BPF Attachment Types\n\nThe attachment type offers more fine-grained control over where a program can be attached in the system. For some program types there is a one-to-one correlation to the type of hook that it can be attached to, so the attachment type is implicitly defined by the program type. For example, XDP programs are attached to XDP hooks in the network stack. For a few program types, an attachment type also has to be specified.\n\nThe attachment type is involved in deciding which helper functions are valid, and it also restricts access to parts of the context information in some cases. There was an example of this earlier in this chapter where the verifier gives an `invalid bpf_context access` error.\n\nYou can also see which program types need an attachment type to be specified, and which attachment types are valid, in the kernel function [bpf_prog_load_check_attach](https://oreil.ly/0LqCQ) (defined in [*bpf/syscall.c*](https://oreil.ly/7OrYS)).\n\nFor example, here is the code that checks the attachment type for a program of type `CGROUP_SOCK`:\n\n```", "```\n\nThis program type can be attached in multiple places: at socket creation, at socket release, or after a bind is completed in IPv4 or IPv6.\n\nAnother place to find a listing of the valid attachment types for programs is the [*libbpf* documentation](https://oreil.ly/jraLh), where you\u2019ll also find the section names that *libbpf* understands for each program and attachment type.\n\n# Summary\n\nIn this chapter you saw that various eBPF program types are used to attach into different hook points in the kernel. If you want to write code that responds to a particular event, you\u2019ll need to determine the program type(s) that are appropriate for hooking onto that event. The context passed into the program depends on the program type, and the kernel may also respond differently to the return code from your program, depending on its type.\n\nThe example code for this chapter mostly focused on perf-related (tracing) events. In the next two chapters you\u2019ll see more details on different eBPF program types used for networking and security applications.\n\n# Exercises\n\nThe example code for this chapter includes kprobe, fentry, tracepoint, raw tracepoint, and BTF-enabled tracepoint programs that are all attached to the entry to the same system call. As you know, eBPF tracing programs can be attached to many other places besides syscalls.\n\n1.  Run the example code using `strace` to capture the `bpf()` system calls, like this:\n\n    ```", "```\n\n    This will record information about each `bpf()` syscall into a file called *outfile*. Look for the `BPF_PROG_LOAD` instructions in that file, and see how the `prog_type` file varies for different programs. You can identify which program is which by the `prog_name` field in the trace, and match them to the source code in *chapter7/hello.bpf.c*.\n\n2.  The example user space code in *hello.c* loads all the program objects defined in `hello.bpf.o`. As an exercise in writing *libbpf* user space code, modify the example code load and attach just one of the eBPF programs (pick whichever one you like), without removing those programs from *hello.bpf.c*.\n\n3.  Write a kprobe and/or fentry program that is triggered when some other kernel function is called. You can find the available functions in your kernel version by looking at */proc/kallsyms*.\n\n4.  Write a regular, raw or BTF-enabled tracepoint program that attaches to some other kernel tracepoint. You can find the available tracepoints in `/sys/kernel/tracing/available_events`.\n\n5.  Try to attach more than one XDP program to a given interface, and confirm that you can\u2019t! You should see an error that looks something like this:\n\n    ```", "```\n\n^([1](ch07.html#ch07fn1-marker)) Except for a few parts of the kernel where kprobes aren\u2019t permitted for security reasons. These are listed in `/sys/kernel/debug/kprobes/blacklist`.\n\n^([2](ch07.html#ch07fn2-marker)) The only example I have seen so far is in the [cilium/ebpf test suite](https://oreil.ly/rL5E8).\n\n^([3](ch07.html#ch07fn3-marker)) Up to Go version 1.17, when a new register-based calling convention was introduced. Nevertheless, I think there will be Go executables built with older versions circulating for some time to come.```"]
- en: Chapter 7\. eBPF Program and Attachment Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。eBPF程序和附加类型
- en: In the preceding chapters you saw lots of examples of eBPF programs, and you
    probably spotted the fact that they are attached to different types of events.
    Some of the examples I’ve shown attach to kprobes, but in other examples I’ve
    demonstrated XDP programs that handle a newly arrived network packet. These are
    just two of the many attachment points within the kernel. In this chapter we’ll
    take a deeper look at different program types and how they can be attached to
    different events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了许多eBPF程序的示例，你可能已经注意到它们附加到不同类型的事件上。我展示的一些示例附加到kprobes，但在其他示例中，我演示了处理新到达的网络数据包的XDP程序。这只是内核中许多附加点中的两个。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can build and run the examples from this chapter using the code and instructions
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter7* directory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf)上的代码和说明构建和运行本章的示例。本章的代码位于*chapter7*目录中。
- en: At the time of this writing, some of the examples are not supported on ARM processors.
    Check out the *README* file in the *chapter7* directory for more details and advice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，一些示例在ARM处理器上不受支持。查看*chapter7*目录中的*README*文件以获取更多详细信息和建议。
- en: There are currently around 30 program types enumerated in [*uapi/linux/bpf.h*](https://oreil.ly/6dNIW),
    and more than 40 attachment types. The attachment type defines more specifically
    where the program gets attached; for lots of program types, the attachment type
    can be inferred from the program type, but some program types can be attached
    to multiple different points in the kernel, so an attachment type has to be specified
    as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[*uapi/linux/bpf.h*](https://oreil.ly/6dNIW)目前列举了大约30种程序类型和40多种附加类型。附加类型更具体地定义了程序的附加位置；对于许多程序类型，附加类型可以从程序类型中推断出来，但是一些程序类型可以附加到内核中的多个不同点，因此还必须指定附加类型。'
- en: As you know, this book isn’t intended to be a reference manual, so I won’t cover
    every single eBPF program type. There’s a good chance that new types will have
    been added by the time you read this book anyway!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，这本书并不是参考手册，所以我不会涵盖每一种eBPF程序类型。在你阅读本书时，很可能已经添加了新的类型！
- en: Program Context Arguments
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序上下文参数
- en: All eBPF programs take a context argument that is a pointer, but the structure
    it points to depends on the type of event that triggered it. eBPF programmers
    need to write programs that accept the appropriate type of context; there is no
    point in pretending that the context argument points to a network packet if the
    event is, say, a tracepoint. Defining different types of programs allows the verifier
    to ensure that the contextual information is handled appropriately and to enforce
    rules about what helper functions are permissible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有eBPF程序都接受一个上下文参数，这是一个指针，但它指向的结构取决于触发它的事件类型。eBPF程序员需要编写接受适当类型上下文的程序；如果事件是tracepoint，那么假装上下文参数指向网络数据包是没有意义的。定义不同类型的程序允许验证器确保上下文信息得到适当处理，并强制执行有关允许的辅助函数的规则。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To dive into the details of the context data passed to different BPF program
    types, check out [this post by Alan Maguire on Oracle’s blog](https://oreil.ly/6dNIW).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解传递给不同BPF程序类型的上下文数据的详细信息，请查看[Alan Maguire在Oracle博客上的这篇文章](https://oreil.ly/6dNIW)。
- en: Helper Functions and Return Codes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助函数和返回代码
- en: As you saw in the previous chapter, the verifier checks that all helper functions
    used by a program are compatible with its program type. The example in the previous
    chapter demonstrated that the `bpf_get_current_pid_tgid()` helper function isn’t
    permitted in an XDP program. There is no user space process or thread involved
    at the point where a packet is received and the XDP hook is triggered, so a call
    to discover the current process and thread ID doesn’t make sense in that context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，验证器会检查程序使用的所有辅助函数是否与其程序类型兼容。上一章的示例表明，`bpf_get_current_pid_tgid()`辅助函数在XDP程序中是不允许的。在接收数据包并触发XDP钩子的地方，没有涉及用户空间进程或线程，因此在这种情况下调用发现当前进程和线程ID是没有意义的。
- en: The program type also determines the meaning of the return code from the program.
    Again using XDP as an example, the return code value tells the kernel what to
    do with the packet once the eBPF program has finished processing it—which could
    involve passing it to the network stack, dropping it, or redirecting it to a different
    interface. These return codes wouldn’t make any sense when an eBPF program is
    triggered by, say, hitting a particular tracepoint, where there is no network
    packet involved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序类型还确定了程序的返回代码的含义。再次以XDP为例，返回代码值告诉内核在eBPF程序完成处理后该如何处理数据包——可能涉及将其传递到网络堆栈，丢弃它，或将其重定向到不同的接口。当eBPF程序由于命中特定的tracepoint而触发时，这些返回代码就没有任何意义，因为这时没有涉及网络数据包。
- en: There is a [manpage for helper functions](https://oreil.ly/e8K73) (with, quite
    reasonably, disclaimers that it might not be complete due to the ongoing development
    of the BPF subsystem).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[辅助函数的manpage](https://oreil.ly/e8K73)（合理地指出，由于BPF子系统的持续开发，它可能不完整）。
- en: You can get a list of which helper functions are available for each program
    type in your version of the kernel with the `bpftool feature` command. This shows
    the system configuration and lists all the available program types and map types,
    and even lists all the helper functions that are supported for each program type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`bpftool feature`命令获取你的内核版本中每种程序类型可用的辅助函数列表。这显示了系统配置，并列出了所有可用的程序类型和映射类型，甚至列出了每种程序类型支持的所有辅助函数。
- en: Helper functions are considered part of the *UAPI*, the Linux kernel’s external,
    stable interface. As such, once a helper function has been defined in the kernel,
    it shouldn’t change in the future, even though the kernel’s internal functions
    and data structures can change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Despite the risk of changes between kernel versions, there was demand from eBPF
    programmers to be able to access some internal functions from eBPF programs. This
    can be achieved using the mechanism called *BPF kernel functions*, or [*kfuncs*](https://oreil.ly/gKSEx)*.*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Kfuncs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kfuncs allow internal kernel functions to be registered with the BPF subsystem
    so that the verifier will allow them to be called from eBPF programs. There is
    a registration for each eBPF program type that is permitted to call a given kfunc.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Unlike helper functions, kfuncs don’t provide compatibility guarantees, so an
    eBPF programmer has to consider the possibility of changes between kernel versions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of [“core” BPF kfuncs](https://oreil.ly/06qoi), which at the
    time of this writing consists of functions that allow eBPF programs to obtain
    and release kernel references to tasks and cgroups.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the type of an eBPF program determines what events it can be attached
    to, which in turn defines the type of context information it receives. The program
    type also defines the set of helper functions and kfuncs it can call.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Program types are broadly considered to fall into two categories: tracing (or
    perf) program types and networking-related program types. Let’s look at some examples.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs that attach to kprobes, tracepoints, raw tracepoints, fentry/fexit
    probes, and perf events were all designed to provide an efficient way for eBPF
    programs in the kernel to report tracing information about events into user space.
    These tracing-related types weren’t expected to influence the way the kernel behaves
    in response to the events they are attached to (although, as you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    there have been some innovations in this area!).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'These are sometimes referred to as “perf-related” programs. For example, the
    `bpftool perf` subcommand lets you view programs attached to perf-related events
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding output is what I see when running example code from the *hello.bpf.c*
    file in the *chapter7* directory, which attaches different programs to a variety
    of events that are all related to `execve()`. I’ll discuss all of these types
    in this section, but as an overview, these programs are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: A kprobe attached to the entry point to the `execve()` system call.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kprobe attached to a kernel function, `do_execve()`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tracepoint placed at the entry to the `execve()` syscall.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two versions of a raw tracepoint called during the processing of `execve()`.
    One of these, as you’ll see in this section, is a BTF-enabled version.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need `CAP_PERFMON` and `CAP_BPF` or `CAP_SYS_ADMIN` capabilities to use
    any of the tracing-related eBPF program types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and Kretprobes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I discussed the concept of kprobes in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque).
    You can attach kprobe programs almost anywhere in the kernel.^([1](ch07.html#ch07fn1))
    Commonly, they are attached using kprobes to the entry to a function and kretprobes
    to the exit of a function, but you can use kprobes to attach to an instruction
    that is some specified offset after the entry to the function. If you choose to
    do this,^([2](ch07.html#ch07fn2)) you’d need to be confident that the kernel version
    you’re running on has the instruction you want to attach to where you think it
    is! Attaching to kernel function entry and exit points can be relatively stable,
    but arbitrary lines of code might easily be modified from one release to the next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the example output from `bpftool perf list`, you can see that there is an
    offset of 0 for both of the kprobes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: When the kernel is compiled, there’s also the possibility that the compiler
    chooses to “inline” any given kernel function; that is, rather than jump from
    where the function is called, the compiler might emit the machine code to implement
    whatever the function does within the calling functions. If a function happens
    to get inlined, there won’t be a kprobe entry point for your eBPF program to attach
    to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Attaching kprobes to syscall entry points
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first example eBPF program for this chapter is called `kprobe_sys_execve`,
    and it is a kprobe attached to the `execve()` syscall. The function and its section
    definition look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '``This is the same as what you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: One reason to attach to syscalls is that they are stable interfaces that won’t
    change between kernel versions (the same is true of tracepoints, which we’ll come
    to shortly). However, syscall kprobes shouldn’t be relied on for security tooling,
    for reasons I’ll cover in detail in [Chapter 9](ch09.html#ebpf_for_security).``  ``###
    Attaching kprobes to other kernel functions
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find lots of examples where eBPF-based tools use kprobes to attach
    to system calls, but, as mentioned earlier, kprobes can also be attached to any
    noninlined function in the kernel. I’ve provided an example in *hello.bpf.c* that
    attaches a kprobe to the function `do_execve()`, and it’s defined like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '``Because `do_execve()` isn’t a system call, there are a few differences between
    this and the previous example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The format of the SEC name is identical to the previous version attached to
    the syscall entry point, but there is no need to define platform-specific variants
    because `do_execve()`, like most kernel functions, is common to all platforms.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I used the `BPF_KPROBE` macro rather than `BPF_KPROBE_SYSCALL`. The intent is
    exactly the same, just that the latter handles syscall parameters.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another important difference: the `pathname` parameter to the syscall
    is a pointer to a string `(char *)`, but for this function the parameter is called
    `filename`, and it’s a pointer to a `struct filename`, which is a data structure
    used within the kernel.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might well be wondering how I knew to use this type for this parameter.
    I’ll show you. The `do_execve()` function in the kernel has the following signature:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I chose to ignore the `do_execve()` parameters `__argv` and `__envp`, and only
    declare the `filename` argument, using the type `struct filename *` to match the
    kernel function’s definition. Given the way arguments are laid out sequentially
    in memory, it’s OK to ignore the last *n* parameters, but you can’t ignore an
    earlier argument in the list if you want to use a later one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'This `filename` structure is defined internal to the kernel, and it’s an illustration
    of how eBPF programming is kernel programming: I had to look up the definition
    of `do_execve()` to find its arguments, and the definition of `struct filename`.
    The name of the executable that is about to be run is pointed to by `filename->name`.
    I’m retrieving this name in the example code with the following lines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '``So to recap: the context parameter to a syscall kprobe is a structure representing
    the values passed by user space into the syscall. The context parameter to a “regular”
    (nonsyscall) kprobe is a structure representing the parameters passed to the called
    function by whatever kernel code is calling it, so the structure depends on the
    function definition.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Kretprobes are very similar to kprobes, except that they are triggered when
    a function returns and can access the return value instead of the arguments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and kretprobes are a reasonable way to hook into kernel functions, but
    there’s a newer option you should consider if you’re running on recent kernels.[PRE5]  [PRE6]cpp
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: SEC("fentry/do_execve") `int``BPF_PROG``(``fentry_execve``,``struct``filename``*``filename``)`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]cpp'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: SEC("kretprobe/do_unlinkat") `int``BPF_KRETPROBE``(``do_unlinkat_exit``,``long``ret``)`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]cpp'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: SEC("fexit/do_unlinkat") `int``BPF_PROG``(``do_unlinkat_exit``,``int``dfd``,``struct``filename``*``name``,``long``ret``)`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]cpp[PRE10]## Tracepoints'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[Tracepoints](https://oreil.ly/yXk_L) are marked locations in the kernel code
    (we’ll come to user space tracepoints later in this chapter). They’re not by any
    means exclusive to eBPF and have long been used to generate kernel trace output
    and by tools like [SystemTap](https://oreil.ly/bLmQL). Unlike attaching to arbitrary
    instructions using kprobes, tracepoints are stable between kernel releases (although
    an older kernel might not have the full set of tracepoints that have been added
    into a newer one).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the available set of tracing subsystems on your kernel by looking
    at */sys/kernel/tracing/available_events*, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: My 5.15 version of the kernel has more than 1,400 tracepoints defined in this
    list. The section definition for a tracepoint eBPF program should match one of
    these items so that *libbpf* can automatically attach it to the tracepoint. The
    definition is in the form `SEC("tp/tracing subsystem/tracepoint name")`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find an example in the *chapter7/hello.bpf.c*files that matches the
    `syscalls:sys_enter_execve` tracepoint that gets hit when the kernel starts processing
    an `execve()` call. The section definition tells *libbpf* that this is a tracepoint
    program, and where it should be attached, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`What about the context parameter to a tracepoint? As I’ll come to shortly,
    BTF can help us here, but first let’s consider what is needed when BTF isn’t available.
    Each tracepoint has a format describing the fields that get traced out from it.
    As an example, here’s the format for the tracepoint at the entry to the `execve()`
    syscall:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I used this information to define a matching structure called `m⁠y⁠_⁠s⁠y⁠s⁠c⁠a⁠l⁠l⁠s⁠_⁠e⁠n⁠t⁠e⁠r⁠_​e⁠x⁠e⁠c⁠v⁠e`
    in *chapter7/hello.bpf.c*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14][PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]cppeBPF programs aren’t allowed to access the first four of these fields.
    If you try to access them, the program will fail verification with an `invalid
    bpf_context access` error.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'My example eBPF program that attaches to this tracepoint can use a pointer
    to this type as its context parameter, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]cpp'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`Then you can access the contents of this structure. For example, you can get
    the filename pointer as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]cpp'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`When you use a tracepoint program type, the structure passed to the eBPF program
    has already been mapped from a set of raw arguments. For better performance, you
    can directly access these raw arguments with a raw tracepoint eBPF program type.
    The section definition should start with `raw_tp` (or `raw_tracepoint`) instead
    of `tp`. You’ll need to convert the arguments from `__u64` to whatever type the
    tracepoint structure uses (when the tracepoint is the entry to a system call,
    these arguments are dependent on the chip architecture).[PRE19]`cpp``  [PRE20]cpp'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: bpftool prog load hello.bpf.o /sys/fs/bpf/hello
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: bpftool net attach xdp id 540 dev eth0
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]cpp'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: $ ip link set dev eth0 xdp obj hello.bpf.o sec xdp
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]cpp'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpgeneric qdisc fq_codel'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: state UP mode DEFAULT group default qlen 1000
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: link/ether 52:55:55:3a:1b:a2 brd ff:ff:ff:ff:ff:ff
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: prog/xdp id 1255 tag 9d0e949f89f1a82c jited
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]cpp'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: $ ip link set dev eth0 xdp off
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]cpp'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: case`BPF_PROG_TYPE_CGROUP_SOCK`:`switch`(`expected_attach_type`){case`BPF_CGROUP_INET_SOCK_CREATE`:case`BPF_CGROUP_INET_SOCK_RELEASE`:case`BPF_CGROUP_INET4_POST_BIND`:case`BPF_CGROUP_INET6_POST_BIND`:return0;default:return-`EINVAL`;}
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]cpp'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: strace -e bpf -o outfile ./hello
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]cpp'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'libbpf: Kernel error message: XDP program already attached'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: interface xdpgeneric attach failed: Device or resource busy'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'

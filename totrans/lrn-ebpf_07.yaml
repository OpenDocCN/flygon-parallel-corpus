- en: Chapter 7\. eBPF Program and Attachment Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters you saw lots of examples of eBPF programs, and you
    probably spotted the fact that they are attached to different types of events.
    Some of the examples I’ve shown attach to kprobes, but in other examples I’ve
    demonstrated XDP programs that handle a newly arrived network packet. These are
    just two of the many attachment points within the kernel. In this chapter we’ll
    take a deeper look at different program types and how they can be attached to
    different events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can build and run the examples from this chapter using the code and instructions
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter7* directory.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, some of the examples are not supported on ARM processors.
    Check out the *README* file in the *chapter7* directory for more details and advice.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently around 30 program types enumerated in [*uapi/linux/bpf.h*](https://oreil.ly/6dNIW),
    and more than 40 attachment types. The attachment type defines more specifically
    where the program gets attached; for lots of program types, the attachment type
    can be inferred from the program type, but some program types can be attached
    to multiple different points in the kernel, so an attachment type has to be specified
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, this book isn’t intended to be a reference manual, so I won’t cover
    every single eBPF program type. There’s a good chance that new types will have
    been added by the time you read this book anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Program Context Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All eBPF programs take a context argument that is a pointer, but the structure
    it points to depends on the type of event that triggered it. eBPF programmers
    need to write programs that accept the appropriate type of context; there is no
    point in pretending that the context argument points to a network packet if the
    event is, say, a tracepoint. Defining different types of programs allows the verifier
    to ensure that the contextual information is handled appropriately and to enforce
    rules about what helper functions are permissible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To dive into the details of the context data passed to different BPF program
    types, check out [this post by Alan Maguire on Oracle’s blog](https://oreil.ly/6dNIW).
  prefs: []
  type: TYPE_NORMAL
- en: Helper Functions and Return Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, the verifier checks that all helper functions
    used by a program are compatible with its program type. The example in the previous
    chapter demonstrated that the `bpf_get_current_pid_tgid()` helper function isn’t
    permitted in an XDP program. There is no user space process or thread involved
    at the point where a packet is received and the XDP hook is triggered, so a call
    to discover the current process and thread ID doesn’t make sense in that context.
  prefs: []
  type: TYPE_NORMAL
- en: The program type also determines the meaning of the return code from the program.
    Again using XDP as an example, the return code value tells the kernel what to
    do with the packet once the eBPF program has finished processing it—which could
    involve passing it to the network stack, dropping it, or redirecting it to a different
    interface. These return codes wouldn’t make any sense when an eBPF program is
    triggered by, say, hitting a particular tracepoint, where there is no network
    packet involved.
  prefs: []
  type: TYPE_NORMAL
- en: There is a [manpage for helper functions](https://oreil.ly/e8K73) (with, quite
    reasonably, disclaimers that it might not be complete due to the ongoing development
    of the BPF subsystem).
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of which helper functions are available for each program
    type in your version of the kernel with the `bpftool feature` command. This shows
    the system configuration and lists all the available program types and map types,
    and even lists all the helper functions that are supported for each program type.
  prefs: []
  type: TYPE_NORMAL
- en: Helper functions are considered part of the *UAPI*, the Linux kernel’s external,
    stable interface. As such, once a helper function has been defined in the kernel,
    it shouldn’t change in the future, even though the kernel’s internal functions
    and data structures can change.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the risk of changes between kernel versions, there was demand from eBPF
    programmers to be able to access some internal functions from eBPF programs. This
    can be achieved using the mechanism called *BPF kernel functions*, or [*kfuncs*](https://oreil.ly/gKSEx)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Kfuncs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kfuncs allow internal kernel functions to be registered with the BPF subsystem
    so that the verifier will allow them to be called from eBPF programs. There is
    a registration for each eBPF program type that is permitted to call a given kfunc.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike helper functions, kfuncs don’t provide compatibility guarantees, so an
    eBPF programmer has to consider the possibility of changes between kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of [“core” BPF kfuncs](https://oreil.ly/06qoi), which at the
    time of this writing consists of functions that allow eBPF programs to obtain
    and release kernel references to tasks and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the type of an eBPF program determines what events it can be attached
    to, which in turn defines the type of context information it receives. The program
    type also defines the set of helper functions and kfuncs it can call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Program types are broadly considered to fall into two categories: tracing (or
    perf) program types and networking-related program types. Let’s look at some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs that attach to kprobes, tracepoints, raw tracepoints, fentry/fexit
    probes, and perf events were all designed to provide an efficient way for eBPF
    programs in the kernel to report tracing information about events into user space.
    These tracing-related types weren’t expected to influence the way the kernel behaves
    in response to the events they are attached to (although, as you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    there have been some innovations in this area!).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are sometimes referred to as “perf-related” programs. For example, the
    `bpftool perf` subcommand lets you view programs attached to perf-related events
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is what I see when running example code from the *hello.bpf.c*
    file in the *chapter7* directory, which attaches different programs to a variety
    of events that are all related to `execve()`. I’ll discuss all of these types
    in this section, but as an overview, these programs are:'
  prefs: []
  type: TYPE_NORMAL
- en: A kprobe attached to the entry point to the `execve()` system call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kprobe attached to a kernel function, `do_execve()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tracepoint placed at the entry to the `execve()` syscall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two versions of a raw tracepoint called during the processing of `execve()`.
    One of these, as you’ll see in this section, is a BTF-enabled version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need `CAP_PERFMON` and `CAP_BPF` or `CAP_SYS_ADMIN` capabilities to use
    any of the tracing-related eBPF program types.
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and Kretprobes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I discussed the concept of kprobes in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque).
    You can attach kprobe programs almost anywhere in the kernel.^([1](ch07.html#ch07fn1))
    Commonly, they are attached using kprobes to the entry to a function and kretprobes
    to the exit of a function, but you can use kprobes to attach to an instruction
    that is some specified offset after the entry to the function. If you choose to
    do this,^([2](ch07.html#ch07fn2)) you’d need to be confident that the kernel version
    you’re running on has the instruction you want to attach to where you think it
    is! Attaching to kernel function entry and exit points can be relatively stable,
    but arbitrary lines of code might easily be modified from one release to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the example output from `bpftool perf list`, you can see that there is an
    offset of 0 for both of the kprobes.
  prefs: []
  type: TYPE_NORMAL
- en: When the kernel is compiled, there’s also the possibility that the compiler
    chooses to “inline” any given kernel function; that is, rather than jump from
    where the function is called, the compiler might emit the machine code to implement
    whatever the function does within the calling functions. If a function happens
    to get inlined, there won’t be a kprobe entry point for your eBPF program to attach
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching kprobes to syscall entry points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first example eBPF program for this chapter is called `kprobe_sys_execve`,
    and it is a kprobe attached to the `execve()` syscall. The function and its section
    definition look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '``This is the same as what you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).'
  prefs: []
  type: TYPE_NORMAL
- en: One reason to attach to syscalls is that they are stable interfaces that won’t
    change between kernel versions (the same is true of tracepoints, which we’ll come
    to shortly). However, syscall kprobes shouldn’t be relied on for security tooling,
    for reasons I’ll cover in detail in [Chapter 9](ch09.html#ebpf_for_security).``  ``###
    Attaching kprobes to other kernel functions
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find lots of examples where eBPF-based tools use kprobes to attach
    to system calls, but, as mentioned earlier, kprobes can also be attached to any
    noninlined function in the kernel. I’ve provided an example in *hello.bpf.c* that
    attaches a kprobe to the function `do_execve()`, and it’s defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '``Because `do_execve()` isn’t a system call, there are a few differences between
    this and the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the SEC name is identical to the previous version attached to
    the syscall entry point, but there is no need to define platform-specific variants
    because `do_execve()`, like most kernel functions, is common to all platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I used the `BPF_KPROBE` macro rather than `BPF_KPROBE_SYSCALL`. The intent is
    exactly the same, just that the latter handles syscall parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another important difference: the `pathname` parameter to the syscall
    is a pointer to a string `(char *)`, but for this function the parameter is called
    `filename`, and it’s a pointer to a `struct filename`, which is a data structure
    used within the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might well be wondering how I knew to use this type for this parameter.
    I’ll show you. The `do_execve()` function in the kernel has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I chose to ignore the `do_execve()` parameters `__argv` and `__envp`, and only
    declare the `filename` argument, using the type `struct filename *` to match the
    kernel function’s definition. Given the way arguments are laid out sequentially
    in memory, it’s OK to ignore the last *n* parameters, but you can’t ignore an
    earlier argument in the list if you want to use a later one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `filename` structure is defined internal to the kernel, and it’s an illustration
    of how eBPF programming is kernel programming: I had to look up the definition
    of `do_execve()` to find its arguments, and the definition of `struct filename`.
    The name of the executable that is about to be run is pointed to by `filename->name`.
    I’m retrieving this name in the example code with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '``So to recap: the context parameter to a syscall kprobe is a structure representing
    the values passed by user space into the syscall. The context parameter to a “regular”
    (nonsyscall) kprobe is a structure representing the parameters passed to the called
    function by whatever kernel code is calling it, so the structure depends on the
    function definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Kretprobes are very similar to kprobes, except that they are triggered when
    a function returns and can access the return value instead of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and kretprobes are a reasonable way to hook into kernel functions, but
    there’s a newer option you should consider if you’re running on recent kernels.[PRE5]  [PRE6]cpp
  prefs: []
  type: TYPE_NORMAL
- en: SEC("fentry/do_execve") `int``BPF_PROG``(``fentry_execve``,``struct``filename``*``filename``)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: SEC("kretprobe/do_unlinkat") `int``BPF_KRETPROBE``(``do_unlinkat_exit``,``long``ret``)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: SEC("fexit/do_unlinkat") `int``BPF_PROG``(``do_unlinkat_exit``,``int``dfd``,``struct``filename``*``name``,``long``ret``)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]cpp[PRE10]## Tracepoints'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tracepoints](https://oreil.ly/yXk_L) are marked locations in the kernel code
    (we’ll come to user space tracepoints later in this chapter). They’re not by any
    means exclusive to eBPF and have long been used to generate kernel trace output
    and by tools like [SystemTap](https://oreil.ly/bLmQL). Unlike attaching to arbitrary
    instructions using kprobes, tracepoints are stable between kernel releases (although
    an older kernel might not have the full set of tracepoints that have been added
    into a newer one).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the available set of tracing subsystems on your kernel by looking
    at */sys/kernel/tracing/available_events*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: My 5.15 version of the kernel has more than 1,400 tracepoints defined in this
    list. The section definition for a tracepoint eBPF program should match one of
    these items so that *libbpf* can automatically attach it to the tracepoint. The
    definition is in the form `SEC("tp/tracing subsystem/tracepoint name")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find an example in the *chapter7/hello.bpf.c*files that matches the
    `syscalls:sys_enter_execve` tracepoint that gets hit when the kernel starts processing
    an `execve()` call. The section definition tells *libbpf* that this is a tracepoint
    program, and where it should be attached, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`What about the context parameter to a tracepoint? As I’ll come to shortly,
    BTF can help us here, but first let’s consider what is needed when BTF isn’t available.
    Each tracepoint has a format describing the fields that get traced out from it.
    As an example, here’s the format for the tracepoint at the entry to the `execve()`
    syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I used this information to define a matching structure called `m⁠y⁠_⁠s⁠y⁠s⁠c⁠a⁠l⁠l⁠s⁠_⁠e⁠n⁠t⁠e⁠r⁠_​e⁠x⁠e⁠c⁠v⁠e`
    in *chapter7/hello.bpf.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14][PRE15]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]cppeBPF programs aren’t allowed to access the first four of these fields.
    If you try to access them, the program will fail verification with an `invalid
    bpf_context access` error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'My example eBPF program that attaches to this tracepoint can use a pointer
    to this type as its context parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '`Then you can access the contents of this structure. For example, you can get
    the filename pointer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '`When you use a tracepoint program type, the structure passed to the eBPF program
    has already been mapped from a set of raw arguments. For better performance, you
    can directly access these raw arguments with a raw tracepoint eBPF program type.
    The section definition should start with `raw_tp` (or `raw_tracepoint`) instead
    of `tp`. You’ll need to convert the arguments from `__u64` to whatever type the
    tracepoint structure uses (when the tracepoint is the entry to a system call,
    these arguments are dependent on the chip architecture).[PRE19]`cpp``  [PRE20]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: bpftool prog load hello.bpf.o /sys/fs/bpf/hello
  prefs: []
  type: TYPE_NORMAL
- en: bpftool net attach xdp id 540 dev eth0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: $ ip link set dev eth0 xdp obj hello.bpf.o sec xdp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpgeneric qdisc fq_codel'
  prefs: []
  type: TYPE_NORMAL
- en: state UP mode DEFAULT group default qlen 1000
  prefs: []
  type: TYPE_NORMAL
- en: link/ether 52:55:55:3a:1b:a2 brd ff:ff:ff:ff:ff:ff
  prefs: []
  type: TYPE_NORMAL
- en: prog/xdp id 1255 tag 9d0e949f89f1a82c jited
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: $ ip link set dev eth0 xdp off
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: case`BPF_PROG_TYPE_CGROUP_SOCK`:`switch`(`expected_attach_type`){case`BPF_CGROUP_INET_SOCK_CREATE`:case`BPF_CGROUP_INET_SOCK_RELEASE`:case`BPF_CGROUP_INET4_POST_BIND`:case`BPF_CGROUP_INET6_POST_BIND`:return0;default:return-`EINVAL`;}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: strace -e bpf -o outfile ./hello
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'libbpf: Kernel error message: XDP program already attached'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: interface xdpgeneric attach failed: Device or resource busy'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE

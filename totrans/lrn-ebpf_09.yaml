- en: Chapter 9\. eBPF for Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。eBPF用于安全
- en: You’ve seen how eBPF can be used to observe events across a system and report
    information about those events to user space tools. In this chapter you’ll consider
    how to build on the concept of event detection to create eBPF-based security tools
    that can detect, or even prevent, malicious activity. I’ll start by helping you
    understand what makes security different from other types of observability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了eBPF如何被用来观察系统中的事件，并向用户空间工具报告有关这些事件的信息。在本章中，您将考虑如何基于事件检测构建基于eBPF的安全工具，这些工具可以检测甚至防止恶意活动。我将首先帮助您了解安全与其他类型的可观察性之间的区别。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Example code for this chapter is in the [GitHub repo](http://github.com/lizrice/learning-ebpf)
    in the *chapter9* directory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于[GitHub存储库](http://github.com/lizrice/learning-ebpf)的*chapter9*目录中。
- en: Security Observability Requires Policy and Context
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全可观察性需要政策和上下文
- en: The difference between a security tool and an observability tool that reports
    on events is that a security tool needs to be able to distinguish between events
    that are expected under normal circumstances and events that suggest malicious
    activity might be taking place. For example, suppose you have an application that
    writes data to a local file as part of its normal processing. Let’s say the app
    is expected to write to */home/<username>/<filename>*, so this activity isn’t
    something you’re interested in from a security perspective. However, you would
    want to be notified if the app writes to one of the many sensitive file locations
    in Linux. For example, it is unlikely that it needs to modify the password information
    stored in */etc/passwd*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工具和报告事件的可观察性工具之间的区别在于，安全工具需要能够区分在正常情况下预期的事件和表明可能发生恶意活动的事件。例如，假设您有一个应用程序，作为其正常处理的一部分将数据写入本地文件。假设该应用程序预期写入*/home/<username>/<filename>*，因此从安全角度来看，这种活动并不是您感兴趣的事情。但是，如果应用程序写入Linux中的许多敏感文件位置之一，您将希望收到通知。例如，它不太可能需要修改*/etc/passwd*中存储的密码信息。
- en: Policies have to take into account not just normal behavior when systems are
    fully functional, but also the expected error path behavior. For example, if a
    physical disk gets full, the application might start sending network messages
    to alert about this situation. These network messages shouldn’t be seen as security
    events—even though they are unusual, they’re not suspicious. Taking error paths
    into account can make it challenging to create effective policies, and we’ll come
    back to that challenge later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 政策必须考虑的不仅是系统完全正常运行时的正常行为，还有预期的错误路径行为。例如，如果物理磁盘变满，应用程序可能会开始发送网络消息以警告这种情况。这些网络消息不应被视为安全事件——尽管它们不寻常，但并不可疑。考虑错误路径可能会使创建有效政策变得具有挑战性，我们将在本章后面回到这个挑战。
- en: Defining what is and isn’t expected behavior is the job of a policy. A security
    tool compares activity to a policy and takes some action when the activity is
    outside the policy, making it suspicious. That action would typically involve
    generating a security event log, which would usually get sent to a Security Information
    Event Management (SIEM) platform. It might also result in an alert to a human
    who will be called on to investigate what happened.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义预期行为和非预期行为的工作是政策的职责。安全工具将活动与政策进行比较，并在活动超出政策范围时采取某些行动，使其变得可疑。该行动通常涉及生成安全事件日志，通常会发送到安全信息事件管理（SIEM）平台。这可能还会导致向需要调查发生了什么的人发出警报。
- en: The more contextual information that’s available to the investigator, the more
    likely they will be able to find out the root cause of the event and determine
    whether it was an attack, which components were affected, how and when the attack
    took place, and who was responsible. As illustrated in [Figure 9-1](#contextual_information_is_required_alon),
    being able to answer questions like this takes a tool from mere logging to deserving
    the nomenclature “security observability.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 调查人员可以获得的上下文信息越多，他们就越有可能找出事件的根本原因，并确定它是否是一次攻击，哪些组件受到影响，攻击是如何发生的，以及谁负责。如[图9-1](#contextual_information_is_required_alon)所示，能够回答这类问题将使工具从仅仅是日志记录变得值得被称为“安全可观察性”。
- en: '![Contextual information is required alongside out-of-policy event detection
    for security observability](assets/lebp_0901.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![安全可观察性需要政策和上下文](assets/lebp_0901.png)'
- en: Figure 9-1\. Contextual information is required alongside out-of-policy event
    detection for security observability
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1。安全可观察性需要上下文信息来检测超出政策范围的事件
- en: Let’s explore some of the ways eBPF programs are being used to detect and enforce
    security events. As you know, eBPF programs can be attached to a variety of events,
    and one set of events that have been commonly used for security for many years
    are syscalls. We’ll start our discussion with syscalls, but as you’ll see, syscalls
    might not be the most effective way to implement security tooling with eBPF. We’ll
    see some newer and more sophisticated approaches later in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一些使用eBPF程序来检测和执行安全事件的方法。正如您所知，eBPF程序可以附加到各种事件，多年来一直被广泛用于安全的一组事件是系统调用。我们将从系统调用开始讨论，但正如您将看到的那样，系统调用可能不是使用eBPF实施安全工具的最有效方式。在本章的后面部分，我们将看到一些更新和更复杂的方法。
- en: Using System Calls for Security Events
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统调用进行安全事件
- en: 'System calls (or syscalls) are the interface between user space applications
    and the kernel. If you can restrict the set of syscalls an app can make, that
    will limit what it is able to do. For example, if you stop an app from making
    syscalls in the `open*()` family, it won’t be able to open files. If you have
    an application that you never expect to open files, you might want to create this
    limitation so that even if the app gets compromised, it won’t be able to open
    files maliciously. If you’ve been using Docker or Kubernetes over the past few
    years, there is a very good chance you have already come across a security tool
    that uses BPF to limit syscalls: seccomp*.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用（或syscalls）是用户空间应用程序和内核之间的接口。如果您可以限制应用程序可以进行的系统调用集，那将限制它能够做什么。例如，如果您阻止应用程序进行`open*（）`系列的系统调用，它将无法打开文件。如果您有一个您从未期望打开文件的应用程序，您可能希望创建这种限制，以便即使应用程序受到损害，它也无法恶意打开文件。如果您在过去几年中一直在使用Docker或Kubernetes，那么您很有可能已经遇到了一种使用BPF来限制系统调用的安全工具：seccomp*.*
- en: Seccomp
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seccomp
- en: 'The name *seccomp* is a contraction of “SECure COMPuting.” In its original,
    or “strict,” form, seccomp is used to limit the set of syscalls a process can
    use to a very small subset: `read()`, `write()`, `_exit()`, and `sigreturn()`.
    The intention of this strict mode was to allow users to run untrusted code (perhaps
    a program downloaded from the internet) without any possibility of that code doing
    malicious things.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*seccomp*的名称是“SECure COMPuting”的缩写。在其原始或“严格”形式中，seccomp用于将进程可以使用的系统调用集限制为非常小的子集：`read()`、`write()`、`_exit()`和`sigreturn()`。这种严格模式的目的是允许用户运行不受信任的代码（也许是从互联网下载的程序），而不可能让该代码执行恶意操作。'
- en: Strict mode is very restrictive, and many applications need to use a much larger
    set of syscalls—but that doesn’t mean they need all 400 and more of them. It makes
    sense to allow a more flexible method for restricting the set that any given application
    can use. This is the reasoning behind the flavor of seccomp that most of us from
    the container world have encountered, which is more properly known as seccomp-bpf.
    Instead of having a fixed subset of syscalls that it permits, this mode of seccomp
    uses BPF code to filter the syscalls that are and aren’t allowed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式非常严格，许多应用程序需要使用更大的系统调用集——但这并不意味着它们需要全部400多个系统调用。允许更灵活的方法来限制任何给定应用程序可以使用的系统调用集是有道理的。这就是我们大多数来自容器世界的人遇到的seccomp的理由，更准确地说是seccomp-bpf。与允许的系统调用的固定子集不同，seccomp的这种模式使用BPF代码来过滤允许和不允许的系统调用。
- en: 'In seccomp-bpf, a set of BPF instructions are loaded that act as a filter.
    Each time a syscall is called, the filter is triggered. The filter code has access
    to the arguments that are passed to the syscall so that it can make decisions
    based on both the syscall itself and the arguments that have been passed to it.
    The outcome is one of a set of possible actions that include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在seccomp-bpf中，加载了一组BPF指令，充当过滤器。每次调用系统调用时，都会触发过滤器。过滤器代码可以访问传递给系统调用的参数，以便根据系统调用本身和传递给它的参数做出决策。结果是一组可能的操作，包括：
- en: Allowing the syscall to go ahead
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许系统调用继续进行
- en: Returning an error code to the user space application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户空间应用程序返回错误代码
- en: Killing the thread
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止线程
- en: Notifying a user space application (seccomp-unotify*)* (as of kernel version
    5.0)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户空间应用程序（seccomp-unotify*）*（截至内核版本5.0）
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to explore writing your own BPF filter code, Michael Kerrisk has
    some good examples at [*https://oreil.ly/cJ6HL*](https://oreil.ly/cJ6HL).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索编写自己的BPF过滤器代码，Michael Kerrisk在[*https://oreil.ly/cJ6HL*](https://oreil.ly/cJ6HL)上有一些很好的例子。
- en: Some of the arguments passed to syscalls are pointers, and the BPF code in seccomp-bpf
    is not able to dereference these pointers. This limits the flexibility of a seccomp
    profile, as it can only use value arguments in its decision-making process. Also,
    it has to be applied to the process when it starts—you can’t modify the profile
    that is being applied to a given application process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给系统调用的一些参数是指针，而seccomp-bpf中的BPF代码无法解引用这些指针。这限制了seccomp配置文件的灵活性，因为它只能在决策过程中使用值参数。此外，它必须在进程启动时应用——您无法修改应用于给定应用程序进程的配置文件。
- en: You may well have used seccomp-bpf without writing BPF code, as the code is
    often derived from a human-readable seccomp profile. [Docker’s default profile](https://oreil.ly/IT_Bf)
    is a good example. This is a general-purpose profile intended to be usable with
    pretty much any normal, containerized application. That inevitably means it allows
    most syscalls and disallows only a few that are unlikely to be appropriate in
    any application, `reboot()` being a great example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您很可能已经使用了seccomp-bpf，而没有编写BPF代码，因为该代码通常是从可读的seccomp配置文件派生的。[Docker的默认配置文件](https://oreil.ly/IT_Bf)就是一个很好的例子。这是一个通用配置文件，旨在几乎可以与任何正常的容器化应用程序一起使用。这不可避免地意味着它允许大多数系统调用，并且只禁止了一些不太可能适用于任何应用程序的系统调用，`reboot()`就是一个很好的例子。
- en: '[According to Aqua Security](https://oreil.ly/1xWmn), most containerized apps
    use somewhere in the range of 40 to 70 syscalls. For better security, it would
    be preferable to use a more constrained profile that is targeted at each specific
    application and only allows the syscalls it actually uses.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[根据Aqua Security](https://oreil.ly/1xWmn)，大多数容器化应用程序使用大约40到70个系统调用。为了更好的安全性，最好使用一个更受限制的配置文件，针对每个特定应用程序，并且只允许它实际使用的系统调用。'
- en: Generating Seccomp Profiles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成Seccomp配置文件
- en: If you ask the average app developer to tell you what syscalls one of their
    programs makes, you’re likely to get a blank look. That’s not intended to be insulting.
    It’s just that most developers write in programming languages that give them higher-level
    abstractions far removed from the details of syscalls. For example, they might
    know what files their application opens, but it’s less likely that they could
    tell you whether they are opened using `open()` or `openat()`*.* This makes it
    unlikely that you’ll get a positive response if you ask the developer to handcraft
    an appropriate seccomp profile along with their application code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Automation is the way forward: the idea is to use a tool to record the set
    of syscalls an application makes. In the early days, seccomp profiles were generally
    compiled using `strace` to gather the set of syscalls an application calls.^([1](ch09.html#ch09fn2))
    This isn’t a wonderful solution in the cloud native age, as there’s no easy way
    to point `strace` at a specific container or Kubernetes pod. It would also be
    more helpful to generate the profile not just as a list of syscalls, but in the
    JSON format that Kubernetes and OCI-compatible container runtimes can take as
    input. There are a couple of tools that do this, using eBPF to gather information
    about all the syscalls being called:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[Inspektor Gadget](https://www.inspektor-gadget.io) includes a seccomp profiler
    that allows you to generate a custom seccomp profile for the containers in a Kubernetes
    pod.^([2](ch09.html#ch09fn3))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat created a seccomp profiler in the form of an [OCI runtime hook](https://oreil.ly/nC8vM).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these profilers, you need to run the application for some arbitrary amount
    of time to generate a profile that includes the full list of the syscalls it might
    legitimately call. As discussed earlier in this chapter, this list needs to include
    error paths. If your application can’t behave correctly under error conditions
    because the syscalls it needs to call are blocked, this might cause a bigger problem.
    And since seccomp profiles deal with a lower abstraction level than most developers
    are familiar with, it’s hard to review them manually to see if they cover all
    the right cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Taking the OCI runtime hook as an example, an eBPF program is [attached to the
    `syscall_enter` raw tracepoint](https://oreil.ly/sbWSc) and maintains an eBPF
    map that keeps track of [which syscalls have been seen](https://oreil.ly/czUM7).
    The user space parts of this tool are written in Go and use the [*iovisor/gobpf*
    library](https://oreil.ly/sYCT3). (I’ll discuss this and other Golang libraries
    for eBPF in [Chapter 10](ch10.html#ebpf_programming).)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the [lines of code](https://oreil.ly/DOShA) from the OCI
    runtime hook that load the eBPF program into the kernel and attach it to the tracepoint
    (a few lines have been omitted for brevity):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#code_id_9_1)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'This line does something quite interesting: it replaces a variable named `$PARENT_PID`
    in the eBPF source code with a numeric process ID. This is a common pattern, and
    it indicates that this tool will load individual eBPF programs for each process
    being instrumented.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_9_2)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Here, an eBPF program called `enter_trace` gets loaded into the kernel.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_9_3)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The `enter_trace` program gets attached to the tracepoint `raw_syscalls:sys_enter`.
    This is the tracepoint at the point of entry to any syscall, which you’ve encountered
    in earlier examples. Whenever any user space code makes a syscall, this tracepoint
    will be hit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: These profilers use eBPF code attached to `sys_enter` to keep track of the set
    of syscalls that have been used, and they generate a seccomp profile to be used
    with seccomp, which does the actual job of enforcing the profile. The next class
    of eBPF tools we’ll consider also attach to `sys_enter`, but they use syscalls
    to track the behavior of an application and compare it against security policies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Syscall-Tracking Security Tools
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用跟踪安全工具
- en: The best-known tool that falls into this category of syscall-tracking security
    tools is the CNCF project [Falco](https://falco.org), which provides security
    alerts. By default, Falco is installed as a kernel module, but there is also an
    eBPF version. Users can define [rules](https://oreil.ly/enufu) to determine what
    events are security relevant, and Falco can generate alerts in a variety of formats
    when events happen that don’t match the policies defined in these rules.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 属于系统调用跟踪安全工具这一类别的最知名的工具是CNCF项目[Falco](https://falco.org)，它提供安全警报。默认情况下，Falco安装为内核模块，但也有eBPF版本。用户可以定义[规则](https://oreil.ly/enufu)来确定哪些事件与安全相关，当发生不符合这些规则定义的事件时，Falco可以以各种格式生成警报。
- en: 'Both the kernel module driver and the eBPF-based driver attach to system calls.
    If you examine the [Falco eBPF programs on GitHub](https://oreil.ly/Q_cBD) you’ll
    see lines like the following that attach probes to raw syscall entry and exit
    points (plus a few other events, such as page faults):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块驱动程序和基于eBPF的驱动程序都连接到系统调用。如果您检查GitHub上的[Falco eBPF程序](https://oreil.ly/Q_cBD)，您会看到类似以下内容的行，它们将探针连接到原始系统调用入口和退出点（以及一些其他事件，例如页面错误）：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '``Since eBPF programs can be loaded dynamically and can detect events triggered
    by preexisting processes, tools like Falco can apply policies to application workloads
    that are already running. Users can modify the set of rules being applied without
    having to modify the applications or their configuration. This is in contrast
    to seccomp profiles, which have to be applied to the application process when
    it is launched.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “由于eBPF程序可以动态加载并且可以检测由预先存在的进程触发的事件，因此像Falco这样的工具可以将策略应用于已经运行的应用工作负载。用户可以修改正在应用的规则集，而无需修改应用程序或其配置。这与seccomp配置文件形成对比，后者必须在启动应用程序时应用于应用程序进程。”
- en: 'Unfortunately there is a problem with this approach of using syscall entry
    points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU)
    issue.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用系统调用入口点进行安全工具的方法存在一个问题：存在时间检查到使用时间（TOCTOU）问题。
- en: When an eBPF program is triggered at the entry point to a system call, it can
    access the arguments that user space has passed to that system call. If those
    arguments are pointers, the kernel will need to copy the pointed-to data into
    its own data structures before acting on that data. As illustrated in [Figure 9-2](#an_attacker_can_change_syscall_argument),
    there is a window of opportunity for an attacker to modify this data, after it
    has been inspected by the eBPF program but before the kernel copies it. Thus,
    the data being acted on might not be the same as what was captured by the eBPF
    program.^([3](ch09.html#ch09fn4))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当eBPF程序在系统调用的入口点触发时，它可以访问用户空间传递给该系统调用的参数。如果这些参数是指针，内核将需要将指向的数据复制到自己的数据结构中，然后再对该数据进行操作。如[图9-2](#an_attacker_can_change_syscall_argument)所示，攻击者有机会在eBPF程序检查数据后但内核复制数据之前修改这些数据。因此，正在操作的数据可能与eBPF程序捕获的数据不同。^([3](ch09.html#ch09fn4))
- en: '![An attacker can change syscall arguments before they are accessed by the
    kernel](assets/lebp_0902.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![攻击者可以在内核访问之前更改系统调用参数](assets/lebp_0902.png)'
- en: Figure 9-2\. An attacker can change syscall arguments before they are accessed
    by the kernel
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2。攻击者可以在内核访问之前更改系统调用参数
- en: The same window would apply for seccomp-bpf, were it not for the fact that in
    seccomp-bpf the program is not allowed to dereference the user space pointer,
    so it’s not possible to examine the data at all.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于seccomp-bpf来说，同样的窗口也适用，因为在seccomp-bpf中，程序不允许对用户空间指针进行解引用，因此根本无法检查数据。
- en: The TOCTOU issue does apply for seccomp_unotify, a recently added mode of seccomp
    where a violation can be reported to user space. The [manpage for seccomp_unotify](https://oreil.ly/cwpki)
    explicitly notes that “It should thus be absolutely clear that the seccomp user-space
    notification mechanism *cannot* be used to implement a security policy!”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TOCTOU问题也适用于seccomp_unotify，这是seccomp的最近添加的模式，其中可以向用户空间报告违规行为。[seccomp_unotify的manpage](https://oreil.ly/cwpki)明确指出“因此，应该绝对清楚，seccomp用户空间通知机制*不能*用于实施安全策略！”
- en: The syscall entry point might be very convenient for observability purposes,
    but for a serious security tool it’s really not sufficient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用入口点可能非常方便用于可观察性目的，但对于严肃的安全工具来说，这确实是不够的。
- en: The [Sysmon for Linux tool](https://oreil.ly/pbtF3) addresses the TOCTOU window
    by attaching to both the entry and exit points for syscalls. Once the call has
    completed, it looks at the kernel’s data structures to get an accurate view. For
    example, if the syscall returns a file descriptor, the eBPF program attached to
    the exit can retrieve correct information about the object that the file descriptor
    represents by looking into the related process’s file descriptor table. While
    this approach can result in an accurate record of security-related activity, it
    can’t prevent an action from taking place, since the syscall has already completed
    by the time a check is made.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[Linux工具Sysmon](https://oreil.ly/pbtF3)通过连接到系统调用的入口和退出点来解决TOCTOU窗口问题。一旦调用完成，它会查看内核的数据结构以获得准确的视图。例如，如果系统调用返回文件描述符，附加到退出的eBPF程序可以通过查看相关进程的文件描述符表来检索有关文件描述符表示的对象的正确信息。虽然这种方法可以产生与安全相关的活动的准确记录，但它无法阻止动作发生，因为在进行检查时系统调用已经完成。'
- en: 'To be certain that it is inspecting the same information the kernel will act
    on, the eBPF program should be attached to an event that occurs after the parameters
    have been copied into kernel memory. Unfortunately, there is no single common
    place in the kernel to do this, as the data is handled differently in syscall-specific
    code. However, there is a well-defined interface where eBPF programs can be safely
    attached: the Linux Security Module (LSM) API. This requires a relatively new
    eBPF feature: BPF LSM.``  ``# BPF LSM'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它检查的是内核将要执行的相同信息，eBPF程序应该附加到在参数被复制到内核内存之后发生的事件上。不幸的是，在内核中没有一个统一的地方可以这样做，因为数据在特定于系统调用的代码中处理方式不同。但是，有一个明确定义的接口可以安全地附加eBPF程序：Linux安全模块（LSM）API。这需要一个相对较新的eBPF功能：BPF
    LSM。``  ``# BPF LSM
- en: The LSM interface provides a set of hooks that each occur just before the kernel
    is about to act on a kernel data structure. The function called by a hook can
    make a decision about whether to allow the action to go ahead. This interface
    was originally provided to allow security tools to be implemented in the form
    of [kernel modules](https://oreil.ly/mF_OD); [BPF LSM](https://oreil.ly/KzaMT)
    extends this so that eBPF programs can be attached to the same hook points, as
    shown in [Figure 9-3](#with_lsm_bpfcomma_ebpf_programs_can_be_).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: LSM接口提供了一组钩子，每个钩子都在内核即将对内核数据结构采取行动之前发生。由钩子调用的函数可以决定是否允许继续执行操作。最初提供此接口是为了允许以[内核模块](https://oreil.ly/mF_OD)的形式实现安全工具；[BPF
    LSM](https://oreil.ly/KzaMT)扩展了此功能，以便eBPF程序可以附加到相同的钩子点，如[图9-3](#with_lsm_bpfcomma_ebpf_programs_can_be_)所示。
- en: '![With LSM BPF, eBPF programs can be triggered by LSM hook events](assets/lebp_0903.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用LSM BPF，eBPF程序可以通过LSM钩子事件触发](assets/lebp_0903.png)'
- en: Figure 9-3\. With LSM BPF, eBPF programs can be triggered by LSM hook events
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-3。使用LSM BPF，eBPF程序可以通过LSM钩子事件触发
- en: There are hundreds of LSM hooks, and they’re pretty nicely [documented in the
    kernel source code](https://oreil.ly/dO8jT). To be clear, there isn’t a one-to-one
    mapping between syscalls and LSM hooks, but if a syscall has the potential to
    do something interesting from a security perspective, processing that syscall
    will trigger one or more of the hooks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百个LSM钩子，并且它们在内核源代码中[有很好的文档记录](https://oreil.ly/dO8jT)。要明确的是，系统调用和LSM钩子之间并没有一对一的映射，但是如果系统调用有可能从安全的角度做一些有趣的事情，处理该系统调用将触发一个或多个钩子。
- en: 'Here’s a trivial example of an eBPF program attached to an LSM hook. This example
    is called during the processing of a `chmod` command (“chmod” stands for “change
    modes” and is mostly used to change the access permissions on a file):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个附加到LSM钩子的eBPF程序的简单示例。此示例在处理`chmod`命令（“chmod”代表“更改模式”，主要用于更改文件的访问权限）时被调用：
- en: '[PRE2]``'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]``'
- en: '[PRE3]This example simply traces out the name of the file and always returns
    `0`, but you can imagine a real implementation that would make use of the arguments
    to decide whether to allow this change of mode. Returning a nonzero value would
    deny permission to make this change, so the kernel wouldn’t go ahead with it.
    It’s worth noting that making policy checks entirely within the kernel like this
    is highly performant.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]此示例只是跟踪文件的名称并始终返回`0`，但您可以想象一个真实的实现，该实现将利用参数来决定是否允许更改模式。返回一个非零值将拒绝更改权限，因此内核将不会继续执行。值得注意的是，像这样在内核内部完全进行策略检查是非常高效的。'
- en: The `path` argument to `BPF_PROG()` is the kernel data structure representing
    the file, and the `mode` argument is the desired new mode value. You can see the
    name of the file being accessed from the field `path->dentry->d_iname`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG()`的`path`参数是表示文件的内核数据结构，`mode`参数是期望的新模式值。您可以从字段`path->dentry->d_iname`中看到正在访问的文件的名称。'
- en: LSM BPF was added in kernel version 5.7, which means that (at least at the time
    of this writing) it’s not yet available on many supported Linux distributions,
    but I expect that over the next couple of years many vendors will develop security
    tooling that makes use of this interface. Before LSM BPF is made widely available,
    there is another possible approach, as used by the developers of Cilium Tetragon.[PRE4]#
    Cilium Tetragon
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: LSM BPF是在内核版本5.7中添加的，这意味着（至少在撰写本文时）它尚未在许多受支持的Linux发行版上可用，但我预计在接下来的几年里，许多供应商将开发使用此接口的安全工具。在LSM
    BPF被广泛使用之前，还有另一种可能的方法，就像Cilium Tetragon的开发人员所使用的那样。[PRE4]# Cilium Tetragon
- en: '[Tetragon](https://oreil.ly/p-bdc) is part of the Cilium project (also part
    of the CNCF). Rather than attaching to LSM API hooks, Tetragon’s approach is to
    build a framework for attaching eBPF programs to arbitrary functions in the Linux
    kernel.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tetragon](https://oreil.ly/p-bdc)是Cilium项目的一部分（也是CNCF的一部分）。Tetragon的方法不是附加到LSM
    API钩子，而是构建一个框架，用于将eBPF程序附加到Linux内核中的任意函数。'
- en: 'Tetragon is designed for use in a Kubernetes environment, and the project defines
    a custom Kubernetes resource type called a *TracingPolicy*. This is used to define
    a set of events to which eBPF programs should be attached, conditions that need
    to be checked by eBPF code, and actions to take if the conditions are met. The
    following is an extract from a sample TracingPolicy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Tetragon是为Kubernetes环境设计的，并且该项目定义了一种称为*TracingPolicy*的自定义Kubernetes资源类型。这用于定义应该附加eBPF程序的一组事件、需要由eBPF代码检查的条件以及如果满足条件应该采取的操作。以下是从示例TracingPolicy中提取的内容：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This policy defines a set of kprobes to attach programs to, the first of which
    is the kernel function `fd_install`. This is an internal function in the kernel.
    Let’s explore why you might choose to attach to a function like that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略定义了一组kprobe，用于附加程序，其中第一个是内核函数`fd_install`。这是内核中的一个内部函数。让我们探讨为什么您可能选择附加到这样的函数。
- en: Attaching to Internal Kernel Functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到内部内核函数
- en: The system call interface and the LSM interface are defined as stable interfaces
    in the Linux kernel; that is to say, they won’t change in a backward-incompatible
    way. If you write code today that uses the functions in those interfaces, they
    will continue to work in future versions of the kernel. These interfaces represent
    just a tiny fraction of the 30 million lines of code that make up the Linux kernel.
    Parts of that codebase are de facto stable, even if they are not officially declared
    as such; they haven’t changed for a long time and are unlikely to do so in the
    future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用接口和LSM接口在Linux内核中被定义为稳定接口；也就是说，它们不会以不兼容的方式进行更改。如果你今天编写使用这些接口中的函数的代码，它们将在将来的内核版本中继续工作。这些接口只代表了构成Linux内核的3000万行代码中的一小部分。即使它们没有被正式声明为这样，这部分代码库是事实上稳定的；它们已经很长时间没有改变，未来也不太可能改变。
- en: It’s perfectly reasonable to write eBPF programs that attach to kernel functions
    that aren’t officially stable, with the expectation that they are likely to work
    for some considerable time to come. Also, given that it typically takes several
    years for a new kernel version to be widely deployed, it’s a safe bet that there
    will be plenty of time to address any incompatibility issues that might arise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写附加到官方稳定性不确定的内核函数的eBPF程序是完全合理的，可以期望它们在相当长的时间内能够正常工作。此外，考虑到新内核版本通常需要几年时间才能被广泛部署，可以肯定会有足够的时间来解决可能出现的任何不兼容性问题。
- en: The Tetragon contributors include a number of kernel developers who have used
    their knowledge of kernel internals to identify some good, safe places where eBPF
    programs can be attached for useful security purposes. There are several [example
    TracingPolicy definitions](https://oreil.ly/51yRN) that make use of this knowledge.
    These examples monitor security events covering file operations, network activity,
    program executions, and changes to privileges—all the kinds of things a malicious
    actor would do as part of an attack.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Tetragon的贡献者包括一些内核开发人员，他们利用对内核内部的了解，确定了一些可以附加eBPF程序以实现有用安全目的的良好且安全的位置。有几个[示例TracingPolicy定义](https://oreil.ly/51yRN)利用了这些知识。这些示例监视涵盖文件操作、网络活动、程序执行和权限更改的安全事件，这些都是恶意行为者在攻击中可能会做的事情。
- en: Let’s come back to that example policy definition that attaches to `fd_install`.
    The “fd” stands for “file descriptor,” and the [comment in the source code for
    this function](https://oreil.ly/Tm6MN) tells us this function “Install[s] a file
    pointer in the fd array.” This happens when a file is opened, and it’s called
    after the file’s data structure has been populated in the kernel. It’s a safe
    place to check the name of the file—and in the earlier TracingPolicy example,
    it’s only of interest if the filename starts with “/etc/”.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到附加到`fd_install`的示例策略定义。这里的“fd”代表“文件描述符”，而[此函数的源代码注释](https://oreil.ly/Tm6MN)告诉我们这个函数“在fd数组中安装一个文件指针”。这发生在打开文件时，并且在文件的数据结构在内核中被填充后调用。这是一个安全的地方来检查文件的名称，并且在早期的TracingPolicy示例中，只有当文件名以“/etc/”开头时才感兴趣。
- en: Just as in LSM BPF programs, Tetragon eBPF programs have access to contextual
    information to allow them to make security decisions entirely within the kernel.
    Rather than reporting all events of a given type to user space, security-relevant
    events can be filtered within the kernel so that only the out-of-policy events
    get reported to user space.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与LSM BPF程序一样，Tetragon的eBPF程序可以访问上下文信息，使它们能够完全在内核内做出安全决策。与将给定类型的所有事件报告给用户空间不同，安全相关事件可以在内核内进行过滤，以便只有违反策略的事件才会报告给用户空间。
- en: Preventative Security
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预防安全
- en: Most eBPF-based security tools have used eBPF programs to detect malicious events,
    which notify a user space application that can then take action. As you can see
    in [Figure 9-4](#an_asynchronous_notification_from_kerne), any action the user
    space app takes happens asynchronously, by which time it might be too late—perhaps
    data could have been exfiltrated, or the attacker could have persisted malicious
    code onto disk.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于eBPF的安全工具都使用eBPF程序来检测恶意事件，然后通知用户空间应用程序采取行动。正如你在[图9-4](#an_asynchronous_notification_from_kerne)中所看到的，用户空间应用程序采取的任何行动都是异步发生的，这时可能为时已晚——也许数据已经被外泄，或者攻击者已经将恶意代码持久化到磁盘上。
- en: '![An asynchronous notification from kernel to user space allows some time for
    an attack to continue](assets/lebp_0904.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![内核到用户空间的异步通知允许攻击继续一段时间](assets/lebp_0904.png)'
- en: Figure 9-4\. An asynchronous notification from kernel to user space allows some
    time for an attack to continue
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-4。内核到用户空间的异步通知允许攻击继续一段时间
- en: In kernel versions 5.3 and up, there is a BPF helper function called `b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)`.
    Tetragon uses this function to implement preventative security. If a policy defines
    a Sigkill action, any matching events will cause Tetragon eBPF code to generate
    a SIGKILL signal that terminates the process that was attempting the out-of-policy
    action. As shown in [Figure 9-5](#tetragon_kills_malicious_processes_sync), this
    happens synchronously; that is, the activity the kernel was performing that the
    eBPF code determined to be out of policy is prevented from completing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核版本5.3及更高版本中，有一个名为`b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)`的BPF辅助函数。Tetragon使用这个函数来实现预防安全。如果策略定义了Sigkill动作，任何匹配的事件都会导致Tetragon的eBPF代码生成一个SIGKILL信号，终止试图执行违反策略动作的进程。如[图9-5](#tetragon_kills_malicious_processes_sync)所示，这是同步发生的；也就是说，内核正在执行的活动被eBPF代码确定为违反策略，将被阻止完成。
- en: '![Tetragon kills malicious processes synchronously by sending a SIGKILL signal
    from the kernel](assets/lebp_0905.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Tetragon通过从内核发送SIGKILL信号同步地杀死恶意进程](assets/lebp_0905.png)'
- en: Figure 9-5\. Tetragon kills malicious processes synchronously by sending a SIGKILL
    signal from the kernel
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-5。Tetragon通过从内核发送SIGKILL信号同步地杀死恶意进程
- en: Sigkill policies need to be used with care, because an incorrectly configured
    policy could result in terminating applications unnecessarily, but it’s an incredibly
    powerful use of eBPF for security purposes. You can start by running in an “audit”
    mode that generates security events but doesn’t apply the SIGKILL enforcement,
    until you’re confident that the policy won’t break anything.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Sigkill策略需要谨慎使用，因为配置不正确的策略可能导致不必要地终止应用程序，但这是eBPF用于安全目的的一种非常强大的用途。您可以从运行“审计”模式开始，生成安全事件但不应用SIGKILL执行，直到您确信该策略不会破坏任何东西。
- en: If you’re interested in learning more about using Cilium Tetragon for detecting
    security events, there is a report titled “[Security Observability with eBPF](https://www.oreilly.com/library/view/security-observability-with/9781492096719/)”
    by Natália Réka Ivánkó and Jed Salazar that digs into much more detail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对使用Cilium Tetragon来检测安全事件感兴趣，可以参考Natália Réka Ivánkó和Jed Salazar撰写的报告“[使用eBPF进行安全可观察性](https://www.oreilly.com/library/view/security-observability-with/9781492096719/)”，其中有更详细的内容。
- en: Network Security
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络安全
- en: '[Chapter 8](ch08.html#ebpf_for_networking) discussed how eBPF can be used very
    effectively to implement network security mechanisms. To summarize:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html#ebpf_for_networking)讨论了如何有效地使用eBPF来实施网络安全机制。总之：'
- en: Firewalling and DDoS protection are a natural fit for eBPF programs attached
    early in the ingress path for network packets. And with the possibility of XDP
    programs offloaded to hardware, malicious packets may never even reach the CPU!
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙和DDoS保护非常适合在网络数据包的入口路径早期附加eBPF程序。并且，通过将XDP程序卸载到硬件，恶意数据包甚至可能根本不会到达CPU！
- en: For implementing more sophisticated network policies, such as Kubernetes policies
    determining which services are allowed to communicate with one another, eBPF programs
    that attach to points in the network stack can drop packets if they are determined
    to be out of policy.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实施更复杂的网络策略，例如Kubernetes策略确定允许哪些服务相互通信，eBPF程序可以附加到网络堆栈中的某些点，如果确定数据包违反策略，可以丢弃数据包。
- en: Network security tools are very often used in a preventative mode, dropping
    packets rather than just auditing malicious activity. This is because it’s so
    easy for bad actors to mount network-related attacks; if you give a device a public
    IP address exposed to the internet, it won’t be long before you start seeing suspicious
    traffic, so organizations are forced to use preventative measures.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全工具往往以预防模式使用，而不仅仅是审计恶意活动。这是因为恶意行为者很容易发动与网络相关的攻击；如果您给设备一个暴露在互联网上的公共IP地址，很快就会开始看到可疑的流量，因此组织被迫采取预防措施。
- en: In contrast, lots of organizations use intrusion detection tools in an audit
    mode, and they rely on forensics to determine whether a suspicious event was really
    malicious and what remedial action needs to be taken. If a given security tool
    is too blunt an instrument and is prone to detecting false-positives, it’s not
    surprising that it needs to be run in audit mode rather than preventative mode.
    It’s my belief that eBPF is enabling more sophisticated security tools with finer-grained,
    accurate controls. Just as we consider firewalls today to be sufficiently accurate
    to use in preventative mode, we’ll see increased use of preventative tooling that
    acts on other, non-networking events. This could even include eBPF-based controls
    being packaged as part of an application product so that it can provide its own
    runtime security.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，许多组织在审计模式下使用入侵检测工具，并依靠取证来确定可疑事件是否真的恶意以及需要采取什么补救措施。如果某个安全工具过于粗糙并容易检测出误报，那么它需要在审计模式下运行而不是预防模式下运行并不奇怪。我相信eBPF正在实现更复杂的安全工具，具有更精细、准确的控制。就像我们今天认为防火墙足够准确以用于预防模式一样，我们将看到更多的预防性工具被用于处理其他非网络事件。这甚至可能包括将基于eBPF的控制作为应用产品的一部分打包，以便它可以提供自己的运行时安全性。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you saw how eBPF’s use in security has evolved from low-level
    checks on system calls to much more sophisticated use of eBPF programs for security
    policy checks, in-kernel event filtering, and runtime enforcement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了eBPF在安全领域的应用是如何从对系统调用的低级检查发展到更复杂的eBPF程序用于安全策略检查、内核事件过滤和运行时执行的。
- en: There’s still much active development in the area of using eBPF for security
    purposes. I believe we will see tools in this area evolving and becoming widely
    adopted over the coming years.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用eBPF进行安全目的方面仍然有很多积极的发展。我相信在未来几年内，我们将看到这一领域的工具不断发展并得到广泛应用。
- en: '^([1](ch09.html#ch09fn2-marker)) See, for example, this post from Jess Frazelle,
    who developed the default seccomp profile for Docker: [“How to Use the New Docker
    Seccomp Profiles”](https://oreil.ly/EcpnM).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#ch09fn2-marker)) 例如，Jess Frazelle开发了Docker的默认seccomp配置文件，可以参考她的这篇文章：[“如何使用新的Docker
    Seccomp配置文件”](https://oreil.ly/EcpnM)。
- en: ^([2](ch09.html#ch09fn3-marker)) The documentation for Inspektor Gadget’s seccomp
    profiler is quite dry, but [this video overview from Jose Blanquicet](https://oreil.ly/0bYaa)
    is more accessible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#ch09fn3-marker)) Inspektor Gadget的seccomp分析器的文档非常枯燥，但[Jose Blanquicet的这个视频概述](https://oreil.ly/0bYaa)更易于理解。
- en: '^([3](ch09.html#ch09fn4-marker)) Exploiting this window was discussed in a
    DEFCON 29 talk titled “[Phantom Attack: Evading System Call Monitoring](https://oreil.ly/WguKq)”
    by Rex Guo and Junyuan Zeng, and its impact on Falco was covered in more detail
    in the talk “[LSM BPF Change Everything](https://oreil.ly/17c-3)” by Leo Di Donato
    and KP Singh.`````'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#ch09fn4-marker)) 在DEFCON 29的一次名为“[幻影攻击：规避系统调用监控](https://oreil.ly/WguKq)”的演讲中讨论了利用这一窗口，演讲者是Rex
    Guo和Junyuan Zeng，而其对Falco的影响在Leo Di Donato和KP Singh的演讲“[LSM BPF改变一切](https://oreil.ly/17c-3)”中有更详细的介绍。

["```cpp\n$ bpftrace -l \"*execve*\"\ntracepoint:syscalls:sys_enter_execve\ntracepoint:syscalls:sys_exit_execve\n...\nkprobe:do_execve_file\nkprobe:do_execve\nkprobe:__ia32_sys_execve\nkprobe:__x64_sys_execve\n...\n```", "```cpp\nbpftrace -e 'kprobe:do_execve { @[comm] = count(); }'\nAttaching 1 probe...\n^C\n\n@[node]: 6\n@[sh]: 6\n@[cpuUsage.sh]: 18\n```", "```cpp\ntracepoint:syscalls:sys_enter_open,\ntracepoint:syscalls:sys_enter_openat\n{\n    @filename[tid] = args->filename;\n}\n\ntracepoint:syscalls:sys_exit_open,\ntracepoint:syscalls:sys_exit_openat\n/@filename[tid]/\n{\n    $ret = args->ret;\n    $fd = $ret > 0 ? $ret : -1;\n    $errno = $ret > 0 ? 0 : - $ret;\n\n    printf(\"%-6d %-16s %4d %3d %s\\n\", pid, comm, $fd, $errno,\n        str(@filename[tid]));\n    delete(@filename[tid]);\n}\n```", "```cpp\n./opensnoop.bt \nAttaching 6 probes...\nTracing open syscalls... Hit Ctrl-C to end.\nPID    COMM               FD ERR PATH\n297388 node               30   0 /home/liz/.vscode-server/data/User/\n                                 workspaceStorage/73ace3ed015\n297360 node               23   0 /proc/307224/cmdline\n297360 node               23   0 /proc/305897/cmdline\n297360 node               23   0 /proc/307224/cmdline\n```", "```cpp\n$ bpftool prog list \n...\n494: tracepoint  name sys_enter_open  tag 6f08c3c150c4ce6e  gpl\n        loaded_at 2022-11-18T12:44:05+0000  uid 0\n        xlated 128B  jited 93B  memlock 4096B  map_ids 254\n495: tracepoint  name sys_enter_opena  tag 26c093d1d907ce74  gpl\n        loaded_at 2022-11-18T12:44:05+0000  uid 0\n        xlated 128B  jited 93B  memlock 4096B  map_ids 254\n496: tracepoint  name sys_exit_open  tag 0484b911472301f7  gpl\n        loaded_at 2022-11-18T12:44:05+0000  uid 0\n        xlated 936B  jited 565B  memlock 4096B  map_ids 254,255\n497: tracepoint  name sys_exit_openat  tag 0484b911472301f7  gpl\n        loaded_at 2022-11-18T12:44:05+0000  uid 0\n        xlated 936B  jited 565B  memlock 4096B  map_ids 254,255\n\n$ bpftool map list \n254: hash  flags 0x0\n        key 8B  value 8B  max_entries 4096  memlock 331776B\n255: perf_event_array  name printf  flags 0x0\n        key 4B  value 4B  max_entries 2  memlock 4096B\n```", "```cpp\n#!/usr/bin/python3 ![1](assets/1.png)frombccimportBPFprogram=\"\"\"![2](assets/2.png)BPF_RINGBUF_OUTPUT(output, 1); ![3](assets/3.png)...int hello(void *ctx) { ... output.ringbuf_output(&data, sizeof(data), 0); ![4](assets/4.png) return 0;}\"\"\"b=BPF(text=program)![5](assets/5.png)...b[\"output\"].open_ring_buffer(print_event)![6](assets/6.png)...\n```", "```cpp\n    //go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG\n                         -cflags $BPF_CFLAGS bpf <C filename> -- -I../headers\n    ```", "```cpp\nstructbpf_map_defSEC(\"maps\")kprobe_map={ `...` ``};` ``SEC``(``\"kprobe/sys_execve\"``)` ``int``kprobe_execve``()``{` ``...` ``}```", "```cpp\n```", "```cppThe auto-generated Go code includes structures representing all the maps and programs (in this case, there is only one of each):\n\n```", "```cppebpf:\"kprobe_map\"`` ``}` ``type``bpfPrograms``struct``{` ``KprobeExecve``*``ebpf``.``Program```", "```cpp``\n```", "```cppThe names \u201cKprobeMap\u201d and \u201cKprobeExecve\u201d are derived from the map and program names used in the C code. These objects are grouped into a `bpfObjects` structure representing everything that\u2019s being loaded into the kernel:\n\n```", "```cpp\n```", "```cppYou can then use these object definitions and related auto-generated functions in your user space Go code. To give you an idea of what this might involve, here\u2019s an extract based on the main function from the same [kprobe example](https://oreil.ly/YXAjH) (omitting error handling for brevity):\n\n```", "```cpp\n\n[![1](assets/1.png)](#code_id_10_7)\n\nLoad all the BPF objects that were embedded in bytecode form, into the `bpfObjects` I just showed you defined by the auto-generated code.\n\n[![2](assets/2.png)](#code_id_10_8)\n\nAttach the program to the `sys_execve` kprobe.\n\n[![3](assets/3.png)](#code_id_10_9)\n\nSet up a ticker so that the code can poll the map once per second.\n\n[![4](assets/4.png)](#code_id_10_10)\n\nRead an item out of the map.\n\nThere are several other examples in the *cilium/ebpf* directory that you can use for reference and inspiration.```", "```cpp```", "```\nbpfModule:=bpf.NewModuleFromFile(bpfObjectPath)![1](assets/1.png)bpfModule.BPFLoadObject()![2](assets/2.png)mymap,_:=bpfModule.GetMap(\"mymap\")![3](assets/3.png)mymap.Update(key,value)rb,_:=bpfModule.InitRingBuffer(\"events\",eventsChannel,buffSize)rb.Start()e:=<-eventsChannel![4](assets/4.png)\n```", "```\n#[xdp(name=\"myapp\")]![1](assets/1.png)pubfnmyapp(ctx:XdpContext)->u32{matchunsafe{try_myapp(ctx)}{![2](assets/2.png)Ok(ret)=>ret,Err(_)=>xdp_action::XDP_ABORTED,}}unsafefntry_myapp(ctx:XdpContext)->Result<u32,u32>{![3](assets/3.png)info!(&ctx,\"received a packet\");Ok(xdp_action::XDP_PASS)}\n```", "```\nletmutbpf=Bpf::load(include_bytes_aligned!(\"../../target/bpfel-unknown-none/release/myapp\"))?;![1](assets/1.png)letprogram:&mutXdp=bpf.program_mut(\"myapp\").unwrap().try_into()?;![2](assets/2.png)program.load()?;![3](assets/3.png)program.attach(&opt.iface,XdpFlags::default())![4](assets/4.png)\n```", "```\n$ sysctl -w kernel.bpf_stats_enabled=1\n```", "```\n$ bpftool prog list \n...\n2179: raw_tracepoint  name raw_tp_exec  tag 7f6d182e48b7ed38  gpl\n        run_time_ns 316876 run_cnt 4\n        loaded_at 2023-01-09T11:07:31+0000  uid 0\n        xlated 216B  jited 264B  memlock 4096B  map_ids 780,777\n        btf_id 953\n        pids hello(19173)\n```"]
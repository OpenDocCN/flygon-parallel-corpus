- en: Chapter 10\. eBPF Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。eBPF编程
- en: In this book so far, you’ve learned a lot about eBPF and seen many examples
    of how it’s used for a variety of applications. But what if you want to implement
    your own ideas based on eBPF? This chapter discusses your options when it comes
    to writing your own eBPF code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你已经学到了很多关于eBPF的知识，并看到了许多关于它如何用于各种应用的例子。但是，如果你想根据eBPF实现自己的想法，该怎么办呢？本章讨论了在编写自己的eBPF代码时的选择。
- en: 'As you know from reading this book, eBPF programming consists of two parts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从阅读本书你知道，eBPF编程包括两个部分：
- en: Writing eBPF programs that run in the kernel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写在内核中运行的eBPF程序
- en: Writing the user space code that manages and interacts with eBPF programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写管理和与eBPF程序交互的用户空间代码
- en: Most of the libraries and languages I’ll discuss in this chapter require you
    as a programmer to handle both parts, with an awareness of what is being handled
    where. But `bpftrace`, perhaps the simplest eBPF programming language, masks this
    distinction from the programmer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中大多数我将讨论的库和语言都要求你作为程序员处理这两部分，并意识到在哪里处理了什么。但是`bpftrace`，也许是最简单的eBPF编程语言，掩盖了程序员对这种区别的认识。
- en: Bpftrace
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bpftrace
- en: As described on the project’s *README* page, “`bpftrace` is a high-level tracing
    language for Linux eBPF … inspired by awk and C, and predecessor tracers such
    as DTrace and SystemTap.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在项目的*README*页面上所描述的，“`bpftrace`是一个用于Linux eBPF的高级跟踪语言……受awk和C的启发，以及前身跟踪器，如DTrace和SystemTap。”
- en: The [`bpftrace`](https://oreil.ly/BZNZO) command-line tool converts programs
    written in this high-level language into eBPF kernel code and provides some output
    formatting for the results within the terminal. As a user, you don’t really need
    to think about the kernel–user space split.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[`bpftrace`](https://oreil.ly/BZNZO)命令行工具将用高级语言编写的程序转换为eBPF内核代码，并为终端内的结果提供一些输出格式。作为用户，你不需要真正考虑内核-用户空间的分离。'
- en: You’ll find several examples of useful one-liners in the project documentation,
    including a nice [tutorial](https://oreil.ly/Ah2QB) that takes you from writing
    a simple “Hello World” script up to writing more sophisticated scripts that can
    trace out data read from within kernel data structures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在项目文档中找到几个有用的一行脚本的例子，包括一个很好的[教程](https://oreil.ly/Ah2QB)，它将带你从编写一个简单的“Hello
    World”脚本到编写更复杂的脚本，可以跟踪内核数据结构中读取的数据。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Get a feel for the range of capabilities that `bpftrace` provides from Brendan
    Gregg’s [`bpftrace` cheat sheet](https://oreil.ly/VBwLm). Or, for in-depth coverage
    of both `bpftrace` and BCC, see his book [*BPF Performance Tools*](https://oreil.ly/kjc95).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从Brendan Gregg的[`bpftrace`速查表](https://oreil.ly/VBwLm)中了解`bpftrace`提供的各种功能。或者，要深入了解`bpftrace`和BCC，可以参考他的书[*BPF性能工具*](https://oreil.ly/kjc95)。
- en: 'As its name suggests, `bpftrace` can attach to tracing (also known as perf-related)
    events, including kprobes, uprobes, and tracepoints. For example, you can list
    the available tracepoints and kprobes on a machine with the `-l` option, like
    this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`bpftrace`可以附加到跟踪（也称为性能相关）事件，包括kprobes、uprobes和tracepoints。例如，你可以使用`-l`选项在机器上列出可用的tracepoints和kprobes，就像这样：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example finds all the available attachment points that contain “execve.”
    From this output you can see that it’s possible to attach to a kprobe called `do_execve`.
    Here’s a `bpftrace` one-line script that attaches to that event:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子找到了所有包含“execve”的可用附加点。从这个输出中，你可以看到可以附加到一个名为`do_execve`的kprobe。以下是一个附加到该事件的`bpftrace`一行脚本：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `{ @[comm] = count(); }` part is the script attached to that event. This
    example keeps track of the number of times the event was triggered by different
    executables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ @[comm] = count(); }`部分是附加到该事件的脚本。这个例子跟踪了不同可执行文件触发该事件的次数。'
- en: 'Scripts for `bpftrace` can coordinate multiple eBPF programs attached to different
    events. For example, consider the [*opensnoop.bt* script](https://oreil.ly/3HWZ2)
    that reports on files being opened. Here is an extract:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftrace`的脚本可以协调附加到不同事件的多个eBPF程序。例如，考虑报告文件被打开的[*opensnoop.bt*脚本](https://oreil.ly/3HWZ2)。以下是一个摘录：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script defines two different eBPF programs, each attached to two different
    kernel tracepoints, at the entry to and exit from the `open()` and `openat()`
    syscalls.^([1](ch10.html#ch10fn1)) Both of these syscalls are used to open files
    and take a filename as an input argument. The program triggered by either flavor
    of syscall entry caches that filename, storing it in a map where the key is the
    current thread ID. When the exit tracepoint is hit, the cached filename is retrieved
    from this map by the `/@filename[tid]/` line in the script.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本定义了两个不同的eBPF程序，分别附加到两个不同的内核跟踪点，即`open()`和`openat()`系统调用的进入和退出点。^([1](ch10.html#ch10fn1))这两个系统调用都用于打开文件，并将文件名作为输入参数。由任一类型的系统调用进入触发的程序缓存了该文件名，并将其存储在一个映射中，其中键是当前线程ID。当退出跟踪点被触发时，脚本中的`/@filename[tid]/`行检索了这个映射中缓存的文件名。
- en: 'Running this script generates output like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本会生成如下输出：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve just told you there are four eBPF programs attached to tracepoints, so
    why does this output say there are six probes? The answer is that there are two
    “special probes” for the `BEGIN` and `END` clauses that the full version of this
    program includes to initialize and clean up the script (very similar to the awk
    language). I’ve omitted those clauses here for brevity, but you can find them
    in the [source code in GitHub](https://oreil.ly/X8wgW).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚告诉你有四个eBPF程序附加到跟踪点，那为什么这个输出说有六个探针呢？答案是这个程序的完整版本包括用于初始化和清理脚本的`BEGIN`和`END`子句两个“特殊探针”（与awk语言非常相似）。出于简洁起见，我在这里省略了这些子句，但你可以在[GitHub的源代码](https://oreil.ly/X8wgW)中找到它们。
- en: 'If you’re using `bpftrace`, you don’t need to know about the underlying programs
    and maps, but for those of you who have read earlier chapters of this book, those
    concepts should be familiar to you by now. If you’re interested to see the programs
    and maps that are loaded in the kernel while a `bpftrace` program is running,
    you can easily do this with `bpftool` (just as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)).
    Here’s the output I got while running *opensnoop.bt*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`bpftrace`，你不需要了解底层的程序和映射，但是对于那些已经阅读了本书早期章节的人来说，这些概念现在应该是熟悉的。如果你有兴趣看到在运行`bpftrace`程序时加载到内核中的程序和映射，你可以很容易地使用`bpftool`来做到这一点（就像你在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到的那样）。这是我在运行*opensnoop.bt*时得到的输出。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can clearly see the four tracepoint programs, plus the hash map that’s used
    for caching the filenames and the `perf_event_array` that is being used to pass
    output data from kernel to user space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到四个跟踪点程序，以及用于缓存文件名的哈希映射和用于从内核传递输出数据到用户空间的`perf_event_array`。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `bpftrace` utility is built on top of BCC, which you met elsewhere in this
    book and which I’ll cover later in this chapter. `bpftrace` scripts get converted
    into BCC programs, which are then compiled at runtime using the LLVM/Clang toolchain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpftrace`实用程序是建立在BCC之上的，你在本书的其他地方已经见过了，我将在本章后面介绍。`bpftrace`脚本被转换为BCC程序，然后使用LLVM/Clang工具链在运行时编译。'
- en: If you want command-line tools for eBPF-based performance measurement, you may
    well find that your needs are met using [`bpftrace`](https://oreil.ly/u5FrJ).
    But although `bpftrace` can be a powerful tool for using eBPF for tracing, it
    doesn’t open up the full range of possibilities that eBPF enables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要基于eBPF的性能测量的命令行工具，你可能会发现你的需求可以通过[`bpftrace`](https://oreil.ly/u5FrJ)来满足。但是，虽然`bpftrace`可以成为使用eBPF进行跟踪的强大工具，但它并没有打开eBPF所能实现的全部可能性。
- en: To unlock the full potential of eBPF, you’ll need to directly write eBPF programs
    yourself for the kernel and also handle the user space part. These two aspects
    can, and often are, written in entirely different languages. Let’s start with
    the choices for eBPF code that runs in the kernel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分发挥eBPF的潜力，你需要直接为内核编写eBPF程序，并处理用户空间部分。这两个方面可以，而且通常是用完全不同的语言编写的。让我们从运行在内核中的eBPF代码的选择开始。
- en: Language Choices for eBPF in the Kernel
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核中的eBPF语言选择
- en: eBPF programs can be written directly in eBPF bytecode,^([2](ch10.html#ch10fn2))
    but in practice, most are compiled to bytecode from either C or Rust. These languages
    have compilers that support eBPF bytecode as a target output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序可以直接用eBPF字节码编写，^([2](ch10.html#ch10fn2))但实际上，大多数程序是从C或Rust编译成字节码的。这些语言有编译器支持eBPF字节码作为目标输出。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: eBPF bytecode isn’t a suitable target for all compiled languages. If the language
    involves a runtime component (like Go, or Java’s virtual machine), it’s likely
    to be incompatible with eBPF’s verifier. For example, it’s hard to imagine how
    memory garbage collection could work hand in hand with the verifier’s checks on
    safe use of memory. Similarly, eBPF programs are required to be single threaded,
    so any concurrency features in a language couldn’t be used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF字节码并不适合所有编译语言的目标。如果语言涉及运行时组件（比如Go，或者Java的虚拟机），它可能与eBPF的验证器不兼容。例如，很难想象内存垃圾收集如何与验证器对内存安全使用的检查相互配合。同样，eBPF程序要求是单线程的，因此语言中的任何并发特性都无法使用。
- en: Although not really eBPF, there is an interesting project called [XDPLua](https://oreil.ly/7_3Fx)
    that proposes writing XDP programs in Lua scripts that run directly within the
    kernel. However, the initial research in this project suggested that eBPF would
    likely be more performant, and as eBPF becomes more powerful with each kernel
    release (e.g., now being able to implement loops), it’s not clear that there is
    much advantage other than the personal preference that some people might have
    to write code in Lua scripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是真正的eBPF，但有一个有趣的项目叫做[XDPLua](https://oreil.ly/7_3Fx)，它提出用Lua脚本在内核中直接运行XDP程序。然而，该项目的初步研究表明，eBPF可能更具性能，随着每个内核版本的eBPF变得更加强大（例如，现在能够实现循环），目前还不清楚除了一些人可能更喜欢用Lua脚本编写代码之外，是否还有其他优势。
- en: I would hazard a guess that most people who choose to write eBPF kernel code
    in Rust would also opt for the same language for the user space code, since shared
    data structures wouldn’t need to be rewritten. It’s not obligatory, though—you
    can mix and match eBPF code with whatever user space language you choose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢猜测，大多数选择用Rust编写eBPF内核代码的人也会选择相同的语言来编写用户空间代码，因为共享数据结构不需要重新编写。不过这并非强制性的，你可以混合和匹配eBPF代码和任何你选择的用户空间语言。
- en: Those who choose to write the kernel-side code in C also have the option to
    write user space code in C (you’ve seen plenty of examples of that in this book
    already). But C is a pretty low-level language that requires programmers to handle
    lots of details for themselves, notably, memory management. While some people
    are comfortable doing this, many people would prefer to write the user space code
    in another, higher-level language. Whatever your preferred language, you’d like
    a library that provides eBPF support so that you don’t have to write directly
    to the system call interface you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    In the rest of this chapter we’ll discuss some of the most popular options for
    eBPF libraries in a variety of languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 选择用C编写内核端代码的人也可以选择用C编写用户空间代码（你在本书中已经看到了很多这样的例子）。但C是一种相当低级的语言，需要程序员自己处理很多细节，特别是内存管理。虽然有些人习惯这样做，但很多人更愿意用另一种更高级的语言来编写用户空间代码。无论你偏好哪种语言，你都希望有一个提供eBPF支持的库，这样你就不必直接编写到你在[第3章](ch03.html#anatomy_of_an_ebpf_program)中看到的系统调用接口。在本章的其余部分，我们将讨论一些不同语言中最受欢迎的eBPF库选项。
- en: BCC Python/Lua/C++
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BCC Python/Lua/C++
- en: Back in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor), the
    first “Hello World” example I gave you was a Python program written using the
    BCC library. This project includes plenty of useful performance measurement tools
    implemented using this same library (as well as newer implementations based on
    *libbpf* that I’ll come to momentarily).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第2章](ch02.html#ebpfapostrophes_quotation_markhello_wor)，我给你的第一个“Hello World”例子是使用BCC库编写的Python程序。这个项目包括了许多有用的性能测量工具，这些工具都是使用相同的库实现的（以及基于*libbpf*的新实现，我马上就会谈到）。
- en: In addition to the [documentation](https://oreil.ly/Elggv) that describes how
    to use the provided BCC tools to measure performance, BCC also includes a [reference
    guide](https://oreil.ly/WgeJA) and a [Python programming tutorial](https://oreil.ly/hR3xr)
    to help you develop your own eBPF tools in this framework.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[文档](https://oreil.ly/Elggv)描述如何使用提供的BCC工具来测量性能，BCC还包括一个[参考指南](https://oreil.ly/WgeJA)和一个[Python编程教程](https://oreil.ly/hR3xr)，帮助你在这个框架中开发自己的eBPF工具。
- en: '[Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf) included a discussion
    of BCC’s approach to portability, which is to compile the eBPF code at runtime
    to ensure that it’s compatible with the target machine’s kernel data structures.
    In BCC, you define the kernel-side eBPF program code as a string (or the contents
    of a file that BCC reads into a string). This string gets passed to Clang for
    compilation, but before that happens, BCC does some preprocessing on the string.
    This enables it to provide handy shortcuts for the programmer, some of which you’ve
    seen already in this book. For example, here are some relevant lines from the
    example code in *chapter2/hello_map.py*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)包括了对BCC的可移植性方法的讨论，即在运行时编译eBPF代码，以确保它与目标机器的内核数据结构兼容。在BCC中，你将内核端的eBPF程序代码定义为一个字符串（或者BCC读入字符串的文件内容）。这个字符串被传递给Clang进行编译，但在此之前，BCC对字符串进行了一些预处理。这使得它可以为程序员提供便利的快捷方式，其中一些你在本书中已经看到了。例如，这里是*chapter2/hello_map.py*中示例代码的一些相关行。'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#code_id_10_1)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_1)'
- en: This is a Python program, which will run in user space.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在用户空间运行的Python程序。
- en: '[![2](assets/2.png)](#code_id_10_2)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_2)'
- en: The `program` string holds the eBPF program to be compiled and then loaded into
    the kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`program`字符串保存了要编译然后加载到内核中的eBPF程序。'
- en: '[![3](assets/3.png)](#code_id_10_3)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_3)'
- en: '`BPF_RINGBUF_OUTPUT` is a BCC macro that defines a ring buffer called `output`.
    This is part of the `program` string, so it’s natural to assume it’s defining
    the buffer from the kernel’s perspective. Hold that thought until we get to callout
    6.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_RINGBUF_OUTPUT`是一个BCC宏，定义了一个名为`output`的环形缓冲区。这是`program`字符串的一部分，所以自然地会认为它是从内核的角度定义缓冲区。等到我们到达调用6时再考虑这个问题。'
- en: '[![4](assets/4.png)](#code_id_10_4)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_4)'
- en: This line looks like a `ringbuf_output()` method on an object called `object`.
    But wait a minute—methods on objects aren’t even part of the C language! BCC is
    doing some heavy lifting here, [expanding methods](https://oreil.ly/vLVth) like
    these into underlying BPF helper functions, `bpf_ringbuf_output()` in this case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行看起来像是一个叫做`object`的对象上的`ringbuf_output()`方法。但等一下——对象上的方法甚至不是C语言的一部分！BCC在这里做了一些繁重的工作，将这些方法扩展成底层的BPF辅助函数，本例中是`bpf_ringbuf_output()`。
- en: '[![5](assets/5.png)](#code_id_10_5)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#code_id_10_5)'
- en: This is where the program string gets rewritten into the BPF C code that Clang
    can compile. This line also loads the resultant program into the kernel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序字符串被重写为BPF C代码的地方，Clang可以编译。这行还将结果程序加载到内核中。
- en: '[![6](assets/6.png)](#code_id_10_6)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#code_id_10_6)'
- en: There is no other place in the code that defines the ring buffer called `output`,
    and yet it’s accessible from the Python user space code here. BCC does double
    duty when it preprocesses the line in callout 3, as it defines the ring buffer
    for both the user space and kernel parts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中没有其他地方定义名为`output`的环形缓冲区，但它可以从这里的Python用户空间代码中访问。BCC在预处理调用3中承担了双重职责，因为它为用户空间和内核部分都定义了环形缓冲区。
- en: As this example shows, BCC essentially provides its own C-like language for
    BPF programming. It makes life easy for the programmer, handling things like shared
    structure definitions for both kernel and user space and providing convenient
    shortcuts to wrap around BPF helper functions. This means BCC is an accessible
    way to get into eBPF programming if you’re new to the field, especially if you’re
    already comfortable with Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，BCC基本上为BPF编程提供了自己的类似C的语言。它为程序员提供了便利，处理了内核和用户空间的共享结构定义等问题，并提供了方便的快捷方式来包装BPF辅助函数。这意味着，如果你是这个领域的新手，尤其是如果你已经熟悉Python，BCC是一个进入eBPF编程的可访问的方式。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’d like to explore BCC programming, this [tutorial aimed at Python programmers](https://oreil.ly/0pHKY)
    is a great way to walk through many more of the features and capabilities of BCC
    than there is space for in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索BCC编程，这个[面向Python程序员的教程](https://oreil.ly/0pHKY)是一个很好的方式，可以让你了解BCC的许多特性和功能，这本书中没有足够的空间来介绍。
- en: The documentation doesn’t make it terribly clear, but as well as supporting
    Python as the language for the user space part of eBPF tools, BCC enables writing
    tools in Lua and C++. There are *lua* and *cpp* directories within the supplied
    [examples](https://oreil.ly/PP0cL) that you can base your own code on, should
    you be keen to try this approach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文档并不是非常清楚，但是除了支持Python作为eBPF工具用户空间的语言之外，BCC还支持用Lua和C++编写工具。在提供的[示例](https://oreil.ly/PP0cL)中有*lua*和*cpp*目录，你可以基于它们编写自己的代码，如果你想尝试这种方法的话。
- en: BCC may be convenient for the programmer, but because of the inefficiencies
    of distributing a compiler toolchain alongside your utility (discussed in more
    depth in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), if you’re looking
    to write production-quality tools that you intend to distribute, I recommend considering
    some of the other libraries discussed in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: BCC可能对程序员很方便，但是由于在你的实用程序旁边分发编译器工具链的低效率（在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中更深入讨论），如果你想要编写用于分发的生产质量工具，我建议考虑本章中讨论的其他一些库。
- en: C and Libbpf
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和Libbpf
- en: You’ve seen lots of examples in this book of eBPF programs written in C, using
    the LLVM toolchain to compile into eBPF bytecode. You’ve also seen that extensions
    were added to support BTF and CO-RE. Many C programmers will also be familiar
    with the other major C compiler, GCC, and will be happy to hear that [GCC from
    version 10](https://oreil.ly/XAzxP) also supports compiling to eBPF as a target;
    however, there are still some gaps compared with the functionality provided in
    LLVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经看到了很多用C编写的eBPF程序的例子，使用LLVM工具链编译成eBPF字节码。你也看到了添加了支持BTF和CO-RE的扩展。许多C程序员也熟悉另一个主要的C编译器GCC，并且会很高兴地听到[从版本10开始的GCC](https://oreil.ly/XAzxP)也支持编译为eBPF目标；然而，与LLVM提供的功能相比，仍然存在一些差距。
- en: As you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), CO-RE and
    *libbpf* enabled an approach to portable eBPF programming that doesn’t require
    shipping a compiler toolchain alongside every eBPF tool. The BCC project took
    advantage of this and, in addition to the original set of BCC performance tracing
    tools, it now has versions of these tools rewritten to take advantage of *libbpf*.
    The general consensus is that the versions of the BCC tools that have been rewritten
    based on *libbpf* are the better option to use, since they have a significantly
    lower memory footprint^([3](ch10.html#ch10fn3)) and don’t involve a start-up delay
    while the compilation step takes place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的，CO-RE和*libbpf*实现了一种可移植的eBPF编程方法，不需要在每个eBPF工具旁边提供编译器工具链。BCC项目利用了这一点，并且除了最初的一组BCC性能跟踪工具之外，现在还有这些工具的版本重写以利用*libbpf*。普遍的共识是，基于*libbpf*重写的BCC工具版本是更好的选择，因为它们具有显著较低的内存占用^([3](ch10.html#ch10fn3))，并且不涉及编译步骤的启动延迟。
- en: If you’re comfortable with programming in C, using *libbpf* can make a lot of
    sense. You’ve seen lots of examples of this already in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你擅长使用C进行编程，使用*libbpf*是很有意义的。在本书中，你已经看到了很多这方面的例子。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To write your own *libbpf* programs in C, the best place to start (now that
    you have read this book!) is [*libbpf-bootstrap*](https://oreil.ly/4mx81). Read
    Andrii Nakryiko’s [blog post about it](https://oreil.ly/-OW8v) as a good introduction
    to the motivations behind this project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C中编写自己的*libbpf*程序，最好的起点（现在你已经读过这本书了！）是[*libbpf-bootstrap*](https://oreil.ly/4mx81)。阅读Andrii
    Nakryiko的[关于此的博客文章](https://oreil.ly/-OW8v)是对这个项目背后动机的很好介绍。
- en: 'There’s also a library called [*libxdp*](https://oreil.ly/374mL) that builds
    on *libbpf* to allow for easier development and management of XDP programs. This
    is part of xdp-tools, which also holds one of my favorite learning resources for
    eBPF programming: the [XDP Tutorial](https://oreil.ly/E6dvl).^([4](ch10.html#ch10fn4))'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为[*libxdp*](https://oreil.ly/374mL)的库，它构建在*libbpf*之上，以便更轻松地开发和管理XDP程序。这是xdp-tools的一部分，也是我最喜欢的eBPF编程学习资源之一：[XDP教程](https://oreil.ly/E6dvl)^([4](ch10.html#ch10fn4))。
- en: But C is quite a challenging, low-level language. C programmers have to take
    responsibility for things like memory management and buffer handling, and it’s
    very easy to end up writing code with security vulnerabilities, not to mention
    crashes due to mishandling pointers. The eBPF verifier helps out on the kernel
    side, but there is no equivalent protection for your user space code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是C是一种相当具有挑战性的低级语言。C程序员必须对内存管理和缓冲区处理等事项负责，很容易编写出存在安全漏洞的代码，更不用说由于错误处理指针而导致的崩溃。eBPF验证器在内核端提供帮助，但对于用户空间代码没有类似的保护。
- en: The good news is that there are libraries for other programming languages that
    interface to *libbpf*, or provide similar relocation functionality to allow for
    portable eBPF programs. Here are a few of the most popular ones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，还有其他编程语言的库可以与*libbpf*进行接口，或者提供类似的重定位功能，以便编写可移植的eBPF程序。以下是一些最受欢迎的库。
- en: Go
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go
- en: The Go language has been widely adopted for infrastructure and cloud native
    tooling, so it’s natural that there should be options for writing eBPF code in
    it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言已经被广泛应用于基础设施和云原生工具，因此在其中编写eBPF代码是很自然的选择。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[This article by Michael Kashin](https://oreil.ly/s9umt) provides another perspective
    comparing different eBPF libraries for Go.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[Michael Kashin的这篇文章](https://oreil.ly/s9umt)提供了另一个视角，比较了Go语言的不同eBPF库。'
- en: Gobpf
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gobpf
- en: Possibly the first serious Golang implementation was the [gobpf](https://oreil.ly/pC0dF)
    project that sits alongside BCC as part of Iovisor. However, it hasn’t been actively
    maintained for a while, and as I write this, there’s some [discussion of deprecating
    it](https://oreil.ly/MnE79), so bear this in mind when making your library choice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能第一个严肃的Golang实现是[gobpf](https://oreil.ly/pC0dF)项目，它作为Iovisor的一部分与BCC并列。然而，它已经有一段时间没有得到积极的维护，就在我写这篇文章的时候，有一些[关于废弃它的讨论](https://oreil.ly/MnE79)，所以在选择库时要记住这一点。
- en: Ebpf-go
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ebpf-go
- en: The [eBPF Go library included as part of the Cilium project](https://oreil.ly/BnGyl)
    is widely used (I found around 10,000 references on GitHub, and the project has
    close to 4,000 stars). It provides convenient functions for managing and loading
    eBPF programs and maps, including CO-RE support, all implemented purely in Go.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Cilium项目的一部分，[eBPF Go库](https://oreil.ly/BnGyl)被广泛使用（我在GitHub上找到了大约1万个引用，该项目获得了接近4,000颗星）。它提供了方便的函数来管理和加载eBPF程序和映射，包括CO-RE支持，全部纯粹使用Go实现。
- en: With this library you have the option to compile your eBPF programs to bytecode
    and embed that bytecode into Go source code, using a supplied tool called [bpf2go](https://oreil.ly/-kDbH).
    You need the LLVM/Clang compiler to do this generation as part of the build step.
    Once the Go code is compiled, you have a single Go binary that you can distribute
    that includes the eBPF bytecode and is portable to different kernels, without
    any dependencies other than the Linux kernel itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该库，您可以选择将您的eBPF程序编译为字节码，并将该字节码嵌入到Go源代码中，使用一个名为[bpf2go](https://oreil.ly/-kDbH)的工具。您需要LLVM/Clang编译器来在构建步骤中进行此生成。一旦编译了Go代码，您就有一个单一的Go二进制文件，您可以分发该文件，其中包括eBPF字节码，并且可以在不同的内核上运行，而不需要除Linux内核本身之外的任何依赖项。
- en: The *cilium/ebpf* library also supports loading and managing eBPF programs built
    as standalone ELF files (like the **.bpf.o* examples you have seen in this book).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*cilium/ebpf*库还支持加载和管理作为独立ELF文件构建的eBPF程序（就像您在本书中看到的**.bpf.o*示例）。'
- en: At the time of this writing, the *cilium/ebpf* library supports the perf events
    for tracing, including the relatively recent fentry events, as well as an extensive
    set of network program types like XDP and cgroup socket attachments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，*cilium/ebpf*库支持用于跟踪的perf事件，包括相对较新的fentry事件，以及一系列广泛的网络程序类型，如XDP和cgroup套接字附件。
- en: 'In this project’s [*examples* directory under *cilium/ebpf*](https://oreil.ly/Vuf9d),
    you’ll see that the C code for in-kernel programs sits in the same directories
    as the corresponding user space code in Go:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的[*cilium/ebpf*下的*examples*目录](https://oreil.ly/Vuf9d)中，您会看到内核程序的C代码与Go中相应的用户空间代码位于相同的目录中：
- en: The C files start with `// +build ignore`, which tells the Go compiler to ignore
    them. At the time of this writing there is an [update in progress](https://oreil.ly/ymuyn)
    to change to the newer `//go:build` style of build tag.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C文件以`// +build ignore`开头，告诉Go编译器忽略它们。在撰写本文时，正在进行[更新](https://oreil.ly/ymuyn)，以更改为较新的`//go:build`样式的构建标签。
- en: 'The user space files include a line like the following, which tells the Go
    compiler to invoke the bpf2go tool on the C file(s):'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间文件包括以下行，告诉Go编译器在C文件上调用bpf2go工具：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running `go:generate` on the package rebuilds the eBPF program and regenerates
    the skeleton in a single step.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在该包上运行`go:generate`会重新构建eBPF程序并在单个步骤中重新生成骨架。
- en: Much like `bpftool gen skeleton`, which you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    `bpf2go` generates skeleton code for manipulating the eBPF objects, minimizing
    the user space code you need to write yourself (except it’s generating Go code
    rather than C). The output files also include the *.o* object files containing
    the bytecode.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中看到的`bpftool gen skeleton`一样，`bpf2go`生成了用于操作eBPF对象的骨架代码，最大程度地减少了用户空间代码的编写（除了生成Go代码而不是C代码）。输出文件还包括包含字节码的*.o*对象文件。
- en: 'In fact, `bpf2go` generates two versions of the bytecode *.o* files, for big-
    and little-endian architectures. There are also two correspondingly generated
    *.go* files, and the correct versions for the target platform get used at compile
    time. As an example, the auto-generated files in the [kprobe example from *cilium/ebpf*](https://oreil.ly/CgwVd)
    are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`bpf2go`生成了字节码*.o*文件的两个版本，用于大端和小端架构。还生成了两个相应的*.go*文件，并且在编译时使用了目标平台的正确版本。例如，[来自*cilium/ebpf*的kprobe示例](https://oreil.ly/CgwVd)中的自动生成文件是：
- en: The *bpf_bpfeb.o* and *bpf_bpfel.o* ELF files containing eBPF bytecode
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含eBPF字节码的*bpf_bpfeb.o*和*bpf_bpfel.o* ELF文件
- en: The *bpf_bpfeb.go* and *bpf_bpfel.go* files, which define Go structures and
    functions that correspond to the maps, programs, and links defined in that bytecode
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Go结构和函数的*bpf_bpfeb.go*和*bpf_bpfel.go*文件，这些结构和函数对应于该字节码中定义的映射、程序和链接
- en: 'You can relate the objects defined in the auto-generated Go code to the C code
    from which it was generated. Here are the objects defined in the C code for that
    kprobe example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将自动生成的Go代码中定义的对象与生成它的C代码相关联。以下是该kprobe示例的C代码中定义的对象：
- en: '[PRE7][PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7][PRE8]'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: typebpfMapsstruct{ `KprobeMap``*``ebpf``.``Map[PRE10]ebpf:"kprobe_execve"``
    ``}[PRE11]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: typebpfMapsstruct{ `KprobeMap``*``ebpf``.``Map[PRE10]ebpf:"kprobe_execve"``
    ``}[PRE11]
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: typebpfObjectsstruct{ `bpfPrograms` ``bpfMaps` ``}[PRE13]
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: typebpfObjectsstruct{ `bpfPrograms` ``bpfMaps` ``}[PRE13]
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: objs:=bpfObjects{}loadBpfObjects(&objs,nil)![1](assets/1.png)deferobjs.Close()kp,_:=link.Kprobe("sys_execve",objs.KprobeExecve,nil)![2](assets/2.png)deferkp.Close()ticker:=time.NewTicker(1*time.Second)![3](assets/3.png)deferticker.Stop()forrangeticker.C{varvalueuint64objs.KprobeMap.Lookup(mapKey,&value)![4](assets/4.png)log.Printf("%s
    called %d times\n",fn,value)}
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: objs:=bpfObjects{}loadBpfObjects(&objs,nil)![1](assets/1.png)deferobjs.Close()kp,_:=link.Kprobe("sys_execve",objs.KprobeExecve,nil)![2](assets/2.png)deferkp.Close()ticker:=time.NewTicker(1*time.Second)![3](assets/3.png)deferticker.Stop()forrangeticker.C{varvalueuint64objs.KprobeMap.Lookup(mapKey,&value)![4](assets/4.png)log.Printf("%s
    called %d times\n",fn,value)}
- en: '[PRE15][PRE16]  ``## Libbpfgo'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15][PRE16]  ``## Libbpfgo'
- en: The [*libbpfgo* project](https://oreil.ly/gvbXr) by Aqua Security implements
    a Go wrapper around *libbpf*’s C code, providing utilities for loading and attaching
    programs and using Go-native features like channels for receiving events. Because
    it’s built on *libbpf*, it supports CO-RE.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由Aqua Security实施的[*libbpfgo*项目](https://oreil.ly/gvbXr)在*libbpf*的C代码周围实现了一个Go包装器，提供了加载和附加程序的实用程序，并使用Go本地功能（如用于接收事件的通道）。因为它是建立在*libbpf*之上的，所以它支持CO-RE。
- en: 'Here’s an extract from the example from *libbpfgo*’s *README*, which gives
    a good high-level view of what to expect from this library:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*libbpfgo*的*README*中的示例摘录，它很好地概述了从该库中可以期望得到的高层视图：
- en: '[PRE17]cpp'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]cpp'
- en: '[![1](assets/1.png)](#code_id_10_11)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_11)'
- en: Read eBPF bytecode from an object file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象文件中读取eBPF字节码。
- en: '[![2](assets/2.png)](#code_id_10_12)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_12)'
- en: Load that bytecode into the kernel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将该字节码加载到内核中。
- en: '[![3](assets/3.png)](#code_id_10_13)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_13)'
- en: Manipulate an entry in an eBPF map.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 操作eBPF映射中的条目。
- en: '[![4](assets/4.png)](#code_id_10_14)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_14)'
- en: Go programmers will appreciate receiving data from a ring or perf buffer on
    a channel, which is a language feature designed to handle asynchronous events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序员会喜欢通过通道从环或perf缓冲区接收数据，这是一种处理异步事件的语言特性。
- en: This library was created for Aqua’s [Tracee](https://oreil.ly/A03zd) security
    project, and it’s also being used by other projects such as [Parca](https://oreil.ly/s8JP9)
    from Polar Signals, which provides eBPF-based CPU profiling. The only concern
    about this project’s approach is the CGo boundary between the *libbpf* C code
    and Go, which can cause performance and other issues.^([5](ch10.html#ch10fn5))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库是为Aqua的[Tracee](https://oreil.ly/A03zd)安全项目创建的，也被其他项目使用，比如[Polar Signals](https://oreil.ly/s8JP9)的[Parca](https://oreil.ly/s8JP9)，它提供基于eBPF的CPU性能分析。这个项目方法的唯一问题是*libbpf*
    C代码和Go之间的CGo边界，可能会导致性能和其他问题。^([5](ch10.html#ch10fn5))
- en: While Go has been the established language for lots of infrastructure coding
    for around a decade, there has more recently been a growing body of developers
    who prefer to use Rust.``  ``# Rust
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go语言在基础设施编码方面已经有十多年的历史，但最近有越来越多的开发人员更喜欢使用Rust。``  ``# Rust
- en: Rust is increasingly being used for building infrastructure tools. It allows
    for the low-level access of C, but with the added benefit of memory safety. Indeed,
    Linus Torvalds [confirmed in 2022](https://oreil.ly/7fINA) that the Linux kernel
    itself will start to incorporate Rust code, and the recent [6.1 release has some
    initial Rust support](https://oreil.ly/HrXy2).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Rust越来越多地被用于构建基础设施工具。它允许像C一样进行低级访问，但又具有内存安全的优势。事实上，Linus Torvalds在2022年[确认](https://oreil.ly/7fINA)，Linux内核本身将开始纳入Rust代码，最近的[6.1版本也有一些初步的Rust支持](https://oreil.ly/HrXy2)。
- en: As I discussed earlier in this chapter, Rust can be compiled to eBPF bytecode,
    meaning that (with the right library support) it’s possible to write both the
    user space and kernel code for eBPF utilities in Rust.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章前面讨论的，Rust可以编译为eBPF字节码，这意味着（在正确的库支持下）可以在Rust中编写eBPF实用程序的用户空间和内核代码。
- en: 'There are a few options for Rust eBPF development: *libbpf-rs*, *Redbpf*, and
    Aya.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Rust eBPF开发有几个选择：*libbpf-rs*、*Redbpf*和Aya。
- en: Libbpf-rs
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Libbpf-rs
- en: '[*Libbpf-rs*](https://oreil.ly/qBagk) is part of the *libbpf* project, and
    provides a Rust wrapper around the *libbpf* C code so that you can write the user
    space parts of eBPF code in Rust. As you can see from the project’s [examples](https://oreil.ly/6wpf8),
    the eBPF programs themselves are written in C.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Libbpf-rs*](https://oreil.ly/qBagk)是*libbpf*项目的一部分，它提供了*libbpf* C代码的Rust包装，以便您可以用Rust编写eBPF代码的用户空间部分。从该项目的[示例](https://oreil.ly/6wpf8)中可以看出，eBPF程序本身是用C编写的。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are further examples in Rust in the [*libbpf-bootstrap*](https://oreil.ly/ter6c)
    project, designed to help you get off the ground if you want to try building your
    own code using this crate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*libbpf-bootstrap*](https://oreil.ly/ter6c)项目中还有更多的Rust示例，旨在帮助您开始构建自己的代码。
- en: This crate is helpful for incorporating eBPF programs into a Rust-based project,
    but it doesn’t fulfill the desire that many people have to write the kernel-side
    code in Rust as well. Let’s look at some other projects that enable that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个crate有助于将eBPF程序纳入基于Rust的项目，但它并不能满足许多人希望在内核端用Rust编写代码的愿望。让我们看看其他一些可以实现这一点的项目。
- en: Redbpf
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redbpf
- en: '[*Redbpf*](https://oreil.ly/AtJod) is a set of Rust crates that interface with
    *libbpf*, developed as part of [foniod](https://oreil.ly/dwGNK), an eBPF-based
    security monitoring agent.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Redbpf*](https://oreil.ly/AtJod)是一组与*libbpf*接口的Rust crate，作为[eBPF](https://oreil.ly/dwGNK)安全监控代理的一部分开发。'
- en: '*Redbpf* predates Rust’s ability to compile to eBPF bytecode, so it uses a
    [multistep compilation process](https://oreil.ly/DuHxE) that involves compiling
    from Rust to LLVM bitcode and then using the LLVM toolchain to generate eBPF bytecode
    in ELF format. *Redbpf* supports a range of program types including tracepoints,
    kprobes and uprobes, XDP, TC, and some socket events.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redbpf*早于Rust编译为eBPF字节码的能力，因此它使用了[多步编译过程](https://oreil.ly/DuHxE)，包括从Rust编译到LLVM位码，然后使用LLVM工具链生成ELF格式的eBPF字节码。*Redbpf*支持一系列程序类型，包括tracepoints、kprobes和uprobes、XDP、TC以及一些套接字事件。'
- en: As the Rust compiler rustc gained the ability to generate eBPF bytecode directly,
    this was leveraged by a project called Aya. At the time of this writing, Aya is
    considered “emerging” according to the [community site at ebpf.io](https://oreil.ly/WynV6),
    while *Redbpf* is listed as a major project, but my personal perspective is that
    momentum seems to be moving toward Aya.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Rust编译器rustc直接获得生成eBPF字节码的能力，这被一个名为Aya的项目利用。在撰写本文时，Aya被认为是“新兴”的，而*Redbpf*被列为一个重要项目，但我个人的观点是，势头似乎正在向Aya发展。
- en: Aya
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Aya
- en: '[Aya](https://aya-rs.dev/book) is built in Rust directly to the syscall level,
    so it doesn’t depend on *libbpf* (or indeed on BCC or the LLVM toolchain). But
    it does support the BTF format, the same relocations that *libbpf* does (as described
    in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), so it’s providing the
    same CO-RE abilities to compile once and run on other kernels. At the time of
    this writing, it supports a wider range of eBPF program types than *Redbpf*, including
    tracing/perf-related events, XDP and TC, cgroups, and LSM attachments.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Aya](https://aya-rs.dev/book)直接在Rust中构建到系统调用级别，因此它不依赖于*libbpf*（或者BCC或LLVM工具链）。但它支持BTF格式，与*libbpf*相同的重定位（如[第5章](ch05.html#co_recomma_btfcomma_and_libbpf)中所述），因此它提供了相同的CO-RE能力，可以一次编译，然后在其他内核上运行。在撰写本文时，它支持比*Redbpf*更广泛的eBPF程序类型，包括跟踪/性能相关事件、XDP和TC、cgroups以及LSM附件。'
- en: As I mentioned, the Rust compiler also supports [compiling to eBPF bytecode](https://oreil.ly/a5q7M),
    so this language can be used for both kernel and user space eBPF programming.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，Rust编译器也支持[编译为eBPF字节码](https://oreil.ly/a5q7M)，因此这种语言可以用于内核和用户空间的eBPF编程。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to write both the kernel side and the user space side natively in
    Rust without the intermediate dependency on LLVM has attracted Rust programmers
    to this option. There’s an interesting [discussion on GitHub](https://oreil.ly/nls4l)
    about why the developers of the [lockc project](https://oreil.ly/_-L6z) (an eBPF-based
    project that enhances the security of container workloads using LSM hooks) decided
    to port their project from *libbpf-rs* to Aya.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中原生编写内核端和用户空间端，而无需中间依赖LLVM的能力吸引了Rust程序员选择这个选项。关于为什么[lockc项目](https://oreil.ly/_-L6z)的开发人员决定将其项目从*libbpf-rs*移植到Aya的有趣的[GitHub讨论](https://oreil.ly/nls4l)。
- en: The project includes [aya-tool](https://oreil.ly/Kd0nf), a utility for generating
    Rust structure definitions that match kernel data structures so that you don’t
    have to write them yourself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包括[aya-tool](https://oreil.ly/Kd0nf)，这是一个实用程序，用于生成与内核数据结构匹配的Rust结构定义，这样您就不必自己编写它们。
- en: The Aya project strongly emphasizes developer experience and makes it easy for
    newcomers to get started. With that in mind, the [“Aya book”](https://aya-rs.dev/book)
    is a very readable introduction with some good example code, annotated with helpful
    explanations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Aya项目非常强调开发者体验，并且让新手很容易上手。考虑到这一点，[“Aya书”](https://aya-rs.dev/book)是一个非常易读的介绍，其中包含一些很好的示例代码，并附有有用的解释。
- en: 'To give you a brief idea of what eBPF code looks like in Rust, here’s an extract
    from Aya’s basic XDP example that permits all traffic:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您对Rust中的eBPF代码是什么样子有一个简要的了解，这里是Aya基本XDP示例的一部分，允许所有流量通过：
- en: '[PRE18]cpp'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]cpp'
- en: '[![1](assets/1.png)](#code_id_10_15)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_15)'
- en: This line is what defines the section name, equivalent to `SEC("xdp/myapp")`
    in C.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行定义了部分名称，相当于C语言中的`SEC("xdp/myapp")`。
- en: '[![2](assets/2.png)](#code_id_10_16)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_16)'
- en: The eBPF program called `myapp` calls the function `try_myapp` to process a
    network packet received at XDP.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`myapp`的eBPF程序调用`try_myapp`函数来处理在XDP接收到的网络数据包。
- en: '[![3](assets/3.png)](#code_id_10_17)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_17)'
- en: The `try_myapp` function logs the fact that a packet was received and always
    returns the `XDP_PASS` value that tells the kernel to carry on processing the
    packet as usual.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_myapp`函数记录了接收到数据包的事实，并始终返回`XDP_PASS`值，告诉内核按照通常方式处理数据包。'
- en: Just as we’ve seen in C-based examples throughout this book, the eBPF program
    gets compiled to an ELF object file. The difference is that Aya uses the Rust
    compiler instead of Clang to create that file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本书中看到的基于C的示例一样，eBPF程序被编译为ELF对象文件。不同之处在于Aya使用Rust编译器而不是Clang来创建该文件。
- en: 'Aya also generates code for the user space activities of loading the eBPF program
    into the kernel and attaching it to an event. Here are a few key lines from the
    user space side of that same basic example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Aya还为用户空间加载eBPF程序到内核并将其附加到事件的活动生成代码。以下是同一个基本示例的用户空间部分的一些关键行：
- en: '[PRE19]cpp'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]cpp'
- en: '[![1](assets/1.png)](#code_id_10_19)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#code_id_10_19)'
- en: Read the eBPF bytecode from the ELF object file produced by the compiler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译器生成的ELF对象文件中读取eBPF字节码。
- en: '[![2](assets/2.png)](#code_id_10_20)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#code_id_10_20)'
- en: Find the program called `myapp` in that bytecode.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在该字节码中找到名为`myapp`的程序。
- en: '[![3](assets/3.png)](#code_id_10_21)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#code_id_10_21)'
- en: Load it into the kernel.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将其加载到内核中。
- en: '[![4](assets/4.png)](#code_id_10_22)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#code_id_10_22)'
- en: Attach it to the XDP event on a specified network interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将其附加到指定网络接口上的XDP事件。
- en: If you’re a Rust programmer, I highly recommend you explore the [additional
    examples](https://oreil.ly/bp_Hq) in the “Aya book” in more detail. There’s also
    a nice [blog post from Kong](https://oreil.ly/mUVIk) that walks through writing
    an XDP load balancer using Aya.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Rust程序员，我强烈建议您更详细地探索“Aya书”中的[其他示例](https://oreil.ly/bp_Hq)。Kong的[博客文章](https://oreil.ly/mUVIk)也很不错，其中详细介绍了使用Aya编写XDP负载均衡器。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Aya maintainers Dave Tucker and Alessandro Decina joined me for [episode 25
    of the “eBPF and Cilium Office Hours” livestream](https://oreil.ly/U7bRu) where
    they demonstrated and gave an introduction to eBPF programming with Aya.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Aya的维护者Dave Tucker和Alessandro Decina在[“eBPF和Cilium办公时间”的第25集直播节目](https://oreil.ly/U7bRu)中与我一起，他们演示并介绍了使用Aya进行eBPF编程。
- en: Rust-bcc
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust-bcc
- en: '[Rust-bcc](https://oreil.ly/prP_K) provides Rust bindings that mimic the BCC
    project’s Python bindings, along with some Rust implementations of some of the
    BCC set of tracing [tools](https://oreil.ly/Dd2nO).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rust-bcc](https://oreil.ly/prP_K)提供了模仿BCC项目的Python绑定的Rust绑定，以及一些BCC跟踪[工具](https://oreil.ly/Dd2nO)的一些Rust实现。'
- en: Testing BPF Programs
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试BPF程序
- en: There’s a `bpf()` command, [`BPF_PROG_RUN`](https://oreil.ly/Y2xPC), that allows
    for running an eBPF program from user space for test purposes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`bpf()`命令，[`BPF_PROG_RUN`](https://oreil.ly/Y2xPC)，允许从用户空间运行eBPF程序进行测试。
- en: '`BPF_PROG_RUN` (currently) works only with a subset of BPF program types that
    are mostly networking related.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`BPF_PROG_RUN`（目前）仅适用于大多数与网络相关的BPF程序类型的子集。'
- en: 'You can also get information about eBPF program performance with some built-in
    statistics information. Run the following command to enable it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过一些内置的统计信息获取有关eBPF程序性能的信息。运行以下命令以启用它：
- en: '[PRE20]cpp'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]cpp'
- en: 'This will show additional information in `bpftool`’s output about programs,
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`bpftool`的输出中显示有关程序的其他信息，如下所示：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The additional statistics are shown in bold, and here they show that the program
    has run four times, taking about 300 microseconds in total.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的统计信息以粗体显示，这里显示该程序已运行四次，总共耗时约300微秒。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Learn more from Quentin Monnet’s FOSDEM 2020 talk titled [“Tools and mechanisms
    to debug BPF programs.”](https://oreil.ly/I5Jhd)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从Quentin Monnet的FOSDEM 2020演讲中了解更多，演讲主题是[“调试BPF程序的工具和机制”](https://oreil.ly/I5Jhd)。
- en: Multiple eBPF Programs
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个eBPF程序
- en: 'An eBPF program is a function attached to an event in the kernel. Many applications
    need to track more than one event to achieve their goals. A simple example of
    this is opensnoop.^([6](ch10.html#ch10fn6)) I covered the `bpftrace` version of
    this early in this chapter, and you saw that it attaches BPF programs to four
    different syscall tracepoints:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF程序是附加到内核中事件的函数。许多应用程序需要跟踪多个事件以实现其目标。其中一个简单的例子是opensnoop。^([6](ch10.html#ch10fn6))我在本章的早期部分介绍了`bpftrace`版本，您看到它将BPF程序附加到四个不同的系统调用跟踪点：
- en: '`syscall_enter_open`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_enter_open`'
- en: '`syscall_exit_open`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_exit_open`'
- en: '`syscall_enter_openat`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_enter_openat`'
- en: '`syscall_exit_openat`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall_exit_openat`'
- en: These are the entry and exit points to the kernel’s handling of the `open()`
    and `openat()` system calls. These two system calls can be used for opening files,
    and the opensnoop tool tracks both of them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是内核处理`open()`和`openat()`系统调用的入口和出口点。这两个系统调用可用于打开文件，而opensnoop工具跟踪这两个系统调用。
- en: But why does it need to track both entry and exit for these system calls? The
    entry points are used because that’s when the system call arguments are available,
    and these include the filename and any flags being passed to the `open[at]` syscall.
    But at that stage it’s too soon to know whether the file will be opened successfully
    or not. That explains why it’s necessary to have eBPF programs attached to the
    exit points too.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么需要跟踪这些系统调用的入口和出口？入口点用于系统调用参数可用的时候，这些参数包括文件名和传递给`open[at]`系统调用的任何标志。但在那个阶段，还不知道文件是否会成功打开。这就解释了为什么有必要在出口点附加eBPF程序。
- en: If you look at the [*libbpf-tools* version of opensnoop](https://oreil.ly/IOty_),
    you’ll see there’s just one user space program, and it loads all four eBPF programs
    into the kernel and attaches them to their events. The eBPF programs themselves
    are essentially independent, but they use eBPF maps to coordinate among themselves.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看[*libbpf-tools*版本的opensnoop](https://oreil.ly/IOty_)，您会发现只有一个用户空间程序，并且它将所有四个eBPF程序加载到内核中并将它们附加到它们的事件上。eBPF程序本身基本上是独立的，但它们使用eBPF映射来相互协调。
- en: A complex application might even need to add and remove eBPF programs dynamically
    throughout a long period of time. There may not even be a fixed number of eBPF
    programs for any given application. For example, Cilium attaches eBPF programs
    to each virtual networking interface, and in a Kubernetes environment these interfaces
    come and go depending on how many pods are running.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的应用程序甚至可能需要在很长一段时间内动态添加和删除eBPF程序。对于任何给定的应用程序，甚至可能没有固定数量的eBPF程序。例如，Cilium将eBPF程序附加到每个虚拟网络接口上，在Kubernetes环境中，这些接口根据运行的pod数量而来去。
- en: Most of the libraries in this chapter handle this multiplicity of eBPF programs
    automatically. For example, *libbpf* and *ebpf-go* generate skeleton code that
    will load *all* the programs and maps from the bytecode in an object file or buffer
    in one function call. They also generate finer-granularity functions so that you
    can manipulate programs and maps individually.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数库都会自动处理这种多样性的eBPF程序。例如，*libbpf*和*ebpf-go*会生成骨架代码，该代码将从对象文件或缓冲区中的字节码加载*所有*程序和映射，并且它们还会生成更细粒度的函数，以便您可以单独操作程序和映射。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The vast majority of people who use eBPF-based tooling won’t need to write eBPF
    code themselves, but if you do find yourself wanting to implement something yourself,
    you have a lot of options. This is a changing field, so it’s very possible that
    by the time you read this, new language libraries and frameworks might exist,
    or consensus may have gathered around some of the libraries I’ve highlighted in
    this chapter. You’ll find an up-to-date list of the major language projects around
    eBPF on the [Infrastructure page of ebpf.io’s list of significant projects](https://ebpf.io/infrastructure).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用基于eBPF的工具的人不需要自己编写eBPF代码，但如果您发现自己想要自己实现一些东西，您有很多选择。这是一个不断变化的领域，所以很可能在您阅读本文时，可能已经存在新的语言库和框架，或者已经就本章中我强调的一些库达成共识。您可以在[ebpf.io的重要项目列表的基础设施页面](https://ebpf.io/infrastructure)上找到关于eBPF的主要语言项目的最新列表。
- en: For quickly collecting trace information, `bpftrace` can be a very valuable
    option.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快速收集跟踪信息，`bpftrace`可能是一个非常有价值的选择。
- en: For more flexibility and control, BCC is a fast way to build an eBPF tool if
    you’re comfortable with Python, provided that you don’t care about the compilation
    step that takes place at runtime.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更灵活和可控的操作，如果您熟悉Python，BCC是构建eBPF工具的快速方式，前提是您不在乎运行时发生的编译步骤。
- en: If you’re writing eBPF code to be widely distributed and portable across different
    kernel versions, you’ll probably want to take advantage of CO-RE. The user space
    frameworks that support CO-RE at time of this writing are *libbpf* for C, *cilium/ebpf*
    and *libbpfgo* for Go, and Aya for Rust.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望编写广泛分发和跨不同内核版本可移植的eBPF代码，您可能会想利用CO-RE。目前支持CO-RE的用户空间框架有C的*libbpf*，Go的*cilium/ebpf*和*libbpfgo*，以及Rust的Aya。
- en: For further advice, I highly recommend joining the [eBPF Slack](http://ebpf.io/slack)
    and discussing your questions there. You’ll likely find the maintainers of many
    of these language libraries in that community.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进一步的建议，我强烈建议加入[eBPF Slack](http://ebpf.io/slack)并在那里讨论您的问题。您可能会在该社区中找到许多这些语言库的维护者。
- en: Exercises
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'If you’d like to try one or more of the libraries discussed in this chapter,
    “Hello World” is always a good place to start:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试本章讨论的一个或多个库，“Hello World”总是一个很好的开始：
- en: Using one or more libraries of your choosing, write an example “Hello World”
    program that outputs a simple trace message.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的一个或多个库，编写一个输出简单跟踪消息的“Hello World”示例程序。
- en: Use `llvm-objdump` to compare the bytecode produced with the “Hello World” example
    from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program). You’ll find lots of similarities!
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`llvm-objdump`比较从[第3章](ch03.html#anatomy_of_an_ebpf_program)的“Hello World”示例生成的字节码。您会发现很多相似之处！
- en: As you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    you can use `strace -e bpf` to see when `bpf()` system calls are made. Try that
    on your “Hello World” program to see if it’s behaving as you expect.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你在[第4章](ch04.html#the_bpfleft_parenthesisright_parenthesi)中看到的，你可以使用`strace
    -e bpf`来查看何时进行了`bpf()`系统调用。在你的“Hello World”程序上尝试一下，看看它是否表现如你所期望的那样。
- en: ^([1](ch10.html#ch10fn1-marker)) Being attached to syscall entry points means
    this script has the same Time Of Check To Time Of Use (TOCTOU) vulnerability discussed
    in the previous chapter. That doesn’t stop it from being a useful tool; it’s just
    that you shouldn’t rely on it as your only line of defense for security purposes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#ch10fn1-marker)) 附加到系统调用入口意味着这个脚本具有与前一章讨论的相同的TOCTOU（Time Of
    Check To Time Of Use）漏洞。这并不能阻止它成为一个有用的工具；只是你不应该仅依赖它作为安全目的的唯一防线。
- en: ^([2](ch10.html#ch10fn2-marker)) For an example of this, check out Cloudflare’s
    blog post [“eBPF, Sockets, Hop Distance and manually writing eBPF assembly”](https://oreil.ly/2GjuK).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#ch10fn2-marker)) 例如，可以查看Cloudflare的博文“eBPF，Sockets，Hop Distance
    and manually writing eBPF assembly”。
- en: ^([3](ch10.html#ch10fn3-marker)) See, for example, Brendan Gregg’s [observation](https://oreil.ly/fz_dQ)
    that the *libbpf*-based version of opensnoop required around 9 MB compared with
    80 MB for the Python-based version.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#ch10fn3-marker)) 例如，Brendan Gregg的[观察](https://oreil.ly/fz_dQ)指出，基于*libbpf*的opensnoop版本需要大约9MB，而基于Python的版本需要80MB。
- en: ^([4](ch10.html#ch10fn4-marker)) Watch me working through some of the XDP Tutorial
    examples in [episode 13 of the eBPF and Cilium Office Hours” livestream](https://oreil.ly/9SaKn).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#ch10fn4-marker)) 在“eBPF和Cilium办公时间”直播的第13集中，看我如何通过一些XDP教程示例进行演示。
- en: ^([5](ch10.html#ch10fn5-marker)) Dave Cheney’s 2016 post “[cgo is not Go](https://oreil.ly/mxThs)”
    remains a good overview of concerns related to the CGo boundary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#ch10fn5-marker)) Dave Cheney在2016年的帖子“cgo is not Go”仍然是对与CGo边界相关的问题的很好的概述。
- en: ^([6](ch10.html#ch10fn6-marker)) As well as the `bpftrace` version of this tool,
    there are equivalents in BCC and in *libbpf-tools*. They all do very much the
    same thing, generating a line of trace whenever a process opens a file. There’s
    a walkthrough of the eBPF code for BCC’s version of opensnoop in my report [“What
    Is eBPF?”](https://www.oreilly.com/library/view/what-is-ebpf/9781492097266).``
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch10.html#ch10fn6-marker)) 除了这个工具的`bpftrace`版本外，在BCC和*libbpf-tools*中也有相应的工具。它们都做着几乎相同的事情，每当一个进程打开一个文件时生成一行跟踪。在我的报告“什么是eBPF？”中有BCC版本opensnoop的eBPF代码的详细说明。

- en: Chapter 10\. eBPF Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book so far, you’ve learned a lot about eBPF and seen many examples
    of how it’s used for a variety of applications. But what if you want to implement
    your own ideas based on eBPF? This chapter discusses your options when it comes
    to writing your own eBPF code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know from reading this book, eBPF programming consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing eBPF programs that run in the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the user space code that manages and interacts with eBPF programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the libraries and languages I’ll discuss in this chapter require you
    as a programmer to handle both parts, with an awareness of what is being handled
    where. But `bpftrace`, perhaps the simplest eBPF programming language, masks this
    distinction from the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Bpftrace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described on the project’s *README* page, “`bpftrace` is a high-level tracing
    language for Linux eBPF … inspired by awk and C, and predecessor tracers such
    as DTrace and SystemTap.”
  prefs: []
  type: TYPE_NORMAL
- en: The [`bpftrace`](https://oreil.ly/BZNZO) command-line tool converts programs
    written in this high-level language into eBPF kernel code and provides some output
    formatting for the results within the terminal. As a user, you don’t really need
    to think about the kernel–user space split.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find several examples of useful one-liners in the project documentation,
    including a nice [tutorial](https://oreil.ly/Ah2QB) that takes you from writing
    a simple “Hello World” script up to writing more sophisticated scripts that can
    trace out data read from within kernel data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Get a feel for the range of capabilities that `bpftrace` provides from Brendan
    Gregg’s [`bpftrace` cheat sheet](https://oreil.ly/VBwLm). Or, for in-depth coverage
    of both `bpftrace` and BCC, see his book [*BPF Performance Tools*](https://oreil.ly/kjc95).
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, `bpftrace` can attach to tracing (also known as perf-related)
    events, including kprobes, uprobes, and tracepoints. For example, you can list
    the available tracepoints and kprobes on a machine with the `-l` option, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example finds all the available attachment points that contain “execve.”
    From this output you can see that it’s possible to attach to a kprobe called `do_execve`.
    Here’s a `bpftrace` one-line script that attaches to that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `{ @[comm] = count(); }` part is the script attached to that event. This
    example keeps track of the number of times the event was triggered by different
    executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scripts for `bpftrace` can coordinate multiple eBPF programs attached to different
    events. For example, consider the [*opensnoop.bt* script](https://oreil.ly/3HWZ2)
    that reports on files being opened. Here is an extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This script defines two different eBPF programs, each attached to two different
    kernel tracepoints, at the entry to and exit from the `open()` and `openat()`
    syscalls.^([1](ch10.html#ch10fn1)) Both of these syscalls are used to open files
    and take a filename as an input argument. The program triggered by either flavor
    of syscall entry caches that filename, storing it in a map where the key is the
    current thread ID. When the exit tracepoint is hit, the cached filename is retrieved
    from this map by the `/@filename[tid]/` line in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script generates output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I’ve just told you there are four eBPF programs attached to tracepoints, so
    why does this output say there are six probes? The answer is that there are two
    “special probes” for the `BEGIN` and `END` clauses that the full version of this
    program includes to initialize and clean up the script (very similar to the awk
    language). I’ve omitted those clauses here for brevity, but you can find them
    in the [source code in GitHub](https://oreil.ly/X8wgW).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using `bpftrace`, you don’t need to know about the underlying programs
    and maps, but for those of you who have read earlier chapters of this book, those
    concepts should be familiar to you by now. If you’re interested to see the programs
    and maps that are loaded in the kernel while a `bpftrace` program is running,
    you can easily do this with `bpftool` (just as you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program)).
    Here’s the output I got while running *opensnoop.bt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see the four tracepoint programs, plus the hash map that’s used
    for caching the filenames and the `perf_event_array` that is being used to pass
    output data from kernel to user space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `bpftrace` utility is built on top of BCC, which you met elsewhere in this
    book and which I’ll cover later in this chapter. `bpftrace` scripts get converted
    into BCC programs, which are then compiled at runtime using the LLVM/Clang toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: If you want command-line tools for eBPF-based performance measurement, you may
    well find that your needs are met using [`bpftrace`](https://oreil.ly/u5FrJ).
    But although `bpftrace` can be a powerful tool for using eBPF for tracing, it
    doesn’t open up the full range of possibilities that eBPF enables.
  prefs: []
  type: TYPE_NORMAL
- en: To unlock the full potential of eBPF, you’ll need to directly write eBPF programs
    yourself for the kernel and also handle the user space part. These two aspects
    can, and often are, written in entirely different languages. Let’s start with
    the choices for eBPF code that runs in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Language Choices for eBPF in the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: eBPF programs can be written directly in eBPF bytecode,^([2](ch10.html#ch10fn2))
    but in practice, most are compiled to bytecode from either C or Rust. These languages
    have compilers that support eBPF bytecode as a target output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: eBPF bytecode isn’t a suitable target for all compiled languages. If the language
    involves a runtime component (like Go, or Java’s virtual machine), it’s likely
    to be incompatible with eBPF’s verifier. For example, it’s hard to imagine how
    memory garbage collection could work hand in hand with the verifier’s checks on
    safe use of memory. Similarly, eBPF programs are required to be single threaded,
    so any concurrency features in a language couldn’t be used.
  prefs: []
  type: TYPE_NORMAL
- en: Although not really eBPF, there is an interesting project called [XDPLua](https://oreil.ly/7_3Fx)
    that proposes writing XDP programs in Lua scripts that run directly within the
    kernel. However, the initial research in this project suggested that eBPF would
    likely be more performant, and as eBPF becomes more powerful with each kernel
    release (e.g., now being able to implement loops), it’s not clear that there is
    much advantage other than the personal preference that some people might have
    to write code in Lua scripts.
  prefs: []
  type: TYPE_NORMAL
- en: I would hazard a guess that most people who choose to write eBPF kernel code
    in Rust would also opt for the same language for the user space code, since shared
    data structures wouldn’t need to be rewritten. It’s not obligatory, though—you
    can mix and match eBPF code with whatever user space language you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Those who choose to write the kernel-side code in C also have the option to
    write user space code in C (you’ve seen plenty of examples of that in this book
    already). But C is a pretty low-level language that requires programmers to handle
    lots of details for themselves, notably, memory management. While some people
    are comfortable doing this, many people would prefer to write the user space code
    in another, higher-level language. Whatever your preferred language, you’d like
    a library that provides eBPF support so that you don’t have to write directly
    to the system call interface you saw in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    In the rest of this chapter we’ll discuss some of the most popular options for
    eBPF libraries in a variety of languages.
  prefs: []
  type: TYPE_NORMAL
- en: BCC Python/Lua/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 2](ch02.html#ebpfapostrophes_quotation_markhello_wor), the
    first “Hello World” example I gave you was a Python program written using the
    BCC library. This project includes plenty of useful performance measurement tools
    implemented using this same library (as well as newer implementations based on
    *libbpf* that I’ll come to momentarily).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the [documentation](https://oreil.ly/Elggv) that describes how
    to use the provided BCC tools to measure performance, BCC also includes a [reference
    guide](https://oreil.ly/WgeJA) and a [Python programming tutorial](https://oreil.ly/hR3xr)
    to help you develop your own eBPF tools in this framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf) included a discussion
    of BCC’s approach to portability, which is to compile the eBPF code at runtime
    to ensure that it’s compatible with the target machine’s kernel data structures.
    In BCC, you define the kernel-side eBPF program code as a string (or the contents
    of a file that BCC reads into a string). This string gets passed to Clang for
    compilation, but before that happens, BCC does some preprocessing on the string.
    This enables it to provide handy shortcuts for the programmer, some of which you’ve
    seen already in this book. For example, here are some relevant lines from the
    example code in *chapter2/hello_map.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_10_1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a Python program, which will run in user space.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_10_2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `program` string holds the eBPF program to be compiled and then loaded into
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_10_3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_RINGBUF_OUTPUT` is a BCC macro that defines a ring buffer called `output`.
    This is part of the `program` string, so it’s natural to assume it’s defining
    the buffer from the kernel’s perspective. Hold that thought until we get to callout
    6.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_10_4)'
  prefs: []
  type: TYPE_NORMAL
- en: This line looks like a `ringbuf_output()` method on an object called `object`.
    But wait a minute—methods on objects aren’t even part of the C language! BCC is
    doing some heavy lifting here, [expanding methods](https://oreil.ly/vLVth) like
    these into underlying BPF helper functions, `bpf_ringbuf_output()` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#code_id_10_5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the program string gets rewritten into the BPF C code that Clang
    can compile. This line also loads the resultant program into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#code_id_10_6)'
  prefs: []
  type: TYPE_NORMAL
- en: There is no other place in the code that defines the ring buffer called `output`,
    and yet it’s accessible from the Python user space code here. BCC does double
    duty when it preprocesses the line in callout 3, as it defines the ring buffer
    for both the user space and kernel parts.
  prefs: []
  type: TYPE_NORMAL
- en: As this example shows, BCC essentially provides its own C-like language for
    BPF programming. It makes life easy for the programmer, handling things like shared
    structure definitions for both kernel and user space and providing convenient
    shortcuts to wrap around BPF helper functions. This means BCC is an accessible
    way to get into eBPF programming if you’re new to the field, especially if you’re
    already comfortable with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’d like to explore BCC programming, this [tutorial aimed at Python programmers](https://oreil.ly/0pHKY)
    is a great way to walk through many more of the features and capabilities of BCC
    than there is space for in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation doesn’t make it terribly clear, but as well as supporting
    Python as the language for the user space part of eBPF tools, BCC enables writing
    tools in Lua and C++. There are *lua* and *cpp* directories within the supplied
    [examples](https://oreil.ly/PP0cL) that you can base your own code on, should
    you be keen to try this approach.
  prefs: []
  type: TYPE_NORMAL
- en: BCC may be convenient for the programmer, but because of the inefficiencies
    of distributing a compiler toolchain alongside your utility (discussed in more
    depth in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), if you’re looking
    to write production-quality tools that you intend to distribute, I recommend considering
    some of the other libraries discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: C and Libbpf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen lots of examples in this book of eBPF programs written in C, using
    the LLVM toolchain to compile into eBPF bytecode. You’ve also seen that extensions
    were added to support BTF and CO-RE. Many C programmers will also be familiar
    with the other major C compiler, GCC, and will be happy to hear that [GCC from
    version 10](https://oreil.ly/XAzxP) also supports compiling to eBPF as a target;
    however, there are still some gaps compared with the functionality provided in
    LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), CO-RE and
    *libbpf* enabled an approach to portable eBPF programming that doesn’t require
    shipping a compiler toolchain alongside every eBPF tool. The BCC project took
    advantage of this and, in addition to the original set of BCC performance tracing
    tools, it now has versions of these tools rewritten to take advantage of *libbpf*.
    The general consensus is that the versions of the BCC tools that have been rewritten
    based on *libbpf* are the better option to use, since they have a significantly
    lower memory footprint^([3](ch10.html#ch10fn3)) and don’t involve a start-up delay
    while the compilation step takes place.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comfortable with programming in C, using *libbpf* can make a lot of
    sense. You’ve seen lots of examples of this already in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To write your own *libbpf* programs in C, the best place to start (now that
    you have read this book!) is [*libbpf-bootstrap*](https://oreil.ly/4mx81). Read
    Andrii Nakryiko’s [blog post about it](https://oreil.ly/-OW8v) as a good introduction
    to the motivations behind this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also a library called [*libxdp*](https://oreil.ly/374mL) that builds
    on *libbpf* to allow for easier development and management of XDP programs. This
    is part of xdp-tools, which also holds one of my favorite learning resources for
    eBPF programming: the [XDP Tutorial](https://oreil.ly/E6dvl).^([4](ch10.html#ch10fn4))'
  prefs: []
  type: TYPE_NORMAL
- en: But C is quite a challenging, low-level language. C programmers have to take
    responsibility for things like memory management and buffer handling, and it’s
    very easy to end up writing code with security vulnerabilities, not to mention
    crashes due to mishandling pointers. The eBPF verifier helps out on the kernel
    side, but there is no equivalent protection for your user space code.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that there are libraries for other programming languages that
    interface to *libbpf*, or provide similar relocation functionality to allow for
    portable eBPF programs. Here are a few of the most popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go language has been widely adopted for infrastructure and cloud native
    tooling, so it’s natural that there should be options for writing eBPF code in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[This article by Michael Kashin](https://oreil.ly/s9umt) provides another perspective
    comparing different eBPF libraries for Go.'
  prefs: []
  type: TYPE_NORMAL
- en: Gobpf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Possibly the first serious Golang implementation was the [gobpf](https://oreil.ly/pC0dF)
    project that sits alongside BCC as part of Iovisor. However, it hasn’t been actively
    maintained for a while, and as I write this, there’s some [discussion of deprecating
    it](https://oreil.ly/MnE79), so bear this in mind when making your library choice.
  prefs: []
  type: TYPE_NORMAL
- en: Ebpf-go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [eBPF Go library included as part of the Cilium project](https://oreil.ly/BnGyl)
    is widely used (I found around 10,000 references on GitHub, and the project has
    close to 4,000 stars). It provides convenient functions for managing and loading
    eBPF programs and maps, including CO-RE support, all implemented purely in Go.
  prefs: []
  type: TYPE_NORMAL
- en: With this library you have the option to compile your eBPF programs to bytecode
    and embed that bytecode into Go source code, using a supplied tool called [bpf2go](https://oreil.ly/-kDbH).
    You need the LLVM/Clang compiler to do this generation as part of the build step.
    Once the Go code is compiled, you have a single Go binary that you can distribute
    that includes the eBPF bytecode and is portable to different kernels, without
    any dependencies other than the Linux kernel itself.
  prefs: []
  type: TYPE_NORMAL
- en: The *cilium/ebpf* library also supports loading and managing eBPF programs built
    as standalone ELF files (like the **.bpf.o* examples you have seen in this book).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, the *cilium/ebpf* library supports the perf events
    for tracing, including the relatively recent fentry events, as well as an extensive
    set of network program types like XDP and cgroup socket attachments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project’s [*examples* directory under *cilium/ebpf*](https://oreil.ly/Vuf9d),
    you’ll see that the C code for in-kernel programs sits in the same directories
    as the corresponding user space code in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: The C files start with `// +build ignore`, which tells the Go compiler to ignore
    them. At the time of this writing there is an [update in progress](https://oreil.ly/ymuyn)
    to change to the newer `//go:build` style of build tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user space files include a line like the following, which tells the Go
    compiler to invoke the bpf2go tool on the C file(s):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running `go:generate` on the package rebuilds the eBPF program and regenerates
    the skeleton in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Much like `bpftool gen skeleton`, which you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf),
    `bpf2go` generates skeleton code for manipulating the eBPF objects, minimizing
    the user space code you need to write yourself (except it’s generating Go code
    rather than C). The output files also include the *.o* object files containing
    the bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `bpf2go` generates two versions of the bytecode *.o* files, for big-
    and little-endian architectures. There are also two correspondingly generated
    *.go* files, and the correct versions for the target platform get used at compile
    time. As an example, the auto-generated files in the [kprobe example from *cilium/ebpf*](https://oreil.ly/CgwVd)
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The *bpf_bpfeb.o* and *bpf_bpfel.o* ELF files containing eBPF bytecode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *bpf_bpfeb.go* and *bpf_bpfel.go* files, which define Go structures and
    functions that correspond to the maps, programs, and links defined in that bytecode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can relate the objects defined in the auto-generated Go code to the C code
    from which it was generated. Here are the objects defined in the C code for that
    kprobe example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7][PRE8]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: typebpfMapsstruct{ `KprobeMap``*``ebpf``.``Map[PRE10]ebpf:"kprobe_execve"``
    ``}[PRE11]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: typebpfObjectsstruct{ `bpfPrograms` ``bpfMaps` ``}[PRE13]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: objs:=bpfObjects{}loadBpfObjects(&objs,nil)![1](assets/1.png)deferobjs.Close()kp,_:=link.Kprobe("sys_execve",objs.KprobeExecve,nil)![2](assets/2.png)deferkp.Close()ticker:=time.NewTicker(1*time.Second)![3](assets/3.png)deferticker.Stop()forrangeticker.C{varvalueuint64objs.KprobeMap.Lookup(mapKey,&value)![4](assets/4.png)log.Printf("%s
    called %d times\n",fn,value)}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15][PRE16]  ``## Libbpfgo'
  prefs: []
  type: TYPE_NORMAL
- en: The [*libbpfgo* project](https://oreil.ly/gvbXr) by Aqua Security implements
    a Go wrapper around *libbpf*’s C code, providing utilities for loading and attaching
    programs and using Go-native features like channels for receiving events. Because
    it’s built on *libbpf*, it supports CO-RE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an extract from the example from *libbpfgo*’s *README*, which gives
    a good high-level view of what to expect from this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#code_id_10_11)'
  prefs: []
  type: TYPE_NORMAL
- en: Read eBPF bytecode from an object file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_10_12)'
  prefs: []
  type: TYPE_NORMAL
- en: Load that bytecode into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_10_13)'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulate an entry in an eBPF map.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_10_14)'
  prefs: []
  type: TYPE_NORMAL
- en: Go programmers will appreciate receiving data from a ring or perf buffer on
    a channel, which is a language feature designed to handle asynchronous events.
  prefs: []
  type: TYPE_NORMAL
- en: This library was created for Aqua’s [Tracee](https://oreil.ly/A03zd) security
    project, and it’s also being used by other projects such as [Parca](https://oreil.ly/s8JP9)
    from Polar Signals, which provides eBPF-based CPU profiling. The only concern
    about this project’s approach is the CGo boundary between the *libbpf* C code
    and Go, which can cause performance and other issues.^([5](ch10.html#ch10fn5))
  prefs: []
  type: TYPE_NORMAL
- en: While Go has been the established language for lots of infrastructure coding
    for around a decade, there has more recently been a growing body of developers
    who prefer to use Rust.``  ``# Rust
  prefs: []
  type: TYPE_NORMAL
- en: Rust is increasingly being used for building infrastructure tools. It allows
    for the low-level access of C, but with the added benefit of memory safety. Indeed,
    Linus Torvalds [confirmed in 2022](https://oreil.ly/7fINA) that the Linux kernel
    itself will start to incorporate Rust code, and the recent [6.1 release has some
    initial Rust support](https://oreil.ly/HrXy2).
  prefs: []
  type: TYPE_NORMAL
- en: As I discussed earlier in this chapter, Rust can be compiled to eBPF bytecode,
    meaning that (with the right library support) it’s possible to write both the
    user space and kernel code for eBPF utilities in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few options for Rust eBPF development: *libbpf-rs*, *Redbpf*, and
    Aya.'
  prefs: []
  type: TYPE_NORMAL
- en: Libbpf-rs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Libbpf-rs*](https://oreil.ly/qBagk) is part of the *libbpf* project, and
    provides a Rust wrapper around the *libbpf* C code so that you can write the user
    space parts of eBPF code in Rust. As you can see from the project’s [examples](https://oreil.ly/6wpf8),
    the eBPF programs themselves are written in C.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are further examples in Rust in the [*libbpf-bootstrap*](https://oreil.ly/ter6c)
    project, designed to help you get off the ground if you want to try building your
    own code using this crate.
  prefs: []
  type: TYPE_NORMAL
- en: This crate is helpful for incorporating eBPF programs into a Rust-based project,
    but it doesn’t fulfill the desire that many people have to write the kernel-side
    code in Rust as well. Let’s look at some other projects that enable that.
  prefs: []
  type: TYPE_NORMAL
- en: Redbpf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Redbpf*](https://oreil.ly/AtJod) is a set of Rust crates that interface with
    *libbpf*, developed as part of [foniod](https://oreil.ly/dwGNK), an eBPF-based
    security monitoring agent.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Redbpf* predates Rust’s ability to compile to eBPF bytecode, so it uses a
    [multistep compilation process](https://oreil.ly/DuHxE) that involves compiling
    from Rust to LLVM bitcode and then using the LLVM toolchain to generate eBPF bytecode
    in ELF format. *Redbpf* supports a range of program types including tracepoints,
    kprobes and uprobes, XDP, TC, and some socket events.'
  prefs: []
  type: TYPE_NORMAL
- en: As the Rust compiler rustc gained the ability to generate eBPF bytecode directly,
    this was leveraged by a project called Aya. At the time of this writing, Aya is
    considered “emerging” according to the [community site at ebpf.io](https://oreil.ly/WynV6),
    while *Redbpf* is listed as a major project, but my personal perspective is that
    momentum seems to be moving toward Aya.
  prefs: []
  type: TYPE_NORMAL
- en: Aya
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Aya](https://aya-rs.dev/book) is built in Rust directly to the syscall level,
    so it doesn’t depend on *libbpf* (or indeed on BCC or the LLVM toolchain). But
    it does support the BTF format, the same relocations that *libbpf* does (as described
    in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf)), so it’s providing the
    same CO-RE abilities to compile once and run on other kernels. At the time of
    this writing, it supports a wider range of eBPF program types than *Redbpf*, including
    tracing/perf-related events, XDP and TC, cgroups, and LSM attachments.'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, the Rust compiler also supports [compiling to eBPF bytecode](https://oreil.ly/a5q7M),
    so this language can be used for both kernel and user space eBPF programming.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ability to write both the kernel side and the user space side natively in
    Rust without the intermediate dependency on LLVM has attracted Rust programmers
    to this option. There’s an interesting [discussion on GitHub](https://oreil.ly/nls4l)
    about why the developers of the [lockc project](https://oreil.ly/_-L6z) (an eBPF-based
    project that enhances the security of container workloads using LSM hooks) decided
    to port their project from *libbpf-rs* to Aya.
  prefs: []
  type: TYPE_NORMAL
- en: The project includes [aya-tool](https://oreil.ly/Kd0nf), a utility for generating
    Rust structure definitions that match kernel data structures so that you don’t
    have to write them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The Aya project strongly emphasizes developer experience and makes it easy for
    newcomers to get started. With that in mind, the [“Aya book”](https://aya-rs.dev/book)
    is a very readable introduction with some good example code, annotated with helpful
    explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a brief idea of what eBPF code looks like in Rust, here’s an extract
    from Aya’s basic XDP example that permits all traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#code_id_10_15)'
  prefs: []
  type: TYPE_NORMAL
- en: This line is what defines the section name, equivalent to `SEC("xdp/myapp")`
    in C.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_10_16)'
  prefs: []
  type: TYPE_NORMAL
- en: The eBPF program called `myapp` calls the function `try_myapp` to process a
    network packet received at XDP.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_10_17)'
  prefs: []
  type: TYPE_NORMAL
- en: The `try_myapp` function logs the fact that a packet was received and always
    returns the `XDP_PASS` value that tells the kernel to carry on processing the
    packet as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we’ve seen in C-based examples throughout this book, the eBPF program
    gets compiled to an ELF object file. The difference is that Aya uses the Rust
    compiler instead of Clang to create that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aya also generates code for the user space activities of loading the eBPF program
    into the kernel and attaching it to an event. Here are a few key lines from the
    user space side of that same basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#code_id_10_19)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the eBPF bytecode from the ELF object file produced by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_10_20)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the program called `myapp` in that bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_10_21)'
  prefs: []
  type: TYPE_NORMAL
- en: Load it into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#code_id_10_22)'
  prefs: []
  type: TYPE_NORMAL
- en: Attach it to the XDP event on a specified network interface.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a Rust programmer, I highly recommend you explore the [additional
    examples](https://oreil.ly/bp_Hq) in the “Aya book” in more detail. There’s also
    a nice [blog post from Kong](https://oreil.ly/mUVIk) that walks through writing
    an XDP load balancer using Aya.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Aya maintainers Dave Tucker and Alessandro Decina joined me for [episode 25
    of the “eBPF and Cilium Office Hours” livestream](https://oreil.ly/U7bRu) where
    they demonstrated and gave an introduction to eBPF programming with Aya.
  prefs: []
  type: TYPE_NORMAL
- en: Rust-bcc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Rust-bcc](https://oreil.ly/prP_K) provides Rust bindings that mimic the BCC
    project’s Python bindings, along with some Rust implementations of some of the
    BCC set of tracing [tools](https://oreil.ly/Dd2nO).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing BPF Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a `bpf()` command, [`BPF_PROG_RUN`](https://oreil.ly/Y2xPC), that allows
    for running an eBPF program from user space for test purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_RUN` (currently) works only with a subset of BPF program types that
    are mostly networking related.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get information about eBPF program performance with some built-in
    statistics information. Run the following command to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show additional information in `bpftool`’s output about programs,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The additional statistics are shown in bold, and here they show that the program
    has run four times, taking about 300 microseconds in total.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Learn more from Quentin Monnet’s FOSDEM 2020 talk titled [“Tools and mechanisms
    to debug BPF programs.”](https://oreil.ly/I5Jhd)
  prefs: []
  type: TYPE_NORMAL
- en: Multiple eBPF Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An eBPF program is a function attached to an event in the kernel. Many applications
    need to track more than one event to achieve their goals. A simple example of
    this is opensnoop.^([6](ch10.html#ch10fn6)) I covered the `bpftrace` version of
    this early in this chapter, and you saw that it attaches BPF programs to four
    different syscall tracepoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall_enter_open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall_exit_open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall_enter_openat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall_exit_openat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the entry and exit points to the kernel’s handling of the `open()`
    and `openat()` system calls. These two system calls can be used for opening files,
    and the opensnoop tool tracks both of them.
  prefs: []
  type: TYPE_NORMAL
- en: But why does it need to track both entry and exit for these system calls? The
    entry points are used because that’s when the system call arguments are available,
    and these include the filename and any flags being passed to the `open[at]` syscall.
    But at that stage it’s too soon to know whether the file will be opened successfully
    or not. That explains why it’s necessary to have eBPF programs attached to the
    exit points too.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the [*libbpf-tools* version of opensnoop](https://oreil.ly/IOty_),
    you’ll see there’s just one user space program, and it loads all four eBPF programs
    into the kernel and attaches them to their events. The eBPF programs themselves
    are essentially independent, but they use eBPF maps to coordinate among themselves.
  prefs: []
  type: TYPE_NORMAL
- en: A complex application might even need to add and remove eBPF programs dynamically
    throughout a long period of time. There may not even be a fixed number of eBPF
    programs for any given application. For example, Cilium attaches eBPF programs
    to each virtual networking interface, and in a Kubernetes environment these interfaces
    come and go depending on how many pods are running.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the libraries in this chapter handle this multiplicity of eBPF programs
    automatically. For example, *libbpf* and *ebpf-go* generate skeleton code that
    will load *all* the programs and maps from the bytecode in an object file or buffer
    in one function call. They also generate finer-granularity functions so that you
    can manipulate programs and maps individually.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of people who use eBPF-based tooling won’t need to write eBPF
    code themselves, but if you do find yourself wanting to implement something yourself,
    you have a lot of options. This is a changing field, so it’s very possible that
    by the time you read this, new language libraries and frameworks might exist,
    or consensus may have gathered around some of the libraries I’ve highlighted in
    this chapter. You’ll find an up-to-date list of the major language projects around
    eBPF on the [Infrastructure page of ebpf.io’s list of significant projects](https://ebpf.io/infrastructure).
  prefs: []
  type: TYPE_NORMAL
- en: For quickly collecting trace information, `bpftrace` can be a very valuable
    option.
  prefs: []
  type: TYPE_NORMAL
- en: For more flexibility and control, BCC is a fast way to build an eBPF tool if
    you’re comfortable with Python, provided that you don’t care about the compilation
    step that takes place at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re writing eBPF code to be widely distributed and portable across different
    kernel versions, you’ll probably want to take advantage of CO-RE. The user space
    frameworks that support CO-RE at time of this writing are *libbpf* for C, *cilium/ebpf*
    and *libbpfgo* for Go, and Aya for Rust.
  prefs: []
  type: TYPE_NORMAL
- en: For further advice, I highly recommend joining the [eBPF Slack](http://ebpf.io/slack)
    and discussing your questions there. You’ll likely find the maintainers of many
    of these language libraries in that community.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’d like to try one or more of the libraries discussed in this chapter,
    “Hello World” is always a good place to start:'
  prefs: []
  type: TYPE_NORMAL
- en: Using one or more libraries of your choosing, write an example “Hello World”
    program that outputs a simple trace message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `llvm-objdump` to compare the bytecode produced with the “Hello World” example
    from [Chapter 3](ch03.html#anatomy_of_an_ebpf_program). You’ll find lots of similarities!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you saw in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi),
    you can use `strace -e bpf` to see when `bpf()` system calls are made. Try that
    on your “Hello World” program to see if it’s behaving as you expect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ^([1](ch10.html#ch10fn1-marker)) Being attached to syscall entry points means
    this script has the same Time Of Check To Time Of Use (TOCTOU) vulnerability discussed
    in the previous chapter. That doesn’t stop it from being a useful tool; it’s just
    that you shouldn’t rely on it as your only line of defense for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#ch10fn2-marker)) For an example of this, check out Cloudflare’s
    blog post [“eBPF, Sockets, Hop Distance and manually writing eBPF assembly”](https://oreil.ly/2GjuK).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.html#ch10fn3-marker)) See, for example, Brendan Gregg’s [observation](https://oreil.ly/fz_dQ)
    that the *libbpf*-based version of opensnoop required around 9 MB compared with
    80 MB for the Python-based version.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch10.html#ch10fn4-marker)) Watch me working through some of the XDP Tutorial
    examples in [episode 13 of the eBPF and Cilium Office Hours” livestream](https://oreil.ly/9SaKn).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch10.html#ch10fn5-marker)) Dave Cheney’s 2016 post “[cgo is not Go](https://oreil.ly/mxThs)”
    remains a good overview of concerns related to the CGo boundary.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch10.html#ch10fn6-marker)) As well as the `bpftrace` version of this tool,
    there are equivalents in BCC and in *libbpf-tools*. They all do very much the
    same thing, generating a line of trace whenever a process opens a file. There’s
    a walkthrough of the eBPF code for BCC’s version of opensnoop in my report [“What
    Is eBPF?”](https://www.oreilly.com/library/view/what-is-ebpf/9781492097266).``
  prefs: []
  type: TYPE_NORMAL

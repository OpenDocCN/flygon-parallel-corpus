- en: Chapter 11\. The Future Evolution of eBPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: eBPF is not finished yet! Like most software, it’s under continual development
    within the Linux kernel, and it’s being added to the Windows operating system
    as well. In this chapter we’ll look at some of the likely future paths for this
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: Since it was introduced within the Linux kernel, BPF has evolved into its own
    subsystem with its own mailing list and maintainers.^([1](ch11.html#ch11fn1))
    As eBPF’s popularity increased and interest broadened beyond the Linux kernel
    community, it made sense to create a neutral body that could coordinate among
    the different parties involved. That body is the eBPF Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: The eBPF Foundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [eBPF Foundation](https://ebpf.io/foundation) was set up in 2021 by Google,
    Isovalent, Meta (then known as Facebook), Microsoft, and Netflix, under the auspices
    of the Linux Foundation. The foundation acts as a neutral body that can hold funds
    and intellectual property, such that various commercial companies can collaborate
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: The intent was not to change anything about the way eBPF technology is developed
    by the Linux kernel community and contributors to the Linux BPF subsystem. The
    foundation’s activities are directed by the BPF Steering Committee, which is entirely
    composed of the technical experts who build the technology, including the Linux
    kernel BPF maintainers and representatives from other core eBPF projects.
  prefs: []
  type: TYPE_NORMAL
- en: The eBPF Foundation focuses on eBPF as a technology platform and the ecosystem
    of tools that enable eBPF development. Projects that build on top of eBPF looking
    for neutral ownership may find a better home in other foundations. For example,
    Cilium, Pixie, and Falco are all part of the CNCF, which makes sense as they are
    all intended to be used in cloud native environments.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key drivers of this collaboration beyond the existing Linux maintainers
    was the interest that Microsoft had in developing eBPF within the Windows operating
    system. This brings about a need to define a standard for eBPF,^([2](ch11.html#ch11fn2))
    such that programs written for one OS can be used on another. This work is being
    done under the auspices of the eBPF Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF for Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Work is well underway at Microsoft to support [eBPF for Windows](https://oreil.ly/ArwkR).
    As I write this in the closing months of 2022, there are already [functional demos](https://oreil.ly/H-0dv)
    that show Cilium Layer 4 load balancing and eBPF-based connection tracking running
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve said before that eBPF programming is kernel programming, and at first glance
    it might seem unintuitive that a program written to run in the Linux kernel and
    that has access to Linux kernel data structures would in any way be able to operate
    in an entirely different operating system. But in practice, particularly when
    it comes to networking, all operating systems will have quite a lot in common.
    A network packet has the same structure whether it was created on a Windows or
    Linux machine, and the layers of the network stack have to be handled the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also recall that eBPF programs consist of a set of bytecode instructions
    that are processed by a virtual machine (VM) implemented within the kernel. That
    VM can be implemented within Windows too!
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-1](#architectural_overview_of_ebpf_for_wind) shows the eBPF for
    Windows architectural overview, taken from [the project’s GitHub repo](https://oreil.ly/Ii4j2).
    As you can see from this diagram, eBPF for Windows reuses some open source components
    from the existing eBPF ecosystem, such as *libbpf*, and the support in Clang for
    producing eBPF bytecode. The Linux kernel is licensed under GPL, and Windows is
    proprietary, so the Windows project can’t reuse any parts of the Linux kernel’s
    implementation of the verifier.^([3](ch11.html#ch11fn3)) Instead, it uses the
    [PREVAIL verifier](https://vbpf.github.io) and the [uBPF JIT compiler](https://oreil.ly/btrkJ)
    (both of which are permissively licensed so that they can be used by a broader
    range of projects and organizations).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural overview of eBPF for Windows, taken from https://oreil.ly/HxKsu](assets/lebp_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Architectural overview of eBPF for Windows, adapted from [*https://oreil.ly/HxKsu*](https://oreil.ly/HxKsu)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One interesting difference is that eBPF code is verified and JIT-compiled in
    a Windows Secure environment in user space rather than within the kernel (the
    uBPF interpreter shown in the kernel in [Figure 11-1](#architectural_overview_of_ebpf_for_wind)
    is used only in debug builds and not production environments).
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be unrealistic to expect that every single eBPF program written to
    run on Linux will work on Windows. But this isn’t so different from the challenge
    of getting eBPF programs to run on different Linux kernel versions: even with
    CO-RE support, internal kernel data structures can be changed as well as added
    or removed between versions. It is the eBPF programmer’s job to handle these possibilities
    gracefully.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of changes to the Linux kernel, what changes can we expect to see in
    eBPF in the coming years?
  prefs: []
  type: TYPE_NORMAL
- en: Linux eBPF Evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The capabilities of eBPF have evolved with practically every kernel release
    since 3.15\. If you want to know what features are available in any given version,
    the BCC project maintains a [useful list](https://oreil.ly/4H5hU). And I certainly
    expect more additions over the coming years.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to predict what’s coming is simply to listen to the people who
    are working on it. For example, at the 2022 Linux Plumbers Conference, eBPF maintainer
    Alexei Starovoitov gave a talk discussing how he expects to see the C language
    used by eBPF programs to evolve.^([4](ch11.html#ch11fn4)) We’ve already seen eBPF
    evolve from supporting a few thousand instructions to practically unlimited complexity,
    with the addition of support for loops and an ever-increasing set of BPF helper
    functions. As additional capabilities are added into the C that’s supported, and
    with the support of the verifier, eBPF C could evolve to allow all the flexibility
    of developing kernel modules, but with the safety and dynamic loading characteristics
    of eBPF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other ideas being discussed and developed for new eBPF features
    and capabilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: Signed eBPF programs
  prefs: []
  type: TYPE_NORMAL
- en: Software supply chain security has been a hot topic for the past few years,
    and a key element is the ability to check that a program you’re thinking of running
    comes from the expected source and has not been tampered with. One way to achieve
    this is, in general, to validate a cryptographic signature that accompanies a
    program. You might think this is something the kernel could do for eBPF programs,
    perhaps as part of the verification step, but unfortunately this is not straightforward!
    As you’ve seen in this book, user space loaders dynamically adjust programs with
    information about where maps are located, and for CO-RE purposes, which from a
    signing perspective is hard to distinguish from malicious modifications. This
    is a problem for which the eBPF community is [keen to find a solution](https://oreil.ly/ns03-).
  prefs: []
  type: TYPE_NORMAL
- en: Long-lived kernel pointers
  prefs: []
  type: TYPE_NORMAL
- en: An eBPF program can retrieve a pointer to a kernel object using a helper function
    or a kfunc, but a pointer is valid only during that execution of the program.
    The pointer cannot be stored in a map for later retrieval. The idea of [typed
    pointer support](https://oreil.ly/fWVdo) will allow for more flexibility in this
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs: []
  type: TYPE_NORMAL
- en: It’s not safe for eBPF programs to simply call memory allocation functions like
    `kmalloc()`, but there is [a proposal that suggests](https://oreil.ly/Yxxc5) an
    eBPF-specific alternative.
  prefs: []
  type: TYPE_NORMAL
- en: When will you be able to take advantage of new eBPF features as they emerge?
    As an end user, the features you’re able to take advantage of depend on the version
    of the kernel you’re running in production, and as I discussed in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque),
    it can take several years for kernel releases to make it to stable distributions
    of Linux. As an individual you might opt for a bleeding-edge kernel, but the vast
    majority of organizations running server deployments use a stable, supported version.
    eBPF programmers have to take into account that if they write code that takes
    advantage of the newest features added to the kernel, the features are unlikely
    to be usable in most production environments for some years to come. Some organizations
    will have sufficiently urgent needs that it’s worth rolling out newer kernel versions
    more quickly in order to early-adopt new eBPF features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in another forward-looking talk on [building tomorrow’s networking](https://oreil.ly/IvPgd),
    Daniel Borkmann discussed a feature called *Big TCP*. This was added to Linux
    in version 5.19 to enable network speeds of 100 GBit/s (and faster) by batching
    up network packets to be processed in the kernel. Most Linux distributions won’t
    support a kernel this recent for a few years, but for specialist organizations
    dealing with large amounts of network traffic, it might well be worth upgrading
    sooner. Adding Big TCP support into eBPF and Cilium today means it’s available
    for those massive-scale users, even if it’s not something that can be enabled
    by most of us for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Since eBPF allows kernel code to be adjusted dynamically, it’s reasonable to
    expect it to be used to address problems “in the field.” In [Chapter 9](ch09.html#ebpf_for_security)
    you read about using eBPF to mitigate kernel vulnerabilities; work is also underway
    to use eBPF to help support hardware devices such as [human interface devices](https://oreil.ly/JVYcY)
    like mice, keyboards, and game controllers. This builds on existing support for
    decoding the protocols used by infrared controllers that I mentioned in [Chapter 7](ch07.html#ebpf_program_and_attachment_types).
  prefs: []
  type: TYPE_NORMAL
- en: eBPF Is a Platform, Not a Feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming up to a decade ago, the hot new technology was containers, and it seemed
    as though everyone was talking about what they were and what advantages they would
    bring. We’re at a similar stage with eBPF today, with lots of conference talks
    and blog posts—several of which I’ve referred to in this book—extolling the benefits
    of eBPF. Today, containers are part of daily life for many developers, whether
    they’re running code locally using Docker or other container runtimes, or deploying
    code to Kubernetes environments. Will eBPF become part of everyone’s regular toolkit
    too?
  prefs: []
  type: TYPE_NORMAL
- en: The answer, I believe, is no—or at least, not directly. Most users won’t write
    eBPF programs directly or manipulate them manually with utilities like `bpftool`.
    But they’ll interact regularly with tools built using eBPF, whether that’s for
    performance measurement, debugging, networking, security, tracing, or a whole
    host of other capabilities yet to be implemented using eBPF. Users might not be
    aware that they’re using eBPF, much as they might not know that when they use
    containers, they’re using kernel features like namespaces and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Today, projects and vendors with knowledge of eBPF highlight their use of it
    because it’s so powerful and implies many advantages. As eBPF-based projects and
    products gain traction and market share, eBPF is becoming the de facto default
    technology platform for infrastructure tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of eBPF programming is—and will continue to be—a sought-after but
    relatively rare skill, just as kernel development today is much less common than
    developing, say, business applications or games. If you enjoy diving into the
    lower levels of systems and want to build essential infrastructure tooling, eBPF
    skills will serve you well. I hope this book has been of some assistance on your
    eBPF journey!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on reaching the end of this book!
  prefs: []
  type: TYPE_NORMAL
- en: I hope that reading *Learning eBPF* has given you insight into the power of
    eBPF. Perhaps it has inspired you to write eBPF code yourself or experiment with
    some of the tools I’ve discussed. If you’ve decided to do some eBPF programming,
    I hope the book has given you some confidence about how to get started. And if
    you have been completing the exercises as you worked through the book, bravo!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re excited about eBPF there are plenty of ways to get involved in the
    community. The best starting point is the website [ebpf.io](http://ebpf.io). This
    will point you to the latest news, projects, events, and happenings, and also
    to the [eBPF Slack](http://ebpf.io/slack) channel where you’re likely to find
    someone with the expertise to answer any questions you might have.
  prefs: []
  type: TYPE_NORMAL
- en: 'I welcome your feedback, comments, and any corrections to this text. You can
    provide your input through the GitHub repository that accompanies this book: [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    I’d also be happy to hear your comments directly. You can find me as @lizrice
    in many places across the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#ch11fn1-marker)) Shout-out to Alexei Starovoitov and Andrii
    Nakryiko from Meta, and Daniel Borkmann from Isovalent, who maintain the BPF subtree
    in the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#ch11fn2-marker)) [Dave Thaler presented on the state of this
    standardization work](https://oreil.ly/4bo6Y) at the Linux Plumbers Conference.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch11.html#ch11fn3-marker)) Well, it *could*, but doing so would require
    Microsoft to also release the Windows source code under the GPL license.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch11.html#ch11fn4-marker)) Alexei Starovoitov discusses the journey of
    BPF from restricted C language to extended and safe C [in this video](https://oreil.ly/xunKW).
  prefs: []
  type: TYPE_NORMAL

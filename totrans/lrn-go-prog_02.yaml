- en: Chapter 2. Go Language Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we established the elemental characteristics that make
    Go a great language with which to create modern system programs. In this chapter,
    we dig deeper into the language's syntax to explore its components and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go source file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go source file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen, in [Chapter 1](ch01.html "Chapter 1. A First Step in Go"), *A
    First Step in Go*, some examples of Go programs. In this section, we will examine
    the Go source file. Let us consider the following source code file (which prints
    `"Hello World"` greetings in different languages):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Go source file](img/B03676_02_Helloworld2-source.jpg)'
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch02/helloworld2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Go source file, such as the one listed earlier, can be divided into
    three main sections, illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Package Clause**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Import Declaration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Source Body**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **package** clause indicates the name of the package this source file belongs
    to (see [Chapter 6](ch06.html "Chapter 6. Go Packages and Programs"), Go *Packages
    and Programs* for a detailed discussion on package organization). The **import**
    declaration lists any external package that the source code wishes to use. The
    Go compiler strictly enforces package declaration usage. It is considered an error
    (compilation) to include an unused package in your source file. The last portion
    of the source is considered the body of your source file. It is where you declare
    variables, constants, types, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: All Go source files must end with the `.go` suffix. In general, you can name
    a Go source file whatever you want. Unlike Java, for instance, there is no direct
    association between a Go file name and the types it declared in its content. It
    is, however, considered good practice to name your file something indicative of
    its content.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explore Go's syntax in greater detail, it is important to understand
    some basic structural elements of the language. While some of these elements are
    syntactically bolted into the language, others are simple idioms and conventions
    that you should be aware of to make your introduction to Go simple and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Optional semicolon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that Go does not require a semicolon as a statement separator.
    This is a trait borrowed from other lighter and interpreted languages. The following
    two programs are functionally equivalent. The first program uses idiomatic Go
    and omits the semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional semicolon](img/B03736_02_Helloworld-snippet1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second version of the program, shown as follows, uses superfluous semicolons
    to explicitly terminate its statements. While the compiler may thank you for your
    help, this is not idiomatic in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional semicolon](img/B03676_02_Helloworld-snippet2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although semicolons in Go are optional, Go''s formal grammar still requires
    them as statement terminators. So, the Go compiler will insert semicolons at the
    end of source code lines that end with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal value for string, Boolean, numeric, or complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A control flow directive such as break, continue, or return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing parenthesis or bracket such as `)`, `}`, or `]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The increment `++` or the decrement `--` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to these rules, the compiler enforces strict syntactical forms that heavily
    influence source code style in Go. For instance, all code blocks must start with
    an open curly `{` brace on the same line as its preceding statement. Otherwise,
    the compiler may insert the semicolon in a location that breaks the code, as shown
    in the following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving the curly brace to the next line causes the compiler to insert the semicolon
    prematurely, which will result in the following syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is because the compiler inserted the semicolon after the `if` statement
    (`if "a"=="a";`), using the semicolon insertion rules discussed in this section.
    You can verify this by manually inserting a semicolon after the `if` condition
    statement; you will get the same error. This is an excellent place to transition
    into the next section, to discuss trailing commas in code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breaking up expressions into multiple lines must follow the semi-colon rules
    discussed in the previous section. Mainly, in a multi-line expression, each line
    must end with a token that prevents the premature insertion of a semi-colon, as
    illustrated in the following table. It should be noted that rows in the table
    with an invalid expression will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Valid** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| Yes, the `+` operator prevents a premature semi-colon from being inserted.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| No, a semi-colon will be inserted after the first line, semantically breaking
    the line. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Yes, the comma properly breaks the expression. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Yes, the compiler inserts a semi-colon only after the last line. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| No, the `Fri` line causes a premature semi-colon to be inserted. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Yes, the `Fri` line contains a trailing comma, which causes compiler to insert
    a semi-colon at the next line. |'
  prefs: []
  type: TYPE_TB
- en: '| `weekDays1 := []string{``"Mon", "Tue",``"Wed", "Thr",``"Fri"}` | Yes, the
    semi-colon is inserted after the line with the closing bracket. |'
  prefs: []
  type: TYPE_TB
- en: You may wonder why the Go compiler puts the onus on the developer to provide
    line-break hints to indicate the end of a statement. Surely, Go designers could
    have devised an elaborate algorithm to figure this out automatically. Yes, they
    could have. However, by keeping the syntax simple and predictable, the compiler
    is able to quickly parse and compile Go source code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Go toolchain includes the gofmt tool, which can be used to consistently
    apply proper formatting rules to your source code. There is also the `govet` tool,
    which goes much further by analyzing your code for structural problems with code
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Go identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go identifiers are used to name program elements including packages, variables,
    functions, and types. The following summarizes some attributes about identifiers
    in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers support the Unicode character set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first position of an identifier must be a letter or an underscore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idiomatic Go favors mixed caps (camel case) naming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package-level identifiers must be unique across a given package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers must be unique within a code block (functions, control statements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blank identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Go compiler is particularly strict about the use of declared identifiers
    for variables or packages. The basic rule is: *you declare it, you must use it*.
    If you attempt to compile code with unused identifiers such as variables or named
    packages, the compilers will not be pleased and will fail compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: Go allows you to turn off this behavior using the blank identifier, represented
    by the `_` (underscore) character. Any declaration or assignment that uses the
    blank identifier is not bound to any value and is ignored at compile time. The
    blank identifier is usually used in two contexts, as listed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Muting package imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a package declaration is preceded by an underscore, the compiler allows
    the package to be declared without any further referenced usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, the package `log` will be muted without any further
    reference in the code. This can be a handy feature during active development of
    new code, where developers may want to try new ideas without constantly having
    to comment out or delete the declarations. Although a package with a blank identifier
    is not bound to any reference, the Go runtime will still initialize it. [Chapter
    6](ch06.html "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*,
    discusses the package initialization lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Muting unwanted function results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a Go function call returns multiple values, each value in the return list
    must be assigned to a variable identifier. In some cases, however, it may be desirable
    to mute unwanted results from the return list while keeping others, as shown in
    the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous call to the function `filepath.Split("/opt/data/bigdata.txt")`
    takes a path and returns two values: the first is the parent path (`/opt/data`)
    and the second is the file name (`bigdata.txt`). The first value is assigned to
    the blank identifier and is, therefore, unbounded to a named identifier, which
    causes it to be ignored by the compiler. In future discussions, we will explore
    other uses of this idiom''s other contexts, such as error-handling and `for` loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go comes with a number of built-in identifiers. They fall into different categories,
    including types, values, and built-in function.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following identifiers are used for Go''s built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Identifier** |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric | `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`,
    `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`, `complex64`, `complex128`,
    `uintptr` |'
  prefs: []
  type: TYPE_TB
- en: '| String | `string` |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Error | `error` |'
  prefs: []
  type: TYPE_TB
- en: Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These identifiers have preassigned values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Identifier** |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean constants | `true`, `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Constant counter | `iota` |'
  prefs: []
  type: TYPE_TB
- en: '| Uninitialized value | `nil` |'
  prefs: []
  type: TYPE_TB
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions are available as part of Go''s built-in pre-declared
    identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Identifier** |'
  prefs: []
  type: TYPE_TB
- en: '| Initialization | `make()`, `new()` |'
  prefs: []
  type: TYPE_TB
- en: '| Collections | `append()`, `cap()`, `copy()`, `delete()` |'
  prefs: []
  type: TYPE_TB
- en: '| Complex numbers | `complex()`, `imag()`, `real()` |'
  prefs: []
  type: TYPE_TB
- en: '| Error Handling | `panic()`, `recover()` |'
  prefs: []
  type: TYPE_TB
- en: Go variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a strictly typed language, which implies that all variables are named
    elements that are bound to both a value and a type. As you will see, the simplicity
    and flexibility of its syntax make declaring and initializing variables in Go
    feel more like a dynamically-typed language.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can use a variable in Go, it must be declared with a named identifier
    for future reference in the code. The long form of a variable declaration in Go
    follows the format shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `var` keyword is used to declare one or more variable identifiers followed
    by the type of the variables. The following source code snippet shows an abbreviated
    program with several variables declared outside of the function `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/vardec1.go
  prefs: []
  type: TYPE_NORMAL
- en: The zero-value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous source code shows several examples of variables being declared
    with a variety of types. Then the variables are assigned a value inside the function
    `main()`. At first glance, it would appear that these declared variables do not
    have an assigned value when they are declared. This would contradict our previous
    assertion that all Go variables are bound to a type and a value.
  prefs: []
  type: TYPE_NORMAL
- en: How can we declare a variable and not bind a value to it? During declaration
    of a variable, if a value is not provided, Go will automatically bind a default
    value (or a zero-value) to the variable for proper memory initialization (we see
    how to do both declaration and initialization in one expression later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows Go types and their default zero-values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Zero-Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `""` (empty string) |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric - Integers: `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`,
    `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric - Floating point: `float32`, `float64` | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | false |'
  prefs: []
  type: TYPE_TB
- en: '| `Array` | Each index position has a zero-value corresponding to the array''s
    element type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Struct` | An empty `struct` with each member having its respective zero-value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Other types: Interface, function, channel, slice, map, and pointer | nil
    |'
  prefs: []
  type: TYPE_TB
- en: Initialized declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As hinted earlier, Go also supports the combination of both variable declaration
    and initialization as one expression using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*var <identifier list> <type> = <value list or initializer expressions>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This declaration format has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier list provided on the left-hand side of the equal sign (followed
    by a type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matching comma-separated value list on the right-hand side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment occurs in the respective order of identifiers and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializer expressions must yield a matching list of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following abbreviated example shows the declaration and initialization
    combination at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/vardec2.go
  prefs: []
  type: TYPE_NORMAL
- en: Omitting variable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have discussed what is called the long form of Go''s variable declaration
    and initialization. To make the language feel closer to its dynamically-typed
    cousins, the type specification can be omitted, as shown in the following declaration
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*var <identifier list> = <value list or initializer expressions>*'
  prefs: []
  type: TYPE_NORMAL
- en: During compilation, the compiler infers the type of the variable based on the
    assigned value or the initializer expression on the right-hand side of the equal
    sign, as shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/vardec3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, when a variable is assigned a value, it must receive a type
    along with that value. When the type of the variable is omitted, the type information
    is deduced from the assigned value or the returned value of an expression. The
    following table shows the type that is inferred given a literal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Literal value** | **Inferred type** |'
  prefs: []
  type: TYPE_TB
- en: '| Double- or single-quoted (raw) text: `"Planet Mars"``"All planets revolve
    around the Sun."` | `string` |'
  prefs: []
  type: TYPE_TB
- en: '| Integers:`-76`0`1244``1840` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| Decimals:`-0.25``4.0``3.1e4``7e-12` | `float64` |'
  prefs: []
  type: TYPE_TB
- en: '| Complex numbers:`-5.0i``3i``(0+4i)` | `complex128` |'
  prefs: []
  type: TYPE_TB
- en: '| Booleans:`true``false` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| Array values:`[2]int{-76, 8080}` | The `array` type defined in the literal
    value. In this case it is: `[2]int` |'
  prefs: []
  type: TYPE_TB
- en: '| Map values:`map[string]int{``  "Sun": 685800,``  "Earth": 6378,``  "Mars":
    3396,``}` | The map type defined in the literal value. In this case it is: `map[string]int`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Slice values:`[]int{-76, 0, 1244, 1840}` | The `slice` type defined in the
    literal value:`[]int` |'
  prefs: []
  type: TYPE_TB
- en: '| Struct values:`struct{``  name string``  diameter int}``{``  "Mars", 3396,``}`
    | A `struct` type as defined in the literal value. In this case the type is:`struct{name
    string; diameter int}` |'
  prefs: []
  type: TYPE_TB
- en: '| Function values:`var sqr = func (v int)   int {``  return v * v``}` | The
    function type defined in the function definition literal. In this `case`, `variable``sqr`
    will have type:`func (v int) int` |'
  prefs: []
  type: TYPE_TB
- en: Short variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go can further reduce the variable declaration syntax using the *short variable
    declaration* format. In this format, the declaration loses the var keyword and
    the type specification, and uses an assignment operator `:=` (colon-equal), as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<identifier list> := <value list or initializer expressions>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple and uncluttered idiom that is commonly used when declaring
    variables in Go. The following code sample shows usage of the short variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/vardec4.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice the keyword `var` and variable types have been omitted in the declaration.
    Short variable declaration uses the same mechanism to infer the type of the variable
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions for short variable declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For convenience, the short form of the variable declaration does come with
    several restrictions that you should be aware of to avoid confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it can only be used within a function block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assignment operator `:=`, declares variable and assign values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:=` cannot be used to update a previously declared variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates to variables must be done with an equal sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these restrictions may have their justifications rooted in the simplicity
    of Go's grammar, they are generally viewed as a source of confusion for newcomers
    to the language. For instance, the colon-equal operator cannot be used with package-level
    variables assignments. Developers learning Go may find it compelling to use the
    assignment operator as a way to update a variable, but that would cause a compilation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope and visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go uses lexical scoping based on code blocks to determine the visibility of
    variables within a package. Depending on the location where a variable is declared,
    within the source text, will determine its scope. As a general rule, a variable
    is only accessible from within the block where it is declared and visible to all
    nested sub-blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the scope of several variables declared
    within a source text. Each variable declaration is marked with its scope (`package`,
    `function`, `for` loop, and `if...else` block):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable scope and visibility](img/B036376_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch02/makenums.go
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, variable visibility works top-down. Variables with package
    scope, such as `mapFile` and `numbersFile`, are globally visible to all other
    elements in the package. Moving down the scope ladder, function-block variables
    such as `data` and `err` are visible to all elements in the function and including
    sub-blocks. Variables `i` and `b` in the inner `for` loop block are only visible
    within that block. Once the loop is done, `i` and `b` would go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One source of confusion to newcomers to Go is the visibility of package-scoped
    variables. When a variable is declared at package level (outside of a function
    or method block), it is globally visible to the entire package, not just to the
    source file where the variable is declared. This means a package-scoped variable
    identifier can only be declared once in a group of files that make up a package,
    a fact that may not be obvious to developers starting out with Go. Refer to [Chapter
    6](ch06.html "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*,
    for details on package organization.
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go''s syntax allows the declaration of top-level variables to be grouped together
    into blocks for greater readability and code organization. The following example
    shows a rewrite of one of the previous examples using the variable declaration
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/vardec5.go
  prefs: []
  type: TYPE_NORMAL
- en: Go constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, a constant is a value with a literal representation such as a string
    of text, Boolean, or numbers. The value for a constant is static and cannot be
    changed after initial assignment. While the concept they represent is simple,
    constants, however, have some interesting properties that make them useful, especially
    when working with numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: Constant literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants are values that can be represented by a text literal in the language.
    One of the most interesting properties of constants is that their literal representations
    can either be treated as typed or untyped values. Unlike variables, which are
    intrinsically bound to a type, constants can be stored as untyped values in memory
    space. Without that type constraint, numeric constant values, for instance, can
    be stored with great precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The followings are examples of valid constant literal values that can be expressed
    in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Typed constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go constant values can be bound to named identifiers using a constant declaration.
    Similar to a variable declaration, Go uses the `const` keyword to indicate the
    declaration of a constant. Unlike variables, however, the declaration must include
    the literal value to be bound to the identifier, as shown in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*const <identifier list> type = <value list or initializer expressions>*'
  prefs: []
  type: TYPE_NORMAL
- en: Constants cannot have any dependency that requires runtime resolution. The compiler
    must be able to resolve the value of a constant at compile time. This means all
    constants must be declared and initialized with a value literal (or an expression
    that results to a constant value).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows some typed constants being declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/const.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the previous source snippet that each declared constant identifier
    is explicitly given a type. As you would expect, this implies that the constant
    identifier can only be used in contexts that are compatible with its types. However,
    the next section explains how this works differently when the type is omitted
    in the constant declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Untyped constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants are even more interesting when they are untyped. An untyped constant
    is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*const <identifier list> = <value list or initializer expression>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the keyword `const` is used to declare a list of identifiers as
    constants along with their respective bounded values. However, in this format,
    the type specification is omitted in the declaration. As an untyped entity, a
    constant is merely a blob of bytes in memory without any type precision restrictions
    imposed. The following shows some sample declarations of untyped constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/const.go
  prefs: []
  type: TYPE_NORMAL
- en: From the previous code snippet, the untyped constant `m2` is assigned a long
    decimal value (truncated to fit on the printed page as it goes another 17 digits).
    Constant `m4` is assigned a much larger number of `m3 x 1.0e+400`. The entire
    value of the resulting constant is stored in memory without any loss in precision.
    This can be an extremely useful tool for developers interested in computations
    where a high level of precision is important.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning untyped constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Untyped constant values are of limited use until they are assigned to variables,
    used as function parameters, or are part of an expression assigned to a variable.
    In a strongly-typed language like Go, this means there is a potential for some
    type adjustment to ensure that the value stored in the constant can be properly
    assigned to the target variable. One advantage of using untyped constants is that
    the type system relaxes the strict application of type checking. An untyped constant
    can be assigned to different, though compatible, types of different precision
    without any complaint from the compiler, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous snippet shows the untyped constant `m2` being assigned to two variables
    of different floating-point precisions, `u1` and `u2`, and to an untyped variable,
    `u3`. This is possible because constant `m2` is stored as a raw untyped value
    and can therefore be assigned to any variable compatible with its representation
    (a floating point).
  prefs: []
  type: TYPE_NORMAL
- en: 'While the type system will accommodate the assignment of `m2` to variables
    of different precision, the resulting assignment is adjusted to fit the variable
    type, as noted in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What about variable `u3`, which is itself an untyped variable? Since `u3` does
    not have a specified type, it will rely on type inference from the constant value
    to receive a type assignment. Recall from the discussion in the section *Omitting
    Variable Types* earlier, that constant literals are mapped to basic Go types based
    on their textual representations. Since constant `m2` represents a decimal value,
    the compiler will infer its default to be a `float64`, which will be automatically
    assigned to variable `u3`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Go's treatment of untyped raw constant literals increases the
    language's usability by automatically applying some simple, but effective, type
    inference rules without sacrificing type-safety. Unlike other languages, developers
    do not have to explicitly specify the type in the value literal or perform some
    sort of typecast to make this work.
  prefs: []
  type: TYPE_NORMAL
- en: Constant declaration block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have guessed, constant declarations, can be organized as code blocks
    to increase readability. The previous example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/const2.go
  prefs: []
  type: TYPE_NORMAL
- en: Constant enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One interesting usage of constants is to create enumerated values. Using the
    declaration block format (shown in the preceding section), you can easily create
    numerically increasing enumerated integer values. Simply assign the pre-declared
    constant value `iota` to a constant identifier in the declaration block, as shown
    in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/enum0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler will then automatically do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare each member in the block as an untyped integer constant value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize `iota` with a value of zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign `iota`, or zero, to the first constant member (`StarHyperGiant`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each subsequent constant is assigned an `int` value increased by one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So the previous list of constants would be assigned a sequence of values going
    from zero to nine. Whenever `const` appears as a declaration block, it resets
    the counter to zero. In the following snippet, each set of constants is enumerated
    from zero to four separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/enum1.go
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the default enumeration type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, an enumerated constant is declared as an untyped integer value.
    However, you can override the default type of the enumerated values by providing
    an explicit numeric type for your enumerated constants, as shown in the following
    code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can specify any numeric type that can represent integers or floating point
    values. For instance, in the preceding code sample, each constant will be declared
    as type `byte`.
  prefs: []
  type: TYPE_NORMAL
- en: Using iota in expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When `iota` appears in an expression, the same mechanism works as expected.
    The compiler will apply the expression for each successive increasing value of
    `iota`. The following example assigns even numbers to the enumerated members of
    the constant declaration block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/enum2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may expect, the previous example assigns an even value to each enumerated
    constants, starting with 0, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Skipping enumerated values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with enumerated constants, you may want to throw away certain
    values that should not be part of the enumeration. This can be accomplished by
    assigning iota to the blank identifier at the desired position in the enumeration.
    For instance, the following skips the values 0 and `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch02/enum3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we skip `iota` position `0`, the first assigned constant value is at
    position `1`. This results in expression `1 << iota` resolving to `1 << 1 = 2`.
    The same is done at the sixth position, where expression `1 << iota` returns `64`.
    That value will be skipped and not assigned to any constant, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Go operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staying true to its simplistic nature, operators in Go do exactly what you would
    expect, mainly, they allow operands to be combined into expressions. There are
    no hidden surprise behaviors with Go operators as there is no support for operator-overloading
    as found in C++ or Scala. This was a deliberate decision from the designers to
    keep the semantics of the language simple and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: This section explores the most common operators that you will encounter as you
    start with Go. Other operators are covered throughout other chapters of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table summarizes the arithmetic operators supported in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Operation** | **Compatible types** |'
  prefs: []
  type: TYPE_TB
- en: '| `*`, `/`, `-` | Multiplication, division, and subtraction | Integers, floating
    points, and complex numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Remainder | Integers |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition | Integers, floating points, complex numbers, and strings
    (concatenation) |'
  prefs: []
  type: TYPE_TB
- en: Note that the addition operator, `+`, can be applied to strings such as in the
    expression `var i = "G is" + " for Go"`. The two string operands are concatenated
    to create a new string that is assigned to variable `i`.
  prefs: []
  type: TYPE_NORMAL
- en: The increment and decrement operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with other C-like languages, Go supports the `++` (increment) and the `--`
    (decrement) operators. When applied, these operators increase, or decrease, the
    operand''s value by one, respectively. The following shows a function that uses
    the decrement operator to traverse the letters in string s in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the increment and decrement operators are statements,
    not expressions, as shown in the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, it is worth noting that the increment and decrement
    statements only support the postfix notation. The following snippet would not
    compile because of statement -`i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Go assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | The simple assignment works as expected. It updates the left operand
    with the value of the right. |'
  prefs: []
  type: TYPE_TB
- en: '| `:=` | The colon-equal operator declares a new variable, the left-side operator,
    and assigns it the value (and type) of the operand on the right. |'
  prefs: []
  type: TYPE_TB
- en: '| `+=`, `-=`, `*=`, `/=`, `%=` | Apply the indicated operation using the left
    and the right operator and store the result in the left operator. For instance,
    `a *= 8` implies `a = a * 8`. |'
  prefs: []
  type: TYPE_TB
- en: Bitwise operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go includes full support for manipulating values at their most elemental forms.
    The following summarizes bitwise operators supported by Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Bitwise AND |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Bitwise OR |'
  prefs: []
  type: TYPE_TB
- en: '| `a ^ b` | Bitwise XOR |'
  prefs: []
  type: TYPE_TB
- en: '| `&^` | Bitwise AND NOT |'
  prefs: []
  type: TYPE_TB
- en: '| `^a` | Unary bitwise complement |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Left-shift |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Right-shift |'
  prefs: []
  type: TYPE_TB
- en: The right operand, in a shift operation, must be an unsigned integer or be able
    to be converted to an unsigned value. When the left operand is an untyped constant
    value, the compiler must be able to derive a signed integer type from its value
    or it will fail compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The shift operators in Go also support both arithmetic and logical shifts. If
    the left operand is unsigned, Go automatically applies logical shift, whereas
    if it is signed, Go will apply an arithmetic shift.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of Go logical operations on Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All Go types can be tested for equality, including basic and composite types.
    However, only string, integer, and floating-point values can be compared using
    ordering operators, as is summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Operation** | **Supported type** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equal | String, numeric, Boolean, interface, pointer, and struct types
    |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Not Equal | String, numeric, Boolean, interface, pointer, and struct
    types |'
  prefs: []
  type: TYPE_TB
- en: '| `<`, `<=`, `>`, `>=` | Ordering operators | String, integers, and floating
    points |'
  prefs: []
  type: TYPE_TB
- en: Operator precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Go has fewer operators than are found in its counterparts such as C or
    Java, its operator precedence rules are far simpler. The following table lists
    Go''s operator precedence echelon, starting with the highest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Precedence** |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplicative | `*`, `/`, `%`, `<<`, `>>`, `&`, `&^` |'
  prefs: []
  type: TYPE_TB
- en: '| Additive | `+`, `-`, `&#124;`, `^` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparative | `==`, `!=`, `<`, `<=`, `>`, `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical AND | `&&` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical OR | `&#124;&#124;` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a lot of ground around the basic constructs of the Go language.
    It started with the structure of Go's source code text file and progressed to
    cover variable identifiers, declarations, and initializations. The chapter also
    provided extensive coverage of Go constants, constant declaration, and operators.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may feel a bit overwhelmed by so much pedestrian information
    about the language and its syntax. The good news is that you don't have to know
    all of these details to be productive with the language. In the following chapters,
    we will continue to explore some of the more interesting bits about Go, including
    data types, functions, and packages.
  prefs: []
  type: TYPE_NORMAL

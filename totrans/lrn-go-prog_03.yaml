- en: Chapter 3. Go Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go borrows several of its control flow syntax from the C-family of languages.
    It supports all of the expected control structures, including `if...else`, `switch`,
    `for` loop, and even `goto`. Conspicuously absent, though, are `while` or `do...while`
    statements. The following topics in this chapter examine Go''s control flow elements,
    some of which you may already be familiar with, and others that bring a new set
    of functionalities not found in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type `Switch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement, in Go, borrows its basic structural form from other C-like
    languages. The statement conditionally executes a code block when the Boolean
    expression that follows the `if` keyword evaluates to `true`, as illustrated in
    the following abbreviated program, which displays information about world currencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/ifstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement in Go looks similar to other languages. However, it sheds
    a few syntactic rules, while enforcing new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses around the test expression are not necessary. While the following
    `if` statement will compile, it is not idiomatic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The curly braces for the code block are always required. The following snippet
    will not compile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will compile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is idiomatic, however, to write the `if` statement on multiple lines (no
    matter how simple the statement block may be). This encourages good style and
    clarity. The following snippet will compile with no issues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preferred idiomatic layout for the statement is to use multiple
    lines, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement may include an optional `else` block, which is executed
    when the expression in the `if` block evaluates to `false`. The code in the `else`
    block must be wrapped in curly braces using multiple lines, as shown in the following
    snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `else` keyword may be immediately followed by another `if` statement forming
    an `if...else...if` chain, as used in the function `printCurr()` from the source
    code listed earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if...else...if` statement chain can grow as long as needed and may be
    terminated by an optional `else` statement to express all other untested conditions.
    Again, this is done in the `printCurr()` function, which tests four conditions
    using the `if...else...if` blocks. Lastly, it includes an `else` statement block
    to catch any other untested conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Go, however, the idiomatic, and cleaner, way to write such a deep `if...else...if`
    code block is to use an expressionless `switch` statement. This is covered later,
    in the *Switch statement* section.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if` statement supports a composite syntax where the tested expression
    is preceded by an initialization statement. At runtime, the initialization is
    executed before the test expression is evaluated, as illustrated in this code
    snippet (from the program listed earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The initialization statement follows normal variable declaration and initialization
    rules. The scope of the initialized variables is bound to the `if` statement block,
    beyond which they become unreachable. This is a commonly used idiom in Go and
    is supported in other flow control constructs covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also supports a `switch` statement similar to that found in other languages
    such as, C or Java. The `switch` statement in Go achieves multi-way branching
    by evaluating values or expressions from `case` clauses, as shown in the following,
    abbreviated, source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/switchstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `switch` statement in Go has some interesting properties and rules that
    make it easy to use and reason about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantically, Go''s `switch` statement can be used in two contexts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression`switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type`switch` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `break` statement can be used to escape out of a switch code block early.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement can include a default case when no other case expressions
    evaluate to a match. There can only be one default case and it may be placed anywhere
    within the switch block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expression switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expression switches are flexible and can be used in many contexts where control
    flow of a program needs to follow multiple path. An expression switch supports
    many attributes, as outlined in the following bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expression switches can test values of any types. For instance, the following
    code snippet (from the previous program listing) tests variable `Curr` of type
    `struct`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The expressions in `case` clauses are evaluated from left to right, top to bottom,
    until a value (or expression) is found that is equal to that of the `switch` expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon encountering the first case that matches the `switch` expression, the program
    will execute the statements for the `case` block and then immediately exit the
    `switch` block. Unlike other languages, the Go `case` statement does not need
    to use a break to avoid falling through the next case (see the *Fallthrough cases*
    section). For instance, calling `isDollar(Curr{"HKD", "Hong Kong Dollar", "Hong
    Kong", 344})` will match the second `case` statement in the preceding function.
    The code will set the result to `true` and exit the `switch` code block immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Case` clauses can have multiple values (or expressions) separated by commas
    with a logical `OR` operator implied between them. For instance, in the following
    snippet, the `switch` expression `curr` is tested against values `currencies[2]`,
    `currencies[4]`, or `currencies[10]`, using one case clause until a match is found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` statement is the cleaner and preferred idiomatic approach to writing
    complex conditional statements in Go. This is evident when the preceding snippet
    is compared to the following, which does the same comparison using `if` statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fallthrough cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no automatic *fall through* in Go''s `case` clause as there is in
    the C or Java `switch` statements. Recall that a `switch` block will exit after
    executing its first matching case. The code must explicitly place the `fallthrough`
    keyword, as the last statement in a `case` block, to force the execution flow
    to fall through the successive `case` block. The following code snippet shows
    a `switch` statement with a `fallthrough` in each case block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/switchstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When a case is matched, the `fallthrough` statements cascade down to the first
    statement of the successive `case` block. So, if `curr = Curr{"AUD", "Australian
    Dollar", "Australia", 36}`, the first case will be matched. Then the flow cascades
    down to the first statement of the second case block, which is also a `fallthrough`
    statement. This causes the first statement, to return `true`, of the third case
    block to execute. This is functionally equivalent to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Expressionless switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports a form of the `switch` statement that does not specify an expression.
    In this format, each `case` expression must evaluate to a Boolean value `true`.
    The following abbreviated source code illustrates the uses of an expressionless
    `switch` statement, as listed in function `find()`. The function loops through
    the slice of `Curr` values to search for a match based on field values in the
    `struct` function that''s passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/switchstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the previous example, the `switch` statement in function `find()`
    does not include an expression. Each `case` expression is separated by a comma
    and must be evaluated to a Boolean value with an implied `OR` operator between
    each. The previous `switch` statement is equivalent to the following use of an
    `if` statement to achieve the same logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Switch initializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` keyword may be immediately followed by a simple initialization
    statement where variables, local to the `switch` code block, may be declared and
    initialized. This convenient syntax uses a semi-colon between the initializer
    statement and the `switch` expression to declare variables, which may appear anywhere
    in the `switch` code block. The following code sample shows how this is done by
    initializing two variables, `name` and `curr`, as part of the `switch` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/switchstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet uses an expressionless `switch` statement with an
    initializer. Notice the trailing semi-colon to indicate the separation between
    the initialization statement and the expression area for the switch. In the example,
    however, the `switch` expression is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Type switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given Go's strong type support, it should be of little surprise that the language
    supports the ability to query type information. The type `switch` is a statement
    that uses the Go interface type to compare the underlying type information of
    values (or expressions). A full discussion on interface types and type assertion
    is beyond the scope of this section. You can find more details on the subject
    in [Chapter 8](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods,
    Interfaces, and Objects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, for the sake of completeness, a short discussion on type switches
    is provided here. For now, all you need to know is that Go offers the type `interface{}`,
    or empty interface, as a super type that is implemented by all other types in
    the type system. When a value is assigned type `interface{}`, it can be queried
    using the type `switch`, as shown in function `findAny()` in the following code
    snippet, to query information about its underlying type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/switchstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `findAny()` takes an `interface{}` as its parameter. The type
    `switch` is used to determine the underlying type and value of the variable `val`
    using the type assertion expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the keyword `type` in the preceding type assertion expression.
    Each case clause will be tested against the type information queried from `val.(type)`.
    Variable `i` will be assigned the actual value of the underlying type and is used
    to invoke a function with the respective value. The default block is invoked to
    guard against any unexpected type assigned to the parameter `val` parameter. Function
    `findAny` may then be invoked with values of diverse types, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The for statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a language related to the C-family, Go also supports `for` loop style control
    structures. However, as you may have come to expect by now, Go''s `for` statements
    work interestingly differently and simply. The `for` statement in Go supports
    four distinct idioms, as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **For Statement** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| For condition | Used to semantically replace `while` and `do...while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Infinite loop | The conditional expression may be omitted to create an infinite
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Traditional | This is the traditional form of the C-family `for` loop with
    the initializer, test, and update clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| For range | Used to iterate over an expression representing a collection
    of items stored in an array, string (array of rune), slice, map, and channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Notice, as with all other control statements in Go, the `for` statements do
    not use parentheses around their expressions. All statements for the loop code
    block must be enclosed within curly brackets or the compiler will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: For condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` condition uses a construct that is semantically equivalent to the
    `while` loop found in other languages. It uses the keyword `for`, followed by
    a Boolean expression that allows the loop to proceed as long as it is evaluated
    to true. The following abbreviated source listing shows an example of this form
    of the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/forstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: The `for` statement, in function `listCurrs()`, iterates as long as the conditional
    expression `i < len(currencencies)` returns `true`. Care must be taken to ensure
    the value of `i` is updated with each iteration to avoid creating an accidental
    infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the Boolean expression is omitted in the `for` statement, the loop runs
    indefinitely, as shown the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to the `for(;;)` or the `while (true)` found in other languages,
    such as C or Java.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional for statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go also supports the traditional form of the `for` statement, which includes
    an initialization statement, a conditional expression, and an update statement,
    all separated by a semi-colon. This is the form of the statement that is traditionally
    found in other C-like languages. The following source snippet illustrates the
    use of a traditional for statement in the function `sortByNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/forstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example implements a selection sort that sorts the `slice` currencies
    by comparing the `Number` field of each `struct` value. The different sections
    of the `for` statement are highlighted using the following snippet of code (from
    the preceding function):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The traditional for statement](img/B03676_For-Loop.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **For statement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/forstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  prefs: []
  type: TYPE_NORMAL
- en: The for range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, the `for` statement supports one additional form that uses the keyword
    `range` to iterate over an expression that evaluates to an array, slice, map,
    string, or channel. The for-range loop has this generic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for [<identifier-list> :=] range <expression> { ... }*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the type produced by the `range` expression, there can be up to
    two variables emitted by each iteration, as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Range Expression** | **Range Variables** |'
  prefs: []
  type: TYPE_TB
- en: '| Loop over array or slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| The range produces two values, where `i` is the loop index and `v` is the
    value `v[i]` from the collection. Further discussions on array and slice are covered
    in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite Types*. |'
  prefs: []
  type: TYPE_TB
- en: '| Loop over string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| The range produces two values, where `i` is the index of byte in the string
    and `v` is the value of the UTF-8 encoded byte at `v[i]` returned as a rune. Further
    discussion on the string type is covered in in [Chapter 4](ch04.html "Chapter 4. Data
    Types"), *Data Types*. |'
  prefs: []
  type: TYPE_TB
- en: '| Loop over map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| The `range` produces two values, where `k` is assigned the value of the map
    key of type `K` and `v` gets stored at `map[k]` of type `V`. Further discussion
    on map is covered in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite
    Types*. |'
  prefs: []
  type: TYPE_TB
- en: '| Loop on channel values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '| An adequate discussion of channels is covered in [Chapter 9](ch09.html "Chapter 9. Concurrency"),
    *Concurrency*. A channel is a two-way conduit able to receive and emit values.
    The `for...range` statement assigns each value received from the channel to variable
    `c` with each iteration. |'
  prefs: []
  type: TYPE_TB
- en: 'You should be aware that the value emitted with each iteration is a copy of
    the original item stored in the source. For instance, in the following program,
    the values in the slice do not get updated after the loop completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To update the original value using the `for...range` loop, use the index expression
    to access the original value, as illustrated in the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, value `i` is used in a slice index expression  `vals[i]`
    to update the original value stored in the slice. It is possible to omit the iteration
    value (the second variable in the assignment) if you only need access to the index
    value of an array, slice, or string (or key for a map). For instance, in the following
    example, the `for...range` statement only emits the current index value with each
    iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/for-range-stmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are some situations where you may not be interested in any of
    the values generated by the iteration, but rather the iteration mechanic itself.
    The next form of the for statement was introduced (as of Version 1.4 of Go) to
    express a for range without any variable declaration as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will print `"Looping"` four times on the standard output.
    This form of the `for...range` loop is used sometimes when the range expression
    is over a channel. It is used to simply notify of the presence of a value in the
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: The break, continue, and goto statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go supports a group of statements designed specifically to exit abruptly out
    of a running code block, such as switch and for statement, and transfer control
    to a different section of the code. All three statements can accept a label identifier
    that specifies a targeted location in the code where control is to be transferred.
  prefs: []
  type: TYPE_NORMAL
- en: The label identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the core of this section, it is worthwhile to look at the
    label used by these statements. Declaring a label in Go requires an identifier
    followed by a colon, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Naming your label is a matter of style. However, one should follow the identifier
    naming guidelines covered in the previous chapter. A label must be enclosed within
    a function. The Go compiler will not allow unused labels to dangle in the code.
    Similar to variables, if a label is declared, it must be referenced in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other C-like languages, the Go `break` statement terminates and exits
    the innermost enclosing `switch` or `for` statement code block and transfers control
    to another part of the running program. The `break` statement can accept an optional
    label identifier specifying a labeled location, in the enclosing function, where
    the flow of the program will resume. Here are some attributes of the label for
    the `break` statement to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: The label must be declared within the same running function where the `break`
    statement is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declared label must be followed immediately by the enclosing control statement
    (a `for` loop or `switch` statement) where the break is nested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a `break` statement is followed by a label, control is transferred, not to
    the location where the label is, but rather to the statement immediately following
    the labeled block. If a label is not provided, the `break` statement abruptly
    exits and transfers control to the next statement following its enclosing `for`
    statement (or `switch` statement) block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an overly exaggerated linear search that illustrates
    the working of the `break` statement. It does a word search and exits once the
    first instance of the word is found in the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/breakstmt.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code snippet, the `break DoSearch` statement will essentially
    exit out of the innermost `for` loop and cause the execution flow to continue
    after the outermost labeled `for` statement, which in this example, will simply
    end the program.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `continue` statement causes the control flow to immediately terminate the
    current iteration of the enclosing `for` loop and jump to the next iteration.
    The `continue` statement can take an optional label as well. The label has similar
    properties to that of the `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: The label must be declared within the same running function where the `continue`
    statement is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declared label must be followed immediately by an enclosing `for` loop statement
    where the continue statement is nested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When present, the `continue` statement is reached within a `for` statement block,
    the `for` loop will be abruptly terminated and control will be transferred to
    the outermost labeled `for` loop block for continuation. If a label is not specified,
    the `continue` statement will simply transfer control to the start of its enclosing
    `for` loop block for continuation of the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let us revisit the previous example of word search. This version
    uses a `continue` statement, which causes the search to find multiple occurrences
    of the searched word in the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/breakstmt2.go
  prefs: []
  type: TYPE_NORMAL
- en: The `continue DoSearch` statement causes the current iteration of the innermost
    loop to stop and transfer control to the labeled outer loop, causing it to continue
    with the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The goto statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `goto` statement is more flexible, in that it allows flow control to be
    transferred to an arbitrary location, inside a function, where a target label
    is defined. The `goto` statement causes an abrupt transfer of control to the label
    referenced by the `goto` statement. The following shows Go''s `goto` statement
    in action in a simple, but functional example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch03/gotostmt.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The code uses the `goto` statement to jump to different sections of the `main()`
    function. Notice that the `goto` statement can target labels defined anywhere
    in the code. The superfluous usage of the `Start:` label is left in the code for
    completeness and is not necessary in this context (since continue, without the
    label, would have the same effect). The following provides some guidance when
    using the `goto` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using the `goto` statement unless the logic being implemented can only
    be achieved using `goto` branching. This is because overuse of the `goto` statement
    can make code harder to reason about and debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place `goto` statements and their targeted label within the same enclosing code
    block when possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid placing labels where a `goto` statement will cause the flow to skip new
    variable declarations or cause them to be re-declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go will let you jump from inner to outer enclosing code blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a compilation error if you try to jump to a peer or to an enclosing code
    block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a walkthrough of the mechanism of control flow in Go,
    including `if`, `switch`, and `for` statements. While Go's flow control constructs
    appear simple and easy to use, they are powerful and implement all branching primitives
    expected of a modern language. Readers are introduced to each concept with ample
    detail and examples to ensure clarity of the topics. The next chapter continues
    our look into Go fundamentals by introducing the reader to the Go type systems.
  prefs: []
  type: TYPE_NORMAL

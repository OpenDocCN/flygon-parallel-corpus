- en: Chapter 5. Functions in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of Go''s syntactical *tour de force* is via its support for higher-order
    functions as is found in dynamic languages such as Python or Ruby. As we will
    see in this chapter, a function is also a typed entity with a value that can be
    assigned to a variable. In this chapter, we are going to explore functions in
    Go covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameter values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error signaling handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function panic and recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, functions are first-class, typed programming elements. A declared function
    literal always has a type and a value (the defined function itself) and can optionally
    be bound to a named identifier. Because functions can be used as data, they can
    be assigned to variables or passed around as parameters of other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring a function in Go takes the general form illustrated in the following
    figure. This canonical form is used to declare named and anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Function declaration](img/B03676_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most common form of function definition in Go includes the function's assigned
    identifier in the function literal. To illustrate this, the following table shows
    the source code of several programs with definitions of named functions with different
    combinations of parameters and return types.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/func0.go | A function with the name identifier `printPi`. It
    takes no parameter and returns no values. Notice when there is nothing to return,
    the `return` statement is optional. |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/func1.go | A function named `avogadro.` It takes no parameter
    but returns a value of type `float64`. Notice the `return` statement is required
    when a return value is declared as part of the function's signature. |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/func2.go | This defines the function `fib`. It takes parameter
    `n` of type `int` and prints the Fibonacci sequence for up to `n`. Again, nothing
    to return, therefore the `return` statement is omitted. |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/func3.go | The last example defines the `isPrime` function.
    It takes a parameter of type `int` and returns a value of type `bool`. Since the
    function is declared to return a value of type `bool`, the last logical statement
    in the execution flow must be a `return` statement that returns a value of the
    declared type. |
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Function signature**'
  prefs: []
  type: TYPE_NORMAL
- en: The set of specified parameter types, result types, and the order in which those
    types are declared is known as the signature of the function. It is another unique
    characteristic that help identify a function. Two functions may have the same
    number of parameters and result values; however, if the order of those elements
    are different, then the functions have different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: The function type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, the name identifier, declared in a function literal, is used to invoke
    the function using an invocation expression whereby the function identifier is
    followed by a parameter list. This is what we have seen throughout the book so
    far and it is illustrated in the following example calling the `fib` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When, however, a function''s identifier appears without parentheses, it is
    treated as a regular variable with a type and a value as shown in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/functype.go
  prefs: []
  type: TYPE_NORMAL
- en: The type of a function is determined by its signature. Functions are considered
    to be of the same type when they have the same number of arguments with the same
    types in the same order. In the previous example the `opAdd` variable is declared
    having the type `func (int, int) int` . This is the same signature as the declared
    functions `add` and `sub`. Therefore, the `opAdd` variable is assigned the `add`
    function variable. This allows `opAdd` to be invoked as you would invoke the `add`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The same is done for the  `opSub` variable. It is assigned the value represented
    by the function identifier `sub` and type `func (int, int)`. Therefore, `opSub(99,13)`
    invokes the second function, which returns the result of a subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last parameter of a function can be declared as **variadic** (**variable
    length arguments**) by affixing ellipses (`…`) before the parameter's type. This
    indicates that zero or more values of that type may be passed to the function
    when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example implements two functions that accept variadic parameters.
    The first function calculates the average of the passed values and the second
    function sums up the numbers passed in as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcvariadic.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler resolves the variadic parameter as a slice of type `[]float64`
    in both the preceding functions. The parameter values can then be accessed using
    a slice expression as shown in the previous example. To invoke functions with
    variadic arguments, simply provide a comma-separated list of values that matches
    the specified type as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When no parameters are provided, the function receives an empty slice. The
    astute reader may be wondering, "Is it possible to pass in an existing slice of
    values as variadic arguments?" Thankfully, Go provides an easy idiom to handle
    such a case. Let''s examine the call to the  `sum` function in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A slice of floating-point values is declared and stored in variable `points`.
    The slice can be passed as a variadic parameter by adding ellipses to the parameter
    in the `sum(points...)` function call.
  prefs: []
  type: TYPE_NORMAL
- en: Function result parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go functions can be defined to return one or more result values. So far in the
    book, most of the functions we have encountered have been defined to return a
    single result value. In general, a function is able to return a list of result
    values, with diverse types, separated by a comma (see the previous section, *Function
    declaration*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this concept, let us examine the following simple program which
    defines a function that implements an Euclidian division algorithm (see [http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)).
    The `div` function returns both the quotient and the remainder values as its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcret0.go
  prefs: []
  type: TYPE_NORMAL
- en: The `**return**` keyword is followed by the number of result values matching
    (respectively) the declared results in the function's signature. In the previous
    example, the signature of the `div` function specifies two `int` values to be
    returned as result values. Internally, the function defines `int` variables `p`
    and `r` that are returned as result values upon completion of the function. Those
    returned values must match the types defined in the function's signature or risk
    compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions with multiple result values must be invoked in the proper context:'
  prefs: []
  type: TYPE_NORMAL
- en: They must be assigned to a list of identifiers of the same types respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only be included in expressions that expect the same number of returned
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is illustrated in the following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Named result parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, the result list of a function''s signature can be specified using
    variable identifiers along with their types. When using named identifiers, they
    are passed to the function as regular declared variables and can be accessed and
    modified as needed. Upon encountering a `return` statement, the last assigned
    result values are returned. This is illustrated in the following source snippet,
    which is a rewrite of the previous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcret1.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `return` statement is naked; it omits all identifiers. As stated
    earlier, the values assigned in `q` and `r` will be returned to the caller. For
    readability, consistency, or style, you may elect not to use a naked `return`
    statement. It is perfectly legal to attach the identifier's name with the `return`
    statement (such as `return q, r`) as before.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameter values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, all parameters passed to a function are done so by value. This means
    a local copy of the passed values is created inside the called function. There
    is no inherent concept of passing parameter values by reference. The following
    code illustrates this mechanism by modifying the value of the passed parameter,
    `val`, inside the `dbl` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcpassbyval.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program runs, it produces the following output that chronicles the
    state of the `p` variable before it is passed to the `dbl` function. The update
    is made locally to the passed parameter variable inside the `dbl` function, and
    lastly the value of the `p` variable after the `dbl` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that the original value assigned to variable `p`
    remains variable unchanged, even after it is passed to a function that seems to
    update its value internally. This is because the `val` parameter in the `dbl`
    function receives a local copy of the passed parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving pass-by-reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcpassbyref.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions and Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can be written as literals without a named identifier. These are
    known as anonymous functions and can be assigned to a variable to be invoked later
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcs.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous program shows two anonymous functions declared and bound to the
    `mul` and `sqr` variables. In both cases, the functions take in parameters and
    return a value. Later in `main()`, the variables are used to invoke the function
    code bound to them.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking anonymous function literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is worth noting that an anonymous function does not have to be bound to
    an identifier. The function literal can be evaluated, in place, as an expression
    that returns the function''s result. This is done by ending the function literal
    with a list of argument values, enclosed in parentheses, as shown in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funcs.go
  prefs: []
  type: TYPE_NORMAL
- en: The literal format not only defines the anonymous function, but also invokes
    it. For instance, in the following snippet (from the previous program), the anonymous
    function literal is nested as a parameter to `fmt.Printf()`. The function itself
    is defined to accept a parameter and returns a value of type `float64`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since the function literal ends with a parameter list enclosed within parentheses,
    the function is invoked as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go function literals are closures. This means they have lexical visibility
    to non-local variables declared outside of their enclosing code block. The following
    example illustrates this fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: github.com/vladimirvivien/learning-go/ch05/funcs.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous program, the function literal code block, `func() float64 {return
    deg * math.Pi / 180}()`, is defined as an expression that converts degrees to
    radians. With each iteration of the loop, a closure is formed between the enclosed
    function literal and the outer non-local variable, `i`. This provides a simpler
    idiom where the function naturally accesses non-local values without resorting
    to other means such as pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go, lexically closed values can remain bounded to their closures long after
    the outer function that created the closure has gone out of scope. The garbage
    collector will handle cleanups as these closed values become unbounded.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already established that Go functions are values bound to a type. So,
    it should not be a surprise that a Go function can take another function as a
    parameter and also return a function as a result value. This describes the notion
    known as a higher-order function, which is a concept adopted from mathematics.
    While types such as `struct` let programmers abstract data, higher-order functions
    provide a mechanism to encapsulate and abstract behaviors that can be composed
    together to form more complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this concept clearer, let us examine the following program, which uses
    a higher-order function, `apply`, to do three things. It accepts a slice of integers
    and a function as parameters. It applies the specified function to each element
    in the slice. Lastly, the `apply` function also returns a function as its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/funchighorder.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the program, the `apply` function is invoked with an anonymous function
    that halves each element in the slice as highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As a higher-order function, `apply` abstracts the transformation logic which
    can be provided by any function of type `func(i int) int`, as shown next. Since
    the `apply` function returns a function, the variable `result` can be invoked
    as shown in the previous snippet.
  prefs: []
  type: TYPE_NORMAL
- en: As you explore this book, and the Go language, you will continue to encounter
    usage of higher-order functions. It is a popular idiom that is used heavily in
    the standard libraries. You will also find higher-order functions used in some
    concurrency patterns to distribute workloads (see [Chapter 9](ch09.html "Chapter 9. Concurrency"),
    *Concurrency*).
  prefs: []
  type: TYPE_NORMAL
- en: Error signaling and handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, let us address how to idiomatically signal and handle errors
    when you make a function call. If you have worked with languages such as Python,
    Java, or C#, you may be familiar with interrupting the flow of your executing
    code by throwing an exception when an undesirable state arises.
  prefs: []
  type: TYPE_NORMAL
- en: As we will explore in this section, Go has a simplified approach to error signaling
    and error handling that puts the onus on the programmer to handle possible errors
    immediately after a called function returns. Go discourages the notion of interrupting
    an execution by indiscriminately short-circuiting the executing program with an
    exception in the hope that it will be properly handled further up the call stack.
    In Go, the traditional way of signaling errors is to return a value of type `error`
    when something goes wrong during the execution of your function. So let us take
    a closer look how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Signaling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand what has been described in the previous paragraph, let
    us start with an example. The following source code implements an anagram program,
    as described in Column 2 from Jon Bentley's popular *Programming Pearls* book
    (second edition). The code reads a dictionary file (`dict.txt`) and groups all
    words with the same anagram. If the code does not quite make sense, please see
    [golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go) for
    an annotated explanation of how each part of the program works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyiy/ch05/anagram1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, if you want a more detail explanation of the previous program, take
    a look at the link supplied earlier. The focus here is on error signaling used
    in the previous program. As a convention, Go code uses the built-in type `error`
    to signal when an error occurred during execution of a function. Therefore, a
    function must return a value of type error to indicate to its caller that something
    went wrong. This is illustrated in the following snippet of the `load` function
    (extracted from the previous example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `load` function returns multiple result parameters. One is
    for the expected value, in this case `[]string`, and the other is the error value.
    Idiomatic Go dictates that the programmer returns a non-nil value for result of
    type `error` to indicate that something abnormal occurred during the execution
    of the function. In the previous snippet, the `load` function signals an error
    occurrence to its callers in two possible instances:'
  prefs: []
  type: TYPE_NORMAL
- en: when the expected filename (`fname`) is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when the call to `os.Open()` fails (for example, permission error, or otherwise)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, when a filename is not provided, the code returns an error
    using `errors.New()` to create a value of type `error` to exit the function. In
    the second case, the `os.Open` function returns a pointer representing the file
    and an error assigned to the `file` and `err` variables respectively. If `err`
    is not `nil` (meaning an error was generated), the execution of the `load` function
    is halted prematurely and the value of `err` is returned to be handled by the
    calling function further up the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When returning an error for a function with multiple result parameters, it is
    customary to return the zero-value for the other (non-error type) parameters.
    In the example, a value of `nil` is returned for the result of type `[]string`.
    While not necessary, it simplifies error handling and avoids any confusion for
    function callers.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As described previously, signaling of an erroneous state is as simple as returning
    a non-nil value, of type `error`, during execution of a function. The caller may
    choose to handle the `error` or `return` it for further evaluation up the call
    stack as was done in the `load` function. This idiom forces errors to propagate
    upwards until they are handled at some point. The next snippet shows how the error
    generated by the `load` function is handled in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since the `main` function is the topmost caller in the call stack, it handles
    the error by terminating the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: This is all there is to the mechanics of error handling in Go. The language
    forces the programmer to always test for an erroneous state on every function
    call that returns a value of the type `error`. The `if…not…nil error` handling
    idiom may seem excessive and verbose to some, especially if you are coming from
    a language with formal exception mechanisms. However, the gain here is that the
    program can construct a robust execution flow where programmers always know where
    errors may come from and handle them appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The error type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `error` type is a built-in interface and, therefore must be implemented
    before it can be used. Fortunately, the Go standard library comes with implementations
    ready to be used. We have already used one of the implementation from the package,
    `errors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create parameterized error values using the `fmt.Errorf` function
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/anagram2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also idiomatic to assign error values to high-level variables so they
    can be reused throughout a program as needed. The following snippet pulled from
    [http://golang.org/src/os/error.go](http://golang.org/src/os/error.go) shows the
    declaration of reusable errors associated with OS file operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own implementation of the `error` interface to create
    custom errors. This topic is revisited in [Chapter 7](ch08.html "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces, and Objects* where the book discusses
    the notion of extending types.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring function calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go supports the notion of deferring a function call. Placing the keyword `defer`
    before a function call has the interesting effect of pushing the function unto
    an internal stack, delaying its execution right before the enclosing function
    returns. To better explain this, let us start with the following simple program
    that illustrates the use of `defer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/defer1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example defines the `do` function that takes variadic parameter
    `steps`. The function defers the statement with `defer fmt.Println("All done!")`.
    Next, the function loops through slice `steps` and defers the output of each element
    with `defer fmt.Println(s).` The last statement in the function `do` is a non-deferred
    call to `fmt.Println("Starting").` Notice the order of the printed string values
    when the program is executed, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple facts that explain the reverse order of the printout. First,
    recall that deferred functions are executed right before their enclosing function
    returns. Therefore, the first value printed is generated by the last non-deferred
    method call. Next, as stated earlier, deferred statements are pushed into a stack.
    Therefore, deferred calls are executed using a last-in-first-out order. That is
    why `"All done!"` is the last string value printed in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Using defer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `defer` keyword modifies the execution flow of a program by delaying function
    calls. One idiomatic usage for this feature is to do a resource cleanup. Since
    defer will always get executed when the surrounding function returns, it is a
    good place to attach cleanup code such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Closing open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing network resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing the Go channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing database transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And do on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate, let us return to our anagram example from earlier. The following
    code snippet shows a version of the code where defer is used to close the file
    after it has been loaded. The `load` function calls `file.Close()` right before
    it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/anagram2.go
  prefs: []
  type: TYPE_NORMAL
- en: The pattern of opening-defer-closing resources is widely used in Go. By placing
    the deferred intent immediately after opening or creating a resource allows the
    code to read naturally and reduces the likeliness of creating a resource leakage.
  prefs: []
  type: TYPE_NORMAL
- en: Function panic and recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the chapter, it was stated that Go does not have the traditional
    exception mechanism offered by other languages. Nevertheless, in Go, there is
    a way to abruptly exit an executing function known as function panic. Conversely,
    when a program is panicking, Go provides a way of recovering and regaining control
    of the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: Function panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During execution, a function may panic because of any one of following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly calling the **panic** built-in function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a source code package that panics due to an abnormal state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a nil value or an out-of-bound array element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency deadlock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a function panics, it aborts and executes its deferred calls. Then its
    caller panics, causing a chain reaction as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Function panic](img/B03676_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The panic sequence continues all the way up the call stack until the `main`
    function is reached and the program exits (crashes). The following source code
    snippet shows a version of the anagram program that will cause an explicit panic
    if an output anagram file already exists when it tries to create one. This is
    done illustratively to cause the `write` function to panic when there is a file
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/anagram2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding snippet, the `write` function calls the `panic` function if
    `os.OpenFile()` method errors out. When the program calls the `main` function,
    if there is an output file already in the working directory, the program will
    panic and crash as shown in the following stack trace, indicating the sequence
    of calls that caused the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Function panic recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a function panics, as explained earlier, it can crash an entire program.
    That may be the desired outcome depending on your requirements. It is possible,
    however, to regain control after a panic sequence has started. To do this, Go
    offers the built-in function called `recover`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recover works in tandem with panic. A call to function recover returns the
    value that was passed as an argument to panic. The following code shows how to
    recover from the panic call that was introduced in the previous example. In this
    version, the write function is moved inside `makeAnagram()` for clarity. When
    the `write` function is invoked from `makeAnagram()` and fails to open a file,
    it will panic. However, additional code is now added to recover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch05/anagram3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to recover from an unwinding panic sequence, the code must make
    a deferred call to the recover function. In the previous code, this is done in
    the `makeAnagrams` function by wrapping `recover()` inside an anonymous function
    literal, as highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the deferred `recover` function is executed, the program has an opportunity
    to regain control and prevent the panic from crashing the running program. If
    `recover()` returns `nil`, it means there is no current panic unwinding up the
    call stack or the panic was already handled downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now when the program is executed, instead of crashing with a stack trace,
    the program recovers and gracefully displays the issue as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering why we are using a `nil` to test the value returned by
    the `recover` function when a string was passed inside the call to `panic`. This
    is because both panic and recover take an empty interface type. As you will learn,
    the empty interface type is a generic type with the ability to represent any type
    in Go's type system. We will learn more about the empty interface in [Chapter
    7](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces
    and Objects* during discussions about interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented its reader with an exploration of Go functions. It started
    with an overview of named function declarations, followed by a discussion on function
    parameters. The chapter delved into a discussion of function types and function
    values. The last portion of the chapter discussed the semantics of error handling,
    panic, and recovery. The next chapter continues the discussion of functions; however,
    it does so within the context of Go packages. It explains the role of a package
    as a logical grouping of Go functions (and other code elements) to form sharable
    and callable code modules.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 6. Go Packages and Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Functions in Go"), *Functions in Go* covered
    functions, the elementary level of abstraction for code organization that makes
    code addressable and reusable. This chapter continues up the ladder of abstraction
    with a discussion centered around Go packages. As will be covered in detail here,
    a package is a logical grouping of language elements stored in source code files
    that can be shared and reused, as covered in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to other languages, Go source code files are grouped into compilable
    and sharable units known as packages. However, all Go source files must belong
    to a package (there is no such notion as a default package). This strict approach
    allows Go to keep its compilation rules and package resolution rules simple by
    favoring convention over configuration. Let us take a deep dive into the fundamentals
    of packages, their creation, use, and recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Go package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into package creation and use, it is crucial to take a high-level
    view of the concept of packages to help steer the discussion later. A Go package
    is both a physical and a logical unit of code organization used to encapsulate
    related concepts that can be reused. By convention, a group of source files stored
    in the same directory are considered to be part of the same package. The following
    illustrates a simple directory tree, where each directory represents a package
    containing some source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06-foo
  prefs: []
  type: TYPE_NORMAL
- en: 'While not a requirement, it is a recommended convention to set a package''s
    name, in each source file, to match the name of the directory where the file is
    located. For instance, source file `blat.go` is declared to be part of package
    `foo`, as shown in the following code, because it is stored in directory named
    `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06-foo/foo/blat.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Files `quux.go` and `qux.go` are both part of package `bazz` since they are
    located in a directory with that name, as shown in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06-foo/foo/bazz/quux.go |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06-foo/foo/bazz/qux.go |
  prefs: []
  type: TYPE_NORMAL
- en: The workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important concept to understand when discussing packages is that of
    the *Go * *workspace*. The workspace is simply an arbitrary directory that serves
    as a namespace used to resolved packages during certain tasks such as compilation.
    By convention, Go tools expect three specifically named subdirectories in a workspace
    directory: `src`, `pkg`, and `bin`. These subdirectories store Go source files
    along with all built package artifacts respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Establishing a static directory location where Go packages are kept together
    has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple setup with near-zero configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast compilation by reducing code search to a known location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools can easily create source graph of code and package artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic inference and resolution of transitive dependencies from source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup can be made portable and easily distributable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a partial (and simplified) tree layout of my Go workspace
    on my laptop with the three subdirectories, `bin`, `pkg`, and `src`, highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Sample workspace directory
  prefs: []
  type: TYPE_NORMAL
- en: '`bin`: This is an auto-generated directory that stores compiled Go executable
    artifacts (also known as programs or commands). When Go tools compile and install
    executable packages, they are placed in this directory. The previous sample workspace
    shows two binaries listed `circ` and `golint`. It is a recommended practice to
    add this directory to your operating system''s `PATH` environment variable to
    make your command available locally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pkg`: This directory is also auto-generated to store built package artifacts.
    When the Go tools build and install non-executable packages, they are stored as
    object files (with `.a` suffix) in subdirectories with name patterns based on
    the targeted operating system and architecture. In the sample workspace, the object
    files are placed under subdirectory `linux_amd64`, which indicates that the object
    files in this directory were compiled for the Linux operating system running on
    a 64-bit architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: This is a user-created directory where the Go source code files are
    stored. Each subdirectory under `src` is mapped to a package. *src* is the root
    directory from which all import paths are resolved. The Go tools search that directory
    to resolve packages referenced in your code during compilation or other activities
    that depend on the source path. The sample workspace in the previous figure shows
    two packages: `github.com/golang/lint/golint/` and `github.com/vladimirvivien/learning-go/ch06/current`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering about the `github.com` prefix in the package path shown
    in the workspace example. It is worth noting there are no naming requirements
    for the package directories (see the *Naming packages* section). A package can
    have any arbitrary name. However, Go recommends certain conventions that help
    with global namespace resolution and package organization.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a workspace is as simple as setting an operating system environment
    named `GOPATH` and assigning to it the root path of the location of the workspace
    directory. On a Linux machine, for instance, where the root directory for the
    workspace is `/home/username/Go`, the workspace would be set as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When setting up the `GOPATH` environment variable, it is possible to specify
    multiple locations where packages are stored. Each directory is separated by an
    OS-dependent path delimiter character (in other words, colon for Linux/Unix, semi-colon
    for Windows) as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Go tools will search all listed locations in the `GOPATH` when resolving
    package names. The Go compiler will, however, only store compiled artifacts, such
    as object and binary files, in the first directory location assigned to `GOPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability to configure your workspace by simply setting an OS environmental
    variable has tremendous advantages. It gives developers the ability to dynamically
    set the workspace at compile time to meet certain workflow requirements. For instance,
    a developer may want to test an unverified branch of code prior to merging it.
    He or she may want to set up a temporary workspace to build that code as follows
    (Linux): `$> GOPATH=/temporary/go/workspace/path go build`'
  prefs: []
  type: TYPE_NORMAL
- en: The import path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving on to the detail of setting up and using packages, one last important
    concept to cover is the notion of an *import path*. The relative path of each
    package, under workspace path `$GOPATH/src`, constitutes a global identifier known
    as the package's `import path`. This implies that no two packages can have the
    same import path values in a given workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go back to our simplified directory tree from earlier. For instance,
    if we set the workspace to some arbitrary path value such as `GOPATH=/home/username/Go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the sample workspace illustrated above, the directory path of the packages
    is mapped to their respective import paths as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory Path** | **Import Path** |'
  prefs: []
  type: TYPE_TB
- en: '| `/home/username/Go/foo` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/home/username/Go/foo/bar` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/home/username/Go/foo/bar/bazz` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Creating packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the chapter has covered the rudimentary concepts of the Go package;
    now it is time to dive deeper and look at the creation of Go code contained in
    packages. One of the main purposes of a Go package is to abstract out and aggregate
    common logic into sharable code units. Earlier in the chapter, it was mentioned
    that a group of Go source files in a directory is considered to be a package.
    While this is technically true, there is more to the concept of a Go package than
    just shoving a bunch of files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help illustrate the creation of our first packages, we will enlist the use
    of example source code found in [github.com/vladimirvivien/learning-go/ch06](https://github.com/vladimirvivien/learning-go/ch06).
    The code in that directory defines a set of functions to help calculate electrical
    values using *Ohm''s Law*. The following shows the layout of the directories that
    make up the packages for the example (assuming they are saved in some workspace
    directory `$GOPATH/src`):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Package layout for Ohm's Law example
  prefs: []
  type: TYPE_NORMAL
- en: 'Each directory, in the previous tree, contains one or more Go source code files
    that define and implement the functions, and other source code elements, that
    will be arranged into packages and be made reusable. The following table summarizes
    the import paths and package information extracted from preceding workspace layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Import Path** | **Package** |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**current**" | `current` |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power**" | `power` |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power/ir**" | `ir` |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**power/vr**" | `vr` |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**resistor**" | `resistor` |'
  prefs: []
  type: TYPE_TB
- en: '| "github.com/vladimirvivien/learning-go/ch06/**volt**" | `volt` |'
  prefs: []
  type: TYPE_TB
- en: While there are no naming requirements, it is sensible to name package directories
    to reflect their respective purposes. From the previous table, each package in
    the example is named to represent an electrical concept, such as current, power,
    resistor, and volt. The *Naming packages* section will go into further detail
    about package naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go source files must declare themselves to be part of a package. This is done
    using the `package` clause, as the first legal statement in a Go source file.
    The declared package consists of the `package` keyword followed by a name identifier.
    The following shows source file `volt.go` from the `volt` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/volt/volt.go
  prefs: []
  type: TYPE_NORMAL
- en: The package identifier in the source file can be set to any arbitrary value.
    Unlike, say, Java, the name of the package does not reflect the directory structure
    where the source file is located. While there are no requirements for the package
    name, it is an accepted convention to name the package identifier the same as
    the directory where the file is located. In our previous source listing, the package
    is declared with identifier `volt` because the file is stored inside the *volt*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-File packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logical content of a package (source code elements such as types, functions,
    variables, and constants) can physically scale across multiple Go source files.
    A package directory can contain one or more Go source files. For instance, in
    the following example, package `resistor` is unnecessarily split among several
    Go source files to illustrate this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/resistor/lib.go |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/resistor/res_equivalance.go |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/resistor/res.go |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/resistor/res_power.go |
  prefs: []
  type: TYPE_NORMAL
- en: Each file in the package must have a package declaration with the same name
    identifier (in this case `resistor`). The Go compiler will stitch all elements
    from all of the source files together to form one logical unit within a single
    scope that can be used by other packages.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to point out that compilation will fail if the package declaration
    is not identical across all source files in a given directory. This is understandable,
    as the compiler expects all files in a directory to be part of the same package.
  prefs: []
  type: TYPE_NORMAL
- en: Naming packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Go expects each package in a workspace to have a unique
    fully qualified import path. Your program may have as many packages as you want
    and your package structure can be as deep as you like in the workspace. However,
    idiomatic Go prescribes some **rules** for the naming and organization of your
    packages to make creating and using packages simple.
  prefs: []
  type: TYPE_NORMAL
- en: Use globally unique namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firstly, it is a good idea to fully qualify the import path of your packages
    in a global context, especially if you plan to share your code with others. Consider
    starting the name of your import path with a namespace scheme that uniquely identifies
    you or your organization. For instance, company *Acme, Inc.* may choose to start
    all of their Go package names with `acme.com/apps`. So a fully qualified import
    path for a package would be `"acme.com/apps/foo/bar"`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later in this chapter, we will see how package import paths can be used when
    integrating Go with source code repository services such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Add context to path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, as you devise a naming scheme for your package, use the package''s path
    to add context to the name of your package name. The context in the name should
    start generic and get more specific from left to right. As an example, let us
    refer to the import paths for the power package (from the example earlier). The
    calculation of power values is split among three sub-packages shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/ir**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/vladimirvivien/learning-go/ch06/**power/vr**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parent path `power` contains package members with broader context. The
    sub-packages `ir` and `vr` contain members that are more specific with narrower
    contexts. This naming pattern is used heavily in Go, including the built-in packages
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crypto/md5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http/httputil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reflect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note a package depth of one is a perfectly legitimate package name (see `reflect`)
    as long as it captures both context and the essence of what it does. Again, keep
    things simple. Avoid the temptation of nesting your packages beyond a depth of
    more than three inside your namespace. This temptation will be especially strong
    if you are a Java developer used to long nested package names.
  prefs: []
  type: TYPE_NORMAL
- en: Use short names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When reviewing the names of built-in Go packages, one thing you will notice
    is the brevity of the names compared to other languages. In Go, a package is considered
    to be a collection of code that implements a specific set of closely related functionalities.
    As such, the import paths of your packages should be succinct and reflect what
    they do without being excessively long. Our example source code exemplifies this
    by naming the package directory with short names such as volt, power, resistance,
    current. In their respective contexts, each directory name states exactly what
    the package does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The short name rule is rigorously applied in the built-in packages of Go. For
    instance, following are several package names from Go''s built-in packages: `log`,
    `http`, `xml`, and `zip`. Each name readily identifies the purpose of the package.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Short package names have the advantage of reducing keystrokes in larger code
    bases. However, having short and generic package names also has the disadvantage
    of being prone to import path clashes where developers in a large project (or
    developers of open source libraries) may end up using the same popular names (in
    other words, `log`, `util`, `db`, and so on) in their code. As we will see later
    in the chapter, this can be handled using `named` import paths.
  prefs: []
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go tools reduce the complexity of compiling your code by applying certain
    conventions and sensible defaults. Although a full discussion of Go''s build tool
    is beyond the scope of this section (or chapter), it is useful to understand the
    purpose and use of the `build` and `install` tools. In general, the use of the
    build and install tools is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*$> go build [<package import path>]*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import path` can be explicitly provided or omitted altogether. The `build`
    tool accepts the `import path` expressed as either fully qualified or relative
    paths. Given a properly setup workspace, the following are all equivalent ways
    to compile package `volt`, from the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `go build` command above will compile all Go source files and their dependencies
    found in directory `volt`. Furthermore, it is also possible to build all of your
    packages and sub-packages in a given directory using the wildcard parameter appended
    to an import path shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous will build all packages and sub-packages found in the directory
    `$GOPATH/src/github.com/vladimirvivien/learning-go/ch06`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the build command outputs its results into a tool-generated temporary
    directory that is lost after the build process completes. To actually generate
    a usable artifact, you must use the `install` tool to keep a copy of the compiled
    object files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `install` tool has the exact semantics as the build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to compiling the code, it also saves and outputs the result to
    workspace location `$GOPATH/pkg` as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The generated object files (with the `.a` extension) allow the package to be
    reused and linked against other packages in the workspace. Later in the chapter,
    we will examine how to compile executable programs.
  prefs: []
  type: TYPE_NORMAL
- en: Package visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regardless of the number of source files declared to be part of a package,
    all source code elements (types, variables, constants, and functions), declared
    at a package level, share a common scope. Therefore, the compiler will not allow
    an element identifier to be re-declared more than once in the entire package.
    Let us use the following code snippets to illustrate this point, assuming both
    source files are part of the same package `$GOPATH/src/foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: foo/file1.go |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: foo/file2.go |
  prefs: []
  type: TYPE_NORMAL
- en: Illegal variable identifier re-declaration
  prefs: []
  type: TYPE_NORMAL
- en: Although they are in two separate files, the declaration of variables with identifier
    `bar` is illegal in Go. Since the files are part of the same package, both identifiers
    have the same scope and therefore clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for function identifiers. Go does not support the overloading
    of function names within the same scope. Therefore, it is illegal to have a function
    identifier used more than once, regardless of the function''s signature. If we
    assume the following code appears in two different source files within the same
    package, the following snippet would be illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: foo/file1.go |
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: foo/file1.go |
  prefs: []
  type: TYPE_NORMAL
- en: Illegal function identifier re-declaration
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code snippets, function name identifier `qux` is used twice.
    The compiler will fail the compilation even though both functions have different
    signatures. The only way to fix this is to change the name.
  prefs: []
  type: TYPE_NORMAL
- en: Package member visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The usefulness of a package is its ability to expose its source elements to
    other packages. Controlling the visibility of elements of a package is simple
    and follows this rule: *capitalized identifiers are exported automatically*. This
    means any type, variable, constant, or function with capitalized identifiers is
    automatically visible from outside of the package where it is declared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the Ohm''s Law example, described earlier, the following illustrates
    this functionality from the package `resistor` (found in [github.com/vladimirvivien/learning-go/ch06/resistor](https://github.com/vladimirvivien/learning-go/ch06/resistor)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Function `R` is automatically exported and can be accessed from other packages
    as: `resistor.R()` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| Function identifier `recip` is in all lowercase and therefore is not exported.
    Though accessible within its own scope, the function will not be visible from
    within other packages. |'
  prefs: []
  type: TYPE_TB
- en: It is worth restating that members within the same package are always visible
    to each other. In Go, there are no complicated visibility structures of private,
    friend, default, and so on, as is found in other languages. This frees the developer
    to concentrate on the solution being implemented rather than modeling visibility
    hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Importing package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you should have a good understanding of what a package is, what
    it does, and how to create one. Now, let us see how to use a package to import
    and reuse its members. As you will find in several other languages, the keyword
    `import` is used to import source code elements from an external package. It allows
    the importing source to access exported elements found in the imported package
    (see the *Package scope and visibility* section earlier in the chapter). The general
    format for the import clause is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*import [package name identifier] "<import path>"*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the import path must be enclosed within double quotes. The `import`
    statement also supports an optional package identifier that can be used to explicitly
    name the imported package (discussed later). The import statement can also be
    written as an import block, as shown in the following format. This is useful where
    there are two or more import packages listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*import (*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[package name identifier] "<import path>"*'
  prefs: []
  type: TYPE_NORMAL
- en: '*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source code snippet shows the import declaration block in the
    Ohm''s Law examples introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/main.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Often the name identifiers of imported packages are omitted, as done above.
    Go then applies the name of the last directory of the import path as the name
    identifier for the imported package, as shown, for some packages, in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Import Path** | **Package name** |'
  prefs: []
  type: TYPE_TB
- en: '| `flag` | `flag` |'
  prefs: []
  type: TYPE_TB
- en: '| `github.com/vladimirvivien/learning-go/ch06/current` | `current` |'
  prefs: []
  type: TYPE_TB
- en: '| `github.com/vladimirvivien/learning-go/ch06/power/ir` | `ir` |'
  prefs: []
  type: TYPE_TB
- en: '| `github.com/vladimirvivien/learning-go/ch06/volt` | `volt` |'
  prefs: []
  type: TYPE_TB
- en: 'The dot notation is used to access exported members of an imported package.
    In the following source code snippet, for instance, method `volt.V()` is invoked
    from imported package `"github.com/vladimirvivien/learning-go/ch06/volt"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/main.go
  prefs: []
  type: TYPE_NORMAL
- en: Specifying package identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As was mentioned, an `import` declaration may explicitly declare a name identifier
    for the import, as shown in the following import snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Following the format described earlier, the name identifier is placed before
    the import path as shown in the preceding snippet. A named package can be used
    as a way to shorten or customize the name of a package. For instance, in a large
    source file with numerous usage of a certain package, this can be a welcome feature
    to reduce keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning a name to a package is also a way to avoid package identifier collisions
    in a given source file. It is conceivable to import two or more packages, with
    different import paths, that resolve to the same package names. As an example,
    you may need to log information with two different logging systems from different
    libraries, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As depicted in the previous snippet, both logging packages will resolve to the
    same name identifier of `"logger"` by default. To resolve this, at least one of
    the imported packages must be assigned a name identifier to resolve the name clash.
    In the previous example, both import paths were named with a meaningful name to
    help with code comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: The dot identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A package can optionally be assigned a dot (period) as its identifier. When
    an `import` statement uses the dot identifier (`.`) for an import path, it causes
    members of the imported package to be merged in scope with that of the importing
    package. Therefore, imported members may be referenced without additional qualifiers.
    So if package `logger` is imported with the dot identifier in the following source
    code snippet, when accessing exported member function `SubmitError` from the logger
    package, the package name is omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While this feature can help reduce repetitive keystrokes, it not an encouraged
    practice. By merging the scope of your packages, it becomes more likely to run
    into identifier collisions.
  prefs: []
  type: TYPE_NORMAL
- en: The blank identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a package is imported, it is a requirement that one of its members be referenced
    in the importing code at least once. Failure to do so will result in a compilation
    error. While this feature helps simplify package dependency resolution, it can
    be cumbersome, especially in the early phase of a developing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the blank identifier (similar to variable declarations) causes the compiler
    to bypass this requirement. For instance, the following snippet imports the built-in
    package `fmt`; however, it never uses it in the subsequent source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A common idiom for the blank identifier is to load packages for their side effects.
    This relies on the initialization sequence of packages when they are imported
    (see the following *Package initialization* section). Using the blank identifier
    will cause an imported package to be initialized even when none of its members
    can referenced. This is used in contexts where the code is needed to silently
    run certain initialization sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Package initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a package is imported, it goes through a series of initialization sequences
    before its members are ready to be used. Package-level variables are initialized
    using dependency analysis that relies on lexical scope resolution, meaning variables
    are initialized based on their declaration order and their resolved transitive
    references to each other. For instance, in the following snippet, the resolved
    variable declaration order in package `foo` will be `a`, `y`, `b`, and `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Go also makes use of a special function named `init` that takes no arguments
    and returns no result values. It is used to encapsulate custom initialization
    logic that is invoked when the package is imported. For instance, the following
    source code shows an `init` function used in the `resistor` package to initialize
    function variable `Rpi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/resistor/res_power.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the `init` function is invoked after the package-level
    variables are initialized. Therefore, the code in the `init` function can safely
    rely on the declared variable values to be in a stable state. The `init` function
    is special in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A package can have more than one `init` functions defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot directly access declared `init` functions at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are executed in the lexical order they appear within each source file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init` function is a great way to inject logic into a package that gets
    executed prior to any other functions or methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in the book, you have learned how to create and bundle Go code as reusable
    packages. A package, however, cannot be executed as a standalone program. To create
    a program (also known as a command), you take a package and define an entry point
    of execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare (at least one) source file to be part of a special package called `main`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare one function name `main()` to be used as the entry point of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function `main` takes no argument nor returns any value. The following
    shows the abbreviated source code for the `main` package used in the Ohm''s Law
    example (from earlier). It uses the package `flag`, from Go''s standard library,
    to parse program arguments formatted as `flag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06/main.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous listing shows the source code of the `main` package and the implementation
    of the function `main` which gets executed when the program runs. The Ohm's Law
    program accepts command-line arguments that specify which electrical operation
    to execute (see the following *Accessing program arguments* section). The function
    `init` is used to initialize parsing of the program flag values. The function
    main is set up as a big switch statement block to select the proper operation
    to execute based on the selected flags.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing program arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a program is executed, the Go runtime makes all command-line arguments
    available as a slice via package variable `os.Args`. For instance, when the following
    program is executed, it prints all command-line arguments passed to the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch06-args/hello.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the program when it is invoked with the shown
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the command-line argument `"hello world how are you?"`, placed after
    the program's name, is split as a space-delimited string. Position 0 in slice
    `os.Args` holds the fully qualified name of the program's binary path. The rest
    of the slice stores each item in the string respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flag` package, from Go''s standard library, uses this mechanism internally
    to provide processing of structured command-line arguments known as flags. In
    the Ohm''s Law example listed earlier, the `flag` package is used to parse several
    flags, as listed in the following source snippet (extracted from the full listing
    earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The snippet shows function `init` used to parse and initialize expected flags
    `"v"`, `"i"`, `"p",` and `"op"` (at runtime, each flag is prefixed with a minus
    sign). The initialization functions in package `flag` sets up the expected type,
    the default value, a flag description, and where to store the parsed value for
    the flag. The flag package also supports the special flag "help", used to provide
    helpful hints about each flag.
  prefs: []
  type: TYPE_NORMAL
- en: '`flag.Parse()`, in the function `main`, is used to start the process of parsing
    any flags provided as command-line. For instance, to calculate the current of
    a circuit with 12 volts and 300 ohms, the program takes three flags and produces
    the shown output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Building and installing programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building and installing Go programs follow the exact same procedures as building
    a regular package (as was discussed earlier in the *Building and installing packages*
    section). When you build source files of an executable Go program, the compiler
    will generate an executable binary file by transitively linking all the decencies
    declared in the `main` package. The build tool will name the output binary, by
    default the same name as the directory where the Go program source files are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the Ohm''s Law example, the file `main.go`, which is located
    in the directory `github.com/vladimirvivien/learning-go/ch06`, is declared to
    be part of the `main` package. The program can be built as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the `main.go` source file is built, the build tool will generate a binary
    named `ch06` because the source code for the program is located in a directory
    with that name. You can control the name of the binary using the output flag `-o`.
    In the following example, the build tool creates a binary file named `ohms`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, installing a Go program is done in exactly the same way as installing
    a regular package using the Go `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When a program is installed using the Go install command, it will be built,
    if necessary, and its generated binary will be saved in the `$GOPAHT/bin` directory.
    Adding the workspace `bin` directory to your OS's `$PATH` environment variable
    will make your Go program available for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go-generated programs are statically linked binaries. They require no additional
    dependencies to be satisfied to run. However, Go-compiled binaries include the
    Go runtime. This is the set of operations that handle functionalities such as
    garbage collection, type information, reflection, goroutines scheduling, and panic
    management. While a comparable C program would be order of magnitudes smaller,
    Go's runtime comes with the tools that make Go enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Remote packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the tools that is shipped with Go allows programmers to retrieve packages
    directly from remote source code repositories. Go, by default, readily supports
    integration with version control systems including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Git (`git`, [http://git-scm.com/](http://git-scm.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mercurial (`hg`, [https://www.mercurial-scm.org/](https://www.mercurial-scm.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion (`svn`, [http://subversion.apache.org/](http://subversion.apache.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bazaar (`bzr`, [http://bazaar.canonical.com/](http://bazaar.canonical.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for Go to pull package source code from a remote repository, you must
    have a client for that version control system installed as a command on your operating
    system's execution path. Under the cover, Go launches the client to interact with
    the source code repository server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` command-line tool allows programmers to retrieve remote packages
    using a fully qualified project path as the import path for the package. Once
    the package is downloaded, it can be imported for use in local source files. For
    instance, if you wanted to include one of the packages from the Ohm''s Law example
    from preceding snippet, you would issue the following command from the command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `go get` tool will download the specified import path along with all referenced
    dependencies. The tool will then build and install the package artifacts in `$GOPATH/pkg`.
    If the `import` path happens to be a program, go get will generate the binary
    in `$GOPATH/bin` as well as any referenced packages in `$GOPATH/pkg`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented an extensive look into the notion of source code organization
    and packages. Readers learned about the Go workspace and the import path. Readers
    were also introduced to the creation of packages and how to import packages to
    achieve code reusability. The chapter introduced mechanisms such as visibility
    of imported members and package initialization. The last portion of the chapter
    discussed the steps that are necessary to create an executable Go program from
    packaged code.
  prefs: []
  type: TYPE_NORMAL
- en: This was a lengthy chapter, and deservedly so to do justice to such a broad
    topic as package creation and management in Go. The next chapter returns to the
    Go types discussion with a detailed treatment of the composite types, such as
    array, slice, struct, and map.
  prefs: []
  type: TYPE_NORMAL

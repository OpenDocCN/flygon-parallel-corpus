- en: Chapter 8. Methods, Interfaces, and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using your skills at this point, you can write an effective Go program using
    the fundamental concepts covered so far. As you will see in this chapter, the
    Go type system can support idioms that go beyond simple functions. While the designers
    of Go did not intend to create an object-oriented language with deep class hierarchies,
    the language is perfectly capable of supporting type compositions with advanced
    features to express the creation of complex object-like structures, as covered
    in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Go function can be defined with a scope narrowed to that of a specific type.
    When a function is scoped to a type, or attached to the type, it is known as a
    *method*. A method is defined just like any other Go function. However, its definition
    includes a *method receiver*, which is an extra parameter placed before the method's
    name, used to specify the host type to which the method is attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better illustrate this concept, the following figure highlights the different
    parts involved in defining a method. It shows the `quart` method attached to the
    `type gallon` based receiver via the `g gallon` receiver parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Go methods](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned, a method has the scope of a type. Therefore, it can only be accessed
    via a declared value (concrete or pointer) of the attached type using *dot notation*.
    The following program shows how the declared method `quart` is accessed using
    this notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/method_basic.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the `gal` variable is initialized as the `gallon` type.
    Therefore, the `quart` method can be accessed using `gal.quart()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, the receiver parameter provides access to the value assigned to
    the base type of the method. In the example, the `quart` method receives the `g`
    parameter, which passes in a copy of the value for the declared type. So when
    the `gal` variable is initialized with a value of `5`, a call to `gal.quart()`
    sets the receiver parameter `g` to `5`. So the following would then print a value
    of `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the base type for method receivers cannot be a
    pointer (nor an interface). For instance, the following will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows a lengthier version of the source that implements a more
    general liquid volume conversion program. Each volumetric type receives its respective
    methods to expose behaviors attributed to that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: github.com/vladimirvivien/learning-go/ch08/methods.go
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, converting `5` gallons to ounces can be done by invoking the
    proper conversion methods on a given value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entire implementation uses a simple, but effective, typical structure to
    represent both data type and behavior. Reading the code, it cleanly expresses
    its intended meaning without any reliance on heavy class structures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Method set**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of methods attached to a type, via the receiver parameter, is known
    as the type's *method set*. This includes both concrete and pointer value receivers.
    The concept of a method set is important in determining type equality, interface
    implementation, and support of the notion of the empty method set for the *empty
    interface* (all discussed in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Value and pointer receivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One aspect of methods that has escaped discussion so far is that receivers are
    normal function parameters. Therefore, they follow the pass-by-value mechanism
    of Go functions. This implies that the invoked method gets a copy of the original
    value from the declared type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Receiver parameters can be passed as either values of or pointers of the base
    type. For instance, the following program shows two methods, `half` and `double`;
    both directly update the value of their respective method receiver parameters,
    `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/receiver_ptr.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `half` method, the code updates the receiver parameter with `g = gallon(g
    * 0.5)`. As you would expect, this will not update the original declared value,
    but rather the copy stored in the `g` parameter. So, when `gal.half()` is invoked
    in `main`, the original value remains unchanged and the following would print
    `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to regular function parameters, a receiver parameter that uses a pointer
    to refer to its base value allows the code to dereference the original value to
    update it. This is highlighted in the `double` method following snippet. It uses
    a method receiver of the `*gallon` type, which is updated using `*g = gallon(*g
    * 2)`. So when the following is invoked in `main`, it would print a value of **10**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pointer receiver parameters are widely used in Go. This is because they make
    it possible to express object-like primitives that can carry both state and behaviors.
    As the next section shows, pointer receivers, along with other type features,
    are the basis for creating objects in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lengthy introductory material from the previous sections was the setup to
    lead to the discussion of objects in Go. It has been mentioned that Go was not
    designed to function as traditional object-oriented language. There are no object
    or class keywords defined in Go. So then, why are we discussing objects in Go
    at all? Well, it turns out that Go perfectly supports object idioms and the practice
    of object-oriented programming without the heavy baggage of classical hierarchies
    and complex inheritance structures found in other object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Let us review some of the primordial features usually attributed to an object-oriented
    language in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Object feature** | **Go** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| Object: A data type that stores states and exposes behavior | Yes | In Go
    all types can achieve this. There is no special type called a class or object
    to do this. Any type can receive a set of method to define its behavior, although
    the `struct` type comes the closest to what is commonly called an object in other
    languages. |'
  prefs: []
  type: TYPE_TB
- en: '| Composition | Yes | Using a type such as a `struct` or an `interface` (discussed
    later), it is possible to create objects and express their polymorphic relationships
    through composition. |'
  prefs: []
  type: TYPE_TB
- en: '| Subtype via interface | Yes | A type that defines a set of behaviors (methods)
    that other types may implement. Later you will see how it is used to implement
    object sub-typing. |'
  prefs: []
  type: TYPE_TB
- en: '| Modularity and encapsulation | Yes | Go supports physical and logical modularity
    at its core with concepts such packages and an extensible type system, and code
    element visibility. |'
  prefs: []
  type: TYPE_TB
- en: '| Type inheritance | No | Go does not support polymorphism through inheritance.
    A newly declared named type does not inherit all attributes of its underlying
    type and are treated differently by the type system. As a consequence, it is hard
    to implement inheritance via type lineage as found in other languages. |'
  prefs: []
  type: TYPE_TB
- en: '| Classes | No | There is no notion of a class type that serves as the basis
    for objects in Go. Any data type in Go can be used as an object. |'
  prefs: []
  type: TYPE_TB
- en: As the previous table suggests, Go supports the majority of concepts that are
    usually attributed to object-oriented programming. The remainder of this chapter
    covers topics and examples showing how to use Go as an object-oriented programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: The struct as object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nearly all Go types can play the role of an object by storing states and exposing
    methods that are capable of accessing and modifying those states. The `struct`
    type, however, offers all of the features that are traditionally attributed to
    objects in other languages, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to host methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to be extended via composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to be sub-typed (with help from the Go `interface` type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of the chapter will base its discussion of objects on using the
    `struct` type.
  prefs: []
  type: TYPE_NORMAL
- en: Object composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with the following simple example to demonstrate how the `struct`
    type may be used as an object that can achieve polymorphic composition. The following
    source code snippet implements a typical structure that models components of motorized
    transportation including `fuel, engine`, `vehicle`, `truck`, and `plane`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/structobj.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The components and their relationships declared in the previous code snippet
    are illustrated in the following figure to visualize the type mapping and their
    compositions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object composition](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Go uses the *composition over inheritance* principle to achieve polymorphism
    using the type embedding mechanism supported by the `struct` type. In Go, there
    is no support for polymorphism via type inheritance. Recall that each type is
    independent and is considered to be different from all others. In fact, the semantics
    in the model above is slightly broken. Types `truck` and `plane` are shown to
    be composed of (or has-a) the `vehicle` type, which does not sound correct. Instead,
    the proper, or at least a more correct, representation would be to show that the
    types `truck` and `plane` *is a* `vehicle` via a subtype relationship. Later in
    the chapter, we will see how this can be achieved using the `interface` type.
  prefs: []
  type: TYPE_NORMAL
- en: Field and method promotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the objects have been established in the previous section, let us
    spend some time discussing the visibility of fields, methods, and embedded types
    inside the structs. The following source snippet shows a continuation of the previous
    example. It declares and initializes a variable `t` of type `truck` and `p` for
    `plane`. The former is initialized using a struct literal and the latter is updated
    using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/structobj.go
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more interesting details in the previous snippet is how the `struct`
    type embedding mechanism promotes fields and methods when accessed using dot notation.
    For instance, the following fields (`make`, `mode`, `fuel`, and `thrust`), are
    all declared in types that are embedded inside of the `plane` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous fields are promoted from their embedded types. They are accessed
    as if they are members of the `plane` type when, in fact, they are coming from
    the types `vehicle` and `engine` respectively. To avoid ambiguity, the name of
    the fields can be qualified as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Methods can also be promoted in a similar way. For instance, in the previous
    code we saw the methods `t.start()` and `p.start()` being invoked. However, neither
    type, `truck` nor `plane`, are receivers of a method named `start()`. As shown
    in the program from earlier, the `start()`method is defined for the `engine` type.
    Since the `engine` type is embedded in the types `truck` and `plane`, the `start()`method
    is promoted in scope to these enclosing types and is therefore  accessible.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Go does not support classes, there is no such concept as a constructor.
    However, one conventional idiom you will encounter in Go is the use of a factory
    function to create and initialize values for a type. The following snippet shows
    a portion of the previous example that has been updated to use a constructor function
    for creating new values of the `plane` and `truck` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/structobj2.go
  prefs: []
  type: TYPE_NORMAL
- en: While not required, providing a function to help with the initialization of
    composite values, such as a struct, increases the usability of the code. It provides
    a place to encapsulate repeatable initialization logic that can enforce validation
    requirements. In the previous example, both constructor functions, `newTruck`
    and `newPlane`, are passed the make and model information to create and initialize
    their respected values.
  prefs: []
  type: TYPE_NORMAL
- en: The interface type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you talk to people who have been doing Go for a while, they almost always
    list the interface as one of their favorite features of the language. The concept
    of interfaces in Go, similar to other languages, such as Java, is a set of methods
    that serves as a template to describe behavior. A Go interface, however, is a
    type specified by the `interface{}` literal, which is used to list a set of methods
    that satisfies the interface. The following example shows the `shape` variable
    being declared as an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, the `shape` variable is declared and assigned an unnamed
    type, `interface{area()float64; perim()float64}`. Declaring variables with unnamed
    `interface` literal types is not really practical. Using idiomatic Go, an `interface`
    type is almost always declared as a named `type`. The previous snippet can be
    rewritten to use a named interface type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interesting aspect of interfaces in Go is how they are implemented and ultimately
    used. Implementing a Go interface is done implicitly. There is no separate element
    or keyword required to indicate the intent of implementation. Any type that defines
    the method set of an `interface` type automatically satisfies its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source code shows the `rect` type as an implementation of the
    `interface` type `shape`. The `rect` type is defined as a `struct` with receiver
    methods `area` and `perim`. This fact automatically qualifies `rect` as an implementation
    of `shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/interface_impl.go
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping with Go interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, during the discussion on objects, it was mentioned that Go favors
    composition (*has-a*) relationships when building objects. While that is true,
    Go can also express "is-a" relationships among objects using subtyping via interfaces.
    In our previous example, it can be argued that the `rect` type (and any other
    type that implements the methods `area` and `perim`) can be treated as a subtype
    of `shape`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subtyping with Go interfaces](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you may expect, any subtype of `shape` can participate in expressions or
    be passed as functions (or methods) parameters where the `shape` type is expected.
    This is shown in the following code snippet where both types, `rect` (defined
    previously) and `triangle`, are able to be passed to the `shapeInfo(shape)` function
    to return a `string` value containing shape calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/interface_impl.go
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implicit mechanism of interfaces allows any named type to satisfy multiple
    interface types at once. This is achieved simply by having the method set of a
    given type intersect with the methods of each `interface` type to be implemented.
    Let us re-implement the previous code to show how this is done. Two new interfaces
    are introduced, `polygon` and `curved`, to better capture and categorize information
    and the behavior of shapes, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/interface_impl2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous source code snippet shows how types can automatically satisfy
    multiple interfaces by simply declaring methods that satisfy the interfaces''
    method sets. This is illustrated by the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing multiple interfaces](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interface embedding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting aspects of the `interface` type is its support for type
    embedding (similar to the `struct` type). This gives you the flexibility to structure
    your types in ways that maximize type reuse. Continuing with the shape example,
    the following code snippet reorganizes and reduces the previous interface count
    from three to two by embedding shape into the other two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/interface_impl3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows how the interface types may be combined so
    the *is-a* relationship still satisfies the relationships between code components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface embedding](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When embedding interface types, the enclosing type will inherit the method set
    of the embedded types. The compiler will complain if the embedded type causes
    method signatures to clash. Embedding becomes a crucial feature, especially when
    the code applies type validation using type checking. It allows a type to roll
    up type information, thus reducing unnecessary assertion steps (type assertion
    is discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: The empty interface type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `interface{}` type, or the empty `interface` type, is the literal representation
    of an `interface` type with an empty method set. According to our discussion so
    far, it can be deduced that *all types implement the empty interface* since all
    types can have a method set with zero or more members.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a variable is assigned the `interface{}` type, the compiler relaxes its
    build-time type checks. The variable, however, still carries type information
    that can be queried at runtime. The following code illustrates how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch08/interface_empty.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, the `anyType` variable is declared to be of the type
    `interface{}`. It is able to be assigned values of different types without complaints
    from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printAnyType()` function takes a parameter of the type `interface{}`.
    This means the function can be passed the values of any valid type, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The empty interface is crucially important for idiomatic Go. Delaying type-checking
    until runtime makes the language feels more dynamic without completely sacrificing
    strong typing. Go offers mechanisms such as type assertion (covered next) to query
    the type information carried by interfaces at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Type assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an interface (empty or otherwise) is assigned to a variable, it carries
    type information that can be queried at runtime. Type assertion is a mechanism
    that is available in Go to idiomatically narrow a variable (of `interface` type)
    down to a concrete type and value that are stored in the variable. The following
    example uses type assertion in the `eat` function to select which `food` type
    to select in the `eat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/interface_assert.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `eat` function takes the `food` interface type as its parameter. The code
    shows how to use idiomatic Go to extract the static type and value stored in the
    `f` interface parameter using assertion. The general form for type assertion expression
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<interface_variable>.(concrete type name)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression starts with the variable of the interface type. It is then followed
    by a dot and the concrete type being asserted enclosed in parentheses. The type
    assertion expression can return two values: one is the concrete value (extracted
    from the interface) and the second is a Boolean indicating the success of the
    assertion, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*value, boolean := <interface_variable>.(concrete type name)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the form of assertion that is shown in the following snippet (extracted
    from the earlier example) when narrowing the `f` parameter to a specific type
    of `food`. If the type is asserted to be `meat`, then the code continues to test
    the value of the `mt` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A type assertion expression can also return just the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*value := <interface_variable>**.**(concrete type name)*'
  prefs: []
  type: TYPE_NORMAL
- en: This form of assertion is risky to do as the runtime will cause a panic in the
    program if the value stored in the interface variable is not of the asserted type.
    Use this form only if you have other safeguards to either prevent or gracefully
    handle a panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, when your code requires multiple assertions to test many types at runtime,
    a much nicer idiom for assertions is the type `switch` statement. It uses the
    `switch` statement semantic to query static type information from an interface
    value using case clauses. The `eat` function from the previous food-related example
    can been updated to use a type `switch` instead of `if` statement, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/interface_assert2.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice the code is much nicer to read. It can support any number of cases and
    is clearly laid out with visual clues that makes it easy to reason about. The
    `switch` type also makes the panic issue go away by simply specifying a default
    case that can handle any types not specifically handled in the case clause.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter attempted to give a broad and, at the same, somewhat comprehensive
    view of several important topics including methods, interfaces, and objects in
    Go. The chapter started with coverage of attaching methods to types using receiver
    parameters. Next the reader was introduced to objects and how to create idiomatic
    object-based programming in Go. Lastly, the chapter presented a comprehensive
    overview of the interface type and how it is used to support object semantics
    in Go. The next chapter takes the reader through one of the most fundamental concepts
    that has made Go such a sensation among developers: concurrency!'
  prefs: []
  type: TYPE_NORMAL

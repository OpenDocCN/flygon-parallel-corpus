- en: Chapter 9. Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concurrency is considered to be the one of the most attractive features of
    Go. Adopters of the language revel in the simplicity of its primitives to express
    correct concurrency implementations without the pitfalls that usually come with
    such endeavors. This chapter covers the necessary topics to understand and create
    concurrent Go programs, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing concurrent programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sync package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked in other languages, such as Java or C/C++, you are probably
    familiar with the notion of concurrency. It is the ability of a program to run
    two or more paths of execution independently. This is usually done by exposing
    a thread primitive directly to the programmer to create and manage concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Go has its own concurrency primitive called the *goroutine*, which allows a
    program to launch a function (routine) to execute independently from its calling
    function. Goroutines are lightweight execution contexts that are multiplexed among
    a small number of OS-backed threads and scheduled by Go's runtime scheduler. That
    makes them cheap to create without the overhead requirements of true kernel threads.
    As such, a Go program can initiate thousands (even hundreds of thousands) of goroutines
    with minimal impact on performance and resource degradation.
  prefs: []
  type: TYPE_NORMAL
- en: The go statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Goroutines are launched using the `go` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*go <function or expression>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A goroutine is created with the `go` keyword followed by the function to schedule
    for execution. The specified function can be an existing function, an anonymous
    function, or an expression that calls a function. The following code snippet shows
    an example of the use of goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine0.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code sample, when the `go count()` statement is encountered
    in the `main` function, it launches the `count` function in an independent execution
    context. Both the `main` and `count` functions will be executing concurrently.
    As a side effect, `main` will complete before any of the `count` functions get
    a chance to print anything to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the chapter, we will see how to handle synchronization idiomatically
    between goroutines. For now, let us use `fmt.Scanln()` to block and wait for keyboard
    input, as shown in the following sample. In this version, the concurrent functions
    get a chance to complete while waiting for keyboard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Goroutines may also be defined as function literals directly in the `go` statement,
    as shown in this updated version of the example shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The function literal provides a convenient idiom that allows programmers to
    assemble logic directly at the site of the `go` statement. When using the `go`
    statement with a function literal, it is treated as a regular closure with lexical
    access to non-local variables, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine3.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, the goroutine is able to access and use the variables
    `start`, `stop`, and `step`. This is safe as long as the variables captured in
    the closure are not expected to change after the goroutine starts. If these values
    are updated outside of the closure, it may create race conditions causing the
    goroutine to read unexpected values by the time it is scheduled to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example where the goroutine closure captures
    the variable `j` from the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine4.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `j` is updated with each iteration, it is impossible to determine what
    value will be read by the closure. In most cases, the goroutine closures will
    see the last updated value of `j` by the time they are executed. This can be easily
    fixed by passing the variable as a parameter in the function literal for the goroutine,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine5.go
  prefs: []
  type: TYPE_NORMAL
- en: The goroutine closures, invoked with each loop iteration, receive a copy of
    the `j` variable via the function parameter. This creates a local copy of the
    `j` value with the proper value to be used when the goroutine is scheduled to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutine scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, all goroutines run independently of each other, as depicted in
    the following illustration. A function that creates a goroutine does not wait
    for it to return, it continues with its own execution stream unless there is a
    blocking condition. Later, the chapter covers synchronization idioms to coordinate
    goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Goroutine scheduling](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go''s runtime scheduler uses a form of cooperative scheduling to schedule goroutines.
    By default, the scheduler will allow a running goroutine to execute to completion.
    However, the scheduler will automatically yield to another goroutine for execution
    if one of the following events occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A `go` statement is encountered in the executing goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A channel operation is encountered (channels are covered later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blocking system call (file or network IO for instance) is encountered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the completion of a garbage collection cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scheduler will schedule a queued goroutines ready to enter execution when
    one of the previous events is encountered in a running goroutine. It is important
    to point out that the scheduler makes no guarantee of the order of execution of
    goroutines. When the following code snippet is executed, for instance, the output
    will be printed in an arbitrary order for each run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/goroutine1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows possible output for the previous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about concurrency, one of the natural concerns that arises is that
    of data safety and synchronization among concurrently executing code. If you have
    done concurrent programming in languages such as Java or C/C++, you are likely
    familiar with the, sometimes brittle, choreography required to ensure running
    threads can safely access shared memory values to achieve communication and synchronization
    between threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one area where Go diverges from its C lineage. Instead of having concurrent
    code communicate by using shared memory locations, Go uses channels as a conduit
    between running goroutines to communicate and share data. The blog post *Effective
    Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html))
    has reduced this concept to the following slogan:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not communicate by sharing memory; instead, share memory by communicating.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of channel has its roots in **communicating sequential processes**
    (**CSP**), work done by renowned computer scientist C. A. Hoare, to model concurrency
    using communication primitives. As will be discussed in this section, channels
    provide the means to synchronize and safely communicate data between running goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses the Go channel type and provides insights into its characteristics.
    Later, you will learn how to use channels to craft concurrent programs.
  prefs: []
  type: TYPE_NORMAL
- en: The Channel type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The channel type declares a conduit within which only values of a given element
    type may be sent or received by the channel. The `chan` keyword is used to specify
    a channel type, as shown in the following declaration format:'
  prefs: []
  type: TYPE_NORMAL
- en: '*chan <element type>*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a bidirectional channel type, `chan int`,
    assigned to the variable `ch`, to communicate integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Later in the chapter, we will learn how to use the channel to send data between
    concurrent portions of a running program.
  prefs: []
  type: TYPE_NORMAL
- en: The send and receive operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go uses the `<-` (arrow) operator to indicate data movement within a channel.
    The following table summarizes how to send or receive data from a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `intCh <- 12` | Send | When the arrow is placed to the left of the value,
    variable or expression, it indicates a send operation to the channel it points
    to. In this example, `12` is sent into channel `intCh`. |'
  prefs: []
  type: TYPE_TB
- en: '| `value := <- intCh` | Receive | When the `<-` operator is place to the left
    of a channel, it indicates a receive operation from the channel. The `value` variable
    is assigned the value received from the `intCh` channel. |'
  prefs: []
  type: TYPE_TB
- en: An uninitialized channel has a *nil* zero value and must be initialized using
    the built-in *make* function. As will be discussed in the following sections,
    a channel can be initialized as either unbuffered or buffered, depending on its
    specified capacity. Each of type of channel has different characteristics that
    are leveraged in different concurrency constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Unbuffered channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the `make` function is invoked without the capacity argument, it returns
    a bidirectional *unbuffered* channel. The following snippet shows the creation
    of an unbuffered channel of type `chan int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The characteristics of an unbuffered channel are illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unbuffered channel](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sequence in the preceding figure (from left to right) shows how the unbuffered
    channel works:'
  prefs: []
  type: TYPE_NORMAL
- en: If the channel is empty, the receiver blocks until there is data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender can send only to an empty channel and blocks until the next receive
    operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the channel has data, the receiver can proceed to receive the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending to an unbuffered channel can easily cause a *deadlock* if the operation
    is not wrapped in a goroutine. The following code will block after sending `12`
    to the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan-unbuff0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the previous program, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the sender blocks immediately upon sending to an unbuffered channel.
    This means any subsequent statement, to receive from the channel for instance,
    becomes unreachable, causing a deadlock. The following code shows the proper way
    to send to an unbuffered channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan-unbuff1.go
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the send operation is wrapped in an anonymous function invoked as
    a separate goroutine. This allows the `main` function to reach the receive operation
    without blocking. As you will see later, this blocking property of unbuffered
    channels is used extensively as a synchronization and coordination idioms between
    goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the `make` function uses the capacity argument, it returns a bidirectional
    *buffered* channel, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will create a buffered channel with a capacity of `3`. The
    buffered channel operates as a first-in-first-out blocking queue, as illustrated
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buffered channel](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The buffered channel depicted in the preceding figure has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: When the channel is empty, the receiver blocks until there is at least one element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sender always succeeds as long as the channel is not at capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the channel is at capacity, the sender blocks until at least one element
    is received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a buffered channel, it is possible to send and receive values within
    the same goroutine without causing a deadlock. The following shows an example
    of sending and receiving using a buffered channel with a capacity of `4` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the previous example is able to send the values `2`, `4`, `6`,
    and `8` to the `ch` channel without the risk of blocking. The four `fmt.Println(<-ch)`
    statements are used to receive the values buffered in the channel successively.
    However, if a fifth send operation is added, prior to the first receive, the code
    will deadlock as highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Later in the chapter, you will read more about idiomatic and safe ways to use
    channels for communications.
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectional channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At declaration, a channel type may also include a unidirectional operator (using
    the `<-` arrow again) to indicate whether a channel is send-only or receive-only,
    as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Declaration** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| `<-` *chan <element type>* | Declares a receive-only channel as shown later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| *chan* `<-`*<element type>* | Declares a send-only channel as shown later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows function `makeEvenNums` with a send-only channel
    argument of type `chan <- int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan1.go
  prefs: []
  type: TYPE_NORMAL
- en: Since the directionality of the channel is baked in the type, access violations
    will be detected at compile time. So in the previous example, the `in` channel
    can only be used for receive operations.
  prefs: []
  type: TYPE_NORMAL
- en: A bidirectional channel can be converted to a unidirectional channel explicitly
    or automatically. For instance, when `makeEvenNums()` is called from `main()`,
    it receives the bidirectional channel `ch` as a parameter. The compiler automatically
    converts the channel to the appropriate type.
  prefs: []
  type: TYPE_NORMAL
- en: Channel length and capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `len` and `cap` functions can be used to return a channel''s length and
    capacity respectively. The `len` function returns the current number of elements
    queued in the channel prior to being read by a receiver. For instance, the following
    code snippet will print **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `cap` function returns the declared capacity of the channel type which,
    unlike length, remains constant throughout the life of the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An unbuffered channel has a length and a capacity of zero.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a channel is initialized it is ready for send and receive operations.
    A channel will remain in that open state until it is forcibly closed using the
    built-in *close* function, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a channel is closed, it has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent send operations will cause a program to panic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive operations never block (regardless of whether buffered or unbuffered)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All receive operations return the zero value of the channel's element type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous snippet, the `ch` channel is closed after two send operations.
    As indicated in the comment, a third send operation would cause a panic because
    the channel is closed. On the receiving side, the code gets the two elements in
    the channel before it is closed. A third receive operation returns `0`, the zero
    value for the channel's elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go offers a long form of the receive operation that returns the value read
    from the channel followed by a Boolean indicating the closed status of the channel.
    This can be used to properly handle the zero value from a closed channel, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/chan3.go
  prefs: []
  type: TYPE_NORMAL
- en: Writing concurrent programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, the discussions about goroutines and channels remained deliberately
    separated to ensure that each topic is properly covered. However, the true power
    of channels and goroutines are realized when they are combined to create concurrent
    programs, as covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the primary uses of channels is synchronization between running goroutines.
    To illustrate this use case, let us examine the following code, which implements
    a word histogram. The program reads the words from the `data` slice then, on a
    separate goroutine, collects the occurrence of each word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern0.go
  prefs: []
  type: TYPE_NORMAL
- en: The code in the previous example uses `done := make(chan bool)` to create the
    channel that will be used to synchronize the two running goroutines in the program.
    The `main` function launches a secondary goroutine, which does the word counting,
    and then it continues execution until it blocks at the `<-done` expression, causing
    it to wait.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, the secondary goroutine runs until it completes its loop. Then,
    it sends a value to the `done` channel with `done <- true`, causing the blocked
    `main` routine to become unblocked and continues with its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code has a bug that may cause a race condition. A correction will
    be introduced later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the code allocates and actually sends a Boolean value
    that is used for the synchronization. Upon further inspection, it is clear that
    the value in the channel is irrelevant and we simply want it to signal. So, we
    can further distill the synchronization idiom into a colloquial form that is presented
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the code achieves goroutine synchronization using:'
  prefs: []
  type: TYPE_NORMAL
- en: The done channel, declared as type `chan struct{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main goroutine blocks at receive expression `<-done`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the done channel is closed, all receivers succeed without blocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the signaling is done using different constructs, this version of the
    code is equivalent to the first version (`pattern0.go`). The emtpy `struct{}`
    type stores no value and it is used strictly for signaling. This version of the
    code closes the `done` channel (instead of sending a value). This has the effect
    of allowing the main goroutine to unblock and continue execution.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A natural use of channels is to stream data from one goroutine to another.
    This pattern is quite common in Go code and for it to work, the followings must
    be done:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuously send data on a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously receive the incoming data from that channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal the end of the stream so the receiver may stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you will see, all of this can be done using a single channel. The following
    code snippet is a rewrite of the previous example. It shows how to use a single
    channel to stream data from one goroutine to another. The same channel is also
    used as a signaling device to indicate the end of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the code produces the word histogram as before, but introduces
    a different approach. This is accomplished using the highlighted portion of the
    code shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| The channel used to stream data. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| The sender goroutine loops through the text line and sends a word at a time.
    It then blocks until the word is received by the receiving (main) goroutine. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| As the words are continuously received (see later), the sender goroutine
    closes the channel when it is done. This will be the signal to the receiver that
    it should also stop. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the receiver code. It is placed in a loop since it is does not know
    ahead of time how much data to expect. With each iteration of the loop, the code
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pulls the data from the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks the open status of the channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If closed, break out of the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise record histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Using for…range to receive data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous pattern is so common in Go that the idiom is built into the language
    in the form of the following `for…range` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for <elemem> := range <channel>{...}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With each iteration, this `for…range` statement will block until it receives
    incoming data from the indicated channel, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern3.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code shows the an updated version of the code using a for-range
    statement, `for word := range wordsCh`. It successively emits the received value
    from the `wordsCh` channel. When the channel is closed (from the goroutine), the
    loop automatically breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember to close the channel so receivers are signaled properly. Otherwise,
    the program may enter into a deadlock which could cause a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Channels and goroutines provide a natural substrate for implementing a form
    of producer/producer pattern using generator functions. In this approach, a goroutine
    is wrapped in a function which generates values that are sent via a channel returned
    by the function. The consumer goroutine receives these values as they are generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The word histogram has been updated to use this pattern, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern4.go
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the generator function, declared as `func words(data []string)
    <-chan string`, returns a receive-only channel of string elements. The consumer
    function, in this instance `main()`, receives the data emitted by the generator
    function, which is processed using a `for…range` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting from multiple channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it is necessary for concurrent programs to handle send and receive
    operations for multiple channels at the same time. To facilitate such endeavor,
    the Go language supports the `select` statement that multiplexes selection among
    multiple send and receive operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*select {*'
  prefs: []
  type: TYPE_NORMAL
- en: '*case <send_ or_receive_expression>:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*default:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*}*'
  prefs: []
  type: TYPE_NORMAL
- en: The `case` statement operates similarly to a `switch` statement with `case`
    clauses. The `select` statement, however, selects one of the send or receive cases
    which succeeded. If two or more communication cases happen to be ready at the
    same time, one will be selected at random. The default case is always selected
    when no other cases succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet updates the histogram code to illustrate the use of the
    `select` statement. The generator function `words` select between two channels,
    `out` to send data as before and a new channel `stopCh`, passed as a parameter,
    which is used to detect an interruption signal to stop sending data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern5.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code snippet, the `words` generator function will select the
    first communication operation that succeeds: `out <- word` or `<-stopCh`. As long
    as the consumer code in `main()` continues to receive from the `out` channel,
    the send operation will succeed first. Notice, however, the code in `main()` closes
    the `stopCh` channel when it encounters the third instance of `"the"`. When that
    happens, it will cause the receive case, in the select statement, to proceed first
    causing the goroutine to return.'
  prefs: []
  type: TYPE_NORMAL
- en: Channel timeout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One popular idiom that is commonly encountered with Go concurrency is the use
    of the select statement, introduced previously, to implement timeouts. This works
    by using the select statement to wait for a channel operation to succeed within
    a given time duration using the API from the `time` package ([https://golang.org/pkg/time/](https://golang.org/pkg/time/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a version of the word histogram example that
    times out if the program takes longer than 200 microseconds to count and print
    the words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/pattern6.go
  prefs: []
  type: TYPE_NORMAL
- en: This version of the histogram example introduces the `done` channel, which is
    used to signal when processing is done. In the `select` statement, the receive
    operation `case``<-done:` blocks until the goroutine closes the `done` channel.
    Also in the `select` statement, the `time.After()` function returns a channel
    which will close after the indicated duration. If the 200 microseconds elapse
    before done is closed, the channel from `time.After()` will close first, causing
    the timeout case to succeed first.
  prefs: []
  type: TYPE_NORMAL
- en: The sync package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are instances when accessing shared values using traditional methods are
    simpler and more appropriate then the use of channels. The *sync* package ([https://golang.org/pkg/sync/](https://golang.org/pkg/sync/))
    provides several synchronization primitives including mutual exclusion (mutex)
    locks and synchronization barriers for safe access to shared values, as discussed
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing with mutex locks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mutex locks allow serial access of shared resources by causing goroutines to
    block and wait until locks are released. The following sample illustrates a typical
    code scenario with the `Service` type, which must be started before it is ready
    to be used. After the service has started, the code updates an internal bool variable,
    `started`, to store its current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync2.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet uses variable `mutex`, of type `sync.Mutex`, to synchronize
    access to the shared variable `started`. For this to work effectively, all contentious
    areas where the `started` variable is updated must use the same lock with successive
    calls to `mutex.Lock()` and `mutex.Unlock()`, as shown in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One idiom you will often encounter is to embed the `sync.Mutex` type directly
    inside a struct, as shown in the next code snippet. This has the effect of promoting
    the `Lock()` and `Unlock()`methods as part of the struct itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync3.go
  prefs: []
  type: TYPE_NORMAL
- en: The `sync` package also offers the RWMutex (read-write mutex), which can be
    used in cases where there is one writer that updates the shared resource, while
    there may be multiple readers. The writer would update the resource using a full
    lock, as before. However, readers use the `RLock()`/`RUnlock()` method pair (for
    read-lock/read-unlock respectively) to apply a read-only lock when reading the
    shared resource. The RWMutex type is used in the next section, *Synchronizing
    Access to Composite Values*.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing access to composite values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous section discussed concurrency safety when sharing access to simple
    values. The same level of care must be applied when sharing access to composite
    type values such as maps and slices, since Go does not offer concurrency-safe
    version of these types, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync4.go
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code uses a `sync.RWMutex` variable (see preceding section, *Synchronizing
    with Mutex Locks*) to manage the locks when accessing the map variable `cache`.
    The code wraps the update operation to the `cache` variable within a pair of method
    calls, `mutex.Lock()` and `mutex.Unlock()`. However, when reading values from
    the `cache` variable, the `mutex.RLock()` and `mutex.RUnlock()`methods are used
    to provide concurrency safety.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency barriers with sync.WaitGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes when working with goroutines, you may need to create a synchronization
    barrier where you wish to wait for all running goroutines to finish before proceeding.
    The `sync.WaitGroup` type is designed for such a scenario, allowing multiple goroutines
    to rendezvous at specific point in the code. Using WaitGroup requires three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of participants in the group via the Add method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each goroutine calls the Done method to signal completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Wait method to block until all goroutines are done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WaitGroup is often used as a way to implement work distribution patterns. The
    following code snippet illustrates work distribution to calculate the sum of multiples
    of `3` and `5` up to `MAX`. The code uses the `WaitGroup` variable, `wg`, to create
    a concurrency barrier that waits for two goroutines to calculate the partial sums
    of the numbers, then gathers the result after all goroutines are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync5.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, the method call, `wg.Add(2)`, configures the `WaitGroup`
    variable `wg` because the work is distributed between two goroutines. The `work`
    function calls `defer wg.Done()` to decrement the WaitGroup counter by one every
    time it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `wg.Wait()`method call blocks until its internal counter reaches
    zero. As explained previously, this will happen when both goroutines' `work` running
    function complete successfully. When that happens, the program unblocks and gathers
    the partial results. It is important to remember that `wg.Wait()` will block indefinitely
    if its internal counter never reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting race conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging concurrent code with a race condition can be time consuming and frustrating.
    When a race condition occurs, it is usually inconsistent and displays little to
    no discernible pattern. Fortunately, since Version 1.1, Go has included a race
    detector as part of its command-line tool chain. When building, testing, installing,
    or running Go source code, simply add the `-race` command flag to enable the race
    detector instrumentation of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when the source file `golang.fyi/ch09/sync1.go` (a code with
    a race condition) is executed with the `-race` flag, the compiler''s output shows
    the offending goroutine locations that caused the race condition, as shown in
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The race detector lists the line numbers where there is concurrent access to
    shared values. It lists the *read* operations followed by the locations where
    *write* operations may happen concurrently. Racy conditions in code can go unnoticed,
    even in well-tested code, until it manifests itself randomly. If you are writing
    concurrent code, it is highly recommended that you integrate the race detector
    as part of your testing suite.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the discussion in this chapter has focused on synchronizing concurrent
    programs. As was mentioned earlier in the chapter, the Go runtime scheduler automatically
    multiplexes and schedules goroutines across available OS-managed threads. This
    means concurrent programs that can be parallelized have the ability to take advantage
    of the underlying processor cores with little to no configuration. For instance,
    the following code cleanly segregates its work unit (to calculate sums of multiples
    of 3 and 5) to be calculated by launching `workers` number of goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch09/sync6.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous code will automatically launch each goroutine, with `go work()`,
    in parallel when executed on a multi-core machine. The Go runtime scheduler, by
    default, will create a number of OS-backed threads for scheduling that is equal
    to the number of CPU cores. That quantity is identified by runtime value called
    *GOMAXPROCS*.
  prefs: []
  type: TYPE_NORMAL
- en: The GOMAXPROCS value can be explicitly changed to influence the number threads
    that are made available to the scheduler. That value can be changed using a command-line
    environment variable with the same name. GOMAXPROCS can also be updated in the
    using function `GOMAXPROCS()` from the *runtime* package ([https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)).
    Either approach allows programmers to fine-tune the number of threads that will
    participate in scheduling goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency can be a complex topic in any language. This chapter covered the
    major topics to guide readers around the use of concurrency primitives in the
    Go language. The first section of the chapter outlined the crucial properties
    of goroutines, including the creation and usage of the *go* statement. Next, the
    chapter covered the mechanism of Go's runtime scheduler and the notion of channels
    used for communication between running goroutines. Lastly, users were introduced
    to several concurrency patterns used to create concurrent programs using goroutines,
    channels, and the synchronization primitives from the sync package.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be introduced to the standard APIs to do data input and output
    in Go.
  prefs: []
  type: TYPE_NORMAL

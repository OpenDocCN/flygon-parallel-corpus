- en: Chapter 11. Writing Networked Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the many reasons for Go''s popularity, as a system language, is its
    inherent support for creating networked programs. The standard library exposes
    APIs ranging from low-level socket primitives to higher-level service abstractions
    such as HTTP and RPC. This chapter explores fundamental topics about creating
    connected applications including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The net package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TCP API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JSON API server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The net package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting point for all networked programs in Go is the *net* package ([https://golang.org/pkg/net](https://golang.org/pkg/net)).
    It provides a rich API to handle low-level networking primitives as well as application-level
    protocols such as HTTP. Each logical component of a network is represented by
    a Go type including hardware interfaces, networks, packets, addresses, protocols,
    and connections. Furthermore, each type exposes a multitude of methods giving
    Go one of the most complete standard libraries for network programming supporting
    both IPv4 and IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Whether creating a client or a server program, Go programmers will need, at
    a minimum, the network primitives covered in the following sections. These primitives
    are offered as functions and types to facilitate clients connecting to remote
    services and servers to handle incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the basic primitives, when doing network programming, is the *address*.
    The types and functions of the `net` package use a string literal to represent
    an address such as `"127.0.0.1"`. The address can also include a service port
    separated by a colon such as `"74.125.21.113:80"`. Functions and methods in the
    `net` package also support string literal representation for IPv6 addresses such
    as `"::1"` or `"[2607:f8b0:4002:c06::65]:80"` for an address with a service port
    of 80.
  prefs: []
  type: TYPE_NORMAL
- en: The net.Conn Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `net.Conn` interface represents a generic connection established between
    two nodes on the network. It implements `io.Reader` and `io.Writer` interfaces
    which allow connected nodes to exchange data using streaming IO primitives. The
    `net` package offers network protocol-specific implementations of the `net.Conn`
    interface such as *IPConn*, *UDPConn*, and *TCPConn*. Each implementation exposes
    additional methods specific to its respective network and protocol. However, as
    we will see in this chapter, the default method set defined in net.Conn is adequate
    for most uses.
  prefs: []
  type: TYPE_NORMAL
- en: Dialing a connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Client programs use the `net.Dial` function, which has the following signature, to
    connect to a host service over the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes two parameters where the first parameter, *network*, specifies
    the network protocol for the connection which can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tcp`, `tcp4`, `tcp6` : `tcp` defaults to `tcp4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udp`, `udp4`, `udp6`: `udp` defaults to `udp4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip`, `ip4`, `ip6`: `ip` defaults to `ip4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix`, `unixgram`, `unixpacket`: for Unix domain sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter parameter of the `net.Dial` function specifies a string value for
    the host address to which to connect. The address can be provided as IPv4 or IPv6
    addresses as discussed earlier. The `net.Dial` function returns an implementation
    of the `net.Conn` interface that matches the specified network parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following code snippet dials a `"tcp"` network at the host
    address, [www.gutenberg.org:80](http://gutenberg.org/), which returns a TCP connection
    of the `*net.TCPConn` type. The abbreviated code uses the TCP connection to issue
    an `"HTTP GET"` request to retrieve the full text of the literary classic Beowulf
    from the Project Gutenberg''s website ([http://gutenberg.org/](http://gutenberg.org/)).
    The raw and unparsed HTTP response is subsequently written to a local file, `beowulf.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/dial0.go
  prefs: []
  type: TYPE_NORMAL
- en: Because the `net.Conn` type implements the `io.Reader` and `io.Writer`, it can
    be used to both send data and receive data using streaming IO semantics. In the
    preceding example, `conn.Write([]byte(httpRequest))` sends the HTTP request to
    the server. The response returned by the host is copied from the `conn` variable
    to the `file` variable using `io.Copy(file, conn)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the previous is an illustration that shows how to connect to an HTTP
    server using raw TCP. The Go standard library provides a separate package designed
    specifically for HTTP programming which abstracts away the low-level protocol
    details (covered later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The `net` package also makes available network specific dialing functions such
    as `DialUDP`, `DiapTCP`, or `DialIP`, each returning its respective connection
    implementation. In most cases, the `net.Dial` function and the `net.Conn` interface
    provide adequate capabilities to connect and manage connections to a remote host.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for incoming connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a service program, one the first steps is to announce the port
    which the service will use to listen for incoming requests from the network. This
    is done by invoking the `net.Listen` function which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It takes two parameters where the first parameter specifies a protocol with
    valid values of `"tcp"`, `"tcp4"`, `"tcp6"`, `"unix"`, or `"unixpacket"`.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the local host address for the service. The local address
    can be specified without an IP address such as `":4040"`. Omitting the IP address
    of the host means that the service is bound to all network card interfaces installed
    on the host. As an alternative, the service can be bound to a specific network
    hardware interface on the host by specifying its IP address on the network, that
    is, `"10.20.130.240:4040"`.
  prefs: []
  type: TYPE_NORMAL
- en: A successful call to the `net.Listen` function returns a value of the `net.Listener`
    type (or a non-nil error if it fails). The `net.Listener` interface exposes methods
    used to manage the life cycle of incoming client connections. Depending on the
    value of the `network` parameter (`"tcp"`, `"tcp4"`, `"tcp6"`, and so on.), `net.Listen`
    will return either a `net.TCPListener` or `net.UnixListener` *,* both of which
    are concrete implementations of the `net.Listener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting client connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `net.Listener` interface uses the *Accept* method to block indefinitely
    until a new connection arrives from a client. The following abbreviated code snippet
    shows a simple server that returns the string "Nice to meet you!" to each client
    connection and then disconnects immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/listen0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, the `listener.Accept` method returns a value of the `net.Conn`
    type to handle data exchange between the server and the client (or it returns
    a non-nil `error` if it fails). The `conn.Write([]byte("Nice to meet you!"))`
    method call is used to write the response to the client. When the server program
    is running, it can be tested using a *telnet* client as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that the server program continues to run and handle subsequent client
    connections, the call to the `Accept` method is wrapped within an infinite for-loop.
    As soon as a connection is closed, the loop restarts the cycle to wait for the
    next client connection. Also notice that it is a good practice to close the listener
    when the server process is shutting down with a call to `Listener.Close()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The observant reader may notice that this simple server will not scale as it
    cannot handle more than one client request at once. In the next section, we will
    see the techniques for creating a scalable server.
  prefs: []
  type: TYPE_NORMAL
- en: A TCP API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, the chapter has covered the minimum networking components necessary
    to create client and service programs. The remainder of the chapter will discuss
    different versions of a server that implement a *monetary currency information*
    service. The service returns ISO 4217 monetary currency information with each
    request. The intent is to show the implications of creating networked services,
    along with their clients, using different application-level protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we introduced a very simple server to demonstrate the necessary steps
    required to set up a networked service. This section dives deeper into network
    programming by creating a TCP server that scales to handle many concurrent connections.
    The server code presented in this section has the following design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Use raw TCP to communicate between client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a simple text-based protocol, over TCP, for communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can query the server for global currency information with text commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a goroutine per connection to handle connection concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain connection until the client disconnects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lists an abbreviated version of the server code. The program uses
    the `curr` package (found at [https://github.com/vladimirvivien/learning-go/ch11/curr0](https://github.com/vladimirvivien/learning-go/ch11/curr0)),
    not discussed here, to load monetary currency data from a local CSV file into
    slice `currencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon successful connection to a client, the server parses the incoming client
    commands specified with a simple text protocol with the format *GET <currency-filter-value>*
    where *<currency-filter-value>* specifies a string value used to search for currency
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/tcpserv0.go
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the simple server introduced in the last section, this server is able
    to service multiple client connections at the same time. Upon accepting a new
    connection, with `ln.Accept()`, it delegates the handling of new client connections
    to a goroutine with `go handleConnection(conn)`. The connection loop then continues
    immediately and waits for the next client connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleConnection` function manages the server communication with the connected
    client. It first reads and parses a slice of bytes, from the client, into a command
    string using `cmd, param := parseCommand(string(cmdLine[0:n]))`. Next, the code
    tests the command with a `switch` statement. If the `cmd` is equal to `"GET"`,
    the code searches slice `currencies` for values that matches `param` with a call
    to `curr.Find(currencies, param)`. Finally, it streams the search result to the
    client's connection using `fmt.Fprintf(conn, "%s %s %s %s\n", cur.Name, cur.Code,
    cur.Number, cur.Country)`.
  prefs: []
  type: TYPE_NORMAL
- en: The simple text protocol supported by the server does not include any sort of
    session control or control messages. Therefore, the code uses the `conn.SetWriteDeadline`
    method to ensure the connection to the client does not linger unnecessarily for
    long periods of time. The method is called during the loop that streams out a
    response to the client. It is set for a deadline of 5 seconds to ensure the client
    is always ready to receive the next chunk of bytes within that time, otherwise
    it times the connection out.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the TCP server with telnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the currency server presented earlier uses a simple text-based protocol,
    it can be tested using a telnet client, assuming the server code has been compiled
    and running (and listening on port `4040`). The following shows the output of
    a telnet session querying the server for currency information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can query the server by using the `get` command followed
    by a filter parameter as explained earlier. The telnet client sends the raw text
    to the server which parses it and sends back raw text as the response. You can
    open multiple telnet sessions against the server and all request are served concurrently
    in their respective goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the TCP server with Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple TCP client can also be written in Go to connect to the TCP server.
    The client captures the command from the console''s standard input and sends it
    to the server as is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/tcpclient0.go
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the Go client follows the same pattern as we have seen in
    the earlier client example. The first portion of the code dials out to the server
    using `net.Dial()`. Once a connection is obtained, the code sets up an event loop
    to capture text commands from the standard input, parses it, and sends it as a
    request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a nested loop that is set up to handle incoming responses from the
    server (see code comment). It continuously streams incoming bytes into variables `buff`
    with `conn.Read(buff)`. This continues until the `Read` method encounters an error.
    The following lists the sample output produced by the client when it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An even better way of streaming the incoming bytes from the server is to use
    buffered IO as done in the following snippet of code. In the updated code, the
    `conbuf` variable, of the `bufio.Buffer` type, is used to read and split incoming
    streams from the server using the `conbuf.ReadString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/tcpclient1.go
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, writing networked services directly on top of raw TCP has some
    costs. While raw TCP gives the programmer complete control of the application-level
    protocol, it also requires the programmer to carefully handle all data processing
    which can be error-prone. Unless it is absolutely necessary to implement your
    own custom protocol, a better approach is to leverage an existing and proven protocols
    to implement your server programs. The remainder of this chapter continues to
    explore this topic using services that are based on HTTP as an application-level
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to its importance and ubiquity, HTTP is one of a handful of protocols directly
    implemented in Go. The `net/http` package ([https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/))
    provides code to implement both HTTP clients and HTTP servers. This section explores
    the fundamentals of creating HTTP clients and servers using the `net/http` package.
    Later, we will return our attention back to building versions of our currency
    service using HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The http.Client type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `http.Client` struct represents an HTTP client and is used to create HTTP
    requests and retrieve responses from a server. The following illustrates how to
    retrieve the text content of Beowulf from Project Gutenberg''s website located
    at [http://gutenberg.org/cache/epub/16328/pg16328.txt](http://gutenberg.org/cache/epub/16328/pg16328.txt), using
    the `client` variable of the `http.Client` type and prints its content to a standard
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpclient1.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous example uses the `client.Get` method to retrieve content from the
    remote server using the HTTP protocol method `GET` internally. The `GET` method
    is part of several convenience methods offered, by the Client type, to interact
    with HTTP servers as summarized in the following table. Notice that all of these
    methods return a value of the `*http.Response` type (discussed later) to handle
    responses returned by the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Client.Get` | As discussed earlier, `Get` is a convenience method that issues
    an HTTP `GET` method to retrieve the resource specified by the `url` parameter
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Client.Post` | The `Post` method is a convenience method that issues an
    HTTP `POST` method to send the content specified by the `body` parameter to the
    server specified by the `url` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Client.PostForm` | The `PostForm` method is a convenience method that uses
    the HTTP `POST` method to send form `data`, specified as mapped key/value pairs,
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Client.Head` | The `Head` method is a convenience method that issues an
    HTTP method, `HEAD`, to the remote server specified by the `url` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Client.Do` | This method generalizes the request and response interaction
    with a remote HTTP server. It is wrapped internally by the methods listed in this
    table. Section *Handling client requests and responses* discusses how to use this
    method to talk to the server. |'
  prefs: []
  type: TYPE_TB
- en: 'It should be noted that the HTTP package uses an internal `http.Client` variable
    designed to mirror the preceding methods as package functions for further convenience.
    They include `http.Get`, `*http.Post*` , `http.PostForm`, and `http.Head`. The
    following snippet shows the previous example using `http.Get` instead of the method
    from the `http.Client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpclient1a.go
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the methods to communicate with the remote server, the `http.Client`
    type exposes additional attributes that can be used to modify and control the
    behavior of the client. For instance, the following source snippet sets the timeout
    to handle a client request to complete within 21 seconds using the `Timeout` attribute
    of the `Client` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpclient2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Transport` field of the `Client` type provides further means of controlling
    the settings of a client. For instance, the following snippet creates a client
    that disables the connection reuse between successive HTTP requests with the `DisableKeepAlive`
    field. The code also uses the `Dial` function to specify further granular control
    over the HTTP connection used by the underlying client, setting its timeout value
    to 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Handling client requests and responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `http.Request` value can be explicitly created using the `http.NewRequest`
    function. A request value can be used to configure HTTP settings, add headers,
    and specify the content body of the request. The following source snippet uses
    the `http.Request` type to create a new request which is used to specify the headers
    sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpclient3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The `http.NewRequest` function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It takes a string that specifies the HTTP method as its first argument. The
    next argument specifies the destination URL. The last argument is an `io.Reader`
    that can be used to specify the content of the request (or set to nil if the request
    has no content). The function returns a pointer to a `http.Request` struct value
    (or a non-nil `error` if one occurs). Once the request value is created, the code
    uses the `Header` field to add HTTP headers to the request to be sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a request is prepared (as shown in the previous source snippet), it is
    sent to the server using the *Do* method of the `http.Client` type and has the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The method accepts a pointer to an `http.Request` value, as discussed in the
    previous section. It then returns a pointer to an `http.Response` value or an
    error if the request fails. In the previous source code, `resp, err := client.Do(req)`
    is used to send the request to the server and assigns the response to the `resp`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The response from the server is encapsulated in struct `http.Response` which
    contains several fields to describe the response including the HTTP response status,
    content length, headers, and the response body. The response body, exposed as
    the `http.Response.Body` field, implements the `io.Reader` which affords the use
    streaming IO primitives to consume the response content.
  prefs: []
  type: TYPE_NORMAL
- en: The `Body` field also implements `*io.Closer*` which allows the closing of IO
    resources. The previous source uses `defer resp.Body.Close()` to close the IO
    resource associated with the response body. This is a recommended idiom when the
    server is expected to return a non-nil body.
  prefs: []
  type: TYPE_NORMAL
- en: A simple HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTTP package provides two main components to accept HTTP requests and serve
    responses:'
  prefs: []
  type: TYPE_NORMAL
- en: The `http.Handler` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `http.Server` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `http.Server` type uses the `http.Handler` interface type, defined in the
    following listing, to receive requests and server responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Any type that implements `http.Handler` can be registered (explained next)
    as a valid handler. The Go `http.Server` type is used to create a new server.
    It is a struct whose values can be configured, at a minimum, with the TCP address
    of the service and a handler that will respond to incoming requests. The following
    code snippet shows a simple HTTP server that defines the `msg` type as handler
    registered to handle incoming client requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpserv0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, the `msg` type, which uses a string as its underlying
    type, implements the `ServeHTTP()` method making it a valid HTTP handler. Its
    `ServeHTTP` method uses the response parameter, `resp`, to print response headers
    `"200 OK"` and `"Content-Type: text/html"`. The method also writes the string
    value `m` to the response variable using `fmt.Fprint(resp, m)` which is sent back
    to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, the variable `server` is initialized as `http.Server{Addr: ":4040",
    Handler: msgHandler}`. This means the server will listen on all network interfaces
    at port `4040` and will use variable `msgHandler` as its `http.Handler` implementation.
    Once initialized, the server is started with the `server.ListenAndServe()` method
    call that is used to block and listen for incoming requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `Addr` and `Handler`, the `http.Server` struct exposes several
    additional fields that can be used to control different aspects of the HTTP service
    such as connection, timeout values, header sizes, and TLS configuration. For instance,
    the following snippet shows an updated example which specifies the server''s read
    and write timeouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpserv1.go
  prefs: []
  type: TYPE_NORMAL
- en: The default server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It should be noted that the HTTP package includes a default server that can
    be used in simpler cases when there is no need for configuration of the server.
    The following abbreviated code snippet starts a simple server without explicitly
    creating a server variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpserv2.go
  prefs: []
  type: TYPE_NORMAL
- en: In the code, the `http.ListenAndServe(":4040", msgHandler)` function is used
    to start a server which is declared as a variable in the HTTP package. The server
    is configured with the local address `":4040"` and the handler `msgHandler` (as
    was done earlier) to handle all incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests with http.ServeMux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `http.Handler` implementation introduced in the previous section is not
    sophisticated. No matter what URL path is sent with the request, it sends the
    same response back to the client. That is not very useful. In most cases, you
    want to map each path of a request URL to a different response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the HTTP package comes with the `http.ServeMux` type which can
    multiplex incoming requests based on URL patterns. When an `http.ServeMux` handler
    receives a request, associated with a URL path, it dispatches a function that
    is mapped to that URL. The following abbreviated code snippet shows `http.ServeMux`
    variable `mux` configured to handle two URL paths `"/hello"` and `"/goodbye"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpserv3.go
  prefs: []
  type: TYPE_NORMAL
- en: The code declares two functions assigned to variables `hello` and `goodbye`.
    Each function is mapped to a path `"/hello"` and `"/goodbye"` respectively using
    the `mux.HandleFunc("/hello", hello)` and `mux.HandleFunc("/goodbye", goodbye)`
    method calls. When the server is launched, with `http.ListenAndServe(":4040",
    mux)`, its handler will route the request `"http://localhost:4040/hello"` to the
    `hello` function and requests with the path `"http://localhost:4040/goodbye"`
    to the `goodbye` function.
  prefs: []
  type: TYPE_NORMAL
- en: The default ServeMux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is worth pointing out that the HTTP package makes available a default ServeMux
    internally. When used, it is not necessary to explicitly declare a ServeMux variable.
    Instead the code uses the package function, `http.HandleFunc,` to map a path to
    a handler function as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/httpserv4.go
  prefs: []
  type: TYPE_NORMAL
- en: To launch the server, the code calls `http.ListenAndServe(":4040", nil)` where
    the ServerMux parameter is set to `nil`. This implies that the server will default
    to the per-declared package instance of http.ServeMux to handle incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: A JSON API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Armed with the information from the last section, it is possible to use the
    HTTP package to create services over HTTP. Earlier we discussed the perils of
    creating services using raw TCP directly when we created a server for our global
    monetary currency service. In this section, we explore how to create an API server
    for the same service using HTTP as the underlying protocol. The new HTTP-based
    service has the following design goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Use HTTP as the transport protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSON for structured communication between client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients query the server for currency information using JSON-formatted requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server respond using JSON-formatted responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following shows the code involved in the implementation of the new service.
    This time, the server will use the `curr1` package (see [github.com/vladimirvivien/learning-go
    /ch11/curr1](https://github.com/vladimirvivien/learning-go%20/ch11/curr1)) to
    load and query ISO 4217 currency data from a local CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the curr1 package defines two types, `CurrencyRequest` and `Currency`,
    intended to represent the client request and currency data returned by the server,
    respectively as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/curr1/currency.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the preceding struct types shown are annotated with tags that describe
    the JSON properties for each field. This information is used by the JSON encoder
    to encode the key name of JSON objects (see [Chapter 10](ch10.html "Chapter 10. Data
    IO in Go"), *Data IO in Go*, for detail on encoding). The remainder of the code,
    listed in the following snippet, defines the functions that set up the server
    and the handler function for incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/jsonserv0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are leveraging HTTP as the transport protocol for the service, you
    can see the code is now much smaller than the prior implementation which used
    pure TCP. The `currs` function implements the handler responsible for incoming
    requests. It sets up a decoder to decode the incoming JSON-encoded request to
    a value of the `curr1.CurrencyRequest` type as highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the function executes the currency search by calling `curr1.Find(currencies,
    currRequest.Get)` which returns the slice `[]Currency` assigned to the `result`
    variable. The code then creates an encoder to encode the `result` as a JSON payload,
    highlighted in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, the handler function is mapped to the `"/currency"` path in the `main`
    function with the call to `mux.HandleFunc("/currency", currs)`. When the server
    receives a request for that path, it automatically executes the `currs` function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API server with cURL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the server is implemented over HTTP, it can easily be tested with any
    client-side tools that support HTTP. For instance, the following shows how to
    use the `cURL` command line tool ([http://curl.haxx.se/](http://curl.haxx.se/)))
    to connect to the API end-point and retrieve currency information about the `Euro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `cURL` command posts a JSON-formatted request object to the server using
    the `-X POST -d '{"get":"Euro"}'` parameters. The output (formatted for readability)
    from the server is comprised of a JSON array of the preceding currency items.
  prefs: []
  type: TYPE_NORMAL
- en: An API server client in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An HTTP client can also be built in Go to consume the service with minimal
    efforts. As is shown in the following code snippet, the client code uses the `http.Client`
    type to communicate with the server. It also uses the `encoding/json` sub-package
    to decode incoming data (note that the client also makes use of the `curr1` package,
    shown earlier, which contains the types needed to communicate with the server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/jsonclient0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, an HTTP client is created to send JSON-encoded request
    values as `currRequest := &curr1.CurrencyRequest{Get: param}` where `param` is
    the currency string to retrieve. The response from the server is a payload that
    represents an array of JSON-encoded objects (see the JSON array in the section,
    *Testing the API Server with cURL*). The code then uses a JSON decoder, `json.NewDecoder(resp.Body).Decode(&currencies)`,
    to decode the payload from the response body into the slice, `[]curr1.Currency`.'
  prefs: []
  type: TYPE_NORMAL
- en: A JavaScript API server client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen how to use the API service using the `cURL` command-line
    tool and a native Go client. This section shows the versatility of using HTTP
    to implement networked services by showcasing a web-based JavaScript client. In
    this approach, the client is a web-based GUI that uses modern HTML, CSS, and JavaScript
    to create an interface that interacts with the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the server code is updated with an additional handler to serve the static
    HTML file that renders the GUI on the browser. This is illustrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/jsonserv1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code snippet shows the declaration of the `gui` handler function
    responsible for serving a static HTML file that renders the GUI for the client.
    The root URL path is then mapped to the function with `mux.HandleFunc("/", gui)`.
    So, in addition to the `"/currency"` path, which hosts the API end-point the `"/"`
    path will return the web page shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A JavaScript API server client](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next HTML page ([golang.fyi/ch11/currency.html](http://learning.golang.fyi/ch11/currency.html))
    is responsible for displaying the result of a currency search. It uses JavaScritpt
    functions along with the `jQuery.js` library (not covered here) to post JSON-encoded
    requests to the backend Go service as shown in the following abbreviated HTML
    and JavaScript snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch11/currency.html
  prefs: []
  type: TYPE_NORMAL
- en: A line-by-line analysis of the HTML and JavaScript code in this example is beyond
    the scope of the book; however, it is worth pointing out that the JavaScript `doRequest`
    function is where the interaction between the client and the server happens. It
    uses the jQuery's `$.ajax` function to build an HTTP request with a `PUT` method
    and to specify a JSON-encoded currency request object, `JSON.stringify({get:param})`,
    to send to the server. The `then` method accepts the callback function, `success(currencies)`,
    which handles the response from the server that parses displays in an HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a search value is provided in the text box on the GUI, the page displays
    its results in the table dynamically as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A JavaScript API server client](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter condenses several important notions about creating networked services
    in Go. It starts with a walkthrough of Go's `net` package including the `net.Conn`
    type to create a connection between network nodes, the `net.Dial` function to
    connect to a remote service, and the `net.Listen` function to handle incoming
    connections from a client. The chapter continues to cover different implementations
    of clients and server programs and shows the implications of creating custom protocols
    directly over raw TCP versus using an existing protocol such as HTTP with JSON
    data format.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter takes a different direction. It explores the packages, types,
    functions, and tools that are available in Go to facilitate source code testing.
  prefs: []
  type: TYPE_NORMAL

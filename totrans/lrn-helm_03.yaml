- en: '*Chapter 2*: Preparing a Kubernetes and Helm Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a tool that provides a variety of benefits that help users deploy and
    manage Kubernetes applications more easily. Before users can start experiencing
    these benefits, however, they must satisfy several prerequisites. First, a user
    must have access to a Kubernetes cluster. Next, a user should have the command-line
    tools for both Kubernetes and Helm. Finally, a user should be aware of Helm's
    basic configuration options in order to be productive with as little friction
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline the tools and concepts that are required in
    order to begin working with Helm. The following topics will be covered in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local Kubernetes environment with Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up `kubectl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will install the following technologies to your local
    workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools can be installed with a package manager or by downloading them directly
    from a download link. We will provide instructions for using the `Chocolatey`
    package manager on Windows, the `Homebrew` package manager on macOS, the `apt-get`
    package manager for Debian-based Linux distributions, and the `dnf` package manager
    for RPM-based Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a local Kubernetes environment with Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm won't be able to deploy applications without access to a Kubernetes cluster.
    For this reason, let's discuss one option that users can follow to run their own
    cluster on their machine—Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube is a community-driven tool that allows users to easily deploy a small,
    single-node Kubernetes cluster to their local machine. A cluster created with
    Minikube is created inside a **virtual machine** (**VM**), so it can be created
    and later discarded in a way that is isolated from the host operating system that
    the VM is running on. Minikube presents an excellent way to experiment with Kubernetes
    and it can also be used to learn how to use Helm alongside the examples provided
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we'll cover how Minikube can be installed and configured
    so that you have a Kubernetes cluster available while learning how to use Helm.
    For more comprehensive instructions, please refer to the *Getting Started* page
    from the official Minikube websit[e at https://minikube.sigs.k8s.io/docs/s](https://minikube.sigs.k8s.io/docs/start/)tart/.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minikube, like the other tools that will be installed within this chapter, has
    binaries compiled for the Windows, macOS, and Linux operating systems. The easiest
    way to install the latest version of Minikube on Windows and macOS is via a package
    manager, such as `Chocolatey` for Windows and `Homebrew` for macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Linux users will find it easier to install the latest `minikube` binary by downloading
    it from Minikube's GitHub releases page, though this method can also be used on
    Windows and macOS as well.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps describe how you can install Minikube based on your machine
    and installation preference. Please note that Minikube version v1.5.2 was used
    during the writing and development of the examples used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it via a package manager (on Windows and macOS), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command for Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command for macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following steps show you how to install it via a download link (on Windows,
    macOS, and Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Minikube` binary can be downloaded directly from its releases page on
    Git[Hub at https://github.com/kubernetes/minikube/re](https://github.com/kubernetes/minikube/releases/tag/v1.5.2)leases/:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the releases page, there is a section called *Assets*, which
    consists of the Minikube binaries available for the various supported platforms:![Figure
    2.1: The Minikube binaries from the GitHub releases page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: The minikube binaries from the GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the **Assets** section, the binary that corresponds to the target platform
    should be downloaded. Once downloaded, you should rename the binary to `minikube`.
    If you are downloading the Linux binary, for example, you would run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute `minikube`, Linux and macOS users may need to add the executable
    bit by running the `chmod` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube` should then be moved to a location managed by the `PATH` variable
    so that it can be executed from any location in your command line. The locations
    that the `PATH` variable contains vary depending on your operating system. For
    macOS and Linux users, these locations can be determined by running the following
    command in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users can determine the `PATH` variable''s locations by running the
    following command in Command Prompt or PowerShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then move the `minikube` binary to a new location by using the `mv`
    command. The following example moves `minikube` to a common `PATH` location on
    Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify your Minikube installation by running `minikube version` and
    ensuring that the displayed version corresponds with the version that was downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although you have downloaded Minikube, you will also need a hypervisor to be
    able to run your local Kubernetes cluster. This can be done by installing VirtualBox,
    which we will describe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VirtualBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minikube depends on the existence of hypervisors in order to install a single-node
    Kubernetes cluster on a VM. For this book, we have chosen to discuss VirtualBox
    as the hypervisor option, since it is the most flexible and is available on the
    Windows, macOS, and Linux operating systems. Additional hypervisor options for
    each operating system can be found in the official Minikube documentation at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Minikube, VirtualBox is easily installed via Chocolatey or Homebrew, but
    can also be easily installed using `apt-get` for Debian-based Linux and `dnf`
    for RPM/RHEL-based Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to install VirtualBox on Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to install VirtualBox on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to install VirtualBox on Debian-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to install VirtualBox on RHEL-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Alternative methods of installing VirtualBox can be found at its official downl[oad
    page at https://www.virtualbox.org/wi](https://www.virtualbox.org/wiki/Downloads)ki/Downloads.
  prefs: []
  type: TYPE_NORMAL
- en: With VirtualBox installed, Minikube must be configured to leverage VirtualBox
    as its default hypervisor. This configuration will be made in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VirtualBox as the designated hypervisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VirtualBox can be made the default hypervisor by setting the `vm-driver` option
    of `minikube` to `virtualbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this command may produce the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This message can be safely ignored if there are no active Minikube clusters
    on the workstation. This command states that any existing Kubernetes clusters
    will not make use of VirtualBox as the hypervisor until the cluster is deleted
    and then recreated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change to VirtualBox can be confirmed by assessing the value of the `vm-driver`
    configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In addition to configuring the default hypervisor, you can also configure the
    resources that are allocated to a Minikube cluster, discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Minikube resource allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Minikube will allocate two CPUs and 2 GB of RAM to its VM. These
    resources are sufficient for each of the examples in this book except for those
    in [*Chapter 7*](B15458_07_Final_JM_ePub.xhtml#_idTextAnchor335), which are more
    resource intensive. If your machine has the available resources, you should increase
    the default memory allocation to 4 GB (the CPU allocation can remain the same).
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to increase the default memory allocation of new Minikube
    VMs to 4 GB (4000 MB).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This change can be verified by running the `minikube config get memory` command,
    similar to the way the `vm-driver` change was verified previously.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue exploring Minikube by discussing its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basic usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, it will be handy to understand the key commands used in
    a typical Minikube operation. They will also be essential to understand during
    the execution of the examples provided throughout the course of this book. Fortunately,
    Minikube is an easy tool to get started with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube has three key subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `start` subcommand is used to create a single-node Kubernetes cluster.
    It will create a VM and bootstrap the cluster within it. The command will terminate
    once the cluster is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stop` subcommand is used to shut down the cluster and the VM. The state
    of the cluster and VM are saved to the disk, allowing users to run the `start`
    subcommand again to quickly begin working, rather than having to build a new VM
    from scratch. You should try to get into the habit of running `minikube stop`
    when you have finished working with a cluster that you would like to return to
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete` subcommand is used to delete a cluster and the VM. This command
    erases the state of the cluster and VM, freeing up the space on the disk that
    was previously allocated. The next time `minikube start` is executed, a fresh
    cluster and VM will be created. You should run the `delete` subcommand when you
    would like to remove all of the allocated resources and work on a fresh Kubernetes
    cluster on your next invocation of `minikube start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are more Minikube subcommands available, but these are the main ones that
    you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: With Minikube installed and configured on a local machine, you can now install
    `kubectl`, the Kubernetes command-line tool, and satisfy the remaining prerequisites
    for working with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017),
    *Understanding Kubernetes and Helm*, Kubernetes is a system that exposes different
    API endpoints. These API endpoints are used to perform various actions on a cluster,
    such as creating, viewing, or deleting resources. To provide simpler user experience,
    developers need a way of interacting with Kubernetes without having to manage
    the underlying API layer.
  prefs: []
  type: TYPE_NORMAL
- en: While you will predominantly use the Helm command-line tool throughout the course
    of this book to install and manage applications, `kubectl` is an essential tool
    for common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Read on to learn how to install `kubectl` on a local workstation. Note that
    the `kubectl` version used at the time of writing is `v1.16.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Kubectl` can be installed using Minikube or it can be obtained via a package
    manager or through direct download. We will first describe how to obtain `kubectl`
    using Minikube.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubectl via Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The installation of `kubectl` is straightforward with Minikube. Minikube provides
    a subcommand called `kubectl`, which will download the Kubectl binary. Begin by
    running `minikube kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install `kubectl` to the `$HOME/.kube/cache/v1.16.2` directory.
    Note that the version of `Kubectl` included in the path will depend on the version
    of Minikube that you are using. To access `kubectl`, you can use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'While invoking `kubectl` with `minikube kubectl` will suffice, the syntax is
    more unwieldy than that of invoking `kubectl` directly. This can be overcome by
    copying the `kubectl` executable from the local Minikube cache into a location
    managed by the `PATH` variable. Performing this action is similar on each operating
    system, but the following is an example of how it can be achieved on a Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once complete, `kubectl` can be invoked as a standalone binary, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Installing Kubectl without Minikube
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubectl can also be installed without Minikube. The Kubernetes upstream documentation
    provides several different mechanisms to do so for a variety of ta[rget operating
    systems at https://kubernetes.io/docs/ta](https://kubernetes.io/docs/tasks/tools/install-kubectl/)sks/tools/install-kubectl/.
  prefs: []
  type: TYPE_NORMAL
- en: Using a package manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way that `kubectl` can be installed without Minikube is with native package
    management. The following list demonstrates how this can be done on different
    operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install `kubectl` on Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to install `kubectl` on macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to install `kubectl` on Debian-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to install `kubectl` RPM-based Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the final Kubectl installation method next.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading directly from a link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubectl can also be downloaded directly from a download link. The download link
    will contain the version of Kubectl that will be downloaded. You can determine
    the latest version of Kubectl by going to [https://storage.googleapis.com/kubernetes-release/release/stable.txt](https://storage.googleapis.com/kubernetes-release/release/stable.txt)
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example instructions display how version v1.16.2 can be downloaded,
    which is the version of Kubectl that is used throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Do[wnload Kubectl for Windows from https://storage.googleapis.com/kubernetes-release/release/v1.1](https://storage.googleapis.com/kubernetes-release/release/v1.16.2/bin/windows/amd64/kubectl.exe)6.2/bin/windows/amd64/kubectl.exe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Download Kubectl for macOS from https://storage.googleapis.com/kubernetes-release/releas](https://storage.googleapis.com/kubernetes-release/release/v1.16.2/bin/darwin/amd64/kubectl)e/v1.16.2/bin/darwin/amd64/kubectl.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download Kubectl for Linux from [https://storage.googleapis.com/kubernetes-release/release/v1.16.2/bin/linux/amd64/kubectl](https://storage.googleapis.com/kubernetes-release/release/v1.16.2/bin/linux/amd64/kubectl).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kubectl binary can then be moved to somewhere managed by the `PATH` variable.
    On the macOS and Linux operating systems, be sure to grant the executable permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Kubectl installation can be verified by running the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've covered how to set up `kubectl`, we're ready to get into the
    key technology of this book—Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Helm
  prefs: []
  type: TYPE_NORMAL
- en: Once Minikube and `kubectl` are installed, the next logical tool to configure
    is Helm. Note that the version of Helm used when writing this book was `v3.0.0`,
    but you are encouraged to use the latest version available of the Helm v3 release
    to receive the latest vulnerability and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm packages exist for Chocolatey and Homebrew to allow easy installation
    on Windows or macOS. On these systems, the following commands can be run to install
    Helm with a package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Helm on Windows using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Helm on macOS using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users, or users who would rather install Helm from a direct downloadable
    link, can download an archive from Helm''s GitHub releases page by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the section called **Installati**[**on** on Helm''s GitHub releases page
    at](https://github.com/helm/helm/releases) :![Figure 2.2: The Installation section
    on the Helm GitHub releases page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: The Installation section on the Helm GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: Download the archive file associated with the operating system you are using
    for the desired version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once downloaded, the file will need to be unarchived. One way that this can
    be achieved is by using the `Expand-Archive` cmdlet function on PowerShell or
    by using the `tar` utility on Bash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Windows/PowerShell, use the following example :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux and Mac, use the following example :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to specify the version that corresponds to the version downloaded. The
    `helm` binary can be found in the unarchived folder. It should be moved to a location
    managed by the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows you how to move the `helm` binary to the `/usr/local/bin`
    folder on a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of the way that Helm was installed, verification can be performed
    by running the `helm version` command. If the resulting output is similar to that
    of the following output, then Helm has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With Helm installed on your machine, proceed to the next section to learn about
    the basic Helm configuration topics.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm is a tool with sensible defaults that allow users to be productive without
    needing to perform a large number of tasks post-installation. With that being
    said, there are several different options users can change or enable to modify
    Helm's behavior. We will cover these options in the following sections, beginning
    with the configuration of upstream repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Adding upstream repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way that users can begin to modify their Helm installation is by adding
    upstream chart repositories. In [*Chapter 1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017),
    *Understanding Kubernetes and Helm*, we described how chart repositories contain
    Helm charts, which are used to package Kubernetes resource files. Helm, being
    the Kubernetes package manager, can connect to various chart repositories to install
    Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides the `repo` subcommand to allow users to manage configured chart
    repositories. This subcommand contains additional subcommands that can be used
    to perform actions against specified repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the five `repo` subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: To add a chart repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`: To list chart repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: To remove a chart repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update`: To update information on available charts locally from chart repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: To generate an index file given a directory containing packaged charts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the preceding list as a guide, adding a chart repository can be accomplished
    using the `repo add` subcommand, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding chart repositories is required in order to install the charts managed
    within them. Chart installation will be discussed in detail throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm whether a repository has been successfully added by leveraging
    the `repo list` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Repositories that have been added to the Helm client will appear in this output.
    The preceding example shows that the `bitnami` repository was added, so it appears
    in the list of repositories known by the Helm client. If additional repositories
    are added, they will also appear in this output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, updates to charts will be published and released to these repositories.
    Repository metadata is cached locally. As a result, Helm is not automatically
    aware when a chart is updated. You can instruct Helm to check for updates from
    each added repository by running the `repo update` subcommand. Once this command
    is executed, you will be able to install the latest charts from each repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also need to remove repositories that have been added previously. This
    can be accomplished by using the `repo` `remove` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The last remaining `repo` subcommand form is `index`. This subcommand is used
    by repository and chart maintainers to publish new or updated charts. This task
    will be covered more extensively in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building your First Helm Chart*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss Helm plugin configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plugins are add-on capabilities that can be used to provide additional features
    to Helm. Most users will not need to worry about plugins and plugin management
    with Helm. Helm is a powerful tool on its own and is complete with the features
    it promises out of the box. With that being said, the Helm community maintains
    a variety of different plugins that can be used to enhance Helm's capab[ilities.
    A list of these plugins can b](https://helm.sh/docs/community/related/)e found
    at [https://helm.sh/docs/community/related/](https://helm.sh/docs/community/related/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm provides a `plugin` subcommand for managing plugins, which contain further
    subcommands, described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plugins can provide a variety of different productivity enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several examples of the upstream plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`helm diff`: Performs a diff between a deployed release and a proposed Helm
    upgrade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm secrets`: Used to help conceal secrets from Helm charts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm monitor`: Used to monitor a release and perform a rollback if certain
    events occur'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm unittest`: Used to perform unit testing on a Helm chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue discussing Helm configuration options by reviewing the different
    environment variables that can be set to change various aspects of Helm's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helm relies on the existence of externalized variables to configure low-level
    options. The Helm documentation lists six primary environment variables used to
    configure Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XDG_CACHE_HOME**: Sets an alternative location for storing cached files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XDG_CONFIG_HOME**: Sets an alternative location for storing Helm configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XDG_DATA_HOME**: Sets an alternative location for storing Helm data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HELM_DRIVER**: Sets the backend storage driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HELM_NO_PLUGINS**: Disables plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KUBECONFIG**: Sets an alternative Kubernetes configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm adheres to The **XDG Base Directory Specification**, which is designed
    to provide a standardized way of defining where different files are located on
    an operating system''s filesystem. Based on the XDG specification, Helm automatically
    creates three different default directories on each operating system as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Helm uses the **cache path** for charts that are downloaded from upstream chart
    repositories. Installed charts are cached to the local machine to enable faster
    installation of the chart the next time it is referenced. To update the cache,
    a user can run the `helm repo update` command, which will refresh the repository
    metadata with the most recent information available, as well as save the chart
    to the local cache.
  prefs: []
  type: TYPE_NORMAL
- en: The **configuration path** is used to save repository information that was added
    by running the `helm repo add` command. When a chart that has not been cached
    is installed, Helm uses the configuration path to look up the URL of the chart
    repository. Helm uses that URL to understand where the chart resides for it to
    be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The **data path** is used to store plugins. When a plugin is installed using
    the `helm plugin install` command, the plugin data is stored in this location.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the remaining environment variables we previously detailed, `HELM_DRIVER`
    is used to determine how the release state is stored in Kubernetes. The default
    value is `secret`, which is also the recommended value. `Secret` will Base64-encode
    the state in a Kubernetes **Secret**. Other options are `configmap`, which will
    store state in a plaintext Kubernetes ConfigMap and `memory`, which will store
    the state in the local process's memory. The use of local memory is intended for
    testing purposes and is not suitable for general purpose or production environments.
  prefs: []
  type: TYPE_NORMAL
- en: The `HELM_NO_PLUGINS` environment variable is used to disable plugins. If unset,
    the default value that keeps plugins enabled is `0`. To disable plugins, the variable
    should be set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `KUBECONFIG` environment variable is used to set the file used for authentication
    to the Kubernetes cluster. If unset, the default value will be `~/.kube/config`.
    In most cases, users will not need to modify this value.
  prefs: []
  type: TYPE_NORMAL
- en: Another component of Helm that can be configured is tab completion, discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash and Z shell users can enable tab completion to simplify Helm usage. Tab
    completion allows Helm commands to be auto-completed when the *Tab* key is pressed,
    allowing users to perform tasks faster and helping prevent input mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how most modern terminal emulators behave by default. When
    the *Tab* key is pressed, terminals try to guess what the next argument needs
    to be by observing the state of the command and the environment. For example,
    the `cd /usr/local/b` input can be tab-completed to `cd /usr/local/bin` in a Bash
    shell. Similarly, an input such as `helm upgrade hello-` can be tab-completed
    to read `helm upgrade hello-world`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tab completion can be enabled by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `$SHELL` variable must be either `bash` or `zsh`. Note that auto-completion
    will only exist in terminal windows that run the preceding command, so other windows
    will need to run this command as well to experience the auto-completion feature.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm needs to be able to authenticate with a Kubernetes cluster in order to
    deploy and manage applications. It authenticates by referencing a `kubeconfig`
    file, which specifies different Kubernetes clusters and how to authenticate against
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Those of you who are using Minikube when following this book will not need to
    configure authentication, as Minikube automatically configures a `kubeconfig`
    file each time a new cluster is created. Those of you who aren't running Minikube,
    however, will likely need to create a `kubeconfig` file or have one provided,
    depending on the Kubernetes distribution you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `kubeconfig` file can be created by leveraging three different `kubectl`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command is `set-cluster`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `set-cluster` command will define a `cluster` entry in the `kubeconfig`
    file. It determines the Kubernetes cluster's hostname or IP address, along with
    its certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command is `set-credentials`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `set-credentials` command will define the name of a user along with its
    authentication method and details. This command can configure a username and password
    pair, client certificate, bearer token, or authentication provider to allow users
    and administrators the ability to specify varying different methods of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the `set-context` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `set-context` command is used to associate a credential to a cluster. Once
    an association between a credential and a cluster is established, the user will
    be able to authenticate to the specified cluster using the credential's authentication
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kubectl config view` command can be used to view the `kubeconfig` file.
    Notice how the `clusters`, `contexts`, and `user` stanzas of `kubeconfig` correspond
    to the previously described commands, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Once a valid kubeconfig file is present, Kubectl and Helm will be able to interact
    with a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how authorization is handled against a
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization/RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While authentication is a means of confirming identity, authorization defines
    the actions that an authenticated user is allowed to perform. Kubernetes uses
    **role-based access control** (**RBAC**) to perform authorization on Kubernetes.
    RBAC is a system of designing roles and privileges that can be assigned to a given
    user or group of users. The actions a user is permitted to perform on Kubernetes
    depends on the roles that the user has been assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes provides many different roles on the platform. Three common roles
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster-admin`: Allows a user to perform any action against any resource throughout
    the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit`: Allows a user to read and write to most resources within a namespace
    or a logical grouping of Kubernetes resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view`: Prevents a user from modifying existing resources, and only allows
    users to read resources within a namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Helm authenticates to Kubernetes using the credentials defined in the
    `kubeconfig` file, Helm is given the same level of access as the users defined
    in the file. If `edit` access is enabled, Helm can be assumed to have sufficient
    permission to install applications, in most cases. For only view access, Helm
    will not be able to install applications, as this level of access is read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users that run Minikube are given `cluster-admin` by default after cluster
    creation. While this would not be best practice in a production environment, it
    is acceptable for learning and experimenting. Those of you running Minikube will
    not have to worry about configuring authorization in order to follow along with
    both the concepts and examples provided in this book. Those of you using other
    Kubernetes clusters that aren''t Minikube will need to make sure they are given
    at least the edit role to be able to deploy most applications with Helm. This
    can be done by asking an administrator to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Best practices around RBAC will be discussed in [*Chapter 9*](B15458_09_Final_JM_ePub.xhtml#_idTextAnchor416),
    *Helm Security Considerations* when we discuss, in greater detail, the concepts
    related to security, including how to appropriately apply roles to prevent mistakes
    or malicious intent in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of different components you will need to have available
    in order to start using Helm. In this chapter, you learned how to install Minikube
    to provide a local Kubernetes cluster that can be used throughout this book. You
    also learned how to install Kubectl, which is the official tool for interacting
    with the Kubernetes API. Finally, you learned how to install the Helm client and
    explored the various ways that Helm can be configured, which includes adding repositories
    and plugins, modifying environment variables, enabling tab completion, and configuring
    authentication and authorization against a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the prerequisite tooling installed, you can begin to learn
    how to deploy your first application with Helm. In the next chapter, you will
    install a Helm chart from an upstream chart repository, as well as learn about
    life cycle management and application configuration. After finishing the chapter,
    you will have an understanding of how Helm acts as the package manager for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links to learn more about the installation options
    available for Minikube, Kubectl, and Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube: [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubectl: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helm: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We covered various different ways of configuring Helm post-installation. Check
    out the following links to learn more about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repository management: [https://helm.sh/docs/intro/quickstart/#initialize-a-helm-chart-repository](https://helm.sh/docs/intro/quickstart/#initialize-a-helm-chart-repository)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plugi[n management: https://helm.sh/docs/t](https://helm.sh/docs/topics/plugins/)opics/plugins/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment variables and the `helm help` output: [https://helm.sh/docs/helm/helm/](https://helm.sh/docs/helm/helm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tab completion: [https://helm.sh/docs/helm/helm_completion/](https://helm.sh/docs/helm/helm_completion/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication and authorization via the `kub`[`econfig` file: https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-mult](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)iple-clusters/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you list the various methods you can use to install the Helm client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Helm authenticate to a Kubernetes cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What mechanism is in place to provide authorization to the Helm client? How
    can an administrator manage these privileges?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `helm repo add` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three XDG environment variables used by Helm? What purpose do they
    serve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is Minikube a good choice for learning how to use Kubernetes and Helm? What
    does Minikube automatically configure for users to allow them to get started more
    rapidly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

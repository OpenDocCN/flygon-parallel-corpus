- en: '*Chapter 7*: Automating Helm Processes Using CI/CD and GitOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have so far discussed two high-level processes. First, we explored
    using Helm as an end user, leveraging Helm as a package manager to deploy applications
    of varying complexities to Kubernetes. Second, we explored developing and testing
    Helm charts as a chart developer, which involved encapsulating Kubernetes complexities
    in Helm charts and performing tests on charts to ensure that the required features
    were delivered to end users successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these processes involve invoking various different Helm CLI commands.
    These Helm CLI commands, while effective in carrying out their respective tasks,
    require manual invocation from the command line. Manual invocation can serve as
    a pain point when managing multiple different charts or applications and can make
    it difficult for larger enterprises to scale. As a result, we should explore alternative
    options that provide additional automation on top of what Helm already provides.
    In this chapter, we will investigate concepts relating to **Continuous Integration**
    and **Continuous Delivery** (**CI**/**CD**) and `GitOps`, which are methodologies
    that can automatically invoke the Helm CLI along with other commands in order
    to perform automated workflows against the contents of a Git repository. These
    workflows can be used to automatically deploy applications using Helm and to build,
    test, and package Helm charts during the chart development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI/CD and GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CI pipeline to build Helm charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CD pipeline to deploy applications with Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires you to have the following technologies installed on your
    local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples used in this chapter on GitHub at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm).
    This repository will be referenced throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI/CD and GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have addressed many of the key concepts that are inherent to Helm
    development—building, testing, and deploying. However, our exploration has been
    limited to manual configurations and invocations of the Helm CLI. While this is
    okay when getting started with Helm, as you look to move a chart into a production-like
    environment, there are several questions that you need to consider, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I be sure that the best practices for chart development and deployment
    are enforced?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the implications of collaborators participating in the development
    and deployment processes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points are applicable to any software project, not just to Helm chart
    development. While we have covered a lot of best practices so far, when taking
    on new collaborators, they may not have the same understanding of these topics
    or the discipline to perform these crucial steps. Through the use of automation
    and repeatable processes, concepts such as CI/CD have been established to address
    some of these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need for an automated software development process that can be adhered to
    each time a software change occurs led to the creation of CI. CI not only ensures
    that best practices are adhered to, but it also helps eliminate the common challenges
    faced by many developers, as embodied in the phrase 'it works on my machine.'
    One factor that we discussed previously is the use of **version control systems**,
    such as `git`, to store source code. Often, each user would have their own independent
    copy of source code, which made maintaining the code base challenging to manage
    as additional contributors were brought on.
  prefs: []
  type: TYPE_NORMAL
- en: CI is properly enabled through the use of an automation tool, where source code
    is retrieved and undergoes a predetermined set of steps whenever changes occur.
    The need for a proper automation tool led to the rise of software specifically
    designed for this purpose. Several examples of CI tools include Jenkins, TeamCity,
    and Bamboo, along with a variety of **Software-as-a-Service** (**SaaS**)-based
    solutions. By offloading the responsibility of tasks onto a third-party component,
    developers are more likely to commit code frequently and project managers can
    feel confident in the skill of their teams and the robustness of their products.
  prefs: []
  type: TYPE_NORMAL
- en: One key feature that is found in most of these tools is the ability to provide
    timely notifications on the current state of a project. Instead of discovering
    a breaking change later in the software development cycle, through the use of
    CI, as soon as changes are incorporated, processes are executed and notifications
    to interested parties are transmitted. By making use of rapid notifications, it
    provides the user who introduced the change with the opportunity to resolve the
    issue while the area of interest is at the front of the mind, instead of later
    on in the delivery process when they may be occupied elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to apply many of CI's concepts throughout an entire software delivery
    life cycle as an application moves its way toward production led to the creation
    of CD. CD is a set of defined steps written to progress software through a release
    process (more commonly referred to as a pipeline). CI and CD are typically paired
    together as many of the same execution engines that perform CI can also implement
    CD. CD has gained acceptance and popularity among many organizations where proper
    change control is enforced and approvals are required in order for the software
    release process to progress to the next stage. As many of the concepts around
    CI/CD are automated in a repeatable fashion, teams can look to fully eliminate
    the need for the manual approval steps once they feel confident that they have
    a reliable framework in place.
  prefs: []
  type: TYPE_NORMAL
- en: The process of implementing a fully automated build, test, deployment, and release
    process without any human intervention is known as **continuous deployment**.
    While many software projects never fully achieve continuous deployment, by just
    implementing the concepts emphasized by CI/CD, teams are able to produce real
    business value faster. In the next section, we will introduce GitOps as a mechanism
    to improve the management of applications and their configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Taking CI/CD to the next level using GitOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is a platform that embraces the use of declarative configuration.
    In the same way that an application written in any programming language, such
    as Python, Golang, or Java traverses its way through a CI/CD pipeline, Kubernetes
    manifests can implement many of the same patterns. Manifests should also be stored
    in a source code repository, such as Git, and can undergo the same type of build,
    test, and deployment practices. The rise in popularity of managing the life cycle
    of Kubernetes cluster configuration within Git repositories and then applying
    these resources in an automated fashion led to the concept of GitOps. First introduced
    by the software company WeaveWorks in 2017, GitOps has increased in popularity
    ever since as a way to manage Kubernetes configurations. While GitOps is best
    known in the context of Kubernetes, its principles can be applied to any cloud-native
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to CI/CD, tools have been developed to manage the GitOps process. These
    include **ArgoCD from Intuit** and **Flux by WeaveWorks**, the organization responsible
    for coining the term GitOps. You do not need to use a tool that is specifically
    designed for GitOps as any automation tool, particularly one designed for managing
    the CI/CD process, can be utilized. The key differentiator between a traditional
    CI/CD tool and a tool designed for GitOps is the ability for the GitOps tool to
    constantly observe the state of the Kubernetes cluster and apply the desired configurations
    whenever the current state does not match the desired state, as defined in the
    manifests stored in Git. These tools make use of the controller pattern that is
    fundamental to Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since Helm charts are ultimately rendered as Kubernetes resources, they, too,
    can be used to participate in the GitOps process and many of the aforementioned
    GitOps tools natively support Helm. We will see how to make use of Helm charts
    using CI/CD and GitOps throughout the remainder of this chapter, leveraging Jenkins
    as the tool of choice for both CI and CD.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop two different pipelines to demonstrate how
    different processes around Helm can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following steps to begin setting up your local environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, given the increased memory requirements of this chapter, you should
    delete your `minikube` cluster and recreate it with `4g` of memory if it was not
    inititalized with 4g of memory in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098)*,
    Preparing a Kubernetes and Helm Environment*. This can be done by running the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Minikube starts, create a new namespace called `chapter7`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should, additionally, fork the Packt repository, which will allow you to
    make modifications against the repository based on the steps described in these
    exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a fork of the Packt repository by clicking the **Fork** button on the
    Git repo:![Figure 7.1 – Select the Fork button to fork the Packt repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Select the Fork button to fork the Packt repository
  prefs: []
  type: TYPE_NORMAL
- en: You must have a GitHub account to fork a repository. The process of creating
    a new account is described in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create a fork of the Packt repository, clone this fork to your local
    machine by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to creating a fork of the Packt repository, you may want to remove
    the `guestbook` chart from your Helm repository, served from your GitHub Pages
    repository, which we created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. While it is not strictly necessary, the examples
    in this chapter will assume a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to remove this chart from your chart repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the local clone of your Helm chart repository. As you will recall,
    the name we recommended for your chart repository was `Learn-Helm-Chart-Repository`,
    so we will use this name throughout this chapter to refer to your GitHub Pages-based
    chart repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `guestbook-1.0.0.tgz` and `index.yaml` files from your chart repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Push these changes to your remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to confirm in GitHub that your chart and index files have
    been removed, leaving only the `README.md` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The only file you should see in your chart repository is the
    README.md file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – The only file you should see in your chart repository is the README.md
    file
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have started Minikube, created a fork of the Packt repository,
    and removed the Guestbook chart from `Learn-Helm-Chart-Repository`, let's begin
    learning how a CI pipeline can be created to release Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CI pipeline to build Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of CI can be applied to the perspective of a chart developer who
    builds, tests, packages, and releases Helm charts to a chart repository. In this
    section, we will describe what using an end-to-end CI pipeline to streamline this
    process may look like, as well as walk you through how to build an example pipeline.
    The first step is to design the components required for the example pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, developing Helm charts was largely a manual process.
    While Helm provides automation for creating `test` hooks in a Kubernetes cluster,
    the invocation of the `helm lint`, `helm test`, or `ct lint-and-install` commands
    is manually executed after a change in code to ensure tests still pass. Once linting
    and testing continue to pass after a code change, the chart can be packaged by
    running the `helm package` command. If the chart is served using a GitHub Pages
    repository (such as the one created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm chart*), the `index.yaml` file is created by running
    `helm repo index`, and the `index.yaml` file, along with the packaged chart, is
    pushed to the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: While invoking each command manually is certainly feasible, this workflow can
    become increasingly difficult to sustain as you develop additional Helm charts
    or add additional contributors. With a manual workflow, it is easy to allow untested
    changes to be made to your charts and it is difficult to ensure that contributors
    are adhering to testing and contributing guidelines. Luckily, these issues can
    be avoided by creating a CI pipeline that automates your release process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps outline an example CI workflow using the commands and tooling
    discussed throughout this book so far. It will assume that the resulting charts
    are saved in a GitHub Pages repository:'
  prefs: []
  type: TYPE_NORMAL
- en: A chart developer makes a code change to a chart or a set of charts in a `git`
    monorepo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The developer pushes the change(s) to the remote repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The charts that have been modified are automatically linted and tested in a
    Kubernetes namespace by running the `ct lint` and `ct install` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If linting and testing is successful, the charts are automatically packaged
    with the `helm package` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `index.yaml` file is automatically generated with the `helm repo index`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The packaged charts and the updated `index.yaml` file are automatically pushed
    to the repository. They are pushed to either `stable` or `staging`, depending
    on the branch that the job was run against.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will perform this process using **Jenkins**. Let's begin
    by understanding what Jenkins is and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jenkins is an open source server used to perform automated tasks and workflows.
    It is commonly used to create CI/CD pipelines via Jenkins's **pipeline as code**
    feature, written in a file called a `Jenkinsfile` that defines a Jenkins pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: A Jenkins pipeline is written using the Groovy **Domain-Specific Language**
    (**DSL**). Groovy is a language similar to Java but, unlike Java, it can be used
    as an object-oriented scripting language, lending itself to writing easy-to-read
    automation. Throughout this chapter, we will walk you through two existing `Jenkinsfile`
    files that have already been prepared for you. You do not need to have any prior
    experience with writing a `Jenkinsfile` file from scratch, as a deep dive into
    Jenkins is beyond the scope of this book. With that said, by the end of this chapter,
    you should be able to take the concepts learned and apply them to an automation
    tool of your choice. While Jenkins is featured in this chapter, its concepts can
    be applied to any other automation tool.
  prefs: []
  type: TYPE_NORMAL
- en: When a `Jenkinsfile` file is created, the defined set of steps of the workflow
    is executed on the Jenkins server itself or in a separate agent delegated to run
    the job, instead. Additional capabilities can be integrated with Kubernetes by
    automatically scheduling Jenkins agents as separate Pods whenever a build is kicked
    off, simplifying the creation and management of agents. After an agent completes,
    it can be configured to automatically terminate so that the next build can run
    in a fresh, clean Pod. In this chapter, we will run the example pipelines using
    Jenkins agents.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins also lends itself well to the concept of GitOps by providing the ability
    to scan a source control repository for the presence of a `Jenkinsfile` file.
    For each branch that contains a `Jenkinsfile` file, a new job is automatically
    configured that will begin by cloning the repository against the desired branch.
    This makes it simple to test new features and fixes as new jobs can be automatically
    created alongside their corresponding branches.
  prefs: []
  type: TYPE_NORMAL
- en: With a basic understanding of Jenkins, let's now install Jenkins on our Minikube
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: 'As with many applications that are commonly deployed on Kubernetes, Jenkins
    can be deployed with one of many different community Helm charts from Helm Hub.
    In this chapter, we will use the Jenkins Helm chart from the **Codecentric** software
    development company. Add the `codecentric` chart repository to begin installing
    the Codecentric Jenkins Helm chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Among the expected Kubernetes-related values, such as configuring the resource
    limits and the service type, the `codecentric` Jenkins Helm chart contains other
    Jenkins-related values used to automatically configure different Jenkins components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since configuring these values requires a deeper understanding of Jenkins that
    is beyond the scope of this book, a `values` file is provided for you that will
    automatically prepare the following Jenkins configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Add relevant Jenkins plugins that are not included in the base image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the credentials required to authenticate with GitHub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a Jenkins agent specifically designed for testing and installing Helm
    charts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Jenkins to automatically create a new job based on the presence of
    the `Jenkinsfile` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip manual prompts that normally occur on the startup of a new installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable authentication to simplify Jenkins access for this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `values` file will also configure the following Kubernetes-related details:'
  prefs: []
  type: TYPE_NORMAL
- en: Set resource limits against the Jenkins server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the Jenkins service type to `NodePort.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the ServiceAccounts and RBAC rules required for Jenkins and Jenkins agents
    to run jobs and deploy Helm charts in the Kubernetes environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the Jenkins `PersistentVolumeClaim` size to `2Gi.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This values file is available at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml](https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml).
    When browsing the content of these values, you may notice that the configuration
    defined under `fileContent` contains Go templating. The beginning of this value
    can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The values.yaml file for the Jenkins Helm chart contains Go
    templating](image/Figure_7.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The `values.yaml` file for the Jenkins Helm chart contains Go templating
  prefs: []
  type: TYPE_NORMAL
- en: 'While Go templating is not normally valid in a `values.yaml` file, the Codecentric
    Jenkins Helm chart supplies the `fileContent` configuration to a template function
    called `tpl`. A simplified view of what this looks like on the template side is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `tpl` command will parse the `fileContent` value as a Go template, allowing
    it to contain Go templating even though it is defined in a `values.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, the Go templating defined in the `fileContent` configuration
    helps ensure that Jenkins is installed in a way that corresponds with this chapter''s
    requirements. Namely, the templating will require the following additional values
    to be provided during installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`githubUsername`: The GitHub username'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`githubPassword`: The GitHub password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`githubForkUrl`: The URL of your Packt repository fork, which was taken in
    the *Technical requirements* section of this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`githubPagesRepoUrl`: The URL of your GitHub Pages Helm repository, which was
    created at the end of [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this is not the URL to your static site, but the URL to the GitHub
    repository itself—for example, https://github.com/$GITHUB_USERNAME/Learn-Helm-Chart-Repository.git.
  prefs: []
  type: TYPE_NORMAL
- en: The four values described in the preceding list can be provided using the `--set`
    flag, or they can be provided from an additional `values` file using the `--values`
    flag. If you choose to create a separate `values` file, ensure that you do not
    commit and push that file to source control as it contains sensitive information.
    The example in this chapter favors the `--set` flag for these four values. In
    addition to the values described, the `values.yaml` file included in the Packt
    repository should also be provided using the `--values` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install your `Jenkins` instance with the `helm install` command, using the
    following example as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can monitor the installation by running a watch against the Pods in the
    `chapter7` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that in very rare cases, your Pod may become stuck at the `Init:0/1` stage.
    This can occur if availability issues to external dependencies, such as if the
    Jenkins plugin site and its mirrors were experiencing downtime. If this occurs,
    try deleting your release and reinstalling it after several minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your Jenkins Pod reports `1/1` under the `READY` column, your `Jenkins`
    instance is ready to be accessed. Copy and paste the following contents of the
    displayed post-installation notes to reveal the Jenkins URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you access Jenkins, your front page should look similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Jenkins home page after running the Helm installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The Jenkins home page after running the Helm installation
  prefs: []
  type: TYPE_NORMAL
- en: If the chart were installed properly, you'll notice that a new job called **Test
    and Release Helm Charts** is created. At the bottom left-hand corner of the page,
    you'll notice the **Build Executor Status** panel, which is used to provide an
    overview of the active jobs that are currently running. A job is automatically
    triggered for the first time when it is created, which is why you will see it
    running when you log in to your Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that Jenkins is installed and its frontend has been validated, let's walk
    through the example `Jenkinsfile` file from the Packt repository to understand
    how the CI pipeline works. Note that we will not display the full contents of
    the `Jenkinsfile` file in this chapter as we want to simply highlight the key
    areas of interest. The full contents of the file can be viewed in the Packt repository
    at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that occurs when the `Test and Deploy Helm Charts` job is triggered
    is that a new Jenkins agent is created. By leveraging the values provided in `Learn-Helm/jenkins/values.yaml`,
    the Jenkins chart installation automatically configures a Jenkins agent called
    `chart-testing-agent`. The following line designates that agent as the agent for
    this `Jenkinsfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This agent is configured by the Jenkins chart values to run using the chart
    testing image provided by the Helm community. The chart testing image, located
    at `quay.io/helmpack/chart-testing`, contains many of the tools that were discussed
    in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292), *Testing Helm
    Charts*. Specifically, this image contains the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`helm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ct`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamllint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yamale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this image contains all of the tools required to test the Helm charts,
    it can be used as the primary image to perform CI for our Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: When a Jenkins agent is run, it clones your GitHub fork, specified by the `githubForkUrl`
    value, using `githubUsername` and `githubPassword` for authentication. This is
    performed implicitly by Jenkins, so no code needs to be specified within the `Jenkinsfile`
    file to perform this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Jenkins agent clones your repository, it begins executing the stages
    defined in the `Jenkinsfile` file. Stages are logical groupings within a pipeline
    that can help visualize the high-level steps. The first stage that will be performed
    is the lint stage, which contains the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `sh` portion in the preceding command is a command used to run a bash shell
    or script and invokes the `lint` subcommand of the `ct` tool. As you will recall,
    this command lints the `Chart.yaml` and `values.yaml` files on all charts that
    have been modified against the master branch, which we covered in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292),
    *Testing Helm Charts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the linting is successful, the pipeline will continue on to the test stage
    and will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command should look familiar, also. It installs each modified chart from
    its version on the master branch and performs the defined test suites. It also
    ensures any upgrades from the previous version are successful, which aids in helping
    to prevent regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two previous stages could have been combined by running a single
    `ct lint-and-install --upgrade` command. This would still have resulted in a valid
    pipeline, but this example, which is broken up into separate stages, allows better
    visualization of the actions that are performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the test stage is successful, the pipeline proceeds to the package charts
    stage, which executes the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The command at this stage will simply package each chart contained under the
    `helm-charts/charts` folder. It will also update and download each dependency
    that is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the packaging is successful, the pipeline proceeds to the final stage, called
    `push charts to repo`. This is the most complex stage, so we will break it up
    into smaller steps. The first step can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the Helm chart repository that we are pushing to is a separate GitHub
    Pages repository, we must clone the repository so that we can add the new charts
    and push the changes. Once the GitHub Pages repository is cloned, a variable called
    `repoType` is set, depending on the branch that the CI/CD pipeline runs against.
    This variable is used to determine whether the charts packaged in the previous
    stage should be pushed to the `stable` or `staging` chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: For this pipeline, `stable` implies that the charts have been tested, validated,
    and merged into the master branch. `staging` implies that the chart is under development
    and has not yet been merged into the master branch nor been officially released.
    You can, alternatively, release charts under the stable repository when you cut
    to a release branch, but for this example, we will take the former approach of
    assuming every merge into master is a new release.
  prefs: []
  type: TYPE_NORMAL
- en: '`stable` and `staging` are served as two separate chart repositories; this
    can be done by creating two separate directories at the top level of the GitHub
    Pages repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The stable and staging folders then contain their own `index.yaml` files to
    differentiate them as separate chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, the final snippet of the preceding pipeline excerpt creates
    the `stable` or `staging` folders automatically if the pipeline execution based
    on the branch relies on its existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the type of repository that the charts should be pushed to has been
    determined, we proceed to the next stage of the pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first command copies each of the packaged charts from the previous stage
    to the `stable` or `staging` folders. Next, the `stable` or `staging` `index.yaml`
    file is updated using the `helm repo index` command to reflect the changed or
    added charts.
  prefs: []
  type: TYPE_NORMAL
- en: One point to keep in mind is that if we use a different chart repository solution,
    such as **ChartMuseum** (a chart repository solution maintained by the Helm community),
    the `helm repo index` command is not needed since the `index.yaml` file is automatically
    updated when ChartMuseum receives a new packaged Helm chart. For implementations
    that do not automatically calculate the `index.yaml` file, such as GitHub Pages,
    the `helm repo index` command is necessary, as we can see in this pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The final two commands from the preceding snippet set the `git` `username` and
    `email`, which are required to push contents to a `git` repository. For this example,
    we will set the username to `chartrepo-robot` to indicate that a CI/CD process
    facilitated the `git` interactions an[d we will set the email to](mailto:chartrepo-robot@example.com)
    as an example value. You probably want the email to represent the organization
    in charge of maintaining the chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to push the changes. This action is captured in the final
    pipeline snippet, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The packaged charts are first added and committed using the `git add` and `git
    commit` commands. Next, a push to the repository is performed with the `git push`
    command, using a credential called `github-auth`. This credential was created
    during installation from the `githubUsername` and `githubPassword` values. The
    `github-auth` credential allows you to securely refer to these secrets without
    printing them in plaintext in your pipeline code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Helm community has published a tool called `Chart Releaser` ([https://github.com/helm/chart-releaser](https://github.com/helm/chart-releaser))
    that can be used as an alternative to generating the `index.yaml` file with the
    `helm repo index` command and uploading it to GitHub with `git push`. The `Chart
    Releaser` tool is designed to abstract some of this additional complexity by managing
    the Helm charts contained in GitHub Pages.
  prefs: []
  type: TYPE_NORMAL
- en: We have decided not to implement the pipeline using this tool in this chapter,
    however, because `Chart Releaser` does not support Helm 3 (at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have provided an overview of the CI pipeline, let's run through
    an example execution.
  prefs: []
  type: TYPE_NORMAL
- en: Running the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed earlier, the first run of this pipeline was actually triggered
    automatically when we installed Jenkins. The job was run against the master branch
    and can be seen by clicking the **Test and Release Helm Charts** link on the Jenkins
    landing page. You will observe that one successful job ran against the master
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The first runthrough of the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The first runthrough of the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Every pipeline build in Jenkins has an associated log that contains the output
    of the execution. You can access the log for this build by selecting the **#1**
    link next to the blue circle on the left-hand side and then selecting **Console
    Output** on the next screen. The logs for this build reveal that the first stage,
    `Lint`, succeeded by displaying this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we would expect because no charts were changed from the perspective
    of the master branch. A similar output can be seen under the install stage as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both the Lint and Install stages completed without error, the pipeline
    continued to the Package Charts stage. Here, you can view the output::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the pipeline concludes by cloning your GitHub Pages repository, creating
    a `stable` folder within it, copying the packaged charts over to the `stable`
    folder, committing the changes to the GitHub Pages repository locally, and pushing
    the changes to GitHub. We can observe that each file that was added to our repository
    is outputted in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be curious to know what your GitHub Pages repository looks like after
    the automatic push. Your repository should look as follows, with a new `stable`
    folder containing the Helm charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The state of the repository after the CI pipeline completes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The state of the repository after the CI pipeline completes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `stable` folder, you should be able to see three different files, two
    separate charts, and one `index.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The contents of the stable folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – The contents of the `stable` folder
  prefs: []
  type: TYPE_NORMAL
- en: This first pipeline build successfully created the initial set of `stable` charts,
    but it did not demonstrate how new charts can be linted and tested before being
    deemed stable and ready for end users to consume. To demonstrate this, we need
    to cut a feature branch off the master branch to modify one or more charts, push
    the changes to the feature branch, and then start a new build in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create a new branch called `chapter7` off of the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: On this branch, we will simply modify the version of the `ngnix` chart to trigger
    the chart's linting and testing. NGINX is a web server and a reverse proxy. It
    is much more lightweight than the Guestbook application we have been working with
    in this book, so for that reason, we will use the `ngnix` chart from the Packt
    repository for this example to avoid any resource constraints that might occur
    with Jenkins also running in your Minikube environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `helm-charts/charts/nginx/Chart.yaml` file, change the version of the
    chart from `1.0.0` to `1.0.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `git status` to confirm that a change was detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `ngnix` `Chart.yaml` file has been modified. Add the file and
    then commit the changes. Finally, you can proceed with pushing the change to your
    fork:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Within Jenkins, we need to trigger a repository scan so that Jenkins can detect
    and start a new build against this branch. Navigate to the **Test and Release
    Helm Charts** page. You can easily do so by clicking on the **Test and Release
    Helm Charts** tab on the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The Test and Release Helm Charts page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – The Test and Release Helm Charts page
  prefs: []
  type: TYPE_NORMAL
- en: 'Once selected, click the **Scan Multibranch Pipeline Now** button in the left-hand
    side menu. This allows Jenkins to detect your new branch and to automatically
    start a new build. The scan should complete within approximately 10 seconds. Refresh
    the page and the new `chapter7` branch should appear on the page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The Test and Deploy Helm Charts page after scanning for the
    new chapter7 branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – The Test and Deploy Helm Charts page after scanning for the new
    `chapter7` branch
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chapter7` job will run for a longer period of time than the master job
    since the `chapter7` job contains a modified Helm chart that is tested with the
    chart testing tool. You can observe this pipeline in action by navigating to the
    console output for `chapter7`. From the **Test and Release Helm Charts** overview
    page, select the [*Chapter 7*](B15458_07_Final_JM_ePub.xhtml#_idTextAnchor335)
    branch and then the **#1** link at the bottom left-hand side. Finally, select
    the **Console Output** link. If you navigate to this page while the pipeline is
    still running, you will receive the log updates as they occur in real time. Wait
    until the end of the pipeline, where the following message should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Toward the beginning of the console output logs, notice how the `ct lint` and
    `ct install` commands were run against the `ngnix` chart as this was the only
    chart where a change occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The additional output for each command should already be familiar as it is the
    same as the output that was described in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292),
    *Testing Helm Charts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your GitHub Pages repository, you should see the new version of the `ngnix`
    chart in the `staging` folder as it was not built against the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The contents of the staging folder](image/Figure_7.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – The contents of the `staging` folder
  prefs: []
  type: TYPE_NORMAL
- en: 'To release the `nginx-1.0.1.tgz` chart, you need to merge the `chapter7` branch
    into the master branch, which will cause this chart to be pushed to the stable
    repository. On the command line, merge your `chapter7` branch into the master
    branch and push it to the `remote` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Within Jenkins, navigate to the master pipeline job by returning to the **Test
    and Release Helm Charts** page and clicking on the **master** job. Your screen
    should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The master job for the Test and Release Helm charts project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – The master job for the Test and Release Helm charts project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once on this page, click on the **Build Now** link on the left-hand side. Once
    again, notice in the logs that chart tests were skipped because the chart testing
    tool compared the clone against the master branch. Since the content is the same,
    the tool determines that there is no testing to be done. When the build finishes,
    navigate to your GitHub Pages repository to confirm the new `nginx-1.0.1.tgz`
    chart is under the `stable` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The state of the repository after the new nginx chart has been
    added'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – The state of the repository after the new `nginx` chart has been
    added
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that these charts are deployed properly to the GitHub Pages
    `stable` repository by adding the repository locally using `helm repo add`. In
    [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart*, you added the root location of the GitHub Pages repository.
    However, we modified the file structure to contain the `stable` and `staging`
    folders. If it is still configured, you can remove this repository by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The repository can be added again with the updated location of the `stable`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that the value of `$GITHUB_PAGES_SITE_URL` references the static site that
    GitHub serves and not your actual `git` repository. Your GitHub Pages site URL
    should have a format similar to [https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable).
    The exact link can be found in the **Settings** tab of your GitHub Pages repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the `stable` repository, run the following command to view each
    of the charts that have been built and pushed over the course of the two master
    builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see three results, two of which contain both versions of the `nginx`
    chart that was built and pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Results from the helm search repo command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – Results from the `helm search repo` command
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how the life cycle of Helm charts can be managed
    through a CI pipeline. By following an automated workflow using the example provided,
    you can easily perform routine linting and testing before releasing charts to
    end users.
  prefs: []
  type: TYPE_NORMAL
- en: While this section focused primarily on the CI of Helm charts, CD and GitOps
    can also be implemented to deploy Helm charts to different environments. We will
    explore how a CD pipeline can be built in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CD pipeline to deploy applications with Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CD pipeline is a set of repeatable steps that can deploy to one or more different
    environments in an automated fashion. In this section, we will create a CD pipeline
    to deploy the `nginx` chart that we tested and pushed to our GitHub Pages repository
    in the previous section. GitOps will also be leveraged by referencing the `values`
    files saved to a `git` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Let's design the high-level steps that need to be included in this pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, deploying to a Kubernetes environment with Helm was a
    manual process. This CD pipeline, however, is designed to deploy to multiple different
    environments while abstracting the use of Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps describe the CD workflow that we will cover in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the stable GitHub Pages repository containing the `nginx` chart release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the `nginx` chart to the development environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the `nginx` chart to the **Quality Assurance** (**QA**) environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the user to approve the pipeline to proceed to the production deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the `nginx` chart to the production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CD workflow is contained in a separate `Jenkinsfile` file to the file created
    previously for the CI pipeline. Before we create the `Jenkinsfile` file, let's
    update the Minikube and Jenkins environments so that we can perform the CD process.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The development, QA, and production environments will be modeled by different
    namespaces within your local Minikube cluster. While we would usually discourage
    you from allowing non-production (development and QA) and production environments
    to coexist within the same cluster, we will co-locate these three environments
    just to demonstrate our example CD process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `dev`, `qa`, and `prod` namespaces to represent each of these environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You should also delete the `chapter7` branch that you created in the previous
    section. This branch should be deleted because when the new CD pipeline is created,
    Jenkins will attempt to run it against each of your repository's branches. For
    simplicity and to avoid resource constraints, we recommend advancing with only
    the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `chapter7` branch from your repository with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will need to upgrade your Jenkins instance to set an environment
    variable called `GITHUB_PAGES_SITE_URL`. This is the location of your chart repository
    in GitHub Pages that has a [https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable)
    format. The environment variable is referenced in the CD pipeline to add the `stable`
    GitHub Pages chart repository with `helm repo add`. To add this variable, you
    can reuse the values that were previously applied by using the `--reuse-values`
    flag, while also specifying an additional value called `githubPagesSiteUrl` by
    using `--set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to upgrade your Jenkins instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This upgrade will cause your Jenkins instance to restart. You can wait for
    the Jenkins Pod to be ready by running a watch against the `chapter7` namespace''s
    Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Jenkins Pod is available when it indicates that `1/1` containers are ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jenkins is ready, access the Jenkins instance by using the same URL from
    the previous section. You should find another job, called `Deploy NGINX Chart`,
    which represents the CD pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – The Jenkins front page after upgrading the Jenkins release'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – The Jenkins front page after upgrading the Jenkins release
  prefs: []
  type: TYPE_NORMAL
- en: This job is configured in the `values.yaml` file to be created when GITHUB_PAGES_SITE_URL
    is set (to help improve the flow of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Note that as with the CI pipeline, the CD pipeline also starts automatically
    since it is detected for the first time. Before we review this pipeline's logs,
    let's examine the process that makes up the CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will just review the key areas of the pipeline, but the
    full CD pipeline has been written up and is located at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous CI pipeline, to test and release Helm charts, the CD pipeline
    begins by dynamically creating a new Jenkins agent as a Kubernetes Pod running
    the chart testing image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Although we are not using the `ct` tool in this pipeline, the chart testing
    image contains the Helm CLI that is required to perform the `nginx` deployments,
    so the image suffices for this example CD pipeline. However, it would also be
    acceptable to create a smaller image that removes the tools that are not utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Once an agent is created, Jenkins implicitly clones your fork, as it did previously
    in the CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first explicitly defined stage of the pipeline is called `Setup`, which
    adds your `stable` chart repository hosted in GitHub Pages to the local Helm client
    on the Jenkins agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository is added, the pipeline can begin deploying NGINX to the
    different environments. The next stage, called `Deploy to Dev`, deploys the NGINX
    chart to your `dev` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first detail you might notice about this stage is the `dir('nginx-cd')`
    closure. This is the `Jenkinsfile` syntax to set the working directory of the
    commands contained within it. We will explain the `nginx-cd` folder in greater
    detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that this stage runs the `helm upgrade` command with the provided
    `--install` flag. `helm upgrade` is normally performed against an already-existing
    release and fails if attempted against a release that doesn't exist. The `--install`
    flag, however, installs the chart if a release does not already exist. If a release
    does already exist, the `helm upgrade` command upgrades the release. The `--install`
    flag is convenient for use for automated processes, such as the CD pipeline described
    in this section, because it prevents you from needing to perform a check to determine
    the existence of a release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting detail about this `helm upgrade` command is that it uses
    the `--values` flag twice—once against a file called `common-values.yaml` and
    once against a file called `dev/values.yaml`. Both of these files are located
    in the `nginx-cd` folder. The following contents are found in the `nginx-cd` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When deploying an application to different environments, you may need to slightly
    modify the application''s configuration to allow it to integrate with other services
    in the environment. Each of the `values` files under the `dev`, `qa`, and `prod`
    folders contain an environment variable that is set on the NGINX deployment, depending
    on the environment that it is deployed to. For example, the `dev/values.yaml`
    file contents are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `qa/values.yaml` file contents are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prod/values.yaml` file contents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: While the NGINX chart that is deployed in this example is straightforward and
    does not strictly require these values to be specified, you will find it helpful
    to separate environment-specific configurations in separate `values` files using
    the method shown here for complex and real-world use cases. The corresponding
    values file can then be applied to the installation by passing it to the `helm
    upgrade --install` command with `--values ${env}/values.yaml`, where `${env}`
    represents either `dev`, `qa`, or `prod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `common-values.yaml` file, as its name implies, is used for values that
    are common across all the deployment environments. The `common-values.yaml` file
    for this example is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This file indicates that each NGINX service created during the installation
    of the chart should have a `NodePort` type. All the other default values set in
    the NGINX chart's `values.yaml` file are also applied to each environment since
    they have not been overridden in the `common-values.yaml` file or the individual
    `values.yaml` environment files.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important point to note is that your application should be deployed as
    identically as possible across each of your deployment environments. Any value
    that changes the physical properties of your running Pods or containers should
    be specified in the `common-values.yaml` file. These configurations include, but
    are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The replica count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource requests and limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImagePullPolicy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The volume mounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Values that change the configuration to integrate with environment-specific
    services can be modified in the individual environment `values` files. These configurations
    may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The location of metrics or monitoring services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of a database or backend service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application/ingress URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notification services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circling back to the Helm command used in the `Deploy to Dev` stage of the CD
    pipeline, a combination of the `--values common-values.yaml` and `--values dev/values.yaml`
    flags merges both of these `values` files to install the `nginx` chart in `dev`.
    This command also uses the `-n dev` flag to indicate that the deployment should
    be performed in the `dev` namespace. In addition, the `--wait` flag is used to
    pause the `nginx` Pod until it is reported as `ready`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the pipeline, the next stage after deploying to `dev` is a
    smoke test. This stage runs the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The NGINX chart contains a test hook that checks the connection of the NGINX
    Pod. If the `test` hook is able to verify that a connection to the Pod can be
    made, the test is returned as successful. While the `helm test` command is often
    reserved for chart testing, it can also be used as a good way of performing a
    basic smoke test during the CD process. A smoke test is a test performed to ensure
    that the critical functions of an application work as designed after a deployment.
    Since the NGINX chart test does not interfere in any way with the running application
    or the rest of the deployment environment, the `helm test` command is an appropriate
    method of making sure that the NGINX chart is deployed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the smoke test, the example CD pipeline runs the next stage, called `Deploy
    to QA`. This stage contains a conditional that assesses whether the current branch
    the pipeline is executing against is the master branch, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This conditional allows you to use feature branches to test the deployment code
    contained in the `values.yaml` files without promoting it to higher environments.
    It implies that only Helm values contained in the master branch should be production-ready,
    although this is not the only strategy you can take when you release an application
    in a CD pipeline. Another common strategy is to allow higher-level promotions
    to take place on release branches that begin with the `release/` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Helm command used in the `Deploy to QA` stage is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Given your knowledge of the `Deploy to Dev` stage and the separation of common
    and environment-specific values, the code for `Deploy to QA` is predictable. It
    references the `qa/values.yaml` file for QA-specific values and passes the `-n
    qa` flag to deploy to the `qa` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: After deploying to `qa`, or a similar testing environment, you can run the smoke
    test described earlier again to ensure that the basic functions of the `qa` deployment
    work properly. You can also include any other automated tests, at this stage,
    that would be necessary to verify the function of your application before their
    deployment to `prod`. These details have been omitted from this example pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next stage of the pipeline is called `Wait for Input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This input step pauses the Jenkins pipeline and prompts the user with a `Deploy
    to Prod?` question. The user is given two choices—`Proceed` and `Abort`—in the
    console log of the running job. While the production deployment can be executed
    automatically without this manual step, many developers and companies prefer to
    have a human gate between the `non-prod` and `prod` deployments. This `input`
    command provides an opportunity for the user to make a decision about whether
    to continue the deployment or to abort the pipeline after the `qa` stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user decides to proceed, the final stage is executed, called `Deploy
    to Prod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This stage is almost identical to the `Deploy to Dev` and `Deploy to QA` stages,
    with the exception of the production-specific `values` file and the `prod` namespace
    defined as part of the `helm upgrade --install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the example CD pipeline has been outlined, let's observe the pipeline
    run that started when you upgraded your Jenkins instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see this CD pipeline in action, navigate to the master branch of the `Deploy
    NGINX Chart` job. On the Jenkins front page, click on **Deploy NGINX Chart** and
    **master**. Your screen should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – The master branch of the Deploy NGINX Chart CD pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – The master branch of the Deploy NGINX Chart CD pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have navigated to this page, click on the **#1** link and navigate
    to the console logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The Console Output page for the Deploy NGINX Chart CD pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – The Console Output page for the Deploy NGINX Chart CD pipeline
  prefs: []
  type: TYPE_NORMAL
- en: When you navigate to the logs, you should see a prompt that says `Deploy to
    Prod?.` We will address this soon. First, let's look back at the beginning of
    the log to review the pipeline's execution up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first deployment you can see is the `dev` deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you should see the smoke test, which was run by the `helm test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After the smoke test came the `qa` deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the input stage, which we saw when we first opened the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – The input step before deploying to prod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – The input step before deploying to prod
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Proceed** link to continue the pipeline execution, as clicking
    **Abort** will fail the pipeline and prevent the production deployment from occurring.
    You will then see the `prod` deployment occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the production deployment is successful, you will see the following
    message at the end of the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can manually verify that the deployments were successful from your command
    line. Run the `helm list` command to find the `nginx-master` releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Each command should list the `nginx` release in each namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `kubectl` to list the Pods in each namespace and verify that
    NGINX was deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The result for each namespace will be similar to the following (`dev` will
    also have a completed test Pod that was performed in the smoke test stage):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed how Helm can be used in a CD pipeline to deploy
    an application across multiple environments in Kubernetes. The pipeline relied
    on the GitOps practice of storing configuration (the `values.yaml` files) in source
    control and referenced these files to properly configure NGINX. With an understanding
    of how Helm can be used in a CD environment, you can now clean up your Minikube
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To clean up your Minikube cluster of this chapter''s exercises, delete the
    `chapter7`, `dev`, `qa`, and `prod` namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also shut down your Minikube VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Invoking the Helm CLI in CI and CD pipelines is an efficient way of further
    abstracting the capabilities that Helm provides. Chart developers can automate
    the end-to-end chart development process by writing a CI pipeline that lints,
    tests, packages, and releases charts to a chart repository. End users can write
    a CD pipeline that uses Helm to deploy a chart across multiple different environments,
    leveraging GitOps to ensure applications can be deployed and configured as code.
    Writing pipelines helps developers and companies scale applications faster and
    more easily by abstracting and automating processes that could otherwise become
    tedious and introduce human error.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce another option for abstracting the Helm
    CLI—writing a Helm operator.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the chart testing container image, go to [https://helm.sh/blog/chart-testing-intro/](https://helm.sh/blog/chart-testing-intro/).
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Jenkins and Jenkins pipelines, check out the Jenkins project
    documentation ([https://jenkins.io/doc/](https://jenkins.io/doc/)), the Jenkins
    pipeline documentation ([https://jenkins.io/doc/book/pipeline/](https://jenkins.io/doc/book/pipeline/))
    and the Multibranch Pipeline plugin documentation ([https://plugins.jenkins.io/workflow-multibranch/](https://plugins.jenkins.io/workflow-multibranch/)).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between CI and CD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between CI/CD and GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What high-level steps are included in a CI/CD pipeline for creating and releasing
    Helm charts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages does CI bring to chart developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What high-level steps are included in a CD pipeline for deploying Helm charts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages does a CD pipeline bring to a chart's end users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you maintain an application's configuration as code for multiple environments?
    What can you do to reduce boilerplate across the `values` files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

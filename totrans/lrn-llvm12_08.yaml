- en: '*Chapter 6*: IR Generation for High-Level Language Constructs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-level languages today usually make use of aggregate data types and **object-oriented
    programming** (**OOP**) constructs. **LLVM IR** has some support for aggregate
    data types, and we must implement OOP constructs such as classes on our own. Adding
    aggregate types gives rise to the question of how parameters of an aggregate type
    are passed. Different platforms have different rules, and this is also reflected
    in the IR. Being compliant with the calling convention ensures that system functions
    can be called.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to translate aggregate data types and pointers
    to LLVM IR, and how to pass parameters to a function in a system-compliant way.
    You'll also learn how to implement classes and virtual functions in LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays, structs, and pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the application binary interface right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IR code for classes and virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have acquired the knowledge to create LLVM
    IR for aggregate data types and OOP. You will also know how to pass aggregate
    data types according to the rules of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays, structs, and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For almost all applications, basic types such as `INTEGER` are not sufficient.
    For example, to represent mathematical objects such as a matrix or a complex number,
    you must construct new data types based on existing data types. These new data
    types are generally called **aggregate** or **composite types**.
  prefs: []
  type: TYPE_NORMAL
- en: '`tinylang` type of `ARRAY [10] OF INTEGER`, or the C type of `long[10]`, is
    expressed in IR as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Structures are composites of different types. In programming languages, they
    are often expressed with named members. For example, in `tinylang`, a structure
    is written as `RECORD x, y: REAL; color: INTEGER; END;` and the same structure
    in C is `struct { float x, y; long color; };`. In LLVM IR, only the type names
    are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To access a member, a numerical index is used. Like arrays, the first element
    has the index number `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The members of this structure are laid out in memory according to the specification
    in the data layout string. If necessary, unused padding bytes are inserted. If
    you need to take control of the memory layout, then you can use a packed structure,
    in which all elements have a 1-byte alignment. The syntax is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Loaded into a register, arrays and structs are treated as a unit. It is not
    possible to refer to a single element of the `%x` array-valued register as `%x[3]`,
    for example. This is due to the `%x[i]` and `%x[j]` refer to the same element
    or not. Instead, we need special instructions to extract and insert single-element
    values into an array. To read the second element, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also update an element, for example, the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both instructions work on the structure, too. For example, to access the `color`
    member from the `%pt` register, you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an important limitation on both instructions: the index must be a
    constant. For structures, this is easily explainable. The index number is only
    a substitute for the name, and languages such as C have no notion of dynamically
    computing the name of a struct member. For arrays, it is simply that it can''t
    be implemented efficiently. Both instructions have value in specific cases when
    the number of elements is small and known. For example, a complex number could
    be modeled as an array of two floating-point numbers. It''s reasonable to pass
    this array around and it is always clear which part of the array must be accessed
    during a computation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For general use in the frontend, we have to resort to pointers to memory. All
    global values in LLVM are expressed as pointers. Let''s declare a global variable,
    `@arr`, as an array of eight `i64` elements, the equivalent of the `long arr[8]`
    C declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the second element of the array, an address calculation must be performed
    to determine the address of the indexed element. Then, the value can then be loaded
    from that address. Put into a `@second` function, this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getelementptr` instruction is the workhorse for address calculations.
    As such, it needs some more explanation. The first operand, `[8 x i64]`, is the
    base type the instruction is operating on. The second operand, `[8 x i64]* @arr`,
    specifies the base pointer. Please note the subtle difference here: we declared
    an array of eight elements, but because all global values are treated as pointers,
    we have a pointer to the array. In C syntax, we work with `long (*arr)[8]`! The
    consequence is that we first have to dereference the pointer before we can index
    the element, such as `arr[0][1]` in C. The third operand, `i64 0`, dereferences
    the pointer and the fourth operand, `i64 1`, is the element index. The result
    of this computation is the address of the indexed element. Please note that no
    memory is touched by this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for structs, the index parameters do not need to be constant. Therefore,
    the `getelementptr` instruction can be used in a loop to retrieve the elements
    of an array. Structs are treated differently here: only constants can be used,
    and the type must be `i32`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, arrays are easily integrated into the code generator from
    [*Chapter 5*](B15647_05_ePub_RK.xhtml#_idTextAnchor079), *Basics of IR Generation*.
    The `convertType()` method must be extended to create the type. If the `Arr` variable
    holds the type denoter of an array, then we can add the following to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This type can be used to declare global variables. For local variables, we
    need to allocate memory for the array. We do this in the first basic block of
    the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To read and write an element, we have to generate the `getelemtptr` instruction.
    This is added to the `emitExpr()` (reading a value) and `emitAssign()` (writing
    a value) methods. To read an element of an array, the value of the variable is
    read first. Then the selectors of the variable are processed. For each index,
    the expression is evaluated and the value is stored. Based on this list, the address
    of the referenced element is calculated and the value is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing to an array element uses the same code, with the exception that you
    do not generate a `load` instruction. Instead, you use the pointer as the target
    in a `store` instruction. For records, you use a similar approach. The selector
    for a record member contains the constant field index, named `Idx`. You convert
    this constant into a constant LLVM value with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can use value in the `Builder.CreateGEP()` methods as for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the knowledge to translate aggregate data types to LLVM IR. Passing
    values of those types in a system-compliant way requires some care, and you will
    learn how to implement it correctly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the application binary interface right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the latest addition of arrays and records to the code generator, you may
    notice that sometimes the generated code does not execute as expected. The reason
    is that we have ignored the calling conventions of the platform so far. Each platform
    defines its own rules for how one function can call another function in the same
    program or a library. These rules are summarized in the **application binary interface**
    (**ABI**) documentation. Typical information includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Are machine registers used for parameter passing? If yes, which?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are aggregates such as arrays and structs passed to a function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are return values handled?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a wide variety of rules in use. On some platforms, aggregates are always
    passed indirectly, meaning that a copy of the aggregate is placed on the stack
    and only a pointer to the copy is passed as a parameter. On other platforms, a
    small aggregate (say 128- or 256-bit-wide) is passed in registers and only above
    that threshold is indirect parameter passing used. Some platforms also use floating-point
    and vector registers for parameter passing, while others demand that floating-point
    values are passed in integer registers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is all interesting, low-level stuff. Unfortunately, it leaks
    into LLVM IR. At first, this is surprising. After all, we define the types of
    all parameters of a function in LLVM IR! It turns out that this is not enough.
    To understand this, let's consider complex numbers. Some languages have built-in
    data types for complex numbers; for example, C99 has `float _Complex` (among others).
    Older versions of C do not have complex number types, but you can easily define
    `struct Complex { float re, im; }` and create arithmetic operations on this type.
    Both types can be mapped to the `{ float, float }` LLVM IR type. If the ABI now
    states that values of a built-in complex number type are passed in two floating-point
    registers, but user-defined aggregates are always passed indirectly, then the
    information given with the function is not enough for LLVM to decide how to pass
    this particular parameter. The unfortunate consequence is that we need to provide
    more information to LLVM, and this information is highly ABI-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to specify this information to LLVM: parameter attributes
    and type rewriting. What you need to use depends on the target platform and the
    code generator. The most commonly used parameter attributes are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inreg` specifies that the parameter is passed in a register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byval` specifies that the parameter is passed by value. The parameter must
    be a pointer type. A hidden copy is made of the pointed-to data and this pointer
    is passed to the called function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroext` and `signext` specify that the passed integer value should be zero-
    or sign-extended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sret` specifies that this parameter holds a pointer to memory that is used
    to return an aggregate type from the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While all code generators support the `zeroext`, `signext`, and `sret` attributes,
    only some support `inreg` and `byval`. An attribute can be added to the argument
    of a function with the `addAttr()` method. For example, to set the `inreg` attribute
    on the `Arg` argument, you call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To set multiple attributes, you can use the `llvm::AttrBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to provide additional information is to use type rewriting. With
    this approach, you disguise the original types. You can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the parameter; for example, instead of passing one complex argument, you
    can pass two floating-point arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cast the parameter into a different representation, for example, a struct of
    size 64 bits or less into an `i64` integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To cast between types without changing the bits of the value, you use the `bitcast`
    instruction. The `bitcast` instruction does not operate on aggregate types, but
    this is not a restriction as you can always use pointers. If a point is modeled
    as a struct with two `int` members, expressed as type `{ i32, i32 }` in LLVM,
    then this can be `bitcast` to `i64` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This converts the pointer to the struct into a pointer to an `i64` integer value.
    Subsequently, you can load this value and pass it as a parameter. You must only
    make sure that both types have the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes to an argument or changing the type is not complicated. But
    how do you know what you need to implement? First of all, you should get an overview
    of the calling convention used on your target platform. For example, the ELF ABI
    on Linux is documented for each supported CPU platform. Just look up the document
    and make yourself comfortable with it. There is documentation about the requirements
    of the LLVM code generators. The source of information is the Clang implementation,
    in the [https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp)
    file. This single file contains the ABI-specific actions for all supported platforms.
    It is also the single place where all information is collected.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to generate the IR for function calls to be
    compliant with the ABI of your platform. The next section covers the different
    ways to create IR for classes and virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating IR code for classes and virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern programming languages support object orientation using classes.
    A **class** is a high-level language construct, and in this section, we explore
    how we can map a class construct into LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing single inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is a collection of data and methods. A class can inherit from another
    class, potentially adding more data fields and methods or overriding existing
    virtual methods. Let''s illustrate this with classes in Oberon-2, which is also
    a good model for `tinylang`. A `Shape` class defines an abstract shape with a
    color and an area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetColor` method only returns the color number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The area of an abstract shape cannot be calculated, so this is an abstract
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shape` type can be extended to represent a `Circle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For a circle, the area can be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The type can also be queried at runtime. If `shape` is a variable of the `Shape`
    type, then we can formulate a type test in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The different syntax aside, this works much like in C++. One notable difference
    to C++ is that the Oberon-2 syntax makes the implicit `this` pointer explicit,
    calling it the receiver of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic problems to solve are how to lay out a class in memory and how to
    implement the dynamic call of methods and runtime type checking. For the memory
    layout, this is quite easy. The `Shape` class has only one data member, and we
    can map it to a corresponding LLVM structure type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Circle` class adds another data member. The solution is to append the
    new data member at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that a class can have many subclasses. With this strategy, the
    data member of the common base class always has the same memory offset and also
    uses the same index to access the field via the `getelementptr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a dynamic call of a method, we must further extend the LLVM structure.
    If the `Area()` function is called on a `Shape` object, then the abstract method
    is called, causing the application to halt. If it is called on a `Circle` object,
    then the corresponding method to calculate the area of a circle is called. The
    `GetColor()` function can be called for objects of both classes. The basic idea
    to implement this is to associate a table with function pointers with each object.
    Here, the table would have two entries: one for the `GetColor()` method and one
    for the `Area()` function. The `Shape` class and the `Circle` class each have
    such a table. The tables differ in the entry for the `Area()` function, which
    calls different code depending on the type of the object. This table is called
    the **virtual method table**, often abbreviated as the **vtable**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vtable alone is not useful. We must connect it with an object. To do so,
    we add a pointer to the vtable always as the first data member to the structure.
    At the LLVM level, the `@Shape` type then becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Circle` type is similarly extended. The resulting memory structure is
    shown in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Memory layout of the classes and the virtual method tables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Memory layout of the classes and the virtual method tables
  prefs: []
  type: TYPE_NORMAL
- en: LLVM does not have void pointers and pointers to bytes are used instead. With
    the introduction of the hidden `vtable` field, there is now also the need to have
    a way to initialize it. In C++, this is part of calling the constructor. In Oberon-2,
    the field is initialized automatically when the memory is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamic call to a method is then executed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the offset of the vtable pointer via the `getelementptr` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the pointer to the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the offset of the function in the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the function pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indirectly call the function via the pointer with the `call` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This does not sound very efficient, but in fact, most CPU architectures can
    perform this dynamic call in just two instructions. So, it is really the LLVM
    level that is verbose.
  prefs: []
  type: TYPE_NORMAL
- en: To turn a function into a method, a reference to the object's data is required.
    This is implemented by passing the pointer to the data as the first parameter
    of the method. In Oberon-2, this is the explicit receiver. In languages similar
    to C++, it is the implicit `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: With the vtable, we have a unique address in memory for each class. Does this
    help with the runtime type test, too? The answer is that it helps only in a limited
    way. To illustrate the problem, let's extend the class hierarchy with an `Ellipse`
    class, which inherits from the `Circle` class. (This is not the classical *is-a*
    relationship in the mathematical sense.) If we have the `shape` variable of the
    `Shape` type, then we could implement the `shape IS Circle` type test as a comparison
    of the vtable pointer stored in the `shape` variable with the vtable pointer of
    the `Circle` class. This comparison only results in `true` if `shape` has the
    exact `Circle` type. But if `shape` is indeed of the `Ellipse` type, then the
    comparison returns `false`, even if an object of the `Ellipse` type can be used
    in all places where only an object of the `Circle` type is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, we need to do more. The solution is to extend the virtual method table
    with runtime type information. How much information you need to store depends
    on the source language. To support the runtime type check, it is enough to store
    a pointer to the vtable of the base class, which then looks as in *Figure 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Class and vtable layout supporting simple type tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Class and vtable layout supporting simple type tests
  prefs: []
  type: TYPE_NORMAL
- en: If the test fails as described earlier, then the test is repeated with the pointer
    to the vtable of the base class. This is repeated until the test yields `true`
    or, if there is no base class, `false`. In contrast to calling a dynamic function,
    the type test is a costly operation, because in the worst case, the inheritance
    hierarchy is walked up to the root class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the whole class hierarchy, then an efficient approach is possible:
    you number each member of the class hierarchy in depth-first order. Then, the
    type test becomes a comparison against a number or an interval, which can be done
    in constant time. In fact, that is the approach of LLVM''s own runtime type test,
    which we learned about in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Coupling runtime type information with the vtable is a design decision, either
    mandated by the source language or just an implementation detail. For example,
    if you need detailed runtime type information, because the source language supports
    reflection at runtime, and you have data types without a vtable, then coupling
    both is not a good idea. In C++, the coupling results in the fact that a class
    with virtual functions (and therefore no vtable) has no runtime type data attached
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Often, programming languages support interfaces, which are a collection of virtual
    methods. Interfaces are important because they add a useful abstraction. We will
    look at possible implementations of interfaces in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extending single inheritance with interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Languages such as **Java** support interfaces. An interface is a collection
    of abstract methods, comparable to a base class with no data members and only
    abstract methods defined. Interfaces pose an interesting problem because each
    class implementing an interface can have the corresponding method at a different
    position in the vtable. The reason is simply that the order of function pointers
    in the vtable is derived from the order of the functions in the class definition
    in the source language. The definition in the interface is independent of this,
    and different orders are the norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the methods defined in an interface can have a different order, we
    attach a table for each implemented interface to the class. For each method of
    the interface, this table can specify either the index of the method in the vtable
    or can be a copy of the function pointer stored in the vtable. If a method is
    called on the interface, then the corresponding vtable of the interface is searched,
    then the pointer to the function is fetched and the method is called. Adding two
    interfaces, `I1` and `I2`, to the `Shape` class results in the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Layout of vtables for interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Layout of vtables for interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'The caveat lies in the fact that we have to find the right vtable. We can use
    an approach similar to the *runtime type test*: we can perform a linear search
    through the list of interface vtables. We can assign a unique number to each interface
    (for example, a memory address) and identify the vtable using this number. The
    disadvantage of this scheme is obvious: calling a method through an interface
    takes much more time than calling the same method on the class. There is no easy
    mitigation for this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: A good approach is to replace the linear search with a hash table. At compile
    time, the interface that a class implements is known. Therefore, we can construct
    a perfect hash function, which maps the interface number to the vtable for the
    interface. A known unique number identifying an interface may be needed for the
    construction, so memory does not help. But there are other ways to compute a unique
    number. If the symbol names in the source are unique, then it is always possible
    to compute a cryptographic hash such as the `MD5` of the symbol and use the hash
    as the number. The calculation occurs at compile time and therefore has no runtime
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: The result is much faster than the linear search and only takes constant time.
    Still, it involves several arithmetic operations on a number and is slower than
    the method call of a class type.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, interfaces also take part in runtime type tests, making the list to
    search even longer. Of course, if the hash table approach is implemented, then
    it can also be used for the runtime type test.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages allow more than one parent class. This has some interesting challenges
    for the implementation, and we master this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple inheritance adds another challenge. If a class inherits from two or
    more base classes, then we need to combine the data members in such a way that
    they are still accessible from the methods. Like in the single inheritance case,
    the solution is to append all data members, including the hidden vtable pointers.
    The `Circle` class is not only a geometric shape but also a graphic object. To
    model this, we let the `Circle` class inherit from the `Shape` class and the `GraphicObj`
    class. In the class layout, the fields from the `Shape` class come first. Then,
    we append all fields of the `GraphicObj` class, including the hidden vtable pointer.
    After that, we add the new data members of the `Circle` class, resulting in the
    overall structure shown in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Layout of classes and vtables with multiple inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Layout of classes and vtables with multiple inheritance
  prefs: []
  type: TYPE_NORMAL
- en: This approach has several implications. There can now be several pointers to
    the object. A pointer to the `Shape` or `Circle` class points to the top of the
    object, while a pointer to a `GraphicObj` class points to inside this object,
    to the beginning of the embedded `GraphicObj` object. This has to be taken into
    account when comparing pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a virtual method is also affected. If a method is defined in the `GraphicObj`
    class, then this method expects the class layout of the `GraphicObj` class. If
    this method is not overridden in the `Circle` class, then there are two possibilities.
    The easy case is if the method call is done with a pointer to a `GraphicObj` instance:
    in this case, you look up the address of the method in the vtable of the `GraphicObj`
    class and call the function. The more complicated case is if you call the method
    with a pointer to the `Circle` class. Again, you can look up the address of the
    method in the vtable of the `Circle` class. The called method expects a `this`
    pointer to an instance of the `GraphicObj` class, so we have to adjust that pointer,
    too. We can do this because we know the offset of the `GraphicObj` class inside
    the `Circle` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a method of `GrapicObj` is overridden in the `Circle` class, then nothing
    special needs to be done if the method is called through a pointer to the `Circle`
    class. However, if the method is called through a pointer to a `GraphicObj` instance,
    then we need to make another adjustment because the method needs a `this` pointer
    pointing to a `Circle` instance. At compile time, we cannot compute this adjustment,
    because we do not know whether this `GraphicObj` instance is part of a multiple
    inheritance hierarchy or not. To solve this, we store the adjustment we need to
    make to the `this` pointer before calling the method together with each function
    pointer in the vtable, as in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – vtable with adjustments to the this pointer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B15647.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – vtable with adjustments to the this pointer
  prefs: []
  type: TYPE_NORMAL
- en: 'The method call now becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the function pointer in the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the `this` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This approach can also be used for implementing interfaces. Because an interface
    has only methods, each implemented interface adds a new vtable pointer to the
    object. This is easier to implement and most likely faster, but it adds overhead
    to each object instance. In the worst case, if your class has a single 64-bit
    data field but implements 10 interfaces, then your object requires 96 bytes in
    memory: 8 bytes for the vtable pointer of the class itself, 8 bytes for the data
    member, and 10 * 8 bytes for the vtable pointers of each interface.'
  prefs: []
  type: TYPE_NORMAL
- en: To support meaningful comparisons to objects and to perform runtime type tests,
    it is needed to normalize a pointer to an object first. If we add an additional
    field to the vtable, containing an offset at the top of the object, then we can
    always adjust the pointer to point to the real object. In the vtable of the `Circle`
    class, this offset is `0`, but not in the vtable of the embedded `GraphicObj`
    class. Of course, whether this needs to be implemented depends on the semantics
    of the source language.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM itself does not favor a special implementation of object-oriented features.
    As seen in this section, we can implement all approaches with the available LLVM
    data types. If you want to try a new approach, then a good way is to do a prototype
    in C first. The required pointer manipulations are quickly translated to LLVM
    IR, but reasoning about the functionality is easier in a higher-level language.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge acquired in this section, you can implement the lowering
    of all OOP constructs commonly found in programming languages into LLVM IR in
    your own code generator. You have recipes on how to represent single inheritance,
    single inheritance with an interface, or multiple inheritance in memory, and also
    how to implement type tests and how to look up virtual functions, which are the
    core concepts of OOP languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to translate aggregate data types and pointers
    to LLVM IR code. You also learned about the intricacies of the ABI. Finally, you
    learned about the different approaches to translating classes and virtual functions
    to LLVM IR. With the knowledge of this chapter, you will be able to create an
    LLVM IR code generator for most real programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about some advanced techniques. Exception
    handling is fairly common in modern programming languages, and LLVM has some support
    for it. Attaching type information to pointers can help with certain optimizations,
    so we will add this, too. Last but not least, the ability to debug an application
    is essential for many developers, so we will add the generation of debug metadata
    to our code generator.
  prefs: []
  type: TYPE_NORMAL

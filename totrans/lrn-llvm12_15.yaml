- en: '*Chapter 12*: Create Your Own Backend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM has a very flexible architecture. You can also add a new target backend
    to it. The core of a backend is the target description, from which most of the
    code is generated. However, it is not yet possible to generate a complete backend,
    and implementing the calling convention requires manually written code. In this
    chapter, we will learn how to add support for a historical CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage for a new backend introduces you to the M88k CPU architecture
    and shows you where to find the information you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the new architecture to the Triple class teaches you how to make LLVM
    aware of a new CPU architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Extending the ELF file format definition in LLVM, you will add support for
    the M88k-specific relocations to the libraries and tools that handle ELD object
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Creating the target description, you will develop all the parts of the target
    description in the TableGen language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Implementing the DAG instruction selection classes, you will create the passes
    and supporting classes required for instruction selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating assembler instructions teaches you how to implement the assembler
    printer, which is responsible for textual assembler generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Emitting machine code, you learn about which additional classes you must
    provide to enable the **machine code** (**MC**) layer to write code to object
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Adding support for disassembling, you will learn how to implement support
    for a disassembler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Piecing it all together, you will integrate the source for the new backend
    into the build system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to develop a new and complete
    backend. You will know about the different parts a backend is made of, giving
    you a deeper understanding of the LLVM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage for a new backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether it's needed commercially to support a new CPU or it's only for a hobby
    project to add support for some old architecture, adding a new backend to LLVM
    is a major task. The following sections outline what you need to develop a new
    backend. We will add a backend for the Motorola M88k architecture, which is a
    RISC architecture from the 1980s.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the architecture on Wikipedia: [https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000).
    The important information about this architecture is still available on the internet.
    You can find the CPU manuals with the instruction set and timing information at
    [http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/),
    and the System V ABI M88k Processor supplement with the definitions of the ELF
    format and the calling convention can be found at [https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463](https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463).'
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD, available at [https://www.openbsd.org/](https://www.openbsd.org/),
    still supports the LUNA-88k system. On the OpenBSD system, it is easy to create
    a GCC cross-compiler for M88k. And with GXemul, available at http://gavare.se/gxemul/,
    there exists an emulator capable of running certain OpenBSD releases for the M88k
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Taken together, the M88k architecture is long out of production, but we found
    enough information and tools to make it an interesting goal to add an LLVM backend
    for it. We will begin with a very basic task and extend the `Triple` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new architecture to the Triple class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An instance of the `Triple` class represents the target platform LLVM is producing
    code for. To support a new architecture, the first task is to extend the `Triple`
    class. In the `llvm/include/llvm/ADT/Triple.h` file, you add a member to the `ArchType`
    enumeration and a new predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `llvm/lib/Support/Triple.cpp` file, there are numerous methods that
    use the `ArchType` enumeration. You need to extend all of them; for example, in
    the `getArchTypeName()` method, you need to add a new case statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, the compiler will warn you if you forget to handle the new `m88k`
    enumeration member in one of the functions. Next, we will expand the **Executable
    and Linkable Format** (**ELF**) definition.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the ELF file format definition in LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ELF file format is one of the binary object file formats that LLVM has
    support for to read and write. ELF itself is defined for many CPU architectures,
    and there is also a definition for the M88k architecture. All we need to do is
    to add the definition of the relocations and some flags. The relocations are given
    in [*Chapter 4*](B15647_04_ePub_RK.xhtml#_idTextAnchor066), *Object Files*, of
    the *System V ABI M88k Processor* supplement book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to type the following into the `llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add some flags to the `llvm/include/llvm/BinaryFormat/ELF.h` file and
    include the relocation definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code can be added anywhere in the file, but it is best to keep a sorted
    order and insert it before the code for the MIPS architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to expand some other methods. In the `llvm/include/llvm/Object/ELFObjectFile.h`
    file are some methods that translate between enumeration members and strings.
    For example, we must add a new case statement to the `getFileFormatName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we extend the `getArch()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Last, we use the relocation definitions in the `llvm/lib/Object/ELF.cpp` file,
    in the `getELFRelocationTypeName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To complete the support, you can also add the relocations in the `llvm/lib/ObjectYAML/ELFYAML.cpp`
    file, in the method that maps the `ELFYAML::ELF_REL` enumeration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we have completed the support of the m88k architecture in the
    ELF file format. You can use the `llvm-readobj` tool to inspect an ELF object
    file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create
    an ELF object file for the m88k architecture with the `yaml2obj` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is adding support for an object file format mandatory?
  prefs: []
  type: TYPE_NORMAL
- en: Integrating support for an architecture into the ELF file format implementation
    requires only a couple of lines. If the architecture for which you create an LLVM
    backend uses the ELF format, then you should take this route. On the other hand,
    adding support for a completely new binary file format is itself a complicated
    task. In this case, a possible approach is to only output assembler files and
    use an external assembler to create object files.
  prefs: []
  type: TYPE_NORMAL
- en: With these additions, the implementation of the ELF file formats now supports
    the M88k architecture. In the next section, we create the target description for
    the M88k architecture, which describes the instructions, registers, calling convention,
    and other details of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the target description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **target description** is the heart of a backend implementation. In an ideal
    world, we could generate the whole backend from the target description. This goal
    has not yet been reached, and therefore, we need to extend the generated code
    later. Let's dissect the target description, beginning with the top-level file.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the top-level file of the target description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We put the files of our new backend into the `llvm/lib/Target/M88k` directory.
    The target description is in the `M88k.td` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we first need to include basic target description classes predefined
    by LLVM and then the files we are going to create in the next sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we also define the supported processor. Among other things, this translates
    into the parameter for the `â€“mcpu=` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these definitions done, we now can piece our target together. We define
    these subclasses, in case we need to modify some of the default values. The `M88kInstrInfo`
    class holds all the information about the instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a parser for the `.s` assembly files, and we additionally state that
    register names are always be prefixed with `%`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a class for the assembly writer, which is responsible for writing
    `.s` assembly files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, all these records are put together to define the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that the top-level file is implemented, we create the included files, starting
    with the register definition in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the register definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CPU architecture usually defines a set of registers. The characteristics of
    these registers can vary greatly. Some architectures allow access to subregisters.
    For example, the x86 architecture has special register names to access only a
    part of a register value. Other architectures do not implement this. Besides general-purpose,
    floating-point, and vector registers, an architecture may also define special
    registers, for example, for status codes or for the configuration of floating-point
    operations. You need to define all this information for LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The M88k architecture defines general-purpose registers, floating-point registers,
    and control registers. To keep the example small, we will only define the general-purpose
    registers. We begin with defining a super-class for the registers. The encoding
    for registers uses only `5` bits, so we limit the field holding the encoding.
    We also define that all the generated C++ code should reside in the `M88k` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `M88kReg` class is used for all register types. We define a special class
    for general-purpose registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define all 32 general-purpose registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The single registers need to be grouped in register classes. The sequence order
    of the registers also defines the allocation order in the register allocator.
    Here, we simply add all registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And last, we need to define an operand based on the register class. The operand
    is used in selecting DAG nodes to match a register, and it can also be extended
    to denote method names for printing and matching the register in assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This finishes our definition of the registers. In the next section, we use these
    definitions to define the calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the calling convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **calling convention** defines how parameters are passed to functions. Usually,
    the first parameters are passed in registers, and the rest of the parameters are
    passed on the stack. There must also be rules on how aggregates are passed and
    how values are returned from a function. From the definition given here, analyzer
    classes are generated, which are used later during the lowering of calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read about the calling convention used on the M88k architecture in
    [*Chapter 3*](B15647_03_ePub_RK.xhtml#_idTextAnchor048), *Low-Level System Information*,
    of the *System V ABI M88k Processor* supplement book. Let''s translate this into
    the TableGen syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a record for the calling convention:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The M88k architecture only has 32-bit registers, therefore values of smaller
    data types need to be promoted to 32 bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling convention states that for aggregate return values, a pointer to
    the memory is passed in the `r12` register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The registers `r2` to `r9` are used to pass parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Every additional parameter is passed on the stack, in 4 bytes-aligned slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An additional record defines how results are passed to the calling function.
    32-bit values are passed in the `r2` register, and 64-bit values use the `r2`
    and `r3` registers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And last, a calling convention also states which registers have to be preserved
    by the called function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If needed, you can also define multiple calling conventions. In the next section,
    we will have a brief look at the scheduling model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scheduling model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scheduling model is used by the code generation to order the instructions
    in an optimal way. Defining a scheduling model improves the performance of the
    generated code, but it is not necessary for code generation. Therefore, we only
    define a placeholder for the model. We add the information that the CPU can issue
    at most two instructions at once, and that it is an in-order CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can find recipes on how to create a complete scheduling model in the talk
    *Writing Great Schedulers* on YouTube at [https://www.youtube.com/watch?v=brpomKUynEA](https://www.youtube.com/watch?v=brpomKUynEA).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will define the instruction formats and the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the instruction formats and the instruction information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already looked at the instruction formats and the instruction information
    in [*Chapter 9*](B15647_09_ePub_RK.xhtml#_idTextAnchor140)*, Instruction Selection*,
    in the *Supporting new machine instructions* section. To define the instructions
    for the M88k architecture, we follow the same approach. First, we define a base
    class for the instruction records. The most important field of this class is the
    `Inst` field, which holds the encoding for the instruction. Most of the other
    field definitions just assign a value to a field defined in the `Instruction`
    superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This base class is used for all instruction formats, so it is also used for
    the `F_JMP` format. You take the encoding for the user manual of the processor.
    The class has two parameters, which must be part of the encoding. The `func` parameter
    defines bits 11 to 15 of the encoding, which defines the instruction as a jump
    with or without saving the return address. The `next` parameter is a bit that
    defines whether the next instruction is executed unconditionally or not. This
    is similar to the delay slot of the MIPS architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class also defines the `rs2` field, which holds the encoding of the register
    holding the target address. The other parameters are the DAG input and output
    operand, the textual assembler string, a DAG pattern used to select this instruction,
    and an itinerary class for the scheduler model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we can finally define the instruction. A jump instruction is
    the last instruction in a basic block, so we need to set the `isTerminator` flag.
    Because control flow can't fall through this instruction, we also have to set
    the `isBarrier` flag. We take the values for the `func` and `next` parameters
    from the user manual of the processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input DAG operand is a general-purpose register and refers to the operand
    from the preceding register''s information. The encoding is stored in the `rs2`
    field, from the preceding class definition. The output operand is empty. The assembler
    string gives the textual syntax of the instruction and also refers to the register
    operand. The DAG pattern uses the predefine `brind` operator. This instruction
    is selected if the DAG contains an indirect branch node with the target address
    hold in a register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We need to define records for all instructions in this way.
  prefs: []
  type: TYPE_NORMAL
- en: In this file, we also implement other necessary patterns for instruction selection.
    A typical application is a constant synthesis. The M88k architecture has 32 bit-wide
    registers, but the instructions with immediate values as operands support only
    16 bit-wide constants. As a consequence, operations such as a bitwise `and` between
    a register and a 32-bit constant have to be split into two instructions that use
    16-bit constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, a flag in the `and` instruction defines whether an operation applies
    to the lower or the upper half of the register. With operators LO16 and HI16 used
    to extract the lower or upper half of a constant, we can formulate a DAG pattern
    for an `and` operation between a register and a 32 bit-wide constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `ANDri` operator is the `and` instruction that applies the constant to the
    lower half of the register, and the `ANDriu` operator uses the upper half of the
    register. Of course, before we can use these names in the pattern, we must define
    the instruction like we defined the `jmp` instruction. This pattern solves the
    problem using a 32-bit constant with an `and` operation, generating two machine
    instructions for it during instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all operations can be represented by the predefined DAG nodes. For example,
    the M88k architecture defined bit field operations, which can be seen as generalizations
    of the normal `and`/`or` operations. For such operations, it is possible to introduce
    new node types, for example, for the `set` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This defines a new record of the `SDNode` class. The first argument is the C++
    enumeration member that denotes the new operation. The second parameter is the
    so-called type profile and defines the type and number of parameters and the result
    type. The predefined `SDTIntBinOp` class defines two integer parameters and an
    integer result type, which is suitable for this operation. You can look up the
    predefined classes in the `llvm/include/llvm/Target/TargetSelectionDAG.td` file.
    If there is no suitable predefined type profile, then you can define a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For calling functions, LLVM requires certain definitions that cannot be predefined
    because they are not completely target-independent. For example, for returns,
    we need to specify a `retflag` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing this to `m88k_set` the record, this also defines some flags for the
    DAG node: the chain and glue sequences are used, and the operator can take a variable
    number of arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the instructions iteratively
  prefs: []
  type: TYPE_NORMAL
- en: A modern CPU can easily have thousands of instructions. It makes sense to not
    implement all instructions at once. Instead, you should first concentrate on basic
    instructions such as logical operations and call and return instructions. This
    is enough to get a very basic backend working. To this base, you then add more
    and more instruction definitions and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This finishes our implementation of the target description. From the target
    description, a lot of code is automatically generated with the `llvm-tblgen` tool.
    To complete the instruction selection and other parts of the backend, we still
    need to develop a C++ source using the generated code. In the next section, we
    implement the DAG instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the DAG instruction selection classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A large portion of the DAG instruction selector is generated by the `llvm-tblgen`
    tool. We still need to create classes using the generated code and put everything
    together. Let's begin with a part of the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the target machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each backend has to provide at least one `TargetMachine` class, usually a subclass
    of the `LLVMTargetMachine` class. The `M88kTargetMachine` class holds a lot of
    the details required for code generation, and it also acts as a factory for other
    backend classes, most notably for the `Subtarget` class and the `TargetPassConfig`
    class. The `Subtarget` class holds the configuration for the code generation,
    such as which features are enabled. The `TargetPassConfig` class configures the
    machine passes of the backend. The declaration for our `M88kTargetMachine` class
    is in the `M88ktargetMachine.h` file and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Please note that there can be a different subtarget for each function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation in the `M88kTargetMachine.cpp` file is straightforward.
    Most interesting is the setup of the machine passes for this backend. This creates
    the connection to the selection DAG (and, if desired, to global instruction selection).
    The passes created in the class are later added to the pass pipeline to produce
    object files or assemblers from the IR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `SubTarget` implementation return from the `M88kTargetMachine` class gives
    access to other important classes. The `M88kInstrInfo` class returns information
    about instructions, including registers. The `M88kTargetLowering` class provides
    a lowering of call-related instructions and also allows adding custom DAG rules.
    Most of the class is generated by the `llvm-tblgen` tool, and we need to include
    the generated header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition in the `M88kSubTarget.h` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we implement the selection DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the selection DAG implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The selection DAG is implemented in the `M88kDAGtoDAGIsel` class in the file
    of the same name. Here, we benefit from having created the target machine description:
    most of the functionality is generated from this description. In a very first
    implementation, we only need to override the `Select()` function and forward it
    to the generated `SelectCode` function. More functions can be overridden for certain
    cases, for example, if we need to extend the preprocessing of the DAG or if we
    need to add special inline assembler constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this class is a machine function pass, we also provide a name for the
    pass. The main bulk of the implementation comes from the generated file, which
    we include in the middle of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add the factory function to create the pass in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we can implement the target-specific operations, which cannot be expressed
    in the target description.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting target-specific operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's turn to the `M88kTargetLowering` class, defined in the `M88kISelLowering.h`
    file. This class configures the instruction DAG selection process and enhances
    the lowering with target-specific operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the target description, we defined new DAG nodes. The enumeration used with
    the new types is also defined in this file, continuing the numbering with the
    last predefined number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The class needs to provide the required lowering methods for the function calls.
    To keep it simple, we look only at returning values. The class can also define
    the `LowerOperation()` hook method for operations that need custom handling. We
    can also enable custom DAG combining methods, for which we define the `PerformDAGCombine()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the class is in the `M88kISelLowering.cpp` file. First,
    we look at how to lower a return value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated functions for the calling convention are needed, so we include
    the generated file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LowerReturn()` method takes a lot of arguments, which are all defined
    by the `TargetLowering` superclass. The most important ones are the `Outs` vector,
    which holds the description of the return argument, and the `OutVals` vector,
    which holds the DAG nodes for the return values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We analyze the return argument with the help of the `CCState` class, passing
    a reference to the generated `RetCC_M88k` function. As result, we have classified
    all the return arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of a `void` function, there is nothing to do and we return. Please
    note that the type of the returned node is `RET_FLAG`. We defined this in the
    target description as the new `ret_flag` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we need to loop over the return arguments. For each return argument,
    we have an instance of the `CCValAssign` class, which tells us how we have to
    treat the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The values may need to be promoted. We add a DAG node with the required extension
    operation, if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value has the right type, we copy the value into a register for returning
    it and chain and glue the copies together. This finishes the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, we need to update the chain and the glue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then return the `ret_flag` node, connecting the result of the lowering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To be able to call functions, we must implement the `LowerFormalArguments()`
    and `LowerCall()` methods. Both methods follow a similar approach and hence are
    not shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the target lowering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The methods to lower function calls and arguments must always be implemented,
    as they are always target-dependent. Other operations may or may not have support
    in the target architecture. To make the lowering process aware of it, we set up
    the configuration in the constructor of the `M88kTargetLowering` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor takes `TargetMachine` and `M88kSubtarget` instances as parameters
    and initializes the corresponding fields with them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We add all the register classes first. We have only general-purpose registers
    defined, therefore it is just a simple call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the register classes are added, we compute the derived properties
    for the registers. For example, since the registers are 32 bits wide, this function
    marks the 64-bit data type as requiring two registers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell which register is used for the stack pointer. On the M88k
    architecture, the `r31` register is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define how `boolean` values are represented. Basically, we
    say here that the values 0 and 1 are used. Other possible options are to look
    only at bit 0 of the value, ignoring all other bits, and setting all bits of the
    value either to 0 or 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For every operation that needs special handling, we must call the `setOperationAction()`
    method. The method takes the operation, the value type, and the action to take
    as input. If the operation is valid, then we use the `Legal` action value. If
    the type should be promoted, then we use the `Promote` action value, and if the
    operation should result in a library call, then we use the `LibCall` action value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we give the `Expand` action value, then the instruction selection first
    tries to expand this operation into other operations. If this is not possible,
    then a library call is used. And last, we can implement our own action if using
    the `Custom` action value. In this case, the `LowerOperation()`method is called
    for a node with this operation. As an example, we set the `CTTZ` count trailing
    zeros operation to the `Expand` action. This operation will be replaced by a sequence
    of primitive bit operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The M88k architecture has a bit field operation, for which it is not easy to
    define a pattern in the target description. Here, we tell the instruction selection
    that we want to perform additional matching on `or` DAG nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the target architecture, setting the configuration in the constructor
    can be much longer. We only defined the bare minimum, ignoring, for example, floating-point
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have marked the `or` operation to perform custom combining on it. As a result,
    the instruction selector calls the `PerformDAGCombine()` method before calling
    the generated instruction selection. This function is called in the various phases
    of the instruction selection, but usually, we perform our matching only after
    the operations are legalized. The common implementation is to look at the operation
    and branch to a function handling the matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the `performORCombine()` method, we try to check whether we can generate
    a `set` instruction for the `or` operation. The `set` instruction sets a number
    of consecutive bits to 1, starting at a specified bit offset. This is a special
    case of the `or` operation, with the second operand being a constant matching
    this format. Because the `or` instruction of the M88k architecture works only
    on 16-bit constants, this matching is beneficial, because otherwise, we would
    have to synthesize the constant, resulting in two `or` instructions. This method
    uses the `isShiftedMask()` helper function to determine whether the constant values
    have the required form.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the second operand is a constant of the required form, then this function
    returns a node representing the `set` instruction. Otherwise, the return value
    `SDValue()` indicates that no matching pattern was found and that the generated
    DAG pattern matcher should be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To finish the implementation of the whole lowering process, we need to implement
    the `M88kFrameLowering` class. This class is responsible for handling the stack
    frame. This includes generating the prologue and epilogue code, handling register
    spills, and more. For the very first implementation, you can just provide empty
    functions. Obviously, for complete functionality, this class must be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: This finishes our implementation of the instruction selection. Next, we look
    at how the final instructions are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Generating assembler instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instruction selection implemented in the previous sections lowers the IR
    instructions into `MachineInstr` instances. This is already a much lower representation
    of instruction, but it is not yet the machine code itself. The last pass in the
    backend pipeline is to emit the instructions, either as assembly text or into
    an object file. The `M88kAsmPrinter` machine pass is responsible for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, this pass lowers a `MachineInstr` instance to an `MCInst` instance,
    which is then emitted to a streamer. The `MCInst` class represents the real machine
    code instruction. This additional lowering is required because the `MachineInstr`
    class still does not have all the required details.
  prefs: []
  type: TYPE_NORMAL
- en: For the first approach, we can limit our implementation to overriding the `emitInstruction()`
    method. You need to override more methods for supporting several operand types,
    mainly to emit the correct relocations. This class is also responsible for handling
    inline assemblers, which you also need to implement if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `M88kAsmPrinter` class is again a machine function pass, we also
    override the `getPassName()` method. The declaration of the class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we must handle two different cases in the `emitInstruction()` method.
    The `MachineInstr` instance can still have operands, which are not real machine
    instructions. For example, this is the case for the return `ret_flag` node, having
    the `RET` opcode value. On the M88k architecture, there is no `return` instruction.
    Instead, a jump to the address store in the `r1` register is made. Therefore,
    we need to construct the branch instruction when we detect the `RET` opcode. In
    the default case, the lowering only needs the information from the `MachineInstr`
    instance, and we delegate this task to the `M88kMCInstLower` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `M88kMCInstLower` class has no predefined superclass. Its main purpose
    is to handle the various operand types. As we currently only have a very limited
    set of supported operand types, we can reduce this class to having only a single
    method. The `lower()` method sets the opcode and the operand of the `MCInst` instance.
    Only register and immediate operands are handled; other operand types are ignored.
    For the full implementation, we also need to handle memory addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The assembler printer needs a factory method, which is called during initialization,
    for example, from the `InitializeAllAsmPrinters()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Finally, having lowered the instructions to real machine code instructions,
    we are still not done. We need to implement various small pieces for the MC layer,
    which we look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting machine code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MC layer is responsible for emitting machine code in textual or binary form.
    Most of the functionality is either implemented in the various MC classes and
    only needs to be configured, or the implementation is generated from the target
    description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initialization of the MC layer takes place in the `MCTargetDesc/M88kMCTargetDesc.cpp`
    file. The following classes are registered with the `TargetRegistry` singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M88kMCAsmInfo`: This class provides basic information, such as the size of
    a code pointer, the direction of stack growth, the comment symbol, or the name
    of assembler directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88MCInstrInfo`: This class holds information about instructions, for example,
    the name of an instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88kRegInfo`: This class provides information about registers, for example,
    the name of a register, or which register is the stack pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88kSubtargetInfo`: This class holds the data of the scheduling model and
    the methods to parse and set CPU features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88kMCAsmBackend`: This class provides helper methods to get the target-dependent
    relocation data for fixups. It also contains factory methods for the object writer
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88kMCInstPrinter`: This class contains helper methods to textually print
    instructions and operands. If an operand defines a custom print method in the
    target description, then it must be implemented in this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M88kMCCodeEmitter`: This class writes the encoding of an instruction to a
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the scope of a backend implementation, we do not need to register
    and implement all of these classes. You can omit to register the `MCInstPrinter`
    subclass if you do not support textual assembler output. If you do not add support
    writing of object files, you can omit the `MCAsmBackend` and `MCCodeEmitter` subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the file by including the generated parts and providing factory methods
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We also provide some factory methods for classes implemented in other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the MC layer, we only need to register all the factory methods
    with the `TargetRegistry` singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, in the `MCTargetDesc/M88kTargetDesc.h` header file, we also need
    to include the header portion of the generated source, to make it available to
    others, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We put the source files for the registered classes all in the `MCTargetDesc`
    directory. For the first implementation, it is sufficient to provide just stubs
    for these classes. For example, as long as support for memory addresses is not
    added to the target description, no fixups will be generated. The `M88kMCAsmInfo`
    class can be very quickly implemented, as we only need to set some properties
    in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Having implemented the support classes for the MC layer, we are now able to
    emit the machine code into files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we implement the class required for disassembling, which
    is the reverse action: turning an object file back into assembler text.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for disassembling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of the instructions in the target description allows the construction
    of decoder tables, which are used to disassemble an object file into a textual
    assembler. The decoder tables and a decoder function are generated by the `llvm-tblgen`
    tool. Besides the generated code, we only need to provide the code to register
    and initialize the `M88kDisassembler` class and some helper functions to decode
    registers and operands. We place the implementation in the `Disassembler/M88kDisassembler.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getInstruction()` method of the `M88kDisassembler` class does the decoding
    work. It takes an array of bytes as input and decodes the next instruction into
    an instance of the `MCInst` class. The class declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The generated classes refer unqualified to the `DecodeStatus` enumeration, so
    we have to make this name visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the disassembler, we define a factory function that simply instantiates
    a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `LLVMInitializeM88kDisassembler()` function, we register the factory
    function at the target registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This function is called from the `InitializeAllDisassemblers()` function or
    the `InitializeNativeTargetDisassembler()` function, when the LLVM core libraries
    are initialized.
  prefs: []
  type: TYPE_NORMAL
- en: The generated decoder function expects helper functions to decode registers
    and operands. The reason for this is that the encoding of those elements often
    involves special cases not expressed in the target description. For example, the
    distance between two instructions is always even, so the lowest bit can be ignored
    because it is always zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decode the registers, the `DecodeGPRRegisterClass()` function has to be
    defined. The 32 registers are encoded with a number between 0 and 31, and we can
    use the static `GPRDecoderTable` table to map between the encoding and the generated
    enumeration for the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'All other required decoder functions follow the same pattern as the `DecodeGPRRegisterClass()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the value to decode fits the required size restriction. If not, then
    return the `MCDisassembler::Fail` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode the value and add it to the `MCInst` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return `MCDisassembler::Success` to indicate success.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can include the generated decoder tables and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include "M88kGenDisassemblerTables.inc"`'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are able to define the `getInstruction()` method. This method has
    two result values, the decoded instruction and the size of the instruction. If
    the byte array is too small, the size must be set to `0`. This is important because
    the size parameter is used by the caller to advance the pointer to the next memory
    location, even if the decoding failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the M88k architecture, the method is simple, because all instructions
    are 4 bytes long. So, after extracting 4 bytes from the array, the generated decoder
    function can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This finishes the implementation of the disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: After we have implemented all the classes, we only need to set up the build
    system to pick up the new target backend, which we will add in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Piecing it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our new target, located in the `llvm/lib/Target/M88k` directory, needs to be
    integrated into the build system. To make development easy, we add it as an experimental
    target in the `llvm/CMakeLists.txt` file. We replace the existing empty string
    with the name of our target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We also need to provide a `llvm/lib/Target/M88k/CMakeLists.txt` file to build
    our target. Besides listing the C++ files for the target, it also defines the
    generation of the source from the target description.
  prefs: []
  type: TYPE_NORMAL
- en: Generating all the types of sources from the target description
  prefs: []
  type: TYPE_NORMAL
- en: Different runs of the `llvm-tblgen` tool generate different portions of C++
    code. However, I recommend adding the generation of all parts to the `CMakeLists.txt`
    file. The reason for this is that it provides better checking. For example, if
    you make an error with the instruction encoding, then this is only caught during
    the generation of the code for the disassembler. So, even if you do not plan to
    support the disassembler, it is still worth generating the source for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a new LLVM component named `M88k`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we name the target description file, add statements to generate the various
    source pieces with TableGen, and define a public target for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We must list all the source files the new component is made of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, we include the directories with the MC and disassembler classes in the
    build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to compile the LLVM with the new backend target. On the build
    directory, we can simply run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This detects the changed `CmakeLists.txt` file, runs the configuration step
    again, and compiles the new backend. To check that all went well, you can run
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should contain the following line in the `Registered Target` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Hurray! We finished the backend implementation. Let''s try it out. The following
    `f1` function in LLVM IR performs a bitwise AND operation between the two parameters
    of the function and returns the result. Save it in the `example.ll` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `llc` tool as follows to see the generated assembler text on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The output is in valid GNU syntax. For the `f1` function, `and` and `jmp` instructions
    are generated. The parameters are passed in the `%r2` and `%r3` registers, which
    are used in the `and` instruction. The result is stored in the `%r2` register,
    which is also the register to return 32-bit values. The return from the function
    is realized with a branch to the address hold in the `%r1` register, which also
    matches the ABI. It all looks very good!
  prefs: []
  type: TYPE_NORMAL
- en: With the topics you learned about in this chapter, you can now implement your
    own LLVM backend. For many relatively simple CPUs such as **digital signal processors**
    (**DSPs**), you do not need to implement more than we did here. Of course, the
    implementation for the M88k CPU architecture does not yet support all features
    of the architecture, for example, floating-point registers. However, you now know
    all the important concepts applied in LLVM backend development, and with this,
    you will be able to add any missing parts!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to develop a new backend target for LLVM. You
    first collected the required documentation and made LLVM aware of the new architecture
    by enhancing the `Triple` class. The documentation also includes the relocation
    definition for the ELF file format, and you added support for that to LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the different parts the target description contains, and using
    the C++ source generated from it, you learned how to implement an instruction
    selection. For outputting the generated code, you developed an assembler printer
    and learned which support classes are needed to write to an object file. You also
    learned how to add support for disassembling, which is used to turn an object
    file back into assembler text. Lastly, you extended the build system to include
    the new target in the build.
  prefs: []
  type: TYPE_NORMAL
- en: You are now equipped with everything you need to use LLVM in creative ways in
    your own projects. The LLVM ecosystem is very active, and new features are added
    all the time, so be sure to follow all developments!
  prefs: []
  type: TYPE_NORMAL
- en: Being a compiler developer myself, it was a pleasure for me to write about LLVM
    and discover some new features along the way. Have fun with LLVM!
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 3. Improving PHP 7 Application Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。提高PHP 7应用程序性能
- en: 'PHP 7 has been completely rewritten from the ground up based on the **PHP Next
    Generation** (**phpng** or **PHPNG**) targeting performance. However, there are
    always more ways to improve the performance of the application, including writing
    high performance code, using best practices, web server optimizations, caching,
    and so on. In this chapter, we will discuss such optimizations listed as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7已经完全重写，基于**PHP Next Generation**（**phpng**或**PHPNG**）进行性能优化。然而，总是有更多的方法来提高应用程序的性能，包括编写高性能代码、使用最佳实践、Web服务器优化、缓存等。在本章中，我们将讨论以下列出的这些优化：
- en: NGINX and Apache
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX和Apache
- en: HTTP server optimization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器优化
- en: Content Delivery Network (CDN)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容交付网络（CDN）
- en: JavaScript/CSS optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript/CSS优化
- en: Full page caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整页面缓存
- en: Varnish
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Varnish
- en: The infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施
- en: NGINX and Apache
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGINX和Apache
- en: There are too many HTTP server software available, and each one has its pros
    and cons. The two most popular HTTP servers used are NGINX and Apache. Let's have
    a look at both of them and note which one is better for our needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有太多的HTTP服务器软件可用，每个都有其优缺点。最常用的两个HTTP服务器是NGINX和Apache。让我们来看看它们两个，并注意哪一个更适合我们的需求。
- en: Apache
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache
- en: Apache is the most widely used HTTP server and is loved by most administrators.
    It is selected by administrators because of its flexibility, widespread support,
    power, and modules for most of the interpreted languages, such as PHP. As Apache
    can process a vast number of interpreted languages, it does not need to communicate
    with other software to fulfill the request. Apache can process requests in prefork
    (the processes are spawned across thread), worker (threads are spawned across
    processes), and event-driven (same as worker process, but it sets dedicated threads
    for *keep-alive* connections and separate threads for active connections); thus,
    it provides much more flexibility.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Apache是最广泛使用的HTTP服务器，大多数管理员都喜爛它。管理员选择它是因为它的灵活性、广泛的支持、强大的功能以及对大多数解释性语言（如PHP）的模块支持。由于Apache可以处理大量的解释性语言，它不需要与其他软件通信来满足请求。Apache可以在prefork（进程在线程之间生成）、worker（线程在进程之间生成）和事件驱动（与worker进程相同，但为*keep-alive*连接设置专用线程和为活动连接设置单独线程）中处理请求；因此，它提供了更大的灵活性。
- en: As discussed earlier, each request will be processed by a single thread or process,
    so Apache consumes too many resources. When it comes to high-traffic applications,
    Apache may slow down the application as it does not provide good support for concurrent
    processing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，每个请求将由单个线程或进程处理，因此Apache消耗了太多资源。当涉及高流量应用程序时，Apache可能会减慢应用程序的速度，因为它不提供良好的并发处理支持。
- en: NGINX
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGINX
- en: NGINX was built to solve the concurrency problems with high-traffic applications.
    NGINX provides asynchronous, event-driven, and nonblocking request handling. As
    requests are processed asynchronously, NGINX does not wait for a request to be
    completed to block the resource.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX是为解决高流量应用程序的并发问题而构建的。NGINX提供了异步、事件驱动和非阻塞的请求处理。由于请求是异步处理的，NGINX不会等待请求完成以阻塞资源。
- en: NGINX creates worker processes, and each individual worker process can handle
    thousands of connections. So, a few processes can handle high traffic at once.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX创建工作进程，每个工作进程可以处理成千上万的连接。因此，少量进程可以同时处理高流量。
- en: NGINX does not provide any built-in support for any interpreted languages. It
    relies on external resources for this. This is also good because the processing
    is made outside NGINX, and NGINX only processes the connections and requests.
    Mostly, NGINX is considered faster than Apache. In some situations, such as with
    static content (serving images, `.css` and `.js` files, and so on), this can be
    true, but in current high performance servers, Apache is not the problem; PHP
    is the bottleneck.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX不提供任何解释性语言的内置支持。它依赖外部资源来实现这一点。这也是好的，因为处理是在NGINX之外进行的，NGINX只处理连接和请求。大多数情况下，NGINX被认为比Apache更快。在某些情况下，例如处理静态内容（提供图像、`.css`和`.js`文件等），这可能是真的，但在当前高性能服务器中，Apache并不是问题；PHP是瓶颈。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both Apache and NGINX are available for all kinds of operations systems. For
    the purpose of this book, we will use Debian and Ubuntu, so all file paths will
    be mentioned according to these OSes
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Apache和NGINX都适用于各种操作系统。在本书中，我们将使用Debian和Ubuntu，因此所有文件路径都将根据这些操作系统进行提及。
- en: As mentioned before, we will use NGINX for this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在本书中使用NGINX。
- en: HTTP server optimization
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器优化
- en: Each HTTP server provides certain features that can be used to optimize request
    handling and serving content. In this section, we will share some techniques for
    both Apache and NGINX that can be used to optimize the web server and provide
    the best performance and scalability. Mostly, when these optimizations are applied,
    a restart for Apache or NGINX is required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP服务器都提供了一些功能，可以用来优化请求处理和提供内容。在本节中，我们将分享一些适用于Apache和NGINX的技术，用来优化Web服务器并提供最佳性能和可伸缩性。通常，应用这些优化后，需要重新启动Apache或NGINX。
- en: Caching static files
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存静态文件
- en: Mostly, static files, such as images, `.css`, `.js`, and fonts don't change
    frequently. So, it is best practice to cache these static files on the end user
    machine. For this purpose, the web server adds special headers to the response,
    which tells the user browser to cache the static content for a certain amount
    of time. The following is the configuration code for both Apache and NGINX.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数静态文件，如图像、`.css`、`.js`和字体，不经常更改。因此，最佳做法是在最终用户的机器上缓存这些静态文件。为此，Web服务器会在响应中添加特殊标头，告诉用户浏览器将静态内容缓存一段时间。以下是Apache和NGINX的配置代码。
- en: Apache
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache
- en: 'Let''s have a look at the Apache configuration to cache the following static
    content:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Apache配置如何缓存以下静态内容：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code that has to be placed in a `.htaccess` file, we used the
    Apache `FilesMatch` directive to match the extensions of files. If a desired extension
    file is requested, Apache sets the headers to cache control for seven days. The
    browser then caches these static files for seven days.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了Apache的`FilesMatch`指令来匹配文件的扩展名。如果请求了所需的扩展名文件，Apache会将头设置为缓存控制七天。然后浏览器会将这些静态文件缓存七天。
- en: NGINX
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NGINX
- en: 'The following configuration can be placed in `/etc/nginx/sites-available/your-virtual-host-conf-file`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置可以放置在`/etc/nginx/sites-available/your-virtual-host-conf-file`中：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we used the NGINX `Location` block with a case-insensitive
    modifier (`~*`) to set `Expires` for seven days. This code will set the cache-control
    header for seven days for all the defined file types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了NGINX的`Location`块和不区分大小写的修饰符(`~*`)来设置七天的`Expires`。此代码将为所有定义的文件类型设置七天的缓存控制头。
- en: 'After making these settings, the response headers for a request will be as
    follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些设置后，请求的响应头将如下所示：
- en: '![NGINX](graphics/B05225_03_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![NGINX](graphics/B05225_03_01.jpg)'
- en: In the preceding figure, it can be clearly seen that the `.js` file is loaded
    from cache. Its cache-control header is set to seven days or 604,800 seconds.
    The expiry date can also be noted clearly in the `expires` headers. After the
    expiry date, the browser will load this `.js` file from the server and cache it
    again for the duration defined in the cache-control headers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，可以清楚地看到`.js`文件是从缓存中加载的。它的缓存控制头设置为七天或604,800秒。到期日期也可以清楚地在`expires`头中注意到。到期日期后，浏览器将从服务器加载此`.js`文件，并根据缓存控制头中定义的持续时间再次缓存它。
- en: HTTP persistent connection
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP持久连接
- en: 'In HTTP persistent connection, or HTTP keep-alive, a single TCP/IP connection
    is used for multiple requests or responses. It has a huge performance improvement
    over the normal connection as it uses only a single connection instead of opening
    and closing connections for each and every single request or response. Some of
    the benefits of the HTTP keep-alive are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP持久连接或HTTP keep-alive中，单个TCP/IP连接用于多个请求或响应。与正常连接相比，它具有巨大的性能改进，因为它只使用一个连接，而不是为每个单独的请求或响应打开和关闭连接。HTTP
    keep-alive的一些好处如下：
- en: The load on the CPU and memory is reduced because fewer TCP connections are
    opened at a time, and no new connections are opened for subsequent requests and
    responses as these TCP connections are used for them.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于一次只打开了较少的TCP连接，并且对于后续的请求和响应不会打开新的连接，因为这些TCP连接用于它们，所以CPU和内存的负载减少了。
- en: Reduces latency in subsequent requests after the TCP connection is established.
    When a TCP connection is to be established, a three-way handshake communication
    is made between a user and the HTTP server. After successfully handshaking, a
    TCP connection is established. In case of keep-alive, the handshaking is performed
    only once for the initial request to establish a TCP connection, and no handshaking
    or TCP connection opening/closing is performed for the subsequent requests. This
    improves the performance of the requests/responses.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建立TCP连接后，减少了后续请求的延迟。当要建立TCP连接时，用户和HTTP服务器之间进行了三次握手通信。成功握手后，建立了TCP连接。在keep-alive的情况下，仅对初始请求进行一次握手以建立TCP连接，并且对于后续请求不进行握手或TCP连接的打开/关闭。这提高了请求/响应的性能。
- en: Network congestion is reduced because only a few TCP connections are opened
    to the server at a time.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拥塞减少了，因为一次只打开了少量TCP连接到服务器。
- en: Besides these benefits, there are some side effects of keep-alive. Every server
    has a concurrency limit, and when this concurrency limit is reached or consumed,
    there can be a huge degradation in the application's performance. To overcome
    this issue, a time-out is defined for each connection, after which the HTTP keep-alive
    connection is closed automatically. Now, let's enable HTTP keep-alive on both
    Apache and NGINX.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些好处，keep-alive还有一些副作用。每个服务器都有并发限制，当达到或消耗此并发限制时，应用程序的性能可能会大幅下降。为了解决这个问题，为每个连接定义了超时，超过超时后，HTTP
    keep-alive连接将自动关闭。现在，让我们在Apache和NGINX上都启用HTTP keep-alive。
- en: Apache
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache
- en: In Apache, keep-alive can be enabled in two ways. You can enable it either in
    the `.htaccess` file or in the Apache config file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apache中，keep-alive可以通过两种方式启用。您可以在`.htaccess`文件或Apache配置文件中启用它。
- en: 'To enable it in the `.htaccess` file, place the following configuration in
    the `.htaccess` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`.htaccess`文件中启用它，请在`.htaccess`文件中放置以下配置：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding configuration, we set the Connection header to keep-alive in
    the `.htaccess` file. As the `.htaccess` configuration overrides the configuration
    in the config files, this will override whatever configuration is made for keep-alive
    in the Apache config file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们在`.htaccess`文件中将连接头设置为keep-alive。由于`.htaccess`配置会覆盖配置文件中的配置，这将覆盖Apache配置文件中对keep-alive所做的任何配置。
- en: 'To enable the keep-alive connection in the Apache config file, we have to modify
    three configuration options. Search for the following configuration and set the
    values to the ones in the example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Apache配置文件中启用keep-alive连接，我们必须修改三个配置选项。搜索以下配置并将值设置为示例中的值：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding configuration, we turned on the keep-alive configuration by
    setting the value of `KeepAlive` to `On`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们通过将`KeepAlive`的值设置为`On`来打开了keep-alive配置。
- en: The next is `MaxKeepAliveRequests`, which defines the maximum number of keep-alive
    connections to the web server at the time. A value of 100 is the default in Apache,
    and it can be changed according to the requirements. For high performance, this
    value should be kept high. If set to 0, it will allow unlimited keep-alive connections,
    which is not recommended.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`MaxKeepAliveRequests`，它定义了同时向Web服务器保持活动连接的最大数量。在Apache中，默认值为100，并且可以根据要求进行更改。为了获得高性能，应该保持这个值较高。如果设置为0，将允许无限的keep-alive连接，这是不推荐的。
- en: The last configuration is `KeepAliveTimeout`, which is set to 100 seconds. This
    defines the number of seconds to wait for the next request from the same client
    on the same TCP connection. If no request is made, then the connection is closed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个配置是`KeepAliveTimeout`，设置为100秒。这定义了在同一TCP连接上等待来自同一客户端的下一个请求的秒数。如果没有请求，则连接将关闭。
- en: NGINX
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGINX
- en: 'HTTP keep-alive is part of the `http_core` module and is enabled by default.
    In the NGINX configuration file, we can edit a few options, such as timeout. Open
    the `nginx` config file, edit the following configuration options, and set its
    values to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP keep-alive是`http_core`模块的一部分，默认情况下已启用。在NGINX配置文件中，我们可以编辑一些选项，如超时。打开`nginx`配置文件，编辑以下配置选项，并将其值设置为以下值：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `keepalive_requests` config defines the maximum number of requests a single
    client can make on a single HTTP keep-alive connection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepalive_requests`配置定义了单个客户端在单个HTTP keep-alive连接上可以发出的最大请求数。'
- en: The `keepalive_timeout` config is the number of seconds that the server needs
    to wait for the next request until it closes the keep-alive connection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepalive_timeout`配置是服务器需要等待下一个请求的秒数，直到关闭keep-alive连接。'
- en: GZIP compression
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GZIP压缩
- en: Content compression provides a way to reduce the contents' size delivered by
    the HTTP server. Both Apache and NGINX provide support for GZIP compression, and
    similarly, most modern browsers support GZIP. When the GZIP compression is enabled,
    the HTTP server sends compressed HTML, CSS, JavaScript, and images that are small
    in size. This way, the contents are loaded fast.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 内容压缩提供了一种减少HTTP服务器传送的内容大小的方法。Apache和NGINX都支持GZIP压缩，同样，大多数现代浏览器都支持GZIP。启用GZIP压缩后，HTTP服务器会发送压缩的HTML、CSS、JavaScript和大小较小的图像。这样，内容加载速度很快。
- en: A web server only compresses content via GZIP when the browser sends information
    about itself that it supports GZIP compression. Usually, a browser sends such
    information in *Request* headers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器发送有关自身支持GZIP压缩的信息时，Web服务器才会通过GZIP压缩内容。通常，浏览器在*Request*标头中发送此类信息。
- en: The following are codes for both Apache and NGINX to enable GZIP compression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是启用GZIP压缩的Apache和NGINX代码。
- en: Apache
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache
- en: 'The following code can be placed in the `.htaccess` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以放置在`.htaccess`文件中：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we used the Apache `deflate` module to enable compression.
    We used filter by type to compress only certain types of files, such as `.html`,
    plain text, `.xml`, `.css`, and `.js`. Also, before ending the module, we set
    a case to not compress the images because compressing images can cause image quality
    degradation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了Apache的`deflate`模块来启用压缩。我们按类型进行过滤，只压缩特定类型的文件，如`.html`，纯文本，`.xml`，`.css`和`.js`。此外，在结束模块之前，我们设置了一个条件，不压缩图像，因为压缩图像会导致图像质量下降。
- en: NGINX
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NGINX
- en: 'As mentioned previously, you have to place the following code in your virtual
    host conf file for NGINX:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您必须将以下代码放置在NGINX的虚拟主机配置文件中：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, GZIP compression is activated by the `gzip on;` line.
    The `gzip_vary on;` line is used to enable varying headers. The `gzip_types` line
    is used to define the types of files to be compressed. Any file types can be added
    depending on the requirements. The `gzip_com_level 4;` line is used to set the
    compression level, but be careful with this value; you don't want to set it too
    high. Its range is from 1 to 9, so keep it in the middle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，通过`gzip on;`行激活了GZIP压缩。`gzip_vary on;`行用于启用不同的标头。`gzip_types`行用于定义要压缩的文件类型。根据要求可以添加任何文件类型。`gzip_com_level
    4;`行用于设置压缩级别，但要小心这个值；不要设置得太高。它的范围是1到9，所以保持在中间。
- en: 'Now, let''s check whether the compression really works. In the following screenshot,
    the request is sent to a server that does not have GZIP compression enabled. The
    size of the final HTML page downloaded or transferred is 59 KB:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查压缩是否真的有效。在下面的截图中，请求发送到一个未启用GZIP压缩的服务器。下载或传输的最终HTML页面的大小为59 KB：
- en: '![NGINX](graphics/B05225_03_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![NGINX](graphics/B05225_03_02.jpg)'
- en: 'After enabling GZIP compression on the web server, the size of the transferred
    HTML page is reduced up to 9.95 KB, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用Web服务器上的GZIP压缩后，传输的HTML页面的大小减小了9.95 KB，如下截图所示：
- en: '![NGINX](graphics/B05225_03_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![NGINX](graphics/B05225_03_03.jpg)'
- en: Also, it can be noted that the time to load the contents is also reduced. So,
    the smaller the size of your contents, the faster the page will load.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以注意到加载内容的时间也减少了。因此，您的内容越小，页面加载速度就越快。
- en: Using PHP as a separate service
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将PHP用作独立服务
- en: Apache uses the `mod_php` module for PHP. This way, the PHP interpreter is integrated
    to Apache, and all processing is done by this Apache module, which eats up more
    server hardware resources. It is possible to use PHP-FPM with Apache, which uses
    the FastCGI protocol and runs in a separate process. This enables Apache to worry
    about HTTP request handlings, and the PHP processing is made by the PHP-FPM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Apache使用`mod_php`模块来处理PHP。这样，PHP解释器集成到Apache中，所有处理都由这个Apache模块完成，这会消耗更多的服务器硬件资源。可以使用PHP-FPM与Apache一起使用，它使用FastCGI协议并在单独的进程中运行。这使得Apache可以处理HTTP请求处理，而PHP处理由PHP-FPM完成。
- en: NGINX, on the other hand, does not provide any built-in support or any support
    by module for PHP processing. So, with NGINX, PHP is always used in a separate
    service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，NGINX不提供任何内置支持或模块支持PHP处理。因此，在NGINX中，PHP始终用作独立服务。
- en: 'Now, let''s take a look at what happens when PHP runs as a separate service:
    the web server does not know how to process the dynamic content request and forwards
    the request to another external service, which reduces the processing load on
    the web server.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当PHP作为独立服务运行时会发生什么：Web服务器不知道如何处理动态内容请求，并将请求转发到另一个外部服务，从而减少了Web服务器的处理负载。
- en: Disabling unused modules
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用未使用的模块
- en: Both Apache and NGINX come with lots of modules built into them. In most cases,
    you won't need some of these modules. It is good practice to disable these modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Apache和NGINX都内置了许多模块。在大多数情况下，您不需要其中一些模块。最好的做法是禁用这些模块。
- en: It is good practice to make a list of the modules that are enabled, disable
    those modules one by one, and restart the server. After this, check whether your
    application is working or not. If it works, go ahead; otherwise, enable the module(s)
    after which the application stopped working properly again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是制作一个启用的模块列表，逐个禁用这些模块，并重新启动服务器。之后，检查您的应用程序是否工作。如果工作正常，继续；否则，在应用程序再次停止正常工作之后，启用模块。
- en: This is because you may see that a certain module may not be required, but some
    other useful module depends on this module. So, it's best practice it to make
    a list and enable or disable the modules, as stated before.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您可能会发现某个模块可能不需要，但其他一些有用的模块依赖于这个模块。因此，最好的做法是制作一个列表，启用或禁用模块，如前所述。
- en: Apache
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache
- en: 'To list all the modules that are loaded for Apache, issue the following command
    in the terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出为Apache加载的所有模块，请在终端中发出以下命令：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command will list all the loaded modules, as can be seen in the following
    screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出所有加载的模块，如下截图所示：
- en: '![Apache](graphics/B05225_03_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Apache](graphics/B05225_03_04.jpg)'
- en: Now, analyze all the loaded modules, check whether they are needed for the application,
    and disable them, as follows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分析所有加载的模块，检查它们是否对应用程序有用，并禁用它们，如下所示。
- en: 'Open up the Apache config file and find the section where all the modules are
    loaded. A sample is included here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Apache配置文件，找到加载所有模块的部分。这里包括一个示例：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The modules that have a `#` sign in front of them are not loaded. So, to disable
    a module in the complete list, just place a `#` sign. The `#` sign will comment
    out the line, and the module won't be loaded anymore.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面加上`#`符号的模块是未加载的。因此，要在完整列表中禁用模块，只需放置一个`#`符号。`#`符号将注释掉该行，模块将不再加载。
- en: NGINX
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NGINX
- en: 'To check which modules NGINX is compiled with, issue the following command
    in the terminal:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查NGINX编译时使用了哪些模块，请在终端中发出以下命令：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will list complete information about the NGINX installation, including
    the version and modules with which NGINX is compiled. Have a look at the following
    screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出NGINX安装的完整信息，包括版本和NGINX编译时使用的模块。请查看以下截图：
- en: '![NGINX](graphics/B05225_03_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![NGINX](graphics/B05225_03_05.jpg)'
- en: Normally, NGINX enables only those modules that are required for NGINX to work.
    To enable any other module that is compiled with NGINX installed, we can place
    a little configuration for it in the `nginx.conf` file, but there is no single
    way to disable any NGINX module. So, it is good to search for this specific module
    and take a look at the module page on the NGINX website. There, we can find information
    about this specific module, and if available, we can find information about how
    to disable and configure this module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，NGINX只启用了NGINX工作所需的模块。要启用已安装的任何其他模块，我们可以在`nginx.conf`文件中为其添加一些配置，但是没有单一的方法来禁用任何NGINX模块。因此，最好搜索特定模块，并查看NGINX网站上的模块页面。在那里，我们可以找到有关特定模块的信息，如果可用，我们可以找到有关如何禁用和配置该模块的信息。
- en: Web server resources
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web服务器资源
- en: Each web server comes with its own optimum settings for general use. However,
    these settings may be not optimum for your current server hardware. The biggest
    problem on the web server hardware is the RAM. The more RAM the server has, the
    more the web server will be able to handle requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web服务器都有自己的通用最佳设置。但是，这些设置可能不适用于您当前的服务器硬件。Web服务器硬件上最大的问题是RAM。服务器的RAM越多，Web服务器就能处理的请求就越多。
- en: NGINX
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NGINX
- en: NGINX provides two variables to adjust the resources, which are `worker_processes`
    and `worker_connections`. The `worker_processes` settings decide how many NGINX
    processes should run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX提供了两个变量来调整资源，即`worker_processes`和`worker_connections`。`worker_processes`设置决定了应该运行多少个NGINX进程。
- en: Now, how many `worker_processes` resources should we use? This depends on the
    server. Usually, it is one worker processes per processor core. So, if your server
    processor has four cores, this value can be set to 4.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该使用多少`worker_processes`资源？这取决于服务器。通常情况下，每个处理器核心使用一个工作进程。因此，如果您的服务器处理器有四个核心，这个值可以设置为4。
- en: 'The value of `worker_connections` shows the number of connections per `worker_processes`
    setting per second. Simply speaking, `worker_connections` tells NGINX how many
    simultaneous requests can be handled by NGINX. The value of `worker_connections`
    depends on the system processor core. To find out the core''s limitations on a
    Linux system (Debian/Ubuntu), issue the following command in the terminal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker_connections`的值显示每秒每个`worker_processes`设置的连接数。简单地说，`worker_connections`告诉NGINX可以处理多少个同时请求。`worker_connections`的值取决于系统处理器核心。要找出Linux系统（Debian/Ubuntu）上核心的限制，请在终端中发出以下命令：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will show you a number that should be used for `worker_connections`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将显示一个应该用于`worker_connections`的数字。
- en: Now, let's say that our processor has four cores, and each core's limitation
    is 512\. Then, we can set the values for these two variables in the NGINX main
    configuration file. On Debian/Ubuntu, it is located at `/etc/nginx/nginx.conf`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的处理器有四个核心，每个核心的限制是512。然后，我们可以在NGINX主配置文件中设置这两个变量的值。在Debian/Ubuntu上，它位于`/etc/nginx/nginx.conf`。
- en: 'Now, find out these two variables and set them as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，找出这两个变量并设置如下：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding values can be high, specially `worker_connections`, because server
    processor cores have high limitations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的值可能会很高，特别是`worker_connections`，因为服务器处理器核心有很高的限制。
- en: Content Delivery Network (CDN)
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容交付网络（CDN）
- en: Content Delivery Network is used to host static media files, such as images,
    `.css` and `.js` files, and audio and video files. These files are stored on a
    geographical network whose servers are located in different locations. Then, these
    files are served to requests from a specific server, depending on the request
    location.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内容交付网络用于托管静态媒体文件，如图像、`.css`和`.js`文件，以及音频和视频文件。这些文件存储在地理网络上，其服务器位于不同的位置。然后，这些文件根据请求位置从特定服务器提供给请求。
- en: 'CDN provides the following features:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: CDN提供以下功能：
- en: As the contents are static, which don't change frequently, CDN caches them in
    memory. When a request comes for a certain file, CDN sends the file directly from
    cache, which is faster than loading the file from disk and sending it to the browser.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于内容是静态的，不经常更改，CDN会将它们缓存在内存中。当对某个文件发出请求时，CDN会直接从缓存中发送文件，这比从磁盘加载文件并发送到浏览器要快。
- en: CDN servers are located in different locations. All the files are stored in
    each location, depending on your settings in CDN. When a browser request arrives
    to CDN, CDN sends the requested contents from the nearest location available to
    the requested location. For example, if the CDN has servers in London, New York,
    and Dubai and a request comes from Middle East, the CDN will send content from
    the Dubai server. This way, as a CDN delivers the contents from the nearest location,
    the response time is reduced.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDN服务器位于不同的位置。所有文件都存储在每个位置，取决于您在CDN中的设置。当浏览器请求到达CDN时，CDN会从最近可用的位置发送请求的内容到请求的位置。例如，如果CDN在伦敦、纽约和迪拜都有服务器，并且来自中东的请求到达时，CDN将从迪拜服务器发送内容。这样，由于CDN从最近的位置提供内容，响应时间得到了缩短。
- en: Each browser has limitations for sending simultaneous requests to a domain.
    Mostly, it's three requests. When a response arrives for a request, the browser
    sends more requests to the same domain, which causes a delay in complete page
    loading. CDN provides subdomains (either their own subdomains or your main domain's
    subdomains, using your main domain's DNS settings), which enables browsers to
    send more parallel requests for the same contents loading from different domains.
    This enables the browser to load the page content fast.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个浏览器对向同一域发送并行请求有限制。通常是三个请求。当对请求的响应到达时，浏览器会向同一域发送更多的请求，这会导致完整页面加载的延迟。CDN提供子域（可以是它们自己的子域或您主域的子域，使用您主域的DNS设置），这使得浏览器可以向从不同域加载的相同内容发送更多的并行请求。这使得浏览器可以快速加载页面内容。
- en: Generally, there is a small amount of requests for dynamic content and more
    requests for static content. If your application's static content is hosted on
    a separate CDN server, this will reduce the load on your server tremendously.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，动态内容的请求量很小，静态内容的请求量更多。如果您的应用的静态内容托管在单独的CDN服务器上，这将极大地减轻服务器的负载。
- en: Using CDN
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CDN
- en: 'So, how do you use CDN in your application? In best practice, if your application
    has high traffic, creating different subdomains at your CDN for each content type
    is the best. For example, a separate domain for CSS and JavaScript files, a subdomain
    for images, and another separate subdomain for audio/videos files can be created.
    This way, the browser will send parallel requests for each content type. Let''s
    say, we have the following URLs for each content type:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何在应用中使用CDN呢？在最佳实践中，如果您的应用流量很大，为每种内容类型在CDN上创建不同的子域是最好的选择。例如，为CSS和JavaScript文件创建一个单独的域，为图像创建一个子域，为音频/视频文件创建另一个单独的子域。这样，浏览器将为每种内容类型发送并行请求。假设我们对每种内容类型有以下URL：
- en: '**For CSS and JavaScript**: `http://css-js.yourcdn.com`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于CSS和JavaScript**：`http://css-js.yourcdn.com`'
- en: '**For images**: `http://images.yourcdn.com`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于图像**：`http://images.yourcdn.com`'
- en: '**For other** **media**: `http://media.yourcdn.com`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于其他媒体**：`http://media.yourcdn.com`'
- en: Now, most open source applications provide settings at their admin control panel
    to set up CDN URLs, but in case you happened to use an open source framework or
    a custom-build application, you can define your own setting for CDN by placing
    the previous URLs either in the database or in a configuration file loaded globally.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数开源应用程序在其管理控制面板中提供设置以设置CDN URL，但如果您使用的是开源框架或自定义构建的应用程序，您可以通过将上述URL放在数据库中或全局加载的配置文件中来定义自己的CDN设置。
- en: 'For our example, we will place the preceding URLs in a config file and create
    three constants for them, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将把上述URL放在一个配置文件中，并为它们创建三个常量，如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we need to load a CSS file, it can be loaded as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要加载CSS文件，可以按以下方式加载：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For a JavaScript file, it can be loaded as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript文件，可以按以下方式加载：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we load images, we can use the previous way in the `src` attribute of the
    `img` tag, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们加载图像，可以在`img`标签的`src`属性中使用上述方式，如下所示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding examples, if we don't need to use CDN or want to change the
    CDN URLs, it will be easy to change in just one place.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，如果我们不需要使用CDN或想要更改CDN URL，只需在一个地方进行更改即可。
- en: Most famous JavaScript libraries and templating engines host their static resources
    on their own personal CDN. Google hosts query libraries, fonts, and other JavaScript
    libraries on its own CDN, which can be used directly in applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数知名的JavaScript库和模板引擎都在其自己的个人CDN上托管其静态资源。谷歌在其自己的CDN上托管查询库、字体和其他JavaScript库，可以直接在应用程序中使用。
- en: Sometimes, we may not want to use CDN or be able to afford them. For this, we
    can use a technique called domain sharing. Using domain sharding, we can create
    subdomains or point out other domains to our resources' directories on the same
    server and application. The technique is the same as discussed earlier; the only
    difference is that we direct other domains or subdomains to our media, CSS, JavaScript,
    and image directories ourselves.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能不想使用CDN或负担不起它们。为此，我们可以使用一种称为域共享的技术。使用域分片，我们可以创建子域或将其他域指向我们在同一服务器和应用程序上的资源目录。这种技术与之前讨论的相同；唯一的区别是我们自己将其他域或子域指向我们的媒体、CSS、JavaScript和图像目录。
- en: This may seem be fine, but it won't provide us with CDN's best performance.
    This is because CDN decides the geographical availability of content depending
    on the customer's location, extensive caching, and files optimization on the fly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不错，但它不会为我们提供CDN的最佳性能。这是因为CDN根据客户的位置决定内容的地理可用性，进行广泛的缓存，并在运行时对文件进行优化。
- en: CSS and JavaScript optimization
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS和JavaScript优化
- en: Every web application has CSS and JavaScript files. Nowadays, it is common that
    most applications have lots of CSS and JavaScript files to make the application
    attractive and interactive. Each CSS and JavaScript file needs a browser to send
    a request to the server to fetch the file. So, the more the CSS and JavaScript
    files you have, the more requests the browser will need to send, thus affecting
    its performance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应用程序都有CSS和JavaScript文件。如今，大多数应用程序都有大量的CSS和JavaScript文件，以使应用程序具有吸引力和互动性。每个CSS和JavaScript文件都需要浏览器向服务器发送请求来获取文件。因此，你拥有的CSS和JavaScript文件越多，浏览器就需要发送的请求就越多，从而影响其性能。
- en: Each file has a content size, and it takes time for the browser to download
    it. For example, if we have 10 CSS files of 10 KB each and 10 JavaScript files
    of 50 KB each, the total content size of the CSS files is 100 KB, and for JavaScript
    it is 500 KB—600 KB for both types of files. This is too much, and the browser
    will take time to download them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都有一个内容大小，浏览器下载它需要时间。例如，如果我们有10个每个10KB的CSS文件和10个每个50KB的JavaScript文件，CSS文件的总内容大小为100KB，JavaScript文件的总内容大小为500KB，两种类型的文件总共为600KB。这太多了，浏览器会花费时间来下载它们。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Performance plays a vital role in web applications. Even Google counts performance
    in its indexing. Don't think of a file that has a few KBs and takes a 1 ms to
    download because when it comes to performance, each millisecond is counted. The
    best thing is to optimize, compress, and cache everything.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 性能在网络应用程序中扮演着至关重要的角色。即使是Google在其索引中也计算性能。不要认为一个文件只有几KB并且需要1毫秒下载，因为在性能方面，每一毫秒都是被计算的。最好的方法是优化、压缩和缓存一切。
- en: 'In this section, we will discuss two ways to optimize our CSS and JS, which
    are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论两种优化我们的CSS和JS的方法，如下所示：
- en: Merging
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并
- en: Minifying
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Merging
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并
- en: In the merging process, we can merge all the CSS files into a single file, and
    the same process is carried out with JavaScript files, thus creating a single
    file for CSS and JavaScript. If we have 10 files for CSS, the browser sends 10
    requests for all these files. However, if we merge them in a single file, the
    browser will send only one request, and thus, the time taken for nine requests
    is saved.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并过程中，我们可以将所有的CSS文件合并成一个文件，JavaScript文件也是同样的过程，从而创建一个CSS和JavaScript的单一文件。如果我们有10个CSS文件，浏览器会发送10个请求来获取所有这些文件。然而，如果我们将它们合并成一个文件，浏览器只会发送一个请求，因此节省了九个请求所花费的时间。
- en: Minifying
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: In the minifying process, all the empty lines, comments, and extra spaces are
    removed from the CSS and JavaScript files. This way, the size of the file is reduced,
    and the file loads fast.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在压缩过程中，CSS和JavaScript文件中的所有空行、注释和额外的空格都被移除。这样，文件的大小就减小了，文件加载速度就快了。
- en: 'For example, let''s say you have the following CSS code in a file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在一个文件中有以下CSS代码：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After minifying the file, we will have CSS code similar to the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩文件后，我们将得到类似以下的CSS代码：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly for JavaScript, let''s consider that we have the following code in
    a JavaScript file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，对于JavaScript，假设我们在一个JavaScript文件中有以下代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if the preceding file is minified, we will have the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果前述文件被压缩，我们将得到以下代码：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It can be noted in the preceding examples that all the unnecessary white spaces
    and new lines are removed. Also, it places the complete file code in one single
    line. All code comments are removed. This way, the file size is reduced, which
    helps the file be loaded fast. Also, this file will consume less bandwidth, which
    is useful if the server resources are limited.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以注意到在前面的例子中，所有不必要的空格和换行都被移除了。它还将完整的文件代码放在一行中。所有的代码注释都被移除了。这样，文件大小就减小了，有助于文件快速加载。此外，这个文件将消耗更少的带宽，如果服务器资源有限的话，这是有用的。
- en: Most open source applications, such as Magento, Drupal, and WordPress, provide
    either built-in support or support the application by third-party plugins/modules.
    Here, we won't cover how to merge CSS or JavaScript files in these applications,
    but we will discuss a few tools that can merge CSS and JavaScript files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源应用程序，如Magento、Drupal和WordPress，提供内置支持或支持第三方插件/模块的应用程序。在这里，我们不会涵盖如何在这些应用程序中合并CSS或JavaScript文件，但我们将讨论一些可以合并CSS和JavaScript文件的工具。
- en: Minify
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minify
- en: Minify is a set of libraries completely written in PHP. Minify supports both
    merging and minifying for both CSS and JavaScript files. Its code is completely
    object-oriented and namespaced, so it can be embedded into any current or proprietary
    framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Minify是一组完全用PHP编写的库。Minify支持CSS和JavaScript文件的合并和压缩。它的代码完全是面向对象和命名空间的，因此可以嵌入到任何当前的或专有的框架中。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Minify homepage is located at [http://minifier.org](http://minifier.org).
    It is also hosted on GitHub at [https://github.com/matthiasmullie/minify](https://github.com/matthiasmullie/minify).
    It is important to note that the Minify library uses a path converter library,
    which is written by the same author. The path converter library can be downloaded
    from [https://github.com/matthiasmullie/path-converter](https://github.com/matthiasmullie/path-converter).
    Download this library and place it in the same folder as the minify libraries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Minify主页位于[http://minifier.org](http://minifier.org)。它也托管在GitHub上，网址为[https://github.com/matthiasmullie/minify](https://github.com/matthiasmullie/minify)。值得注意的是，Minify库使用了一个路径转换库，这个库是由同一作者编写的。路径转换库可以从[https://github.com/matthiasmullie/path-converter](https://github.com/matthiasmullie/path-converter)下载。下载这个库并将其放在与minify库相同的文件夹中。
- en: 'Now, let''s create a small project that we will use to minify and merge CSS
    and JavaScript files. The folder structure of the project will be as in the following
    screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个小项目，用来缩小和合并CSS和JavaScript文件。项目的文件夹结构将如下截图所示：
- en: '![Minify](graphics/B05225_03_06.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Minify](graphics/B05225_03_06.jpg)'
- en: In the preceding screenshot, the complete project structure is shown. The project
    name is `minify`. The `css` folder has all of our CSS files, including the minified
    or merged ones. Similarly, the `js` folder has all our JavaScript files, including
    the minified or merged ones. The `libs` folder has the `Minify` library along
    with the `Converter` library. `Index.php` has our main code to minify and merge
    CSS and JavaScript files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，显示了完整的项目结构。项目名称是`minify`。`css`文件夹中包含了所有的CSS文件，包括缩小或合并的文件。同样，`js`文件夹中包含了所有的JavaScript文件，包括缩小或合并的文件。`libs`文件夹中包含了`Minify`库和`Converter`库。`Index.php`包含了我们用来缩小和合并CSS和JavaScript文件的主要代码。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `data` folder in the project tree is related to JavaScript minification.
    As JavaScript has keywords that require a space before and after them, these `.txt`
    files are used to identify these operators.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 项目树中的`data`文件夹与JavaScript缩小有关。由于JavaScript有需要在其前后加上空格的关键字，这些`.txt`文件用于识别这些运算符。
- en: 'So, let''s start by minifying our CSS and JavaScript files using the following
    code in `index.php`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从`index.php`中使用以下代码来缩小我们的CSS和JavaScript文件：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code is simple. First, we included all our required libraries.
    Then, in the `Minify CSS` block, we created two path variables: `$cssSourcePath`,
    which has the path to the CSS file that we need to minify, and `$cssOutputPath`,
    which has path to the minified CSS file that will be generated.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很简单。首先，我们包含了所有需要的库。然后，在`Minify CSS`块中，我们创建了两个路径变量：`$cssSourcePath`，它包含了我们需要缩小的CSS文件的路径，以及`$cssOutputPath`，它包含了将要生成的缩小CSS文件的路径。
- en: After this, we instantiated an object of the `CSS.php` class and passed the
    CSS file that we need to minify. Finally, we called the minify method of the `CSS`
    class and passed the output path along with the filename, which will generate
    the required file for us.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们实例化了`CSS.php`类的一个对象，并传递了我们需要缩小的CSS文件。最后，我们调用了`CSS`类的缩小方法，并传递了输出路径以及文件名，这将为我们生成所需的文件。
- en: The same explanation goes for the JS minifying process.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JS缩小过程也是同样的解释。
- en: 'If we run the preceding PHP code, all the files are in place, and everything
    goes fine, then two new filenames will be created: `styles.min.css` and `app.min.js`.
    These are the new minified versions of their original files.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述PHP代码，所有文件都就位，一切顺利，那么将会创建两个新的文件名：`styles.min.css`和`app.min.js`。这些是它们原始文件的新缩小版本。
- en: 'Now, let''s use Minify to merge multiple CSS and JavaScript files. First, add
    some CSS and JavaScript files to the respective folders in the project. After
    this, we just need to add a little code to the current code. In the following
    code, I will skip including all the libraries, but these files have to be loaded
    whenever you need to use Minify:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Minify来合并多个CSS和JavaScript文件。首先，在项目中的相应文件夹中添加一些CSS和JavaScript文件。之后，我们只需要在当前代码中添加一点代码。在下面的代码中，我将跳过包含所有库，但是每当您需要使用Minify时，这些文件都必须被加载。
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, take a look at the highlighted code. In the CSS part, we saved the minified
    and merged file as `style.min.merged.css`, but naming is not important; it is
    all up to our own choice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下高亮显示的代码。在CSS部分，我们将缩小和合并的文件保存为`style.min.merged.css`，但命名并不重要；这完全取决于我们自己的选择。
- en: Now, we will simply use the add method of the `$cssMinifier` and `$jsMinifier`
    objects to add new files and then call `minify`. This causes all the additional
    files to be merged in the initial file and then minified, thus generating a single
    merged and minified file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用`$cssMinifier`和`$jsMinifier`对象的`add`方法来添加新文件，然后调用`minify`。这将导致所有附加文件合并到初始文件中，然后进行缩小，从而生成单个合并和缩小的文件。
- en: Grunt
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Grunt
- en: According to its official website, Grunt is a JavaScript task runner. It automates
    certain repetitive tasks so that you don't have to work repeatedly. It is an awesome
    tool and is widely used among web programmers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其官方网站，Grunt是一个JavaScript任务运行器。它自动化了某些重复的任务，这样你就不必重复工作。这是一个很棒的工具，在Web程序员中被广泛使用。
- en: Installing Grunt is very easy. Here, we will install it on MAC OS X, and the
    same method is used for most Linux systems, such as Debian and Ubuntu.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Grunt非常容易。在这里，我们将在MAC OS X上安装它，大多数Linux系统，如Debian和Ubuntu，使用相同的方法。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Grunt requires Node.js and npm. Installing and configuring Node.js and npm is
    out of the scope of this book, so for this book, we will assume that these tools
    are installed on your machine or that you can search for them and figure out how
    to install them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt需要Node.js和npm。安装和配置Node.js和npm超出了本书的范围，因此在本书中，我们将假设这些工具已经安装在您的计算机上，或者您可以搜索它们并弄清楚如何安装它们。
- en: 'If Node.js and npm are installed on your machine, just fire up the following
    command in your terminal:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node.js和npm已经安装在您的计算机上，只需在终端中输入以下命令：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will install Grunt CLI. If everything goes fine, then the following command
    will show you the version the of Grunt CLI:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Grunt CLI。如果一切顺利，那么以下命令将显示Grunt CLI的版本：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output of the preceding command is `grunt-cli v0.1.13;` as of writing this
    book, this version is available.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出是`grunt-cli v0.1.13;`，在撰写本书时，这个版本是可用的。
- en: Grunt provides you with a command-line, which enables you to run a Grunt command.
    A Grunt project requires two files in your project file tree. One is `package.json`,
    which is used by `npm` and lists Grunt and the Grunt plugins that the project
    needs as DevDependencies.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt为您提供了一个命令行，可以让您运行Grunt命令。一个Grunt项目在您的项目文件树中需要两个文件。一个是`package.json`，它被`npm`使用，并列出了项目需要的Grunt和Grunt插件作为DevDependencies。
- en: The second file is the `GruntFile`, which is stored as `GruntFile.js` or `GruntFile.coffee`
    and is used to configure and define Grunt tasks and load Grunt plugins.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是`GruntFile`，它存储为`GruntFile.js`或`GruntFile.coffee`，用于配置和定义Grunt任务并加载Grunt插件。
- en: 'Now, we will use the same preceding project, but our folder structure will
    be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用相同的项目，但我们的文件夹结构将如下所示：
- en: '![Grunt](graphics/B05225_03_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Grunt](graphics/B05225_03_07.jpg)'
- en: 'Now, open the terminal in your project root and issue the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目根目录中打开终端并发出以下命令：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will generate the `package.json` file by asking a few questions. Now,
    open the `package.json` file and modify it so that the contents of the final `package.json`
    files look similar to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过询问一些问题生成`package.json`文件。现在，打开`package.json`文件并修改它，使最终的`package.json`文件的内容看起来类似于以下内容：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I added comments to different parts of the `package.json` file so that it is
    easy to understand. Note that for the final file, we will remove the comments
    from this file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`package.json`文件的不同部分添加了注释，以便易于理解。请注意，对于最终文件，我们将从该文件中删除注释。
- en: It can be seen that in the `DevDependencies` section, we added three Grunt plugins
    used for different tasks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，在`DevDependencies`部分，我们添加了用于不同任务的三个Grunt插件。
- en: 'The next step is to add `GruntFile`. Let''s create a file called `GruntFile.js`
    in our project root similar to the `package.json` file. Place the following contents
    in `GruntFile`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加`GruntFile`。让我们在项目根目录创建一个名为`GruntFile.js`的文件，内容类似于`package.json`文件。将以下内容放入`GruntFile`：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code is simple and self-explanatory, and the comments are added
    whenever needed. At the top, we loaded our `package.json` file, and after this,
    we defined different tasks along with their src and destination files. Remember
    that every task's src and destination syntax is different, and it depends on the
    plugin. After `initConfig` block, we loaded different plugins and npm tasks and
    then registered them with GRUNT.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简单易懂，需要时添加注释。在顶部，我们加载了我们的`package.json`文件，之后，我们定义了不同的任务以及它们的源文件和目标文件。请记住，每个任务的源文件和目标文件语法都不同，这取决于插件。在`initConfig`块之后，我们加载了不同的插件和npm任务，然后将它们注册到GRUNT上。
- en: Now, let's run our tasks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的任务。
- en: 'First, let''s combine CSS and JavaScript files and store them in their respective
    destinations defined in our tasks list in GruntFile via the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们合并CSS和JavaScript文件，并将它们存储在GruntFile中任务列表中定义的各自目标中，通过以下命令：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After running the preceding command in your terminal, if you see a message such
    as `Done, without errors`, then the task is completed successfully.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中运行上述命令后，如果看到`完成，无错误`的消息，则任务已成功完成。
- en: 'In the same way, let''s minify our css file using the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们使用以下命令来压缩我们的css文件：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will minify our JavaScript file using the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下命令来压缩我们的JavaScript文件：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, it may seem like a lot of work to use Grunt, but it provides some other
    features that can make a developer's life easy. For example, what if you need
    to change your JavaScript and CSS files? Should you run all the preceding commands
    again? No, Grunt provides a watch plugin, which activates and executes all the
    files in the destination paths in the tasks, and if any changes occur, it runs
    the tasks automatically.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Grunt可能看起来需要很多工作，但它提供了一些其他功能，可以让开发人员的生活变得更轻松。例如，如果您需要更改JavaScript和CSS文件怎么办？您应该再次运行所有前面的命令吗？不，Grunt提供了一个watch插件，它会激活并执行任务中目标路径中的所有文件，如果发生任何更改，它会自动运行任务。
- en: For a more detailed learning, take a look at Grunt's official website at [http://gruntjs.com/](http://gruntjs.com/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多详细信息，请查看Grunt的官方网站[http://gruntjs.com/](http://gruntjs.com/)。
- en: Full page caching
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整页面缓存
- en: In full page caching, the complete page of the website is stored in a cache,
    and for the next requests, this cached page is served. Full page cache is more
    effective if your website content does not change too often; for example, on a
    blog with simple posts, new posts are added on a weekly basis. In this case, the
    cache can be cleared after new posts are added.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整页面缓存中，网站的完整页面存储在缓存中，对于下一个请求，将提供此缓存页面。如果您的网站内容不经常更改，则完整页面缓存更有效；例如，在一个简单的博客上，每周添加新帖子。在这种情况下，可以在添加新帖子后清除缓存。
- en: What if you have a website that has pages with dynamic parts, such as an e-commerce
    website? In this case, a complete page caching will create problems because the
    page is always different for each request; as a user is logged in, he/she may
    add products to the shopping cart and so on. In this case, using full page caching
    may not be that easy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个网站，其中页面具有动态部分，例如电子商务网站怎么办？在这种情况下，完整页面缓存会带来问题，因为每个请求的页面总是不同；用户登录后，他/她可能会向购物车中添加产品等。在这种情况下，使用完整页面缓存可能并不容易。
- en: Most popular platforms provide either built-in support for full page cache or
    through plugins and modules. In this case, the plugin or module takes care of
    the dynamic blocks of the page for each request.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的平台都提供对完整页面缓存的内置支持或通过插件和模块。在这种情况下，插件或模块会为每个请求处理页面的动态块。
- en: Varnish
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Varnish
- en: Varnish, as mentioned on its official website, makes your website fly; and this
    is true! Varnish is an open source web application accelerator that runs in front
    of your web server software. It has to be configured on port 80 so that each request
    comes to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方网站所述，Varnish可以让您的网站飞起来；这是真的！Varnish是一个开源的Web应用程序加速器，运行在您的Web服务器软件的前面。它必须配置在端口80上，以便每个请求都会经过它。
- en: Now, the Varnish configuration file (called VCL files with the `.vcl` extenstion)
    has a definition for backends. A backend is the web server (Apache or NGINX) configured
    on another port (let's say 8080). Multiple backends can be defined, and Varnish
    will take care of the load balancing too.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Varnish配置文件（称为带有`.vcl`扩展名的VCL文件）有一个后端的定义。后端是配置在另一个端口（比如说8080）上的Web服务器（Apache或NGINX）。可以定义多个后端，并且Varnish也会负责负载均衡。
- en: When a request comes to Varnish, it checks whether the data for this request
    in available at its cache or not. If it finds the data in its cache, this cached
    data is returned to the request, and no request is sent to the web server or backend.
    If Varnish does not find any data in its cache, it sends a request to the web
    server and requests the data. When it receives data from the web server, it first
    caches this data and then sends it back to the request.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达Varnish时，它会检查该请求的数据是否在其缓存中可用。如果它在缓存中找到数据，则将缓存的数据返回给请求，不会发送请求到Web服务器或后端。如果Varnish在其缓存中找不到任何数据，则会向Web服务器发送请求并请求数据。当它从Web服务器接收数据时，首先会缓存这些数据，然后将其发送回请求。
- en: As it is clear in the preceding discussion, if Varnish finds the data in the
    cache, there is no need for a request to the web server and, therefore, for processing
    in there, and the response is sent back very fast.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的讨论所清楚的那样，如果Varnish在缓存中找到数据，就不需要向Web服务器发送请求，因此也不需要在那里进行处理，响应会非常快速地返回。
- en: Varnish also provides features such as load balancing and health checks. Also,
    Varnish has no support for SSL and cookies. If Varnish receives cookies from the
    web server or backend, this page is not cached. There are different ways to overcome
    these issues easily.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Varnish还提供了负载平衡和健康检查等功能。此外，Varnish不支持SSL和cookies。如果Varnish从Web服务器或后端接收到cookies，则不会缓存该页面。有不同的方法可以轻松解决这些问题。
- en: 'We''ve done enough theory; now, let''s install Varnish on a Debian/Ubuntu server
    via the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲了足够的理论；现在，让我们通过以下步骤在Debian/Ubuntu服务器上安装Varnish：
- en: 'First, add the Varnish repositories to the `sources.list` file. Place the following
    line in the file:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将Varnish存储库添加到`sources.list`文件中。在文件中加入以下行：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, issue the following command to update the repositories:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，输入以下命令以更新存储库：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, issue the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will download and install Varnish. Now, the first thing to do is configure
    Varnish to listen at port 80 and make your web server listen at another port,
    such as 8080\. We will configure it here with NGINX.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将下载并安装Varnish。现在，首先要做的是配置Varnish以侦听端口80，并使您的Web服务器侦听另一个端口，例如8080。我们将在这里使用NGINX进行配置。
- en: 'Now, open the Varnish configuration file location at `/etc/default/varnish`
    and change it so that it looks similar to the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开Varnish配置文件位置`/etc/default/varnish`，并进行更改，使其看起来类似于以下代码：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save the file and restart Varnish by issuing the following command in the terminal:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在终端中输入以下命令重新启动Varnish：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now our Varnish runs on port `80`. Let''s make NGINX run on port `8080`. Edit
    the NGINX `vhost` file for the application and change the listen port from `80`
    to `8080`, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的Varnish在端口`80`上运行。让NGINX在端口`8080`上运行。编辑应用程序的NGINX `vhost`文件，并将侦听端口从`80`更改为`8080`，如下所示：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, restart NGINX by issuing the following command in the terminal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中输入以下命令重新启动NGINX：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next step is to configure the Varnish VCL file and add a backend that will
    communicate with our backend on port `8080`. Edit the Varnish VCL file located
    at `/etc/varnish/default.vcl`, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置Varnish VCL文件并添加一个将与我们的后端通信的后端，端口为`8080`。编辑位于`/etc/varnish/default.vcl`的Varnish
    VCL文件，如下所示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding configuration, our backend host is located at the same server
    on which Varnish runs, so we entered the local IP. We can also enter a localhost
    in this case. However, if our backend runs on a remote host or another server,
    the IP of this server should be entered.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，我们的后端主机位于Varnish运行的同一台服务器上，因此我们输入了本地IP。在这种情况下，我们也可以输入localhost。但是，如果我们的后端在远程主机或另一台服务器上运行，则应输入该服务器的IP。
- en: Now, we are done with Varnish and web server configuration. Restart both Varnish
    and NGINX. Open your browser and enter the IP or hostname of the server. The first
    response may seem slow, which is because Varnish is fetching data from the backend
    and then caching it, but other subsequent responses will be extremely fast, as
    Varnish cached them and is now sending back the cached data without communicating
    with the backend.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了Varnish和Web服务器的配置。重新启动Varnish和NGINX。打开浏览器，输入服务器的IP或主机名。初始响应可能会很慢，因为Varnish正在从后端获取数据，然后对其进行缓存，但其他后续响应将非常快，因为Varnish已经对其进行了缓存，并且现在正在发送缓存的数据而不与后端通信。
- en: 'Varnish provides a tool in which we can easily monitor the Varnish cache status.
    It is a real-time tool and updates its contents in real time. It is called varnishstat.
    To start varnishstat, just issue the following command in the terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Varnish提供了一个工具，我们可以轻松监视Varnish缓存状态。这是一个实时工具，会实时更新其内容。它被称为varnishstat。要启动varnishstat，只需在终端中输入以下命令：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding command will display a session similar to the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将显示类似于以下截图的会话：
- en: '![Varnish](graphics/B05225_03_08.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Varnish](graphics/B05225_03_08.jpg)'
- en: As can be seen in the preceding screenshot, it displays very useful information,
    such as the running time and the number of requests made at the beginning, cache
    hits, cache misses, all backends, backend reusages, and so on. We can use this
    information to tune Varnish for its best performance.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，它显示非常有用的信息，例如运行时间和开始时的请求数，缓存命中，缓存未命中，所有后端，后端重用等。我们可以使用这些信息来调整Varnish以获得最佳性能。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A complete Varnish configuration is out of the scope of this book, but a good
    documentation can be found on the Varnish official website at [https://www.varnish-cache.org](https://www.varnish-cache.org).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Varnish的完整配置超出了本书的范围，但可以在Varnish官方网站[https://www.varnish-cache.org](https://www.varnish-cache.org)找到很好的文档。
- en: The infrastructure
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施
- en: We discussed too many topics on increasing the performance of our application.
    Now, let's discuss the scalability and availability of our application. With time,
    the traffic on our application can increase to thousands of users at a time. If
    our application runs on a single server, the performance will be hugely effected.
    Also, it is not a good idea to keep the application running at a single point
    because in case this server goes down, our complete application will be down.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our application more scalable and better in availability, we can use
    an infrastructure setup in which we can host our application on multiple servers.
    Also, we can host different parts of the application on different servers. To
    better understand, take a look at the following diagram:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![The infrastructure](graphics/B05225_03_09.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: This is a very basic design for the infrastructure. Let's talk about its different
    parts and what operations will be performed by each part and server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible that only the Load Balancer (LB) will be connected to the public
    Internet, and the rest of the parts can be connected to each through a private
    network in a Rack. If a Rack is available, this will be very good because all
    the communication between all the servers will be on a private network and therefore
    secure.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Web servers
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding diagram, we have two web servers. There can be as many web
    servers as needed, and they can be easily connected to LB. The web servers will
    host our actual application, and the application will run on NGINX or Apache and
    PHP 7\. All the performance tunings we will discuss in this chapter can be used
    on these web servers. Also, it is not necessary that these servers should be listening
    at port 80\. It is good that our web server should listen at another port to avoid
    any public access using browsers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The database server
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database server is mainly used for the database where the MySQL or Percona
    Server can be installed. However, one of the problems in the infrastructure setup
    is to store session data in a single place. For this purpose, we can also install
    the Redis server on the database server, which will handle our application's session
    data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The preceding infrastructure design is not a final or perfect design. It is
    just to give the idea of a multiserver application hosting. It has room for a
    lot of improvement, such as adding another local balancer, more web servers, and
    servers for the database cluster.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Load balancer (LB)
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first part is the **load balancer** (**LB**). The purpose of the load balancer
    is to divide the traffic among the web servers according to the load on each web
    server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: For the load balancer, we can use HAProxy, which is widely used for this purpose.
    Also, HAProxy checks the health of each web server, and if a web server is down,
    it automatically redirects the traffic of this down web server to other available
    web servers. For this purpose, only LB will be listening at port 80.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to place a load on our available web servers (in our case, two
    web servers) of encrypting and decrypting the SSL communication, so we will use
    the HAProxy server to terminate SSL there. When our LB receives a request with
    SSL, it will terminate SSL and send a normal request to one of the web servers.
    When it receives a response, HAProxy will encrypt the response and send it back
    to the client. This way, instead of using both the servers for SSL encryption/decryption,
    only a single LB server will be used for this purpose.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Varnish can be also used as a load balancer, but this is not a good idea because
    the whole purpose of Varnish is HTTP caching.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: HAProxy load balancing
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding infrastructure, we placed a load balancer in front of our web
    servers, which balance load on each server, check the health of each server, and
    terminate SSL. We will install HAProxy and configure it to achieve all the configurations
    mentioned before.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: HAProxy installation
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will install HAProxy on Debian/Ubuntu. As of writing this book, HAProxy
    1.6 is the latest stable version available. Perform the following steps to install
    HAProxy:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Debian/Ubuntu上安装HAProxy。在撰写本书时，HAProxy 1.6是最新的稳定版本。执行以下步骤安装HAProxy：
- en: 'First, update the system cache by issuing the following command in the terminal:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在终端中发出以下命令更新系统缓存：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, install HAProxy by entering the following command in the terminal:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在终端中输入以下命令安装HAProxy：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will install HAProxy on the system.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在系统上安装HAProxy。
- en: 'Now, confirm the HAProxy installation by issuing the following command in the
    terminal:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中发出以下命令确认HAProxy安装：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![HAProxy installation](graphics/B05225_03_10.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![HAProxy安装](graphics/B05225_03_10.jpg)'
- en: If the output is as in the preceding screenshot, then congratulations! HAProxy
    is installed successfully.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出与上述截图相同，则恭喜！HAProxy已成功安装。
- en: HAProxy load balancing
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HAProxy负载均衡
- en: 'Now, it''s time to use HAProxy. For this purpose, we have the following three
    servers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是使用HAProxy的时候了。为此，我们有以下三个服务器：
- en: The first is a load balancer server on which HAProxy is installed. We will call
    it LB. For this book's purpose, the IP of the LB server is 10.211.55.1\. This
    server will listen at port 80, and all HTTP requests will come to this server.
    This server also acts as a frontend server as all the requests to our application
    will come to this server.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是负载均衡器服务器，安装了HAProxy。我们将其称为LB。对于本书的目的，LB服务器的IP是10.211.55.1。此服务器将在端口80上进行监听，并且所有HTTP请求将发送到此服务器。此服务器还充当前端服务器，因为我们的应用的所有请求都将发送到此服务器。
- en: The second is a web server, which we will call Web1\. NGINX, PHP 7, MySQL, or
    Percona Server are installed on it. The IP of this server is 10.211.55.2\. This
    server will either listen at port 80 or any other port. We will keep it to listen
    at port 8080.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是Web服务器，我们将其称为Web1。NGINX、PHP 7、MySQL或Percona Server都安装在上面。此服务器的IP是10.211.55.2。此服务器将在端口80或任何其他端口上进行监听。我们将其保持在端口8080上进行监听。
- en: The third is a second web server, which we will call Web2, with the IP 10.211.55.3\.
    This has the same setup as of the Web1 server and will listen at port 8080.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是第二个Web服务器，我们将其称为Web2，IP为10.211.55.3。这与Web1服务器的设置相同，并将在端口8080上进行监听。
- en: The Web1 and Web2 servers are also called backend servers. First, let's configure
    the LB or frontend server to listen at port 80.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Web1和Web2服务器也称为后端服务器。首先，让我们配置LB或前端服务器在端口80上进行监听。
- en: 'Open the `haproxy.cfg` file located at `/etc/haproxy/` and add the following
    lines at the end of the file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`/etc/haproxy/`的`haproxy.cfg`文件，并在文件末尾添加以下行：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we set HAProxy to listen at the HTTP port 80 on any IP
    address, either the local loopback IP 127.0.0.1 or the public IP. Then, we set
    the default backend.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将HAProxy设置为在任何IP地址（本地回环IP 127.0.0.1或公共IP）上监听HTTP端口80。然后，我们设置默认的后端。
- en: 'Now, we will add two backend servers. In the same file, at the end, place the
    following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加两个后端服务器。在同一文件中，在末尾放置以下代码：
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding configuration, we added two servers into the web backend. The
    reference name for the backend is `web-backend`, which is used in the frontend
    configuration too. As we know, both our web servers listen at port 8080, so we
    mentioned that it is the definition of each web server. Also, we used `check`
    at the end of the definition of each web server, which tells HAProxy to check
    the server's health.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，我们将两个服务器添加到Web后端。后端的引用名称是`web-backend`，在前端配置中也使用了它。我们知道，我们的两个Web服务器都在端口8080上进行监听，因此我们提到这是每个Web服务器的定义。此外，我们在每个Web服务器的定义末尾使用了`check`，告诉HAProxy检查服务器的健康状况。
- en: 'Now, restart HAProxy by issuing the following command in the terminal:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中发出以下命令重新启动HAProxy：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To start HAProxy, we can use the `sudo service haproxy start` command. To stop
    HAProxy, we can use the `sudo service haproxy stop` command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动HAProxy，可以使用`sudo service haproxy start`命令。要停止HAProxy，可以使用`sudo service haproxy
    stop`命令。
- en: Now, enter the IP or hostname of the LB server in the browser, and our web application
    page will be displayed either from Web1 or Web2.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中输入LB服务器的IP或主机名，我们的Web应用页面将显示为来自Web1或Web2。
- en: Now, disable any of the web servers and then reload the page again. The application
    will still work fine, because HAProxy automatically detected that one of web servers
    is down and redirected the traffic to the second web server.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，禁用任何一个Web服务器，然后再次重新加载页面。应用程序仍将正常工作，因为HAProxy自动检测到其中一个Web服务器已关闭，并将流量重定向到第二个Web服务器。
- en: 'HAProxy also provides a stats page, which is browser-based. It provides complete
    monitoring information about the LB and all the backends. To enable stats, open
    `haprox.cfg`, and place the following code at the end of the file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy还提供了一个基于浏览器的统计页面。它提供有关LB和所有后端的完整监控信息。要启用统计信息，打开`haprox.cfg`，并在文件末尾放置以下代码：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The stats are enabled at port `1434`, which can be set to any port. The URL
    of the page is `stats uri`. It can be set to any URL. The `auth` section is for
    basic HTTP authentication. Save the file and restart HAProxy. Now, open the browser
    and enter the URL, such as `10.211.55.1:1434/haproxy-stats`. The stats page will
    be displayed as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 统计信息在端口`1434`上启用，可以设置为任何端口。页面的URL是`stats uri`。它可以设置为任何URL。`auth`部分用于基本的HTTP身份验证。保存文件并重新启动HAProxy。现在，打开浏览器，输入URL，例如`10.211.55.1:1434/haproxy-stats`。统计页面将显示如下：
- en: '![HAProxy load balancing](graphics/B05225_03_11.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![HAProxy负载均衡](graphics/B05225_03_11.jpg)'
- en: In the preceding screenshot, each backend web server can be seen, including
    frontend information.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，可以看到每个后端Web服务器，包括前端信息。
- en: 'Also, if a web server is down, HAProxy stats will highlight the row for this
    web server, as can be seen in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一个Web服务器宕机，HAProxy统计信息将突出显示此Web服务器的行，如下截图所示：
- en: '![HAProxy load balancing](graphics/B05225_03_12.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![HAProxy负载均衡](graphics/B05225_03_12.jpg)'
- en: For our test, we stopped NGINX at our Web2 server and refreshed the stats page,
    and the Web2 server row in the backend section was highlighted.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试，我们停止了Web2服务器上的NGINX，并刷新了统计页面，然后在后端部分中，Web2服务器行被突出显示。
- en: 'To terminate SSL using HAProxy, it is pretty simple. To terminate SSL using
    HAProxy, we will just add the SSL port 443 binding along with the SSL certificate
    file location. Open the `haproxy.cfg` file, edit the frontend block, and add the
    highlighted code in it, as in the following block:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HAProxy终止SSL，非常简单。我们只需在SSL端口443绑定上添加SSL证书文件位置。打开`haproxy.cfg`文件，编辑前端块，并在其中添加高亮显示的代码，如下所示的块：
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, HAProxy also listens at 443, and when an SSL request is sent to it, it
    processes it there and terminates it so that no HTTPS requests are sent to backend
    servers. This way, the load of SSL encryption/decryption is removed from the web
    servers and is managed by the HAProxy server only. As SSL is terminated at the
    HAProxy server, there is no need for web servers to listen at port 443, as regular
    requests from HAProxy server are sent to the backend.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，HAProxy也在443端口监听，当SSL请求发送到它时，它在那里处理并终止它，以便不会将HTTPS请求发送到后端服务器。这样，SSL加密/解密的负载就从Web服务器中移除，并由HAProxy服务器单独管理。由于SSL在HAProxy服务器上终止，因此无需让Web服务器在443端口监听，因为来自HAProxy服务器的常规请求会发送到后端。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed several topics starting from NGINX and Apache
    to Varnish. We discussed how we can optimize our web server's software settings
    for the best performance. Also, we discussed CDNs and how to use them in our customer
    applications. We discussed two ways to optimize JavaScript and CSS files for the
    best performance. We briefly discussed full page cache and Varnish installation
    and configuration. At the end, we discussed multiserver hosting or infrastructure
    setup for our application to be scalable and the best in availability.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从NGINX和Apache到Varnish等多个主题。我们讨论了如何优化我们的Web服务器软件设置以获得最佳性能。此外，我们还讨论了CDN以及如何在客户应用程序中使用它们。我们讨论了优化JavaScript和CSS文件以获得最佳性能的两种方法。我们简要讨论了完整页面缓存和Varnish的安装和配置。最后，我们讨论了多服务器托管或基础架构设置，以使我们的应用程序具有可伸缩性和最佳可用性。
- en: In next chapter, we will look into the ways of increasing the performance of
    our database. We will discuss several topics, including the Percona Server, different
    storage engines for the database, query caching, Redis, and Memcached.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何提高数据库性能的方法。我们将讨论包括Percona Server、数据库的不同存储引擎、查询缓存、Redis和Memcached在内的多个主题。

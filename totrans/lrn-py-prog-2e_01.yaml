- en: A Gentle Introduction to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Give a man a fish and you feed him for a day. Teach a man to fish and you
    feed him for a lifetime."– Chinese proverb'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia, **computer programming** is:'
  prefs: []
  type: TYPE_NORMAL
- en: '"...a process that leads from an original formulation of a computing problem
    to executable computer programs. Programming involves activities such as analysis,
    developing understanding, generating algorithms, verification of requirements
    of algorithms including their correctness and resources consumption, and implementation
    (commonly referred to as coding) of algorithms in a target programming language."'
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, coding is telling a computer to do something using a language
    it understands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers are very powerful tools, but unfortunately, they can''t think for
    themselves. They need to be told everything: how to perform a task, how to evaluate
    a condition to decide which path to follow, how to handle data that comes from
    a device, such as the network or a disk, and how to react when something unforeseen
    happens, say, something is broken or missing.'
  prefs: []
  type: TYPE_NORMAL
- en: You can code in many different styles and languages. Is it hard? I would say
    *yes* and *no*. It's a bit like writing. Everybody can learn how to write, and
    you can too. But, what if you wanted to become a poet? Then writing alone is not
    enough. You have to acquire a whole other set of skills and this will take a longer
    and greater effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it all comes down to how far you want to go down the road. Coding
    is not just putting together some instructions that work. It is so much more!
  prefs: []
  type: TYPE_NORMAL
- en: Good code is short, fast, elegant, easy to read and understand, simple, easy
    to modify and extend, easy to scale and refactor, and easy to test. It takes time
    to be able to write code that has all these qualities at the same time, but the
    good news is that you're taking the first step towards it at this very moment
    by reading this book. And I have no doubt you can do it. Anyone can; in fact,
    we all program all the time, only we aren't aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Would you like an example?
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to make instant coffee. You have to get a mug, the instant coffee
    jar, a teaspoon, water, and the kettle. Even if you're not aware of it, you're
    evaluating a lot of data. You're making sure that there is water in the kettle
    and that the kettle is plugged in, that the mug is clean, and that there is enough
    coffee in the jar. Then, you boil the water and maybe, in the meantime, you put
    some coffee in the mug. When the water is ready, you pour it into the cup, and
    stir.
  prefs: []
  type: TYPE_NORMAL
- en: So, how is this programming?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we gathered resources (the kettle, coffee, water, teaspoon, and mug) and
    we verified some conditions concerning them (the kettle is plugged in, the mug
    is clean, and there is enough coffee). Then we started two actions (boiling the
    water and putting coffee in the mug), and when both of them were completed, we
    finally ended the procedure by pouring water in to the mug and stirring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you see it? I have just described the high-level functionality of a coffee
    program. It wasn''t that hard because this is what the brain does all day long:
    evaluate conditions, decide to take actions, carry out tasks, repeat some of them,
    and stop at some point. Clean objects, put them back, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: All you need now is to learn how to deconstruct all those actions you do automatically
    in real life so that a computer can actually make some sense of them. And you
    need to learn a language as well, to instruct it.
  prefs: []
  type: TYPE_NORMAL
- en: So this is what this book is for. I'll tell you how to do it and I'll try to
    do that by means of many simple but focused examples (my favorite kind).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python's characteristics and ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines on how to get up and running with Python and virtual environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run Python programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize Python code and Python's execution model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proper introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I love to make references to the real world when I teach coding; I believe they
    help people retain the concepts better. However, now is the time to be a bit more
    rigorous and see what coding is from a more technical perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write code, we''re instructing a computer about the things it has to
    do. Where does the action happen? In many places: the computer memory, hard drives,
    network cables, the CPU, and so on. It''s a whole *world*, which most of the time
    is the representation of a subset of the real world.'
  prefs: []
  type: TYPE_NORMAL
- en: If you write a piece of software that allows people to buy clothes online, you
    will have to represent real people, real clothes, real brands, sizes, and so on
    and so forth, within the boundaries of a program.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, you will need to create and handle objects in the program
    you're writing. A person can be an object. A car is an object. A pair of socks
    is an object. Luckily, Python understands objects very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main features any object has are properties and methods. Let''s take
    a person object as an example. Typically in a computer program, you''ll represent
    people as customers or employees. The properties that you store against them are
    things like the name, the SSN, the age, if they have a driving license, their
    email, gender, and so on. In a computer program, you store all the data you need
    in order to use an object for the purpose you''re serving. If you are coding a
    website to sell clothes, you probably want to store the heights and weights as
    well as other measures of your customers so that you can suggest the appropriate
    clothes for them. So, properties are characteristics of an object. We use them
    all the time: *Could you pass me that pen?*—*Which one?*—*The black one*. Here,
    we used the *black* property of a pen to identify it (most likely among a blue
    and a red one).'
  prefs: []
  type: TYPE_NORMAL
- en: Methods are things that an object can do. As a person, I have methods such as
    *speak*, *walk*, *sleep*, *wake up*, *eat*, *dream*, *write*, *read*, and so on.
    All the things that I can do could be seen as methods of the objects that represent
    me.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that you know what objects are and that they expose methods that you
    can run and properties that you can inspect, you're ready to start coding. Coding
    in fact is simply about managing those objects that live in the subset of the
    world that we're reproducing in our software. You can create, use, reuse, and
    delete objects as you please.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the *Data Model* chapter on the official Python documentation
    ([https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Objects are Python''s abstraction for data. All data in a Python program is
    represented by objects or by relations between objects."'
  prefs: []
  type: TYPE_NORMAL
- en: We'll take a closer look at Python objects in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*. For now, all we need to know is that every object
    in Python has an ID (or identity), a type, and a value.
  prefs: []
  type: TYPE_NORMAL
- en: Once created, the ID of an object is never changed. It's a unique identifier
    for it, and it's used behind the scenes by Python to retrieve the object when
    we want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The type, as well, never changes. The type tells what operations are supported
    by the object and the possible values that can be assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see Python's most important data types in [Chapter 2](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Built-in Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: The value can either change or not. If it can, the object is said to be **mutable**,
    while when it cannot, the object is said to be **immutable**.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use an object? We give it a name, of course! When you give an object
    a name, then you can use the name to retrieve the object and use it.
  prefs: []
  type: TYPE_NORMAL
- en: In a more generic sense, objects such as numbers, strings (text), collections,
    and so on are associated with a name. Usually, we say that this name is the name
    of a variable. You can see the variable as being like a box, which you can use
    to hold data.
  prefs: []
  type: TYPE_NORMAL
- en: So, you have all the objects you need; what now? Well, we need to use them,
    right? We may want to send them over a network connection or store them in a database.
    Maybe display them on a web page or write them into a file. In order to do so,
    we need to react to a user filling in a form, or pressing a button, or opening
    a web page and performing a search. We react by running our code, evaluating conditions
    to choose which parts to execute, how many times, and under which circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: And to do all this, basically we need a language. That's what Python is for.
    Python is the language we'll use together throughout this book to instruct the
    computer to do something for us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, enough of this theoretical stuff; let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is the marvelous creation of Guido Van Rossum, a Dutch computer scientist
    and mathematician who decided to gift the world with a project he was playing
    around with over Christmas 1989\. The language appeared to the public somewhere
    around 1991, and since then has evolved to be one of the leading programming languages
    used worldwide today.
  prefs: []
  type: TYPE_NORMAL
- en: I started programming when I was 7 years old, on a Commodore VIC-20, which was
    later replaced by its bigger brother, the Commodore 64\. Its language was *BASIC*.
    Later on, I landed on Pascal, Assembly, C, C++, Java, JavaScript, Visual Basic,
    PHP, ASP, ASP .NET, C#, and other minor languages I cannot even remember, but
    only when I landed on Python did I finally have that feeling that you have when
    you find the right couch in the shop. When all of your body parts are yelling,
    *Buy this one! This one is perfect for us!*
  prefs: []
  type: TYPE_NORMAL
- en: It took me about a day to get used to it. Its syntax is a bit different from
    what I was used to, but after getting past that initial feeling of discomfort
    (like having new shoes), I just fell in love with it. Deeply. Let's see why.
  prefs: []
  type: TYPE_NORMAL
- en: About Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the gory details, let's get a sense of why someone would
    want to use Python (I would recommend you to read the Python page on Wikipedia
    to get a more detailed introduction).
  prefs: []
  type: TYPE_NORMAL
- en: To my mind, Python epitomizes the following qualities.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python runs everywhere, and porting a program from Linux to Windows or Mac is
    usually just a matter of fixing paths and settings. Python is designed for portability
    and it takes care of specific **operating system** (**OS**) quirks behind interfaces
    that shield you from the pain of having to write code tailored to a specific platform.
  prefs: []
  type: TYPE_NORMAL
- en: Coherence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is extremely logical and coherent. You can see it was designed by a brilliant
    computer scientist. Most of the time, you can just guess how a method is called,
    if you don't know it.
  prefs: []
  type: TYPE_NORMAL
- en: You may not realize how important this is right now, especially if you are at
    the beginning, but this is a major feature. It means less cluttering in your head,
    as well as less skimming through the documentation, and less need for mappings
    in your brain when you code.
  prefs: []
  type: TYPE_NORMAL
- en: Developer productivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Mark Lutz (*Learning Python, 5th Edition*, *O'Reilly Media*), a
    Python program is typically one-fifth to one-third the size of equivalent Java
    or C++ code. This means the job gets done faster. And faster is good. Faster means
    a faster response on the market. Less code not only means less code to write,
    but also less code to read (and professional coders read much more than they write),
    less code to maintain, to debug, and to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect is that Python runs without the need for lengthy and
    time-consuming compilation and linkage steps, so you don't have to wait to see
    the results of your work.
  prefs: []
  type: TYPE_NORMAL
- en: An extensive library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has an incredibly wide standard library (it's said to come with *batteries
    included*). If that wasn't enough, the Python community all over the world maintains
    a body of third-party libraries, tailored to specific needs, which you can access
    freely at the **Python Package Index** (**PyPI**). When you code Python and you
    realize that you need a certain feature, in most cases, there is at least one
    library where that feature has already been implemented for you.
  prefs: []
  type: TYPE_NORMAL
- en: Software quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is heavily focused on readability, coherence, and quality. The language
    uniformity allows for high readability and this is crucial nowadays where coding
    is more of a collective effort than a solo endeavor. Another important aspect
    of Python is its intrinsic multiparadigm nature. You can use it as a scripting
    language, but you also can exploit object-oriented, imperative, and functional
    programming styles. It is versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Software integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important aspect is that Python can be extended and integrated with
    many other languages, which means that even when a company is using a different
    language as their mainstream tool, Python can come in and act as a glue agent
    between complex applications that need to talk to each other in some way. This
    is kind of an advanced topic, but in the real world, this feature is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Satisfaction and enjoyment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last, but not least, there is the fun of it! Working with Python is fun. I can
    code for 8 hours and leave the office happy and satisfied, alien to the struggle
    other coders have to endure because they use languages that don't provide them
    with the same amount of well-designed data structures and constructs. Python makes
    coding fun, no doubt about it. And fun promotes motivation and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: These are the major aspects of why I would recommend Python to everyone. Of
    course, there are many other technical and advanced features that I could have
    talked about, but they don't really pertain to an introductory section like this
    one. They will come up naturally, chapter after chapter, in this book.
  prefs: []
  type: TYPE_NORMAL
- en: What are the drawbacks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably, the only drawback that one could find in Python, which is not due
    to personal preferences, is its *execution speed*. Typically, Python is slower
    than its compiled brothers. The standard implementation of Python produces, when
    you run an application, a compiled version of the source code called byte code
    (with the extension `.pyc`), which is then run by the Python interpreter. The
    advantage of this approach is portability, which we pay for with a slowdown due
    to the fact that Python is not compiled down to machine level as are other languages.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python speed is rarely a problem today, hence its wide use regardless
    of this suboptimal feature. What happens is that, in real life, hardware cost
    is no longer a problem, and usually it's easy enough to gain speed by parallelizing
    tasks. Moreover, many programs spend a great proportion of the time waiting for
    IO operations to complete; therefore, the raw execution speed is often a secondary
    factor to the overall performance. When it comes to number crunching though, one
    can switch to faster Python implementations, such as PyPy, which provides an average
    five-fold speedup by implementing advanced compilation techniques (check [http://pypy.org/](http://pypy.org/)
    for reference).
  prefs: []
  type: TYPE_NORMAL
- en: When doing data science, you'll most likely find that the libraries that you
    use with Python, such as **Pandas** and **NumPy**, achieve native speed due to
    the way they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: If that wasn't a good-enough argument, you can always consider that Python has
    been used to drive the backend of services such as Spotify and Instagram, where
    performance is a concern. Nonetheless, Python has done its job perfectly adequately.
  prefs: []
  type: TYPE_NORMAL
- en: Who is using Python today?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not yet convinced? Let''s take a very brief look at the companies that are
    using Python today: Google, YouTube, Dropbox, Yahoo!, Zope Corporation, Industrial
    Light & Magic, Walt Disney Feature Animation, Blender 3D, Pixar, NASA, the NSA,
    Red Hat, Nokia, IBM, Netflix, Yelp, Intel, Cisco, HP, Qualcomm, and JPMorgan Chase,
    to name just a few.'
  prefs: []
  type: TYPE_NORMAL
- en: Even games such as *Battlefield 2*, *Civilization IV*, and *QuArK* are implemented
    using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python is used in many different contexts, such as system programming, web programming,
    GUI applications, gaming and robotics, rapid prototyping, system integration,
    data science, database applications, and much more. Several prestigious universities
    have also adopted Python as their main language in computer science courses.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about installing Python on your system, let me tell you about
    which Python version I'll be using in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Python 2 versus Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes in two main versions: Python 2, which is the past, and Python
    3, which is the present. The two versions, though very similar, are incompatible
    in some respects.'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, Python 2 is actually quite far from being the past. In short,
    even though Python 3 has been out since 2008, the transition phase from Version
    2 is still far from being over. This is mostly due to the fact that Python 2 is
    widely used in the industry, and of course, companies aren't so keen on updating
    their systems just for the sake of updating them, following the *if it ain't broke,
    don't fix it* philosophy. You can read all about the transition between the two
    versions on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue that has hindered the transition is the availability of third-party
    libraries. Usually, a Python project relies on tens of external libraries, and
    of course, when you start a new project, you need to be sure that there is already
    a Version-3-compatible library for any business requirement that may come up.
    If that's not the case, starting a brand-new project in Python 3 means introducing
    a potential risk, which many companies are not happy to take.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, though, the majority of the most widely used libraries
    have been ported to Python 3, and it's quite safe to start a project in Python
    3 for most cases. Many of the libraries have been rewritten so that they are compatible
    with both versions, mostly harnessing the power of the `six` library (the name
    comes from the multiplication 2 x 3, due to the porting from Version 2 to 3),
    which helps introspecting and adapting the behavior according to the version used.
    According to PEP 373 ([https://legacy.python.org/dev/peps/pep-0373/](https://legacy.python.org/dev/peps/pep-0373/)),
    the **end of life** (**EOL**) of Python 2.7 has been set to 2020, and there won't
    be a Python 2.8, so this is the time when companies that have projects running
    in Python 2 need to start devising an upgrade strategy to move to Python 3 before
    it's too late.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my box (MacBook Pro), this is the latest Python version I have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So you can see that the version is an alpha release of Python 3.7, which will
    be released in June 2018\. The preceding text is a little bit of Python code that
    I typed into my console. We'll talk about it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this book will be run using Python 3.7\. Even though at
    the moment the final version might still be slightly different than what I have,
    I will make sure that all the code and examples are up to date with 3.7 by the
    time the book is published.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the code can also run in Python 2.7, either as it is or with minor tweaks,
    but at this point in time, I think it's better to learn Python 3, and then, if
    you need to, learn the differences it has with Python 2, rather than going the
    other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about this version thing though; it's not that big an issue in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I never really got the point of having a *setup* section in a book, regardless
    of what it is that you have to set up. Most of the time, between the time the
    author writes the instructions and the time you actually try them out, months
    have passed. That is, if you're lucky. One version change and things may not work
    in the way that is described in the book. Luckily, we have the web now, so in
    order to help you get up and running, I'll just give you pointers and objectives.
  prefs: []
  type: TYPE_NORMAL
- en: I am conscious that the majority of readers would probably have preferred to
    have guidelines in the book. I doubt it would have made their life much easier,
    as I strongly believe that if you want to get started with Python you have to
    put in that initial effort in order to get familiar with the ecosystem. It is
    very important, and it will boost your confidence to face the material in the
    chapters ahead. If you get stuck, remember that Google is your friend.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's talk about your OS. Python is fully integrated and most
    likely already installed in basically almost every Linux distribution. If you
    have a macOS, it's likely that Python is already there as well (however, possibly
    only Python 2.7), whereas if you're using Windows, you probably need to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Python and the libraries you need up and running requires a bit of handiwork.
    Linux and macOS seem to be the most user-friendly OSes for Python programmers;
    Windows, on the other hand, is the one that requires the biggest effort.
  prefs: []
  type: TYPE_NORMAL
- en: My current system is a MacBook Pro, and this is what I will use throughout the
    book, along with Python 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The place you want to start is the official Python website: [https://www.python.org](https://www.python.org).
    This website hosts the official Python documentation and many other resources
    that you will find very useful. Take the time to explore it.'
  prefs: []
  type: TYPE_NORMAL
- en: Another excellent, resourceful website on Python and its ecosystem is [http://docs.python-guide.org](http://docs.python-guide.org).
    You can find instructions to set up Python on different operating systems, using
    different methods.
  prefs: []
  type: TYPE_NORMAL
- en: Find the download section and choose the installer for your OS. If you are on
    Windows, make sure that when you run the installer, you check the option `install
    pip` (actually, I would suggest to make a complete installation, just to be safe,
    of all the components the installer holds). We'll talk about `pip` later.
  prefs: []
  type: TYPE_NORMAL
- en: Now that Python is installed in your system, the objective is to be able to
    open a console and run the Python interactive shell by typing `python`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that I usually refer to the **Python interactive shell** simply
    as the **Python console**.
  prefs: []
  type: TYPE_NORMAL
- en: To open the console in Windows, go to the Start menu, choose Run, and type `cmd`.
    If you encounter anything that looks like a permission problem while working on
    the examples in this book, please make sure you are running the console with administrator
    rights.
  prefs: []
  type: TYPE_NORMAL
- en: On the macOS X, you can start a Terminal by going to Applications | Utilities
    | Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Linux, you know all that there is to know about the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will use the term *console* interchangeably to indicate the Linux console,
    the Windows Command Prompt, and the Macintosh Terminal. I will also indicate the
    command-line prompt with the Linux default format, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you're not familiar with that, please take some time to learn the basics
    on how a console works. In a nutshell, after the `$` sign, you normally find an
    instruction that you have to type. Pay attention to capitalization and spaces,
    as they are very important.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever console you open, type `python` at the prompt, and make sure the Python
    interactive shell shows up. Type `exit()` to quit. Keep in mind that you may have
    to specify `python3` if your OS comes with Python 2.* preinstalled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is roughly what you should see when you run Python (it will change in
    some details according to the version and OS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Python is set up and you can run it, it''s time to make sure you have
    the other tool that will be indispensable to follow the examples in the book:
    virtualenv.'
  prefs: []
  type: TYPE_NORMAL
- en: About virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably have guessed by its name, **virtualenv **is all about virtual
    environments. Let me explain what they are and why we need them and let me do
    it by means of a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: You install Python on your system and you start working on a website for Client
    X. You create a project folder and start coding. Along the way, you also install
    some libraries; for example, the Django framework, which we'll see in depth in
    [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe), *Web Development*.
    Let's say the Django version you install for Project X is 1.7.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your website is so good that you get another client, Y. She wants you
    to build another website, so you start Project Y and, along the way, you need
    to install Django again. The only issue is that now the Django version is 1.8
    and you cannot install it on your system because this would replace the version
    you installed for Project X. You don''t want to risk introducing incompatibility
    issues, so you have two choices: either you stick with the version you have currently
    on your machine, or you upgrade it and make sure the first project is still fully
    working correctly with the new version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be honest, neither of these options is very appealing, right? Definitely
    not. So, here''s the solution: virtualenv!'
  prefs: []
  type: TYPE_NORMAL
- en: virtualenv is a tool that allows you to create a virtual environment. In other
    words, it is a tool to create isolated Python environments, each of which is a
    folder that contains all the necessary executables to use the packages that a
    Python project would need (think of packages as libraries for the time being).
  prefs: []
  type: TYPE_NORMAL
- en: So you create a virtual environment for Project X, install all the dependencies,
    and then you create a virtual environment for Project Y, installing all its dependencies
    without the slightest worry because every library you install ends up within the
    boundaries of the appropriate virtual environment. In our example, Project X will
    hold Django 1.7.1, while Project Y will hold Django 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is of vital importance that you never install libraries directly at the
    system level. Linux, for example, relies on Python for many different tasks and
    operations, and if you fiddle with the system installation of Python, you risk
    compromising the integrity of the whole system (guess to whom this happened...).
    So take this as a rule, such as brushing your teeth before going to bed: *always,
    always create a virtual environment when you start a new project*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install virtualenv on your system, there are a few different ways. On a
    Debian-based distribution of Linux, for example, you can install it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Probably, the easiest way is to follow the instructions you can find on the
    virtualenv official website: [https://virtualenv.pypa.io](https://virtualenv.pypa.io).
  prefs: []
  type: TYPE_NORMAL
- en: You will find that one of the most common ways to install virtualenv is by using `pip`,
    a package management system used to install and manage software packages written
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.5, the suggested way to create a virtual environment is to use
    the `venv` module. Please see the [official documentation](https://docs.python.org/3.7/library/venv.html)
    for further information. However, at the time of writing, virtualenv is still
    by far the tool most used for creating virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: Your first virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very easy to create a virtual environment, but according to how your system
    is configured and which Python version you want the virtual environment to run,
    you need to run the command properly. Another thing you will need to do with virtualenv,
    when you want to work with it, is to activate it. Activating virtualenv basically
    produces some path juggling behind the scenes so that when you call the Python
    interpreter, you're actually calling the active virtual environment one, instead
    of the mere system one.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll show you a full example on my Macintosh console. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `learn.pp` under your project root (which in my case is
    a folder called `srv`, in my home folder). Please adapt the paths according to
    the setup you fancy on your box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `learn.pp` folder, we will create a virtual environment called `learnpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some developers prefer to call all virtual environments using the same name
    (for example, `.venv`). This way they can run scripts against any virtualenv by
    just knowing the name of the project they dwell in. The dot in `.venv` is there
    because in Linux/macOS prepending a name with a dot makes that file or folder
    invisible.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the virtual environment, we will activate it. The methods are
    slightly different between Linux, macOS, and Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll make sure that we are running the desired Python version (3.7.*)
    by running the Python interactive shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will deactivate the virtual environment using the `deactivate` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These five simple steps will show you all you have to do to start and use a
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how those steps might look (note that you might get a
    slightly different result, according to your OS, Python version, and so on) on
    the macOS (commands that start with a `#` are comments, spaces have been introduced
    for readability, and `⇢` indicates where the line has wrapped around due to lack
    of space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I had to tell virtualenv explicitly to use the Python 3.7 interpreter
    because on my box Python 2.7 is the default one. Had I not done that, I would
    have had a virtual environment with Python 2.7 instead of Python 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine the two instructions for step 2 in one single command like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I chose to be explicitly verbose in this instance, to help you understand each
    bit of the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to notice is that in order to activate a virtual environment,
    we need to run the `/bin/activate` script, which needs to be sourced. When a script
    is **sourced**, it means that it is executed in the current shell, and therefore
    its effects last after the execution. This is very important. Also notice how
    the prompt changes after we activate the virtual environment, showing its name
    on the left (and how it disappears when we deactivate it). On Linux, the steps
    are the same so I won't repeat them here. On Windows, things change slightly,
    but the concepts are the same. Please refer to the official virtualenv website
    for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be able to create and activate a virtual environment.
    Please try and create another one without me guiding you. Get acquainted with
    this procedure because it''s something that you will always be doing: **we never
    work system-wide with Python**, remember? It''s extremely important.'
  prefs: []
  type: TYPE_NORMAL
- en: So, with the scaffolding out of the way, we're ready to talk a bit more about
    Python and how you can use it. Before we do that though, allow me to speak a few
    words about the console.
  prefs: []
  type: TYPE_NORMAL
- en: Your friend, the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this era of GUIs and touchscreen devices, it seems a little ridiculous to
    have to resort to a tool such as the console, when everything is just about one
    click away.
  prefs: []
  type: TYPE_NORMAL
- en: But the truth is every time you remove your right hand from the keyboard (or
    the left one, if you're a lefty) to grab your mouse and move the cursor over to
    the spot you want to click on, you're losing time. Getting things done with the
    console, counter-intuitive as it may be, results in higher productivity and speed.
    I know, you have to trust me on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speed and productivity are important and, personally, I have nothing against
    the mouse, but there is another very good reason for which you may want to get
    well-acquainted with the console: when you develop code that ends up on some server,
    the console might be the only available tool. If you make friends with it, I promise
    you, you will never get lost when it''s of utmost importance that you don''t (typically,
    when the website is down and you have to investigate very quickly what''s going
    on).'
  prefs: []
  type: TYPE_NORMAL
- en: So it's really up to you. If you're undecided, please grant me the benefit of
    the doubt and give it a try. It's easier than you think, and you'll never regret
    it. There is nothing more pitiful than a good developer who gets lost within an
    SSH connection to a server because they are used to their own custom set of tools,
    and only to that.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get back to Python.
  prefs: []
  type: TYPE_NORMAL
- en: How you can run a Python program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways in which you can run a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python can be used as a scripting language. In fact, it always proves itself
    very useful. Scripts are files (usually of small dimensions) that you normally
    execute to do something like a task. Many developers end up having their own arsenal
    of tools that they fire when they need to perform a task. For example, you can
    have scripts to parse data in a format and render it into another different format.
    Or you can use a script to work with files and folders. You can create or modify
    configuration files, and much more. Technically, there is not much that cannot
    be done in a script.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite common to have scripts running at a precise time on a server. For
    example, if your website database needs cleaning every 24 hours (for example,
    the table that stores the user sessions, which expire pretty quickly but aren't
    cleaned automatically), you could set up a Cron job that fires your script at
    3:00 A.M. every day.
  prefs: []
  type: TYPE_NORMAL
- en: According to Wikipedia, the software utility Cron is a time-based job scheduler
    in Unix-like computer operating systems. People who set up and maintain software
    environments use Cron to schedule jobs (commands or shell scripts) to run periodically
    at fixed times, dates, or intervals.
  prefs: []
  type: TYPE_NORMAL
- en: I have Python scripts to do all the menial tasks that would take me minutes
    or more to do manually, and at some point, I decided to automate. We'll devote
    half of [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe), *GUIs
    and Scripts,* on scripting with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Python interactive shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of running Python is by calling the interactive shell. This is something
    we already saw when we typed `python` on the command line of our console.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open a console, activate your virtual environment (which by now should
    be second nature to you, right?), and type `python`. You will be presented with
    a couple of lines that should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Those `>>>` are the prompt of the shell. They tell you that Python is waiting
    for you to type something. If you type a simple instruction, something that fits
    in one line, that's all you'll see. However, if you type something that requires
    more than one line of code, the shell will change the prompt to `...`, giving
    you a visual clue that you're typing a multiline statement (or anything that would
    require more than one line of code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go on, try it out; let''s do some basic math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The last operation is showing you something incredible. We raise `2` to the
    power of `1024`, and Python is handling this task with no trouble at all. Try
    to do it in Java, C++, or C#. It won't work, unless you use special libraries
    to handle such big numbers.
  prefs: []
  type: TYPE_NORMAL
- en: I use the interactive shell every day. It's extremely useful to debug very quickly,
    for example, to check if a data structure supports an operation. Or maybe to inspect
    or run a piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: When you use Django (a web framework), the interactive shell is coupled with
    it and allows you to work your way through the framework tools, to inspect the
    data in the database, and many more things. You will find that the interactive
    shell will soon become one of your dearest friends on the journey you are embarking
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution, which comes in a much nicer graphic layout, is to use **Integrated
    DeveLopment Environment** (**IDLE**). It's quite a simple IDE, which is intended
    mostly for beginners. It has a slightly larger set of capabilities than the naked
    interactive shell you get in the console, so you may want to explore it. It comes
    for free in the Windows Python installer and you can easily install it in any
    other system. You can find information about it on the Python website.
  prefs: []
  type: TYPE_NORMAL
- en: Guido Van Rossum named Python after the British comedy group, Monty Python,
    so it's rumored that the name IDLE has been chosen in honor of Eric Idle, one
    of Monty Python's founding members.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from being run as a script, and within the boundaries of a shell, Python
    can be coded and run as an application. We'll see many examples throughout the
    book about this mode. And we'll understand more about it in a moment, when we'll
    talk about how Python code is organized and run.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python as a GUI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python can also be run as a **graphical user interface** (**GUI**). There are
    several frameworks available, some of which are cross-platform and some others
    are platform-specific. In [Chapter 12](part0305.html#92RRI0-2ddb708647cc4530a187c2c6c0e9acfe),
    *GUIs and Scripts*, we'll see an example of a GUI application created using Tkinter,
    which is an object-oriented layer that lives on top of **Tk** (Tkinter means Tk
    interface).
  prefs: []
  type: TYPE_NORMAL
- en: Tk is a GUI toolkit that takes desktop application development to a higher level
    than the conventional approach. It is the standard GUI for **Tool Command Language** (**Tcl**),
    but also for many other dynamic languages, and it can produce rich native applications
    that run seamlessly under Windows, Linux, macOS X, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter comes bundled with Python; therefore, it gives the programmer easy access
    to the GUI world, and for these reasons, I have chosen it to be the framework
    for the GUI examples that I'll present in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the other GUI frameworks, we find that the following are the most widely
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyGTK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Describing them in detail is outside the scope of this book, but you can find
    all the information you need on the Python website ([https://docs.python.org/3/faq/gui.html](https://docs.python.org/3/faq/gui.html))
    in the *What platform-independent GUI toolkits exist for Python?* section. If
    GUIs are what you''re looking for, remember to choose the one you want according
    to some principles. Make sure they:'
  prefs: []
  type: TYPE_NORMAL
- en: Offer all the features you may need to develop your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run on all the platforms you may need to support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rely on a community that is as wide and active as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap graphic drivers/tools that you can easily install/access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is Python code organized?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk a little bit about how Python code is organized. In this section,
    we'll start going down the rabbit hole a little bit more and introduce more technical
    names and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the basics, how is Python code organized? Of course, you write
    your code into files. When you save a file with the extension `.py`, that file
    is said to be a Python module.
  prefs: []
  type: TYPE_NORMAL
- en: If you're on Windows or macOS that typically hide file extensions from the user,
    please make sure you change the configuration so that you can see the complete
    names of the files. This is not strictly a requirement, but a suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: It would be impractical to save all the code that it is required for software
    to work within one single file. That solution works for scripts, which are usually
    not longer than a few hundred lines (and often they are quite shorter than that).
  prefs: []
  type: TYPE_NORMAL
- en: A complete Python application can be made of hundreds of thousands of lines
    of code, so you will have to scatter it through different modules, which is better,
    but not nearly good enough. It turns out that even like this, it would still be
    impractical to work with the code. So Python gives you another structure, called **package**,
    which allows you to group modules together. A package is nothing more than a folder,
    which must contain a special file, `__init__.py`, that doesn't need to hold any
    code but whose presence is required to tell Python that the folder is not just
    some folder, but it's actually a package (note that as of Python 3.3, the `__init__.py` module
    is not strictly required any more).
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, an example will make all of this much clearer. I have created an
    example structure in my book project, and when I type in my console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I get a tree representation of the contents of the `ch1/example` folder, which
    holds the code for the examples of this chapter. Here''s what the structure of
    a really simple application could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that within the root of this example, we have two modules, `core.py`
    and `run.py`, and one package: `util`. Within `core.py`, there may be the core
    logic of our application. On the other hand, within the `run.py` module, we can
    probably find the logic to start the application. Within the `util` package, I
    expect to find various utility tools, and in fact, we can guess that the modules
    there are named based on the types of tools they hold: `db.py` would hold tools
    to work with databases, `math.py` would, of course, hold mathematical tools (maybe
    our application deals with financial data), and `network.py` would probably hold
    tools to send/receive data on networks.'
  prefs: []
  type: TYPE_NORMAL
- en: As explained before, the `__init__.py` file is there just to tell Python that
    `util` is a package and not just a mere folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Had this software been organized within modules only, it would have been harder
    to infer its structure. I put a *module only* example under the `ch1/files_only`
    folder; see it for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us a completely different picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is a little harder to guess what each module does, right? Now, consider that
    this is just a simple example, so you can guess how much harder it would be to
    understand a real application if we couldn't organize the code in packages and
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use modules and packages?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a developer is writing an application, it is likely that they will need
    to apply the same piece of logic in different parts of it. For example, when writing
    a parser for the data that comes from a form that a user can fill in a web page,
    the application will have to validate whether a certain field is holding a number
    or not. Regardless of how the logic for this kind of validation is written, it's
    likely that it will be needed in more than one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a poll application, where the user is asked many questions,
    it''s likely that several of them will require a numeric answer. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: What is your age?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many pets do you own?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many children do you have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many times have you been married?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be very bad practice to copy/paste (or, more properly said: duplicate)
    the validation logic in every place where we expect a numeric answer. This would
    violate the **don''t repeat yourself** (**DRY**) principle, which states that
    you should never repeat the same piece of code more than once in your application.
    I feel the need to stress the importance of this principle: *you should never
    repeat the same piece of code more than once in your application* (pun intended).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons why repeating the same piece of logic can be very
    bad, the most important ones being:'
  prefs: []
  type: TYPE_NORMAL
- en: There could be a bug in the logic, and therefore, you would have to correct
    it in every place that the logic is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to amend the way you carry out the validation, and again you would
    have to change it in every place it is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may forget to fix/amend a piece of logic because you missed it when searching
    for all its occurrences. This would leave wrong/inconsistent behavior in your
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code would be longer than needed, for no good reason.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is a wonderful language and provides you with all the tools you need
    to apply all the coding best practices. For this particular example, we need to
    be able to reuse a piece of code. To be able to reuse a piece of code, we need
    to have a construct that will hold the code for us so that we can call that construct
    every time we need to repeat the logic inside it. That construct exists, and it's
    called a **function**.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going too deep into the specifics here, so please just remember that
    a function is a block of organized, reusable code that is used to perform a task.
    Functions can assume many forms and names, according to what kind of environment
    they belong to, but for now this is not important. We'll see the details when
    we are able to appreciate them, later on, in the book. Functions are the building
    blocks of modularity in your application, and they are almost indispensable. Unless
    you're writing a super-simple script, you'll use functions all the time. We'll
    explore functions in [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Functions, the Building Blocks of Code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python comes with a very extensive library, as I have already said a few pages
    ago. Now, maybe it''s a good time to define what a library is: a **library** is
    a collection of functions and objects that provide functionalities that enrich
    the abilities of a language.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, within Python's `math` library, we can find a plethora of functions,
    one of which is the `factorial` function, which of course calculates the factorial
    of a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, the **factorial** of a non-negative integer number *N*, denoted
    as *N!*, is defined as the product of all positive integers less than or equal
    to *N*. For example, the factorial of `5` is calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`5! = 5 * 4 * 3 * 2 * 1 = 120`'
  prefs: []
  type: TYPE_NORMAL
- en: The factorial of `0` is `0! = 1`, to respect the convention for an empty product.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you wanted to use this function in your code, all you would have to do
    is to import it and call it with the right input values. Don't worry too much
    if input values and the concept of calling is not very clear for now; please just
    concentrate on the import part. We use a library by importing what we need from
    it, and then we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, to calculate the factorial of number `5`, we just need the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever we type in the shell, if it has a printable representation, will be
    printed on the console for us (in this case, the result of the function call:
    `120`).'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go back to our example, the one with `core.py`, `run.py`, `util`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the package `util` is our utility library. Our custom utility
    belt that holds all those reusable tools (that is, functions), which we need in
    our application. Some of them will deal with databases (`db.py`), some with the
    network (`network.py`), and some will perform mathematical calculations (`math.py`)
    that are outside the scope of Python's standard `math` library and, therefore,
    we have to code them for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see in detail how to import functions and use them in their dedicated
    chapter. Let''s now talk about another very important concept: *Python''s execution
    model*.'
  prefs: []
  type: TYPE_NORMAL
- en: Python's execution model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I would like to introduce you to a few very important concepts,
    such as scope, names, and namespaces. You can read all about Python's execution
    model in the official language reference, of course, but I would argue that it
    is quite technical and abstract, so let me give you a less formal explanation
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Names and namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say you are looking for a book, so you go to the library and ask someone for
    the book you want to fetch. They tell you something like *Second Floor, Section
    X, Row Three*. So you go up the stairs, look for Section X, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It would be very different to enter a library where all the books are piled
    together in random order in one big room. No floors, no sections, no rows, no
    order. Fetching a book would be extremely hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write code, we have the same issue: we have to try and organize it
    so that it will be easy for someone who has no prior knowledge about it to find
    what they''re looking for. When software is structured correctly, it also promotes
    code reuse. On the other hand, disorganized software is more likely to expose
    scattered pieces of duplicated logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s start with the book. We refer to a book by its title and
    in Python lingo, that would be a name. Python names are the closest abstraction
    to what other languages call variables. Names basically refer to objects and are
    introduced by name-binding operations. Let''s make a quick example (notice that
    anything that follows a `#` is a comment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined three objects in the preceding code (do you remember what are the
    three features every Python object has?):'
  prefs: []
  type: TYPE_NORMAL
- en: 'An integer number `n` (type: `int`, value: `3`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A string `address` (type: `str`, value: Sherlock Holmes'' address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A dictionary `employee` (type: `dict`, value: a dictionary that holds three
    key/value pairs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry, I know you're not supposed to know what a dictionary is. We'll
    see in [Chapter 2](part0056.html#1LCVG0-2ddb708647cc4530a187c2c6c0e9acfe), *Built-in
    Data Types*, that it's the king of Python data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that the prompt changed from `>>>` to `...` when I typed in
    the definition of employee? That's because the definition spans over multiple
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are `n`, `address`, and `employee`? They are **names**. Names that
    we can use to retrieve data within our code. They need to be kept somewhere so
    that whenever we need to retrieve those objects, we can use their names to fetch
    them. We need some space to hold them, hence: namespaces!'
  prefs: []
  type: TYPE_NORMAL
- en: A **namespace** is therefore a mapping from names to objects. Examples are the
    set of built-in names (containing functions that are always accessible in any
    Python program), the global names in a module, and the local names in a function.
    Even the set of attributes of an object can be considered a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of namespaces is that they allow you to define and organize your
    names with clarity, without overlapping or interference. For example, the namespace
    associated with that book we were looking for in the library can be used to import
    the book itself, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We start from the `library` namespace, and by means of the dot (`.`) operator,
    we walk into that namespace. Within this namespace, we look for `second_floor`,
    and again we walk into it with the `.` operator. We then walk into `section_x`,
    and finally within the last namespace, `row_three`, we find the name we were looking
    for: `book`.'
  prefs: []
  type: TYPE_NORMAL
- en: Walking through a namespace will be clearer when we'll be dealing with real
    code examples. For now, just keep in mind that namespaces are places where names
    are associated with objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another concept, which is closely related to that of a namespace,
    which I''d like to briefly talk about: the **scope**.'
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Python''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '" *A scope is a textual region of a Python program, where a namespace is directly
    accessible*."'
  prefs: []
  type: TYPE_NORMAL
- en: Directly accessible means that when you're looking for an unqualified reference
    to a name, Python tries to find it in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scopes are determined statically, but actually, during runtime, they are used
    dynamically. This means that by inspecting the source code, you can tell what
    the scope of an object is, but this doesn''t prevent the software from altering
    that during runtime. There are four different scopes that Python makes accessible
    (not necessarily all of them are present at the same time, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: The **local** scope, which is the innermost one and contains the local names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **enclosing** scope, that is, the scope of any enclosing function. It contains
    non-local names and also non-global names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **global** scope contains the global names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **built-in** scope contains the built-in names. Python comes with a set
    of functions that you can use in an off-the-shelf fashion, such as `print`, `all`,
    `abs`, and so on. They live in the built-in scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rule is the following: when we refer to a name, Python starts looking for
    it in the current namespace. If the name is not found, Python continues the search
    to the enclosing scope and this continues until the built-in scope is searched.
    If a name hasn''t been found after searching the built-in scope, then Python raises
    a `NameError`** exception**, which basically means that the name hasn''t been
    defined (you saw this in the preceding example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which the namespaces are scanned when looking for a name is therefore:
    **local**, **enclosing**, **global**, **built-in** (**LEGB**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all very theoretical, so let''s see an example. In order to show you
    local and enclosing namespaces, I will have to define a few functions. Don''t
    worry if you are not familiar with their syntax for the moment. We''ll study functions
    in [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe), *Functions,
    the Building Blocks of Code*. Just remember that in the following code, when you
    see `def`, it means I''m defining a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define the same name `m`, both in the global scope
    and in the local one (the one defined by the `local` function). When we execute
    this program with the following command (have you activated your virtualenv?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see two numbers printed on the console: `5` and `7`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens is that the Python interpreter parses the file, top to bottom.
    First, it finds a couple of comment lines, which are skipped, then it parses the
    definition of the function `local`. When called, this function does two things:
    it sets up a name to an object representing number `7` and prints it. The Python
    interpreter keeps going and it finds another name binding. This time the binding
    happens in the global scope and the value is `5`. The next line is a call to the
    `print` function, which is executed (and so we get the first value printed on
    the console: `5`).'
  prefs: []
  type: TYPE_NORMAL
- en: After this, there is a call to the function `local`. At this point, Python executes
    the function, so at this time, the binding `m = 7` happens and it's printed.
  prefs: []
  type: TYPE_NORMAL
- en: One very important thing to notice is that the part of the code that belongs
    to the definition of the `local` function is indented by four spaces on the right.
    Python, in fact, defines scopes by indenting the code. You walk into a scope by
    indenting, and walk out of it by unindenting. Some coders use two spaces, others
    three, but the suggested number of spaces to use is four. It's a good measure
    to maximize readability. We'll talk more about all the conventions you should
    embrace when writing Python code later.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would happen if we removed that `m = 7` line? Remember the LEGB rule.
    Python would start looking for `m` in the local scope (function `local`), and,
    not finding it, it would go to the next enclosing scope. The next one, in this
    case, is the global one because there is no enclosing function wrapped around
    `local`. Therefore, we would see two numbers `5` printed on the console. Let''s
    actually see what the code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `scopes2.py` will print this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As expected, Python prints `m` the first time, then when the function `local`
    is called, `m` isn't found in its scope, so Python looks for it following the
    LEGB chain until `m` is found in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example with an extra layer, the enclosing scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `scopes3.py` will print on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `print` instruction from the function `local` is referring
    to `m` as before. `m` is still not defined within the function itself, so Python
    starts walking scopes following the LEGB order. This time `m` is found in the
    enclosing scope.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if this is still not perfectly clear for now. It will come to you
    as we go through the examples in the book. The *Classes* section of the Python
    tutorial ([https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html))
    has an interesting paragraph about scopes and namespaces. Make sure you read it
    at some point if you want a deeper understanding of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish off this chapter, I would like to talk a bit more about objects.
    After all, basically everything in Python is an object, so I think they deserve
    a bit more attention.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I introduced objects previously in the *A proper introduction* section
    of the chapter, I said that we use them to represent real-life objects. For example,
    we sell goods of any kind on the web nowadays and we need to be able to handle,
    store, and represent them properly. But objects are actually so much more than
    that. Most of what you will ever do, in Python, has to do with manipulating objects.
  prefs: []
  type: TYPE_NORMAL
- en: So, without going into too much detail (we'll do that in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*), I want to give you the *in a nutshell* kind
    of explanation about classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen that objects are Python''s abstraction for data. In fact,
    everything in Python is an object, infact numbers, strings (data structures that
    hold text), containers, collections, even functions. You can think of them as
    if they were boxes with at least three features: an ID (unique), a type, and a
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do they come to life? How do we create them? How do we write our own
    custom objects? The answer lies in one simple word: **classes**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects are, in fact, instances of classes. The beauty of Python is that classes
    are objects themselves, but let''s not go down this road. It leads to one of the
    most advanced concepts of this language: **metaclasses**. For now, the best way
    for you to get the difference between classes and objects is by means of an example.'
  prefs: []
  type: TYPE_NORMAL
- en: Say a friend tells you, *I bought a new bike!* You immediately understand what
    she's talking about. Have you seen the bike? No. Do you know what color it is?
    Nope. The brand? Nope. Do you know anything about it? Nope. But at the same time,
    you know everything you need in order to understand what your friend meant when
    she told you she bought a new bike. You know that a bike has two wheels attached
    to a frame, a saddle, pedals, handlebars, brakes, and so on. In other words, even
    if you haven't seen the bike itself, you know the concept of *bike*. An abstract
    set of features and characteristics that together form something called *bike*.
  prefs: []
  type: TYPE_NORMAL
- en: In computer programming, that is called a **class**. It's that simple. Classes
    are used to create objects. In fact, objects are said to be **instances of classes**.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we all know what a bike is; we know the class. But then I have
    my own bike, which is an instance of the bike class. And my bike is an object
    with its own characteristics and methods. You have your own bike. Same class,
    but different instance. Every bike ever created in the world is an instance of
    the bike class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. We will write a class that defines a bike and then we''ll
    create two bikes, one red and one blue. I''ll keep the code very simple, but don''t
    fret if you don''t understand everything about it; all you need to care about
    at this moment is to understand the difference between a class and an object (or
    instance of a class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I hope by now I don't need to tell you to run the file every time, right? The
    filename is indicated in the first line of the code block. Just run `$ python
    filename`, and you'll be fine. But remember to have your virtualenv activated!
  prefs: []
  type: TYPE_NORMAL
- en: So many interesting things to notice here. First things first; the definition
    of a class happens with the `class` statement. Whatever code comes after the `class`
    statement, and is indented, is called the body of the class. In our case, the
    last line that belongs to the class definition is the `print("Braking!")` one.
  prefs: []
  type: TYPE_NORMAL
- en: After having defined the class, we're ready to create instances. You can see
    that the class body hosts the definition of two methods. A method is basically
    (and simplistically) a function that belongs to a class.
  prefs: []
  type: TYPE_NORMAL
- en: The first method, `__init__`, is an **initializer**. It uses some Python magic
    to set up the objects with the values we pass when we create it.
  prefs: []
  type: TYPE_NORMAL
- en: Every method that has leading and trailing double underscores, in Python, is
    called a **magic method**. Magic methods are used by Python for a multitude of
    different purposes; hence it's never a good idea to name a custom method using
    two leading and trailing underscores. This naming convention is best left to Python.
  prefs: []
  type: TYPE_NORMAL
- en: The other method we defined, `brake`, is just an example of an additional method
    that we could call if we wanted to brake the bike. It contains just a `print`
    statement, of course; it's an example.
  prefs: []
  type: TYPE_NORMAL
- en: We created two bikes then. One has red color and a carbon fiber frame, and the
    other one has blue color and a steel frame. We pass those values upon creation.
    After creation, we print out the color property and frame type of the red bike,
    and the frame type of the blue one just as an example. We also call the `brake`
    method of the `red_bike`.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing to notice. You remember I told you that the set of attributes
    of an object is considered to be a namespace? I hope it's clearer what I meant
    now. You see that by getting to the `frame_type` property through different namespaces
    (`red_bike`, `blue_bike`), we obtain different values. No overlapping, no confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The dot (`.`) operator is of course the means we use to walk into a namespace,
    in the case of objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines on how to write good code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing good code is not as easy as it seems. As I already said before, good
    code exposes a long list of qualities that is quite hard to put together. Writing
    good code is, to some extent, an art. Regardless of where on the path you will
    be happy to settle, there is something that you can embrace which will make your
    code instantly better: **PEP 8**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Python''s development is conducted largely through the Python Enhancement
    Proposal (PEP) process. The PEP process is the primary mechanism for proposing
    major new features, for collecting community input on an issue, and for documenting
    the design decisions that have gone into Python."'
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 is perhaps the most famous of all PEPs. It lays out a simple but effective
    set of guidelines to define Python aesthetics so that we write beautiful Python
    code. If you take one suggestion out of this chapter, please let it be this: use
    it. Embrace it. You will thank me later.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding today is no longer a check-in/check-out business. Rather, it's more of
    a social effort. Several developers collaborate on a piece of code through tools
    such as Git and Mercurial, and the result is code that is fathered by many different
    hands.
  prefs: []
  type: TYPE_NORMAL
- en: Git and Mercurial are probably the distributed revision control systems that
    are most used today. They are essential tools designed to help teams of developers
    collaborate on the same software.
  prefs: []
  type: TYPE_NORMAL
- en: These days, more than ever, we need to have a consistent way of writing code,
    so that readability is maximized. When all developers of a company abide by PEP
    8, it's not uncommon for any of them landing on a piece of code to think they
    wrote it themselves. It actually happens to me all the time (I always forget the
    code I write).
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a tremendous advantage: when you read code that you could have written
    yourself, you read it easily. Without a convention, every coder would structure
    the code the way they like most, or simply the way they were taught or are used
    to, and this would mean having to interpret every line according to someone else''s
    style. It would mean having to lose much more time just trying to understand it.
    Thanks to PEP 8, we can avoid this. I''m such a fan of it that I won''t sign off
    a code review if the code doesn''t respect it. So, please take the time to study
    it; it''s very important.'
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this book, I will try to respect it as much as I can. Unfortunately,
    I don't have the luxury of 79 characters (which is the maximum line length suggested
    by PEP 8), and I will have to cut down on blank lines and other things, but I
    promise you I'll try to lay out my code so that it's as readable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The Python culture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has been adopted widely in all coding industries. It's used by many different
    companies for many different purposes, and it's also used in education (it's an
    excellent language for that purpose, because of its many qualities and the fact
    that it's easy to learn).
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons Python is so popular today is that the community around it
    is vast, vibrant, and full of brilliant people. Many events are organized all
    over the world, mostly either around Python or its main web framework, Django.
  prefs: []
  type: TYPE_NORMAL
- en: Python is open, and very often so are the minds of those who embrace it. Check
    out the community page on the Python website for more information and get involved!
  prefs: []
  type: TYPE_NORMAL
- en: There is another aspect to Python which revolves around the notion of being
    **Pythonic**. It has to do with the fact that Python allows you to use some idioms
    that aren't found elsewhere, at least not in the same form or as easy to use (I
    feel quite claustrophobic when I have to code in a language which is not Python
    now).
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, over the years, this concept of being Pythonic has emerged and, the
    way I understand it, is something along the lines of *doing things the way they
    are supposed to be done in Python.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand a little bit more about Python''s culture and about
    being Pythonic, I will show you the *Zen of Python*. A lovely Easter egg that
    is very popular. Open up a Python console and type `import this`. What follows
    is the result of this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two levels of reading here. One is to consider it as a set of guidelines
    that have been put down in a fun way. The other one is to keep it in mind, and
    maybe read it once in a while, trying to understand how it refers to something
    deeper: some Python characteristics that you will have to understand deeply in
    order to write Python the way it''s supposed to be written. Start with the fun
    level, and then dig deeper. Always dig deeper.'
  prefs: []
  type: TYPE_NORMAL
- en: A note on IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just a few words about IDEs. To follow the examples in this book, you don't
    need one; any text editor will do fine. If you want to have more advanced features,
    such as syntax coloring and auto completion, you will have to fetch yourself an
    IDE. You can find a comprehensive list of open source IDEs (just Google Python
    IDEs) on the Python website. I personally use Sublime Text editor. It's free to
    try out and it costs just a few dollars. I have tried many IDEs in my life, but
    this is the one that makes me most productive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two important pieces of advice:'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever IDE you choose to use, try to learn it well so that you can exploit
    its strengths, but *don't depend on it*. Exercise yourself to work with VIM (or
    any other text editor) once in a while; learn to be able to do some work on any
    platform, with any set of tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever text editor/IDE you use, when it comes to writing Python, *indentation
    is four spaces*. Don't use tabs, don't mix them with spaces. Use four spaces,
    not two, not three, not five. Just use four. The whole world works like that,
    and you don't want to become an outcast because you were fond of the three-space
    layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to explore the world of programming and that of
    Python. We've barely scratched the surface, just a little, touching concepts that
    will be discussed later on in the book in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about Python's main features, who is using it and for what, and what
    are the different ways in which we can write a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we flew over the fundamental notions of namespaces,
    scopes, classes, and objects. We also saw how Python code can be organized using
    modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: On a practical level, we learned how to install Python on our system, how to
    make sure we have the tools we need, `pip` and virtualenv, and we also created
    and activated our first virtual environment. This will allow us to work in a self-contained
    environment without the risk of compromising the Python system installation.
  prefs: []
  type: TYPE_NORMAL
- en: Now you're ready to start this journey with me. All you need is enthusiasm,
    an activated virtual environment, this book, your fingers, and some coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Try to follow the examples; I'll keep them simple and short. If you put them
    under your fingertips, you will retain them much better than if you just read
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Python's rich set of built-in data types.
    There's much to cover and much to learn!
  prefs: []
  type: TYPE_NORMAL

- en: Iterating and Making Decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Insanity: doing the same thing over and over again and expecting different
    results."– Albert Einstein'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at Python's built-in data types. Now that
    you're familiar with data in its many forms and shapes, it's time to start looking
    at how a program can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, control flow (or alternatively, flow of control) refers
    to the specification of the order in which the individual statements, instructions
    or function calls of an imperative program are executed or evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to control the flow of a program, we have two main weapons: **conditional
    programming** (also known as **branching**) and **looping**. We can use them in
    many different combinations and variations, but in this chapter, instead of going
    through all the possible forms of those two constructs in a *documentation* fashion,
    I''d rather give you the basics and then I''ll write a couple of small scripts
    with you. In the first one, we''ll see how to create a rudimentary prime-number
    generator, while in the second one, we''ll see how to apply discounts to customers
    based on coupons. This way, you should get a better feeling for how conditional
    programming and looping can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick peek at the itertools module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional programming, or branching, is something you do every day, every
    moment. It''s about evaluating conditions: *if the light is green, then I can
    cross;* *if it''s raining, then I''m taking the umbrella;* and *if I''m late for
    work, then I''ll call my manager*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main tool is the `if` statement, which comes in different forms and colors,
    but basically it evaluates an expression and, based on the result, chooses which
    part of the code to execute. As usual, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possibly the simplest example: when fed to the `if` statement, `late`
    acts as a conditional expression, which is evaluated in a Boolean context (exactly
    like if we were calling `bool(late)`). If the result of the evaluation is `True`,
    then we enter the body of the code immediately after the `if` statement. Notice
    that the `print` instruction is indented: this means it belongs to a scope defined
    by the `if` clause. Execution of this code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `late` is `True`, the `print` statement was executed. Let''s expand on
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time I set `late = False`, so when I execute the code, the result is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the result of evaluating the `late` expression, we can either enter
    block `#1` or block `#2`, *but not both*. Block `#1` is executed when `late` evaluates
    to `True`, while block `#2` is executed when `late` evaluates to `False`. Try
    assigning `False`/`True` values to the `late` name, and see how the output for
    this code changes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example also introduces the `else` clause, which becomes very
    handy when we want to provide an alternative set of instructions to be executed
    when an expression evaluates to `False` within an `if` clause. The else clause
    is optional, as is evident by comparing the preceding two examples.
  prefs: []
  type: TYPE_NORMAL
- en: A specialized else – elif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes all you need is to do something if a condition is met (a simple `if`
    clause). At other times, you need to provide an alternative, in case the condition
    is `False` (`if`/`else` clause), but there are situations where you may have more
    than two paths to choose from, so, since calling the manager (or not calling them)
    is kind of a binary type of example (either you call or you don''t), let''s change
    the type of example and keep expanding. This time, we decide on tax percentages.
    If my income is less than $10,000, I won''t pay any taxes. If it is between $10,000
    and $30,000, I''ll pay 20% in taxes. If it is between $30,000 and $100,000, I''ll
    pay 35% in taxes, and if it''s over $100,000, I''ll (gladly) pay 45% in taxes.
    Let''s put this all down into beautiful Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the example line by line: we start by setting up the income
    value. In the example, my income is $15,000\. We enter the `if` clause. Notice
    that this time we also introduced the `elif` clause, which is a contraction of `else-if`,
    and it''s different from a bare `else` clause in that it also has its own condition.
    So, the `if` expression of `income < 10000` evaluates to `False`, therefore block
    `#1` is not executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The control passes to the next condition evaluator: `elif income < 30000`.
    This one evaluates to `True`, therefore block `#2` is executed, and because of
    this, Python then resumes execution after the whole `if`/`elif`/`elif`/`else`
    clause (which we can just call the `if` clause from now on). There is only one
    instruction after the `if` clause, the `print` call, which tells us I will pay
    `3000.0` in taxes this year (*15,000 * 20%*). Notice that the order is mandatory:
    `if` comes first, then (optionally) as many `elif` clauses as you need, and then
    (optionally) an `else` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: Interesting, right? No matter how many lines of code you may have within each
    block, when one of the conditions evaluates to `True`, the associated block is
    executed and then execution resumes after the whole clause. If none of the conditions
    evaluates to `True` (for example, `income = 200000`), then the body of the `else`
    clause would be executed (block `#4`). This example expands our understanding
    of the behavior of the `else` clause. Its block of code is executed when none
    of the preceding `if`/`elif`/.../`elif` expressions has evaluated to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Try to modify the value of `income` until you can comfortably execute all blocks
    at will (one per execution, of course). And then try the **boundaries**. This
    is crucial, whenever you have conditions expressed as **equalities** or **inequalities**
    (`==`, `!=`, `<`, `>`, `<=`, `>=`), those numbers represent boundaries. It is
    essential to test boundaries thoroughly. Should I allow you to drive at 18 or
    17? Am I checking your age with `age < 18`, or `age <= 18`? You can't imagine
    how many times I've had to fix subtle bugs that stemmed from using the wrong operator,
    so go ahead and experiment with the preceding code. Change some `<` to `<=` and
    set income to be one of the boundary values (10,000, 30,000, 100,000) as well
    as any value in between. See how the result changes, and get a good understanding
    of it before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see another example that shows us how to nest `if` clauses. Say
    your program encounters an error. If the alert system is the console, we print
    the error. If the alert system is an email, we send it according to the severity
    of the error. If the alert system is anything other than console or email, we
    don''t know what to do, therefore we do nothing. Let''s put this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is quite interesting, because of its silliness. It shows
    us two nested `if` clauses (**outer** and **inner**). It also shows us that the
    outer `if` clause doesn't have any `else`, while the inner one does. Notice how
    indentation is what allows us to nest one clause within another one.
  prefs: []
  type: TYPE_NORMAL
- en: If `alert_system == 'console'`, body `#1` is executed, and nothing else happens.
    On the other hand, if `alert_system == 'email'`, then we enter into another `if`
    clause, which we called inner. In the inner `if` clause, according to `error_severity`,
    we send an email to either an admin, first-level support, or second-level support
    (blocks `#2`, `#3`, and `#4`). The `send_email` function is not defined in this
    example, therefore trying to run it would give you an error. In the source code
    of the book, which you can download from the website, I included a trick to redirect
    that call to a regular `print` function, just so you can experiment on the console
    without actually sending an email. Try changing the values and see how it all
    works.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One last thing I would like to show you, before moving on to the next subject,
    is the **ternary operator** or, in layman''s terms, the short version of an `if`/`else`
    clause. When the value of a name is to be assigned according to some condition,
    sometimes it''s easier and more readable to use the ternary operator instead of
    a proper `if` clause. In the following example, the two code blocks do exactly
    the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For simple cases like this, I find it very nice to be able to express that logic
    in one line instead of four. Remember, as a coder, you spend much more time reading
    code than writing it, so Python's conciseness is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: Are you clear on how the ternary operator works? Basically, `name = something
    if condition else something-else`. So `name` is assigned `something` if `condition`
    evaluates to `True`, and `something-else` if `condition` evaluates to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know everything about controlling the path of the code, let''s
    move on to the next subject: *looping*.'
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any experience with looping in other programming languages, you
    will find Python's way of looping a bit different. First of all, what is looping?
    **Looping** means being able to repeat the execution of a code block more than
    once, according to the loop parameters we're given. There are different looping
    constructs, which serve different purposes, and Python has distilled all of them
    down to just two, which you can use to achieve everything you need. These are
    the `for` and `while` statements.
  prefs: []
  type: TYPE_NORMAL
- en: While it's definitely possible to do everything you need using either of them,
    they serve different purposes and therefore they're usually used in different
    contexts. We'll explore this difference thoroughly in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loop is used when looping over a sequence, such as a list, tuple,
    or a collection of objects. Let''s start with a simple example and expand on the
    concept to see what the Python syntax allows us to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This simple snippet of code, when executed, prints all numbers from `0` to `4`.
    The `for` loop is fed the list `[0, 1, 2, 3, 4]` and at each iteration, `number`
    is given a value from the sequence (which is iterated sequentially, in order),
    then the body of the loop is executed (the print line). The `number` value changes
    at every iteration, according to which value is coming next from the sequence.
    When the sequence is exhausted, the `for` loop terminates, and the execution of
    the code resumes normally with the code after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to iterate over a range of numbers, and it would be quite
    unpleasant to have to do so by hardcoding the list somewhere. In such cases, the
    `range` function comes to the rescue. Let''s see the equivalent of the previous
    snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `range` function is used extensively in Python programs when it comes to
    creating sequences: you can call it by passing one value, which acts as `stop`
    (counting from `0`), or you can pass two values (`start` and `stop`), or even
    three (`start`, `stop`, and `step`). Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, ignore that we need to wrap `range(...)` within a `list`. The
    `range` object is a little bit special, but in this case, we''re just interested
    in understanding what values it will return to us. You can see that the deal is
    the same with slicing: `start` is included, `stop` excluded, and optionally you
    can add a `step` parameter, which by default is `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Try modifying the parameters of the `range()` call in our `simple.for.py` code
    and see what it prints. Get comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all the tools to iterate over a sequence, so let''s build on that
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds a little bit of complexity to the game. Execution will
    show this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the **inside-out** technique to break it down, OK? We start from
    the innermost part of what we''re trying to understand, and we expand outward.
    So, `len(surnames)` is the length of the `surnames` list: `3`. Therefore, `range(len(surnames))`
    is actually transformed into `range(3)`. This gives us the range [0, 3), which
    is basically a sequence (`0`, `1`, `2`). This means that the `for` loop will run
    three iterations. In the first one, `position` will take value `0`, while in the
    second one, it will take value `1`, and finally value `2` in the third and last
    iteration. What is (`0`, `1`, `2`), if not the possible indexing positions for
    the `surnames` list? At position `0`, we find `''Rivest''`, at position `1`, `''Shamir''`,
    and at position `2`, `''Adleman''`. If you are curious about what these three
    men created together, change `print(position, surnames[position])` to `print(surnames[position][0],
    end='''')`, add a final `print()` outside of the loop, and run the code again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this style of looping is actually much closer to languages such as Java
    or C++. In Python, it''s quite rare to see code like this. You can just iterate
    over any sequence or collection, so there is no need to get the list of positions
    and retrieve elements out of a sequence at each iteration. It''s expensive, needlessly
    expensive. Let''s change the example into a more Pythonic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that's something! It's practically English. The `for` loop can iterate over
    the `surnames` list, and it gives back each element in order at each interaction.
    Running this code will print the three surnames, one at a time. It's much easier
    to read, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you wanted to print the position as well though? Or what if you actually
    needed it? Should you go back to the `range(len(...))` form? No. You can use the
    `enumerate` built-in function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code is very interesting as well. Notice that enumerate gives back a two-tuple
    `(position, surname)` at each iteration, but still, it's much more readable (and
    more efficient) than the `range(len(...))` example. You can call `enumerate` with
    a `start` parameter, such as `enumerate(iterable, start)`, and it will start from
    `start`, rather than `0`. Just another little thing that shows you how much thought
    has been given in designing Python so that it makes your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a `for` loop to iterate over lists, tuples, and in general anything
    that Python calls iterable. This is a very important concept, so let's talk about
    it a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators and iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the Python documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)),
    an iterable is:'
  prefs: []
  type: TYPE_NORMAL
- en: An object capable of returning its members one at a time. Examples of iterables
    include all sequence types (such as list, str, and tuple) and some non-sequence
    types like dict, file objects, and objects of any classes you define with an __iter__()
    or __getitem__() method. Iterables can be used in a for loop and in many other
    places where a sequence is needed (zip(), map(), ...). When an iterable object
    is passed as an argument to the built-in function iter(), it returns an iterator
    for the object. This iterator is good for one pass over the set of values. When
    using iterables, it is usually not necessary to call iter() or deal with iterator
    objects yourself. The for statement does that automatically for you, creating
    a temporary unnamed variable to hold the iterator for the duration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, what happens when you write `for k in sequence: ... body ...`,
    is that the `for` loop asks `sequence` for the next element, it gets something
    back, it calls that something `k`, and then executes its body. Then, once again,
    the `for` loop asks `sequence` for the next element, it calls it `k` again, and
    executes the body again, and so on and so forth, until the sequence is exhausted.
    Empty sequences will result in zero executions of the body.'
  prefs: []
  type: TYPE_NORMAL
- en: Some data structures, when iterated over, produce their elements in order, such
    as lists, tuples, and strings, while some others don't, such as sets and dictionaries
    (prior to Python 3.6). Python gives us the ability to iterate over iterables,
    using a type of object called an **iterator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the official documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)),
    an iterator is:'
  prefs: []
  type: TYPE_NORMAL
- en: An object representing a stream of data. Repeated calls to the iterator's __next__()
    method (or passing it to the built-in function next()) return successive items
    in the stream. When no more data are available a StopIteration exception is raised
    instead. At this point, the iterator object is exhausted and any further calls
    to its __next__() method just raise StopIteration again. Iterators are required
    to have an __iter__() method that returns the iterator object itself so every
    iterator is also iterable and may be used in most places where other iterables
    are accepted. One notable exception is code which attempts multiple iteration
    passes. A container object (such as a list) produces a fresh new iterator each
    time you pass it to the iter() function or use it in a for loop. Attempting this
    with an iterator will just return the same exhausted iterator object used in the
    previous iteration pass, making it appear like an empty container.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't fully understand all the preceding legalese, you will
    in due time. I put it here as a handy reference for the future.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the whole iterable/iterator mechanism is somewhat hidden behind
    the code. Unless you need to code your own iterable or iterator for some reason,
    you won't have to worry about this too much. But it's very important to understand
    how Python handles this key aspect of control flow because it will shape the way
    you will write your code.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over multiple sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see another example of how to iterate over two sequences of the same
    length, in order to work on their respective elements in pairs. Say we have a
    list of people and a list of numbers representing the age of the people in the
    first list. We want to print a pair person/age on one line for all of them. Let''s
    start with an example and let''s refine it gradually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, this code should be pretty straightforward for you to understand. We
    need to iterate over the list of positions (`0`, `1`, `2`, `3`) because we want
    to retrieve elements from two different lists. Executing it we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is both inefficient and not Pythonic. It''s inefficient because retrieving
    an element given the position can be an expensive operation, and we''re doing
    it from scratch at each iteration. The postal worker doesn''t go back to the beginning
    of the road each time they deliver a letter, right? They move from house to house.
    From one to the next one. Let''s try to make it better using `enumerate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s better, but still not perfect. And it''s still a bit ugly. We''re iterating
    properly on `people`, but we''re still fetching `age` using positional indexing,
    which we want to lose as well. Well, no worries, Python gives you the `zip` function,
    remember? Let''s use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah! So much better! Once again, compare the preceding code with the first example
    and admire Python''s elegance. The reason I wanted to show this example is twofold.
    On the one hand, I wanted to give you an idea of how shorter code in Python can
    be compared to other languages where the syntax doesn''t allow you to iterate
    over sequences or collections as easily. And on the other hand, and much more
    importantly, notice that when the `for` loop asks `zip(sequenceA, sequenceB)`
    for the next element, it gets back a tuple, not just a single object. It gets
    back a tuple with as many elements as the number of sequences we feed to the `zip`
    function. Let''s expand a little on the previous example in two ways, using explicit
    and implicit assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the nationalities list. Now that we feed three
    sequences to the `zip` function, the for loop gets back a *three-tuple* at each
    iteration. Notice that the position of the elements in the tuple respects the
    position of the sequences in the `zip` call. Executing the code will yield the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, for reasons that may not be clear in a simple example such as the
    preceding one, you may want to explode the tuple within the body of the `for`
    loop. If that is your desire, it''s perfectly possible to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s basically doing what the `for` loop does automatically for you, but in
    some cases you may want to do it yourself. Here, the three-tuple `data` that comes
    from `zip(...)` is exploded within the body of the `for` loop into three variables:
    `person`, `age`, and `nationality`.'
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding pages, we saw the `for` loop in action. It's incredibly useful
    when you need to loop over a sequence or a collection. The key point to keep in
    mind, when you need to be able to discriminate which looping construct to use,
    is that the `for` loop rocks when you have to iterate over a finite amount of
    elements. It can be a huge amount, but still, something that ends at some point.
  prefs: []
  type: TYPE_NORMAL
- en: There are other cases though, when you just need to loop until some condition
    is satisfied, or even loop indefinitely until the application is stopped, such
    as cases where we don't really have something to iterate on, and therefore the
    `for` loop would be a poor choice. But fear not, for these cases, Python provides
    us with the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is similar to the `for` loop, in that they both loop, and at
    each iteration they execute a body of instructions. What is different between
    them is that the `while` loop doesn't loop over a sequence (it can, but you have
    to write the logic manually and it wouldn't make any sense, you would just want
    to use a `for` loop), rather, it loops as long as a certain condition is satisfied.
    When the condition is no longer satisfied, the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let''s see an example that will clarify everything for us. We want
    to print the binary representation of a positive number. In order to do so, we
    can use a simple algorithm that collects the remainders of division by `2` (in
    reverse order), and that turns out to be the binary representation of the number
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write some code to calculate the binary representation for the number
    39: 100111[2]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I highlighted `n > 0`, which is the condition to keep
    looping. We can make the code a little shorter (and more Pythonic), by using the
    `divmod` function, which is called with a number and a divisor, and returns a
    tuple with the result of the integer division and its remainder. For example,
    `divmod(13, 5)` would return `(2, 3)`, and indeed *5 * 2 + 3 = 13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have reassigned `n` to the result of the division
    by `2`, and the remainder, in one single line.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the condition in a `while` loop is a condition to continue looping.
    If it evaluates to `True`, then the body is executed and then another evaluation
    follows, and so on, until the condition evaluates to `False`. When that happens,
    the loop is exited immediately without executing its body.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the condition never evaluates to `False`, the loop becomes a so-called **infinite
    loop**. Infinite loops are used, for example, when polling from network devices:
    you ask the socket whether there is any data, you do something with it if there
    is any, then you sleep for a small amount of time, and then you ask the socket
    again, over and over again, without ever stopping.'
  prefs: []
  type: TYPE_NORMAL
- en: Having the ability to loop over a condition, or to loop indefinitely, is the
    reason why the `for` loop alone is not enough, and therefore Python provides the
    `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you need the binary representation of a number, check out the
    `bin` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, let''s adapt one of the examples (`multiple.sequences.py`) using
    the while logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I have highlighted the *initialization*, *condition*,
    and *update* of the `position` variable, which makes it possible to simulate the
    equivalent `for` loop code by handling the iteration variable manually. Everything
    that can be done with a `for` loop can also be done with a `while` loop, even
    though you can see there's a bit of boilerplate you have to go through in order
    to achieve the same result. The opposite is also true, but unless you have a reason
    to do so, you ought to use the right tool for the job, and 99.9% of the time you'll
    be fine.
  prefs: []
  type: TYPE_NORMAL
- en: So, to recap, use a `for` loop when you need to iterate over an iterable, and
    a `while` loop when you need to loop according to a condition being satisfied
    or not. If you keep in mind the difference between the two purposes, you will
    never choose the wrong looping construct.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to alter the normal flow of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: The break and continue statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the task at hand, sometimes you will need to alter the regular
    flow of a loop. You can either skip a single iteration (as many times as you want),
    or you can break out of the loop entirely. A common use case for skipping iterations
    is, for example, when you're iterating over a list of items and you need to work
    on each of them only if some condition is verified. On the other hand, if you're
    iterating over a collection of items, and you have found one of them that satisfies
    some need you have, you may decide not to continue the loop entirely and therefore
    break out of it. There are countless possible scenarios, so it's better to see
    a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want to apply a 20% discount to all products in a basket list
    for those that have an expiration date of today. The way you achieve this is to
    use the `continue` statement, which tells the looping construct (`for` or `while`)
    to stop execution of the body immediately and go to the next iteration, if any.
    This example will take us a little deeper down the rabbit hole, so be ready to
    jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the `date` and `timedelta` objects, then we set up our
    products. Those with `sku` as `1` and `3` have an expiration date of `today`,
    which means we want to apply a 20% discount on them. We loop over each `product`
    and we inspect the expiration date. If it is not (inequality operator, `!=`) `today`,
    we don't want to execute the rest of the body suite, so we `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that it is not important where in the body suite you place the `continue`
    statement (you can even use it more than once). When you reach it, execution stops
    and goes back to the next iteration. If we run the `discount.py` module, this
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This shows you that the last two lines of the body haven't been executed for
    `sku` number `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see an example of breaking out of a loop. Say we want to tell whether
    at least one of the elements in a list evaluates to `True` when fed to the `bool`
    function. Given that we need to know whether there is at least one, when we find
    it, we don''t need to keep scanning the list any further. In Python code, this
    translates to using the `break` statement. Let''s write this down into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is such a common pattern in programming, you will see it
    a lot. When you inspect items this way, basically what you do is to set up a `flag`
    variable, then start the inspection. If you find one element that matches your
    criteria (in this example, that evaluates to `True`), then you update the flag
    and stop iterating. After iteration, you inspect the flag and take action accordingly.
    Execution yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See how execution stopped after `True` was found? The `break` statement acts
    exactly like the `continue` one, in that it stops executing the body of the loop
    immediately, but also, prevents any other iteration from running, effectively
    breaking out of the loop. The `continue` and `break` statements can be used together
    with no limitation in their numbers, both in the `for` and `while` looping constructs.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, there is no need to write code to detect whether there is at least
    one element in a sequence that evaluates to `True`. Just check out the built-in `any` function.
  prefs: []
  type: TYPE_NORMAL
- en: A special else clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features I've seen only in the Python language is the ability to
    have `else` clauses after `while` and `for` loops. It's very rarely used, but
    it's definitely nice to have. In short, you can have an `else` suite after a `for`
    or `while` loop. If the loop ends normally, because of exhaustion of the iterator
    (`for` loop) or because the condition is finally not met (`while` loop), then
    the `else` suite (if present) is executed. In case execution is interrupted by
    a `break` statement, the `else` clause is not executed. Let's take an example
    of a `for` loop that iterates over a group of items, looking for one that would
    match some condition. In case we don't find at least one that satisfies the condition,
    we want to raise an **exception**. This means we want to arrest the regular execution
    of the program and signal that there was an error, or exception, that we cannot
    deal with. Exceptions will be the subject of [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, so don't worry if you don't
    fully understand them now. Just bear in mind that they will alter the regular
    flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me now show you two examples that do exactly the same thing, but one of
    them is using the special `for...else` syntax. Say that we want to find, among
    a collection of people, one that could drive a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `flag` pattern again. We set the driver to be `None`, then if we
    find one, we update the `driver` flag, and then, at the end of the loop, we inspect
    it to see whether one was found. I kind of have the feeling that those kids would
    drive a very *metallic* car, but anyway, notice that if a driver is not found, `DriverException`
    is raised, signaling to the program that execution cannot continue (we're lacking
    the driver).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same functionality can be rewritten a bit more elegantly using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we aren't forced to use the `flag` pattern any more. The exception
    is raised as part of the `for` loop logic, which makes good sense because the
    `for` loop is checking on some condition. All we need is to set up a `driver`
    object in case we find one, because the rest of the code is going to use that
    information somewhere. Notice the code is shorter and more elegant, because the
    logic is now correctly grouped together where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Transforming Code into Beautiful, Idiomatic Python* video, Raymond
    Hettinger suggests a much better name for the `else` statement associated with
    a for loop: `nobreak`. If you struggle remembering how the `else` works for a
    `for` loop, simply remembering this fact should help you.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting all this together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen all there is to see about conditionals and loops, it's
    time to spice things up a little, and look at those two examples I anticipated
    at the beginning of this chapter. We'll mix and match here, so you can see how
    you can use all these concepts together. Let's start by writing some code to generate
    a list of prime numbers up to some limit. Please bear in mind that I'm going to
    write a very inefficient and rudimentary algorithm to detect primes. The important
    thing for you is to concentrate on those bits in the code that belong to this
    chapter's subject.
  prefs: []
  type: TYPE_NORMAL
- en: A prime generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: A prime number (or a prime) is a natural number greater than 1 that has no positive
    divisors other than 1 and itself. A natural number greater than 1 that is not
    a prime number is called a composite number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this definition, if we consider the first 10 natural numbers, we can
    see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, and 10 are not. In order
    to have a computer tell you whether a number, *N*, is prime, you can divide that
    number by all natural numbers in the range [2, *N*). If any of those divisions
    yields zero as a remainder, then the number is not a prime. Enough chatter, let''s
    get down to business. I''ll write two versions of this, the second of which will
    exploit the `for...else` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of things to notice in the preceding code. First of all, we
    set up an empty `primes` list, which will contain the primes at the end. The limit
    is `100`, and you can see it's inclusive in the way we call `range()` in the outer
    loop. If we wrote `range(2, upto)` that would be *[2, upto)*, right? Therefore
    `range(2, upto + 1)` gives us *[2, upto + 1) == [2, upto]*.
  prefs: []
  type: TYPE_NORMAL
- en: So, there are two `for` loops. In the outer one, we loop over the candidate
    primes, that is, all natural numbers from `2` to `upto`. Inside each iteration
    of this outer loop, we set up a flag (which is set to `True` at each iteration),
    and then start dividing the current `n` by all numbers from `2` to `n - 1`. If
    we find a proper divisor for `n`, it means `n` is composite, and therefore we
    set the flag to `False` and break the loop. Notice that when we break the inner
    one, the outer one keeps on going normally. The reason why we break after having
    found a proper divisor for `n` is that we don't need any further information to
    be able to tell that `n` is not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: When we check on the `is_prime` flag, if it is still `True`, it means we couldn't
    find any number in [2, *n*) that is a proper divisor for `n`, therefore `n` is
    a prime. We append `n` to the `primes` list, and hop! Another iteration proceeds,
    until `n` equals `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we proceed, one question: of all the iterations of the outer loop, one
    of them is different from all the others. Could you tell which one, and why? Think
    about it for a second, go back to the code, try to figure it out for yourself,
    and then keep reading on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you figure it out? If not, don''t feel bad, it''s perfectly normal. I asked
    you to do it as a small exercise because it''s what coders do all the time. The
    skill to understand what the code does by simply looking at it is something you
    build over time. It''s very important, so try to exercise it whenever you can.
    I''ll tell you the answer now: the iteration that behaves differently from all
    others is the first one. The reason is because in the first iteration, `n` is
    `2`. Therefore the innermost `for` loop won''t even run, because it''s a `for`
    loop that iterates over `range(2, 2)`, and what is that if not [2, 2)? Try it
    out for yourself, write a simple `for` loop with that iterable, put a `print`
    in the body suite, and see whether anything happens (it won''t...).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from an algorithmic point of view, this code is inefficient, so let''s
    at least make it more beautiful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Much nicer, right? The `is_prime` flag is gone, and we append `n` to the `primes`
    list when we know the inner `for` loop hasn't encountered any `break` statements.
    See how the code looks cleaner and reads better?
  prefs: []
  type: TYPE_NORMAL
- en: Applying discounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, I want to show you a technique I like a lot. In many programming
    languages, other than the `if`/`elif`/`else` constructs, in whatever form or syntax
    they may come, you can find another statement, usually called `switch`/`case`,
    that in Python is missing. It is the equivalent of a cascade of `if`/`elif`/.../`elif`/`else`
    clauses, with a syntax similar to this (warning! JavaScript code!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we `switch` on a variable called `day_number`. This
    means we get its value and then we decide what case it fits in (if any). From
    `1` to `5` there is a cascade, which means no matter the number, [`1`, `5`] all
    go down to the bit of logic that sets `day` as `"Weekday"`. Then we have single
    cases for `0` and `6`, and a `default` case to prevent errors, which alerts the
    system that `day_number` is not a valid day number, that is, not in [`0`, `6`].
    Python is perfectly capable of realizing such logic using `if`/`elif`/`else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we reproduce the same logic of the JavaScript snippet
    in Python, using `if`/`elif`/`else` statements. I raised the `ValueError` exception
    just as an example at the end, if `day_number` is not in [`0`, `6`]. This is one
    possible way of translating the `switch`/`case` logic, but there is also another
    one, sometimes called dispatching, which I will show you in the last version of
    the next example.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, did you notice the first line of the previous snippet? Have you
    noticed that Python can make double (actually, even multiple) comparisons? It's
    just wonderful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the new example by simply writing some code that assigns a discount
    to customers based on their coupon value. I''ll keep the logic down to a minimum
    here, remember that all we really care about is understanding conditionals and
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting up some customers. They have an order total, a coupon code,
    and an ID. I made up four different types of coupons, two are fixed and two are
    percentage-based. You can see that in the `if`/`elif`/`else` cascade I apply the
    discount accordingly, and I set it as a `'discount'` key in the `customer` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, I just print out part of the data to see whether my code is working
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is simple to understand, but all those clauses are kind of cluttering
    the logic. It''s not easy to see what''s going on at a first glance, and I don''t
    like it. In cases like this, you can exploit a dictionary to your advantage, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code yields exactly the same result we had from the snippet
    before it. We spared two lines, but more importantly, we gained a lot in readability,
    as the body of the `for` loop now is just three lines long, and very easy to understand.
    The concept here is to use a dictionary as a **dispatcher**. In other words, we
    try to fetch something from the dictionary based on a code (our `coupon_code`),
    and by using `dict.get(key, default)`, we make sure we also cater for when the
    `code` is not in the dictionary and we need a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I had to apply some very simple linear algebra in order to calculate
    the discount properly. Each discount has a percentage and fixed part in the dictionary,
    represented by a two-tuple. By applying `percent * total + fixed`, we get the
    correct discount. When `percent` is `0`, the formula just gives the fixed amount,
    and it gives `percent * total` when fixed is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is important because it is also used in other contexts, with
    functions, where it actually becomes much more powerful than what we've seen in
    the preceding snippet. Another advantage of using it is that you can code it in
    such a way that the keys and values of the `discounts` dictionary are fetched
    dynamically (for example, from a database). This will allow the code to adapt
    to whatever discounts and conditions you have, without having to modify anything.
  prefs: []
  type: TYPE_NORMAL
- en: If it's not completely clear to you how it works, I suggest you take your time
    and experiment with it. Change values and add print statements to see what's going
    on while the program is running.
  prefs: []
  type: TYPE_NORMAL
- en: A quick peek at the itertools module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A chapter about iterables, iterators, conditional logic, and looping wouldn't
    be complete without a few words about the `itertools` module. If you are into
    iterating, this is a kind of heaven.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python official documentation ([https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)),
    the `itertools` module is:'
  prefs: []
  type: TYPE_NORMAL
- en: This module which implements a number of iterator building blocks inspired by
    constructs from APL, Haskell, and SML. Each has been recast in a form suitable
    for Python. The module standardizes a core set of fast, memory efficient tools
    that are useful by themselves or in combination. Together, they form an “iterator
    algebra” making it possible to construct specialized tools succinctly and efficiently
    in pure Python.
  prefs: []
  type: TYPE_NORMAL
- en: By no means do I have the room here to show you all the goodies you can find
    in this module, so I encourage you to go check it out for yourself, I promise
    you'll enjoy it. In a nutshell, it provides you with three broad categories of
    iterators. I will give you a very small example of one iterator taken from each
    one of them, just to make your mouth water a little.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Infinite iterators allow you to work with a `for` loop in a different fashion,
    such as if it were a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code gives this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `count` factory class makes an iterator that just goes on and on counting.
    It starts from `5` and keeps adding `3` to it. We need to break it manually if
    we don't want to get stuck in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators terminating on the shortest input sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This category is very interesting. It allows you to create an iterator based
    on multiple iterators, combining their values according to some logic. The key
    point here is that among those iterators, in case any of them are shorter than
    the rest, the resulting iterator won''t break, it will simply stop as soon as
    the shortest iterator is exhausted. This is very theoretical, I know, so let me
    give you an example using `compress`. This iterator gives you back the data according
    to a corresponding item in a selector being `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compress(''ABC'', (1, 0, 1))` would give back `''A''` and `''C''`, because
    they correspond to `1`. Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `odd_selector` and `even_selector` are 20 elements long, while
    `data` is just 10 elements long. `compress` will stop as soon as `data` has yielded
    its last element. Running this code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It's a very fast and nice way of selecting elements out of an iterable. The
    code is very simple, just notice that instead of using a `for` loop to iterate
    over each value that is given back by the compress calls, we used `list()`, which
    does the same, but instead of executing a body of instructions, puts all the values
    into a list and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Combinatoric generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, combinatoric generators. These are really fun, if you are
    into this kind of thing. Let's just see a simple example on permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wolfram Mathworld:'
  prefs: []
  type: TYPE_NORMAL
- en: A permutation, also called an "arrangement number" or "order", is a rearrangement
    of the elements of an ordered list S into a one-to-one correspondence with S itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are six permutations of ABC: ABC, ACB, BAC, BCA, CAB, and
    CBA.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a set has *N* elements, then the number of permutations of them is *N!*
    (*N* factorial). For the ABC string, the permutations are *3! = 3 * 2 * 1 = 6*.
    Let''s do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This very short snippet of code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Be very careful when you play with permutations. Their number grows at a rate
    that is proportional to the factorial of the number of the elements you're permuting,
    and that number can get really big, really fast.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken another step toward expanding our coding vocabulary.
    We've seen how to drive the execution of the code by evaluating conditions, and
    we've seen how to loop and iterate over sequences and collections of objects.
    This gives us the power to control what happens when our code is run, which means
    we are getting an idea of how to shape it so that it does what we want and it
    reacts to data that changes dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen how to combine everything together in a couple of simple examples,
    and in the end, we took a brief look at the `itertools` module, which is full
    of interesting iterators that can enrich our abilities with Python even more.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to switch gears, take another step forward, and talk about functions.
    The next chapter is all about them because they are extremely important. Make
    sure you're comfortable with what has been covered up to now. I want to provide
    you with interesting examples, so I'll have to go a little faster. Ready? Turn
    the page.
  prefs: []
  type: TYPE_NORMAL

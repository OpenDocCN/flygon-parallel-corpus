- en: Debugging and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If debugging is the process of removing software bugs, then programming must
    be the process of putting them in."– Edsger W. Dijkstra'
  prefs: []
  type: TYPE_NORMAL
- en: In the life of a professional coder, debugging and troubleshooting take up a
    significant amount of time. Even if you work on the most beautiful code base ever
    written by a human, there will still be bugs in it; that is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: We spend an awful lot of time reading other people's code and, in my opinion,
    a good software developer is someone who keeps their attention high, even when
    they're reading code that is not reported to be wrong or buggy.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to debug code efficiently and quickly is a skill that every coder
    needs to keep improving. Some think that because they have read the manual, they're
    fine, but the reality is, the number of variables in the game is so great that
    there is no manual. There are guidelines one can follow, but there is no magic
    book that will teach you everything you need to know in order to become good at
    this.
  prefs: []
  type: TYPE_NORMAL
- en: I feel that on this particular subject, I have learned the most from my colleagues.
    It amazes me to observe someone very skilled attacking a problem. I enjoy seeing
    the steps they take, the things they verify to exclude possible causes, and the
    way they consider the suspects that eventually lead them to a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Every colleague we work with can teach us something, or surprise us with a fantastic
    guess that turns out to be the right one. When that happens, don't just remain
    in wonderment (or worse, in envy), but seize the moment and ask them how they
    got to that guess and why. The answer will allow you to see whether there is something
    you can study in-depth later on so that, maybe next time, you'll be the one who
    will catch the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Some bugs are very easy to spot. They come out of coarse mistakes and, once
    you see the effects of those mistakes, it's easy to find a solution that fixes
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: But there are other bugs that are much more subtle, much more slippery, and
    require true expertise, and a great deal of creativity and out-of-the-box thinking,
    to be dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: The worst of all, at least for me, are the nondeterministic ones. These sometimes
    happen, and sometimes don't. Some happen only in environment A but not in environment
    B, even though A and B are supposed to be exactly the same. Those bugs are the
    truly evil ones, and they can drive you crazy.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, bugs don't just happen in the sandbox, right? With your boss
    telling you, *"Don't worry! Take your time to fix this. Have lunch first!"* Nope.
    They happen on a Friday at half past five, when your brain is cooked and you just
    want to go home. It's in those moments when everyone is getting upset in a split
    second, when your boss is breathing down your neck, that you have to be able to
    keep calm. And I do mean it. That's the most important skill to have if you want
    to be able to fight bugs effectively. If you allow your mind to get stressed,
    say goodbye to creative thinking, to logical deduction, and to everything you
    need at that moment. So take a deep breath, sit properly, and focus.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will try to demonstrate some useful techniques that you can
    employ according to the severity of the bug, and a few suggestions that will hopefully
    boost your weapons against bugs and issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''re going to look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, I'll present you with the most common techniques, the ones I use
    most often; however, please don't consider this list to be exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with print
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably the easiest technique of all. It's not very effective, it cannot
    be used everywhere, and it requires access to both the source code and a Terminal
    that will run it (and therefore show the results of the `print` function calls).
  prefs: []
  type: TYPE_NORMAL
- en: However, in many situations, this is still a quick and useful way to debug.
    For example, if you are developing a Django website and what happens in a page
    is not what you would expect, you can fill the view with prints and keep an eye
    on the console while you reload the page. When you scatter calls to `print` in
    your code, you normally end up in a situation where you duplicate a lot of debugging
    code, either because you're printing a timestamp (like we did when we were measuring
    how fast list comprehensions and generators were), or because you have somehow
    to build a string of some sort that you want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that it's extremely easy to forget calls to `print` in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: So, for these reasons, rather than using a bare call to `print`, I sometimes
    prefer to code a custom function. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with a custom function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a custom function in a snippet that you can quickly grab and paste into
    the code, and then use to debug, can be very useful. If you're fast, you can always
    code one on the fly. The important thing is to code it in a way that it won't
    leave stuff around when you eventually remove the calls and its definition. Therefore
    *it's important to code it in a way that is completely self-contained*. Another
    good reason for this requirement is that it will avoid potential name clashes
    with the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I am using a keyword-only argument to be able to print a separator,
    which is a line of `40` dashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is very simple. I just redirect whatever is in `msg` to a call
    to `print` and, if `print_separator` is `True`, I print a line separator. Running
    the code will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no separator after the last line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one easy way to somehow augment a simple call to the `print` function.
    Let''s see how we can calculate a time difference between calls, using one of
    Python''s tricky features to our advantage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit trickier, but still quite simple. First, notice we import the
    `time` function from the `time` module from inside the `debug` function. This
    allows us to avoid having to add that import outside of the function, and maybe
    forget it there.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at how I defined `timestamp`. It's a list, of course, but what's
    important here is that it is a **mutable** object. This means that it will be
    set up when Python parses the function and it will retain its value throughout
    different calls. Therefore, if we put a timestamp in it after each call, we can
    keep track of time without having to use an external global variable. I borrowed
    this trick from my studies on **closures**, a technique that I encourage you to
    read about because it's very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Right, so, after having printed whatever message we had to print and some importing
    time, we then inspect the content of the only item in `timestamp`. If it is `None`,
    we have no previous reference, therefore we set the value to the current time
    (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we have a previous reference, we can calculate a difference
    (which we nicely format to three decimal digits) and then we finally put the current
    time again in `timestamp` (`#2`). It's a nice trick, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code shows this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whatever your situation, having a self-contained function like this can be very
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the traceback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We briefly talked about the traceback in [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe), *Testing,
    Profiling, and Dealing with Exceptions*, when we saw several different kinds of
    exceptions. The traceback gives you information about what went wrong in your
    application. It''s helpful to read it, so let''s see a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a dictionary and we try to access a key that isn''t in it. You should
    remember that this will raise a `KeyError` exception. Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we get all the information we need: the module name, the line
    that caused the error (both the number and the instruction), and the error itself.
    With this information, you can go back to the source code and try to understand
    what''s going on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a more interesting example that builds on top of this, and
    exercises a feature that is only available in Python 3\. Imagine that we''re validating
    a dictionary, working on mandatory fields, therefore we expect them to be there.
    If not, we need to raise a custom `ValidationError` that we will trap further
    upstream in the process that runs the validator (which is not shown here, so it
    could be anything, really). It should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We define a custom exception that is raised when the mandatory key isn't there.
    Note that its body consists of its documentation string, so we don't need to add
    any other statements.
  prefs: []
  type: TYPE_NORMAL
- en: Very simply, we define a dummy dict and try to access it using `mandatory_key`.
    We trap `KeyError` and raise `ValidatorError` when that happens. And we do it
    by using the `raise ... from ...` syntax, which was introduced in Python 3 by
    PEP 3134 ([https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/)),
    to chain exceptions. The purpose of doing this is that we may also want to raise
    `ValidatorError` in other circumstances, not necessarily as a consequence of a
    mandatory key being missing. This technique allows us to run the validation in
    a simple `try`/`except` that only cares about `ValidatorError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without being able to chain exceptions, we would lose information about `KeyError`. The
    code produces this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is brilliant, because we can see the traceback of the exception that led
    us to raise `ValidationError`, as well as the traceback for the `ValidationError`
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: I had a nice discussion with one of my reviewers about the traceback you get
    from the `pip` installer. He was having trouble setting everything up in order
    to review the code for [Chapter 13](part0324.html#9KVM80-2ddb708647cc4530a187c2c6c0e9acfe),
    *Data Science*. His fresh Ubuntu installation was missing a few libraries that
    were needed by the `pip` packages in order to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The reason he was blocked was that he was trying to fix the errors displayed
    in the traceback starting from the top one. I suggested that he started from the
    bottom one instead, and fix that. The reason was that, if the installer had gotten
    to that last line, I guess that before that, whatever error may have occurred,
    it was still possible to recover from it. Only after the last line, `pip` decided
    it wasn't possible to continue any further, and therefore I started fixing that
    one. Once the libraries required to fix that error had been installed, everything
    else went smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a traceback can be tricky, and my friend was lacking the necessary experience
    to address this problem correctly. Therefore, if you end up in the same situation.
    Don't be discouraged, and try to shake things up a bit, don't take anything for
    granted.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a huge and wonderful community and it's very unlikely that, when
    you encounter a problem, you're the first one to see it, so open a browser and
    search. By doing so, your searching skills will also improve because you will
    have to trim the error down to the minimum but essential set of details that will
    make your search effective.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play and understand the traceback a bit better, in the standard
    library there is a module you can use called, surprise surprise, `traceback`.
    It provides a standard interface to extract, format, and print stack traces of
    Python programs, mimicking the behavior of the Python interpreter when it prints
    a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very effective way of debugging Python is to use the Python debugger:
    `pdb`. Instead of using it directly though, you should definitely check out the
    `pdbpp` library. `pdbpp` augments the standard `pdb` interface by providing some
    convenient tools, my favorite of which is the **sticky mode**, which allows you
    to see a whole function while you step through its instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several different ways to use this debugger (whichever version, it's
    not important), but the most common one consists of simply setting a breakpoint
    and running the code. When Python reaches the breakpoint, execution is suspended
    and you get console access to that point so that you can inspect all the names,
    and so on. You can also alter data on the fly to change the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a toy example, let''s pretend we have a parser that is raising `KeyError`
    because a key is missing in a dictionary. The dictionary is from a JSON payload
    that we cannot control, and we just want, for the time being, to cheat and pass
    that control, since we''re interested in what comes afterward. Let''s see how
    we could intercept this moment, inspect the data, fix it, and get to the bottom
    of it, with `pdbpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this code will break when `key` gets the `''third''` value,
    which is missing in the dictionary. Remember, we''re pretending that both `d`
    and `keys` come dynamically from a JSON payload we don''t control, so we need
    to inspect them in order to fix `d` and pass the `for` loop. If we run the code
    as it is, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So we see that that `key` is missing from the dictionary, but since every time
    we run this code we may get a different dictionary or `keys` tuple, this information
    doesn''t really help us. Let''s inject a call to `pdb` just before the `for` loop.
    You have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most common way of doing it. You import `pdb` and call its `set_trace`
    method. Many developers have macros in their editor to add this line with a keyboard
    shortcut. As of Python 3.7 though, we can simplify things even further, to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The new `breakpoint` built-in function calls `sys.breakpointhook()` under the
    hood, which is programmed by default to call `pdb.set_trace()`. However, you can
    reprogram `sys.breakpointhook()` to call whatever you want, and therefore `breakpoint`
    will point to that too, which is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example is in the `pdebugger_pdb.py` module. If we now run
    this code, things get interesting (note that your output may vary a little and
    that all the comments in this output were added by me):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, note that when you reach a breakpoint, you're served a console that tells
    you where you are (the Python module) and which line is the next one to be executed.
    You can, at this point, perform a bunch of exploratory actions, such as inspecting
    the code before and after the next line, printing a stack trace, and interacting
    with the objects. Please consult the official Python documentation ([https://docs.python.org/3.7/library/pdb.html](https://docs.python.org/3.7/library/pdb.html))
    on `pdb` to learn more about this. In our case, we first inspect the `keys` tuple.
    After that, we inspect the keys of `d`. We see that `'third'` is missing, so we
    put it in ourselves (could this be dangerous—think about it). Finally, now that
    all the keys are in, we type `c`, which means (*c*)ontinue.
  prefs: []
  type: TYPE_NORMAL
- en: '`pdb` also gives you the ability to proceed with your code one line at a time
    using (*n*)ext, to (*s*)tep into a function for deeper analysis, or to handle
    breaks with (*b*)reak. For a complete list of commands, please refer to the documentation
    or type (*h*)elp in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see, from the output of the preceding run, that we could finally get
    to the end of the validation.
  prefs: []
  type: TYPE_NORMAL
- en: '`pdb` (or `pdbpp`) is an invaluable tool that I use every day. So, go and have
    fun, set a breakpoint somewhere, and try to inspect it, follow the official documentation
    and try the commands in your code to see their effect and learn them well.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in this example I have assumed you installed `pdbpp`. If that is
    not the case, then you might find that some commands don't work the same in `pdb`.
    One example is the letter `d`, which would be interpreted from `pdb` as the *down*
    command. In order to get around that, you would have to add a `!` in front of `d`,
    to tell `pdb` that it is meant to be interpreted literally, and not as a command.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of debugging a misbehaving application is to inspect its log files.
    **Log files** are special files in which an application writes down all sorts
    of things, normally related to what's going on inside of it. If an important procedure
    is started, I would typically expect a corresponding line in the logs. It is the
    same when it finishes, and possibly for what happens inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: Errors need to be logged so that when a problem happens, we can inspect what
    went wrong by taking a look at the information in the log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different ways to set up a logger in Python. Logging is very
    malleable and you can configure it. In a nutshell, there are normally four players
    in the game: loggers, handlers, filters, and formatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loggers**: Expose the interface that the application code uses directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlers**: Send the log records (created by loggers) to the appropriate
    destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**: Provide a finer-grained facility for determining which log records
    to output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatters**: Specify the layout of the log records in the final output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logging is performed by calling methods on instances of the `Logger` class.
    Each line you log has a level. The levels normally used are: `DEBUG`, `INFO`,
    `WARNING`, `ERROR`, and `CRITICAL`. You can import them from the `logging` module.
    They are in order of severity and it''s very important to use them properly because
    they will help you filter the contents of a log file based on what you''re searching
    for. Log files usually become extremely big so it''s very important to have the
    information in them written properly so that you can find it quickly when it matters.'
  prefs: []
  type: TYPE_NORMAL
- en: You can log to a file but you can also log to a network location, to a queue,
    to a console, and so on. In general, if you have an architecture that is deployed
    on one machine, logging to a file is acceptable, but when your architecture spans
    over multiple machines (such as in the case of service-oriented or microservice
    architectures), it's very useful to implement a centralized solution for logging
    so that all log messages coming from each service can be stored and investigated
    in a single place. It helps a lot, otherwise trying to correlate giant files from
    several different sources to figure out what went wrong can become truly challenging.
  prefs: []
  type: TYPE_NORMAL
- en: A **service-oriented architecture** (**SOA**) is an architectural pattern in
    software design in which application components provide services to other components
    via a communications protocol, typically over a network. The beauty of this system
    is that, when coded properly, each service can be written in the most appropriate
    language to serve its purpose. The only thing that matters is the communication
    with the other services, which needs to happen via a common format so that data
    exchange can be done.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservice architectures** are an evolution of SOAs, but follow a different
    set of architectural patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I will present you with a very simple logging example. We will log a
    few messages to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through it line by line. First, we import the `logging` module, then
    we set up a basic configuration. In general, a production-logging configuration
    is much more complicated than this, but I wanted to keep things as easy as possible.
    We specify a filename, the minimum logging level we want to capture in the file,
    and the message format. We'll log the date and time information, the level, and
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: I will start by logging an `info` message that tells me we're about to process
    our list. Then, I will log (this time using the `DEBUG` level, by using the `debug`
    function) which is the value at some position. I'm using `debug` here because
    I want to be able to filter out these logs in the future (by setting the minimum
    level to `logging.INFO` or more), because I might have to handle very big lists
    and I don't want to log all the values.
  prefs: []
  type: TYPE_NORMAL
- en: If we get `IndexError` (and we do, since I'm looping over `range(4)`), we call
    `logging.exception()`, which is the same as `logging.error()`, but it also prints
    the traceback.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, I log another `info` message saying we''re done. The
    result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we need to be able to debug an application that is running
    on a box, and not on our console. We can see what went on, the traceback of any
    exception raised, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example presented here only scratches the surface of logging. For a more
    in-depth explanation, you can find information in the *Python HOWTOs* section of
    the official Python documentation: *Logging HOWTO*, and *Logging Cookbook*.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is an art. You need to find a good balance between logging everything
    and logging nothing. Ideally, you should log anything that you need to make sure
    your application is working correctly, and possibly all errors or exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section, I'd like to demonstrate briefly a couple of techniques
    that you may find useful.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about profiling in [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, and I'm only mentioning it
    here because profiling can sometimes explain weird errors that are due to a component
    being too slow. Especially when networking is involved, having an idea of the
    timings and latencies your application has to go through is very important in
    order to understand what may be going on when problems arise, therefore I suggest
    you get acquainted with profiling techniques and also for a troubleshooting perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assertions are a nice way to make your code ensure your assumptions are verified.
    If they are, all proceeds regularly but, if they are not, you get a nice exception
    that you can work with. Sometimes, instead of inspecting, it''s quicker to drop
    a couple of assertions in the code just to exclude possibilities. Let''s see an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simulates a situation in which `mylist` isn''t defined by us like
    that, of course, but we''re assuming it has four elements. So we put an assertion
    there, and the result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This tells us exactly where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Where to find information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Python official documentation, there is a section dedicated to debugging
    and profiling, where you can read up about the `bdb` debugger framework, and about
    modules such as `faulthandler`, `timeit`, `trace`, `tracemallock`, and of course
    `pdb`. Just head to the standard library section in the documentation and you'll
    find all this information very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short section, I'd like to give you a few tips that come from my troubleshooting
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Using console editors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, get comfortable using **Vim** or **nano** as an editor, and learn the
    basics of the console. When things break, you don't have the luxury of your editor
    with all the bells and whistles there. You have to connect to a box and work from
    there. So it's a very good idea to be comfortable browsing your production environment
    with console commands, and be able to edit files using console-based editors,
    such as vi, Vim, or nano. Don't let your usual development environment spoil you.
  prefs: []
  type: TYPE_NORMAL
- en: Where to inspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My second suggestion concerns where to place your debugging breakpoints. It
    doesn't matter if you are using `print`, a custom function, or `pdb`, you still
    have to choose where to place the calls that provide you with the information,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Well, some places are better than others, and there are ways to handle the debugging
    progression that are better than others.
  prefs: []
  type: TYPE_NORMAL
- en: I normally avoid placing a breakpoint in an `if` clause because, if that clause
    is not exercised, I lose the chance of getting the information I wanted. Sometimes
    it's not easy or quick to get to the breakpoint, so think carefully before placing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing is where to start. Imagine that you have 100 lines of
    code that handle your data. Data comes in at line 1, and somehow it's wrong at
    line 100\. You don't know where the bug is, so what do you do? You can place a
    breakpoint at line 1 and patiently go through all the lines, checking your data.
    In the worst case scenario, 99 lines (and many cups of coffee) later, you spot
    the bug. So, consider using a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: You start at line 50, and inspect. If the data is good, it means the bug happens
    later, in which case you place your next breakpoint at line 75\. If the data at
    line 50 is already bad, you go on by placing a breakpoint at line 25\. Then, you
    repeat. Each time, you move either backward or forward, by half the jump you did
    last time.
  prefs: []
  type: TYPE_NORMAL
- en: In our worst-case scenario, your debugging would go from 1, 2, 3, ..., 99, in
    a linear fashion, to a series of jumps such as 50, 75, 87, 93, 96, ..., 99 which
    is way faster. In fact, it's logarithmic. This searching technique is called **binary
    search**, it's based on a divide-and-conquer approach, and it's very effective,
    so try to master it.
  prefs: []
  type: TYPE_NORMAL
- en: Using tests to debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, about tests? Well, if we have
    a bug and all tests are passing, it means something is wrong or missing in our
    test code base. So, one approach is to modify the tests in such a way that they
    cater for the new edge case that has been spotted, and then work your way through
    the code. This approach can be very beneficial, because it makes sure that your
    bug will be covered by a test when it's fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring is also very important. Software applications can go completely crazy
    and have non-deterministic hiccups when they encounter edge-case situations such
    as the network being down, a queue being full, or an external component being
    unresponsive. In these cases, it's important to have an idea of what the big picture
    was when the problem occurred and be able to correlate it to something related
    to it in a subtle, perhaps mysterious way.
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor API endpoints, processes, web pages availability and load times,
    and basically almost everything that you can code. In general, when starting an
    application from scratch, it can be very useful to design it keeping in mind how
    you want to monitor it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we looked at different techniques and suggestions for
    debugging and troubleshooting our code. Debugging is an activity that is always
    part of a software developer's work, so it's important to be good at it.
  prefs: []
  type: TYPE_NORMAL
- en: If approached with the correct attitude, it can be fun and rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: We explored techniques to inspect our code base on functions, logging, debuggers,
    traceback information, profiling, and assertions. We saw simple examples of most
    of them and we also talked about a set of guidelines that will help when it comes
    to facing the fire.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember always to *stay calm and focused*, and debugging will be much
    easier. This too, is a skill that needs to be learned and it's the most important.
    An agitated and stressed mind cannot work properly, logically, and creatively,
    therefore, if you don't strengthen it, it will be hard for you to put all of your
    knowledge to good use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore GUIs and scripts, taking an interesting
    detour from the more common web-application scenario.
  prefs: []
  type: TYPE_NORMAL

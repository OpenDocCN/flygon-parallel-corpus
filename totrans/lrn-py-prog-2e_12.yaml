- en: GUIs and Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A user interface is like a joke. If you have to explain it, it''s not that
    good."– Martin LeBlanc'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to work on a project together. We are going to
    write a simple scraper that finds and saves images from a web page. We''ll focus
    on three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple HTTP webserver in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A script that scrapes a given URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GUI application that scrapes a given URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **graphical user interface** (**GUI**) is a type of interface that allows
    the user to interact with an electronic device through graphical icons, buttons,
    and widgets, as opposed to text-based or command-line interfaces, which require
    commands or text to be typed on the keyboard. In a nutshell, any browser, any
    office suite such as LibreOffice, and, in general, anything that pops up when
    you click on an icon, is a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you haven''t already done so, this would be the perfect time to start
    a console and position yourself in a folder called `ch12` in the root of your
    project for this book. Within that folder, we''ll create two Python modules (`scrape.py`
    and `guiscrape.py`) and a folder (`simple_server`). Within `simple_server`, we''ll
    write our HTML page: `index.html`. Images will be stored in `simple_server/img`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure in `ch12` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you're using either Linux or macOS, you can do what I do and put the code
    to start the HTTP server in a `serve.sh` file. On Windows, you'll probably want
    to use a batch file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML page we''re going to scrape has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It's an extremely simple page, so let's just note that we have five images,
    three of which are PNGs and two of which are JPGs (note that even though they
    are both JPGs, one ends with `.jpg` and the other with `.jpeg`, which are both
    valid extensions for this format).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Python gives you a very simple HTTP server for free that you can start
    with the following command (in the `simple_server` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is the log you get when you access `http://localhost:8000`, where
    our beautiful page will be served. Alternatively, you can put that command in
    a file called `serve.sh`, and just run that with this command (make sure it''s
    executable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will have the same effect. If you have the code for this book, your page
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to use any other set of images, as long as you use at least one PNG
    and one JPG, and that in the `src` tag you use relative paths, not absolute ones.
    I got these lovely owls from [https://openclipart.org/](https://openclipart.org/).
  prefs: []
  type: TYPE_NORMAL
- en: First approach – scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s start writing the script. I''ll go through the source in three
    steps: imports, arguments parsing, and business logic.'
  prefs: []
  type: TYPE_NORMAL
- en: The imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how the script starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Going through them from the top, you can see that we'll need to parse the arguments,
    which we'll feed to the script itself (`argparse`). We will need the `base64`
    library to save the images within a JSON file (`json`), and we'll need to open
    files for writing (`os`). Finally, we'll need `BeautifulSoup` for scraping the
    web page easily, and `requests` to fetch its content. I assume you're familiar
    with `requests` as we have used it in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the HTTP protocol and the `requests` mechanism in [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Web Development*, so for now, let's just (simplistically) say that we perform
    an HTTP request to fetch the content of a web page. We can do it programmatically
    using a library, such as `requests`, and it's more or less the equivalent of typing
    a URL in your browser and pressing *Enter* (the browser then fetches the content
    of a web page and displays it to you).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all these imports, only the last two don''t belong to the Python standard
    library, so make sure you have them installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the version numbers might be different for you. If they''re not
    installed, use this command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the only thing that I reckon might confuse you is the `base64/json`
    couple, so allow me to spend a few words on that.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, JSON is one of the most popular formats for
    data exchange between applications. It's also widely used for other purposes too,
    for example, to save data in a file. In our script, we're going to offer the user
    the ability to save images as image files, or as a JSON single file. Within the
    JSON, we'll put a dictionary with keys as the image names and values as their
    content. The only issue is that saving images in the binary format is tricky,
    and this is where the `base64` library comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: The `base64` library is actually quite useful. For example, every time you send
    an email with an image attached to it, the image gets encoded with `base64` before
    the email is sent. On the recipient side, images are automatically decoded into
    their original binary format so that the email client can display them.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the technicalities are out of the way, let''s see the second section
    of our script (it should be at the end of the `scrape.py` module):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Look at that first line; it is a very common idiom when it comes to scripting.
    According to the official Python documentation, the `'__main__'` string is the
    name of the scope in which top-level code executes. A module's `__name__` is set
    equal to `'__main__'` when read from standard input, a script, or from an interactive
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you put the execution logic under that `if`, it will be run only
    when you run the script directly, as its `__name__` will be `'__main__'`. On the
    other hand, should you import from this module, then its name will be set to something
    else, so the logic under the `if` won't run.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is define our parser. I would recommend using the standard
    library module, `argparse`, which is simple enough and quite powerful. There are
    other options out there, but in this case, `argparse` will provide us with all
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to feed our script three different pieces of data: the types of images
    we want to save, the format in which we want to save them, and the URL for the
    page to be scraped.'
  prefs: []
  type: TYPE_NORMAL
- en: The types can be PNGs, JPGs, or both (default), while the format can be either
    image or JSON, image being the default. URL is the only mandatory argument.
  prefs: []
  type: TYPE_NORMAL
- en: So, we add the `-t` option, allowing also the long version, `--type`. The choices
    are `'all'`, `'png'`, and `'jpg'`. We set the default to `'all'` and we add a
    `help` message.
  prefs: []
  type: TYPE_NORMAL
- en: We do a similar procedure for the `format` argument, allowing both the short
    and long syntax (`-f` and `--format`), and finally we add the `url` argument,
    which is the only one that is specified differently so that it won't be treated
    as an option, but rather as a positional argument.
  prefs: []
  type: TYPE_NORMAL
- en: In order to parse all the arguments, all we need is `parser.parse_args()`. Very
    simple, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line is where we trigger the actual logic, by calling the `scrape`
    function, passing all the arguments we just parsed. We will see its definition
    shortly. The nice thing about `argparse` is that if you call the script by passing
    `-h`, it will print a nice usage text for you automatically. Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you think about it, the one true advantage of this is that we just need to
    specify the arguments and we don't have to worry about the usage text, which means
    we won't have to keep it in sync with the arguments' definition every time we
    change something. This is precious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few different ways to call our `scrape.py` script, which demonstrate
    that `type` and `format` are optional, and how you can use the short and long
    syntaxes to employ them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first one is using default values for `type` and `format`. The second one
    will save only PNG images, and the third one will save only JPGs, but in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the scaffolding, let''s deep dive into the actual logic
    (if it looks intimidating, don''t worry; we''ll go through it together). Within
    the script, this logic lies after the imports and before the parsing (before the
    `if __name__` clause):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the `scrape` function. The first thing it does is fetch the
    page at the given `url` argument. Whatever error may happen while doing this,
    we trap it in `RequestException` (`err`) and print it. `RequestException` is the
    base exception class for all the exceptions in the `requests` library.
  prefs: []
  type: TYPE_NORMAL
- en: However, if things go well, and we have a page back from the `GET` request,
    then we can proceed (`else` branch) and feed its content to the `BeautifulSoup`
    parser. The `BeautifulSoup` library allows us to parse a web page in no time,
    without having to write all the logic that would be needed to find all the images
    in a page, which we really don't want to do. It's not as easy as it seems, and
    reinventing the wheel is never good. To fetch images, we use the `_fetch_images`
    function and we filter them with `_filter_images`. Finally, we call `_save` with
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Splitting the code into different functions with meaningful names allows us
    to read it more easily. Even if you haven''t seen the logic of the `_fetch_images`,
    `_filter_images`, and `_save` functions, it''s not hard to predict what they do,
    right? Check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`_fetch_images` takes a `BeautifulSoup` object and a base URL. All it does
    is loop through all of the images found on the page and fill in the `name` and
    `url` information about them in a dictionary (one per image). All dictionaries
    are added to the `images` list, which is returned at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: There is some trickery going on when we get the name of an image. We split the
    `img_url` (`http://localhost:8000/img/my_image_name.png`) string using `'/'` as
    a separator, and we take the last item as the image name. There is a more robust
    way of doing this, but for this example it would be overkill. If you want to see
    the details of each step, try to break this logic down into smaller steps, and
    print the result of each of them to help yourself understand. Toward the end of
    the book, I'll show you another technique for debugging in a much more efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, by just adding `print(images)` at the end of the `_fetch_images` function,
    we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I truncated the result for brevity. You can see each dictionary has a `url` and
    `name` key/value pair, which we can use to fetch, identify, and save our images
    as we like. At this point, I hear you asking what would happen if the images on
    the page were specified with an absolute path instead of a relative one, right?
    Good question!
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the script will fail to download them because this logic
    expects relative paths. I was about to add a bit of logic to solve this issue
    when I thought that, at this stage, it would be a nice exercise for you to do
    it, so I'll leave it up to you to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Inspect the start of that `src` variable. If it starts with `''http''`,
    it''s probably an absolute path. You might also want to checkout `urllib.parse`
    to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope the body of the `_filter_images` function is interesting to you. I wanted
    to show you how to check on multiple extensions using a mapping technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this function, if `type_` is `all`, then no filtering is required, so we
    just return all the images. On the other hand, when `type_` is not `all`, we get
    the allowed extensions from the `ext_map` dictionary, and use it to filter the
    images in the list comprehension that ends the function body. You can see that
    by using another helper function, `_matches_extension`, I have made the list comprehension
    simpler and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: All `_matches_extension` does is split the name of the image getting its extension
    and check whether it is within the list of allowed ones. Can you find one micro-improvement
    (speed-wise) that could be made to this function?
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you''re wondering why I have collected all the images in the list
    and then removed them, instead of checking whether I wanted to save them before
    adding them to the list. The first reason is that I needed `_fetch_images` in
    the GUI application as it is now. The second reason is that combining, fetching,
    and filtering would produce a longer and more complicated function, and I''m trying
    to keep the complexity level down. The third reason is that this could be a nice
    exercise for you to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's keep going through the code and inspect the `_save` function. You can
    see that, when `images` isn't empty, this basically acts as a dispatcher. We either
    call `_save_images` or `_save_json`, depending on what information is stored in
    the `format_` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done. Let's jump to `_save_images`. We loop on the `images` list
    and for each dictionary we find there, we perform a `GET` request on the image
    URL and save its content in a file, which we name as the image itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s now step into the `_save_json` function. It''s very similar
    to the previous one. We basically fill in the `data` dictionary. The image name
    is the *key*, and the Base64 representation of its binary content is the *value*.
    When we''re done populating our dictionary, we use the `json` library to dump
    it in the `images.json` file. I''ll give you a small preview of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Now, before proceeding to the next section, make sure you play
    with this script and understand how it works. Try to modify something, print out
    intermediate results, add a new argument or functionality, or scramble the logic.
    We're going to migrate it into a GUI application now, which will add a layer of
    complexity simply because we'll have to build the GUI interface, so it's important
    that you're well acquainted with the business logic—it will allow you to concentrate
    on the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – a GUI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several libraries that write GUI applications in Python. The most
    famous ones are **Tkinter**, **wxPython**, **PyGTK**, and **PyQt**. They all offer
    a wide range of tools and widgets that you can use to compose a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: The one I'm going to use for the rest of this chapter is Tkinter. **Tkinter**
    stands for **Tk interface** and it is the standard Python interface to the Tk
    GUI toolkit. Both Tk and Tkinter are available on most Unix platforms, macOS X,
    as well as on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that `tkinter` is installed properly on your system by running
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It should open a dialog window, demonstrating a simple `Tk` interface. If you
    can see that, we're good to go. However, if it doesn't work, please search for
    `tkinter` in the Python official documentation ([https://docs.python.org/3.7/library/tkinter.html](https://docs.python.org/3.7/library/tkinter.html)).
    You will find several links to resources that will help you get up and running
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to make a very simple GUI application that basically mimics the
    behavior of the script we saw in the first part of this chapter. We won't add
    the ability to save JPGs or PNGs singularly, but after you've gone through this
    chapter, you should be able to play with the code and put that feature back in
    by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is what we''re aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Gorgeous, isn't it? As you can see, it's a very simple interface (this is how
    it should look on a mac). There is a frame (that is, a container) for the URL
    field and the Fetch info button, another frame for the **Listbox** (Content) to
    hold the image names and the radio button to control the way we save them, and
    finally there is a Scrape! button at the bottom. We also have a status bar, which
    shows us some information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get this layout, we could just place all the widgets on a root
    window, but that would make the layout logic quite messy and unnecessarily complicated.
    So, instead, we will divide the space using frames and place the widgets in those
    frames. This way we will achieve a much nicer result. So, this is the draft for
    the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have a **Root Window**, which is the main window of the application. We divide
    it into two rows, the first one in which we place the **Main Frame**, and the
    second one in which we place the **Status Frame** (which will hold the status
    bar text). The **Main Frame** is subsequently divided into three rows. In the
    first one, we place the **URL Frame**, which holds the **URL** widgets. In the
    second one, we place the **Img Frame**, which will hold the **Listbox** and the
    **Radio Frame**, which will host a label and the radio button widgets. And finally
    we have the third one, which will just hold the **Scrape** button.
  prefs: []
  type: TYPE_NORMAL
- en: In order to lay out frames and widgets, we will use a layout manager, called
    **grid**, that simply divides up the space into rows and columns, as in a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all the code I''m going to write comes from the `guiscrape.py` module,
    so I won''t repeat its name for each snippet, to save space. The module is logically
    divided into three sections, not unlike the script version: imports, layout logic,
    and business logic. We''re going to analyze them line by line, in three chunks.'
  prefs: []
  type: TYPE_NORMAL
- en: The imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imports are like in the script version, except we''ve lost `argparse`, which
    is no longer needed, and we have added two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first line is quite common practice when dealing with `tkinter`, although
    in general it is bad practice to import using the `*` syntax*.* You can incur
    in name collisions and, if the module is too big, importing everything would be
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we import `ttk`, `filedialog`, and `messagebox` explicitly, following
    the conventional approach used with this library. `ttk` is the new set of styled
    widgets. They behave basically like the old ones, but are capable of drawing themselves
    correctly according to the style your OS is set on, which is nice.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the imports (omitted) is what we need in order to carry out the
    task you know well by now. Note that there is nothing we need to install with
    `pip` in this second part; we already have everything we need.
  prefs: []
  type: TYPE_NORMAL
- en: The layout logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to paste it chunk by chunk so that I can explain it easily to you.
    You''ll see how all those pieces we talked about in the layout draft are arranged
    and glued together. What I''m about to paste, as we did in the script before,
    is the final part of the `guiscrape.py` module. We''ll leave the middle part,
    the business logic, for last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you know by now, we only want to execute the logic when the module is run
    directly, so that first line shouldn't surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last two lines, we set up the main window, which is an instance of the
    `Tk` class. We instantiate it and give it a title. Note that I use the prepending
    underscore technique for all the names of the `tkinter` objects, in order to avoid
    potential collisions with names in the business logic. I just find it cleaner
    like this, but you''re allowed to disagree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set up the **Main Frame**. It's a `ttk.Frame` instance. We set `_root`
    as its parent, and give it some `padding`. The `padding` is a measure in pixels
    of how much space should be inserted between the inner content and the borders
    in order to let our layout breathe a little, otherwise we have a *sardine effect*,
    where widgets are packed too tightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line is more interesting. We place this `_mainframe` on the first
    `row` (`0`) and first `column` (`0`) of the parent object (`_root`). We also say
    that this frame needs to extend itself in each direction by using the `sticky`
    argument with all four cardinal directions. If you''re wondering where they came
    from, it''s the `from tkinter import *` magic that brought them to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we start by placing the **URL Frame** down. This time, the parent object
    is `_mainframe`, as you will recall from our draft. This is not just a simple
    `Frame`, it's actually a `LabelFrame`, which means we can set the text argument
    and expect a rectangle to be drawn around it, with the content of the text argument
    written in the top-left part of it (check out the previous picture if it helps).
    We position this frame at (`0`, `0`), and say that it should expand to the left
    and to the right. We don't need the other two directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use `rowconfigure` and `columnconfigure` to make sure it behaves
    correctly, should it need to resize. This is just a formality in our present layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the code to lay out the URL textbox and the `_fetch` button. A
    textbox in this environment is called `Entry`. We instantiate it as usual, setting
    `_url_frame` as its parent and giving it a width. Also, and this is the most interesting
    part, we set the `textvariable` argument to be `_url`. `_url` is a `StringVar`,
    which is an object that is now connected to `Entry` and will be used to manipulate
    its content. Therefore, we don't modify the text in the `_url_entry` instance
    directly, but by accessing `_url`. In this case, we call the `set` method on it
    to set the initial value to the URL of our local web page.
  prefs: []
  type: TYPE_NORMAL
- en: We position `_url_entry` at (`0`, `0`), setting all four cardinal directions
    for it to stick to, and we also set a bit of extra padding on the left and right
    edges using `padx`, which adds padding on the *x*-axis (horizontal). On the other
    hand, `pady` takes care of the vertical direction.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should get that every time you call the `.grid` method on an object,
    we're basically telling the grid layout manager to place that object somewhere,
    according to rules that we specify as arguments in the `grid()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we set up and place the `_fetch` button. The only interesting parameter
    is `command=fetch_url`. This means that when we click this button, we call the
    `fetch_url` function. This technique is called **callback**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we called **Img Frame** in the layout draft. It is placed on the
    second row of its parent `_mainframe`. It will hold the **Listbox** and the **Radio
    Frame**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the most interesting bit of the whole layout logic. As we did
    with `_url_entry`, we need to drive the contents of `Listbox` by tying it to an `_images` variable.
    We set up `Listbox` so that `_img_frame` is its parent, and `_images` is the variable
    it's tied to. We also pass some dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting bit comes from the `_scrollbar` instance. Note that, when we
    instantiate it, we set its command to `_img_listbox.yview`. This is the first
    half of the contract between `Listbox` and `Scrollbar`. The other half is provided
    by the `_img_listbox.configure` method, which sets `yscrollcommand=_scrollbar.set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By providing this reciprocal bond, when we scroll on `Listbox`, `Scrollbar`
    will move accordingly and vice versa, when we operate `Scrollbar`, `Listbox` will
    scroll accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We place the **Radio Frame**, ready to be populated. Note that `Listbox` is
    occupying (`0`, `0`) on `_img_frame`, `Scrollbar` (`0`, `1`), and therefore `_radio_frame`
    will go in (`0`, `2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we place the label, and we give it some padding. Note that the label
    and radio buttons are children of `_radio_frame`.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `Entry` and `Listbox` objects, `Radiobutton` is also driven by a
    bond to an external variable, which I called `_save_method`. Each `Radiobutton`
    instance sets a value argument, and by checking the value on `_save_method`, we
    know
  prefs: []
  type: TYPE_NORMAL
- en: 'which button is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On the third row of `_mainframe` we place the **Scrape** button. Its `command`
    is `save`, which saves the images to be listed in `Listbox`, after we have successfully
    parsed a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We end the layout section by placing down the status frame, which is a simple
    `ttk.Frame`. To give it a little status bar effect, we set its `relief` property
    to `'sunken'` and give it a uniform padding of two pixels. It needs to stick to
    the left, right, and bottom parts of the `_root` window, so we set its `sticky`
    attribute to `(E, W, S)`.
  prefs: []
  type: TYPE_NORMAL
- en: We then place a label in it and, this time, we tie it to a `StringVar` object,
    because we will have to modify it every time we want to update the status bar
    text. You should be acquainted with this technique by now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, on the last line, we run the application by calling the `mainloop`
    method on the `Tk` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Please remember that all these instructions are placed under the `if __name__
    == "__main__":` clause in the original script.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the code to design our GUI application is not hard. Granted,
    at the beginning, you have to play around a little bit. Not everything will work
    out perfectly at the first attempt, but I promise you it's very easy and you can
    find plenty of tutorials on the web. Let's now get to the interesting bit, the
    business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll analyze the business logic of the GUI application in three chunks. There
    is the fetching logic, the saving logic, and the alerting logic.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the code to fetch the page and images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First of all, let me explain that `config` dictionary. We need some way of passing
    data between the GUI application and the business logic. Now, instead of polluting
    the global namespace with many different variables, my personal preference is
    to have a single dictionary that holds all the objects we need to pass back and
    forth, so that the global namespace isn't clogged up with all those names, and
    we have a single, clean, easy way of knowing where all the objects that are needed
    by our application are.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, we'll just populate the `config` dictionary with the
    images we fetch from the page, but I wanted to show you the technique so that
    you have at least one example. This technique comes from my experience with JavaScript.
    When you code a web page, you often import several different libraries. If each
    of these cluttered the global namespace with all sorts of variables, there might
    be issues in making everything work, because of name clashes and variable overriding.
  prefs: []
  type: TYPE_NORMAL
- en: So, it's much better to leave the global namespace as clean as we can. In this
    case, I find that using one `config` variable is more than acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch_url` function is quite similar to what we did in the script. First,
    we get the `url` value by calling `_url.get()`. Remember that the `_url` object
    is a `StringVar` instance that is tied to the `_url_entry` object, which is an
    `Entry`. The text field you see on the GUI is the `Entry`, but the text behind
    the scenes is the value of the `StringVar` object.
  prefs: []
  type: TYPE_NORMAL
- en: By calling `get()` on `_url`, we get the value of the text, which is displayed
    in `_url_entry`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to prepare `config['images']` to be an empty list, and to empty
    the `_images` variable, which is tied to `_img_listbox`. This, of course, has
    the effect of cleaning up all the items in `_img_listbox`.
  prefs: []
  type: TYPE_NORMAL
- en: After this preparation step, we can try to fetch the page, using the same `try`/`except`
    logic we adopted in the script at the beginning of the chapter. The one difference
    is the action we take if things go wrong. We call `_sb(str(err))`. `_sb` is a
    helper function whose code we'll see shortly. Basically, it sets the text in the
    status bar for us. Not a good name, right? I had to explain its behavior to you–food
    for thought.
  prefs: []
  type: TYPE_NORMAL
- en: If we can fetch the page, then we create the `soup` instance, and fetch the
    images from it. The logic of `fetch_images` is exactly the same as the one explained
    before, so I won't repeat myself here.
  prefs: []
  type: TYPE_NORMAL
- en: If we have images, using a quick tuple comprehension (which is actually a generator
    expression fed to a tuple constructor) we feed the `_images` as `StringVar` and
    this has the effect of populating our `_img_listbox` with all the image names.
    Finally, we update the status bar.
  prefs: []
  type: TYPE_NORMAL
- en: If there were no images, we still update the status bar, and at the end of the
    function, regardless of how many images were found, we update `config['images']`
    to hold the `images` list. In this way, we'll be able to access the images from
    other functions by inspecting `config['images']` without having to pass that list
    around.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logic to save the images is pretty straightforward. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks the Scrape! button, the `save` function is called using
    the callback mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that this function does is check whether there are actually
    any images to be saved. If not, it alerts the user about it, using another helper
    function, `_alert`, whose code we'll see shortly. No further action is performed
    if there are no images.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the `config['images']` list is not empty, `save` acts
    as a dispatcher, and it calls `_save_images` or `_save_json`, according to which
    value is held by `_same_method`. Remember, this variable is tied to the radio
    buttons, therefore we expect its value to be either `'img'` or `'json'`.
  prefs: []
  type: TYPE_NORMAL
- en: This dispatcher is a bit different from the one in the script. According to
    which method we have selected, a different action must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to save the images as images, we need to ask the user to choose a
    directory. We do this by calling `filedialog.askdirectory` and assigning the result
    of the call to the `dirname` variable. This opens up a nice dialog window that
    asks us to choose a directory. The directory we choose must exist, as specified
    by the way we call the method. This is done so that we don't have to write code
    to deal with a potentially missing directory when saving the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how this dialog should look on a mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we cancel the operation, `dirname` will be set to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Before finishing analyzing the logic in `save`, let's quickly go through `_save_images`.
  prefs: []
  type: TYPE_NORMAL
- en: It's very similar to the version we had in the script so just note that, at
    the beginning, in order to be sure that we actually have something to do, we check
    on both `dirname` and the presence of at least one image in `config['images']`.
  prefs: []
  type: TYPE_NORMAL
- en: If that's the case, it means we have at least one image to save and the path
    for it, so we can proceed. The logic to save the images has already been explained.
    The one thing we do differently this time is join the directory (which means the
    complete path) to the image name, by means of `os.path.join`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of `_save_images`, if we saved at least one image, we alert the user
    that we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back now to the other branch in `save`. This branch is executed when
    the user selects the As JSON radio button before pressing the Scrape button. In
    this case, we want to save a file; therefore, we cannot just ask for a directory.
    We want to give the user the ability to choose a filename as well. Hence, we fire
    up a different dialog: `filedialog.asksaveasfilename`.'
  prefs: []
  type: TYPE_NORMAL
- en: We pass an initial filename, which is proposed to the user–they have the ability
    to change it if they don't like it. Moreover, because we're saving a JSON file,
    we're forcing the user to use the correct extension by passing the `filetypes`
    argument. It is a list, with any number of two-tuples *(description, extension),*
    that runs the logic of the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how this dialog should look on a macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we have chosen a place and a filename, we can proceed with the saving logic,
    which is the same as it was in the previous script. We create a JSON object from
    a Python dictionary (`data`) that we populate with key/value pairs made by the
    `images` name and Base64-encoded content.
  prefs: []
  type: TYPE_NORMAL
- en: In `_save_json` as well, we have a little check at the beginning that makes
    sure that we don't proceed unless we have a filename and at least one image to
    save. This ensures that if the user presses the Cancel button, nothing bad happens.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s see the alerting logic. It''s extremely simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it! To change the status bar message all we need to do is to access `_status_msg`
    `StringVar`, as it's tied to the `_status` label.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we want to show the user a more visible message, we can
    fire up a message box. Here''s how it should look on a mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `messagebox` object can also be used to warn the user (`messagebox.showwarning`)
    or to signal an error (`messagebox.showerror`). But it can also be used to provide
    dialogs that ask us whether we're sure we want to proceed or if we really want
    to delete that file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect `messagebox` by simply printing out what `dir(messagebox)` returns,
    you'll find methods such as `askokcancel`, `askquestion`, `askretrycancel`, `askyesno`,
    and `askyesnocancel`, as well as a set of constants to verify the response of
    the user, such as `CANCEL`, `NO`, `OK`, `OKCANCEL`, `YES`, and `YESNOCANCEL`.
    You can compare these to the user's choice so that you know the next action to
    execute when the dialog closes.
  prefs: []
  type: TYPE_NORMAL
- en: How can we improve the application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you're accustomed to the fundamentals of designing a GUI application,
    I'd like to give you some suggestions on how to make ours better.
  prefs: []
  type: TYPE_NORMAL
- en: We can start with the code quality. Do you think this code is good enough, or
    would you improve it? If so, how? I would test it, and make sure it's robust and
    caters for all the various scenarios that a user might create by clicking around
    on the application. I would also make sure the behavior is what I would expect
    when the website we're scraping is down for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we could improve is the naming. I have prudently named all
    the components with a leading underscore, both to highlight their somewhat *private*
    nature, and to avoid having name clashes with the underlying objects they are
    linked to. But in retrospect, many of those components could use a better name,
    so it's really up to you to refactor until you find the form that suits you best.
    You could start by giving a better name to the `_sb` function!
  prefs: []
  type: TYPE_NORMAL
- en: For what concerns the user interface, you could try to resize the main application.
    See what happens? The whole content stays exactly where it is. Empty space is
    added if you expand, or the whole widgets set disappears gradually if you shrink.
    This behavior isn't exactly nice, therefore one quick solution could be to make
    the root window fixed (that is, unable to resize).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that you could do to improve the application is to add the same
    functionality we had in the script, to save only PNGs or JPGs. In order to do
    this, you could place a combo box somewhere, with three values: All, PNGs, JPGs,
    or something similar. The user should be able to select one of those options before
    saving the files.'
  prefs: []
  type: TYPE_NORMAL
- en: Even better, you could change the declaration of `Listbox` so that it's possible
    to select multiple images at the same time, and only the selected ones will be
    saved. If you manage to do this (it's not as hard as it seems, believe me), then
    you should consider presenting the `Listbox` a bit better, maybe providing alternating
    background colors for the rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice thing you could add is a button that opens up a dialog to select
    a file. The file must be one of the JSON files the application can produce. Once
    selected, you could run some logic to reconstruct the images from their Base64-encoded
    version. The logic to do this is very simple, so here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need to open `images.json` in read mode, and grab the `data`
    dictionary. Once we have it, we can loop through its items, and save each image
    with the Base64-decoded content. I'll leave it up to you to tie this logic to
    a button in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool feature that you could add is the ability to open up a preview
    pane that shows any image you select from `Listbox`, so that the user can take
    a peek at the images before deciding to save them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one last suggestion for this application is to add a menu. Maybe even
    a simple menu with File and ? to provide the usual Help or About. Just for fun.
    Adding menus is not that complicated; you can add text, keyboard shortcuts, images,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Where do we go from here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in digging deeper into the world of GUIs, then I'd like
    to offer you the following suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: The turtle module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `turtle` module is an extended reimplementation of the eponymous module
    from the Python standard distribution up to version Python 2.5\. It's a very popular
    way to introduce children to programming.
  prefs: []
  type: TYPE_NORMAL
- en: It's based on the idea of an imaginary turtle starting at (0, 0) in the Cartesian
    plane. You can programmatically command the turtle to move forward and backward,
    rotate, and so on; by combining all the possible moves, all sorts of intricate
    shapes and images can be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely worth checking out, if only to see something different.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython, PyQt, and PyGTK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have explored the vastness of the `tkinter` realm, I''d suggest you
    explore other GUI libraries: wxPython ([https://www.wxpython.org/](https://www.wxpython.org/)),
    PyQt ([https://riverbankcomputing.com/software/pyqt/intro](https://riverbankcomputing.com/software/pyqt/intro)),
    and PyGTK ([https://pygobject.readthedocs.io/en/latest/](https://pygobject.readthedocs.io/en/latest/)).
    You may find out one of these works better for you, or it makes it easier for
    you to code the application you need.'
  prefs: []
  type: TYPE_NORMAL
- en: I believe that coders can realize their ideas only when they are conscious of
    what tools they have available. If your toolset is too narrow, your ideas may
    seem impossible or extremely hard to realize, and they risk remaining exactly
    what they are, just ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the technological spectrum today is humongous, so knowing everything
    is not possible; therefore, when you are about to learn a new technology or a
    new subject, my suggestion is to grow your knowledge by exploring breadth first.
  prefs: []
  type: TYPE_NORMAL
- en: Investigate several things, and then go deep with the one or the few that looked
    most promising. This way you'll be able to be productive with at least one tool,
    and when the tool no longer fits your needs, you'll know where to dig deeper,
    thanks to your previous exploration.
  prefs: []
  type: TYPE_NORMAL
- en: The principle of least astonishment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing an interface, there are many different things to bear in mind.
    One of them, which for me is the most important, is the law or **principle of
    least astonishment**. It basically states that if in your design a necessary feature
    has a high astonishing factor, it may be necessary to redesign your application.
    To give you one example, when you're used to working with Windows, where the buttons
    to minimize, maximize, and close a window are on the top-right corner, it's quite
    hard to work on Linux, where they are at the top-left corner. You'll find yourself
    constantly going to the top-right corner only to discover once more that the buttons
    are on the other side.
  prefs: []
  type: TYPE_NORMAL
- en: If a certain button has become so important in applications that it's now placed
    in a precise location by designers, please don't innovate. Just follow the convention.
    Users will only become frustrated when they have to waste time looking for a button
    that is not where it's supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: The disregard for this rule is the reason why I cannot work with products such
    as Jira. It takes me minutes to do simple things that should require seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Threading considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic is outside the scope of this book, but I do want to mention it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coding a GUI application that needs to perform a long-running operation
    when a button is clicked, you will see that your application will probably freeze
    until the operation has been carried out. In order to avoid this, and maintain
    the application's responsiveness, you may need to run that time-expensive operation
    in a different thread (or even a different process) so that the OS will be able
    to dedicate a little bit of time to the GUI every now and then, to keep it responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Gain a good grasp of the fundamentals first, and then have fun exploring them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on a project together. We have written a script that
    scrapes a very simple web page and accepts optional commands that alter its behavior
    in doing so. We also coded a GUI application to do the same thing by clicking
    buttons instead of typing on a console. I hope you enjoyed reading it and following
    along as much as I enjoyed writing it.
  prefs: []
  type: TYPE_NORMAL
- en: We saw many different concepts, such as working with files and performing HTTP
    requests, and we talked about guidelines for usability and design.
  prefs: []
  type: TYPE_NORMAL
- en: I have only been able to scratch the surface, but hopefully you have a good
    starting point from which to expand your exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, I have pointed out several different ways you could
    improve the application, and I have challenged you with a few exercises and questions.
    I hope you have taken the time to play with those ideas. You can learn a lot just
    by playing around with fun applications like the one we've coded together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to talk about data science, or at least about
    the tools that a Python programmer has when it comes to facing this subject.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 5. Symfony at a Glance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。一览Symfony
- en: Full-stack frameworks like Symfony help ease the process of building modular
    applications by providing all of the necessary components, from user interface
    to data store. This enables a much rapid cycle of delivering individual bits and
    pieces of application as it grows. We will experience this later on by segmenting
    our application in several smaller modules, or bundles in Symfony terminology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 像Symfony这样的全栈框架有助于通过提供所有必要的组件，从用户界面到数据存储，来简化构建模块化应用程序的过程。这使得在应用程序增长时能够更快地交付各个部分。我们将通过将应用程序分割为几个较小的模块或Symfony术语中的bundle来体验到这一点。
- en: 'Moving forward we will install Symfony, create a blank project, and start looking
    into individual framework features essential for building modular application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装Symfony，创建一个空项目，并开始研究构建模块化应用程序所必需的各个框架特性：
- en: Controller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单
- en: The bundle system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bundle系统
- en: Databases and Doctrine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库和Doctrine
- en: Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Validation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Installing Symfony
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Symfony
- en: 'Installing Symfony is pretty straightforward. We can use the following command
    to install Symfony on Linux or Mac OS X:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Symfony非常简单。我们可以使用以下命令在Linux或Mac OS X上安装Symfony：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use the following command to install Symfony on Windows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令在Windows上安装Symfony：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the command is executed, we can simply move the newly created `symfony`
    file to our project directory and execute it further as `symfony`, or `php symfony`
    in Windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令后，我们可以简单地将新创建的`symfony`文件移动到我们的项目目录，并在Windows中进一步执行它作为`symfony`或`php symfony`。
- en: 'This should trigger an output shown as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该触发以下输出：
- en: '![Installing Symfony](graphics/B05460_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![安装Symfony](graphics/B05460_05_01.jpg)'
- en: Preceding response indicates we have successfully setup Symfony and are now
    ready to start creating new projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应表明我们已经成功设置了Symfony，现在准备开始创建新项目。
- en: Creating a blank project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个空项目
- en: 'Now that we have a Symfony installer all setup, let''s go ahead and create
    a new blank project. We do so by simply executing a `symfony new test-app` command,
    as shown in the following command line instance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置好了Symfony安装程序，让我们继续创建一个新的空项目。我们只需执行`symfony new test-app`命令，如下面的命令行示例所示：
- en: '![Creating a blank project](graphics/B05460_05_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个空项目](graphics/B05460_05_02.jpg)'
- en: Here we are creating a new project, called `test-app`. We can see that the Symfony
    installer is downloading the latest Symfony framework from the internet, alongside
    outputting a brief instruction on how to run the built in PHP server via Symfony
    console application. The whole process might take up to a few minutes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为`test-app`的新项目。我们可以看到Symfony安装程序正在从互联网下载最新的Symfony框架，并输出一个简要的指令，说明如何通过Symfony控制台应用程序运行内置的PHP服务器。整个过程可能需要几分钟。
- en: 'The structure of newly created `test-app` directory occurs similar to the following
    one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的`test-app`目录的结构与以下类似：
- en: '![Creating a blank project](graphics/B05460_05_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个空项目](graphics/B05460_05_03.jpg)'
- en: 'There are numerous files and directories created here for us. Our interest,
    however, is focused on `app` and `src` directories. The `app` directory is where
    the site wide application configuration resides. Here we can find configuration
    for database, routing, security, and other services. Also, this is where default
    layout and template file reside, as shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里为我们创建了许多文件和目录。然而，我们感兴趣的是`app`和`src`目录。`app`目录是整个站点应用程序配置的所在地。在这里，我们可以找到数据库、路由、安全和其他服务的配置。此外，这也是默认布局和模板文件所在的地方，如下面的截图所示：
- en: '![Creating a blank project](graphics/B05460_05_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个空项目](graphics/B05460_05_04.jpg)'
- en: 'The `src` directory on the other hand contains already modularized code in
    form of the base `AppBundle` module, as in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`src`目录包含了已经模块化的代码，以`AppBundle`模块的形式，如下面的截图所示：
- en: '![Creating a blank project](graphics/B05460_05_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个空项目](graphics/B05460_05_05.jpg)'
- en: We are going to speak about the role of these files in more details later as
    we progress. For now, its worth nothing that pointing our browser to this project
    would make `DefaultController.php` the one to actually render the output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，我们将更详细地讨论这些文件的作用。目前，值得注意的是，将我们的浏览器指向这个项目会使`DefaultController.php`实际上渲染输出。
- en: Using Symfony console
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Symfony控制台
- en: 'Symfony framework comes with a built-in console tool that we can trigger by
    simply executing the following command within our project root directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony框架自带一个内置的控制台工具，我们可以通过在项目根目录中执行以下命令来触发它：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By doing so, an extensive list of available commands is shown on screen, sectioned
    into the following groups:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会在屏幕上显示一个可用命令的广泛列表，分为以下几组：
- en: '`assets`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资产`'
- en: '`cache`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`缓存`'
- en: '`config`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`配置`'
- en: '`debug`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调试`'
- en: '`doctrine`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctrine`'
- en: '`generate`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`生成`'
- en: '`lint`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lint`'
- en: '`orm`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orm`'
- en: '`router`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`路由`'
- en: '`security`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安全`'
- en: '`server`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`服务器`'
- en: '`swiftmailer`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swiftmailer`'
- en: '`translation`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`翻译`'
- en: These empower us with various functionalities. Our special interest moving forward
    is going to be around `doctrine` and `generate` commands. The `doctrine` command,
    more specifically `doctrine:generate:crud`, generates a CRUD based on an existing
    Doctrine entity. Furthermore, the `doctrine:generate:entity` command generates
    a new Doctrine entity inside an existing bundle. These can be extremely handy
    for cases where we want a quick and easy entity creation, alongside the entire
    CRUD around it. Similarly, `generate:doctrine:entity` and `generate:doctrine:crud`
    do the same thing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令赋予我们各种功能。我们未来特别感兴趣的是`doctrine`和`generate`命令。`doctrine`命令，特别是`doctrine:generate:crud`，基于现有的Doctrine实体生成一个CRUD。此外，`doctrine:generate:entity`命令在现有bundle中生成一个新的Doctrine实体。在我们需要快速轻松地创建实体以及围绕它的整个CRUD时，这些命令非常有用。同样，`generate:doctrine:entity`和`generate:doctrine:crud`也是如此。
- en: Before we go ahead and test these commands, we need to make sure we have our
    database configuration parameters in place so that Symfony can see and talk to
    our database. To do so, we need to set appropriate values in `app/config/parameters.yml`
    file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续测试这些命令之前，我们需要确保我们的数据库配置参数已经设置好，以便Symfony可以看到并与我们的数据库进行通信。为此，我们需要在`app/config/parameters.yml`文件中设置适当的值。
- en: 'For the purpose of this section, let''s go ahead and create a simple Customer
    entity within the default `AppBundle` bundle, with entire CRUD around it, assuming
    the following properties on Customer entity: `firstname`, `lastname`, and `e-mail`.
    We start by running the `php bin/console generate:doctrine:entity` command from
    within the project root directory, which results in the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本节的目的，让我们继续在默认的`AppBundle`包中创建一个简单的Customer实体，围绕它创建整个CRUD，假设Customer实体具有以下属性：`firstname`、`lastname`和`e-mail`。我们首先在项目根目录中运行`php
    bin/console generate:doctrine:entity`命令，结果如下输出：
- en: '![Using Symfony console](graphics/B05460_05_12.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_12.jpg)'
- en: Here we first provided `AppBundle:Customer` as entity name and confirmed the
    use of annotations as configuration format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先提供了`AppBundle:Customer`作为实体名称，并确认了注释作为配置格式的使用。
- en: 'Finally, we are asked to start adding the fields to our entity. Typing in the
    first name and hitting enter moves us through a series of short questions about
    our field type, length, nullable, and unique states, as shown in the following
    screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们被要求开始向我们的实体添加字段。输入名字并按回车键，将我们移动到一系列关于字段类型、长度、可空和唯一状态的简短问题，如下屏幕截图所示：
- en: '![Using Symfony console](graphics/B05460_05_11.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_11.jpg)'
- en: 'We should now have two classes generated for our Customer entity. Via the help
    of Symfony and Doctrine, these classes are put in context of **Object Relational
    Mapper** (**ORM**), as they link the Customer entity with the proper database
    table. However, we haven''t yet instructed Symfony to actually create the table
    for our entity. To do so, we execute the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该已经为我们的Customer实体生成了两个类。通过Symfony和Doctrine的帮助，这些类被放置在**对象关系映射器**（**ORM**）的上下文中，因为它们将Customer实体与适当的数据库表进行了关联。但是，我们还没有指示Symfony实际上为我们的实体创建表。为此，我们执行以下命令：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should produce the output as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下屏幕截图所示的输出：
- en: '![Using Symfony console](graphics/B05460_05_13.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_13.jpg)'
- en: 'If we now take a look at the database, we should see a `customer` table with
    all the proper columns created with SQL create dsyntax as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看数据库，应该会看到一个`customer`表，其中包含使用SQL创建dsyntax创建的所有正确列，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, we still do not have an actual CRUD functionality in place.
    We simply have an ORM empowered Customer entity class and appropriate database
    table behind it. The following command will generate the actual CRUD controllers
    and templates for us:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们仍然没有实际的CRUD功能。我们只是有一个经过ORM授权的Customer实体类和适当的数据库表。以下命令将为我们生成实际的CRUD控制器和模板：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should produce the following interactive output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下交互式输出：
- en: '![Using Symfony console](graphics/B05460_05_14.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_14.jpg)'
- en: 'By providing the fully classified entity name `AppBundle:Customer`, generator
    proceeds with a series of additional inputs, from generating write actions, type
    of configuration to read, to prefix of route, as shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供完全分类的实体名称`AppBundle:Customer`，生成器将继续一系列附加输入，从生成写操作、读取的配置类型到路由前缀，如下屏幕截图所示：
- en: '![Using Symfony console](graphics/B05460_05_15.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_15.jpg)'
- en: 'Once done, we should be able to access our Customer CRUD actions by simply
    opening a URL like `http://test.app/customer/` (assuming `test.app` is the host
    we set for our example) as shown:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们应该能够通过简单打开类似`http://test.app/customer/`的URL（假设`test.app`是我们设置的主机）来访问我们的Customer
    CRUD操作，如下所示：
- en: '![Using Symfony console](graphics/B05460_05_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_06.jpg)'
- en: 'If we click on the **Create a new entry** link, we will be redirected to the
    `/customer/new/` URL, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们单击**创建新条目**链接，我们将被重定向到`/customer/new/` URL，如下屏幕截图所示：
- en: '![Using Symfony console](graphics/B05460_05_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_07.jpg)'
- en: 'Here we can enter the actual values for our Customer entity and click **Create**
    button in order to persist it into the database `customer` table. After adding
    a few entities, the initial `/customer/` URL is now able to list them all, as
    shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以输入我们的Customer实体的实际值，并单击**Create**按钮，以将其持久化到数据库的`customer`表中。添加了一些实体后，初始的`/customer/`
    URL现在能够列出它们所有，如下屏幕截图所示：
- en: '![Using Symfony console](graphics/B05460_05_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_08.jpg)'
- en: 'Here we see links to **show** and **edit** actions. The **show** action is
    what we might consider the customer facing action, whereas the **edit** action
    is the administrator facing action. Clicking on the **edit** action, takes us
    to the URL of the form `/customer/1/edit/`, whereas number `1` in this case is
    the ID of customer entity in database:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了**显示**和**编辑**操作的链接。**显示**操作是我们可能考虑的面向客户的操作，而**编辑**操作是面向管理员的操作。单击**编辑**操作，将我们带到表单的URL`/customer/1/edit/`，而在这种情况下的数字`1`是数据库中客户实体的ID：
- en: '![Using Symfony console](graphics/B05460_05_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_09.jpg)'
- en: Here we can change the property values and click **Edit** to persist them back
    into the database, or we can click on the **Delete** button to remove the entity
    from the database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以更改属性值并单击**编辑**以将它们持久化到数据库中，或者我们可以单击**删除**按钮以从数据库中删除实体。
- en: 'If we were to create a new entity with an already existing e-mail, which is
    flagged as a unique field, the system would throw a generic error as such the
    following one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个具有已存在电子邮件的新实体，该电子邮件被标记为唯一字段，系统将抛出一个通用错误，如下所示：
- en: '![Using Symfony console](graphics/B05460_05_10.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台](graphics/B05460_05_10.jpg)'
- en: This is merely default system behavior, and as we progress further we will look
    into making this more user friendly. By now, we have seen how powerful Symfony's
    console is. With a few simple commands, we were able to create our entity and
    its entire CRUD actions. There is plenty more the console is capable of. We can
    even create our own console commands as we can implement any type of logic. However,
    for the purpose of our needs, current implementation will suffice for a moment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是默认的系统行为，随着我们的进展，我们将探讨如何使其更加用户友好。到目前为止，我们已经看到了Symfony控制台的强大之处。通过几个简单的命令，我们能够创建实体及其整个CRUD操作。控制台还有很多功能。我们甚至可以创建自己的控制台命令，因为我们可以实现任何类型的逻辑。然而，就我们的需求而言，当前的实现暂时足够了。
- en: Controller
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers play a major role in web applications by being at the forefront
    of any application output. They are the endpoints, the code that executes behind
    each URL. In a more technical manner, we can say the controller is any callable
    (a function, method on an object, or a closure) that takes the HTTP request and
    returns an HTTP response. The response is not bound to a single format like HTML,
    it can be anything from XML, JSON, CSV, image, redirect, error, and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器在Web应用程序中扮演着重要的角色，是任何应用程序输出的前沿。它们是端点，是在每个URL后面执行的代码。从技术上讲，我们可以说控制器是任何可调用的东西（函数、对象上的方法或闭包），它接受HTTP请求并返回HTTP响应。响应不限于单一格式，可以是XML、JSON、CSV、图像、重定向、错误等任何东西。
- en: 'Let''s take a look at the previously created (partial) `src/AppBundle/Controller/CustomerController.php`
    file, more precisely its `newAction` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下之前创建的（部分）`src/AppBundle/Controller/CustomerController.php`文件，更确切地说是它的`newAction`方法：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we ignore the actual data retrieval part (`//…`), there are three important
    things to note in this little example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略实际的数据检索部分（`//…`），在这个小例子中有三个重要的事情需要注意：
- en: '`@Route`: this is the Symfony''s annotation way of specifying HTTP endpoint,
    the URL we will use to access this. The first `"/new"` parameter states the actual
    endpoint, the second `name="customer_new"` parameter sets the name for this route
    that we can then use as an alias in URL generation functions in templates and
    so on. It is worth noting, that this builds upon the `@Route("/customer")` annotation
    set on the actual `CustomerController` class where the method is defined, thus
    making for the full URL to be something like `http://test.app/customer/new`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Route`：这是Symfony的注释方式来指定HTTP端点，我们将用它来访问。第一个`"/new"`参数表示实际的端点，第二个`name="customer_new"`参数设置了这个路由的名称，我们可以在模板中的URL生成函数中使用它作为别名。值得注意的是，这是建立在实际`CustomerController`类上的`@Route("/customer")`注释之上的，因此完整的URL可能是`http://test.app/customer/new`。'
- en: '`@Method`: This takes the name of one or more HTTP methods. This means that
    the `newAction` method will trigger only if the HTTP requests match the previously
    defined `@Route` and are of one or more HTTP method types defined in `@Method`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Method`：这里接受一个或多个HTTP方法的名称。这意味着`newAction`方法只会在HTTP请求与先前定义的`@Route`匹配并且是在`@Method`中定义的一个或多个HTTP方法类型时触发。'
- en: '`$this->render`: This returns the `Response` object. The `$this->render` calls
    the `render` function of the `Symfony\Bundle\FrameworkBundle\Controller\Controller`
    class, which instantiates new `Response()`, sets its content, and returns the
    whole instance of that object.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->render`：这返回`Response`对象。`$this->render`调用`Symfony\Bundle\FrameworkBundle\Controller\Controller`类的`render`函数，它实例化新的`Response()`，设置其内容，并返回该对象的整个实例。'
- en: 'Now let''s take a look at the `editAction` method within our controller, as
    partially shown in the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们控制器中的`editAction`方法，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see a route that accepts a singe ID, marked as `{id}` within the first
    `@Route` annotation parameter. The body of the method (excluded here), does not
    contain any direct reference to fetching the `id` parameter. We can see that the
    `editAction` function accepts two parameters, one being `Request`, the other being
    `Customer`. But how does the method know to accept the `Customer` object? This
    is where Symfony's `@ParamConverter` annotation comes into play. It calls converters
    to convert the request parameters to objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个路由接受一个单一的ID，标记为第一个`@Route`注释参数中的`{id}`。方法的主体（在此处排除）不包含对获取`id`参数的直接引用。我们可以看到`editAction`函数接受两个参数，一个是`Request`，另一个是`Customer`。但是方法如何知道要接受`Customer`对象呢？这就是Symfony的`@ParamConverter`注释发挥作用的地方。它调用转换器将请求参数转换为对象。
- en: The great thing about `@ParamConverter` annotation is that we can use it explicitly
    or implicitly. That is, if we do not add `@ParamConverter` annotation but add
    type hinting to the method parameter, Symfony is going to try and load the object
    for us. This is the exact case we have in our example above, as we did not explicitly
    type the `@ParamConverter` annotation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ParamConverter`注释的好处在于我们可以明确或隐式地使用它。也就是说，如果我们不添加`@ParamConverter`注释，但在方法参数中添加类型提示，Symfony将尝试为我们加载对象。这正是我们在上面的例子中的情况，因为我们没有明确地添加`@ParamConverter`注释。'
- en: Terminology wise, controllers are often exchanged for routing. However, they
    are not the same thing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 术语上，控制器经常被用来交换路由。然而，它们并不是同一回事。
- en: Routing
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: In the shortest terms, routing is about linking the controllers with URLs entered
    in browser. Todays modern web applications need nice URLs. This means moving away
    from URLs like `/index.php?product_id=23` to something like `/catalog/product/t-shirt`.
    This is where routing comes in to play.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，路由是将控制器与浏览器中输入的URL链接起来。现代的Web应用程序需要友好的URL。这意味着从像`/index.php?product_id=23`这样的URL迁移到像`/catalog/product/t-shirt`这样的URL。这就是路由发挥作用的地方。
- en: 'Symfony has a powerful routing mechanism that enables us to do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony有一个强大的路由机制，使我们能够做到以下几点：
- en: Create complex routes which map to controllers
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建映射到控制器的复杂路由
- en: Generate URLs inside templates
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中生成URL
- en: Generate URLs inside controllers
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器内生成URL
- en: Load routing resources from various locations
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种位置加载路由资源
- en: The way routing works in Symfony is that all of the requests come through `app.php`.
    Then, the Symfony core asks the router to inspect the request. The router then
    matches the incoming URL to a specific route and returns information about the
    route. This information, among other things, includes the controller that should
    be executed. Finally, the Symfony kernel executes the controller, which returns
    a response object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony中路由的工作方式是所有请求都通过`app.php`。然后，Symfony核心要求路由器检查请求。路由器然后将传入的URL与特定路由匹配，并返回有关路由的信息。这些信息，除其他事项外，包括应执行的控制器。最后，Symfony内核执行控制器，返回一个响应对象。
- en: 'All of the application routes are loaded from a single routing configuration
    file, usually `app/config/routing.yml` file, as shown by our test app:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序路由都从单个路由配置文件加载，通常是`app/config/routing.yml`文件，如我们的测试应用程序所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The app is simply one of many possible entries. Its resource value points to
    `AppBundle` controller directory, and type is set to annotation which means that
    the class annotations will be read to specify exact routes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序只是许多可能输入之一。它的资源值指向`AppBundle`控制器目录，类型设置为注释，这意味着类注释将被读取以指定确切的路由。
- en: 'We can define a route with several variations. One of them is shown in the
    following block:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义具有多种变化的路由。其中一种如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding examples show several ways we can define our route. The interesting
    one is the case with required and optional parameter. If we think about it, removing
    ID from the latest example will match the example before it with sku. The Symfony
    router will always choose the first matching route it finds. We can solve the
    problem by adding regular expression requirements attributed on `@Route` annotation
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了我们可以定义路由的几种方式。有趣的是带有必需和可选参数的情况。如果我们考虑一下，从最新的例子中删除ID将匹配带有sku的前一个例子。Symfony路由器总是选择它找到的第一个匹配路由。我们可以通过在`@Route`注释上添加正则表达式要求来解决这个问题，如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is more to be said about controllers and routing, as we will see once
    we start building our application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于控制器和路由还有更多要说的，一旦我们开始构建我们的应用程序，我们将会看到。
- en: Templates
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Previously we said that controllers accept request and return response. The
    response, however, can often be any content type. The production of actual content
    is something controllers delegate to the templating engine. The templating engine
    then has the capability to turn the response into HTML, JSON, XML, CSV, LaTeX,
    or any other text-based content type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们说过控制器接受请求并返回响应。然而，响应往往可以是任何内容类型。实际内容的生成是控制器委托给模板引擎的。然后模板引擎有能力将响应转换为HTML、JSON、XML、CSV、LaTeX或任何其他基于文本的内容类型。
- en: In the old days, programmers mixed PHP with HTML into the so called PHP templates
    (`.php` and `.phtml`). Though still used with some platforms, this kind of approach
    is considered insecure and lacking in many aspects. One of which was cramming
    business logic into template files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，程序员将PHP与HTML混合到所谓的PHP模板（`.php`和`.phtml`）中。尽管在某些平台上仍在使用，但这种方法被认为是不安全的，并且在许多方面缺乏。其中之一是将业务逻辑塞入模板文件中。
- en: To address these shortcomings, Symfony packs its own templating language called
    Twig. Unlike PHP, Twig is meant to strictly express presentation and not to thinker
    about program logic. We cannot execute any of the PHP code within the Twig. And
    the Twig code is nothing more than an HTML with a few special syntax types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些缺点，Symfony打包了自己的模板语言Twig。与PHP不同，Twig旨在严格表达演示文稿，而不是思考程序逻辑。我们不能在Twig中执行任何PHP代码。而Twig代码只不过是带有一些特殊语法类型的HTML。
- en: 'Twig defines three types of special syntax:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Twig定义了三种特殊语法类型：
- en: '`{{ ... }}`: This outputs variable or the result of an expression to the template.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ ... }}`：这将把变量或表达式的结果输出到模板中。'
- en: '`{% ... %}`: This tag controls the logic of the template (`if` and `for` loops,
    and others).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% ... %}`：这个标签控制模板的逻辑（`if`和`for`循环等）。'
- en: '`{# ... #}`: It is the equivalent of the PHP `/* comment */` syntax. The Comments
    content isn''t included in the rendered page.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{# ... #}`：它相当于PHP的`/* comment */`语法。注释内容不包括在渲染页面中。'
- en: 'Filters are another nice feature of Twig. They act like chained method calls
    upon a variable value, modifying the content before it is outputted, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是Twig的另一个很好的功能。它们就像对变量值进行链式方法调用一样，修改输出之前的内容，如下所示：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It also supports functions listed as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持以下列出的函数：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding random function call would return one random value from within
    the array. With all the built-in list of filters and functions, Twig also allows
    for writing our own if needed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的随机函数调用将从数组中返回一个随机值。除了内置的过滤器和函数列表外，Twig还允许根据需要编写自己的过滤器和函数。
- en: 'Similar to PHP class inheritance, Twig also supports template and layout inheritance.
    Let''s take a quick look back at the the `app/Resources/views/customer/index.html.twig`
    file as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP类继承类似，Twig也支持模板和布局继承。让我们快速回顾一下`app/Resources/views/customer/index.html.twig`文件，如下所示：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here we see a customer `index.html.twig` template using the `extends` tag to
    extend a template from another one, in this case `base.html.twig` found in `app/Resources/views/`
    directory with content as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个客户`index.html.twig`模板，使用`extends`标签来扩展另一个模板，这种情况下是在`app/Resources/views/`目录中找到的`base.html.twig`，内容如下：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here we see several block tags: `title`, `stylesheets`, `body`, and `javascripts`.
    We can declare as many blocks as we want here and name them any way we like. This
    makes the `extend` tag a key to template inheritance. It tells the Twig to first
    evaluate the base template, which sets the layout and defines blocks, after which
    the child template like `customer/index.html.twig` fills in the content of these
    blocks.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到几个块标签：`title`，`stylesheets`，`body`和`javascripts`。我们可以在这里声明任意数量的块，并以任何我们喜欢的方式命名它们。这使得`extend`标签成为模板继承的关键。它告诉Twig首先评估基础模板，设置布局并定义块，然后子模板如`customer/index.html.twig`填充这些块的内容。
- en: 'Templates live in two locations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模板存在于两个位置：
- en: '`app/Resources/views/`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/Resources/views/`'
- en: '`bundle-directory/Resources/views/`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundle-directory/Resources/views/`'
- en: What this means is in order to `render/extend app/Resources/views/base.html.twig`
    we would use `base.html.twig` within our template file, and to `render/extend
    app/Resources/views/customer/index.html.twig` we would use the `customer/index.html.twig`
    path.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了`render/extend app/Resources/views/base.html.twig`，我们将在我们的模板文件中使用`base.html.twig`，而为了`render/extend
    app/Resources/views/customer/index.html.twig`，我们将使用`customer/index.html.twig`路径。
- en: When used with templates that reside in bundles, we have to reference them slightly
    differently. In this case, the `bundle:directory:filename` string syntax is used.
    Take the `FoggylineCatalogBundle:Product:index.html.twig` path for example. This
    would be a full path to use one of the bundles template file. Here the `FoggylineCatalogBundle`
    is a bundle name, `Product` is a name of a directory within that bundle `Resources/views`
    directory, and `index.html.twig` is the name of the actual template within the
    `Product` directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当与存储在bundles中的模板一起使用时，我们必须稍微不同地引用它们。在这种情况下，使用`bundle:directory:filename`字符串语法。以`FoggylineCatalogBundle:Product:index.html.twig`路径为例。这将是使用bundles模板文件的完整路径。这里`FoggylineCatalogBundle`是一个bundle名称，`Product`是该bundle`Resources/views`目录中的一个目录名称，`index.html.twig`是`Product`目录中实际模板的名称。
- en: Each template filename has two extensions that first specify the format and
    then the engine for that template; such as `*.html.twig`, `*.html.php`, and`*.css.twig`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板文件名都有两个扩展名，首先指定格式，然后指定该模板的引擎；例如`*.html.twig`，`*.html.php`和`*.css.twig`。
- en: We will get into more details regarding these templates once we move onto building
    our app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始构建我们的应用程序，我们将更详细地了解这些模板。
- en: Forms
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: Sign up, sign in, add to cart, checkout, all of these and more are actions that
    make use of HTML forms in web shop applications and beyond. Building forms is
    one of the most common tasks for developers. One that often takes time to do it
    right.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注册、登录、添加到购物车、结账，所有这些以及更多操作都在网店应用程序和其他地方使用HTML表单。构建表单是开发人员最常见的任务之一。通常需要时间来正确完成。
- en: Symfony has a `form` component through which we can build HTML forms in an OO
    way. The component itself is also a standalone library that can be used independently
    of Symfony.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony有一个`form`组件，通过它我们可以以面向对象的方式构建HTML表单。这个组件本身也是一个独立的库，可以独立于Symfony使用。
- en: 'Let''s take a look at the content of the `src/AppBundle/Entity/Customer.php`
    file, our `Customer` entity class that was auto-generated for us when we defined
    it via console:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`src/AppBundle/Entity/Customer.php`文件的内容，这是为我们自动生成的`Customer`实体类，当我们通过控制台定义它时：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we have a plain PHP class, which does not extend anything nor is in any
    other way linked to Symfony. It represents a single customer entity, for which
    it sets and gets the data. With the entity class in place, we would like to render
    a form that will pick up all of the relevant data used by our class. This is where
    the `Form` component comes in place.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个普通的PHP类，它既不继承任何东西，也不以任何其他方式与Symfony相关联。它代表一个单一的客户实体，为其设置和获取数据。有了实体类，我们想要渲染一个表单，该表单将获取我们类使用的所有相关数据。这就是`Form`组件的作用所在。
- en: 'When we used the CRUD generator via console earlier, it created the `Form`
    class for our Customer entity within the `src/AppBundle/Form/CustomerType.php`
    file with content as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前通过控制台使用CRUD生成器时，它为我们的Customer实体创建了`Form`类，位于`src/AppBundle/Form/CustomerType.php`文件中，内容如下：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see the simplicity behind the form component comes down to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到表单组件背后的简单性归结为以下几点：
- en: '**Extend form type**: We extend from `Symfony\Component\Form\AbstractType`
    class'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展表单类型**：我们从`Symfony\Component\Form\AbstractType`类继承'
- en: '**Implement buildForm method**: This is where we add actual fields we want
    to show on the form'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现buildForm方法**：这是我们添加要在表单上显示的实际字段的地方'
- en: '**Implement configureOptions**: This specifies at least the `data_class` configuration
    which points to our Customer entity.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现configureOptions**：这至少指定了`data_class`配置，指向我们的Customer实体。'
- en: 'The form builder object is the one doing the heavy lifting here. It does not
    take much for it to create a form. With the `form` class in place, let''s take
    a look at the `controller` action in charge of feeding the template with the form.
    In this case, we will focus on `newAction` within the `src/AppBundle/Controller/CustomerController.php`
    file, with content shown as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表单构建器对象在这里承担了大部分工作。它不需要太多的工作就可以创建一个表单。有了`form`类，让我们来看看负责向模板提供表单的`controller`动作。在这种情况下，我们将专注于`src/AppBundle/Controller/CustomerController.php`文件中的`newAction`，内容如下：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code first instantiates the `Customer` entity class. The `$this->createForm(…)`
    is actually calling `$this->container->get('form.factory')->create(…)`, passing
    it our `form` class name and instance of `customer` object. We then have the `isSubmitted`
    and `isValid` check, to see if this is a GET or valid POST request. Based on that
    check, the code either returns to customer listing or sets the `form` and `customer`
    instance to be used with the template `customer/new.html.twig`. We will speak
    more about the actual validation later on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先实例化了`Customer`实体类。`$this->createForm(…)`实际上是调用了`$this->container->get('form.factory')->create(…)`，将我们的`form`类名和`customer`对象的实例传递给它。然后我们有`isSubmitted`和`isValid`检查，以查看这是GET请求还是有效的POST请求。根据这个检查，代码要么返回到客户列表，要么设置`form`和`customer`实例，以便与模板`customer/new.html.twig`一起使用。我们稍后会更详细地讨论实际的验证。
- en: 'Finally, lets take a look at the actual template found in the `app/Resources/views/customer/new.html.twig`
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`app/Resources/views/customer/new.html.twig`文件中的实际模板：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we see `extends` and `block` tags, alongside some form of related functions.
    Symfony adds several form rendering function to Twig as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到了`extends`和`block`标签，以及一些相关的函数。Symfony向Twig添加了几个表单渲染函数，如下所示：
- en: '`form(view, variables)`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form(view, variables)`'
- en: '`form_start(view, variables)`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_start(view, variables)`'
- en: '`form_end(view, variables)`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_end(view, variables)`'
- en: '`form_label(view, label, variables)`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_label(view, label, variables)`'
- en: '`form_errors(view)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_errors(view)`'
- en: '`form_widget(view, variables)`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_widget(view, variables)`'
- en: '`form_row(view, variables)`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form_row(view, variables)`'
- en: '`form_rest(view, variables)`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of our application forms will be auto-generated like this one, so we are
    able to get a fully functional CRUD without going too deep into the rest of form
    functionality.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Symfony
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to keep up with modern demands, today's frameworks and applications
    require a flexible configuration system. Symfony fulfils this role nicely through
    its robust configuration files and environments concept.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Symfony configuration file `config.yml` is located under the `app/config/`
    directory, with (partial) content sectioned as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The top-level entries like `framework`, `twig`, `doctrine`, and `swiftmailer`
    define the configuration of an individual bundle.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the configuration file can be of XML or PHP format (`config.xml`
    or `config.php`). While YAML is simple and readable, XML is more powerful, whereas
    PHP is powerful but less readable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the console tool to dump the entire configuration as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example lists the config file for core `FrameworkBundle`. We can
    use the same command to show possible configurations for any bundle that implements
    container extension, something we will look into later on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Symfony has a nice implementation of environment concept. Looking into the
    `app/config` directory, we can see that default Symfony project actually starts
    with three different environments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`config_dev.yml`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_prod.yml`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_test.yml`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each application can run in various environments. Each environment shares the
    same code, but different configuration. Whereas dev environment might make use
    of extensive logging, a prod environment might make use of extensive caching.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The way these environments get triggered is via the front controller file,
    as in the following partial examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The test environment is missing here, as it is used only when running automated
    tests and cannot be accessed directly via a browser.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app/AppKernel.php` file is the one that actually loads the configuration,
    whether it is YAML, XML, or PHP as shown in the following code fragment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The environments follow the same concept, whereas each environment imports the
    base configuration file and then modifies its values to suit the needs of the
    specific environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The bundle system
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the popular frameworks and platforms support some form of modules, plugins,
    extensions or bundles. For most of the time, the difference really lies just in
    the naming, while the concept of extensibility and modularity is the same. With
    Symfony, these modular blocks are called bundles.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Bundles are a first-class citizen in Symfony, as they support all of the operations
    available to other components. Everything in Symfony is a bundle, even the core
    framework. Bundles enable us to build modularized applications, whereas the entire
    code for a given feature is contained within a single directory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: A single bundle holds all its PHP files, templates, style sheets, JavaScript
    files, tests, and anything else in one root directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: When we first setup our test app, it created an `AppBundle` for us, under the
    `src` directory. As we moved forward with the auto-generated CRUD, we saw our
    bundle getting all sorts of directories and files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'For a bundle to be noticed by Symfony, it needs to be added to the `app/AppKernel.php`
    file, with the `registerBundles` method as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Creating a new bundle is as simple as creating a single PHP file. Let''s go
    ahead and create an `src/TestBundle/TestBundle.php` file with content that looks
    like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the file is in place, all we need to do is to register it via the `registerBundles`
    method of the `app/AppKernel.php` file as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'An even easier way to create a bundle would be to just run a console command
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would trigger a series of questions about bundle that in the end results
    in bundle creation that looks like the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![The bundle system](graphics/B05460_05_16.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'Once the process is complete, a new bundle with several directories and files
    is created as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过程完成，将创建一个新的bundle，其中包含几个目录和文件，如下面的截图所示：
- en: '![The bundle system](graphics/B05460_05_17.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![bundle系统](graphics/B05460_05_17.jpg)'
- en: Bundle generator was kind enough to create controller, dependency injection
    extension extension, routing, prepare services configuration, templates, and even
    tests. Since we chose to share our bundle, Symfony opted for XML as default configuration
    format. The dependency extension simply means we can access our bundle configuration
    by using `foggyline_test` as the root element in Symfony's main `config.yml`.
    The actual `foggyline_test` element is defined within the `DependencyInjection/Configuration.php`
    file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Bundle生成器很友好地创建了控制器、依赖注入扩展、路由、准备服务配置、模板，甚至测试。由于我们选择共享我们的bundle，Symfony选择XML作为默认配置格式。依赖扩展简单地意味着我们可以通过在Symfony的主`config.yml`中使用`foggyline_test`作为根元素来访问我们的bundle配置。实际的`foggyline_test`元素在`DependencyInjection/Configuration.php`文件中定义。
- en: Databases and Doctrine
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库和Doctrine
- en: Databases are the backbone of almost every web application. Every time we need
    to store or retrieve data, we do so with the help of databases. The challenge
    in the modern OOP world is to abstract the database so that our PHP code is database
    agnostic. MySQL is probably the most known database in the PHP world. PHP itself
    has a great support for working with MySQL, whether it is via the `mysqli_*` extension
    or via PDO. However, both approaches are MySQL specific, to o close to database.
    Doctrine solves this problem by introducing a level of abstraction, enabling us
    to work with PHP objects that represent tables, rows, and their relations in MySQL.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库几乎是每个Web应用程序的支柱。每当我们需要存储或检索数据时，我们都是通过数据库来实现的。在现代面向对象编程世界中的挑战是将数据库抽象化，以便我们的PHP代码与数据库无关。MySQL可能是PHP世界中最知名的数据库。PHP本身对与MySQL的工作有很好的支持，无论是通过`mysqli_*`扩展还是通过PDO。然而，这两种方法都是针对MySQL特定的，离数据库太近。Doctrine通过引入一层抽象解决了这个问题，使我们能够使用代表MySQL中的表、行及其关系的PHP对象进行工作。
- en: Doctrine is completely decoupled from Symfony, so using it is completely optional.
    The great thing about it, however, is that the Symfony console provides great
    auto-generated CRUD based on Doctrine ORM, as we saw in previous examples when
    creating Customer entity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine完全与Symfony解耦，因此使用它完全是可选的。然而，它的一个很棒的地方是Symfony控制台提供了基于Doctrine ORM的自动生成CRUD，就像我们在之前的示例中创建Customer实体时看到的那样。
- en: 'As soon as we created the project, Symfony provided us with an auto-generated
    `app/config/parameters.yml` file. This is the file in which we, among other things,
    provide database access information as shown in the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了项目，Symfony就会为我们提供一个自动生成的`app/config/parameters.yml`文件。这个文件中，我们提供数据库访问信息，就像下面的示例中所示的那样。
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we configure proper parameters, we can use console generation features.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了适当的参数，我们就可以使用控制台生成功能。
- en: 'It is worth noting that parameters within this file are merely a convention,
    as `app/config/config.yml` is pulling them under `doctrine dbal` configuration
    like the one shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，该文件中的参数仅仅是一种约定，因为`app/config/config.yml`将它们拉入`doctrine dbal`配置，就像这里所示的那样。
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Symfony console tool allows us to drop and create a database based on this
    config, which comes in handy during development, as shown in the following code
    block:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony控制台工具允许我们根据这个配置来删除和创建数据库，在开发过程中非常方便，就像下面的代码块所示的那样。
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We saw previously how the console tool enables us to create entities and their
    mapping into database tables. This will suffice for our needs throughout this
    book. Once we have them created, we need to be able to perform CRUD operations
    on them. If we gloss over the auto-generated CRUD controller `src/AppBundle/Controller/CustomerController.php`
    file, we can the CRUD related code as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到控制台工具如何使我们能够创建实体并将它们映射到数据库表中。这将足够满足我们在本书中的需求。一旦我们创建了它们，我们需要能够对它们执行CRUD操作。如果我们忽略自动生成的CRUD控制器`src/AppBundle/Controller/CustomerController.php`文件，我们可以看到以下与CRUD相关的代码：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is a lot more to be said about Doctrine, which is far out of the scope
    of this book. More information can be found at the official page ([http://www.doctrine-project.org](http://www.doctrine-project.org)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Doctrine还有很多要说的，这已经超出了本书的范围。更多信息可以在官方页面找到（[http://www.doctrine-project.org](http://www.doctrine-project.org)）。
- en: Testing
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Nowadays testing has become an integral part of every modern web application.
    Usually the term testing implies unit and functional testing. Unit testing is
    about testing our PHP classes. Every single PHP class is considered to be a unit,
    thus the name unit test. Functional tests on the other hand test various layers
    of our application, usually concentrated on testing the functionality overall,
    like the sign in or sign up process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试已经成为每个现代Web应用程序的一个组成部分。通常，测试这个术语意味着单元测试和功能测试。单元测试是关于测试我们的PHP类。每个单独的PHP类被认为是一个单元，因此称为单元测试。另一方面，功能测试测试我们应用程序的各个层面，通常集中在测试整体功能，比如登录或注册过程。
- en: The PHP ecosystem has a great unit testing framework called **PHPUnit**, available
    for download at [https://phpunit.de](https://phpunit.de). It enables us to write
    primarily unit, but also functional type tests. The great thing about Symfony
    is that it comes with built in support for PHPUnit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PHP生态系统有一个很棒的单元测试框架叫做**PHPUnit**，可以在[https://phpunit.de](https://phpunit.de)下载。它使我们能够编写主要是单元测试，但也包括功能类型测试。Symfony的一个很棒的地方是它内置了对PHPUnit的支持。
- en: Before we can start running Symfony's tests, we need to make sure we have PHPUnit
    installed and available as console command. When executed, PHPUnit automatically
    tries to pick up and read testing configuration from `phpunit.xml` or `phpunit.xml.dist`
    within the current working directory, if available. By default Symfony comes with
    a `phpunit.xml.dist` file in its root folder, thus making it possible for the
    `phpunit` command to pick up its test configuration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始运行Symfony的测试之前，我们需要确保已安装PHPUnit并且可以作为控制台命令使用。当执行时，PHPUnit会自动尝试从当前工作目录中的`phpunit.xml`或`phpunit.xml.dist`中读取测试配置，如果可用的话。默认情况下，Symfony在其根文件夹中带有一个`phpunit.xml.dist`文件，因此`phpunit`命令可以获取其测试配置。
- en: 'The following is a partial example of a default `phpunit.xml.dist` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认`phpunit.xml.dist`文件的部分示例：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `testsuites` element defines the directory tests, in which all of our tests
    are located. The `filter` element with its children is used to configure the whitelist
    for the code coverage reporting. The `php` element with its children is used to
    configure PHP settings, constants, and global variables.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuites`元素定义了包含所有测试的目录tests。`filter`元素及其子元素用于配置代码覆盖报告的白名单。`php`元素及其子元素用于配置PHP设置、常量和全局变量。'
- en: 'Running a `phpunit` command against a default project like ours would result
    in output like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们这样的默认项目运行`phpunit`命令将产生以下输出：
- en: '![Testing](graphics/B05460_05_18.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![测试](graphics/B05460_05_18.jpg)'
- en: 'Note that bundle tests are not automatically picked up. Our `src/AppBundle/Tests/Controller/CustomerControllerTest.php`
    file, which was created for us automatically when we used auto-generated CRUD,
    was not executed. Not because its content is commented out by default, but because
    the `bundle` test directory isn''t visible to `phpunit`. To make it execute, we
    need to extend the `phpunit.xml.dist` file by adding to directory `testsuite`
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，bundle测试不会自动被捡起。我们自动创建的`src/AppBundle/Tests/Controller/CustomerControllerTest.php`文件在我们使用自动生成的CRUD时自动创建，但没有被执行。这不是因为它的内容默认被注释掉，而是因为`bundle`测试目录对`phpunit`不可见。为了使其执行，我们需要通过以下方式扩展`phpunit.xml.dist`文件，将目录添加到`testsuite`：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Depending on how we build our application, we might want to add all of our bundles
    to the `testsuite` list, even if we plan on distributing bundles independently.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们构建应用程序的方式，我们可能希望将所有bundle添加到`testsuite`列表中，即使我们计划独立分发bundle。
- en: There is plenty more to be said about testing. We will do so bit by bit as we
    progress through further chapters and cover the needs of individual bundles. For
    the moment, it is suffice to know how to trigger tests and how to add new locations
    to testing configuration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试还有很多要说的。随着我们进一步学习并覆盖各个bundle的需求，我们将逐步进行。目前，了解如何触发测试以及如何向测试配置添加新位置就足够了。
- en: Validation
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Validation plays an essential role in modern applications. When talking about
    web applications, we can say we differentiate between two main types of validation;
    form data and persisted data validation. Taking input from a user via a web form
    should be validated, the same as any persisting data that goes into a database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在现代应用程序中起着至关重要的作用。谈到Web应用程序时，我们可以说我们区分两种主要类型的验证；表单数据和持久化数据验证。通过Web表单从用户那里获取输入应该进行验证，与进入数据库的任何持久化数据一样。
- en: 'Symfony excels here by providing a Validation component based on JSR 303 Bean
    Validation drafted and available at [http://beanvalidation.org/1.0/spec/](http://beanvalidation.org/1.0/spec/).
    If we look back at our `app/config/config.yml`, under the `framework` root element,
    we can see that the `validation` service is turned on by default:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony通过提供基于JSR 303 Bean Validation的验证组件在这方面表现出色，该组件起草并可在[http://beanvalidation.org/1.0/spec/](http://beanvalidation.org/1.0/spec/)上找到。如果我们回顾一下我们的`app/config/config.yml`，在`framework`根元素下，我们可以看到`validation`服务默认已启用：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can access the validation service from any controller class by simply calling
    it via the `$this->get(''validator'')` expression, as shown in the following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地通过`$this->get('validator')`表达式调用任何控制器类中的验证服务，如下例所示：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The problem with the example above is that validation would never return any
    errors. The reason for this is that we do not have any assertions set on our class.
    The console auto-generated CRUD did not really define any constraints on our `Customer`
    class. We can confirm that by trying to add a new customer and typing in any text
    in the e-mail field, as we can see the e-mail wont be validated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例的问题在于验证永远不会返回任何错误。原因是我们的类上没有设置任何断言。控制台自动生成的CRUD实际上没有在我们的`Customer`类上定义任何约束。我们可以通过尝试添加新客户并在电子邮件字段中输入任何文本来确认这一点，因为我们可以看到电子邮件不会被验证。
- en: 'Let''s go ahead and edit the `src/AppBundle/Entity/Customer.php` file by adding
    the `@Assert\Email` function to the `$email` property like the one shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编辑`src/AppBundle/Entity/Customer.php`文件，通过向`$email`属性添加`@Assert\Email`函数，就像这里所示的那样：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The great thing about assertions constraints is that they accept parameters
    just as functions. We can therefore fine-tune individual constraints to our specific
    needs. If we now try to skip or add a faulty e-mail address, we would get a message
    like **Email "john@gmail.test" is invalid**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 断言约束的好处是它们像函数一样接受参数。因此，我们可以根据特定需求对单个约束进行微调。如果我们现在尝试跳过或添加一个错误的电子邮件地址，我们将收到类似**Email
    "john@gmail.test" is invalid**的消息。
- en: There are numerous constraints available, for the full list we can consult the
    [http://symfony.com/doc/current/book/validation.html](http://symfony.com/doc/current/book/validation.html)
    page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的约束，我们可以在[http://symfony.com/doc/current/book/validation.html](http://symfony.com/doc/current/book/validation.html)页面上查阅完整列表。
- en: Constraints can be applied to a class property or a public getter method. While
    the property constraints are most common and easy to use, the getter method constraints
    allow us to specify more complex validation rules.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以应用于类属性或公共getter方法。虽然属性约束最常见且易于使用，但getter方法约束允许我们指定更复杂的验证规则。
- en: 'Let''s take look at the `newAction` method of an `src/AppBundle/Controller/CustomerController.php`
    file as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`src/AppBundle/Controller/CustomerController.php`文件中的`newAction`方法：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we see an instance of a `CustomerType` form being bind to the `Customer`
    instance. The actual GET or POST request data is passed to an instance of a form
    via the `handleRequest` method. The form is now able to understand entity validation
    constraints and respond properly via its `isValid` method call. What this means
    is that we do not have to manually validate by using the validation service ourselves,
    the forms can do it for us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个`CustomerType`表单实例被绑定到`Customer`实例。实际的GET或POST请求数据通过`handleRequest`方法传递给表单的一个实例。现在，表单能够理解实体验证约束，并通过其`isValid`方法调用做出适当的响应。这意味着我们不必手动使用验证服务进行验证，表单可以为我们完成这项工作。
- en: We will continue to expand on validation features as we progress through individual
    bundles.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐个捆绑包进展的过程中，我们将继续扩展验证功能。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter we touched on some important functionality, which makes
    Symfony so great. Controllers, templates, Doctrine, ORM, forms, and validation
    make for a complete solution from data presentation and persistence. We have seen
    the flexibility and power behind each of the components. The bundle system takes
    it a step further by wrapping these into individual mini applications, or modules.
    We are now able to take full control of incoming HTTP requests, manipulate the
    data store, and present data to the user, all of this within a single bundle.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涉及了一些使Symfony如此出色的重要功能。控制器、模板、Doctrine、ORM、表单和验证构成了完整的数据呈现和持久化解决方案。我们已经看到了每个组件背后的灵活性和强大功能。捆绑包系统通过将这些组件封装成单独的小应用程序或模块，进一步提升了功能。现在，我们能够完全控制传入的HTTP请求，操作数据存储，并向用户呈现数据，所有这些都在一个捆绑包内完成。
- en: Moving forward, in the next chapter, we will utilize the insights and knowledge
    gained throughout the previous chapters to finally start building our modular
    application according to the requirements.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将利用前几章获得的见解和知识，最终根据要求开始构建我们的模块化应用程序。

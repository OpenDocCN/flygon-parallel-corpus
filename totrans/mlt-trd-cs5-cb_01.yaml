- en: Chapter 1. Threading Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the basic tasks for working with threads in
    C#. You will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a thread wait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aborting a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining thread state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground and background threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with a C# lock keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with a Monitor construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point of time in the past, the common computer had only one computing
    unit and could not execute several computing tasks simultaneously. However, operating
    systems could already work with multiple programs simultaneously, implementing
    the concept of multitasking. To prevent the possibility of one program taking
    control of the CPU, forever causing other applications and the operating system
    itself to hang, the operating systems had to split a physical computing unit across
    a few virtualized processors in some way and give a certain amount of computing
    power to each executing program. Moreover, an operating system must always have
    priority access to the CPU and should be able to prioritize CPU access to different
    programs. A thread is an implementation of this concept. It could be considered
    a virtual processor given to the one specific program that runs it independently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that a thread consumes a significant amount of operating system resources.
    Trying to share one physical processor across many threads will lead to a situation
    where an operating system is busy just managing threads instead of running programs.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, while it was possible to enhance computer processors, making them
    execute more and more commands per second, working with threads was usually an
    operating system task. There was no sense in trying to compute some tasks in parallel
    on a single-core CPU because it would take more time than running those computations
    sequentially. However, when processors started to have more computing cores, older
    programs could not take advantage of this because they just used one processor
    core.
  prefs: []
  type: TYPE_NORMAL
- en: To use a modern processor's computing power effectively, it is very important
    to be able to compose a program in a way that it can use more than one computing
    core, which leads to organizing it as several threads communicating and synchronizing
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will focus on performing some very basic operations
    with threads in the C# language. We will cover a thread's lifecycle, which includes
    creating, suspending, making a thread wait, and aborting a thread, and then we
    will go through basic synchronization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the following recipes, we will use Visual Studio 2012 as the main
    tool to write multithreaded programs in C#. This recipe will show you how to create
    a new C# program and use threads in it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are free Visual Studio 2012 Express editions, which can be downloaded
    from the Microsoft website. We will need Visual Studio 2012 Express for Windows
    Desktop for most of the examples and Visual Studio 2012 Express for Windows 8
    for Windows 8-specific recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    through your account at [http://www.packtpub.com](http://www.packtpub.com). If
    you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create a new C# program and use threads in it, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the project uses .NET Framework 4.0 or higher version.![How to
    do it...](img/7644OT_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program. The output will be something like:![How to do it...](img/7644OT_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In steps 1 and 2 we created a simple console application in C# using .Net Framework
    version 4.0\. Then in step 3 we included the namespace `System.Threading`, which
    contains all the types needed for the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of a program is being executed can be referred to as a process.
    A process consists of one or more threads. This means that when we run a program,
    we always have one main thread that executes the program code.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4 we defined the method `PrintNumbers`, which will be used in both the
    main and newly created threads. Then in step 5, we created a thread that runs
    `PrintNumbers`. When we construct a thread, an instance of the `ThreadStart` or
    `ParameterizedThreadStart` delegate is passed to the constructor. The C# compiler
    is creating this object behind the scenes when we just type the name of the method
    we want to run in a different thread. Then we start a thread and run `PrintNumbers`
    in the usual manner on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, there will be two ranges of numbers from 1 to 10 randomly crossing
    each other. This illustrates that the `PrintNumbers` method runs simultaneously
    on the main thread and on the other thread.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to make a thread wait for some time without wasting
    operating system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to make a thread wait without wasting operating system resource,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program is run, it creates a thread that will execute a code in the
    `PrintNumbersWithDelay` method. Immediately after that, it runs the `PrintNumbers`
    method. The key feature here is adding the `Thread.Sleep` method call to a `PrintNumbersWithDelay`
    method. It causes a thread executing this code to wait a specified amount of time
    (two seconds in our case) before printing each number. While a thread is sleeping,
    it uses as little CPU time as possible. As a result, we will see that the code
    in the `PrintNumbers` method that usually runs later will be executed before the
    code in the `PrintNumbersWithDelay` method in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Making a thread wait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how a program can wait for some computation in another
    thread to complete to use its result later in the code. It is not enough to use
    `Thread.Sleep` because we don't know the exact time the computation will take.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how a program can wait for some computation in another thread
    to complete to use its result later, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program is run, it runs a long-running thread that prints out numbers
    and waits two seconds before printing each number. But in the main program, we
    called the `t.Join` method, which allows us to wait for thread `t` to complete.
    When it is complete, the main program continues to run. With the help of this
    technique, it is possible to synchronize execution steps between two threads.
    The first one waits until another one is complete and then continues to work.
    While the first thread is waiting, it is in a blocked state (as it is in the previous
    recipe when you call `Thread.Sleep`).
  prefs: []
  type: TYPE_NORMAL
- en: Aborting a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will describe how to abort another thread's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to abort another thread''s execution, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program and a separate number-printing thread run, we wait for
    6 seconds and then call a `t.Abort` method on a thread. This injects a `ThreadAbortException`
    method into a thread causing it to terminate. It is very dangerous, generally
    because this exception can happen at any point and may totally destroy the application.
    In addition, it is not always possible to terminate a thread with this technique.
    The target thread may refuse to abort by handling this exception and calling the
    `Thread.ResetAbort` method. Thus, it is not recommended that you use the `Abort`
    method to close a thread. There are different methods that are preferred, such
    as providing a `CancellationToken` method to cancel a thread execution. This approach
    will be described in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"),
    *Using a Thread Pool*.
  prefs: []
  type: TYPE_NORMAL
- en: Determining a thread state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe possible states a thread could have. It is useful
    to get information about whether a thread is started yet or whether it is in a
    blocked state. Please note that because a thread runs independently, its state
    could be changed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to determine a thread state and acquire useful information
    about it, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts it defines two different threads; one of them will
    be aborted and the other runs successfully. The thread state is located in the
    `ThreadState` property of a `Thread` object, which is a C# enumeration. At first
    the thread has a `ThreadState.Unstarted` state. Then we run it and assume that,
    for the duration of 30 iterations of a cycle, the thread will change its state
    from `ThreadState.Running` to `ThreadState.WaitSleepJoin`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the current `Thread` object is always accessible through the
    `Thread.CurrentThread` static property.
  prefs: []
  type: TYPE_NORMAL
- en: If it does not happen, just increase the number of iterations. Then we abort
    the first thread and see that now it has a `ThreadState.Aborted` state. It is
    also possible that the program will print out the `ThreadState.AbortRequested`
    state. This illustrates very well the complexity of synchronizing two threads.
    Please keep in mind that you should not use thread abortion in your programs.
    I've covered it here only to show the corresponding thread state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can see that our second thread `t2` completed successfully and now
    has a `ThreadState.Stopped` state. There are several other states, but they are
    partly deprecated and partly not as useful as those we examined.
  prefs: []
  type: TYPE_NORMAL
- en: Thread priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe the different possible options for thread priority.
    Setting a thread priority determines how much CPU time a thread will be given.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the workings of thread priority, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two different threads. The first one,
    `ThreadPriority.Highest`, will have the highest thread priority, while the second
    one, that is `ThreadPriority.Lowest`, will have the lowest. We print out the main
    thread priority value and then start these two threads on all available cores.
    If we have more than one computing core, we should get an initial result within
    two seconds. The highest priority thread should calculate more iterations usually,
    but both values should be close. However, if there are any other programs running
    that load all the CPU cores, the situation could be quite different.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this situation, we set up the `ProcessorAffinity` option, instructing
    the operating system to run all our threads on a single CPU core (number one).
    Now the results should be very different and the calculations will take more than
    2 seconds. This happens because the CPU core will run mostly the high-priority
    thread, giving the rest of the threads very little time.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is an illustration of how an operating system works with
    thread prioritization. Usually, you should not write programs relying on this
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Foreground and background threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe what foreground and background threads are and how
    setting this option affects the program's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the effect of foreground and background threads on a program,
    perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts it defines two different threads. By default, a
    thread we create explicitly is a foreground thread. To create a background thread,
    we manually set the `IsBackground` property of the `threadTwo` object to `true`.
    We configure these threads in a way that the first one will complete faster, and
    then we run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first thread completes, the program shuts down and the background
    thread terminates. This is the main difference between the two: a process waits
    for all the foreground threads to complete before finishing the work, but if it
    has background threads, they just shut down.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to mention that if a program defines a foreground thread
    that does not complete, the main program will not end properly.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to provide a code we run in another thread with
    the required data. We will go through the different ways to fulfill this task
    and review common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to pass parameters to a thread, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an object of class `ThreadSample`,
    providing it with a number of iterations. Then we start a thread with the object's
    method `CountNumbers`. This method runs in another thread, but it uses the number
    10, which is the value that we passed to the object's constructor. Therefore,
    we just passed this number of iterations to another thread in the same indirect
    way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to pass data is to use the `Thread.Start` method by accepting an
    object that can be passed to another thread. To work this way, a method that we
    started in another thread must accept one single parameter of type object. This
    option is illustrated by creating a `threadTwo` thread. We pass `8` as an object
    to the `Count` method, where it is cast to an `integer` type.
  prefs: []
  type: TYPE_NORMAL
- en: The next option involves using lambda expressions. A lambda expression defines
    a method that does not belong to any class. We create such a method that invokes
    another method with the arguments needed and start it in another thread. When
    we start the `threadThree` thread, it prints out 12 numbers, which are exactly
    the numbers we passed to it via the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Using the lambda expressions involves another C# construct named `closure`.
    When we use any local variable in a lambda expression, C# generates a class and
    makes this variable a property of this class. So actually, we do the same thing
    as in the `threadOne` thread, but we do not define the class ourselves; the C#
    compiler does this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This could lead to several problems; for example, if we use the same variable
    from several lambdas, they will actually share this variable value. This is illustrated
    by the previous example; when we start `threadFour` and `threadFive`, they will
    both print `20` because the variable was changed to hold the value `20` before
    both threads were started.
  prefs: []
  type: TYPE_NORMAL
- en: Locking with a C# lock keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to ensure that if one thread uses some resource,
    another does not simultaneously use it. We will see why this is needed and what
    the thread safety concept is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites The source code for this recipe can be found at `BookSamples\Chapter1\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use the C# lock keyword, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an object of the class `Counter`.
    This class defines a simple counter that can be incremented and decremented. Then
    we start three threads that share the same counter instance and perform an increment
    and decrement in a cycle. This leads to nondeterministic results. If we run the
    program several times, it will print out several different counter values. It
    could be zero, but mostly won't be.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the `Counter` class is not thread safe. When several threads
    access the counter at the same time, the first thread gets the counter value `10`
    and increments it to 11\. Then a second thread gets the value 11 and increments
    it to 12\. The first thread gets the counter value 12, but before a decrement
    happens, a second thread gets the counter value 12 as well. Then the first thread
    decrements 12 to 11 and saves it into the counter, and the second thread simultaneously
    does the same. As a result, we have two increments and only one decrement, which
    is obviously not right. This kind of a situation is called race condition and
    is a very common cause of errors in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that this does not happen, we must ensure that while one thread
    works with the counter, all other threads must wait until the first one finishes
    the work. We can use the `lock` keyword to achieve this kind of behavior. If we
    `lock` an object, all the other threads that require an access to this object
    will be waiting in a blocked state until it is unlocked. This could be a serious
    performance issue and later, in [Chapter 2](ch02.html "Chapter 2. Thread Synchronization"),
    *Thread Synchronization*, we will learn more about this.
  prefs: []
  type: TYPE_NORMAL
- en: Locking with a Monitor construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates another common multithreaded error called a deadlock.
    Since a deadlock will cause a program to stop working, the first piece in this
    example is a new `Monitor` construct that allows us to avoid a deadlock. Then,
    the previously described `lock` keyword is used to get a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe10`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the multithreaded error deadlock, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the `LockTooMuch` method. In this method, we just `lock` the
    first object, wait a second and then `lock` the second object. Then we start this
    method in another thread and try to `lock` the second object and then the first
    object from the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the `lock` keyword like in the second part of this demo, it would
    be a deadlock. The first thread holds a `lock` on the `lock1` object and waits
    while the `lock2` object gets free; the main thread holds a `lock` on the `lock2`
    object and waits for the `lock1` object to become free, which in this situation
    will never happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the `lock` keyword is a syntactic sugar for `Monitor` class usage.
    If we were to disassemble a code with `lock`, we would see that it turns into
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we can use the `Monitor` class directly; it has the `TryEnter` method,
    which accepts a timeout parameter and returns `false` if this timeout parameter
    expires before we can acquire the resource protected by `lock`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to handle exceptions in other threads properly.
    It is very important to always place a `try/catch` block inside the thread because
    it is not possible to catch an exception outside a thread's code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe11`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the handling of exceptions in other threads, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two threads that will throw an exception.
    One of these threads handles exception, while the other does not. You can see
    that the second exception is not caught by a `try/catch` block around a code that
    starts the thread. So if you work with threads directly, the general rule is to
    not throw an exception from a thread, but to use a `try/catch` block inside a
    thread code instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the older versions of .NET Framework (1.0 and 1.1), this behavior was different
    and uncaught exceptions did not force an application shutdown. It is possible
    to use this policy by adding an application configuration file (such as `app.config`)
    containing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE

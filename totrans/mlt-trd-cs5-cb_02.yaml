- en: Chapter 2. Thread Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe some of the common techniques of working
    with shared resources from multiple threads. You will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Mutex construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SemaphoreSlim construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AutoResetEvent construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ManualResetEventSlim construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the CountDownEvent construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Barrier construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ReaderWriterLockSlim construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SpinWait construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading
    Basics*, it is problematic to use a shared object simultaneously from several
    threads. It is very important to synchronize those threads so that they perform
    operations on that shared object in a proper sequence. In a multithreaded counter
    recipe, we met a problem called the race condition. It happened because the execution
    of those multiple threads were not synchronized properly. When one thread performs
    the increment and decrement operations, the other threads must wait for their
    turn. This general problem is often referred to as **thread synchronization**.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to achieve thread synchronization. First, if there is
    no shared object, there is no need for synchronization at all. Surprisingly, it
    is very often that we can get rid of complex synchronization constructs by just
    redesigning your program and removing a shared state. If it's possible, just avoid
    using a single object from several threads.
  prefs: []
  type: TYPE_NORMAL
- en: If we must have a shared state, the second approach is to use only **atomic**
    operations. This means that an operation takes a single quantum of time and completes
    at once, so no other thread can perform another operation until the first operation
    is complete. Therefore, there is no need to make other threads wait for this operation
    to complete and there is no need to use locks; this in turn excludes the situation
    of a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not possible and the program's logic is more complicated, then we
    have to use different constructs to coordinate threads. One group of those constructs
    puts a waiting thread into a **blocked** state. In a blocked state, a thread uses
    as little CPU time as possible. However, this means that it will include at least
    one so-called **context switch**—the thread scheduler of an operating system—that
    will save the waiting thread's state, and switch to another thread, restoring
    its state by turn. This takes a considerable amount of resources; however, if
    the thread is going to be suspended for a long time, it is good. These kinds of
    constructs are also called **kernel-mode** constructs because only the kernel
    of an operating system is able to stop a thread from using CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: In case we have to wait for a short period of time, it is better to simply wait
    than switch the thread to a blocked state. This will save us the context switch
    at the cost of some CPU time wasted while the thread is waiting. Such constructs
    are referred to as **user-mode** constructs. They are very lightweight and fast,
    but they waste a lot of CPU time in case a thread has to wait for long.
  prefs: []
  type: TYPE_NORMAL
- en: To use the best of both the worlds, there are **hybrid** constructs; these try
    to use the user-mode waiting first, and then if a thread waits long enough, it
    switches to a blocked state, saving CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look through the aspects of thread synchronization.
    We will cover how to perform atomic operations and how to use the existing synchronization
    constructs included in the .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to perform basic atomic operations on an object
    to prevent the race condition without blocking threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the basic atomic operations, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates three threads that will execute a code in
    the `TestCounter` method. This method runs a sequence of increment/decrement operations
    on an object. Initially, the `Counter` object is not thread-safe and we get a
    race condition here. So in the first case, a counter value is not deterministic.
    We could get a zero value; however, if you run the program several times, you
    will eventually get some incorrect nonzero result.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    we resolved this problem by locking our object, causing other threads to block
    while one thread gets the old counter value, then computes and assigns a new value
    to the counter. However, if we execute this operation in such a way, it cannot
    be stopped midway; we would achieve the proper result without any locking with
    the help of the `Interlocked` construct. It provides the atomic methods `Increment`,
    `Decrement`, and `Add` for basic math, and it helps us to write the `Counter`
    class without the use of locking.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Mutex construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to synchronize two separate programs using a `Mutex`
    construct. `Mutex` is a primitive synchronization that grants exclusive access
    of the shared resource to only one thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the synchronization of two separate programs using the `Mutex`
    construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines a mutex with a specific name, providing
    the `initialOwner` flag as `false`. This allows the program to acquire a mutex
    if it is already created. Then, if no mutex was acquired, the program simply displays
    **Running**, and waits for any key to be pressed to release the mutex and exit.
  prefs: []
  type: TYPE_NORMAL
- en: If we start a second copy of the program, it will wait for 5 seconds, trying
    to acquire the mutex. If we press any key in the first copy of a program, the
    second one will start executing. However, if we keep waiting for 5 seconds, the
    second copy of the program will fail to acquire the mutex.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that a named mutex is a global operating system object! Always close
    the mutex properly; the best choice is to wrap a mutex object using a block.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to synchronize threads in different programs, which could
    be useful in a large number of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SemaphoreSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to `SemaphoreSlim` is a lightweight version of `Semaphore`;
    it limits the number of threads that can access a resource concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand limiting a multithreaded access to a resource with the help of
    the `SemaphoreSlim` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it creates a `SemaphoreSlim` instance, specifying
    the number of concurrent threads allowed in its constructor. Then it starts six
    threads with different names and start times to run.
  prefs: []
  type: TYPE_NORMAL
- en: Every thread is trying to acquire an access to a database, but we restrict the
    number of concurrent accesses to a database by four threads with the help of a
    semaphore. When four threads get an access to a database, the other two threads
    wait until one of the previous threads finishes its work and signals by calling
    the `_semaphore.Release` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we use a hybrid construct, which allows us to save a context switch in
    cases where the wait time is less. However, there is an older version of this
    construct called `Semaphore`. This version is a pure, kernel-time construct. There
    is no sense in using it, except in one very important scenario; we can create
    a named semaphore like a named mutex and use it to synchronize threads in different
    programs. `SemaphoreSlim` does not use Windows kernel semaphores and does not
    support interprocess synchronization, so use `Semaphore` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Using the AutoResetEvent construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, there is an example of how to send notifications from one thread
    to another with the help of an `AutoResetEvent` construct. `AutoResetEvent` notifies
    a waiting thread that an event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `7644_Code\Chapter2\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to send notifications from one thread to another with the
    help of the `AutoResetEvent` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines two `AutoResetEvent` instances. One
    of them is for signaling from the second thread to the main thread, and the second
    one will be signaling from the main thread to the second thread. We provide `false`
    to the `AutoResetEvent` constructor, specifying the initial sate of both the instances
    as `unsignaled`. This means that any thread calling the `WaitOne` method of one
    of these objects will be blocked until we call the `Set` method. If we initialize
    the event state to `true`, it becomes `signaled` and the thirst thread calling
    `WaitOne` would proceed immediately. The event state then becomes `unsignaled`
    automatically, so we need to call the `Set` method once again to let the other
    threads calling the `WaitOne` method on this instance to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create a second thread, which will execute the first operation for 10
    seconds and wait for the signal from the second thread. The signal means that
    the first operation is completed. Now the second thread is waiting for a signal
    from the main thread. We do some additional work on the main thread and send a
    signal by calling the `_mainEvent.Set` method. Then we wait for another signal
    from the second thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`AutoResetEvent` is a kernel-time construct, so if the wait time is not significant,
    it is better to use the next recipe with `ManualResetEventslim`, which is a hybrid
    construct.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the ManualResetEventSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to make signaling between threads more flexible
    with the `ManualResetEventSlim` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `ManualResetEventSlim` construct, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it first creates an instance of the `ManualResetEventSlim`
    construct. Then we start three threads that will wait for this event to signal
    them to continue the execution.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process of working with this construct is like letting people pass
    through a gate. The `AutoResetEvent` event that we looked at in the previous recipe
    works like a turnstile, allowing only one person to pass at a time. `ManualResetEventSlim`,
    which is a hybrid version of `ManualResetEvent`, stays open until we manually
    call the `Reset` method. Going back to the code, when we call `_mainEvent.Set`,
    we open it and allow the threads that are ready to accept this signal and continue
    working. However, thread number three is still sleeping and does not make it in
    time. We call `_mainEvent.Reset` and we thus close it. The last thread is now
    ready to go on, but it has to wait for the next signal, which will happen a few
    seconds later.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in one of the previous recipes, we use a hybrid construct that lacks the
    possibility to work at the operating system level. If we need to have a global
    event, we should use the `EventWaitHandle` construct, which is the base class
    for `AutoResetEvent` and `ManualResetEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CountDownEvent construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to use a `CountdownEvent` signaling construct
    to wait until a certain number of operations complete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `CountDownEvent` construct, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, we create a new `CountdownEvent` instance, specifying
    that we want it to signal when two operations complete in its constructor. Then
    we start two threads that signal to the event when they complete. As soon as the
    second thread is complete, the main thread returns from waiting on `CountdownEvent`
    and proceeds further. Using this construct, it is very convenient to wait for
    multiple asynchronous operations to complete.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a significant disadvantage; `_countdown.Wait()` will wait
    forever if we fail to call `_countdown.Signal()` the required number of times.
    Please make sure that all your threads complete with the `Signal` method call
    when using `CountdownEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Barrier construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates another interesting synchronization construct called
    `Barrier`. The `Barrier` construct helps to organize several threads to meet at
    some point in time, providing a callback that will be executed each time the threads
    have called the `SignalAndWait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `Barrier` construct, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a `Barrier` construct, specifying that we want to synchronize two
    threads, and after each of those two threads have called the `_barrier.SignalAndWait`
    method, we need to execute a callback that will print out the number of phases
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Each thread is going to send a signal to `Barrier` twice, so we will have two
    phases. Every time both the threads call the `SignalAndWait` method, `Barrier`
    will execute the callback. It is useful for working with multithreaded iteration
    algorithms, to execute some calculations on each iteration end. The end of iteration
    is reached when the last thread calls the `SignalAndWait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ReaderWriterLockSlim construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to create a thread-safe mechanism to read and
    write to a collection from multiple threads using a `ReaderWriterLockSlim` construct.
    `ReaderWriterLockSlim` represents a lock that is used to manage access to a resource,
    allowing multiple threads for reading or exclusive access for writing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create a thread-safe mechanism to read and write to a
    collection from multiple threads using the `ReaderWriterLockSlim` construct, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it simultaneously runs three threads that read
    data from a dictionary and two threads that write some data into this dictionary.
    To achieve thread safety, we use the `ReaderWriterLockSlim` construct, which was
    designed especially for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has two kinds of locks: a read lock that allows multiple threads reading
    and a write lock that blocks every operation from other threads until this write
    lock is released. There is also an interesting scenario when we obtain a read
    lock, read some data from the collection, and depending on that data, decide to
    obtain a write lock and change the collection. If we get the write locks at once,
    too much time is spent not allowing our readers to read the data, because the
    collection is blocked when we get a write lock. To minimize this time, there are
    `EnterUpgradeableReadLock`/`ExitUpgradeableReadLock` methods. We get a read lock
    and read the data; if we find that we have to change the underlying collection,
    we just upgrade our lock using the `EnterWriteLock` method, then perform a write
    operation quickly, and release a write lock using `ExitWriteLock`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we get a random number; we then get a read lock and check if this
    number exists in the dictionary keys collection. If not, we upgrade our lock to
    a write lock and then add this new key to a dictionary. It is a good practice
    to use `try`/`finally` blocks to make sure we always release locks after acquiring
    them.
  prefs: []
  type: TYPE_NORMAL
- en: All our threads have been created as background threads and after waiting for
    30 seconds, the main thread as well as all the background threads complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SpinWait construct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to wait on a thread without involving kernel-mode
    constructs. In addition, we introduce `SpinWait`, a hybrid synchronization construct,
    which is designed to wait in user mode for some time, and then switch to the kernel
    mode to save CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter2\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand waiting on a thread without involving kernel-mode constructs,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, it defines a thread that will execute an endless
    loop for 20 milliseconds until the main thread sets the `_isCompleted` variable
    to `true`. We could experiment and run this cycle for 20-30 seconds instead, measuring
    the CPU load with the Windows task manager. It will show a significant amount
    of processor time, depending on how many cores the CPU has.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `volatile` keyword to declare the `_isCompleted` static field. The
    `volatile` keyword indicates that a field might be modified by multiple threads
    executing at the same time. Fields that are declared `volatile` are not subject
    to compiler and processor optimizations that assume access by a single thread.
    This ensures that the most up-to-date value is present in the field at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use a `SpinWait` version, which on each iteration prints a special flag
    that shows us whether a thread is going to switch to a blocked state. We run this
    thread for 5 milliseconds to see that. In the beginning, `SpinWait` tries to stay
    in user mode, and after about nine iterations, it begins to switch the thread
    to a blocked state. If we try to measure the CPU load with this version, we will
    not see any CPU usage in the Windows task manager.
  prefs: []
  type: TYPE_NORMAL

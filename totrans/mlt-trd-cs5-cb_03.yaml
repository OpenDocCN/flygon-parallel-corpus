- en: Chapter 3. Using a Thread Pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe common techniques for working with shared
    resources from multiple threads. You will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a delegate on a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting an asynchronous operation on a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread pool and the degree of parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a wait handle and a timeout with a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the BackgroundWorker component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed several ways to create threads and organize
    their cooperation. Now let's consider another scenario where we create many asynchronous
    operations that take very little time to complete. As we discussed in the *Introduction*
    section of [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    creating a thread is an expensive operation, so doing this for each short-lived,
    asynchronous operation will include a significant overhead expense.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this problem, there is a common approach called **pooling** that
    can be successfully applied to any situation when we need many short-lived, expensive
    resources. We allocate a certain amount of those resources in advance, and organize
    them into a resource pool. Each time we need a new resource, we just take it from
    the pool, instead of creating a new one, and return it to the pool after the resource
    is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: The **.NET thread pool** is an implementation of this concept. It is accessible
    via the `System.Threading.ThreadPool` type. A thread pool is managed by .NET **Common
    Language Runtime** (**CLR**), which means that there is one instance of a thread
    pool per CLR. The `ThreadPool` type has a `QueueUserWorkItem` static method that
    accepts a **delegate**, representing a user-defined, asynchronous operation. After
    this method is called, this delegate goes to the internal queue. Then, if there
    are no threads inside the pool, it creates a new **worker thread** and puts the
    first delegate in the queue on it.
  prefs: []
  type: TYPE_NORMAL
- en: If we put new operations on a thread pool, after the previous operations are
    completed, it is possible to re-use this one thread to execute these operations.
    However, if we put new operations faster, the thread pool will create more threads
    to serve these operations. There is a limit to prevent creating too many threads,
    and in that case, new operations will wait in the queue until the worker threads
    in the pool become free to serve them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to keep operations on a thread pool short-lived! Do not
    put long-running operations on a thread pool or block worker threads. This will
    lead to all worker threads becoming busy, and they would no longer be able to
    serve user operations. This, in turn, will lead to performance problems and errors
    that are very hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: When we stop putting new operations on a thread pool, it will eventually remove
    threads that are no longer needed after being idle for some time. This will free
    up any operating system resources that are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to emphasize once again that a thread pool is intended to execute
    short-running operations. Using a thread pool gives us the possibility to save
    operating system resources at the cost of reducing the degree of parallelism.
    We use fewer threads, but execute asynchronous operations slower than usual, batching
    them by a number of worker threads available. This makes sense if operations are
    fast to complete, but it will degrade the performance for executing many long-running,
    compute-bound operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to be very careful of is using a thread pool in ASP.NET
    applications. ASP.NET infrastructure uses a thread pool itself, and if you waste
    all worker threads from a thread pool, a web server will no longer be able to
    serve incoming requests. It is recommended to use only input/output bound asynchronous
    operations in ASP.NET, because they use a different mechanics called **I/O threads**.
    We will discuss I/O threads in [Chapter 9](ch09.html "Chapter 9. Using Asynchronous
    I/O"), *Using asynchronous I/O*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that worker threads of a thread pool are background threads. This
    means that when all of the threads in the foreground (including the main application
    thread) are complete, then all the background threads will be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to use a thread pool to execute asynchronous
    operations. We will cover different ways to put an operation on a thread pool,
    and how to cancel an operation and prevent it from running for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a delegate on a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to execute a delegate asynchronously on a thread
    pool. In addition, we will discuss an approach called **Asynchronous Programming
    Model** (**APM**), which was historically the first asynchronous programming pattern
    in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe1`
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to invoke a delegate on a thread pool, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates a thread in an old-fashioned way, and then
    starts it and waits for its completion. Since a thread constructor accepts only
    a method that does not return any result, we use a **lambda expression** to wrap
    up a call to the `Test` method. We make sure that this thread is not from the
    thread pool by printing out the `Thread.CurrentThread.IsThreadPoolThread` property
    value. We also print out a managed thread ID to identify a thread on which this
    code was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define a delegate and run it by calling the `BeginInvoke` method. This
    method accepts a callback that will be called after the asynchronous operation
    completes, and a user-defined state to pass into the callback. This state is usually
    used to distinguish one asynchronous call from another. As a result, we get a
    `result` object that implements the `IAsyncResult` interface. `BeginInvoke` returns
    the result immediately, allowing us to continue with any work while the asynchronous
    operation is being executed on a worker thread of the thread pool. When we need
    the result of an asynchronous operation, we use the `result` object returned from
    the `BeginInvoke` method call. We can poll on it using a result property `IsCompleted`,
    but in this case, we use the `AsyncWaitHandle` result property to wait on it until
    the operation is complete. After this is done, to get a result from it, we call
    the `EndInvoke` method on a delegate, passing the delegate arguments and our `IAsyncResult`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, using `AsyncWaitHandle` is not necessary. If we comment out `r.AsyncWaitHandle.WaitOne`,
    the code will still run successfully, because the `EndInvoke` method actually
    waits for the asynchronous operation to complete. It is always important to call
    `EndInvoke` (or `EndOperationName` for other asynchronous APIs), because it throws
    any unhandled exceptions back to the calling thread. Always call both the `Begin`
    and `End` methods when using this kind of asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: When the operation completes, a callback passed to the `BeginInvoke` method
    will be posted on a thread pool, more specifically, a worker thread. If we comment
    out the `Thread.Sleep` method call at the end of the `Main` method definition,
    the callback will not be executed. This is because when the main thread completes,
    all the background threads will be stopped, including this callback. It is possible
    that both asynchronous calls to a delegate and a callback will be served by the
    same worker thread, which is easy to see by a worker thread ID.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of using the `BeginOperationName`/`EndOperationName` method and
    the `IAsyncResult` object in .NET is called Asynchronous Programming Model or
    the APM pattern, and such methods' pairs are called Asynchronous Methods. This
    pattern is still being used in various .NET class library APIs, but in modern
    programming, it is preferable to use **Task Parallel Library** (**TPL**) for organizing
    an asynchronous API. We will cover this topic in [Chapter 4](ch04.html "Chapter 4. Using
    Task Parallel Library"), *Using Task Parallel Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Posting an asynchronous operation on a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to put an asynchronous operation on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to post an asynchronous operation on a thread pool, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we define the `AsyncOperation` method that accepts a single parameter
    of the object type. Then, we post this method on a thread pool using the `QueueUserWorkItem`
    method. Then we post this method once again, but this time we pass a `state` object
    to this method call. This object will be passed to the `AsynchronousOperation`
    method as the `state` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Make a thread sleep for 1 second after those operations provide a thread pool
    with the possibility to re-use threads for new operations. If you comment these
    `Thread.Sleep` calls, most certainly, thread IDs will be different in all cases.
    If not, probably the first two threads will be re-used to run the following two
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: First, we post a lambda expression to a thread pool. Nothing special here; instead
    of defining a separate method, we use the lambda expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, instead of passing the state of a lambda expression, we use **closure**
    mechanics. It gives us more flexibility, and allows us to provide more than one
    object to the asynchronous operation and static typing for those objects. So the
    previous mechanism of passing an object into a method callback is really redundant
    and obsolete. There is no need to use it now when we have closures in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Thread pool and the degree of parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how a thread pool works with many asynchronous operations,
    and how it is different from creating many separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how a thread pool works with many asynchronous operations and how
    it is different from creating many separate threads, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, we create many different threads and run an operation
    on each one of them. This operation prints out a thread ID and blocks a thread
    for 100 milliseconds. As a result, we create 500 threads, which run all of those
    operations in parallel. The total time on my machine is about 300 milliseconds,
    but we consume many operating system resources for all those threads.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we follow the same procedure, but instead of creating a thread for each
    operation, we post them on a thread pool. After this, the thread pool starts to
    serve these operations; it begins to create more threads near the end, but still,
    it takes much more time, about 12 seconds on my machine. We save memory and threads
    for an operating system usage but pay with an execution time for it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, there is an example on how to cancel an asynchronous operation
    on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to implement a cancellation option on a thread, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we introduce new `CancellationTokenSource` and `CancellationToken` constructs.
    They appeared in .NET 4.0, and now are the de facto standard for implementing
    asynchronous operations' cancellation process. Since a thread pool has been existing
    for long time, it has no special API for cancellation tokens; however, they still
    could be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we see three ways to organize a cancellation process. The first
    is just to poll and check the `CancellationToken.IsCancellationRequested` property.
    If it is set to `true`, it means that our operation is being cancelled, and we
    must abandon the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The second way is to throw an `OperationCancelledException` exception. This
    allows for controlling the cancellation process not from inside the operation,
    which is being cancelled, but from the code on the outside.
  prefs: []
  type: TYPE_NORMAL
- en: The last option is to register a **callback** that will be called on a thread
    pool when an operation is cancelled. This will allow chaining a cancellation logic
    into another asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a wait handle and timeout with a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to implement a timeout for thread pool operations,
    and how to wait properly on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to implement a timeout and how to wait properly on a thread pool,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A thread pool has another useful method: `ThreadPool.RegisterWaitForSingleObject`.
    This method allows us to queue a callback on a thread pool, and this callback
    will be executed when the provided wait handle is signaled or a timeout has occurred.
    This allows us to implement a timeout for thread pool operations.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we queue a long-running operation on a thread pool. It runs for 6 seconds
    and then sets a `ManualResetEvent` signaling construct, in case it completes successfully.
    In other case, if cancellation is requested, the operation is just abandoned.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we register the second asynchronous operation that will be called when
    it receives a signal from the `ManualResetEvent` object, which is set by the first
    operation if it is completed successfully. Another option is when a timeout has
    occurred before the first operation is completed. If this happens, we use `CancellationToken`
    to cancel the first operation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we provide a 5-second timeout for the operation, it would not be
    enough. This is because the operation takes 6 seconds to complete, and we'd need
    to cancel this operation. So if we provide a 7-second timeout, which is acceptable,
    the operation completes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is very useful when you have a large number of threads that must wait in
    the blocked state for some multithreaded event construct to signal. Instead of
    blocking all those threads, we are able to use the thread pool infrastructure.
    It will allow to free up these threads until the event is set. This is a very
    important scenario for server applications, which require scalability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to use a `System.Threading.Timer` object to create
    periodically-called asynchronous operations on a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to create periodically-called asynchronous operations on a thread
    pool, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we create a new `Timer` instance. The first parameter is a lambda expression
    that will be executed on a thread pool. We call the `TimerOperation` method providing
    it with a start date. We do not use the user `state` object, so the second parameter
    is null; then, we specify when are we going to run `TimerOperation` for the first
    time, and what will be the period between calls. So the first value actually means
    that we start the first operation in a second, and then we run each of them for
    2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we wait for 6 seconds and change our timer. We start `TimerOperation`
    in a second after calling the `_timer.Change` method, and then run each of them
    for 4 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Timer could be more complex than this!**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use a timer in a more complicated way. For instance, we can
    run the timer operation only once, providing a timer period parameter with the
    `Timeout.Infinte` value. Then, inside the timer asynchronous operation, we are
    able to set the next time when the timer operation will be executed, depending
    on some custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we wait for the *Enter* key to be pressed and finish the application.
    While it is running, we can see the time passed since the program started.
  prefs: []
  type: TYPE_NORMAL
- en: Using the BackgroundWorker component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes another approach to asynchronous programming by example
    of a `BackgroundWorker` component. With the help of this object, we are able to
    organize our asynchronous code as a set of events and event handlers. You will
    learn how to use this component for asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use the `BackgroundWorker` component, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we create an instance of a `BackgroundWorker` component.
    We explicitly state that we want our background-worker-supported operations' cancellation
    and notifications on the operation's progress.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is where the most interesting part comes into play. Instead of manipulating
    with a thread pool and delegates, we use another C# idiom called **events**. An
    event represents one *source* of some notification and a number of *subscribers*
    ready to react when a notification arrives. In our case, we state that we would
    subscribe for three events, and when they occur, we would call the corresponding
    **event handlers**. These are methods with a specially defined signature that
    will be called when an event notifies its subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, instead of organizing an asynchronous API in a pair of `Begin`/`End`
    methods, it is possible to just start an asynchronous operation and then subscribe
    to different events that could happen while this operation is being executed.
    This approach is called **Event-based Asynchronous Pattern** (**EAP)**. It was
    historically the second attempt to structure asynchronous programs, and now it
    is recommended to use TPL, which will be described in [Chapter 4](ch04.html "Chapter 4. Using
    Task Parallel Library"), *Using Task Parallel Library*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have subscribed to three events. The first of them is the `DoWork` event.
    A handler of this event will be called when a background worker object starts
    an asynchronous operation with the `RunWorkerAsync` method. The event handler
    will be executed on a thread pool, and this is the main operating point where
    work is canceled if cancellation is requested, and where we provide information
    on the progress of the operation. At last, when we get the result, we set it to
    event arguments, and then the `RunWorkerCompleted` event handler is called. Inside
    this method, we find out whether our operation is succeeded, or maybe there were
    some errors, or it was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, a `BackgroundWorker` component is actually intended to be used
    in **Windows Forms Applications** (**WPF**). Its implementation makes working
    with UI controls possible from a background worker event handler's code directly,
    which is very comfortable as compared to the interaction of worker threads of
    a thread pool with UI controls.
  prefs: []
  type: TYPE_NORMAL

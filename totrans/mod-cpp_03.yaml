- en: Using Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are the infrastructure of C++; code is contained in functions and
    to execute that code you have to call a function. C++ is remarkably flexible in
    the ways that you can define and call functions: you can define functions with
    a fixed number of parameters or a variable number of parameters; you can write
    generic code so that the same code can be used with different types; and you can
    even write generic code with a variable number of types.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining C++ functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the most basic level, a function has parameters, has code to manipulate the
    parameters, and returns a value. C++ gives you several ways to determine these
    three aspects. In the following section, we will cover those parts of a C++ function
    from the left to the right of the declaration. Functions can also be **templated**,
    but this will be left to a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and defining functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function must be defined exactly once, but through overloading, you can have
    many functions with the same name that differ by their parameters. Code that uses
    a function has to have access to the name of the function, and so it needs to
    have access to either the function definition (for example, the function is defined
    earlier in the source file) or the declaration of the function (also called the
    function prototype). The compiler uses the prototype to type-check that the *calling
    code* is calling the function, using the right types.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, libraries are implemented as separate compiled library files and
    prototypes of the library functions are provided in header files so that many
    source files can use the functions by including the headers. However, if you know
    the function name, parameters, and return type, you can type the prototype yourself
    in your file.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever you do, you are simply providing the information for the compiler
    to type-check the expression that calls function. It is up to the linker to locate
    the function in the library and either copy the code into the executable or set
    up the infrastructure to use the function from a shared library. Including the
    header file for a library does not mean that you will be able to use the functions
    from that library because in standard C++, the header file does not have information
    about the library that contains a function.
  prefs: []
  type: TYPE_NORMAL
- en: Visual C++ provides a `pragma` called `comment`, which can be used with the
    `lib` option as a message to the linker to link with a specific library. So `#pragma
    comment(lib, "mylib")` in a header file will tell the linker to link with `mylib.lib`.
    In general, it is better to use project management tools, such as **nmake** or
    **MSBuild**, to ensure that the right libraries are linked in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the C Runtime Library is implemented this way: the function is compiled
    in a static library or a dynamic link library, and the function prototypes are
    provided in a header file. You provide the library in the linker command line,
    and typically you will include the header file for the library so that the function
    prototypes are available to the compiler. As long as the linker knows about the
    library, you can type the prototype in your code (and describe it as *external
    linkage* so the compiler knows the function is defined elsewhere). This can save
    you from including some large files into your source files, files that will mostly
    have prototypes of functions that you will not use.'
  prefs: []
  type: TYPE_NORMAL
- en: However, much of the C++ Standard Library is implemented in header files, which
    means that these files can be quite large. You can save compile time by including
    these header files in a precompiled header.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far in this book, we have used one source file so all the functions are
    defined in the same file as where they are used, and we have defined the function
    before calling it, that is, the function is defined *above* the code that calls
    it. You do not have to define the function before it is used as long as the function
    prototype is defined before the function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `mult` function is defined after the `main` function, but this code will
    compile because the prototype is given before the `main` function. This is called
    a **forward declaration**. The prototype does not have to have the parameter names.
    This is because the compiler only needs to know the types of the parameters, not
    their names. However, since parameter names should be self-documenting, it is
    usually a good idea to give the parameter names so that you can see the purpose
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying linkage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, the function is defined in the same source file, so
    there is *internal linkage*. If the function is defined in another file, the prototype
    will have *external linkage* and so the prototype will have to be defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `extern` keyword is one of many specifiers that you can add to a function
    declaration. For example, the `static` specifier can be used on a prototype to
    indicate that the function has internal linkage and the name can only be used
    in the current source file. In the preceding example, it is appropriate to mark
    the function as `static` in the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can also declare a function as `extern "C"`, which affects how the name
    of the function is stored in the object file. This is important for libraries,
    and will be covered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a function calculates a value that can be calculated at compile time, you
    can mark it on the left of the declaration with `constexpr` to indicate that the
    compiler can optimize the code by computing the value at compile time. If the
    function value can be calculated at compile time, it means that the parameters
    in the function call must be known at compile time and so they must be literals.
    The function must also be a single line. If these restrictions are not met, then
    the compiler is free to ignore the specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Related is the `inline` specifier. This can be placed on the left of a function
    declaration as a suggestion to the compiler that, when other code calls the function,
    rather than the compiler inserting a jump to the function in memory (and the creation
    of a stack frame), the compiler should put a copy of the actual code in the calling
    function. Again, the compiler is free to ignore this specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the return type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions may be written to run a routine and not return a value. If this is
    the case, you must specify that the function returns `void`. In most cases, a
    function will return a value, if only to indicate that the function has completed
    correctly. There is no requirement that the calling function obtains the return
    value or does anything with it. The calling function can simply ignore the return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to specify the return type. The first way is to give the
    type before the function name. This is the method used in most of the examples
    so far. The second way is called the **trailing return type** and requires that
    you place `auto` as the return type before the function name and use the `->`
    syntax to give the actual return type after the parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function is so simple that it is a good candidate to be inlined. The return
    type on the left is given as `auto`, meaning that the actual return type is specified
    after the parameter list. The `-> int` means that the return type is `int`. This
    syntax has the same effect as using `int` on the left. This syntax is useful when
    a function is templated and the return type may not be noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: In this trivial example, you can omit the return type entirely and just use
    `auto` on the left of the function name. This syntax means that the compiler will
    deduce the return type from the actual value returned. Clearly the compiler will
    only know what the return type is from the function body, so you cannot provide
    a prototype for such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if a function does not return at all (for example, if it goes into
    a never-ending loop to poll some value) you can mark it with the C++11 attribute
    `[[noreturn]]`. The compiler can use this attribute to write more efficient code
    because it knows that it does not need to provide code to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, function names have the same rules for variables: they must begin
    with a letter or an underscore and cannot contain spaces or other punctuation
    characters. Following the general principle of self-documenting code, you should
    name the function according to what it does. There is one exception and these
    are the special functions used to provide overloads for operators (which are mostly
    punctuation symbols). These functions have a name in the form of `operatorx`,
    where `x` is the operator that you will use in your code. A later section will
    explain how to implement operators with global functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Operators are one example of overloading. You can overload any function, that
    is, use the same name but provide implementations with different parameter types
    or different numbers of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions may have no parameters, in which case the function is defined with
    a pair of empty parentheses. A function definition must give the type and name
    of the parameters between the parentheses. In many cases, functions will have
    a fixed number of parameters, but you can write functions with a variable number
    of parameters. You can also define functions with default values for some of the
    parameters, in effect, providing a function that overloads itself on the number
    of parameters passed to the function. Variable argument lists and default arguments
    will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions can also be marked to indicate whether they will throw an exception.
    More details about exceptions will be given in [Chapter 7](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml),
    *Diagnostics and Debugging*, but there are two syntaxes you need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier versions of C++ allowed you to use the `throw` specifier on a function
    in three ways: firstly, you can provide a comma separated list of the types of
    the exceptions that may be thrown by code in the function; secondly, you can provide
    an ellipsis (`...`) which means that the function may throw any exception; and
    thirdly, you can provide an empty pair of parentheses, which means the function
    will not throw exceptions. The syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `throw` specifier has been deprecated in C++11 largely because the ability
    to indicate the type of exception was not useful. However, the version of `throw`
    that indicates that no exception will be thrown was found to be useful because
    it enables a compiler to optimize code by providing no code infrastructure to
    handle exceptions. C++11 retains this behavior with the `noexcept` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Function body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the return type, function name, and parameters have been determined, you
    then need to define the body of the function. The code for a function must appear
    between a pair of braces (`{}`). If the function returns a value, then the function
    must have at least one line (the last line in the function) with the `return`
    statement. This must return the appropriate type or a type that can be implicitly
    converted to the return type of the function. As mentioned before, if the function
    is declared as returning `auto`, then the compiler will deduce the return type.
    In this case, all the `return` statements *must* return the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Using function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function is called, the compiler checks all the overloads of the function
    to find one that matches the parameters in the calling code. If there is no exact
    match then standard and user-defined type conversions are performed, so the values
    provided by the calling code may be a different type from the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, parameters are passed by value and a copy is made, which means
    that the parameters are treated as local variables in the function. The writer
    of the function can decide to pass a parameter by reference, either through a
    pointer or a C++ reference. **Pass-by-reference** means that the variable in the
    calling code can be altered by the function, but this can be controlled by making
    the parameters `const`, in which case the reason for pass-by-reference is to prevent
    a (potentially costly) copy being made. Built-in arrays are always passed as a
    pointer to the first item to the array. The compiler will create temporaries when
    needed. For example, when a parameter is a `const` reference and the calling code
    passes a literal, a temporary object is created, and is only available to code
    in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Passing Initializer lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can pass an initializer list as a parameter if that list can be converted
    to the type of the parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines a structure that has two members. In the `main` function,
    a new instance of `point` is created on the stack and it is initialized by accessing
    the members directly. The instance is then passed to a function that has a `point`
    parameter. Since the parameter of `set_point` is pass-by-value, the compiler creates
    a copy of the structure on the stack of the function. The second call of `set_point`
    does the same: the compiler will create a temporary `point` object on the stack
    of the function and initialize it with the values in the initializer list.'
  prefs: []
  type: TYPE_NORMAL
- en: Using default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations when you have one or more parameters that have values
    that are so frequently used that you want them to be treated as a default value
    for the parameter, while still having the option of allowing the caller to provide
    a different value if necessary. To do this, you provide the default value in the
    parameter list of the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, this function is expected to be used to print a single message,
    but occasionally the user may want to have the screen cleared first (say, for
    the first message, or after a pre-determined count of lines). To accommodate this
    use of the function, the `clear_screen` parameter is given a default value of
    `false`, but the caller still has the option of passing a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the default values occur in the function definition, not in a function
    prototype, so if the `log_message` function is declared in a header file the prototype
    should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The parameters that can have default values are the right-most parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat each parameter with a default value as representing a separate
    overload of the function, so conceptually the `log_message` function should be
    treated as two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you define a `log_message` function that has just a `const string&` parameter,
    then the compiler will not know whether to call that function or the version where
    `clear_screen` is given a default value of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Variable number of parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function with default parameter values can be regarded as having a variable
    number of user-provided parameters, where you know at compile time the maximum
    number of parameters and their values if the caller chooses not to provide values.
    C++ also allows you to write functions where there is less certainty about the
    number of parameters, and the values passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to have a variable number of parameters: initializer lists,
    C-style variable argument lists, and variadic templated functions. The latter
    of these three will be addressed later in the chapter once templated functions
    have been covered.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializer lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this book, initializer lists have been treated as a kind of C++11
    construct, a bit like built-in arrays. In fact, when you use the initializer list
    syntax using braces, the compiler actually creates an instance of the templated
    `initialize_list` class. If an initializer list is used to initialize another
    type (for example, to initialize a `vector`), the compiler creates an `initialize_list`
    object with the values given between the braces, and the container object is initialized
    using the `initialize_list` iterators. This ability to create an `initialize_list`
    object from a braced initializer list can be used by to give a function a variable
    number of parameters, albeit all of the parameters must be of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `sum` function has a single parameter of `initializer_list<int>`, which
    can only be initialized with a list of integers. The `initializer_list` class
    has very few functions because it only exists to give access to the values in
    the braced list. Significantly, it implements a `size` function that returns the
    number of items in the list, and `begin` and `end` functions that return a pointer
    to the first item in the list, and to the position after the last item. These
    two functions are needed to give iterator access to the list, and it enables you
    to use the object with the ranged-`for` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: This is typical in the C++ Standard Library. If a container holds data in a
    contiguous block of memory, then pointer arithmetic can use the pointer to the
    first item and a pointer immediately after the last item to determine how many
    items are in the container. Incrementing the first pointer gives sequential access
    to every item, and pointer arithmetic allows random access. All containers implement
    a `begin` and `end` function to give access to the container *iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `main` function calls this function three times, each time
    with a braced initializer list, and the function will return a sum of the items
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly this technique means that each item in the *variable* parameter list
    has to be the same type (or a type that can be converted to the specified type).
    You would have the same result if the parameter had been a `vector`; the difference
    is that an `initializer_list` parameter requires less initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Argument lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ inherits from C the idea of argument lists. To do this, you use the ellipses
    syntax (`...`) as the last parameter to indicate that the caller can provide zero
    or more parameters. The compiler will check how the function is called and will
    allocate space on the stack for these extra parameters. To access the extra parameters,
    your code must include the `<cstdarg>` header file, which has macros that you
    can use to extract the extra parameters off the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is inherently type-unsafe because the compiler cannot check that the parameters
    that the function will get off the stack at runtime will be the same type as the
    parameters put on the stack by the calling code. For example, the following is
    an implementation of a function that will sum integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The definition of the function must have at least one parameter so that the
    macros work; in this case the parameter is called `first`. It is important that
    your code leaves the stack in a consistent state and this is carried out using
    a variable of the `va_list` type. This variable is initialized at the beginning
    of the function by calling the `va_start` macro and the stack is restored to its
    previous state at the end of the function by calling the `va_end` macro.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this function simply iterates through the argument list, and maintains
    a sum, and the loop finishes when the parameter has a value of -1\. There are
    no macros to give information about how many parameters there are on the stack,
    nor are there any macros to give an indication of the type of the parameter on
    the stack. Your code has to assume the type of the variable and provide the desired
    type in the `va_arg` macro. In this example, `va_arg` is called, assuming that
    every parameter on the stack is an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all parameters have been read off the stack, the code calls `va_end` before
    returning the sum. The function can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since `-1` is used to indicate the end of the list, it means that to sum a zero
    number of parameters, you have to pass at least one parameter, that is `-1`. In
    addition, the second line shows that you have a problem if you are passing a list
    of negative numbers (in this case `-1` cannot be a parameter). This problem could
    be addressed in this implementation by choosing another *marker value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another implementation could eschew the use of a marker for the end of the
    list, and instead use the first, required, argument to give the count of the parameters
    that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the first value is the *number of arguments* that follow, and so
    the routine will extract this exact number of integers off the stack and sum them.
    The code is called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is no convention for how to handle the issue of determining how many parameters
    have been passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The routine assumes that every item on the stack is an `int`, but there is
    no information about this in the prototype of the function, so the compiler cannot
    do type checking on the parameters actually used to call the function. If the
    caller provides a parameter of a different type, the wrong number of bytes could
    be read off the stack, making the results of all the other calls to `va_arg` invalid.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to press both, the comma and period keys, at the same time, and
    this has happened after typing the `10` parameter. The period means that the `10`
    is a `double`, and so the compiler puts a `double` value on the stack. When the
    function reads values off the stack with the `va_arg` macro, it will read the
    8-byte `double` as two 4-byte `int` values and for code produced by Visual C++
    this results in a total sum of `1076101140`. This illustrates the type unsafe
    aspect of argument lists: you cannot get the compiler to do type checks of the
    parameters passed to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your function has different types passed to it then you have to implement
    some mechanism to determine what those parameters are. A good example of argument
    lists is the C `printf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The required parameter of this function is a format string, and importantly
    this has an ordered list of variable parameters and their types. The format string
    provides the information that is not available via the `<cstdarg>` macros: the
    number of variable parameters and the type of each one. The implementation of
    the `printf` function will iterate through the format string and when it comes
    across a format specifier for a parameter (a character sequence starting with
    `%`) it will read the expected type off the stack with `va_arg`. It should be
    clear that C-style argument lists are not as flexible as they appear on first
    sight; moreover, they can be quite dangerous.'
  prefs: []
  type: TYPE_NORMAL
- en: Function features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are modularized pieces of code defined as part of your application,
    or in a library. If a function is written by another vendor it is important that
    your code calls the function in the way intended by the vendor. This means understanding
    the calling convention used and how it affects the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you call a function, the compiler will create a stack frame for the new
    function call and it will push items on to the stack. The data put on the stack
    depends on your compiler and whether the code is compiled for the debug or release
    build; however, in general there will be information about the parameters passed
    to the function, the return address (the address after the function call), and
    the automatic variables allocated in the function.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, when you make a function call at runtime, there will be a memory
    overhead and performance overhead from creating the stack frame before the function
    runs, and a performance overhead in cleaning up, after the function completes.
    If a function is inlined, this overhead does not occur because the function call
    will use the current stack frame rather than a new one. Clearly, inlined functions
    should be small, both in terms of code and the memory used on the stack. The compiler
    can ignore the `inline` specifier and call the function with a separate stack
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying calling conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your code uses your own functions, you do not need to pay any attention
    to *calling conventions* because the compiler will make sure the appropriate convention
    is used. However, if you are writing library code that can be used by other C++
    compilers, or even by other languages, then the calling convention becomes important.
    Since this book is not about interoperable code we won''t go into much depth,
    but instead will look at two aspects: function naming and stack maintenance.'
  prefs: []
  type: TYPE_NORMAL
- en: Using C linkage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you give a C++ function a name, this is the name that you will use to call
    the function in your C++ code. However, under the covers, the C++ compiler will
    *decorate* the name with extra symbols for the return type and parameters so that
    overloaded functions all have different names. To C++ developers, this is also
    known as **name mangling**.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to export a function through a shared library (in Windows, a **dynamic
    linked library**), you must use types and names that other languages can use.
    To do this, you can mark a function with `extern "C"`. This means that the function
    has C linkage and the compiler will not use C++ name mangling. Clearly, you should
    use this only on functions that will be used by external code and you should not
    use it with functions that have return values and parameters that use C++ custom
    types.
  prefs: []
  type: TYPE_NORMAL
- en: However, if such a function does return a C++ type, the compiler will only issue
    a warning. The reason is that C is a flexible language and a C programmer will
    be able to work out how to turn the C++ type into something usable, but it is
    poor practice to abuse them like this!
  prefs: []
  type: TYPE_NORMAL
- en: The `extern "C"` linkage can also be used with global variables, and you can
    use it on a single item or (using braces) on many items.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying how the stack Is maintained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visual C++ supports six calling conventions that you can use on a function.
    The `__clrcall` specifier means that the function should be called as a .NET function
    and allows you to write code that has mixed native code and managed code. C++/CLR
    (Microsoft''s language extensions to C++ to write .NET code) is beyond the scope
    of this book. The other five are used to indicate how parameters are passed to
    a function (on the stack or using CPU registers) and whose responsibility it is
    to maintain the stack. We will cover just three: `__cdecl`, `__stdcall`, and `__thiscall`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will rarely explicitly use `__thiscall`; it is the calling convention used
    for functions defined as members of custom types, and indicates that the function
    has a hidden parameter that is a pointer to the object that can be accessed through
    the `this` keyword in the function. More details will be given in the next chapter,
    but it is important to realize that such member functions have a different calling
    convention, especially when you need to initialize function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: By default, C++ global functions will use the `__cdecl` calling convention.
    The stack is maintained by the calling code, so in the calling code each call
    to a `__cdecl` function is followed by code to clean up the stack. This makes
    each function call a little larger, but it is needed for variable argument lists
    to be used. The `__stdcall` calling convention is used by most of the Windows
    SDK functions and it indicates that the called function cleans up the stack so
    there is no need for such code to be generated in the calling code. Clearly, it
    is important that the compiler knows that a function uses `__stdcall` because,
    otherwise, it will generate code to clean up a stack frame that has already been
    cleaned up by the function. You will usually see Windows functions marked with
    `WINAPI,` which is a `typedef` for `__stdcall`.
  prefs: []
  type: TYPE_NORMAL
- en: Using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases the memory overhead of a call stack is unimportant. However,
    when you use recursion it is possible to build up a long chain of stack frames.
    As the name suggests, recursion is when a function calls itself. A simple example
    is a function that calculates a factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call this for 4, the following calls are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The important point is that in the recursive function there must be at least
    one way to leave the function without recursion. In this case, it will be when
    `factorial` is called with a parameter of 1\. In practice, a function like this
    should be marked as `inline` to avoid creating any stack frames at all.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can have several functions with the same name, but where the parameter list
    is different (the number of parameters and/or the type of the parameters). This
    is *overloading* the function name. When such a function is called, the compiler
    will attempt to find the function that best fits the parameters provided. If there
    is not a suitable function, the compiler will attempt to convert the parameters
    to see if a function with those types exists. The compiler will start with trivial
    conversions (for example, an array name to a pointer, a type to a `const` type),
    and if this fails the compiler will try to promote the type (for example, `bool`
    to `int`). If that fails, the compiler will try standard conversions (for example,
    a reference to a type). If such conversions results in more than one possible
    candidate, then the compiler will issue an error that the function call is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler will also take the scope of the function into account when looking
    for a suitable function. You cannot define a function within a function, but you
    can provide a function prototype within the scope of a function and the compiler
    will attempt (if necessary through conversions) to call a function with such a
    prototype first. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the function `f` is overloaded with one version that takes an
    `int` and the other with a `double`. Normally, if you call `f(1)` then the compiler
    will call the first version of the function. However, in `main` there is a prototype
    for the version that takes a `double`, and an `int` can be converted to a `double`
    with no loss of information. The prototype is in the same scope as the function
    call, so in this code the compiler will call the version that takes a `double`.
    This technique essentially *hides* the version with an `int` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Deleted functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a more formal way to hide functions than using the scope. C++ will
    attempt to explicitly convert built-in types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this with an `int`, or anything that can be converted to an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second case, a `char` is an integer, so it is promoted to an `int` and
    the function is called. In the third case, the compiler will issue a warning that
    the conversion can cause a loss of data, but it is a warning and so the code will
    compile. If you want to prevent this implicit conversion you can *delete* the
    functions that you do not want callers to use. To do this, provide a prototype
    and use the syntax `= delete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the code attempts to call the function with a `char` or a `double`
    (or `float`, which will be implicitly converted to a `double`), the compiler will
    issue an error.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by value and passing by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the compiler will pass parameters by value, that is, a copy is made.
    If you pass a custom type, then its *copy constructor* is called to create a new
    object. If you pass a pointer to an object of a built-in type or custom type,
    then the *pointer* will be passed by value, that is, a new pointer is created
    on the function stack for the parameter and it is initialized with the memory
    address passed to the function. This means that, in the function, you can change
    the pointer to point to other memory (this is useful if you want to use pointer
    arithmetic on that pointer). The data that the pointer points to will be passed
    by a reference, that is, the data remains where it is, outside of the function,
    but the function can use the pointer to change the data. Similarly, if you use
    a reference on a parameter then it means that the object is passed by the reference.
    Clearly, if you use `const` on a pointer or reference parameter then this will
    affect whether the function can change the data pointed to or referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you may want to return several values from a function, and you
    may choose to use the return value of the function to indicate if the function
    executed correctly. One way to do this is to make one of the parameters an *out*
    parameter, that is, it is either a pointer or a reference to an object or container
    that the function will alter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this function, you must create a `vector` object and pass it to the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because the `values` parameter is a reference it means that when `get_values`
    calls `push_back` to insert a value in the `values` container it is actually inserting
    that value into the `items` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an out parameter is passed via a pointer it is important to look at the
    pointer declaration. A single `*` means that the variable is a pointer, two means
    that it is a pointer to a pointer. The following function returns an `int` through
    an out parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This pattern of returning a value indicating success is frequently used, particularly
    with code that accesses data across process or machine boundaries. The function
    return value can be used to give detailed information about why the call failed
    (no network access?, invalid security credentials?, and so on), and indicates
    that the data in the out parameters should be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the out parameter has a double `*` then it means the return value is itself
    a pointer, either to a single value or to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you pass in the size of the buffer you want using the first parameter
    and on return you receive the actual size of the buffer via this parameter (it
    is in/out) and a pointer to the buffer in the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Any function that returns a memory buffer must document who has the responsibility
    of deallocating the memory. In most cases, it is usually the caller, as assumed
    in this example code.
  prefs: []
  type: TYPE_NORMAL
- en: Designing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often functions will act upon global data, or data passed in by the caller.
    It is important that when the function completes, it leaves this data in a consistent
    state. Equally so, it is important that, the function can make assumptions about
    the data before it accesses it.
  prefs: []
  type: TYPE_NORMAL
- en: Pre- and post-conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function will typically alter some data: values passed into the function,
    data returned by the function, or some global data. It is important when designing
    a function that you determine what data will be accessed and changed and that
    these rules are documented.'
  prefs: []
  type: TYPE_NORMAL
- en: A function will have pre-conditions, assumptions about the data that it will
    use. For example, if a function is passed a filename, with the intention that
    the function will extract some data from the file, whose responsibility is it
    to check that the file exists? You can make it the responsibility of the function,
    and so the first few lines will check that the name is a valid path to a file
    and call operating system functions to check that the file exists. However, if
    you have several functions that will perform actions on the file, you will be
    replicating this checking code in each function and it may be better to put that
    responsibility on the calling code. Clearly, such actions can be expensive, so
    it is important to avoid both the calling code and the function to perform the
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](d02b18df-f5a2-4400-9562-536175a9f55c.xhtml), *Diagnostics and Debugging*,
    will describe how to add debugging code, called **asserts**, that you can place
    in your functions to check the values of the parameters to make sure that the
    calling code is following the pre-condition rules you have set. Asserts are defined
    using conditional compilation and so will only appear in **debug builds** (that
    is, C++ code compiled with debugging information). **Release builds** (completed
    code that will be delivered to the end user) will conditionally compile asserts
    away; this makes the code faster, and if your testing is thorough enough, you
    can be assured that pre-conditions are met.'
  prefs: []
  type: TYPE_NORMAL
- en: You should also document the post-conditions of your function. That is, assumptions
    about the data returned by the function (through the function return value, out
    parameters, or parameters passed by a reference). Post-conditions are the assumptions
    that the calling code will make. For example, you may return a signed integer
    where the function is meant to return a positive value, but a negative value is
    used to indicate an error. Often functions that return pointers will return `nullptr`
    if the function fails. In both cases, the calling code knows that it needs to
    check the return value and only use it if it is either positive or not `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Using invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be careful to document how a function uses data external to the function.
    If the intention of the function is to change external data, you should document
    what the function will do. If you don't explicitly document what the function
    does to external data, then you must ensure that when the function finishes such
    data is left untouched. The reason is that the calling code will only assume what
    you have said in the documentation and the side-effects of changing global data
    may cause problems. Sometimes it is necessary to store the state of global data
    and return the item back to that state before the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this, is the `cout` object. The `cout` object is global to your
    application, and it can be changed through manipulators to make it interpret numeric
    values in certain ways. If you change it in a function (say, by inserting the
    `hex` manipulator), then this change will remain when the `cout` object is used
    outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function called `read16` that reads 16 bytes from a file and prints
    the values out to the console both in hexadecimal form and interpreted as an ASCII
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code stores the state of the `cout` object in a temporary variable, `flags`.
    The `read16` function can change the `cout` object in any way necessary, but because
    we have the stored state it means that the object can be restored to its original
    state before returning.
  prefs: []
  type: TYPE_NORMAL
- en: Function pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is run, the functions it will call will exist in memory
    somewhere. This means that you can get the address of a function. C++ allows you
    to use the function call operator (a pair of parentheses enclosing the parameters
    `()`) to call a function through a function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the parentheses!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, a simple example of how function pointers can cause difficult to notice
    bugs in your code. A global function called `get_status` performs various validation
    actions to determine if the state of the system is valid. The function returns
    a value of zero to mean that the system state is valid and values over zero are
    error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code could be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is an error because the developer has missed off the `()`, so the compiler
    does not treat this as a function call. Instead, it treats this as a test of the
    memory address of the function, and since the function will never be located at
    a memory address of zero, the comparison will always be `true` and the message
    will be printed even if the system state is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last section highlights how easy it is to get the address of a function:
    you just use the name of the function without the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The pointer `pv` is only of mild interest; you now know where in memory the
    function is stored, but to print this address you still need to cast it to an
    integer. To make the pointer useful, you need to be able to declare a pointer
    through which the function can be called. To look at how to do this, let''s go
    back to the function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The function pointer must be able to call the function passing no parameters
    and expecting a return value of an integer. The function pointer is declared like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*` indicates that the variable `fn` is a pointer; however, this binds
    to the left, so without the parentheses surrounding `*fn` the compiler would interpret
    this to mean that the declaration is for an `int*` pointer. The rest of the declaration
    indicates how this function pointer is called: taking no parameters and returning
    an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling through a function pointer is simple: you give the name of the pointer
    where you would normally give the name of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note again how important the parentheses are; they indicates that the function
    at the address held in the function pointer, `fn`, is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function pointers can make code look rather cluttered, especially when you
    use them to point to templated functions, so often code will define an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lines declare aliases for the type of the function pointer needed
    to call the `get_status` function. Both are valid, but the `using` version is
    more readable since it is clear that `pf1` is the alias being defined. To see
    why, consider this alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The type alias is called `MyPtr` and it is to a function that returns a `bool`
    and takes two `MyType` pointers. This is much clearer with `using`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The tell-tale sign here is the `(*)`, which indicates that the type is a function
    pointer because you are using the parenthesis to break the associatively of the
    `*`. You can then read outwards to see the prototype of the function: to the left
    to see the return type, and to the right to get the parameter list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have declared an alias, you can create a pointer to a function and
    call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, because the `two_ints` alias is declared as a pointer, you do not
    use a `*` when declaring a variable of this type.
  prefs: []
  type: TYPE_NORMAL
- en: Using function pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function pointer is merely a pointer. This means that you can use it as a
    variable; you can return it from a function, or pass it as a parameter. For example,
    you may have some code that performs some lengthy routine and you want to provide
    some feedback during the routine. To make this flexible, you could define your
    function to take a **callback pointer** and periodically in the routine call the
    function to indicate progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here `big_routine` has a function pointer parameter called `progress`. The function
    has a loop that will be called many times and every one hundredth loop it calls
    the callback function, passing a `string` that gives information about the progress.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `string` class defines a `+=` operator that can be used to append
    a string to the end of the `string` in the variable and the `<string>` header
    file defines a function called `to_string` that is overloaded for each of the
    built-in types to return a `string` formatted with the value of the function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function declares the function pointer as `const` merely so that the compiler
    knows that the function pointer should not be changed to a pointer to another
    function in this function. The code can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `monitor` function has the same prototype as described by the `callback`
    function pointer (if, for example, the function parameter was `string&` and not
    `const string&,` then the code will not compile). The `big_routine` function is
    then called, passing a pointer to the `monitor` function as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass callback functions to library code, you must pay attention to the
    calling convention of the function pointer. For example, if you pass a function
    pointer to a Windows function, such as `EnumWindows`, it must point to a function
    declared with the `__stdcall` calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standards uses another technique to call functions defined at runtime,
    which is, functors. It will be covered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Templated functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write library code, you often have to write several functions that
    differ only between the types that are passed to the function; the routine action
    is the same, it's just the types that have changed. C++ provides *templates* to
    allow you to write more generic code; you write the routine using a *generic type*
    and at compile time the compiler will generate a function with the appropriate
    types. The templated function is marked as such using the `template` keyword and
    a list of parameters in angle brackets (`<>`) that give placeholders for the types
    that will be used. It is important to understand that these template parameters
    are types and refer to the types of the parameters (and return a value of the
    function) that will be replaced with the actual types used by calling the functions.
    They are not parameters of the function, and you do not (normally) provide them
    when you call the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is best to explain template functions with an example. A simple `maximum`
    function can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this with other integer types, and smaller types (`short`, `char`,
    `bool`, and so on) will be promoted to an `int`, and values of larger types (`long
    long`) will be truncated. Similarly, variables of `unsigned` types will be converted
    to the `signed int` which could cause problems. Consider this call of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the value of the `result` variable: `s1` or `s2`? It is `s2`. The reason
    is that both values are converted to `signed int` and when converted to a signed
    type `s1` will be a value of `-1` and `s2` will be a value of `2147483647`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle unsigned types, you need to *overload* the function and write a version
    for signed and unsigned integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The routine is the same, but the types have changed. There is another issue--what
    if the caller mixes types? Does the following expression make any sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code will compile because a `bool` and a `double` can be converted to an
    `int` and the first overload will be called. Since such a call is nonsense, it
    would be much better if the compiler caught this error.
  prefs: []
  type: TYPE_NORMAL
- en: Defining templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning back to the two versions of the `maximum` function, the routine is
    the same for both; all that has changed is the type. If you had a generic type,
    let''s call it `T`, where `T` could be any type that implements an `operator>`,
    the routine could be described by this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not compile because we have not defined the type `T`. Templates allow
    you to tell the compiler that the code uses a type and will be determined from
    the parameter passed to the function. The following code will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The template declaration specifies the type that will be used using the `typename`
    identifier. The type `T` is a placeholder; you can use any name you like as long
    as it is not a name used elsewhere at the same scope, and of course, it must be
    used in the parameter list of the function. You can use `class` instead of `typename`,
    but the meaning is the same.
  prefs: []
  type: TYPE_NORMAL
- en: You can call this function, passing values of any type, and the compiler will
    create the code for that type, calling the `operator>` for that type.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that, the first time the compiler comes across a
    templated function, it will create a version of the function for the specified
    type. If you call the templated function for several different types, the compiler
    will create, or instantiate, a *specialized* function for each of these types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of this template indicates that only one type will be used,
    so you can only call it with two parameters of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these will compile and the first two will give the expected results.
    The last line will assign `b` to a value of `true` because `bool` is an integer
    and `true` has a value of `1+` and `false` has a value of `0`. This may not be
    what you would want, so we will return to this issue later. Note that, since the
    template says that both parameters must be the same type, the following will not
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that the `template` parameter list only gives a single type.
    If you want to define a function with parameters of different types, then you
    will have to provide extra parameters to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is done to illustrate how templates work; it really does not make sense
    to define a maximum function that takes two different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version is written for two different types, the template declaration mentions
    two types, and these are used for the two parameters. But notice that the function
    returns `T`, the type of the first parameter. The function can be called like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the first is `1` (or if you use the `bool alpha` manipulator,
    `true`) and the result of the second line is `100.99`. The reason is not immediately
    obvious. In both cases, the comparison will return `100.99` from the function,
    but because the type of the return value is `T`, the returned value type will
    be the type of the first parameter. In the first case, `100.99` is first converted
    to a `bool`, and since `100.99` is not zero, the value returned is `true` (or
    `1`). In the second case, the first parameter is a `double`, so the function returns
    a `double` and this means that `100.99` is returned. If the template version of
    `maximum` is changed to return `U` (the type of the second parameter) then the
    values returned by the preceding code are reversed: the first line returns `100.99`
    and the second returns `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you *call* the template function, you do not have to give the
    types of the template parameters because the compiler will deduce them. It is
    important to point out that this applies only to the parameters. The return type
    is not determined by the type of the variable the caller assigns to the function
    value because the function can be called without using the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the compiler will deduce the template parameters from how you call
    the function, you can explicitly provide the types in the called function to call
    a specific version of the function and (if necessary) get the compiler to perform
    implicit conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This code will call the version of `maximum` that has two `int` parameters and
    returns an `int`, so the return value is `100`, that is, `100.99` converted to
    an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Using template parameter values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The templates defined so far have had types as the parameters of the template,
    but you can also provide integer values. The following is a rather contrived example
    to illustrate the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two template parameters. The second parameter provides the name of
    a type where `T` is a placeholder used for the type of the parameter of the function.
    The first parameter looks like a function parameter because it is used in a similar
    way. The parameter `size` can be used in the function as a local (read-only) variable.
    The function parameter is `T` and so the compiler can deduce the second template
    parameter from the function call, but it cannot deduce the first parameter, so
    you *must* provide a value in the call. Here is an example of calling this template
    function for an `int` for `T` and a value of `10` for `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first line calls the function with `10` as the template parameter and `42`
    as the function parameter. Since `42` is an `int`, the `init` function will create
    an `int` array with ten members and each one is initialized to a value of `42`.
    The compiler deduced `int` as the second parameter, but this code could have called
    the function with `init<10,int>(42)` to explicitly indicate that you require an
    `int` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-type parameters must be constant at compile time: the value can be
    integral (including an enumeration), but not a floating point. You can use arrays
    of integers, but these will be available through the template parameter as a pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although in most cases the compiler cannot deduce the value parameter, it can
    if the value is defined as the size of an array. This can be used to make it appear
    that a function can determine the size of a built-in array, but of course, it
    can''t because the compiler will create a version of the function for each size
    needed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are two template parameters: one is the type of the array, and
    the other is the size of the array. The parameter of the function looks a little
    odd, but it is just a built-in array being passed by a reference. If the parentheses
    are not used then the parameter is `T& arr[N]`, that is, an N-sized built-in array
    of references to objects of type `T`, which is not what we want. We want an N-sized
    built-in array objects of type `T`. This function is called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting thing about the preceding code is that the compiler sees that
    there are five items in the initializer list. The built-in array has five items,
    thus calls the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, the compiler will instantiate this function for every combination
    of `T` and `N` that your code calls. If the template function has a large amount
    of code, then this may be an issue. One way around this is to use a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This does two things. First, there is a version of `print_array` that takes
    a pointer and the number of items that the pointer points to. This means that
    the `size` parameter is determined at runtime, so versions of this function are
    only instantiated at compile time for the types of the arrays used, not for both
    type and array size. The second thing to note is that the function that is templated
    with the size of the array is declared as `inline` and it calls the first version
    of the function. Although there will be a version of this for each combination
    of type and array size, the instantiation will be inline rather than a complete
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Specialized templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you may have a routine that works for most types (and a candidate
    for a templated function), but you may identify that some types need a different
    routine. To handle this, you can write a specialized template function, that is,
    a function that will be used for a specific type and the compiler will use this
    code when a caller uses types that fit this specialization. As an example, here
    is a fairly pointless function; it returns the size of a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for most built-in types, but if you call it with a pointer, you
    will get the size of the pointer, not what the pointer points to. So, `number_of_bytes("x")`
    will return 4 (on a 32-bit system) rather than 2 for the size of the `char` array.
    You may decide that you want a specialization for `char*` pointers that uses the
    C function, `strlen`, to count the number of characters in the string until the
    `NUL` character. To do this, you need a similar prototype to the templated function,
    replacing the template parameter with the actual type, and since the template
    parameter is not needed you miss this out. Since this function is for a specific
    type, you need to add the specialized type to the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now when you call `number_of_bytes("x")` the specialization will be called and
    it will return a value of 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we defined a templated function to return a maximum of two parameters
    of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Using specialization, you can write versions for types that are not compared
    using the `>` operator. Since it makes no sense to find the maximum of two Booleans,
    you can delete the specialization for `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This now means that, if the code calls `maximum` with `bool` parameters, the
    compiler will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variadic template is when there is a variable number of template parameters.
    The syntax is similar to variable arguments to a function; you use ellipses, but
    you use them on the left of the argument in the parameter list, which declares
    it a *parameter pack*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `Arguments` template parameter is zero or more types, which are the types
    of the corresponding number of arguments, `args`, of the function. In this example,
    the function has at least one parameter, of type `T`, but you can have any number
    of fixed parameters, including none at all.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, you need to unpack the parameter pack to get access to
    the parameters passed by the caller. You can determine how many items there are
    in the parameter pack using the special operator, `sizeof...` (note the ellipses
    are part of the name); unlike the `sizeof` operator, this is the item count and
    not the size in bytes. To unpack the parameter pack, you need to use the ellipses
    on the right of the name of the parameter pack (for example, `args...`). The compiler
    will expand the parameter pack at this point, replacing the symbol with the contents
    of the parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you will not know at design time how many parameters there are or
    what types they are, so there are some strategies to address this. The first uses
    recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The variadic templated `print` function can be called with one or more parameters
    of any type that can be handled by the `ostream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is called, the parameter list is split into two: the first parameter
    (`1`) in the first parameter, `first,` and the other three are put in the parameter
    pack, `next`. The function body then calls the first version of `print` which,
    prints the `first` parameter to the console. The next line in the variadic function
    then expands the parameter pack in a call to `print`, that is, this calls itself
    recursively. In this call, the `first` parameter will be `2.0`, and the rest will
    be put in the parameter pack. This continues until the parameter pack has been
    expanded so much that there are no more parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to unpack the parameter pack is to use an initializer list. In
    this case, the compiler will create an array with each parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The array, `arr,` is created with the size of the parameter pack and the unpack
    syntax used with the initializer braces will fill the array with the parameters.
    Although this will work with any number of parameters, all the parameters have
    to be the same type of the array, `arr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One trick is to use the comma operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This creates a dummy array called `dummy`. This array is not used, other than
    in the expansion of the parameter pack. The array is created in the size of the
    `args` parameter pack and the ellipsis expands the parameter pack using the *expression*
    between the parentheses. The expression uses the comma operator, which will return
    the right side of the comma. Since this is an integer, it means that each entry
    of `dummy` has a value of zero. The interesting part is the left side of the comma
    operator. Here the version of `print` with a single templated parameter is called
    with each item in the `args` parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier we said that function names should not contain punctuation. That is
    not strictly true because, if you are writing an operator, you *only* use punctuation
    in the function name. An operator is used in an expression acting on one or more
    operands. A unary operator has one operand, a binary operator has two operands,
    and an operator returns the result of the operation. Clearly this describes a
    function: a return type, a name, and one or more parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides the keyword `operator` to indicate that the function is not used
    with the function call syntax, but instead is called using the syntax associated
    with the operator (usually, a unary operator the first parameter is on the right
    of the operator, and for a binary operator the first parameter is on the left
    and the second is on the right, but there are exceptions to this).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, you will provide the operators as part of a custom type (so the
    operators act upon variables of that type) but in some cases, you can declare
    operators at a global scope. Both are valid. If you are writing a custom type
    (classes, as explained in the next chapter), then it makes sense to encapsulate
    the code for an operator as part of the custom type. In this section, we will
    concentrate on the other way to define an operator: as a global function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can provide your own versions of the following unary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also provide your own versions of the following binary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can also write versions of the function call operator `()`, array subscript
    `[]`, conversion operators, the cast operator `(),` and `new` and `delete`. You
    cannot redefine the `.`, `.*`, `::`, `?:`, `#` or `##` operators, nor the "named"
    operators, `sizeof`, `alignof` or `typeid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining the operator, you write a function where the function name is
    `operator*x*` and `*x*` is the operator symbol (note that there is no space).
    For example, if you define a `struct` that has two members defining a Cartesian
    point, you may want to compare two points for equality. The `struct` can be defined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing two `point` objects is easy. They are the same if `x` and `y` of
    one object are equal to the corresponding values in the other object. If you define
    the `==` operator, then you should also define the `!=` operator using the same
    logic because `!=` should give the exact opposite result of the `==` operator.
    This is how these operators can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parameters are the two operands of the operator. The first one is the
    operand on the left-hand side and the second parameter is the operand on the right-hand
    side of the operator. These are passed as references so that a copy is not made,
    and they are marked as `const` because the operator will not alter the objects.
    Once defined, you can use the `point` type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have defined a pair of functions called `equals` and `not_equals`
    and use these instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: However, defining operators makes the code more readable because you use the
    type like the built-in types. Operator overloading is often referred to as *syntactic
    sugar*, syntax that makes the code easier to read--but this trivializes an important
    technique. For example, smart pointers are a technique that involves class **destructors**
    to manage resource lifetime, and are only useful because you can call the objects
    of such classes as if they are pointers. You can do this because the smart pointer
    class implements the `->` and `*` operators. Another example is **functors**,
    or function objects, where the class implements the `()` operator so that objects
    can be accessed as if they are functions.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a custom type, you should ask yourself if overloading an operator
    for your type makes sense. If the type is a numeric type, for example, a complex
    number or a matrix - then it makes sense to implement arithmetic operators, but
    would it make sense to implement the logical operators since the type does not
    have a logical aspect? There is a temptation to redefine the *meaning* of operators
    to cover your specific operation, but this will make your code less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a unary operator is implemented as a global function that takes
    a single parameter. The postfix increment and decrement operators are an exception
    to allow for a different implementation from prefix operators. Prefix operators
    will have a reference to the object as a parameter (which the operator will increment
    or decrement) and return a reference to this changed object. The postfix operator,
    however, has to return the value of the object before the increment or decrement.
    Thus, the operator function has two parameters: a reference to an object that
    will be changed and an integer (which will always be a value of 1); it will return
    a copy of the original object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary operator will have two parameters and return an object or a reference
    to an object. For example, for the `struct` we defined previously, we could define
    an insertion operator for `ostream` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you can now insert a `point` object to the `cout` object to
    print it on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Function objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function object, or **functor**, is a custom type that implements the function
    call operator: (`operator()`). This means that a function operator can be called
    in a way that looks like it is a function. Since we haven''t covered classes yet,
    in this section we will just explore the function objects types that are provided
    by the Standard Library and how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<functional>` header file contains various types that can be used as function
    objects. The following table lists these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Purpose** | **Types** |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | `divides`, `minus`, `modulus`, `multiplies`, `negate`, `plus`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise | `bit_and`, `bit_not`, `bit_or`, `bit_xor` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison | `equal_to`, `greater`, `greater_equal`, `less`, `less_equals`,
    `not_equal_to` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical | `logical_and`, `logical_not`, `logical_or` |'
  prefs: []
  type: TYPE_TB
- en: 'These are all binary function classes, other than `bit_not`, `logical_not,`
    and `negate`, which are unary. Binary function objects act on two values and return
    a result, unary function objects act on a single value and return a result. For
    example, you could calculate the modulus of two numbers with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This declares a function object called `fn` that will perform modulus. The
    object is used in the second line, which calls the `operator()` function on the
    object with two parameters, so the following line is equivalent to the preceding
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is that the value of `0` is printed on the console. The `operator()`
    function merely performs the modulus on the two parameters, in this case `10 %
    2`. This does not look too exciting. The `<algorithm>` header contains functions
    that work on function objects. Most take predicates, that is, logical function
    objects, but one, `transform`, takes a function object that performs an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will perform five modulus calculations on the values in the two vectors.
    Conceptually, it does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That is, each item in `result` is the modulus of the corresponding item in `v1`
    and `v2`. In the code, the first line creates a `vector` with the five values.
    We will calculate the modulus of these values with `2`, so the second line declares
    an empty `vector` but with the same capacity as the first `vector`. This second
    `vector` is filled by calling the `fill` function. The first parameter is the
    address of the first item in the `vector` and the `end` function returns the address
    after the *last* item in the `vector`. The final item in the function call is
    the value that will be placed in the `vector` in every item starting with the
    item pointed to by the first parameter up to, but excluding, the item pointed
    to by the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the second `vector` will contain five items and each one will
    be `2`. Next, a `vector` is created for the results; and again, it is the same
    size as the first array. Finally, the calculation is performed by the `transform`
    function, shown here again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters give the iterators of the first `vector` and from this
    the number of items can be calculated. Since all three `vector`s are the same
    size, you only need the `begin` iterator for `v2` and `result`.
  prefs: []
  type: TYPE_NORMAL
- en: The last parameter is the function object. This is a temporary object and only
    exists during this statement; it has no name. The syntax used here is an explicit
    call to the constructor of the class; it is templated so you need to give the
    template parameter. The `transform` function will call the `operator(int,int)`
    function on this function object for each item in `v1` as the first parameter
    and the corresponding item in `v2` as the second parameter and it will store the
    result in the corresponding position in `result`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `transform` takes any binary function object as the second parameter,
    you can pass an instance of `plus<int>` to add a value of 2 to every item in `v1`,
    or pass an instance of `multiplies<int>` to multiply every item in `v1` by 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'One situation where function objects are useful is when performing multiple
    comparisons using a predicate. A predicate is a function object that compares
    values and returns a Boolean. The `<functional>` header contains several classes
    to allow you to compare items. Let''s see how many items in the `result` container
    are zero. To do this, we use the `count_if` function. This will iterate over a
    container, apply the predicate to every item, and count how many times the predicate
    returns a value of `true`. There are several ways to do this. The first defines
    a predicate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A pointer to this can then be passed to the `count_if` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two parameters indicate the range of values to check. The last parameter
    is a pointer to the function that is used as the predicate. Of course, if you
    are checking for different values you can make this more generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that we are defining the operation in a place
    other than where it is used. The `equals` function could be defined in another
    file; however, with a predicate it is more readable to have the code that does
    the checking defined close to the code that needs the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<functional>` header also defines classes that can be used as function
    objects. For example, `equal_to<int>`, which compares two values. However, the
    `count_if` function expects a unary function object, to which it will pass a single
    value (see the `equals_zero` function, described previously). `equal_to<int>`
    is a binary function object, comparing two values. We need to provide the second
    operand and to do this we use the helper function called `bind2nd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `bind2nd` will *bind* the parameter `0` to the function object created from
    `equal_to<int>`. Using a function object like this brings the definition of the
    predicate closer to the function call that will use it, but the syntax looks rather
    messy. C++11 provides a mechanism to get the compiler to determine the function
    objects that are required and bind parameters to them. These are called lambda
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lambda expression is used to create an anonymous function object at the location
    where the function object will be used. This makes your code much more readable
    because you can see what will be executed. On first sight, a lambda expression
    looks like a function definition in-place as a function parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: So that we don't have the complication of a function that uses a predicate,
    in this code we have assigned a variable to the lambda expression. This is not
    normally how you would use it, but it makes the description clearer. The square
    brackets at the beginning of the lambda expression are called the **capture list**.
    This expression does not capture variables, so the brackets are empty. You can
    use variables declared outside of the lambda expression and these have to be *captured*.
    The capture list indicates whether all such variables will be captured by a reference
    (use `[&]`) or by a value (use `[=]`). You can also name the variables that will
    be captured (if there are more than one, use a comma-separated list) and if they
    are captured by a value, you use just their names. If they are captured by a reference,
    use a `&` on their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could make the preceding lambda expression more generic by introducing
    a variable declared outside of the expression called `limit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If you compare a lambda expression to a global function, the capture list is
    a bit like identifying the global variables that the global function can access.
  prefs: []
  type: TYPE_NORMAL
- en: After the caption list, you give the parameter list in parentheses. Again, if
    you compare a lambda to a function, the lambda parameter list is equivalent to
    the function parameter list. If the lambda expression does not have any parameters,
    then you can miss out the parentheses altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body for the lambda is given in a pair of braces. This can contain anything
    that can be found in a function. The lambda body can declare local variables,
    and it can even declare `static` variables, which looks bizarre, but is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of the lambda is deduced from the item that is returned. A
    lambda expression does not have to return a value, in which case the expression
    will return `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The power of lambda expressions is that you can use them in cases when a function
    object or a predicate is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Here we declare a `vector` and initialize it with some values. The `count_if`
    function is used to count how many items in the container are less than 3\. So,
    the first two parameters are used to give the range of items to check, and the
    third parameter is a lambda expression that performs the comparison. The `count_if`
    function will call this expression for every item in the range that is passed
    in via the `a` parameter of the lambda. The `count_if` function keeps a running
    count of how many times the lambda returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example in this chapter uses the techniques you have learned in this chapter
    to list all the files in a folder, and subfolders, in order of file size, giving
    a listing of the filenames and their sizes. The example is the equivalent of typing
    the following at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here, `folder` is the folder you are listing. The `/s` option recurses, `/a-d`
    removes folders from the list, and `/os` orders by size. The problem is that without
    the `/b` option we get information about each folder, but using it removes the
    file size in the list. We want a list of filenames (and their paths), their size,
    ordered by the smallest first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new folder for this chapter (`Chapter_05`) under the `Beginning_C++`
    folder. In Visual C++ create a new C++ source file and save it as `files.cpp`
    under this new folder. The example will use basic output and strings. It will
    take a single command line parameter; if more command-line parameters are passed,
    we just use the first one. Add the following to `files.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The example will use the Windows functions, `FindFirstFile` and `FindNextFile`,
    to get information about files that meet a file specification. These return data
    in a `WIN32_FIND_DATAA` structure, which has information about the filename, the
    file size, and file attributes. The functions also return information about folders
    too, so it means we can test for subfolders and recurse. The `WIN32_FIND_DATAA`
    structure gives the file size as a 64-bit number in two parts: the upper and lower
    32 bits. We will create our own structure to hold this information. At the top
    of the file, after the C++ include files, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the Windows SDK header file so that you can access the Windows
    functions, and the structure is used to hold the information about a file's size.
    We want to compare files by their sizes. The `WIN32_FIND_DATAA` structure provides
    the size in two `unsigned long` members (one with the upper 4 bytes and the other
    with the lower 4 bytes). We could store this as a 64-bit number, but instead,
    so that we have an excuse to write some operators, we store the size in our `file_size`
    structure. The example will print out file sizes and will compare file sizes,
    so we will write an operator to insert a `file_size` object into an output steam;
    since we want to order the files by size, we need an operator to determine if
    one `file_size` object is greater than the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will use Windows functions to get information about the files, in
    particular their name and size. This information will be stored in a `vector`,
    so at the top of the file add these two highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tuple` class is needed so that we can store both a `string` (the filename)
    and a `file_size` object as each item in the `vector`. To make the code more readable
    add the following alias after the structure definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then just above the `main` function add the skeleton code for the function
    that will get the file in a folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes a reference to a `vector` and a folder path. The code will
    go through each item in the specified folder. If it is a file, it will store the
    details in the `vector`; otherwise, if the item is a folder it will call itself
    to get the files in that subfolder. Add a call to this function at the bottom
    of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The code has already checked that there is at least one command line argument,
    and we use this as the folder to examine. The `main` function should print out
    the file information, so we declare a `vector` on the stack and pass this by reference
    to the `files_in_folder` function. This code does nothing so far, but you can
    compile the code to make sure that there are no typos (remember to use the `/EHsc`
    parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the work is carried out in the `files_in_folder` function. As a start,
    add the following code to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We will use the ASCII version of the functions (hence the trailing `A` on the
    structure and function names). The `FindFirstFileA` function takes a search path,
    and in this case, we use the name of a folder suffixed with a `*`, meaning *everything
    in this folder*. Notice that the Windows function wants a `const char*` parameter,
    so we use the `c_str` function on the `string` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the function call succeeds and it finds an item that meets this criterion,
    then the function fills in the `WIN32_FIND_DATAA` structure passed by the reference
    and it also returns an opaque pointer which will be used to make subsequent calls
    on this search (you do not need to know what it points to). The code checks to
    see if the call was successful, and if so, it repeatedly calls `FindNextFileA`
    to get the next item until this function returns 0, indicating there are no more
    items. The opaque pointer is passed to `FindNextFileA` so that it knows which
    search is being checked. When the search is complete, the code calls `FindClose`
    to release whatever resources Windows allocates for the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search will return both file and folder items; to handle each differently,
    we can test the `dwFileAttributes` member of the `WIN32_FIND_DATAA` structure.
    Add the following code in the `do` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WIN32_FIND_DATAA` structure contains just the relative name of the item
    in the folder, so the first few lines create an absolute path. The following lines
    test to see if the item is a folder (directory) or a file. If the item is a file,
    then we simply add it to the vector passed to the function. Add the following
    to the `else` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines initialize a `file_size` structure with the size data,
    and the last line adds a `tuple` with the name of the file and its size to the
    `vector`. So that you can see the results of a simple call to this function, add
    the following to the bottom of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This iterates through the items in the `files` vector. Each item is a `tuple<string,
    file_size>` object and to get the `string` item, you can use the Standard Library
    function, `get,` using 0 as the function template parameter, and to get the `file_size`
    object you call `get` with 1 as the function template parameter. The code calls
    the `setw` manipulator to make sure that the file sizes are always printed in
    a column 16 characters wide. To use this, you need to add an include for `<iomanip>`
    at the top of the file. Notice that `get<1>` will return a `file_size` object
    and this is inserted into `cout`. As it stands, this code will not compile because
    there is no operator to do this. We need to write one.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the definition of the structure, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This operator will alter the `ostream` object, so we store the initial state
    at the beginning of the function and restore the object to this state at the end.
    Since the file size is a 64-bit number, we convert the constituent parts of the
    `file_size` object and then print it out as a hexadecimal number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can compile and run this application. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This will list the names and sizes of the files in the `windows` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more things that need to be done--recurse subfolders and sort
    the data. Both are straightforward to implement. In the `files_in_folder` function,
    add the following code to the code block of the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The search will return the `.` (current) folder and `..` (parent) folder, so
    we need to check for these and ignore them. The next action is to recursively
    call the `files_in_folder` function to obtain the files in the subfolder. If you
    wish, you can compile and test the application, but this time it is best to test
    the code using the `Beginning_C++` folder because recursively listing the Windows
    folder will produce a lot of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code returns the list of files as they were obtained, but we want to see
    them in order of file size. To do this we can use the sort function in the `<algorithm>`
    header, so add an include to this after the include for `<tuple>`. In the `main`
    function, after the call to `files_in_folder,` add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The first two parameters of the `sort` function indicate the range of items
    to check. The third item is a predicate, and the function will pass two items
    from the `vector` to the predicate. You have to return a value of `true` if the
    two parameters are in order (the first is smaller than the second).
  prefs: []
  type: TYPE_NORMAL
- en: 'The predicate is provided by a lambda expression. There are no captured variables
    so the expression starts with `[]` and this is followed by the parameter list
    of the items being compared by the `sort` algorithm (passed by `const` reference,
    because they will not be changed). The actual comparison is carried out between
    the braces. Since we want to list the files in ascending order, we have to ensure
    that the second of the two is bigger than the first. In this code, we use the
    `>` operator on the two `file_size` objects. So that this code will compile, we
    need to define this operator. After the insertion operator add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: You can now compile the example and run it. You should find that the files in
    the specified folder and subfolders are listed in order of the size of the files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions allow you to segment your code into logical routines, which makes
    your code more readable, and gives the flexibility of being able to reuse code.
    C++ provides a wealth of options to define functions, including variable argument
    lists, templates, function pointers, and lambda expressions. However, there is
    one main issue with global functions: the data is separate from the function.
    This means that the function has to access the data via global data items, or
    data has to be passed to a function via a parameter every time the function is
    called. In both cases, the data exists outside the function and could be used
    by other functions unrelated to the data. The next chapter will give a solution
    to this: classes. A `class` allows you to encapsulate data in a custom type, and
    you can define functions on that type so that only these functions will be able
    to access the data.'
  prefs: []
  type: TYPE_NORMAL

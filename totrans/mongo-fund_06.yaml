- en: 6\. Updating with Aggregation Pipelines and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to two additional features of update operations
    in MongoDB. You will first learn how to perform some complex update operations
    using pipeline support. Using pipeline support, you will be able to write a multi-step
    update expression and also refer to the values of other fields. Next, the chapter
    covers the updating of array fields in documents, which involves adding elements
    to an array, updating or deleting all or specific elements, creating arrays as
    a set, and sorting array elements. You will practice pushing unique elements to
    an array and sorting its elements as part of the final activity. By the end of
    this chapter, you will be able to derive update expressions based on the values
    of other fields and manipulate array fields in the documents of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered querying using various operators to prepare query expressions.
    We have also learned how to create, delete, and modify documents in the collection,
    used various delete and update functions, and considered their differences and
    usability. We have also covered how to replace documents and how to perform upsert
    operations using a number of update operators. Now it is time to practice more
    complex update operations using the aggregation pipeline support, and learn how
    to modify arrays in a document.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin this chapter with MongoDB pipeline support, where we will briefly
    introduce the aggregation pipeline and how it helps you to perform more complex
    update operations. We will then cover how to update array fields, how to add and
    sort elements of an existing array, and use an array as a set of unique elements.
    Next, you will learn how to remove the first, last, or another specific element
    from an array. Finally, you will learn how to prepare an array filter with a query
    criterion and use it to modify only specific elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Updating with an Aggregation Pipeline (MongoDB 4.2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we covered update functions that are used to modify
    fields from one or more documents. We also wrote a lot of update operations using
    various operators. As you have seen in the examples, where we assigned a field
    with a new value, we either used hardcoded values (for example, while updating
    `num_mflix_comments`) or dynamically derived values using operators such as `$inc`.
    However, in more complex update operations, you may need to use dynamically derived
    fields that are based on the values of other fields. Or, the update operation
    may involve multiple steps of update expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous versions of MongoDB, referring to other fields' values or writing
    multi-step update operations was not possible, but, with the release of MongoDB
    4.2, all of its update functions have started supporting aggregation pipelines.
    The aggregation pipelines and various aggregation operators will be covered in
    `detail` in *Chapter 7*, *Aggregation Pipelines*. For now, we will limit the discussion
    to writing update expressions using pipeline support.
  prefs: []
  type: TYPE_NORMAL
- en: A pipeline is composed of multiple update expressions called stages. When an
    update operation containing multiple stages of update expressions is executed,
    each of the matched documents is processed and transformed through each stage
    sequentially. The output of the first stage is input for the next stage, until
    the last stage in the pipeline produces the final output. Apart from writing multi-stage
    update expressions, pipeline support also allows the use of field references in
    the update expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In previous update expressions, we have either set hardcoded values on the fields,
    or for numeric fields, we have used various operators to manipulate their existing
    values. However, using pipeline support, we can read and use the values of other
    fields in an update expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the syntax for using aggregation pipelines
    in `updateMany()`. It is the same for all other update functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the second argument to the function, which specifies
    an update expression, is now an array of multiple update expressions or stages.
    As stated, the syntax is only valid if your MongoDB version is 4.2 or later. Instead
    of passing an array, if a document with a single update expression is provided,
    it will be executed as a normal update command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider how the aggregation pipeline allows us to write complex update
    queries and enables us to use field expressions and aggregation operations with
    an example. We have been using the *CH05* database in the previous chapter's examples
    and will continue using it here. If you already have the `users` collection, delete
    all of its elements before we insert two records into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following records to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both documents have an `_id` and `full_name` field, composed of first and last
    names separated by a white space. We will write an update command to split the
    full name into the respective fields of first name and last name, and update the
    `full_name` field so that only the first name appears in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `updateMany()` operation is updating all the documents in the `users`
    collection. The second argument to the function is an array containing three stages
    (`$set`, `$set`, and `$project`). Now, we will go through each of these stages
    and explore the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Operators such as `$project`, `$arrayElemAt`, and `$concat` are aggregation
    operators. These operators cannot be used on versions older than MongoDB 4.2 or
    in an update expression that is not part of the aggregation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1 ($set)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, we are using the `$split` operator to split the full name with
    a white space. This gives us a two-element array containing the first name and
    the last name. We are also creating a new field of `name_array` using the `$set`
    operator and assigning the newly created array to it. `name_array` is a temporary
    field for us.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2 ($set)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, we refer to the array stored in `name_array` and create new fields
    for the first name and last name. To do so, we use `$arrayElemAt` on the name
    array to fetch its element from a specific index position. A new field called
    `first_name` is created using the zeroth position element, and the `last_name`
    field is created using the first index position element. At the end of this stage,
    each user's documents will have `first_name`, `last_name`, `name_array`, and the
    original `full_name` field.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3 ($project)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last stage, we project fields. We explicitly include the `first_name`
    and `last_name` fields and rewrite `full_name` by concatenating `first_name` in
    uppercase and `last_name`; note that we will not change the case for `last_name`.
  prefs: []
  type: TYPE_NORMAL
- en: The `$toUpper` operator refers to the value of `first_name` and returns the
    same string in uppercase. The `$concat` operator accepts an array of strings and
    returns a single string by concatenating all the elements in the same order. Here,
    we were concatenating `first_name` in uppercase, a white space, and `last_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$project` operator is used to project fields and to assign them. In this
    stage, we project `first_name`, `last_name`, and `full_name`, meaning that `name_array`
    will be omitted automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Updating using pipeline support'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Updating using pipeline support'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output shows that the operation was successful. It matched two
    documents and both of them were modified. We will now query the documents and
    see whether they have updated correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `find` query and the output shows that the documents are modified
    correctly. The original full name is correctly split into a first and a last name.
    Also, the first name in the `full_name` field is in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we studied how to write complex update commands using pipeline
    stages and aggregation operator support provided by MongoDB 4.2\. We also learned
    that the stages are executed in sequence and the output of a stage becomes the
    input of the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Array Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned about updating fields in one or more MongoDB
    documents. We also learned how to write update expressions using various operators
    and how to use MongoDB pipeline support. In this section, we will learn about
    updating array fields from a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try some basic update operations on array fields, we will insert the following
    document into the `movies` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The document only has a `title` field and does not contain an array, so let''s
    try creating one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding operation uses `$set` in the `genre` field. The value of `genre`
    is a single-element array—`["unknown"]`. The output can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Updating value of an array field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Updating value of an array field'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output shows that the `genre` field is created and assigned the value of
    the given array. Next, we will remove the fields from the document, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update command uses `$unset` to remove the `genre` field. You
    can see the output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Removing an array field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Removing an array field'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that the field is correctly removed from the document.
    From these two examples, it is clear that when an array field is being updated
    using the array as a value, it is treated like any other field. Next, we will
    see how we can manipulate array elements.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we can update fields with array values. It is useful when we
    want to fully replace an array value. However, to add more elements to an array,
    an operator called `$push` can be used. The operator pushes a given element to
    the end of an array, and if the given field is not present, it is created. Let's
    use this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Adding Elements to Arrays'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will add elements to arrays using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert a single document, add the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The update operation in the preceding snippet finds a document by its `_id`
    value and pushes an element to the `genre` array. This field is currently absent
    in the document. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Adding one element into an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Adding one element into an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown here, the `genre` array field is created successfully, and the given
    element is added to the array. Now add one more genre, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command inserts another genre, `Drama`. You can see the output
    here, which shows that the `Drama` element has been added to the end of the existing
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Adding another element into the array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Adding another element into the array'
  prefs: []
  type: TYPE_NORMAL
- en: We dealt with adding single elements in this exercise. In the next section,
    we will add multiple elements at once.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Multiple Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, `$push` can add one element at a time. To add multiple elements
    to an array in a single update command, we have to use `$push` along with `$each`.
    The following is the syntax for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements that need to be appended to the array are provided to the `$each`
    operator in the form of an array. When such an update expression is executed,
    `$each` iterates through each element, and the element is pushed to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding update operation finds and updates a document by its `_id` field
    and uses `$push` to add elements to the `genre` field. We add two elements to
    the array by providing those two elements to `$each`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Pushing multiple elements into an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Pushing multiple elements into an array'
  prefs: []
  type: TYPE_NORMAL
- en: The document in the response (see the preceding screenshot) indicates that both
    the elements are correctly appended to the end of the array and are added in the
    same order.
  prefs: []
  type: TYPE_NORMAL
- en: Sort Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays in MongoDB, and in general, are an ordered but unsorted collection of
    elements. In other words, the elements of the array will always remain in the
    order in which they were inserted. However, while executing an update command
    with `$push`, we can also sort an array. To do that, we must use the `$sort` operator
    with `$each`. In the previous examples, we added four elements to the `genre`
    array. Now, we will try to sort the array alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we use `$push` in the `genre` field. One thing to
    note is that this query is not pushing any element to the array because there
    are no elements provided to the `$each` operator. The new `$sort` operator is
    assigned the value `1`, which denotes ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Sorting an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Sorting an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown, the `genre` array is now alphabetically sorted in ascending order
    of the elements. In the previous example, we sorted an array without adding an
    element to it, but we can also perform the sort while inserting one or more elements
    into an array. In that case, the new elements will be added to the array, and
    the array will be sorted based on the given sort order. Consider the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this update command, we pass a new element, `Crime`, to the genre. Note
    that the `$sort` operator has a value of `-1`. When we execute this command, the
    new element will be added to the array, and the array will be sorted in descending
    alphabetical order. This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Sorting an array and pushing elements into it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Sorting an array and pushing elements into it'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the response, the array is sorted in descending order and
    the new element, `Crime`, is part of the `genre` array. Without providing the
    `$sort` operator, the new element would be appended to the end of the array. In
    both the previous examples, the `genre` array contains plain string elements.
    However, if we have an array of objects that contains multiple fields, sorting
    can be performed based on the fields of nested objects. Consider the following
    record in an `items` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `items` field is an array of four objects, each containing three fields.
    We will sort the array by price now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The update command finds one document and sorts the array field. Unlike the
    previous examples, this time we want to sort the elements based on their nested field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Sorting an array based on a value of a nested field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Sorting an array based on a value of a nested field'
  prefs: []
  type: TYPE_NORMAL
- en: Note the array field in the modified document. All the elements are now sorted
    in descending order by price. In the next section, we will learn about using arrays
    in MongoDB as sets.
  prefs: []
  type: TYPE_NORMAL
- en: An Array as a Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is an ordered collection of elements that can be iterated over or accessed
    using its specific index position. A set is a collection of unique elements whose
    order is not guaranteed. MongoDB supports only plain arrays and no other types
    of collections. However, you may want your array to contain unique elements only.
    MongoDB provides a way to do that by using the `$addToSet` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$addToSet` operator is like `$push`, with the only difference being that
    an element will be pushed only if it is not present already. This operator does
    not change the underlying array, but it ensures that only unique elements are
    pushed into it. Currently, the document for the movie `Macbeth` in our `movies`
    collection looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `genre` array is a really good example, wherein you want your array to
    have unique elements because duplicate genres for a movie do not make sense. Consider
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the update operation uses `$addToSet` to push an element of `Action`
    in the `genres` array. Note that the element is already part of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Adding element into an array as a set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Adding element into an array as a set'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding screenshot, the `Action` element was not pushed
    to the array because the array already contains it. The same behavior is evident
    even when we use `$each` to push multiple elements into an array. For example,
    consider this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `$each` to add three genres to the array, of which only the middle
    one is new:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Adding multiple elements into an array as a set'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Adding multiple elements into an array as a set'
  prefs: []
  type: TYPE_NORMAL
- en: The modified document confirms that only the new genre, `Thriller`, has been
    added to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: New Category of Classic Movies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recently, due to the re-release of `Casablanca`, there has been quite an upsurge
    in demand for classic movies. The analytics department at your company found that,
    not surprisingly, classics are the only movies that both critics and viewers have
    rated above 95\. So, your company wants to assign all those movies in the database
    to a new genre, called "Classic." In your movie documents, a sample tomato rating
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your task is to put a filter on the meter field in both the `viewer` and `critic`
    sub-objects to find classic movies and assign them the new genre. The following
    steps will help you to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor and start writing a query. You will have to prepare an update
    command to update multiple documents, so use `updateMany()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first criterion in finding movies is that the tomato meter rating from
    viewers needs to be more than `95`. Type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have added a filter to the viewer meter. As the field is nested within
    a nested field, you used the dot notations accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the second criterion, you need to put the same filter on the `critic`
    ratings. Add the second criterion to the query, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, you have added the same filter to the critic meter.
    The command now has all the required filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create an update expression to add a new genre called `Classic` to all
    the matching movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You have now added the update expression. Note that the genres in the array
    should always be unique and so you would use `$addToSet` instead of `$push` to
    add the `Classic` element to the `genres` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a MongoDB shell and connect to the Mongo Atlas cluster, and then
    go to the `sample_mflix` database. Execute the preceding command on the database.
    The output should be as follows:![Figure 6.12: Adding the new genre'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Adding the new genre'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that all 30 records have been updated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify this, write a `find` query using the same condition and project the
    essential fields with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` query here uses the same filter and displays only the `title` and
    `genres` fields. You can see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Output showing the movies belonging to the Classic genre'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Output showing the movies belonging to the Classic genre'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that all of the movies now have the new genre, `Classic`.
    In this exercise, you used the concept of sets for a business use case. In the
    next section, let's look at the deletion of array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Array Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have studied the various means of adding elements to an array and
    sorting an array using various operators. MongoDB also provides the means of removing
    elements from arrays. In this section, we will go through different operators
    that allow you to remove all or specific elements from an array.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the First or Last Element ($pop)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `$pop` operator, when used in an update command, allows you to remove the
    first or last element in an array. It removes one element at a time and can only
    be used with the values `1` (for the last element) or `-1` (for the first element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in the preceding snippet shows the movie record as having six elements
    in the `genre` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `findOneAndUpdate` operation makes use of `$pop` on the `genre`
    field with the value `1`, which will remove the last element from the array. All
    other aspects of the command are the same as we have seen in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Removing the last element from an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: Removing the last element from an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified document indicates that the last element (`Thriller`) has been
    successfully removed from the array. Now, use the following command with the value
    of `$pop` as `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Removing the first element from an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: Removing the first element from an array'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that the first element of the array (`'Unknown'`) has now been
    removed. Remember that `$pop` only allows `1` or `-1` as a value and that providing
    any other number, including a zero, results in an error.
  prefs: []
  type: TYPE_NORMAL
- en: Removing All Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you only need to remove certain elements from an array, you can use the
    `$pullAll` operator. To do so, you provide one or more elements to the operator,
    which then removes all occurrences of those elements from the array. For instance,
    consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this update operation, we use `$pullAll` in the `genre` field. We provide
    two elements, `Action` and `Crime`, in the form of an array. The output for this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Removing all elements of an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: Removing all elements of an array'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the specified genres, `Action` and `Crime`, are now removed
    from the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Matched Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we saw how we can use `$pullAll` to remove specific
    elements from an array. In this example, we will use another operator, called
    `$pull`, to write a query condition, using various logical and conditional operators,
    and the array elements that match the query will then be removed. As an example,
    consider the following snippet, in which an array named `items` contains four
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a query to update the array with `$pull`. Remember that
    it allows us to use combinations of logical and conditional operators to prepare
    a query condition, just like any `find` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this update command, the `$pull` operator is provided with a query condition
    in the array field `items`. The conditions filter the array elements, where the
    `quantity` is `3` and the `name` ends with ''ck''. The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Removing elements that matched the given regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Removing elements that matched the given regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: The document in response shows that an element where the quantity was `3` and
    name ends with 'ck' is removed, as expected. Let's now look at updating array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Array Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an array, each element is bound to a specific index position. These index
    positions start at zero, and we can use a pair of square brackets (`[`, `]`) with
    the respective index position to refer to an element from the array. Using such
    a pair of square brackets with `$` allows you to update elements of an array.
    Consider the following snippet, which shows how the `genres` array looks currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `genres` array has two elements, and we will update both of them using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this operation, we use `$set` in the `genres` field. The field is referred
    to by using the expression `"genre.$[]"` expression and provided with the value
    `Action` value. The `$[]` operator refers to all the elements contained by the
    given array and the update expression will be applied to all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: Replacing all elements from an array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: Replacing all elements from an array'
  prefs: []
  type: TYPE_NORMAL
- en: The document, in response, indicates that `genre` is still a two-element array.
    However, both elements are now changed to `Action`. Therefore, we can use `$[]`
    to update all elements of an array with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can also update specific elements from an array. To do so, we
    first need to find such elements and identify them. To derive an element identifier,
    we can use the update option of `arrayFilters` to provide a query condition and
    assign it a variable (known as an identifier) to the matching elements. We then
    use the identifier along with `$[]` to update the values of those specific elements.
    To see an example of this, we will use the document from our `items` collection
    and add one more element to its array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding `update` command, we have added a new element to the array.
    Notice that the newly added element does not have the `price` and `quantity` fields.
    In the following update command, we will find and update elements from this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding update operation, we use `$set` to update the elements of
    the `items` array. The array element to be updated is referred to by an expression
    of `$[myElements]` and assigned a new value, which is a nested object. The identifier
    of `myElements` is defined using `arrayFilters` based on a query condition. All
    of the elements that match the given condition are identified by `myElements`,
    which are then updated using `$set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: Replacing elements that match given filters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Replacing elements that match given filters'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query condition of `{quantity: null}` is matched by the last element of
    the array and has been updated with the new document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Updating the Director''s Name'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On your movie website, people can find movies by their title or by names of
    actors or directors. Your task for this exercise is to connect to update the name
    of one of these directors from `H. C. Potter` to `H. C. Potter (Henry Codman Potter)`,
    so that users don''t confuse him with another director who has a similar name.
    Remember, a movie or a series can be directed by multiple people. The `directors`
    field in your database is an array, and a person from the directors'' team can
    appear at any index position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This `find` command finds all the movies by the director''s abbreviated name
    and prints the movie title, followed by the director''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the mongo shell and connect to the `sample_mflix` database on your Mongo
    Atlas cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As all six movies need to be updated, use the `updateMany()` update function.
    Open any text editor and write the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the director''s abbreviated name in the query condition, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This command is still incomplete and syntactically invalid. So far, you have
    only added the query condition to the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the update expression. As you are changing a field here, use the
    `$set` operator in the array field. Also, to change only a specific element in
    an array, use an element identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding (and still incomplete) command, you have added an update expression
    that uses the `$set` operator on the array. Notice that the array element to which
    the `hcPotter` identifier refers is being assigned with the new value—that is,
    `Henry Codman Potter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have used an element identifier in the update expression, define
    the identifier using `arrayFilters` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the preceding snippet, you have added an option of `arrayFilters`.
    The identifier of `hcPotter` is given a value of `H.C. Potter`—the value that
    currently exists in the arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the mongo shell and connect to the MongoDB Atlas cluster. Use the
    database of `sample_mflix` and execute the preceding command.![Figure 6.20: Updating
    the name of the director'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Updating the name of the director'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that all six records were found and updated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, find the director''s movies with his full name using a regular expression
    in the `directors` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The query uses a regular expression to find the movies of the director according
    to his full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21: Output showing the director''s correct name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.21: Output showing the director''s correct name'
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that you have correctly updated the director's name in
    all the records. In this exercise, you practiced using array filters to modify
    only the matching elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we studied how to update array fields in a document. We learned
    to add new elements, remove elements from an array, and update specific elements
    in an array. We also learned how to treat an array as a set and sort existing
    or new elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Adding an Actor''s Name to the Cast'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recently, an error in the database came to your attention. The actor Nick Robinson
    played the character of `Zach` in the 2015 movie, `Jurassic World`. However, the
    `cast` field in the movie record does not attribute this actor to this movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: Showing only casts of the movie'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.22: Showing only casts of the movie'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output, as shown in the preceding screenshot, confirms that the actor''s
    name is missing. Your task for this activity is to add `Nick Robinson` to the
    cast of this movie and sort this array by actor names. As a best practice, you
    should also ensure that the `cast` array has unique values. The following steps
    will help you to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a query expression based on the movie title and add an update expression
    to it. As you have to avoid duplicate insertions, you should treat the array as
    a set by using the `$addToSet` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to sort the array. Since sets are considered to be collections
    of unique and unordered elements, you cannot sort the elements while using `$addToSet`.
    So, first push the element in the array of unique elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, create another update command and sort all the arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this activity, you added unique elements to an array and sorted them. You
    also verified that it isn't possible to add elements to an array as a set and
    sort it at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor471).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by learning how to update documents using aggregation
    pipeline support. Pipeline support, which was introduced in MongoDB version 4.2,
    helps us to perform some complex updates. Using pipeline support, we can write
    multi-stage update expressions, where the output of a stage is provided as input
    to the next stage. It also allows us to use field references and aggregation operators.
    We also learned how to manipulate elements in array fields, how to add, remove,
    and update elements in an array, how to sort an array, and how to add only unique
    elements to an array.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about MongoDB aggregation framework and pipeline
    in detail.
  prefs: []
  type: TYPE_NORMAL

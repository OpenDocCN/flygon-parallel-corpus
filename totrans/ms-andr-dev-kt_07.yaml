- en: Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we obtained crucial permissions needed to access Android
    system features. In our case, we obtained location permissions. In this chapter,
    we will move on by inserting data into the database. We will insert location data
    that we will get from Android's location provider. For that purpose, we will define
    proper database schema and management classes. We will also define classes to
    access the location provider to obtain location data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To persist data for our application, we will need a database. In Android, for
    offline data storage, you can use SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is supported out of the box, which means that it comes included with
    the Android Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benefits of SQLite are that it is powerful, fast, and reliable with a huge community
    that uses it. If you find any problem, it will be easy to find a solution since
    somebody from the community has most likely already solved such issues. SQLite
    is a self-contained, embedded, full-featured, public-domain SQL database engine.
  prefs: []
  type: TYPE_NORMAL
- en: We will use SQLite to store all our Todos and Notes. To do that, we will define
    our database, the mechanism for accessing it, and data management. We will not
    expose a naked database instance directly, but we will wrap it properly so it
    is easy to insert, update, query, or remove data.
  prefs: []
  type: TYPE_NORMAL
- en: Describing our database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First thing we will do is describe our database by defining its tables and
    columns with proper data types. We will also define simple models that will represent
    our data. To do so, create a new package called `database`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new Kotlin class called `DbModel`. The `DbModel` class will
    represent the matrix for all database models of our application and will contain
    only the ID, since the ID is a mandatory field and will be used as a primary key.
    Make sure your `DbModel` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we define our starting point, we will define data classes that will
    actually contain data. Inside our existing package called `model`, create new
    classes--`DbEntry`, `Note`, and `Todo`. `Note` and `Todo` will extend `Entry`,
    which extends the `DbModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Entry` class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we put the current geolocation as the information stored
    in our note along with `title` and note `message` content. We also overrode the
    ID. Since the newly instantiated `note` is not yet stored into the database, its
    ID will be zero. After we store it, it will be updated to the ID value obtained
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Todo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Todo` class will have one additional field than the `Note` class--`timestamp`
    for the time when `todo` is scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after we define our data models, we will describe our database. We have
    to define the database helper class responsible for database initialization. The
    database helper class must extend Android''s `SQLiteOpenHelper` class. Create
    the `DbHelper` class and make sure it extends the `SQLiteOpenHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our class `companion` object contains definitions for table and column names.
    We also defined SQLs for tables creation. Finally, SQLs are executed in the `onCreate()`
    method. In the next section, we will go further with database management and finally
    insert some data.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CRUD operations are operations for creating, updating, selecting, or removing
    data. They are defined with an interface called `Crud` and it will be generic.
    Create a new interface in the `database` package. Make sure it covers all CRUD
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For executing CRUD operations, there are two method versions. First version
    is the one that accepts *collections of instances* and the second that *accepts
    a single item*. Let''s create CRUD concretization by creating a Kotlin object
    called `Db`. Creating an object makes our concretization a perfect singleton.
    The `Db` object must implement the `Crud` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Insert CRUD operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insert` operation will add new data into the database. What follows is
    its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Update CRUD operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `update` operation will update the existing data in our database. What
    follows is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Delete CRUD operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` operation will remove the existing data from the database. What
    follows is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Select CRUD operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `select` operation will read and return data from the database. What follows
    is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each CRUD operation will obtain a database instance by using our `DbHelper`
    class. We will not expose it directly, but utilize it by our CRUD mechanism. After
    each operation, the database will be closed. We can only get a readable database
    or, like in our case, a `WritableDatabase` instance by accessing `writableDatabase`.
    Each CRUD operation is performed as an SQL transaction. This means that we will
    start it by calling `beginTransaction()` on the database instance. The transaction
    is completed by calling `endTransaction()`. If we do not call `setTransactionSuccessful()`
    before it, no changes will apply. As we already mentioned, there are two versions
    of each CRUD operation--one that contains the main implementation and the second
    that just passes instances to the other. To perform the insert into the database,
    it's important to note that we will use the `insert()` method on the database
    instance that accepts the table name into which we are inserting, and content
    values (`ContentValues` class) that represent the data. The `update` and `delete`
    operations are similar. We use the `update()` and `delete()` methods. In our case,
    for data removal, we used `compileStatement()` containing the delete SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: The code we provided here is a bit complex. We directly pointed only to database
    related matter. So, be patient, read the code slowly, and take your time to investigate
    it. We encourage you to create your own version of database management classes
    in your own way by utilizing the Android database classes we have already mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Tying things together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have one more step! It's the practical use of our database classes and performing
    CRUD operations. We will extend the application to create notes, and we will focus
    on insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we insert anything into the database, we must provide a mechanism to
    obtain the current user location since it''s required for both `notes` and `todos`.
    Create a new class called `LocationProvider` and locate it in the `location` package
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We exposed the main structure for the `LocationProvider` object. Let''s take
    a look at the rest of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `locationListener` instance code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`LocationListener` is Android''s interface whose purpose is to be executed
    on `location` events. We created our concretization that will basically notify
    all subscribed parties about those events. The most important for us is `onLocationChanged()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn on location listening, we must check if permissions are properly fulfilled.
    If that is the case, then we are obtaining Android''s `LocationManager` and defined
    `Criteria` for location updates. We defined our criteria to be very precise and
    accurate. Finally, we request location updates by passing the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`long minTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float minDistance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Criteria criteria`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocationListener listener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Looper looper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, we passed our `LocationListener` concretization that will notify
    all subscribed third parties about `location` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We stopped listening for location by simply removing our listener `instance.doSubscribe()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doUnsubscribe()` method code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These two methods are responsible for subscribing and unsubscribing in location
    updates to interested third parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all we need. Open the `NoteActivity` class and extend it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What did we do here? Let's go from top to bottom and explain everything! We
    added two fields--one that contains the current `Note` instance we are editing
    and one that holds information about the current user's location. Then, we defined
    a `TextWatcher` instance. `TextWatcher` is a listener that we will assign to our
    `EditText` views, and, on each change, the proper update method will be triggered.
    That method will create a new `note` class and persist it into a database if it
    does not exist, or perform a data update if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will not insert note until there is no location data available, we
    defined our `locationListener` to put received location into the location field
    and to unsubscribe itself. Then, we will get the current value for the `note`
    title and its main content and create a new `note` instance. Since the database
    operations can take some time, we will execute them asynchronously. For that purpose,
    we will use the `AsyncTask` class. The `AsyncTask` class is Android's class that
    is intended to be used for the most async operations. Class defines input type,
    progress type, and result type. In our case, input type is `Note`. We do not have
    a progress type, but we have a result type `Boolean`, that is, if the operation
    is successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: The main work is done in the `doInBackground()` concretization while the result
    is handled in `onPostExecute()`. As you can see, we are performing insertion in
    the background using classes we recently defined for database management.
  prefs: []
  type: TYPE_NORMAL
- en: If you keep looking, the next thing we do is assign `textWatcher` to `EditText`
    views in the `onCreate()` method. Then, we define our most important method--`updateNote()`.
    It will update an existing note or insert a new one if it does not exist. Again,
    we used `AsyncTask` to perform an operation in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build your application and run it. Try to insert `note`. Observe your Logcat.
    You will notice database-related logs as your type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you can see these logs, you have successfully implemented your first database
    in Android. We encourage you to extend the code for the rest of the CRUD operations.
    Make sure `NoteActivity` supports the `select` and `delete` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we demonstrated how to persist complex data in Android. Databases
    are the heart of every application, so Journaler is not an exception. We covered
    all CRUD operations performed on the SQLite database and gave a proper implementation
    for each of them. In our next chapter, we will demonstrate another persistence
    mechanism for less complex data. We will deal with Android shared preferences,
    and we will use them to keep simple and small data for our application.
  prefs: []
  type: TYPE_NORMAL

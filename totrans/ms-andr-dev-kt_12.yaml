- en: Backend and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will connect our application to the remote backend instance.
    All data we create will be synchronized to and from the backend. For the API calls,
    we will use Retrofit. Retrofit is the most frequently used HTTP client for the
    Android platform. We will guide you step by step through the common practices
    so you can easily connect and implement connection to backend in any application
    you develop in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is, by far, the longest chapter in this book, and here, we will
    cover many important things such as the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrofit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gson with Kotson library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lists and grids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read this chapter carefully and enjoy playing with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying entities used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we synchronize anything, we must identify exactly what we will synchronize.
    The answer to this question is obvious, but we will recapitulate the list of our
    entities anyway. We have two main entities we are planning to synchronize:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Note` entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Todo` entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`location`: `Location` (will be serialized)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, currently, we represent the location with latitude and longitude
    in our database. We will change this to `Text` type since we will introduce Gson
    and Kotson for serialization/deserialization purposes!
  prefs: []
  type: TYPE_NORMAL
- en: 'Todo specific attributes are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheduledFor`: `Long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, open your classes and take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, it's recommended to use `data` classes as the representation for
    your entities. In our case, we did not use `data` classes since we extended a
    common class containing the attributes shared between the `Note` and `Todo` classes.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend the use of `data` classes since it can significantly simplify your
    work routine, especially if you are using these entities in backend communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not rare that we have a need for classes that have only one purpose--holding
    the data. The benefit of using `data` classes is that some functionality that
    is often used along with its purpose is automatically provided. As you probably
    already know how to define a `data` class, you have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `data` class, the compiler automatically provides you with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `equals()` and `hashCode()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toString()` method in human readable form,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entity(param1=Something, param2=Something)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `copy()` method for the cloning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All `data` classes must satisfy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The primary constructor needs to have at least one parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All primary constructor parameters need to be marked as `val` or `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes cannot be `abstract`, `open`, `sealed`, or `inner`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s introduce some `data` classes! Since we plan to use a remote backend
    instance, it will require some authentication. We will create new entities (`data`
    classes) for the data we pass during the authentication process, and for the result
    of the authentication. Create a new package called `api`. Then, create a new `data`
    class called `UserLoginRequest` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`UserLoginRequest` class will contain our authentication credentials. The API
    call will return a JSON that will be deserialized into the `JournalerApiToken` data
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention that we used the annotation to tell Gson that the token field
    will be obtained from the `id_token` field in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize--Always consider the use of `data` classes! Especially if the data
    they represent will be used for holding database and backend information.
  prefs: []
  type: TYPE_NORMAL
- en: Connect data models to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a scenario like we have with the Journaler application to hold the
    data in the database, and you plan to synchronize it with the remote backend instance,
    it can be a good idea to first create a persistence layer that will store your
    data. Keeping data persisted into a local filesystem database prevents data from
    loss, especially if you have a bigger amount of it!
  prefs: []
  type: TYPE_NORMAL
- en: So, once again, what did we do? We created a persistence mechanism that will
    store all our data into the SQLite database. Then, in this chapter, we will introduce
    the backend communication mechanism. Because we don't know if our API calls will
    fail or whether the backend instance will be available at all, we have the data
    persisted. If we keep our data in the device memory only, and if the API call
    for synchronization fails and our application crashes, we can lose this data.
    Let's say if the API call failed and the application crashed, but we have our
    data persisted, we can retry the synchronization. The data is still there!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Retrofit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned, Retrofit is an open source library. It is the most
    popular HTTP client for Android used today. Because of that, we will introduce
    you to Retrofit basics and demonstrate how to use it. The version we will cover
    is 2.3.0\. We will give you step-by-step guidance on how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, Retrofit depends on some libraries too. We will use it with Okhttp.
    Okhttp is an HTTP/HTTP2 client developed by the same guys who developed Retrofit.
    Before we start, we will put dependencies into our `build.gradle` configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We updated our Retrofit and Okhttp to the latest version. We added dependencies
    for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gson converter that will be used to deserialize the API responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okhttp library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging interceptor for Okhttp so we can log what is going on with our API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we synchronize our Gradle configuration, we are ready to start!
  prefs: []
  type: TYPE_NORMAL
- en: Defining Retrofit service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retrofit turns your HTTP API into a Kotlin interface. Create an interface called
    `JournalerBackendService` inside the API package. Let''s put some code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we have in this interface? We defined a list of calls that will be
    able to execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication for the user: This accepts request headers and instances of
    the `UserLoginRequest` class containing user credentials. It will be used as a
    payload for our call. Executing the call will return a wrapped `JournalerApiToken`
    instance. We will need a token for all other calls, and we will put its content
    into the header of each call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notes` and `TODOs` obtain: This accepts request headers containing the authentication
    token as well. As a result of the call, we get a wrapped list of the `Note` or
    `Todo` class instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notes` and `TODOs` putting (when we send new stuff to the server): This accepts
    request headers containing the authentication token as well. Payload for the call
    will be a list of the `Note` or `Todo` class instances. We will not return any
    important data for these calls. It is important that the response code is positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notes` and `TODOs` removal--This accepts request headers containing the authentication
    token as well. Payload for the call will be a list of `Note` or `Todo` class instances
    to be removed from our remote backend server instance. We will not return any
    important data for these calls. It is important that the response code is positive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each has a proper annotation representing the HTTP method with the path. We
    also use annotations to mark the payload body and headers map.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Retrofit service instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, after we have described our service, we need a real Retrofit instance
    that we will use to trigger API calls. First, we will introduce some additional
    classes. We will hold the latest token instance inside the `TokenManager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also have an object to obtain the API call headers map called `BackendServiceHeaderMap`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can show you how to build a `Retrofit` instance. Create a new object
    called `BackendServiceRetrofit` and make sure it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `obtain()` method will return us a `Retrofit` instance ready to
    fire API calls. We made a `Retrofit` instance with a backend base URL set to local
    host. We also passed the Gson converter factory to be used as a mechanism for
    JSON deserialization. Most importantly, we passed an instance of the client that
    we will use, and we created a new OkHttp client.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Gson with Kotson library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON serialization and deserialization are very important for every Android
    application and are frequently used. For that purpose, we will be using the Gson
    library developed by Google. Also, we will use Kotson and Kotlin bindings for
    Gson. So, let's start!
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to provide dependencies for our `build.gradle` configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will update our code to use Gson with Kotson bindings for location serialization/deserialization
    in database management. First, we need to apply a small change to the `Db` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we changed the location information handling. Instead of having
    location latitude and longitude columns, we now have only one database column--`location`.
    The type is `Text`. We will hold the serialized `Location` class values that will
    be generated by the Gson library. Also, when we retrieve the serialized values,
    we will deserialize them using Gson into `Location` class instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to actually use Gson. Open `Db.kt` and update it to serialize,
    and deserialize `Location` class instances using Gson, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the preceding code, to update using Gson is very simple.
    We rely on the following two Gson library methods accessed from the Gson class
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromJson<T>()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toJson()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to Kotson and Kotlin bindings, we can use a parameterize type for the
    data we serialize using the `fromJson<T>()` method.
  prefs: []
  type: TYPE_NORMAL
- en: What else is available?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will list some alternatives for Retrofit and Gson. Outside, there is
    a big open source community that makes great things every day. You are not obligated
    to use any libraries we present. You can choose any of the alternatives, or even
    create your own implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its homepage says, Volley is an HTTP library that makes networking for Android
    apps easier and, most importantly, faster. Some of the key features Volley offers
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic scheduling of network requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple concurrent network connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent disk and memory response caching with standard HTTP cache coherence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for request prioritization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancellation request API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and tracing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homepage--[https://github.com/google/volley](https://github.com/google/volley).
  prefs: []
  type: TYPE_NORMAL
- en: Gson alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jackson is a low-level JSON parser. It''s very similar to the Java StAX parser
    for XML. Some of the key features Jackson offers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Very fast and convenient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive annotation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming reading and writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-box JAX-RS support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated support for binary content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Homepage--[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson).
  prefs: []
  type: TYPE_NORMAL
- en: Executing our first API call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We defined a Retrofit service with all API calls, but we haven't connected anything
    to it yet. It is time to use it. We will extend our code to use Retrofit. Each
    API call can be executed synchronously or asynchronously. We will show you both
    ways. Do you remember that we set our Retrofit service base URL to the localhost?
    This means that we will need a local backend instance that will respond to our
    HTTP requests. Since backend implementation is not the subject of this book, we
    will leave it up to you to create a simple service responding to this request.
    You can implement it from any programming language you like, such as Kotlin, Java,
    Python, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are impatient and don''t want to implement your own application for
    dealing with HTTP requests, you can override the base URL, Notes, and TODOs paths
    as shown in the following example and use the backend instance ready for tryout:'
  prefs: []
  type: TYPE_NORMAL
- en: Base URL--[http://static.milosvasic.net/json/journaler](http://static.milosvasic.net/json/journaler)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Login POST to target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Notes` `GET` to target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`TODOs` `GET` to target:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Like this, we will target the remote backend instance returning us stub `Notes`
    and `TODOs`. Now open your `JournalerBackendService` interface and extend it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The method we just added will give us an instance of `JournalerBackendService`
    using Retrofit. Through this, we will trigger all our calls. Open the `MainService`
    class. Find the `synchronize()` method. Remember that we put sleep there to simulate
    communication with the backend. Now, we will replace it with real backend calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Analyze the code slowly and take your time! There are a lot of things going
    on! First, we will create instances of headers and the Journaler backend service.
    Then, we performed the authentication synchronously by triggering the `execute()`
    method. We received `Response<JournalerApiToken>`. The `JournalerApiToken` instance
    is wrapped in the `Response` class instance. After we check if the response is
    successful, and that we actually received and deserialized `JournalerApiToken`,
    we set it to `TokenManager`. Finally, we trigger asynchronous calls for `Notes`
    and `TODOs` retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: The `enqueue()` method triggers the async operation, and, as a parameter, accepts
    the Retrofit Callback concretization. We will do the same that we did with the
    sync call. We will check if it is successful and if there is data. If everything
    is ok, we will pass all instances to our database manager for saving.
  prefs: []
  type: TYPE_NORMAL
- en: We only implemented the `Notes` and `TODOs` retrieval. For the rest of the API
    calls, we leave it up to you to do the implementation. It is a great way to learn
    Retrofit!
  prefs: []
  type: TYPE_NORMAL
- en: Let's build you an application and run it. As an application and its main service
    starts, the API calls are executed. Filter the Logcat output by OkHttp. Observe
    the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication log lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Notes` log lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`TODOs` log lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request: This is an example of the request part we do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Response: This is an example of the response we receive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have implemented your first Retrofit service! Now it is
    time to implement the rest of the calls. Also, do some code refactoring! This
    is a small homework task for you. Update your service so it can accept login credentials.
    In our current code, we hardcoded the username and password. Your mission will
    be to refactor the code and pass the parameterized credential.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, improve the code so it's no longer possible to execute the same
    call multiple times at the same moment. We left this as the legacy from our previous
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Content providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to further improve our application and introduce you to Android content
    providers. Content providers are one of the top power features Android Framework
    has to offer. What is the purpose of content providers? As its name suggests,
    content providers have the purpose of managing access to data stored by our application
    or stored by other applications. They provide a mechanism for sharing the data
    with other applications and provide a security mechanism for data access, that
    may or may not be from the same process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following illustration displaying how content provider can
    manage access to shared storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad7d8f5f-eed6-4480-988f-3d2429c76339.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a plan to share `Notes` and the `TODOs` data with other applications.
    Thanks to the abstraction layer content providers offers, it''s easy to make the
    changes in the storage implementation layer without affecting the upper layers.
    Because of this, you can use content providers even if you do not plan to share
    any data with other applications. We can, for example, completely replace the
    persistence mechanism from SQLite to something completely different. Take a look
    at the following illustration showing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0109ab05-42bf-40e3-87d1-d34dd8ee5ebd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are not sure whether you need content provider or not, here is when
    you should implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to share your application's data with other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are planning to copy and paste complex data or files from your application
    to other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are planning to support custom search suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Framework comes with an already defined content provider that you
    can use; for example, to manage contacts, audio, video, or other files. Content
    providers are not limited to SQLite access only, but you can use it for other
    structured data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s once again highlight the main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Permissions over accessing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracting the data layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, as we already said, we are planning to support data exposure from the Journaler
    application. Before we create our content provider, we must note that this will
    require refactoring of the current code. Don't worry, we will present content
    provider, explain it to you and all the refactoring we do. After we do this--finish
    our implementation and refactoring--we will create an example client application
    that will use our content provider and trigger all the CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `ContentProvider` class. Create a new package called `provider`
    with the `JournalerProvider` class extending the `ContentProvider` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining a `companion` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Class initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Overriding the `onCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the operation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Class ending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Going from top to bottom, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined the database name and version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined the database instance lazy initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined the URI(s) we will use to access the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented all the CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined the MIME type for the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you have a content provider implementation, it is required to register
    it in your `manifest` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Observe. We set the exported attribute to `True`. What does this mean? It means
    that, if `True`, the Journaler provider is available to other applications. Any
    application can use the provider's content URI to access the data. One more important
    attribute is `multiprocess`. If the app runs in multiple processes, this attribute
    determines whether multiple instances of the Journaler provider are created. If
    `True`, each of the applications' processes has its own content provider instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue. In the `Crud` interface, add this to the `companion` object
    if you do not have it already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will rename our `Db` class into Content. Update the `Content` implementation,
    as follows, to use `JournalerProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Note` insert operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`Note` update operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Note` delete operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Note` select operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`Todo` object definition and its insert operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`Todo` update operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Todo` delete operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`Todo` select operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the code carefully. We replaced the direct database access with content
    provider. Update your UI classes to use the new refactored code. If you have trouble
    doing this, you can take a look at the GitHub branch containing these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12](https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The branch also contains an example of the Journaler content provider client
    application. We will highlight an example of use on the client application''s
    main screen containing four buttons. Each button triggers an example of the CRUD
    operation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates how to trigger CRUD operations from other applications
    using content provider.
  prefs: []
  type: TYPE_NORMAL
- en: Android adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To present content on our main screen, we will use the Android Adapter class.
    The Android Framework offers adapters as a mechanism to provide items to view
    groups as lists or grids. To show an example of Adapter usage, we will define
    our own adapter implementation. Create a new package called `adapter` and an `EntryAdapter`
    member class extending the `BaseAdapter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We overrode the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getView()`: This returns the instance of the populated view based on the current
    position in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getItem()`: This returns the instance of the item we use to create the view;
    in our case, this is the `Entry` class instance (`Note` or `Todo`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getItemId()`: This returns the ID for the current item instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCount()`: This returns the total number of items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will connect the adapter and our UI. Open `ItemsFragment` and updated its
    `onResume()` method to instantiate the adapter and assign it to a `ListView`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you build and run your application, you should see every page of `ViewPager`
    populated with the loaded items, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fdfdd42-d4ba-4f48-b569-5da14b86d4f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Content loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Content loaders provide you with a mechanism to load data from a content provider
    or other data source for display in a UI component, such as Activity or Fragment.
    These are the benefits that loaders provide:'
  prefs: []
  type: TYPE_NORMAL
- en: Running on a separate thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying thread management by providing callback methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loaders persist and cache results across configuration changes, which prevents
    duplicated queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can implement and be observers to monitor changes in the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will create our content loader implementation. First, we need to update
    the `Adapter` class. Since we will deal with cursors, we will use a `CursorAdapte`r
    instead of `BaseAdapter`. `CursorAdapter` accepts a `Cursor` instance as a parameter
    in the primary constructor. The `CursorAdapter` implementation is much simpler
    than the one we have right now. Open `EntryAdapter` and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following two methods to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`newView()`: This returns the instance of the view to populate with data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindView()`: This populates data from the `Cursor` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let''s update our `ItemsFragment` class, so it uses the content loader
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize `LoaderManager` by calling the `LoaderManager` member of our
    Fragment. The two crucial methods we execute are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initLoader()`: This ensures a loader is initialized and active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restartLoader()`: This starts a new or restarts an existing `loader` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both methods accept the loader ID and bundle data as arguments and the `LoaderCallbacks<Cursor>`
    implementation, which provides the following three methods to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreateLoader()`: This instantiates and returns a new loader instance for
    the ID we provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadFinished()`: This is called when a previously created loader has finished
    loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoaderReset()`: This is called when a previously created loader is being
    reset, and, because of that, making its data unavailable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android supports a mechanism for data binding so that data is bound with views
    and the glue code is minimized. Enable data binding by updating your build Gradle
    configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can define your binding expressions. Take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s bind the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That's it! See how simple it is to bind data to layout views! We strongly recommend
    that you play with data binding as much as you can. Create your own examples!
    Feel free to experiment!
  prefs: []
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We showed you how to work with data. As you noticed, in the main view data container,
    we used `ListView`. Why did we choose it? First of all, it's the most commonly
    used container to hold your data. In most cases, you will use `ListView` to hold
    the data from your adapters. Never put a large number of views in a scrollable
    container like `LinearLayout`! Whenever possible, use `ListView`. It will recycle
    views when they are not needed anymore and reinstantiate them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists can affect your application performance since it's a well-optimized
    container for displaying your data. Displaying a list is an essential functionality
    of almost any application! Any application that produces a set of data as a result
    of some operation needs a list. It's almost impossible that you will not use it
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Using grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We noted how lists are important. However, what if we plan to present our data
    as a grid? Lucky for us!! The Android Framework provides us with a `GridView`
    that works very similar to `ListView`. You define your `GridView` in layout and
    assign the adapter instance to `GridView`''s adapter property. `GridView` will
    recycle all views for you and perform instantiation when needed. The main difference
    between the list and the grid is that you have to define the number of columns
    for your `GridView`. The following example will present you with an example of
    `GridView`''s use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will highlight the important attributes we used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`columnWidth`: This specifies the width for each column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numColumns`: This specifies the number of columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalSpacing`: This specifies the vertical spacing between the rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`horizontalSpacing`: This specifies the horizontal spacing between the items
    in the grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try updating the current application's main `ListView` to present the data as
    `GridView`. Adjust it so it looks pleasant for the end user. Once again, feel
    free to experiment!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing drag and drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, in the last section of this chapter, we will show you how to implement
    the drag and drop feature. It's a feature that you will probably need in most
    applications containing data in lists. Using lists is not mandatory for performing
    drag and drop, because you can drag anything (view) and release it anywhere where
    a proper listener is defined. For a better understanding of what we are talking
    about, we will show you an example of how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a view. On that view, we will set a long press listener that
    will trigger the drag and drop operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `ClipData` class to pass the data to drop a target. We defined
    `dragListener` like this and assigned it to a view where we expect it to drop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Drag listener will fire up the code when we start dragging a view and finally
    release it on the `target` view that has the listener assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of topics. We learned about backend communication,
    how to establish communication with the backend remote instance using Retrofit,
    and how to handle the data we obtain. The aim of this chapter was to work with
    content providers and content loaders. We hope you realized their importance and
    what their benefits are. Finally, we demonstrated data binding; noted the importance
    of our data view containers, such as `ListView` and `GridView`; and showed you
    how to carry out the drag and drop operation. In the next chapter, we will start
    testing our code. Be ready for the performance optimization since that is what
    we will do in the next chapter!
  prefs: []
  type: TYPE_NORMAL

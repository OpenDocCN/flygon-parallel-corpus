- en: Building Gameplay Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come to the point on our journey where we are able to start piecing
    together the various systems that we will be using to drive our games and tools.
    These systems are the parts of the engine that power the interactions with all
    the amazing assets we are now able to import into our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing camera systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use states in many different ways. They can be used for controlling the game
    flow, handling the different ways characters can act and react, even for simple
    menu navigation. Needless to say, states are an important requirement for a strong
    and manageable code base.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different types of states machines; the one we will focus on
    in this section is the **Finite State Machine (FSM)** pattern. Observant readers
    among you will have noticed that we have already seen an FSM pattern in the function
    of the screen system that has been implemented. In fact, what we will be creating
    here is very similar to what was created for that system with some key differences
    that will make this a more generic and flexible state machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways we can implement a simple state machine in our game. One
    way would be to simply use a switch case set up to control the states and an `enum`
    structure for the state types. An example of this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using a switch/case like this can be effective for a lot of situations, but
    it does have some strong drawbacks. What if we decide to add a few more states?
    What if we decide to add branching and more `if` conditionals?
  prefs: []
  type: TYPE_NORMAL
- en: The simple switch/case we started out with has suddenly become very large and
    undoubtedly unwieldy. Every time we want to make a change or add some functionality,
    we multiply the complexity and introduce more chances for bugs to creep in. We
    can help mitigate some of these issues and provide more flexibility by taking
    a slightly different approach and using classes to represent our states. Through
    the use of inheritance and polymorphism, we can build a structure that will allow
    us to chain together states and provide the flexibility to reuse them in many
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through how we can implement this in our demo examples, starting
    with the base class we will inherit from in the future, `IState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is just a very simple class that has a constructor, a
    virtual destructor, and three completely virtual functions that each inherited
    state must override. `OnEntry`, which will be called as the state is first entered,
    will only execute once per state change. `OnExit`, like `OnEntry`, will only be
    executed once per state change and is called when the state is about to be exited.
    The last function is the `Update` function; this will be called once per game
    loop and will contain much of the state''s logic. Although this seems very simple,
    it gives us a great starting point to build more complex states. Now let''s implement
    this basic `IState` class in our examples and see how we can use it for one of
    the common needs of a state machine: creating game states.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new class called `GameState` that will inherit from
    `IState`. This will be the new base class for all the states our game will need.
    The `GameState.h` file consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `GameState` class is very much like the `IState` class it inherits from,
    except for one key difference. In this class, we add a new virtual method `Draw()`
    that all classes will now inherit from `GameState` will be implemented. Each time
    we use `IState` and create a new specialized base class, player state, menu state,
    and so on, we can add these new functions to customize it to the requirements
    of the state machine. This is how we use inheritance and polymorphism to create
    more complex states and state machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our example, let''s now create a new `GameState`. We start
    by creating a new class called `GameWaiting` that inherits from `GameState`. To
    make it a little easier to follow, I have grouped all of the new `GameState` inherited
    classes into one set of files `GameStates.h` and `GameStates.cpp`. The `GamStates.h`
    file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new here; we are just declaring the functions for each of our `GameState`
    classes. Now, in our `GameStates.cpp` file, we can implement each individual state''s
    functions as described in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of page space, I am only showing the `GameWaiting` implementation,
    but the same goes for the other states. Each one will have its own unique implementation
    of these functions, which allows you to control the code flow and implement more
    states as necessary without creating a hard-to-follow maze of code paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our states defined, we can implement them in our game. Of
    course, we could go about this in many different ways. We could follow the same
    pattern that we did with our screen system and implement a `GameState` list class,
    a definition of which could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Or we could simply use the `GameState` classes we created with a simple `enum`
    and a switch case. The use of the state pattern allows for this flexibility. In
    the examples case, I chose to follow the same design as the screen system; you
    can see the full implementation of the `GameStateExample` project in the source
    code repository. It's worth going through the source code, as we will continue
    to use these state designs throughout the book. Try to modify the example; add
    a new state that creates a different print out on the screen than the others.
    You could even try nesting states within states to create even more powerful code
    branching abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have discussed a good amount about the structure of systems
    and have now been able to move on to designing ways of interacting with our game
    and 3D environment. This brings us to an important topic: the design of virtual
    camera systems. A camera is what provides us with a visual representation of our
    3D world. It is how we immerse ourselves and it provides us with feedback on our
    chosen interactions. In this section, we are going to go over the concept of a
    virtual camera in computer graphics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into writing the code for our camera, it is important to have
    a strong understanding of how, exactly, it all works. Let''s start with the idea
    of being able to navigate around the 3D world. In order to do this, we need to
    use what is referred to as a transformation pipeline. A transformation pipeline
    can be thought of as the steps that are taken to transform all objects and points
    relative to the position and orientation of a camera viewpoint. The following
    is a simple diagram that details the flow of a transformation pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3452a528-196c-4721-87af-496f5aca1405.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Beginning with the first step in the pipeline, local space, when a mesh is
    created it has a local origin 0 x, 0 y, 0 z. This local origin is typically located
    in either the center of the object or in the case of some player characters, the
    center of the feet. All points that make up that mesh are then based on that local
    origin. When talking about a mesh that has not been transformed, we refer to it
    as being in local space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39326e41-9c69-40b2-af8d-ee369ac280a0.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image pictures the gnome mesh in a model editor. This is what
    we would consider local space.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we want to bring a mesh into our environment, the world space.
    In order to do this, we have to multiply our mesh points by what is referred to
    as a model matrix. This will then place the mesh in world space, which sets all
    the mesh points to be relative to a single world origin. It's easiest to think
    of world space as being the description of the layout of all the objects that
    make up your game's environment. Once meshes have been placed in world space,
    we can start to do things such as compare distances and angles. A great example
    of this step is when placing game objects in a world/level editor; this is creating
    a description of the model's mesh in relation to other objects and a single world
    origin (0,0,0). We will discuss editors in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in order to navigate this world space, we have to rearrange the points
    so that they are relative to the camera's position and orientations. To accomplish
    this, we perform a few simple operations. The first is to translate the objects
    to the origin. First, we would move the camera from its current world coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example figure, there is **20** on the *x* axis, **2** on
    the *y* axis, and **-15** on the *z* axis, to the world origin or **0,0,0**. We
    can then map the objects by subtracting the camera''s position, the values used
    to translate the camera object, which in this case would be **-20**, **-2**, **15**.
    So if our game object started out at **10.5** on the *x* axis, **1** on the *y*
    axis, and **-20** on the *z* axis, the newly translated coordinates would be **-9.5**,
    **-1**, **-5**. The last operation is to rotate the camera to face the desired
    direction; in our current case, that would be pointing down the -*z* axis. For
    the following example, that would mean rotating the object points by **-90** degrees,
    making the example game object''s new position **5**, **-1**, **-9.5**. These
    operations combine into what is referred to as the view matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a47e37f1-60e7-46d4-93c7-82d8ce00cbb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we go any further, I want to briefly cover some important details when
    it comes to working with matrices, in particular, handling matrix multiplication
    and the order of operations. When working with OpenGL, all matrices are defined
    in a column-major layout. The opposite being row-major layout, found in other
    graphics libraries such as Microsoft''s DirectX. The following is the layout for
    column-major view matrices, where U is the unit vector pointing up, F is our vector
    pointing forward, R is the right vector, and P is the position of the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b8ec10-e037-4bb2-b309-2fb5b85d7d33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When constructing a matrix with a combination of translations and rotations,
    such as the preceding view matrix, you cannot, generally, just stick the rotation
    and translation values into a single matrix. In order to create a proper view
    matrix, we need to use matrix multiplication to combine two or more matrices into
    a single final matrix. Remembering that we are working with column-major notations,
    the order of the operations is therefore right to left. This is important since,
    using the orientation (R) and translation (T) matrices, if we say V = T x R, this
    would produce an undesired effect because this would first rotate the points around
    the world origin and then move them to align to the camera position as the origin.
    What we want is V = R x T, where the points would first align to the camera as
    the origin and then apply the rotation. In a row-major layout, this is the other
    way around of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a829f1e-437e-43fb-b03c-e69e8fdbf898.png)'
  prefs: []
  type: TYPE_IMG
- en: The good news is that we do not necessarily need to handle the creation of the
    view matrix manually. Older versions of OpenGL and most modern math libraries,
    including GLM, have an implementation of a `lookAt()` function. Most take a version
    of camera position, target or look position, and the up direction as parameters,
    and return a fully created view matrix. We will be looking at how to use the GLM
    implementation of the `lookAt()` function shortly, but if you want to see the
    full code implementation of the ideas described just now, check out the source
    code of GLM which is included in the project source repository.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing through the transformation pipeline, the next step is to convert
    from eye space to homogeneous clip space. This stage will construct a projection
    matrix. The projection matrix is responsible for a few things.
  prefs: []
  type: TYPE_NORMAL
- en: First is to define the near and far clipping planes. This is the visible range
    along the defined forward axis (usually *z*). Anything that falls in front of
    the near distance and anything that falls past the far distance is considered
    out of range. Any geometrical objects that are on the outside of this range will
    be *clipped* (removed) from the pipeline in a later step.
  prefs: []
  type: TYPE_NORMAL
- en: Second is to define the **Field of View** (**FOV**). Despite the name, the field
    of view is not a field but an angle. For the FOV, we actually only specify the
    vertical range; most modern games use 66 or 67 degrees for this. The horizontal
    range will be calculated for us by the matrix once we provide the aspect ratio
    (how wide compared to how high). To demonstrate, a 67 degree vertical angle on
    a display with a 4:3 aspect ratio would have a FOV of 89.33 degrees (*67 * 4/3
    = 89.33*).
  prefs: []
  type: TYPE_NORMAL
- en: These two steps combine to create a volume that takes the shape of a pyramid
    with the top chopped off. This created volume is referred to as the view frustum.
    Any of the geometry that falls outside of this frustum is considered to be out
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates what the view frustum looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f7c74c5-f2d2-4d17-86f8-d91a3f38037e.png)'
  prefs: []
  type: TYPE_IMG
- en: You might note that there is more visible space available at the end of the
    frustum than in the front. In order to properly display this on a 2D screen, we
    need to tell the hardware how to calculate the perspective. This is the next step
    in the pipeline. The larger, far end of the frustum will be pushed together creating
    a box shape. The collection of objects visible at this wide end will also be squeezed
    together; this will provide us with a perspective view. To understand this, imagine
    the phenomenon of looking along a straight stretch of railway tracks. As the tracks
    continue into the distance, they appear to get smaller and closer together.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the pipeline, after defining the clipping space, is to use
    what is called the perspective division to normalize the points into a box shape
    with the dimensions of (-1 to 1, -1 to 1, -1 to 1). This is referred to as the
    **normalized device space**. By *normalizing* the dimensions into unit size, we
    allow the points to be multiplied to scale up or down to any viewport dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The last major step in the transformation pipeline is to create the 2D representation
    of the 3D that will be displayed. To do this, we flatten the normalized device
    space with the objects further away being drawn behind the objects that are closer
    to the camera (draw depth). The dimensions are scaled from the *X* and *Y* normalized
    values into actual pixel values of the viewport. After this step, we have a 2D
    space referred to as the **Viewport space**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the transformation pipeline stages. With that theory covered,
    we can now shift to implementation and write some code. We are going to start
    by looking at the creation of a basic, first person 3D camera, which means we
    are looking through the eyes of the player''s character. Let''s start with the
    camera''s header file, `Camera3D.h`, which can be found in the `Chapter05` project
    folder in the source code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with the necessary includes. As I just mentioned, GLM includes support
    for working with matrices, so we include both `glm.hpp` and the `matrix_transform.hpp`
    to gain access to GLM''s `lookAt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the public accessible functions for our Camera3D class. The first
    two are just the standard constructor and destructor. We then have the `Init()`
    function. We declare this function with a few defaults provided for the parameters;
    this way if no values are passed in, we will still have values to calculate our
    matrices in the first update call. That brings us to the next function declared,
    the `Update()` function. This is the function that the game engine will call each
    loop to keep the camera updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `Update()` function, there is a set of five getter functions to return
    both the View and Projection matrices, as well as the camera''s forward, up, and
    right vectors. To keep the implementation clean and tidy, we can simply declare
    and implement these *getter* functions right in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly after the set of getter functions, we have two setter functions. The
    first will set the horizontal angle, the second will set the vertical angle. This
    is useful for when the screen size or aspect ratio changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last public function in the Camera3D class is the `MoveCamera()` function.
    This simple function takes in a vector 3, then cumulatively adds that vector to
    the `m_position` variable, which is the current camera position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the private declarations of the class, we start with two `glm::mat4` variables.
    A `glm::mat4` is the datatype for a 4x4 matrix. We create one for the view or
    camera matrix and one for the projection matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a single vector 3 variable to hold the position of the camera,
    followed by three float values—one for the horizontal and one for the vertical
    angles, as well as a variable to hold the field of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We then have three more vector 3 variable types that will hold the right, up,
    and forward values for the camera object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the declarations for our 3D camera class, the next step is
    to implement any of the functions that have not already been implemented in the
    header file. There are only two functions that we need to provide, the `Init()`
    and the `Update()` functions. Let''s begin with the `Init()` function, found in
    the `Camera3D.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Init()` function is straightforward; all we are doing in the function
    is taking in the provided values and setting them to the corresponding variable
    we declared. Once we have set these values, we simply call the `Update()` function
    to handle the calculations for the newly created camera object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Update()` function is where all of the heavy lifting of the classes is
    done. It starts out by calculating the new forward for our camera. This is done
    with a simple formula leveraging GLM's cosine and sine functions. What is occurring
    is that we are converting from spherical coordinates to cartesian coordinates
    so that we can use the value in the creation of our view matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After we calculate the new forward, we then calculate the new right vector
    for our camera, again using a simple formula that leverages GLM''s sine and cosine
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the forward and up vectors calculated, we can use GLM''s cross-product
    function to calculate the new up vector for our camera. It is important that these
    three steps happen every time the camera changes position or rotation, and before
    the creation of the camera''s view matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we specify the FOV. Currently, I am just setting it back to the initial
    FOV specified when initializing the camera object. This would be the place to
    recalculate the FOV if the camera was, say, zoomed in or out (hint: mouse scroll
    could be useful here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the field of view specified, we can then calculate the projection
    matrix for our camera. Luckily for us, GLM has a very handy function called `glm::perspective()`,
    which takes in a field of view in radians, an aspect ratio, the near clipping
    distance, and a far clipping distance, which will then return a created projection
    matrix for us. Since this is an example, I have specified a 4:3 aspect ratio (4.0f/3.0f)
    and a clipping space of 0.1 units to 100 units directly. In production, you would
    ideally move these values to variables that could be changed during runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the last thing we do in the `Update()` function is to create the view
    matrix. As I mentioned before, we are fortunate that the GLM library supplies
    a `lookAt()` function to abstract all the steps we discussed earlier in the section.
    This `lookAt()` function takes three parameters. The first is the position of
    the camera. The second is a vector value of where the camera is pointed, or *looking
    at*, which we provide by doing a simple addition of the camera's current position
    and it's calculated forward. The last parameter is the camera's current up vector
    which, again, we calculated previously. Once finished, this function will return
    the newly updated view matrix to use in our graphics pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: That is a simple 3D camera class in a nutshell. Go ahead and run the CameraDemo
    project to see the system in action. You can move the camera around with the WASD
    keys and change the viewing angle with the mouse. Next, we will move onto another
    important game engine system, physics!
  prefs: []
  type: TYPE_NORMAL
- en: Working with physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it tends to be very rare that a game does not implement at least some
    basic form of physics. The topic of game physics is rather large and complex and
    could easily fill a few volumes before you could consider it well covered. It's
    because of this that entire teams are dedicated to the creation of the *physics
    engines* and it can take years of development to build production-level systems.
    Since this is the case, we won't attempt to cover all aspects here, but instead
    take a higher-level approach. We will cover some of the more commonly needed aspects
    of physics systems, specifically basic collision detection. For more advanced
    needs, such as the support for gravity, friction, and advanced collision detection,
    we will cover the implementation of a third-party physics library. At the end
    of this section, our demo engine will have advanced physics support.
  prefs: []
  type: TYPE_NORMAL
- en: Point in AABB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, let''s take a look at one of the easier collision checks you can
    perform in 3D, finding out whether a point is inside or outside an **Axis Aligned
    Bounding Box** (**AABB**). AABBs are very easy to create. You can basically think
    of these as non-rotatable cubes or boxes. The following image depicts an AABB
    and point—collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c502b9d4-9123-486a-b50f-59304240a90f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a bounding box, you can specify a max point and a min point in vector
    format or by having a center point and then specifying a height, width, and depth.
    For this example, we will create our AABB''s with the min and max points approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a simple example struct for an AABB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an AABB, we can develop a way to check if a single point falls
    inside of the AABB. This check is very simple; all we need to do is check if all
    its values, x, y, and z, are greater than the AABB''s min values and less than
    the AABB''s max values. This check in the code would look something like the following,
    in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: AABB to AABB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen how to test if a point is within a certain AABB, the
    next very useful collision check we will look at is the AABB to AABB check—a quick
    test to find out if two AABBs are colliding. The following image depicts this
    collision check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e4f7aad-e66f-4e3a-8635-cc8f2162973e.png)'
  prefs: []
  type: TYPE_IMG
- en: The collision check between two AABBs is very simple and fast. It is a very
    common choice for most objects that need a form of collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: The bad thing about AABBs is that they can't be rotated. Once they are rotated,
    they stop being AABBs since they are not aligned to the *x*, *y*, and *z* axes
    anymore. For objects that rotate, a better option would be to use spheres, capsules,
    or even **oriented bounding boxes** (**OBBs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if two AABBs are colliding, we just need to check that the first AABB''s
    max point is greater than the second one''s min point and that the first one''s
    min point is less than the second one''s max point. The following is what this
    check would look like in code, in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the order of the boxes, which one is first and which one is the second,
    doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Since this check contains a lot of  `&&` comparisons, if the first check is
    false, it will not continue to check the rest; this is what allows for a very
    fast test.
  prefs: []
  type: TYPE_NORMAL
- en: Sphere to sphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last simple collision check I want to touch on here is the test to find
    out if two spheres are colliding with each other. Testing collisions between spheres
    is very simple and easy to perform. An advantage that spheres have over things
    such as AABBs is that it doesn''t matter if the object rotates, the sphere will
    remain the same. The following is an image that depicts the collision check between
    two spheres:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee43bc1c-46b3-4415-8767-a9bd4b83e28d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To perform the check, we simply need to calculate the distance between the
    centers of the spheres and compare it to the sum of their radii. If this distance
    is less than the sum of their radii, then the spheres are overlapping. If it''s
    the same, then the spheres are just touching. The following is how this collision
    test would look like in code, in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the distance between the centers of the spheres, we need to create a
    vector between their center points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then calculate the length of that vector with the sum of the radii:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a more efficient way to do this. Since the dot product of a vector
    with itself equals the squared length of that vector, we could just calculate
    the squared length of the vector against the square of the sum of the radii. If
    we do it this way, we don't need to calculate the length of the vector, which
    is an expensive operation in itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can perform the collision check. If the distance squared is less
    than or equal to the square sum, then the spheres have collided, otherwise, the
    object has not collided and we return false.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these simple checks, most basic collision detection can be handled.
    In fact, as we will see in the next section, most advanced checks are comprised
    of many smaller checks. However, there will come a point when you will find yourself
    needing more advanced or optimized ways of handling physics; this is when you
    can turn to a third-party library to provide this support. In the next section,
    we will look at the implementation of one of these third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Bullet physics library.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bullet is a physics engine that simulates collision detection and soft and rigid
    body dynamics. It has been used in many released video games as well as for visual
    effects in movies. The Bullet physics library is free and open-source software
    subject to the terms of the zlib License.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the features Bullet has to offer include:'
  prefs: []
  type: TYPE_NORMAL
- en: Rigid body and soft body simulation with discrete and continuous collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collision shapes: sphere, box, cylinder, cone, convex hull using GJK, non-convex,
    and triangle mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soft body support: cloth, rope, and deformable objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rich set of rigid body and soft body constraints with constraint limits and
    motors
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code link and more information at: [http://bulletphysics.org](http://bulletphysics.org).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how you can incorporate Bullet into your own game project.
    I am not going to spend the time going over how to link the libraries to our demo
    project since we have covered this a few times now. If you do need a refresher,
    flip back a few chapters to see how. What we are going to do is incorporate the
    Bullet engine into our demo engine and then use the Bullet engine's calculations
    to position our game objects in real time. In this example, we are going to create
    a simple ground plane and then a ball (sphere) to fall and collide with the ground.
    We will be using Bullet's built-in types to support this, including gravity to
    give it a realistic effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with the Ground `GameObject`, we set up variables to hold some of
    our needed physics values. The first is of type `btCollisionShape`. This is a
    Bullet type that allows the definition of simple shapes to use when creating bounding
    objects for the physics tests. The next is of type `btDefaultMotionState`, which
    again is a Bullet datatype that describes the way the object should behave when
    in motion. The last variable we need is of type `btRigidBody`, which is a Bullet
    datatype that will hold all the physical properties of the object that our physics
    engine would be concerned with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have these variables defined, we can then construct the physics representation
    of the ground object in its `Init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by setting our `groundShape` variable to be a `btStaticPlanShape`.
    This is a Bullet object that specifies a simple plane object, which is perfect
    for our needs and a simple ground object. Next, we set the `groundMotionState`.
    We do this by using the `btDefaultMotionState` Bullet object. The `btDefaultMotionState`
    is the type used for specifying the way an object will behave in motion. When
    creating a new `btDefaultMotionState`, we need to pass in some information about
    the object''s transform, that is the rotation and position of the object. To do
    this we pass a `btTransform` object with its own parameters of a rotation in quaternion
    format (`btQuaternion(0, 0, 0, 1)`) and a position in vector 3 format (`btVector3(m_position.x,
    m_position.y, m_position.z)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, with the `groundShape` and `groundMotionState` set, we can move on to creating
    and setting the rigid body info. First we define a holder `btRigidBodyConstuctionInfo`
    variable for the construction information called `groundRigidBodyCI`. This object
    takes in a few parameter values, a scaler value to specify mass, the motion state
    of the object, the collision shape, and a vector 3 to specify the local Inertia
    value. Inertia is the resistance of any physical object to any change in its state
    of motion. It is basically the tendency of objects to keep moving in a straight
    line at constant velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Since our ground object is static and does not require any changes based on
    the physics input, we can forego an  `Update()` function and move on to the Ball
    object that we will be using to test out the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `BallObject.h` file, we define some variables that we need,
    much like we did for our ground object. We create a motion state, a scalar (an
    integer) value for mass, collision shape, and, finally, a rigid body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, moving into the `BallObject.cpp` file, we assign some values to the variables
    we have just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set our collision shape. In this case, we are going to use the type
    `btSphereShape`. This is the default shape for spheres and takes in a parameter
    to set the radius for the sphere. Next, we create a vector 3 holder for the sphere''s
    inertia. We are setting this to be all zeros since we want this ball to fall freely
    with no resistance based on the mass of the object and a gravity value we will
    set shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set the ball''s motion state, just like we did for the ground object.
    We set the rotation to be 0 and the position to the current position of the ball
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We then calculate the local inertia value using the handy `calculateLocalInertia()`
    function, passing in the mass and `fallInertia` values. This will set the falling
    vector for our ball object to be used in the first tick of the physics engine.
    Finally, we end with setting up the rigid body object, exactly like we did previously
    with the ground object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the ball object, we do expect the physics engine output to affect the
    ball object. It''s because of this that we need to make some adjustments in the
    `Update()` function of the ball object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first step in the update loop for the ball object is to get the physics
    object's transform from the rigid body. Once we have this transform object, we
    can then set the ball object's mesh (the visible object) to make the position
    of the physics transform object. That's it for the object itself. The ball and
    ground objects now house all the needed physics information. We can now implement
    the physics engine loop into our game loop and get the ball rolling, no pun intended!
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation of the physics engine into our existing game engine''s
    loop, we need to set up a few values first. Jumping into our `Gameplayscreen.h,`
    we define the variables to hold these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First is a definition of a `btBroadphaseInterface` class object, which provides
    a Bullet interface to detect AABB-overlapping object pairs. In this case, we are
    setting it to a `btDbvtBroadphase`, which implements a `btBroadphase` using two
    dynamic AABB bounding volume hierarchies/trees. This tends to be the best broadphase
    when working with many moving objects; its insertion/addition and removal of objects
    is generally faster than the sweep and prune broad phases found in the `btAxisSweep3`
    and `bt32BitAxisSweep3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have defined for the collision configuration, collision dispatcher,
    and sequential impulse constraint solver. We won''t go too deep on each of these,
    but the main points are that the collision configuration sets up some Bullet internal
    values, such as collision detection stack allocators and pool memory allocators.
    The collision dispatcher is the definition of how the collisions will be handled.
    It supports algorithms that handle *ConvexConvex* and *ConvexConcave* collision
    pairs, time of impact, closest points, and penetration depth. Finally, the sequential
    impulse constraint solver, which defines what can be thought of as the algorithm,
    will determine how to solve the collisions between objects. For those wishing
    to know, it is a **Single Instruction, Multiple Data** (**SIMD**) implementation
    of the Projected Gauss-Seidel (iterative LCP) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The last variable we need to define is for our dynamics world object. A `btDiscreteDynamicsWorld`
    provides a discrete rigid body simulation. This can be thought of as the environment
    or *world* in which the physics simulation occurs. Once we have this defined,
    we have all the pieces in place to start our physics simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into the `GameplayScreen.cpp` file and look at the `OnEntry()`
    function that we will use to initialize the physics simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we set is our gravity vector. In our simple example, we are
    setting this to be `-1` on the *y* axis. Next, we add the two created rigid bodies
    to the simulation environment, one for the ground and one for the ball. That handles
    the initialization of our physics engine; now we need to handle updating it on
    each engine tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Inside of the `GameplayScreen::Update()` function, we first check the input,
    then call the update on the physics engine, before finally calling the update
    on the game objects themselves. It is important to note this order. We want to
    accept the user's input first, but we want to make sure we have updated the physics
    engine before the objects. The reason is that the physics calculations should
    have some effect on the objects and we don't want to cause a case where our drawing
    loop is ahead of the physics loop, as this would definitely cause some unwanted
    effects. You will also notice the physics update function, `stepSimulation`, takes
    in two parameters. The first is the amount of time to step the simulation by.
    This is typically the time since you last called it. In this case, we are setting
    this to 1/60 of a second, or 60 FPS. The second parameter is the maximum number
    of steps that Bullet is allowed to take each time you call it. If you pass a very
    large value as the first parameter, say, something like five times the size of
    the fixed internal time step or game clock, then you must increase the number
    of  `maxSubSteps` to compensate for this; otherwise, your simulation is *losing* time,
    which will again result in some unwanted physics calculation output.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! We now have a physics engine running its simulation and effecting
    the objects in our world that we are drawing on the screen. You can see this in
    action by running the `PhysicsDemo` example project in the `Chapter05` GitHub
    repository. The output will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/587278a9-af53-427b-b6bc-759b806a024a.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground and made strong progress in developing
    the core game systems needed for developing professional-grade projects. We now
    have our own custom game state system that can be adopted by many of the other
    components in the game engine itself. We developed our own custom camera system
    while building an understanding of how cameras work at a lower level. Finally,
    we looked at how we can add complete third-party game systems to our projects
    by adding the Bullet physics engine to our example engine.
  prefs: []
  type: TYPE_NORMAL

- en: Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most games are built on the concept of competing to win. This form of competition
    can take many forms. Since the earliest video games, players have found themselves
    competing against the machine. The inclusion of thinking, reacting, and challenging
    computer opponents makes games feel alive and connected to the player. In this
    chapter, we are going to learn how to add thinking to our games with the inclusion
    of artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is game AI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion and pathfinding techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is game AI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often misunderstood, defining what game artificial intelligence is and, for
    that matter, what game AI is not is a very challenging endeavor. With such an
    encompassing field as AI, it would be very easy to fill many volumes of books
    on the subject. Given we only have a chapter to discuss the concept and implementation,
    in this section we are going to do our best to develop a reasonable definition
    of what game AI is and what it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Defining game AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, defining exactly what game AI is can be a difficult task, but
    I am going to do my best to describe what I feel is a concise interpretation when
    it comes to electronic video games. When a designer creates a game world, they
    do so by sculpting a vision and defining some common rules for interaction in
    that world. Typically, players will experience this world through the observation
    of the world's elements. Interactions, such as with the world's NPCs, opponents,
    and environments, and through narrative aspects, give the player a sense of immersion
    in the game's world. These interactions can take many shapes and forms. In games,
    players constantly have some interaction with the world through inanimate objects,
    but it's the interactions with other people that really stands out. It's what
    makes the game feel more immersive, more tangible, and more alive.
  prefs: []
  type: TYPE_NORMAL
- en: The sensation of something in the game world feeling alive generally comes through
    the observations of the game world and objects, such as an NPC making decisions.
    This is a great flag in the search to find a definition for game AI. In a broader
    sense, AI can be thought of as the application of this perceived decision-making.
    Commonly, this perception of decision-making comes in the form of an autonomous
    AI agent, for example, the common NPC. These decisions might include anything
    from movement, dialog choices, or even changes to the environment that might convey
    the experience the developer is attempting to create. This again is another flag
    for me when defining game AI. In essence, it is about the experience the developer
    is trying to create. To that end, game AI is more about an approximation of getting
    a desired effect, not necessarily a perfect scientific interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that when developers are setting out to create an AI experience,
    they do it with the key aspects of the player's fun and immersion in mind. No
    one wants to play against the perfect opponent. We want to perceive intelligence
    on the other end of the interaction, we just don't want it to be smarter. This
    is where developing game AI and the field of general AI development starts to
    become at odds. We will dive deeper into this diversion in the next section, but
    for now, let's look at some uses of AI in game development.
  prefs: []
  type: TYPE_NORMAL
- en: Conversations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games that have some sort of interaction through dialog tend to give a sense
    of immersion in a world through how the characters' connect with the player and
    how the player becomes invested in their story. This, however, has been a challenge,
    and is often implemented, as we looked at in the last chapter, through dialog
    trees. This dialog tree approach, while solid in some situations, can easily grow
    in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue with completely scripted conversations is, as the conversation
    continues over time, the player is quickly taken out of the illusion that this
    is an intelligent interaction. It makes the interaction feel constrained and in
    turn makes the world also feel constraining. One way to battle this issue is to
    introduce AI into the conversations. You could have scripted interactions augmented
    with decision-making algorithms to give a feeling of deeper intelligence in the
    responses. On the extreme side of this concept, you could employ a method of parsing
    player input and custom generating responses on the fly. An approach such as this
    would likely include what is referred to as **Natural Language Processing** (**NLP**).
    By utilizing something akin to a chatbot, designers and engineers can create worlds
    populated by agents that think when responding to user interactions. While this
    might sound extremely tempting, the field of Natural Language Processing is still
    considered to be in its infancy. With APIs powered by cloud computing, such as
    Microsoft's Cognitive Services APIs, the processes of creating the infrastructure
    to support NLP is getting easier. However, proper implementation and training
    of the language models can be quite time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Competitive opponents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of games include the concept of enemies or competitive opponents for players
    to interact with. I would, in fact, say this is what most folks would think of
    as an example of game AI. How these opponents interact with the player, their
    environment, and other AI-controlled opponents is all part of their AI design.
    Often, this AI design will include concepts of decision-making, such as behavior
    trees, feedback loops, states, and other patterns. They will also often include
    other AI components such as motion algorithms and pathfinding techniques, both
    of which we will cover in more depth later in the chapter. Creating fun yet challenging
    opponents is not an easy task. As I stated earlier, no one wants to play a game
    where they feel they have no chance of winning. Having an AI that is constantly
    quicker and smarter than the player should not be the goal of designing an opponent
    AI; you should instead focus on giving the user a competitive AI that could potentially
    scale to meet the growing skill of the player. It's in this light where advanced
    techniques, such as using machine learning to build adaptive AI, are starting
    to gain traction. Although these techniques are still in their exploratory phases,
    the day of tailored AI opponents could soon be near.
  prefs: []
  type: TYPE_NORMAL
- en: Motion and pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably, just as common as using AI for opponents is the concept of utilizing
    AI for motion and pathfinding. Using AI in motion includes the implementation
    of algorithms to handle the autonomous movement of game elements. Ideas such as
    steering, pursuit, and avoid are all concepts you can express in AI algorithms.
    Motion AI is also commonly implemented to handle simple collision avoidance. Pathfinding
    is the concept of using AI to find the most efficient or effective route when
    moving a game object from one location to the next. Algorithms such as **Dijkstra**
    and **A*** have been around since the sixties and have provided a staple for pathfinding
    AI development. We will dive deeper into motion and pathfinding algorithms and
    techniques later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What game AI is not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Artificial intelligence, as a field of study, is very large, and really does
    include a lot more than what games use. As of late, discussions around AI in the
    developer space have become more expansive, with more and more developers looking
    for ways to leverage AI technologies lies in their projects. For this reason,
    I thought it would be important to touch on some of the more commonly known use
    cases for AI outside of the realms of game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the hottest areas for AI outside of the game development is machine
    learning. **Machine learning** (**ML**) is probably best described by Arthur Lee
    Samuel, when he coined the term machine learning: *A computers ability to learn
    how to achieve an outcome or prediction without being explicitly programmed to
    do so.* Within the field of data analytics, machine learning is used as a method
    to devise complex models and algorithms that help forecast outcomes for a given
    problem. This is also known as predictive analytics. These analytical models allow
    researchers and data scientists to create reliable, repeatable computations and
    results and discover other insights through historical relationships and trends
    in the data. As mentioned in the previous section, the idea of tailored AI that
    learns from your play style and adapts is a very appealing concept. However, it
    can be a slippery slope; if the AI becomes too smart, then the game''s fun level
    can and will quickly drop. A good example of how ML is being used in gameplay
    is in the Forza racing game series. Here, racing AI avatars are processed in a
    cloud computing powered machine learning implementation to tailor the competitive
    level of the AI racers you encounter to your current ability level.'
  prefs: []
  type: TYPE_NORMAL
- en: Another growing use for AI outside of game development field is its implementation
    in data mining scenarios. While this area of AI is still in its early stages,
    its use in understanding user and customer data is extremely appealing to a lot
    of business sectors. The boundaries of this AI use case and its potential overlap
    with game development concepts have yet to be defined. However, some of the core
    components of data mining for understanding how players interact with a game and
    its various components can easily be seen as beneficial to game developers. Knowing
    exactly how players interact with elements such as the game GUI will allow developers
    to create better experiences for each user.
  prefs: []
  type: TYPE_NORMAL
- en: The last use case for AI outside of game development that I want to address
    is probably one of the most recognized uses when the average person thinks of
    AI, and that's the use of AI in the study of cognitive processing. In academic
    interpretations of AI, cognitive processing is the process of developing scientifically
    provable models for these processes. This can basically be summarized as the modeling
    of human intelligence in AI processes. While this approach is very important for
    scientific research, the current use cases for game development are still too
    far abstracted to be considered useful. That being said, the use of bots and NLP
    is starting to creep its way into game development, as mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the specific goals of academic and research AI differ completely from
    game AI goals. This is because of inherent differences, such as the implementations
    and techniques used in each being completely different. More often, game AI solutions
    will favor a simplistic approach, allowing easy changes and tuning, whereas the
    research approach will more than likely opt for the most scientifically complete
    implementation. In the next sections, we will look at a few of these simpler game
    development implementations and discuss their use cases and theory.
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often, the goal of AI is to give the appearance of human intelligence.
    One of the key aspects to the perception of intelligence is the idea that the
    AI agent is making decisions. Having choice over certain actions, even if scripted,
    gives the player a feeling of a thinking world, populated by thinking entities.
    In the next section, we will cover some of the more well-known decision-making
    techniques in game AI.
  prefs: []
  type: TYPE_NORMAL
- en: AI state machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been following through the book chapter by chapter, you may have
    noticed the use of the state pattern more than a few times. This pattern is a
    very powerful pattern, hence its common use throughout our various component designs.
    In the realm of artificial intelligence, the state pattern is again a shining
    star. The use of the state machine, specifically the **FSM** (**finite-state machine**),
    allows for the detailed representation of the code's execution flow. It is a perfect
    fit for the implementation of AI in games, allowing the design of powerful interactions
    without complex code.
  prefs: []
  type: TYPE_NORMAL
- en: I am not going to spend much time on the concept and theory of finite-state
    machine implementation, since we have covered it ad nauseam. Instead, we are going
    to look at an example of its implementation in an AI script. If you do need a
    refresher on the pattern, review the [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building
    Gameplay Systems*, section on understanding states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram depicting the simple brain of an enemy. In this
    example, each state represents an action, such as search or attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5527c00-1545-4e52-bce6-e5ed22d608fa.png)'
  prefs: []
  type: TYPE_IMG
- en: While this is a simple example, it does provide useful AI for many situations.
    We can implement this inside a game project using C++, as we have seen in the
    *Screen* example and elsewhere. However, if you have read through the previous
    chapter, you would have seen how we can implement logic such as this in a script.
    This, of course, allows us the flexibility of scripting, such as not having to
    rebuild the project to adjust the elements of the code. This is very beneficial
    for AI, so in this chapter I will be showing the example code using Lua scripts
    that can be implemented using the steps described in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible implementation of this AI design in a Lua script could look something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should look familiar to the NPC dialog example from the last chapter. Here,
    to complete the system, we would first load the script into an instance of an
    AI agent or NPC, and then call the `currentState` variable's currently-assigned
    function in the `Update` loop of the game code itself. With this code implementation,
    we have an effective way of building basic AI interactions. This technique has
    been around since the early days of game development. In fact, this would be a
    very similar implementation to the ghost opponents AI in the arcade classic, PAC-MAN.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also expand on this simple FSM implementation and add a stack-based
    FSM into the solution. This is, again, much the same as the implementation example
    we saw in [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building Gameplay
    Systems*, so I am not going to go through all the details about the theory of
    stack-based FSM. The basic principle of the stack-based FSM is that we can add
    to and remove our objects from the stack in a first in, last out order. The term
    commonly used for adding items to a stack is called pushing, and the removal of
    an object from the stack is called popping. So, for a state example, the stack
    would look something like the following diagram during the different functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f905652-25f7-47ee-b792-c05b26056e84.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the major advantages of using a stack-based FSM is that you can now use
    the stack to control the current state. Each state can pop itself from the stack,
    allowing the execution of the next state. We can also implement the concept of
    *on entry* and *on exit*, allowing us to have states within states. We can do
    things such as set up and clean up in each state, giving us much more flexibility
    in our AI state system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing our states for a stack-based FSM in a Lua script might look something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our C++ code, we would add the rest of the architecture needed to
    power the state-based FSM. Here, we would create a vector or array object that
    would hold pointers to the state objects loaded in from the Lua script. We would
    then call the functions for `OnEnter`, `OnExit`, and `Update` for the state object
    currently occupying the last element in the array. As seen before, we could handle
    this by simply creating an enum and switching cases to handle the state flow.
    We could also go the route of creating a `StateList` class that would implement
    the required functions to wrap up the FSM. This `StateList` class, for our example,
    could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Whichever way you choose to implement the state-based FSM, you will still get
    the added benefit of having the stack control in place. As you can see, the state
    pattern, when used in AI development, gives us a great, flexible starting point
    for creating AI interactions. Next, we will look at some other techniques to introduce
    decision-making into your AI design.
  prefs: []
  type: TYPE_NORMAL
- en: Decision trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A decision tree is a flowchart-like structure comprised of branches and leaves.
    Each branch of the tree is a conditional, where a decision is made. Each leaf
    is the action for the choice made in the conditional. At the farthest extents
    of the tree, the leaves are the actual commands that control the AI agent. Using
    a decision tree structure allows for easier design and understanding of the flow
    of the AI implementation. A simple AI brain implemented in a decision tree would
    look something similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f564e89d-5d08-456f-8ce9-0844c823035f.png)'
  prefs: []
  type: TYPE_IMG
- en: You might be thinking to yourself that this looks and sounds very much like
    the dialog trees we implemented in [Chapter 8](64a8360e-3372-4e98-bade-cab6ec948ea7.xhtml),
    *Advanced Gameplay Systems*. That is because they are! Just like in the case of
    working with dialog and choices, using a tree structure is a great way to script
    out the flow of an AI interaction. The decision trees can be extremely deep, with
    branches and nodes calling sub-trees which perform particular functions. This
    gives the designer the ability to use an extensive library of different decisions
    that can be chained together to provide a convincing depth of AI interaction.
    You can even go as far as developing branches that can be ordered by their overall
    desirability based on the current task, which could then fall back to other decisions,
    should the desired one fail. This resiliency and flexibility is where tree structures
    really stand out.
  prefs: []
  type: TYPE_NORMAL
- en: Those familiar with data structures in C++ are probably already thinking about
    how this tree structure can be implemented in code. Maybe Lists are coming to
    mind. There are many different ways to implement a decision tree. We could define
    the tree in an external format, such as XML. We could implement it along with
    the structure and architecture with a mix of C++ and a scripting language such
    as Lua, but since I really want to drill home the understanding of the tree design,
    we are going put the entire implementation in Lua. A great example of how this
    can be accomplished is demonstrated by David Young in the book *Learning Game
    AI Programming with Lua*, so we are going to base our simple example on David's
    more detailed example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s look at the structure of the tree object. In the `DecisionTree.lua`
    file, we could have something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, in our tree structure, we implement an update loop, which evaluates the
    root branch within the tree and processes the resulting action. Once the action
    has been created, processed, and finished, the decision tree will reevaluate itself
    starting again from the root branch to determine the next action to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the branch object. In our implementation, the branches will consist
    of a conditional that will determine which element will be executed next. It is
    the responsibility of the conditional evaluation to return a value that ranges
    from one to the maximum number of children in the branch. This will denote which
    element should be executed next. Our decision branch Lua class object will have
    basic functions for adding additional children as well as setting the conditional
    function used during the branch''s calculation. In the `DecisionBranch.lua` file,
    we could have an implementation that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As pointed out by David in his example, since leaves are simply actions, we
    can include each leaf action in the branches themselves. This allows us to get
    the needed functionality without the need for an additional structure in the code.
    With the use of the `type_ variable`, we can determine whether a child of the
    branch is another branch or an action that needs to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: For the evaluation of the branch itself, we execute the conditional and then
    use the returned value to determine the next step in the tree. It should be noted
    that every branch within the tree must eventually end with an action. If the tree
    has any leaves that do not end in actions, the tree is malformed and will not
    evaluate properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Staying in the `DecisionBranch.lua` file, the code to evaluate the branch would
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the tree data structure in place, we can go ahead and build
    one for use. To do this, we first create a new instance of the decision tree,
    create each branch needed in the tree, connect the conditional branches, and finally
    add the action leaves. In the `AILogic.lua` file, we could have something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the decision tree in place, we could now call this script and load the
    tree into an AI agent object. We could make changes on the fly, add more decisions
    and actions, and even add in other AI techniques to augment the decisions. While
    a decision tree allows developers and designers to create easy to understand and
    read AI structures, it does have its drawbacks. One of the most notable drawbacks
    is its modeling of complicated logical conditions, where you need to account for
    each possible outcome of the condition. Also, with the larger number of branch
    possibilities, a tree will also start to have the need to be balanced. If this
    balancing does not occur, parts of the tree will need to be replicated, quickly
    increasing the complexity of the tree structure and leading to more bug-prone
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last topic in AI decision-making I want to briefly touch on is the concept
    of feedback loops. A feedback loop is a situation where a certain output value
    of a system is fed or given back to the system which, in turn, influences the
    state of the system, affecting its subsequent value. Ideally, in video games,
    especially in AI interactions, every loop should be a stable feedback loop. A
    simple definition of a stable feedback loop is a situation where the output of
    the system is used to reverse the circumstances that caused the feedback value
    in the first place, making the feedback system move to the convergence of a stable
    state. This keeps your AI feedback from causing a runaway effect with a negative
    or positive feedback loop taking place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand what a feedback loop really is, let''s take an example
    most commonly seen in video games, stamina. Stamina is seen in many scenarios
    such as a character''s ability to sprint or run, or a character''s ability to
    climb. In our example, we will look at the example of a boxing match. The following
    is a diagram showing the feedback loop we want to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a09fb51-5a12-447c-8e09-6f492d48f86b.png)'
  prefs: []
  type: TYPE_IMG
- en: As stated previously, we need to make sure the stamina feedback loop for our
    boxing example is stable. This means that when we reach a predefined low level
    of stamina, we need to switch the loop to defending, allowing us to recover stamina.
    If we reach a predefined replenished level, we do the opposite and switch to attacking
    to reduce the stamina level. This switching allows us to keep the loop stable
    and is referred to as an oscillating feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this in code is surprisingly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That is it, honestly. It is not complicated to code the implementation of this
    technique. We did skip over a few things, like how to handle reducing and increasing
    stamina. Considering this is in an AI system, we want it to appear more realistic,
    so it wouldn't be great to just increase these values statically. Finding a good
    random value to put in place here could give it a more realistic feel. Ultimately,
    this is an easy to implement technique which provides a nice way to vary outcomes
    and provides a more unique interaction with AI components.
  prefs: []
  type: TYPE_NORMAL
- en: Motion and pathfinding techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI agents and other non-player characters quite often need to move around the
    game world. Implementing this movement so that it appears in a lifelike fashion
    is a challenging process. In the next section, we will look at how we can implement
    algorithms and techniques to add AI agent movement and pathfinding to our game
    development projects.
  prefs: []
  type: TYPE_NORMAL
- en: Motion algorithms and techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using motion algorithms to control an AI agent's movements throughout a level
    or game world is a very common use case for AI algorithms in video games. These
    algorithms can implement behaviors to give the impression of a thinking and reacting
    AI agent, and they can also perform other tasks such as simple object avoidance.
    In the next section, we are going to look at a few of these motion techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Steering behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steering behaviors are a subset of motion algorithms comprised of various techniques
    for controlling the movement of the AI agent based on external and internal variables.
    In our example engine, we have already incorporated a 3D physics calculation library—refer
    back to [Chapter 5](9379b574-a962-466b-9efe-d21b410c51c0.xhtml), *Building Gameplay
    Systems*, for a refresher—and we already have a concept for an NPC class to act
    as our AI agent. This means we have a large part of the needed framework to create
    a Newtonian physics-based steering system, also known as a steering-based locomotion
    system. The steering-based locomotion system is comprised of a few different classifications
    for adding forces to an AI agent. These include the classifications of seeking,
    fleeing, evasion, wandering, pursuit, and a few more. The completely detailed
    implementations of these algorithms would take up chapters on their own, so instead
    we will focus on the high-level concepts and use cases for each algorithm. To
    help you out on the implementation side, I have included the `OpenSteer` library
    in the example engine. `OpenSteer` will handle the details of the calculations,
    making it easier for our engine and our AI Lua scripts to easily use these algorithms
    to control the agents' movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a screenshot of an `OpenSteer` library program running a seek
    and evade algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b0b05a-2f94-4307-b446-e3279bd3c877.png)'
  prefs: []
  type: TYPE_IMG
- en: Seek
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the seek algorithm. The seek algorithm''s goal is to steer
    the AI agent towards a specific position in the game space. This behavior applies
    force so that the current heading and the desired heading will align towards the
    target destination point. The following diagram describes this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1d19952-67a0-4381-b46c-cda9dfd4ce6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Desired Heading** is really a vector in the direction from the character
    to the target. The length of the **Desired Heading** could be set as a value,
    such as the character''s current speed. The steering vector or **Seek Path** is
    the difference between this desired heading and the character''s current heading.
    The equation for this can be simplified to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting side effect of the seek algorithm is that if an AI agent continues
    to seek, it will eventually pass through the target, and then flip its direction
    to approach the target again. This produces a motion path that looks a bit like
    a moth buzzing around a light bulb. To use `OpenSteer` to calculate the steering
    force, you call the `steerForSeek` function, passing a 3-point vector to describe
    the target''s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Flee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The flee steering behavior is simply the inverse of seek. Instead of working
    to align the heading to a specific target, the flee algorithm steers the AI agent''s
    heading to be aligned away from the target point. The desired heading, as such,
    points in the opposite direction. The following diagram shows this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/248bf05a-120d-4975-97c3-1368cf84ca4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use `OpenSteer` to calculate the steering force for a fleeing AI agent,
    you call the `steerForFlee` function, passing a 3-point vector to describe the
    target''s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Pursuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pursuit steering behavior is very similar to the seek behavior, but the
    difference here is that the target point is actually a moving object or player.
    The following diagram illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc201d75-cfb0-4d7f-be36-63174f2b835b.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to create effective pursuit behavior, we will need to do some predicting
    when it comes to the target's future position. One approach that we can take is
    to use a prediction method that we can revaluate in each update loop. In our simple
    predictor, we are going to make the assumption that our target will not turn during
    this update loop. While this assumption will more often be wrong, the predictor
    result will only be used for a fraction of a second (1/30). Which means that if
    a target does veer away, a quick correction based on the target changing direction
    will be calculated in the next simulation step. Also with this assumption, the
    position of a target that is X units of time in the future can be calculated by
    scaling its velocity by X and adding that offset to its current position. Then
    it is literally a matter of applying the seek steering behavior to the predicted
    target location to achieve the pursuit behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `OpenSteer` to calculate the steering force for a pursuing AI agent,
    you call the `steerForPursuit` function, passing an object to use as the target
    we are pursuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like flee is the opposite of seek, evasion is the opposite of pursuit.
    This means that instead of steering the AI agent toward the target''s calculated
    future position, we are instead fleeing from the target''s current position. The
    following diagram illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d565e6ae-e0fc-4f4e-8276-c69a6bd33bc3.png)'
  prefs: []
  type: TYPE_IMG
- en: When using evasion steering behavior, the AI agent will head away from the predicted
    point of interception. This can often result in a less than natural behavior,
    as most truly fleeing entities will likely have a random evasion pattern. One
    way to achieve a more natural effect would be to modify the force applied with
    another behavior, such as the wandering behavior we will touch on next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `OpenSteer` to calculate the steering force for an evading AI agent,
    you call the `steerforEvasion` function, passing an object to use as the target
    we are evading, as well as a float value to specify the maximum amount of time
    in the future to use when calculating the force to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Wandering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned previously, sometimes it's better to have some fluctuation in
    a behavior by adding another behavior to modify the force. The wandering behavior
    is a great example of a modifying behavior. The wandering behavior basically returns
    a tangent steering force in relation to the agent's forward vector. It should
    be noted that, since the wandering behavior is meant to add some deviation to
    an agent's movement, it should not be used as a steering force all by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `OpenSteer` to calculate a wandering steering force for an AI agent,
    you call the `steerForWander` function, passing a float value to specify the time
    step between wanders. The time step value allows the wander rate to be consistent
    when frame times vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While that is all the time we can dedicate to AI steering behaviors in this
    book, we have only really begun to scratch the surface of what is available. Concepts
    like flocking and simple object avoidance are unfortunately outside of the scope
    of this chapter, but are fully supported by the `OpenSteer` library. If you are
    interested in learning more about these behaviors, I highly recommend reading
    through the `OpenSteer` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Search algorithms and pathfinding techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of cases in games, we often need to find a path from one location to
    the next. Another very common need for AI in game development, and the last one
    we will touch on in this chapter, is the use of search algorithms to find optimal
    paths for moving around AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we are going to focus on graph search algorithms. Graph search
    algorithms, as their name suggests, work with graphs as their source of data input.
    In our example of a map, the graph is a set of locations and the connections between
    them. These are often referred to as nodes and edges respectively. The following
    is an example of what very basic graph data might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d09f3fab-ad19-4a00-ac89-5e885b73a3a2.png)'
  prefs: []
  type: TYPE_IMG
- en: The output from these graph search algorithms can be used to develop the path
    needed to be taken by the AI agent. This path is made up of the graph's nodes
    and edges. It should be noted that the algorithms will tell your AI where to move,
    but it won't provide the how. These algorithms are not like the steer-force algorithms
    from earlier in the chapter, as they won't move the AI agent. However, combined
    with the steering algorithms, these pathfinding algorithms will create great overall
    AI behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how graphs represent the map and the
    points we want to find paths between, let's look at some of the most common algorithms
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth first
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The breadth first search is the simplest of search algorithms. It explores
    all directions equally. So how does it explore? Well, in all of these search algorithms,
    the key idea is to keep track of an expanding area, referred to as the frontier.
    The breadth first algorithm expands this frontier by moving out from the starting
    point and checking its neighbors first, then its neighbor''s neighbors, and so
    on. The following is a diagram showing how this expansion takes place on a grid.
    The numbers denote the order the grid square was visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b90ad766-5e37-42ba-b7ff-2f12df3882f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple example of how we can implement this in C++ follows. I have left out
    a few sections of code for the sake of space in the book. The full implementation
    can be found in the `Chapter09` example project, in the source code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed from the source code, one trick with this algorithm
    is we need to avoid doubling back and processing a node more than once. In this
    simple example, we implement an array of Boolean values of visited nodes. If we
    don't mark visited vertices in this example, we create an endless loop process.
  prefs: []
  type: TYPE_NORMAL
- en: This is an incredibly useful algorithm, not only for regular pathfinding but
    also for procedural map generation, flow field pathfinding, distance maps, and
    other types of map analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, we will need to find the shortest path when each step can have
    different costs associated. For example, in the *Civilization* game series, moving
    through different land types requires different amounts of turns per movement.
    In cases like this, we can implement the Dijkstra''s algorithm, also known as
    a **Uniform Cost Search**. This algorithm lets us prioritize which paths to explore.
    Instead of exploring all possible paths equally, it favors the lower cost paths.
    In order to accomplish the prioritization of paths, we need to track movement
    costs. In essence, we want to take the movement costs into account when deciding
    how to evaluate each location. In this algorithm, we are going to need what is
    known as a priority queue or heap. Using a heap instead of a regular queue changes
    the way the frontier expands. The following is an excerpt of the example code
    that demonstrates the Dijkstra''s algorithm in C++, and I have again skipped over
    a few pieces for the sake of space. You can find the full Dijkstra example in
    the `Chapter09` folder of the source repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm is great when finding the shortest path using different costs,
    but it does waste time exploring in all directions. Next, we will look at another
    algorithm that lets us find the shortest path to a single destination.
  prefs: []
  type: TYPE_NORMAL
- en: A*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arguably one of the best and most popular techniques used in pathfinding is
    the **A*** algorithm. A* is a modification of Dijkstra's algorithm that is optimized
    for a single destination. Where Dijkstra's algorithm can find paths to all locations,
    A* finds paths to one location. It prioritizes paths that seem to be leading closer
    to the goal. The implementation is very similar to the Dijkstra implementation,
    but the difference is in the use of a heuristic search function to augment the
    algorithm. This heuristic search is used to estimate the distance to the goal.
    What this amounts to is that A* uses the sum of a Dijkstra search and a heuristic
    search to calculate the fastest path to a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a great example of a pseudo-code implementation explaining
    the A* algorithm''s process, courtesy of Wikipedia ([https://en.wikipedia.org/wiki/A*_search_algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up our quick look at some of the more common pathfinding techniques.
    While we did see some implementation in this section, if you are looking for a
    great starting point for your production games, I would highly recommend looking
    at some of the open source libraries available. These are extremely valuable learning
    resources and provide proven implementation techniques you can build on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a large field of study in a short period of time.
    We developed a base definition of what game AI really is and, for that matter,
    what it is not. In this chapter, we also looked at expanding the decision-making
    functions with the inclusion of AI techniques. We covered how an AI agents' movements
    can be controlled through the use of steering forces and behavior. Finally, we
    capped off the chapter by looking at the use of pathfinding algorithms to create
    paths from point to point for our AI agents. While we did cover a fair amount
    in this chapter, there is still much more to be uncovered in the world of game
    AI. I implore you to continue your journey. In the next chapter, we will look
    at how we can add multiplayer and other network functionalities to our example
    game engine.
  prefs: []
  type: TYPE_NORMAL

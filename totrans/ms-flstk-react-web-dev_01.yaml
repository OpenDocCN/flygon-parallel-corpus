- en: Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor,
    and Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to *Mastering Full-Stack React Web Development* . In this book, you
    will create a universal full-stack application in JavaScript. The application
    that we are going to build is a publishing platform similar to those that are
    currently popular on the market, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Medium ( [https://medium.com/](https://medium.com/) )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress ( [https://wordpress.com/](https://wordpress.com/) )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: issuu ( [https://issuu.com/](https://issuu.com/) )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many smaller publishing platforms, and, of course, our application
    will have fewer features than the ones listed in the aforementioned list because
    we will only focus on the main features, such as publishing an article, editing
    an article, or deleting an article (the core features that you can use to implement
    your own ideas). Besides that, we will focus on building a robust application
    that can be built on because one of the most important things about these kinds
    of applications is scalability. Sometimes, a single article gets much more web
    traffic than the whole site put together (10,000 percent times more traffic is
    normal in the industry because, for instance, a single article could gain insane
    traction through social media).
  prefs: []
  type: TYPE_NORMAL
- en: The first chapter of this book is all about setting up the project's main dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our focus for this chapter will include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation of **Node Version Manager** (**NVM** ) for easier Node management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Node and NPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing MongoDB in our local environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robomongo for Mongo's GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mongoose installation and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial React Redux structure for our client-side app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Falcor on the backend and frontend as a glue and replacement for the
    old RESTful approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use very modern app stacks that gained a lot of traction in 2015 and
    2016--I am sure that the stack that you are going to learn throughout the book
    will be even more popular in years to come, as we in our company, *MobileWebPro.pl*
    , see huge spikes of interest in the technologies that are listed in the previous
    bullets. You will gain a lot from this book, and will catch up with the newest
    approaches to building robust, full-stack applications.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about our technical stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we assume that you are familiar with JavaScript (ES5 and ES6)
    and we will also introduce you to some mechanisms from ES7 and ES8.
  prefs: []
  type: TYPE_NORMAL
- en: For the client side, you will use React.js, which you must already be familiar
    with, so we won't discuss React's API in detail.
  prefs: []
  type: TYPE_NORMAL
- en: For data management on the client side, we will use Redux. We will also show
    you how to set up the server-side rendering with Redux.
  prefs: []
  type: TYPE_NORMAL
- en: For the database, you will learn how to use MongoDB alongside Mongoose. The
    second one is an object data modeling library that provides a rigorous modeling
    environment for your data. It enforces a structure, and at the same time it also
    allows you to keep the flexibility that makes MongoDB so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and Express.js are standard choices for a frontend developer to start
    a full-stack development. Express's framework has the best support for the innovative
    client backend data fetching mechanism created by **Netflix** -**Falcor.js** .
    We believe you will love Falcor because of its simplicity and the fact that it
    will save you so much time when doing full-stack development. We will explain
    in detail later in the book why it is so efficient to use this data fetching library
    instead of the standard process of building a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we will use an object notation (JSON) pretty much everywhere--with
    React as the library, JSON is heavily used for diffing the Virtual DOM (under
    the hood). Redux uses a JSON tree for its single state tree container as well.
    Netflix Falcor's library also uses an advanced concept called a virtual JSON graph
    (we will describe it in detail later). Finally, MongoDB is also a document-based
    database.
  prefs: []
  type: TYPE_NORMAL
- en: JSON everywhere--this setup will improve our productivity drastically, mainly
    because of Falcor, which is binding everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Environment preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starting up, you''re going to need the following tools installed on your
    operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPM--installed automatically with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We strongly recommend using either Linux or OS X for development. For Windows
    users, we'd recommend setting up a virtual machine and doing the development part
    within it. For doing so, you can either use **Vagrant** ( [https://www.vagrantup.com/](https://www.vagrantup.com/)
    ), which creates a virtual env process in the background with development taking
    place almost natively on Windows, or you can use Oracle's **VirtualBox** ( [https://www.virtualbox.org/](https://www.virtualbox.org/)
    ) directly, and work within a virtual desktop, however the performance here is
    significantly lower than working native.
  prefs: []
  type: TYPE_NORMAL
- en: NVM and Node installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NVM is a very handy tool for keeping different Node versions on your machine
    during development. Go to [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    for instructions if you don't have NVM installed on your system yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have NVM on your system, you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists all possible Node versions that are available. We will use
    Node v4.0.0 in our case, so you need to type the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will install Node version 4.0.0\. and set it as default. We
    use NPM 2.14.23 during the book so you can check your version with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After you have the same versions of Node and NPM on your local machine, then
    we can start to set up the rest of the tools that we are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the MongoDB instructions at [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)
    under the Tutorials section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot from the MongoDB website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The instructions and prepared packages for installing Node.js can be found at
    [https://nodejs.org](https://nodejs.org) .
  prefs: []
  type: TYPE_NORMAL
- en: Robomongo GUI for MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Robomongo** is a cross-platform desktop client that may be compared to MySQL
    or PostgreSQL for SQL databases.'
  prefs: []
  type: TYPE_NORMAL
- en: When developing an app, it's good to have a GUI and be able to quickly review
    collections in our database. This is an optional step if you feel familiar with
    using shell for DB management, but it's helpful if it's your first step in working
    with databases.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain Robomongo (for all operating systems), visit [https://robomongo.org/](https://robomongo.org/)
    and install one on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will use version 0.9.0 RC4 of Robomongo.
  prefs: []
  type: TYPE_NORMAL
- en: Running MongoDB and viewing our collections in the Robomongo GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have installed MongoDB and Robomongo on your machine, you need to
    run its daemon process, which listens to connections and delegates them to the
    database. To run the Mongo daemon process in your terminal, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Robomongo''s client--the following screen will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a connection with defaults by clicking the Create link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pick a name for your connection and use port `27017` , which is the default
    for databases, and click on Save .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you have a localhost database setup finished, and you can preview
    its content using the GUI client.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the first example collection into the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the project''s directory, create a file called `initData.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we are building the publishing app so it will be a list of articles.
    In the following code, we have an example collection of two articles in a JSON
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In general, we start from a mocked collection of articles--later we will add
    a feature to add more articles into MongoDB's collection, but for now we will
    stick with only two articles for the sake of brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list your localhost databases, open the Mongo shell by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While in the Mongo shell, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following for a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our example, it shows that we have one database in the localhost called `local`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Importing the articles to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following, we will use Terminal (the command prompt) in order to import
    the articles into the database. Alternatively, you can use Robomongo to do it
    via the GUI as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you need a new tab in your Terminal and `mongo import` will work
    while you are in the Mongo shell (Don't confuse it with the `mongod` process).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you shall see the following information in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you get the error `Failed: error connecting to db server: no reachable
    servers` , then make sure you have `mongod` running on the given host IP (`127.0.0.1`
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing those articles via the command line, you will also see this
    reflected in Robomongo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Server setup with Node.js and Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our article collection in MongoDB, we can start working on our
    Express.js server in order to work on the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need an NPM project in our directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `--yes` flag means that we will use the default settings for `package.json`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create an `index.js` file in the `server` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In `index.js` , we need to add a Babel/register in order to get better coverage
    of the ECMAScript 2015 and 2016 specification. This will enable us to support
    such structures as `async` and `generator` functions, which are not available
    in the current version of Node.js by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following for the `index.js` file content (we will install Babel''s
    `dev` dependencies later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing `express` and other initial dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the command, you can see `@4.13.4` after `express` and others. These are
    the versions of the libraries we're going to install, and we've picked it intentionally
    to make sure that it works well along side Falcor, but most probably you can skip
    these, and newer versions should work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to install `dev` dependencies (we have spilled all `npm install`
    commands into separate for better readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We need the `babel-preset-stage-0` is for ES7 features. The `babel-preset-es2015`
    and `babel-preset-react` are required for JSX and ES6 support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we install Babel to give our Node''s server the ability to
    use ES6 features. We need to add the `.babelrc` file, so create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open the `.babelrc` file and fill it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `.babelrc` is a hidden file. Probably the best way to edit
    the `.babelrc` is to open the whole project in a text editor such as Sublime Text.
    Then you should be able to see all hidden files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`babel` and `babel-core/register` : This is the library for transpiling new
    ECMAScript functions into the existing version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cors` : This module is responsible for creating cross-origin requests to our
    domain in an easy way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body-parser` : This is the middleware for parsing the request''s body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this, your project''s file structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `***` is a wildcard, which means that there are files required for our project,
    but we don't list them here as it would be too long.
  prefs: []
  type: TYPE_NORMAL
- en: Working on our server (server.js)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start working on the `server/server.js` file, which is new to our project,
    so we need to create it first with the following commands, in the `server` directory
    of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The content for the `server/server.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These files use the `babel/register` library so that we can use ES6 syntax in
    our code. In the `index.js` file, we have an `http` module which comes from Node.js
    ( [https://nodejs.org/api/http.html#http_http](https://nodejs.org/api/http.html#http_http)
    ). Next, we have `express` , `cors` , and `body-parser` .
  prefs: []
  type: TYPE_NORMAL
- en: Cors is middleware for dynamically or statically enabling **cross-origin resource
    sharing** (**CORS** ) in Express applications--it will be useful in our development
    environment (we will delete it later for our production server).
  prefs: []
  type: TYPE_NORMAL
- en: Body-parser is middleware for HTTP's body parsing. It has some fancy settings
    that help us build the app faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This how our app looks at this stage of our development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mongoose and Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, we have a simple working Express.js server. Now we have to add
    Mongoose to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have installed Mongoose and a running MongoDB database in the background,
    we can import it to our `server.js` file and do the coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of how to run the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure that you have MongoDB running in the background on your machine using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the `mongod` command in your terminal (or PowerShell on Windows),
    then you should see something like the following in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before you run the server, make sure the `devDependencies` in your `package.json`
    file look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run the server, make sure that the dependencies in your `package.json`
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main directory, run Node with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, your terminal should show something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Redux basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover only the most basic concepts of Redux that will
    help us make our simple publishing app. The app will only be in *read-only* mode
    for this chapter; later in the book we will add more functionality such as adding/editing
    an article. You will discover all the important rules and principles about Redux
    in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic topics covered are:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a state tree?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How immutability works in Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept and basic use of reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: The single immutable state tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important principle of Redux is that you are going to represent the
    whole state of your application as a single JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: All changes (actions) in Redux are explicit, so you can track a history of all
    your actions through the application with a dev tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is a simple, example dev tool use case that you will
    use in your development environment. It will help you to track the changes of
    state in your app. The example shows how we have incremented the counter value
    in our state by *+1* , three times. Of course, our publishing app structure will
    be much more complicated than this example. You will learn more about that dev
    tool later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability - actions and state tree are read-only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Redux bases its concepts on functional programming paradigms, you cannot
    modify/mutate the values in your state tree in the same way that you can for Facebook's
    (and other) FLUX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other FLUX implementations, an action is a plain object that describes
    the change--like adding an article (in the following code we mock the payload
    for the sake of brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An action is a minimal representation of the change for our app state tree.
    Let's prepare actions for our publishing app.
  prefs: []
  type: TYPE_NORMAL
- en: Pure and impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **pure function** is a function that doesn't have any side effects, such as
    for example, I/O (reading a file or an HTTP request). **Impure functions** have
    side effects so, for example, if you make a call to the HTTP request, it can return
    different values for exactly the same arguments *Y,Z (function(X,Y))* because
    an endpoint is returning us a random value, or could be down because of a server
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions are always predictable for the same *X,Y* arguments. In Redux,
    we use only pure functions in reducers and actions (otherwise Redux's `lib` won't
    work properly).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will learn the whole structure and where to make API calls.
    So if you follow the book, then you won't have to worry too much about that principle
    in Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The reducer function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reducers from Redux can be compared to a single store from Facebook's Flux.
    What is important is that a reducer always takes a previous state and returns
    a new reference to a new object (with the use of `Object.assign` and others like
    that), so we can have immutable JS helping us to build a more predictable state
    of our application in comparison to older Flux implementations that mutate variables
    in the store.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, creating a new reference is optimal because Redux uses old references
    to values from reducers that didn't change. This means that even if each action
    creates a whole new object via a reducer then the values that don't change have
    a previous reference in the memory so we don't overuse the computation power of
    the machine. Everything is fast.
  prefs: []
  type: TYPE_NORMAL
- en: In our app, we will have an article reducer that will help us to list, add,
    edit, and delete our articles from the view layer.
  prefs: []
  type: TYPE_NORMAL
- en: First reducer and webpack config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a reducer for our publication app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our first reducer''s location is `src/reducers/article.js` and the content
    of our `reducers/article.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have our `articleMock` kept in the browser memory
    (it's the same as in `initData.js` )--later, we will fetch this data from our
    backend database.
  prefs: []
  type: TYPE_NORMAL
- en: The arrow function, `const article` is getting `action.type` which will come
    from constants (we will create them later) in the same way that Facebook's FLUX
    implementation works.
  prefs: []
  type: TYPE_NORMAL
- en: For the default `return` in the `switch` statement, we provide the state from
    `state = articleMock` (return state; part above). This will return the initial
    state of our publishing app at first startup before any other action occurs. To
    be exact, the default in our case will do exactly the same as the `RETURN_ALL_ARTICLES`
    action before we start fetching data from the backend (after the articles' fetching
    mechanism from backend is implemented; then the default will return an empty object).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of our webpack configuration (described here), we need `index.html`
    in `dist` . Let''s create a `dist/index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dist/index.html` file''s content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have an article `reducer` and `dist/index.html` , but before we start building
    our Redux's publishing app, we need to configure webpack for our built automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install webpack first (you may need `sudo` root access for it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the main directory next to the `package.json` and `initData.js` files,
    input the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create webpack configs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply, webpack config says that the entry of the CommonJS module is at entry
    `''./src/app.js''` . webpack builds a whole app following all imports from the
    `app.js` and the final output is located at path `''./dist''` . Our app that is
    located at `contentBase: ''./dist''` will live at port `3000` . We also configure
    the use of ES2015 and React so that webpack will compile ES2015 into ES5 and React''s
    JSX into JavaScript for us. If you are interested in webpack''s configuration
    options, then read its documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the important dependencies installation and npm dev script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the Babel tools that are used by webpack (check the config file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update our `package.json` file (add `scripts` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our complete `package.json` should look like the following, with all frontend
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may realize, the mentioned `package.json` doesn''t have the `^` signs
    as we want to use the exact versions of each package in order to make sure that
    all our packages are installed with the correct and exact version given in the
    package. Otherwise, you may have some difficulties, for example, if you add `"mongoose":
    "4.4.5"` , with the `^` then it will install a newer version that causes some
    additional warnings in the console. Let''s stick to the versions mentioned in
    the book in order to avoid unnecessary problems with the app that we are building.
    We want to avoid NPM dependencies hell at all cost.'
  prefs: []
  type: TYPE_NORMAL
- en: Working on src/app.js and src/layouts/PublishingApp.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our `app.js` file, where the main part of our app will live at
    `src/app.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of our new `src/app.js` file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The new part is the `store = createStore(article)` part--this utility from Redux
    lets you keep an application state object, dispatch an action, and allows you
    to give a reducer as an argument that tells you how the app is updated with actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `react-redux` is a useful binding of Redux into React (so we will write
    less code and be more productive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Provider store` helps us to make the Redux store available to the `connect()`
    calls in the child components (as shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`connect` will be used in any component that has to listen to the reducer''s
    changes in our app. You will see how to use it later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the store, we use `const store = createStore(article)` --just for the sake
    of brevity, I will mention that there are several methods in the store that we
    will use in the next steps of building our app from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getState` function gives you the current state of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dispatch` function can help you change the state of your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Subscribe allows you register a callback that Redux will call each time an action
    has been dispatched, so the view layer can learn about the change in the application
    state and refresh its view.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up React-Redux application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish our first React-Redux app. For a summary, let''s see our current
    directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create the main view of our app. We will put this into the layout
    directory in our first version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `PublishingApp.js` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding introduces the ES7 syntax `...` next to `...` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`...` is a spread operator that is well described in Mozilla''s documentation
    as; *an expression to be expanded in places where multiple arguments (for function
    calls) or multiple elements (for array literals) are expected* . In our case,
    this `...` operator spreads one object state into a second one (in our case, empty
    object `{ }` ). It''s written like this here because, in future, we will specify
    multiple reducers that have to be mapped from our app''s state into the `this.props`
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: Finishing our first static publishing app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing to do in our static app is to render the articles that come from
    `this.props` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Redux, the object mocked in the reducer is available, so if you check
    `console.log(this.props)` in the render function of `PublishingApp.js` , then
    you will be able to access our `articles` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we need to change the React''s render function, as follows (in
    `src/layouts/PublishingApp.js` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are iterating `for(let articleKey in this.props)`
    over the article `Mock` object (passed from the reducer''s state in `this.props`
    ) and creating an array of articles (in JSX) with `articlesJSX.push(currentArticleJSX);`
    . After it is created, then we will have added the `articlesJSX` into the `return`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This comment will start your project on port `3000` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After you check `localhost:3000` , the new static Redux app should look as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great, so we have a static app in Redux! It's time to fetch data from our MongoDB
    database using Falcor.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falcor's basic concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Falcor is like a glue between:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend and its database structure (remember importing `initData.js` into MongoDB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend Redux single state tree container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It glues the pieces in a way that is much more effective than building an old-fashioned
    REST API for a single-page application.
  prefs: []
  type: TYPE_NORMAL
- en: Like the *Redux basic concepts* section, in this one we will learn only the
    most basic concepts of Falcor and they will help us build a simple full-stack
    application in *read-only* mode. Later in the book, you will learn how to make
    an add/edit article with Falcor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on the most important aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Falcor's model?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving values from Falcor (frontend and backend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts and basic use of JSON graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts and basic use of sentinels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to retrieve data from the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure our first route with middleware for Express.js called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`falcor-router`'
  prefs: []
  type: TYPE_NORMAL
- en: What is Falcor and why do we need it in our full-stack publishing app?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first consider what the difference is between web pages and web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: When the **World Wide Web** (**WWW** ) was invented, web pages served small
    amounts of large resources (such as HTML, PDF, and PNG files). For example, you
    could request a PDF, video, or text file from a server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since *circa 2008* , the development of web apps has been getting more and more
    popular. Web applications serve large amounts of small resources. What does it
    mean for us? You have a lot of small REST API calls to the server using AJAX calls.
    The old approach of many API requests creates latency, which slows down the mobile/web
    app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we use old REST API requests (as we did in 2005) in apps written in 2016
    and later? This is where Falcor shines; it solves the problem of latency and tight
    coupling of backend to frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling and latency versus one model everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are familiar with frontend development, you know how to make requests
    to an API. This old way of doing things always forces you to tight-couple the
    backend API with frontend API utilities. It''s always like that:'
  prefs: []
  type: TYPE_NORMAL
- en: You make an API endpoint like [https://applicationDomain.com/api/recordDetails?id=92](https://applicationDomain.com/api/recordDetails?id=92)
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You consume the data with HTTP API requests on the frontend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In large applications, it's hard to maintain real DRY RESTful APIs, and this
    problem causes plenty of endpoints that are not optimized, so the frontend sometimes
    has to do many round trips in order to fetch the data required for a certain view
    (and sometimes it fetches much more than it needs, which causes even more latency
    for the end user of our application).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a large application with over 50 different API endpoints.
    After the first version of your application is finished, your client or boss finds
    a better way to structure the user flow in the app. What does this mean? That
    you have to work on changing both frontend and backend endpoints in order to satisfy
    the changes in the user interface layer. This is called tight coupling between
    frontend and backend.
  prefs: []
  type: TYPE_NORMAL
- en: What does Falcor bring to this situation to improve on those two areas that
    cause the inefficiency in working with RESTful APIs? The answer is one model everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: It would be super easy to build your web applications if all your data was accessible
    in memory, on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Falcor provides utilities that help you feel that all your data is at your fingertips
    without coding backend API endpoints and client-side consuming utilities.
  prefs: []
  type: TYPE_NORMAL
- en: No more tight coupling on client and server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falcor helps you represent all of your app's data as one virtual JSON model
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: When programming client side, Falcor makes you feel as if the whole JSON model
    of your application is reachable locally, and allows you to read data the same
    way as you would from an in-memory JSON--you will learn it very soon!
  prefs: []
  type: TYPE_NORMAL
- en: Because of Falcor's library for browsers and the `falcor-express` middleware,
    you can retrieve your data from the model on-demand, from the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Falcor transparently handles all the network communication and keeps your client-side
    app in sync with the server and databases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also learn how to use `falcor-router` .
  prefs: []
  type: TYPE_NORMAL
- en: Client-side Falcor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install Falcor from NPM first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `falcor-http-datasource` helps us to retrieve data from server to client
    side, out-of-the-box (without worrying about HTTP API requests)--we will use this
    later when moving the client-side model to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our app''s Falcor model on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the content of the `falcorModel.js` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you can find a well-known, brief, and readable model of our publishing
    application with two articles in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will fetch that data from the frontend Falcor's model in our `src/layouts/PublishingApp.js`
    React component, we will add a new function called `_fetch()` which will be responsible
    for fetching all articles on our application start.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to import our Falcor model first, so at the top of the `PublishingApp.js`
    file, we need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `PublishingApp` class, we need to add the following two functions; `componentWillMount`
    and `_fetch` (more explanation follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, you see the asynchronous function called `_fetch` . This is a special
    syntax that allows you to use the `await` keyword like we do when using `let articlesLength
    = await falcorModel` and `let articles = await falcorModel` .
  prefs: []
  type: TYPE_NORMAL
- en: Using `async await` over Promises means our code is more readable and avoids
    callback hell situations where nesting multiple callbacks one after the other
    makes code very hard to read and extend.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` /`await` feature is taken from ECMAScript 7 inspired by C#. It allows
    you to write functions that appear to be blocked at each asynchronous operation
    that is waiting for the result before continuing to the next operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the code will execute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First it will call Falcor''s mode for an article count with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the article's `Length` variable, we will have a count of `articles.length`
    from our model (in our case it will be number two).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we know that we have two articles in our model, then the next block of
    code executes the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` method on `falcorModel.get([''articles'', {from: 0, to: articlesLength-1},
    [''id'',''articleTitle'', ''articleContent'']]).` is also an asynchronous operation
    (in the same way as `http request` ). In the `get` method''s parameter, we provide
    the location of our articles in our model (in `src/falcorModel.js` ), so we are
    providing the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the preceding Falcor path is based on our model. Let''s
    call it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are saying to Falcor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we want to get data from `articles` within our object using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next from `articles` collection select subset of all the articles it has with
    a range `{from: 0, to: articlesLength-1}` (the `articlesLength` we have fetched
    earlier) with the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step explains to Falcor, which properties from the object you want
    to fetch from our model. So the complete path in that `falcorModel.get` query
    is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The array of `['id','articleTitle', 'articleContent']` says that you want those
    three properties out of every article.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the end, we receive an array of article objects from Falcor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After we have fetched the data from our Falcor model, we need to dispatch an
    action that will change the article's reducer accordingly and ultimately re-render
    our list of articles from our Falcor model from the `const articleMock` (in `src/reducers/article.js`
    ) instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we will be able to dispatch an action, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `actions` directory with `article.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the content for our `src/actions/article.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: There isn't too much in that `actions/article.js` file `.` If you are familiar
    with FLUX already then it's very similar. One important rule for actions in Redux
    is that it has to be a pure function. For now, we will hardcode a constant called
    `ARTICLES_LIST_ADD` into `actions/article.js` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/layouts/PublishingApp.js` file we need to add a new import code
    at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have added the preceding two in our `PublishingApp` , then modify
    our existing function in the same file from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `articleActions: bindActionCreators(articleActions, dispatch)` so that
    we are able to bind the articles'' actions into our `this.props` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the mentioned changes `(articleActions: bindActionCreators(articleActions,
    dispatch))` in our component, we will be able to dispatch an action from props
    because now, when you use `this.props.articleActions.articlesList(articles)` then
    the `articles` object fetched from Falcor will be available in our reducer (and
    from there, there is only one step to make our app fetch data work).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after you are done with these changes, add an action into our component
    in the `_fetch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Our whole function for fetching will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, don''t forget about calling `_fetch` from `ComponentWillMount` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we shall be able to receive an action in our Redux''s reducer.
    Let''s improve our `src/reducers/article.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't need `articleMock` anymore, so we have deleted it from
    the `src/reducers/article.js` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a new case, `ARTICLES_LIST_ADD` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It returns a new `articlesList` object (with a new reference in the memory,
    thanks to `Object.assign` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t confuse the two files with the same name and other locations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reducers/article.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`actions/article.js`'
  prefs: []
  type: TYPE_NORMAL
- en: You need to make sure that you are editing the correct file, otherwise the app
    won't work.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of client-side Falcor + Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run `http://localhost:3000/index.html` , you will see that, currently
    we have two separate applications:'
  prefs: []
  type: TYPE_NORMAL
- en: One at the frontend using Redux and client-side Falcor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One at the backend using MongoDB, Mongoose, and Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to stick both together so we have one source of state for our applications
    (that comes from MongoDB).
  prefs: []
  type: TYPE_NORMAL
- en: Moving Falcor's model to the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also need to update our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Because we are starting the full-stack development part, we need to add `npm
    start` to our scripts in `package.json` --this will help compile client side,
    put them into the `dist` folder (generated via webpack), and create static files
    in `dist` , and then use this folder as the source of static files (check `server/server.js`
    for `app.use(express.static('dist'));` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important thing is to install new dependencies that are required for
    Falcor on the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have finally installed new dependencies and configured the basic scripts
    for running the backend and frontend on the same port, then edit the `server/server.js`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of our file, import new libraries in the `server/server.js` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then between the following two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Add new code for managing Falcor at the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is almost the same as the one in the `src/falcorModel.js`
    file. The only difference is that now Falcor will fetch data from the backend's
    mocked object, called `cache` in `server.js` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second part is to change our data source on the frontend, so in the `src/falcorModel.js`
    file, you change the following old code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following updated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see in your browser''s dev tools a new HTTP request made by Falcor--for
    example, in our case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you follow all the instructions correctly, then you can also make a request
    to your server directly from your browser by executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you shall see a `jsonGraph` in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You don't have to worry about those preceding two screenshots. They are just
    an example of how Falcor is communicating between the backend and frontend in
    Falcor's language. You don't have to worry anymore about exposing API endpoints
    and programming frontend to understand what data the backend is providing. Falcor
    is doing all of this out-of-the-box and you will learn more details while making
    this publishing application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Falcor's router (Express.js)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our model on the backend is hardcoded, so that it stays in the RAM
    memory of a server. We need to add the ability to read the data from our MongoDB's
    articles collection--this is where the `falcor-router` comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create our routes definition files that will be consumed by `falcor-router`
    lib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created the `server/routes.js` file; the content for that router will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have created our first route that will match the `articles.length`
    from our `_fetch` function (in `layouts/PublishingApp.js` ).
  prefs: []
  type: TYPE_NORMAL
- en: We have hardcoded the number two in `articlesCountInDB` , later we will make
    a query to our database there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new stuff here is `route: ''articles.length''` , this is simply a route
    for matching by Falcor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more precise, the Falcor routes'' paths are exactly the same stuff that
    you have provided in your `src/layouts/PublishingApp.js (_fetch function)` for
    example, to match this frontend call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`path: [''articles'', ''length'']` : This property tells us Falcor''s path
    (it''s consumed by Falcor at the backend and frontend). We need to provide that
    because sometimes, one route can return many different objects as server articles
    (you will see it in the next route we create).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value: articlesCountInDB` : This is a return value. In this case, it is an
    integer number, but it can also be an object with several properties, as you will
    learn later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second route for returning our two articles from the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our second route (and last one in this chapter) will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The new thing in the second route is `pathSet` , if you log that into the console,
    then you will see, in our case (when trying to run our full-stack app) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`pathSet` tells us what indexes are requested from the client side (`[ 0, 1
    ]` , in our example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because, in this case, we are returning an array of articles (multiple articles),
    we need to create a result variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the requested indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we iterate over an array of requested indexes
    (do you remember `{from: 0, to: articlesLength-1}` in `PublishingApp.js` ?). Based
    on the indexes `([0, 1])` we fetch mocked data via `const singleArticleObject
    = articlesArrayFromDB[index];` . Later we put into the `path` and `index` (`path:
    [''articles'', index],` ) so Falcor knows to what path in our JSON graph object,
    the value `singleArticleObject` belongs to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return that array of articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '`console.info` will show us what has been returned by that path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Final touch to make full-stack Falcor run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we still have mocked data in our routes, but before we start making
    calls to MongoDB, we need to wrap up the current setup so you will be able to
    see it running in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `server/server.js` and make sure you import the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have imported our `falcor-router` and `routes.js` --we need to
    use them, so modify this old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This will work only when the `falcor-router` has been already installed and
    imported in the `server.js` file. This is a library for `DataSource` that creates
    a virtual JSON graph document on your app server. As you can see in `server.js`
    so far we have `DataSource` provided by our hardcoded model, `return model.asDataSource();`
    . The router here will make the same, but now you will be able to match routes
    based on your app requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as you can see, the new `falcorRouter` takes an argument of our routes
    `return new falcorRouter(routes);` .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed the instructions correctly, you will be able to run the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'On port `3000` , you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding MongoDB/Mongoose calls based on Falcor's routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get back to our `server/routes.js` file. We need to move over (delete
    from `server.js` and move into `routes.js` ) this following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first route `articles.length` , you need to replace the mocked number
    two (the articles count) into Mongoose''s `count` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We are returning a Promise in `get` (Mongoose, by its asynchronous nature, always
    returns a Promise while making any database's request, as in the example, `Article.count`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The method `Article.count` simply retrieves the integer number of articles'
    count from our *Article* model (that was prepared at the beginning of this book
    in `MongoDB/Mongoose sub-chapter` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second route `route: ''articles[{integers}]["id","articleTitle","articleContent"]''`
    , has to be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We return a Promise again with `Article.find` . Also, we have deleted the mocked
    response from the database and instead we are using the `Article.find` method.
  prefs: []
  type: TYPE_NORMAL
- en: The array of articles is returned in `}).then ((articlesArrayFromDB) => {` and
    next we simply iterate and create a results array.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on `const singleArticleObject = articlesArrayFromDB[index].toObject();`
    we use a method `.toObject` . This is very important for making this work.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-check with the server/routes.js and package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to save you time in case the app doesn''t run, we can double-check
    that the backend''s Falcor routes are prepared correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Check that your `server/routes.js` file looks similar to the preceding code
    and the other code elements that you have used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, check that your `package.json` look likes the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing to notice about `package.json` is that we have removed
    the `^` from `"mongoose": "4.4.5"` . We did this because if NPM installs any higher
    version than `4.4.5` , then we get a warning in the bash/command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Our first working full-stack app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After that, you should have a complete full-stack version of the app working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At almost every step, the UI part of our app is identical. The preceding screenshot
    is the publishing app, which does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetches data from the DB using `Falcor-Express` and `Falcor-Router` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data moves from the backend (the source is MongoDB) to the frontend. We
    populate Redux's `src/reducers/article.js` state tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We render the DOM elements based on our single state tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these steps allow us to take all of the full-stack app's data from the database,
    to the user's browser (so a user can see an article).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We haven't started to work on the app design, but in our book, we will use the
    Material Design CSS for React ( [http://material-ui.com](http://material-ui.com)
    ). In the next chapter, we will start using it for user registration and login.
    After that, we will re-style the main page of our application using Material Design's
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to give you a teaser of the goal (while working through the book),
    here is a screenshot of the app and how the publishing app will improve in the
    following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, there is an example article from our application.
    We are using several Material Design components in order to make our work easier
    and the publishing app look more professional. You will learn it later.
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to work on the full-stack login and registration for our publishing
    app in the next chapter? Let's continue the fun.
  prefs: []
  type: TYPE_NORMAL

- en: Full-Stack Login and Registration for Our Publishing App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Token** (**JWT** ) is a security tokens format, which is relatively
    new, but works very well. It''s an open standard (RFC 7519) that improves oAuth2
    and OpenID connection when dealing with the problem of passing claims between
    parties in a web application environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server assigns an encoded JSON object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After client has been alerted, it sends that encoded token with every request
    to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on that token, the server knows who is sending a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s worth visiting the [http://jwt.io/](http://jwt.io/) website and playing
    with it before you start working with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After successful login, the JWT''s solution provides an object to our frontend
    application that tells us about a current user''s authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iss` is an issuer property--in our case it will be our publishing app''s
    backend application. The name of the logged user is obvious--`John Doe` has logged
    in successfully. The `admin` property is just saying that an identified user (logged
    into our backend''s app with the correct login and password) is an admin `(''admin'':
    true flag)` . You will learn how to use it in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides what has been said in the preceding example, the JWT's response also
    contains information about subjects/claims, a signed SHA256's generated token,
    and an expiration date. The important rule here is that you must be sure about
    the issuer of your token. You need to trust the content provided along with the
    response. It may sound complicated, but it is very simple in real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is that you need to keep the token generated by JWT protected---this
    will be elaborated upon later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our client's publishing app requests a token from our express's server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The publishing backed app issues a token to the frontend Redux's app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, each time we fetch data from the backend, we check if a user has
    access to the requested resources on the backend--the resource consumes the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our case, the resource is a falcor-router's route, which has a close relationship
    with the backend, but this may work as well in more distributed platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the JWT tokens are similar to private keys--you must keep them
    secure!
  prefs: []
  type: TYPE_NORMAL
- en: Structure of JWT token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The header has information that is required on the backend for recognizing
    what cryptographic operation to do based on that information (metadata, the algorithms,
    and keys being used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In general, that part is done 100 percent out of the box for us, so we don't
    have to care about headers while implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part consists of claims provided in the JSON format, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Issuer** : This lets us know who has issued the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audience** : This lets us know that this token has to be consumed by our
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue date** : This lets us know when the token has been created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expiration date** : This lets us know when the token is expiring so we have
    to generate a new one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject** : This lets us know which part of the app can use the token (useful
    in bigger applications)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these claims, we can create custom claims that are specifically defined
    by the app''s creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: New MongoDB users collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create a users'' collection in our database. The users will have
    privileges allowing them to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new articles in our publishing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit existing articles in our publishing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete articles in our publishing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step is that we need to create a collection. You can do this from
    the GUI in Robomongo (introduced at the beginning of the book), but we will use
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all we need to create a file called `initPubUsers.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following content to `initPubUsers.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SHA256 string, `c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852`
    , is the equivalent of a password, 123456, with a salt's string equal to `pubApp`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to generate this salted password hash yourself, then go to [http://www.xorbin.com/tools/sha256-hash-calculator](http://www.xorbin.com/tools/sha256-hash-calculator)
    and type `123456pubApp` on their website. You will get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These steps are required only at the beginning. Later we need to program a registration
    form that is salting the password for our own.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the initPubUsers.js file into MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have the correct content in our `initPubUsers.js` file, we can run
    a command line as follows in order to import the new `pubUsers` collection to
    our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the same terminal output as what we we got after importing the
    article in [Chapter 1](text00021.html) , *Configuring Full-Stack with Node.js,
    Express.js, MongoDB, Mongoose, Falcor, and Redux* , looking similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Working on the login's falcor-route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to start working with the falcor-router in order to create a new
    endpoint that will use the JWT library to provide a unique token for the client-side
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we need to do is to provide `secret` on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create that `secret` endpoint''s config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to put in the content of this `secret` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In future, we will use environment variables on the production server, so the
    notation `process.env.JWT_SECRET || 'devSecretGoesHere'` means that the environment
    variable of `JWT_SECRET` doesn't exist so use default `secret` endpoint's `string,devSecretGoesHere`
    . At this point we don't need any development environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a falcor-router's login (backend)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make our codebase more organized, instead of adding one more route
    to our `server/routes.js` file, we will make a new file called `routesSession.js`
    and in that file we will keep all the endpoints related to the current logged
    user's session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are in the `server` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First open the `server.js` file in order to add one line of code that will
    allow you to post usernames and passwords to the backend. Add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This has to be added under `app.use(bodyParser.json({extended: false}));` so
    you will end up with `server.js` code that begins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is a new line that has to be added in order to make it work.
    Then create a new file in the same directory with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And put this initial content into the `routesSession.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How the call routes work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just created an initial call login route in the `routesSession.js`
    file. Instead of using a GET method, we are going to use a `''call''(**call: async
    (callPath, args) => **)` . That is the equivalent to POST in the old RESTful approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the call and get methods in Falcor''s routes is that
    we can provide arguments with `args` . That allows us to get from the client-side
    the username and the password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plan is that after we receive credentials with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will check them against our database with one user admin. A user will
    need to know that the real plaintext password is `123456` in order to get a correct
    login JWTtoken:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have prepared in this step a `userStatementQuery` ---this will be used
    later when querying a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the DB configs - configMongoose.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to separate DB configs from `routes.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And its new content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just introduced the following new `env` variables: `MONGO_HOSTNAME`
    , `MONGO_PORT` , and `MONGO_ENV` . We will use them when preparing a production
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mongodb://${conf.hostname}:${conf.port}/${conf.env}` expression is using
    a templating feature available since EcmaScript6.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of `configMongoose.jsconfig` will be known to you, as we have introduced
    it in [Chapter 1](text00021.html) , *Configuring Full-Stack with Node.js, Express.js,
    MongoDB, Mongoose, Falcor, and Redux* .
  prefs: []
  type: TYPE_NORMAL
- en: Improving the routes.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have created two new files, `configMongoose.js` and `routesSession.js`
    , we have to improve our `server/routes.js` file in order to make everything work
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to delete from `routes.js` the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to spread `sessionRoutes` into our current `PublishingAppRoutes`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of `PublishingAppRoutes` you need to spread `...sessionRoutes`
    , `routes` , so the login route will be available to use across the Falcor's routes.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We got rid of the old code that was helping us to run the first Mongoose query
    that was fetching the articles, and we moved everything to `configMongoose` so
    that we can use it in different files around our project. We have also imported
    the session routes and later spread them with the `...` spread operation into
    the array called `PublishingAppRoutes` .
  prefs: []
  type: TYPE_NORMAL
- en: Checking to see if the app works before implementing JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, when doing `npm start` , the app should be working and showing
    the list of articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When running with `npm start` you should get the following information, validating
    that everything works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Mongoose users' model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the file `configMongoose.js` we need to create and export a `User` model.
    Add the following code to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `userSchema` describes our user's JSON model. The user is our Mongoose's
    model that is pointing to the `pubUsers` collection in our MongoDB. At the end,
    we are exporting the `User` model by adding it to the export default's object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JWT in the routesSession.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to export our `User` model into `routesSession` scope by
    adding at the top of that file an `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `jsonwebtoken` and `crypto` (for SHA256):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed `jsonwebtoken` , we need to import it to `routesSession.js`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have imported everything in the `routesSession` , continue on working
    with the `route: [''login'']` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to improve `userStatementQuery` , so it will have the `saltedPassword`
    instead of plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So instead of plain text, we will query a salted SHA256 password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under this `userStatementQuery` , return Promise, with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `User.find` is a Promise that comes from Mongoose user''s model (that we
    created in `configMongoose.js` )--this is a standard method. Then as a first argument
    we provide `userStatementQuery` which is that filter''s object with the username
    and password in it: `(*{ username, password } = args[0];)` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we provide a function that is a callback when the query is done: `(function(err,
    user) {)` . We count the amount of results with `if(result.length) {` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `result.length=== 0` then we have mocked `return` statement, and we are
    getting the `else` code running with the following return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you will learn later, we will ask for that token's path on the frontend,
    `['login', 'token']` . In this case, we haven't found the correct username and
    the password provided so we return the `"INVALID"` string, instead of a JWT token.
    The path `['login', 'error']` is describing the error's type in more detail so
    that message can be shown to a user that has provided the invalid login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Successful login on falcor-route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to improve the successful login path. We have a case for handling an
    invalid login; we need to make a case that will handle a successful login, so
    replace this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code that is returning the successful login''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the only thing that we fetch from DB right now is the role `value
    === result[0].role` . We need to add this to hash, because we don't want our app
    to be vulnerable so a normal user can get an admin role with some hacking. The
    value of the token is calculated based on `userDetailsToHash = username+role`
    ---that's enough for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we are fine with this, the only thing that needs to be done on the backend
    is returning the paths with values:'
  prefs: []
  type: TYPE_NORMAL
- en: The login token with `['login', 'token']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username with `['login', 'username']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logged user's role with `['login', 'role']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information that there were no errors at all with `['login', 'error']`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to use this route on the frontend. Run the app and if everything
    is working fine, we can start coding on the frontend side.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend side and Falcor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new route for the login in our Redux application. In order
    to do that, we need to introduce the `react-router` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It's important to use the correct NPM's version otherwise things get broke!
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have installed them, we need to add routes in `src` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then make the content of this `index.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are missing two components for our app called `CoreLayout`
    and `LoginView` (we will implement them in a minute).
  prefs: []
  type: TYPE_NORMAL
- en: The CoreLayout component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CoreLayout` component is the wrapper for our whole application. Create
    it by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, populate it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you probably know, all the content of a current route will go into the `{this.props.children}`
    target (that is a `basicReact.JS` concept that you must know beforehand). We also
    created two links to our routes as a header.
  prefs: []
  type: TYPE_NORMAL
- en: The LoginView component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the time being, we will create a mocked `LoginView` component. Let''s create
    the `views` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of the `LoginView.js` file is shown in the following code with
    the `FORM GOES HERE` placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We are done with all the missing pieces for the `routes/index.js` , but there
    is some other outstanding stuff to do before our app with the routing will start
    working.
  prefs: []
  type: TYPE_NORMAL
- en: A root's container for our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because our app is getting more complicated, we need to create a container
    that it will live in. In order to do that, let''s do the following in the `src`
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Root.js` is going to be our main root file. The content of this file is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For now it's only a simple container, but later we will implement into it more
    features for debugging, hot reloading, and so on. The `noQueryKeyHistory` is saying
    to the router, that we don't want to have any random strings in our URL so our
    routes will be looking nicer (not a big deal, you can change the false flag to
    true, to see what I am talking about).
  prefs: []
  type: TYPE_NORMAL
- en: Remaining configuration for configureStore and rootReducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create `rootReducer` first. Why do we need it? Because in bigger applications
    you always end up with many different reducers; for example, in our app we will
    have reducers such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Article''s reducer** : Which keeps stuff related to articles (`RETURN_ALL_ARTICLES`
    and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session''s reducer** : Which will be related to our users'' sessions (`LOGIN`
    , `REGISTER` , and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editor''s reducer** : Which will be related to the editor''s actions (`EDIT_ARTICLE`
    , `DELETE_ARTICLE` , `ADD_NEW_ARTICLE` , and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing''s reducer** : This will manage the state of our routes (out-of-the-box,
    because it is managed by the redux-simple-router''s external lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create an `index.js` file in our `reducers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The content for the `index.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The new thing here is that we are introducing a `combineReducers` function from
    Redux. This is exactly what I've written before. We will have more than one reducer---in
    our case, we have also introduced the `routeReducer` from a redux-simple-router's
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `configureStore` that will be managing our stores
    and also in order to implement a server rendering later in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The content for the `configureStore.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are importing the `rootReducer` that we've created
    recently. We also import the `redux-thunk` lib which is very useful for server-side
    rendering (described later in the book).
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we export a store which is composed of many different reducers (currently
    routing and the article's reducer that you can find in `reducer/index.js` ) and
    is able to handle the server-rendering initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Last tweaks in layouts/PublishingApp.js before running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing that changed in our app is that we have out-of-date code in our
    publishing app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is it outdated? Because we have introduced `rootReducer` and `combineReducers`
    . So if you check your code in the rendering of `PublishingApp` here, it won''t
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see the difference? The old `for(let articleKey in this.props)` has
    changed into `for(let articleKey in this.props.article)` and `this.props[articleKey]`
    has changed to `this.props.article[articleKey]` . Why? I will recall again: now
    every new reducer will be available in our app via its name created in `routes/index.js`
    . We have named our reducer article, so we now had to add this into `this.props.article`
    to make this stuff work together.'
  prefs: []
  type: TYPE_NORMAL
- en: Last changes in src/app.js before running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing is to improve the `src/app.js` so it will use the root''s container.
    We need to change the old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We start using the `Root` instead of the `Provider` directly, and we need to
    send the store and history's props to the `Root` component. The `***export const
    store = configureStore(window.__INITIAL_STATE__)***` part is here for the server-side
    rendering which we will add in one of the following chapters. We also use the
    history's library to manage the browser's history with the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Screenshots of our running app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently when you do `npm start` then you will see the following two routes.
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](Image00022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Login view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working on the login form that will call the backend in order to authenticate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so we have done a lot of preparation in terms of having an extensible
    project structure (`routes` , `rootReducer` , `configStores` , and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make our app nicer from a user perspective, we will start using
    Material Design CSS. For making our work easier with forms, we will start using
    a `formsy-react` library. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book, the version .20.14.4 of Material UI is the
    best choice; I used this version because the ecosystem is changing so quickly
    that it's better to mark the used version in here so you won't have any surprises
    when following the instructions in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The `formsy-react` library is a very handy library which will help us to validate
    our forms in the publishing app. We will use it on pages like login and registration
    as you will see on the next pages.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on LoginForm and DefaultInput components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we are done with installing our new dependencies, let''s create a folder
    that will keep files related to dumb components (the components that don''t have
    access to any stores; they communicate with the other parts of our application
    with the help of callbacks---you will learn more about this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then make the content of this file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `{HOC}` from `formsy-react` is another way of decorating the component (aka
    `mixin` in React's ECMAScript5) with export default `HOC(DefaultInput)` --you
    can find more information about this at [https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc](https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using the `TextField` from the `material-ui` ; then it takes different
    properties. The following are the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ref` : We want `ref` for each input with its name (username and e-mail).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`floatingLabelText` : This is a nice looking floating text (known as label).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChange` : This tells the function''s name that has to be called when someone
    is typing into the TextField.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` : This helps us to manage the required inputs in our form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` : This is, of course, the current value of our TextField.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue` : This is a value that is initial. It is very important to remember
    that it''s called just once when a component is calling a constructor of the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current text (`this.state.currentText` ) is the value of the `DefaultInput`
    component---it changes with the new value on every `changeValue` event called
    by the callback given in the `TextFieldonChange` prop.
  prefs: []
  type: TYPE_NORMAL
- en: LoginForm and making it work with LoginView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create `LoginForm` . This will use the `DefaultInput` component
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the content of our `src/components/LoginForm.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have our `LoginForm` component that is using the `DefaultInput`
    's component. It's a simple `React.js` form that after being submit calls the
    `this.props.onSubmit` --this `onSubmit` function will be defined in `src/views/LoginView.js`
    smart component in a moment. I won't talk too much about attached styles on the
    component because it's up to you how you will style it--you will see a screenshot
    of applied styles of our app in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the src/views/LoginView.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last part at our development at this stage before running our application
    is to improve the `LoginView` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/views/LoginView.js` make the following changes. Import our new `LoginForm`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then after you are done with imports and constructors, you need a new function
    called `login` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `login` function only prints our new JWT token to the console--it's
    enough for now; later we will build more on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step here is to improve our `render` function from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To the new one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we are done! The following is what you will see after running `npm
    start` and running it in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the browser''s console, we can see the submitted credential''s
    object `(credentials Object {username: "admin", password: "123456"})` and also
    a token that has been fetched from the backend `(tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)`
    . All this tells us that we are on track in order to implement the login''s mechanism
    in our publishing application.'
  prefs: []
  type: TYPE_NORMAL
- en: Important If you get an error, then make sure that you have used the `123456`
    password while creating the hash. Otherwise, type in the custom password that
    is valid to your case.
  prefs: []
  type: TYPE_NORMAL
- en: Making DashboardView's component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have a login feature that is not finished, but before continuing
    the work on it, let''s create a simple `src/views/DashboardView.js` component
    that will be shown after a successful login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some simple content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple component, which is static at this point. Later, we will build
    more features into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing regarding the dashboards that we need to create is a new route
    in the `src/routes/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We've just added second route using the react-router's config. It uses `DashboardView`
    component located in `../views/DashboardView` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the login's mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last improvements for login at this point of our publishing app remain
    at the `src/views/LoginView.js` location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s add handling an invalid login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added this `if(tokenRes === ''INVALID'')` in order to update the error
    state with `this.setState({error: errorRes})` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add into the `render` function `Snackbar` that will show
    to the user a type of error. At the top of the `LoginView` component add this
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to update the `render` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So after adding it, the `render` function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `SnackBar onRequestClose` is required here otherwise you will get a warning
    in the developer's console from the Material UI. Okay, so we are handling login's
    error, now let's work on successful logins.
  prefs: []
  type: TYPE_NORMAL
- en: Handling successful logins in the LoginView's component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For handling a successful token''s backend responses add the login function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A new code for handling correct responses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we know that the `tokenRes` is not `INVALID` and it''s not undefined
    (otherwise shows a fatal error to the user), then we follow certain steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are fetching the username from the Falcor''s model `(await falcorModel.getValue(''login.username''))`
    . We are fetching the user''s role `(await falcorModel.getValue(''login.role''))`
    . Then we save all the known variables from the backend into `localStoragewith`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At the same end we are sending our user to the `/dashboard` route with the use
    of `this.props.history.pushState(null, '/dashboard')` .
  prefs: []
  type: TYPE_NORMAL
- en: A few important notes about DashboardView and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we won't secure `DashboardView` as there isn't any important
    stuff to secure---we will do it later when we put more assets/features into this
    route, which at the end of our book will be an editor's dashboard that will give
    control over all articles in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The only remaining step for us is to make it a `RegistrationView` component.
    This route will also be available for everyone at this point. Later in the book,
    we will make a mechanism so that only the main admin will be able to add new editors
    into the system (and manage them).
  prefs: []
  type: TYPE_NORMAL
- en: Starting work on the new editor's registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to wrap up the registration, let''s first make some changes in our
    user''s scheme from Mongoose''s config file at the location `server/configMongoose.js`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To the new scheme as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added unique indexes to the `username` and the `email`
    fields. Also, we have added a default value for a role, as any next user in our
    collection will be an editor (not an admin).
  prefs: []
  type: TYPE_NORMAL
- en: Adding register's falcor-route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the file located at `server/routesSession.js` , you need to add a new route
    (next to the login''s route):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: What this code is actually doing is simply receiving the new user's object from
    the frontend via `const newUserObj = args[0]` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we are salting the password that we will store in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are creating a new user model from Mongoose via `const newUser = new
    User(newUserObj)` , because the `newUser` variable is a new model (not saved yet)
    of the user. Next we need to save it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After it's saved into the db and the Promise has been resolved, we are managing
    an invalid entry to the db first by making the Mongoose result's object into a
    simple JSON structure with `const newUserDetail = newRes.toObject();` .
  prefs: []
  type: TYPE_NORMAL
- en: 'And after we are done with it, then we are returning an `INVALID` information
    to the Falcor''s model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we are done with handling an invalid user registration from Falcor. The
    next step is to replace this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to cast our new user's ID into the string, `newUserId = newUserDetail._id.toString()`
    (otherwise it will break the code).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have a standard return statement that complements the model
    in Falcor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly recall, after it returns correctly on the backend, we will be able
    to request this value on the frontend as follows: `const newUserId = await falcorModel.getValue([''register'',
    ''newUserId'']);` (this is just an example of how to fetch this new `UserId` on
    the client-side--don''t write it into your code, we will do it in a minute).'
  prefs: []
  type: TYPE_NORMAL
- en: You will get used to it after few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend implementation (RegisterView and RegisterForm)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a component that will manage on the frontend, the register''s
    form with the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of that file will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding registration component is creating a form exactly the same way
    as on `LoginForm` . After a user clicks the `Register` button, it sends a callback
    to the `src/views/RegisterView.js` component (we will create this in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in the components' directory we keep only DUMB components so all
    the communication with the rest of the app must to be done via callbacks like
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: RegisterView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `RegisterView` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Its content is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: These are standard things that we use in our smart components (we need `falcorModel`
    in order to communicate with the backend and `mapStateToProps` and `mapDispatchToProps`
    in order to communicate with our Redux's store/reducer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that''s not all for the register view; next let''s add a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code snippet, we are missing the `register`
    function, so between the `constructor` and the `render` function add the function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `async register (newUserModel)` function is asynchronous
    and friendly to the awaits. Next we are just logging into the console what a user
    has submitted with `console.info("newUserModel", newUserModel)` . After that,
    we query the falcor-router with a call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have called the router, we fetch the response with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the response from the backend, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `INVALID` we are fetching and setting error message into the component''s
    state (`this.setState({error: errorRes}))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user has registered correctly, then we have their new ID and we are asking
    the user to login with the history's push state `(this.props.history.pushState(null,
    '/login');)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We didn''t create a route inside `routes/index.js` for `RegisterView` and there
    is no link in `CoreLayout` so our user is unable to use it. Add new imports in
    `routes/index.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a route, so the export default from `routes/index.js` will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, add a link inside the `src/layoutsCoreLayout.js` file''s `render`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point ,we should be able to register with this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will start working on the server-side rendering of our
    app. This means that on each request to our Express's server, we will generate
    the HTML markup based on the request from the client side. That feature is very
    useful for apps like ours where the speed of web loading is very important for
    such users as ours.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that most of the news sites are for entertainment and that means
    a short attention span from our potential users. The speed of loading is important.
    There are also some opinions that the server-side rendering also helps for search
    engine optimization reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The crawlers have easier ways to *read* the text from our article as they don't
    need to execute the JavaScript in order to fetch it from the server (in comparison
    to non-server-side rendering single-page apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'At least one thing is certain: if you have a server-side rendering on your
    articles'' publishing app then Google may see that you care about the fast loading
    of your app and so it will probably give you some disadvantage over full single-page
    websites that don''t care about server-side rendering.'
  prefs: []
  type: TYPE_NORMAL

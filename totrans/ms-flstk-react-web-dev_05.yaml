- en: Falcor Advanced Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our app has the ability to add, edit, and delete articles, but only
    on the frontend with the help of Redux's reducers. We need to add some full-stack
    mechanism to make this able to perform CRUD operations on the database. We will
    also need to add some security features on the backend so non-authenticated users
    won't be able to perform CRUD operations on the MongoDB collections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pause coding for a moment. Before we start developing the full-stack Falcor
    mechanism, let's discuss our React, Node, and Falcor setup in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to understand why we have chosen Falcor in our technical stack.
    In general, at the custom software development company where I work (you can find
    more at [www.ReactPoland.com](http://www.ReactPoland.com) ), we use Falcor as
    it has many great advantages for our clients in terms of the productivity of developing
    full-stack mobile/web applications. Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A speedup of over by 30 percent in development in comparison to a RESTful approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shallow learning curve, so a developer who learns Falcor can become effective
    very quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effective way of fetching data (from backend to the client side) that is
    quite astounding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will keep these four points short and sweet, for now. Later in the chapter,
    you will learn more about problems that you may face when using Falcor and Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we have assembled a kind of full-stack starter kit with React, Redux,
    Falcor, Node, Express, and MongoDB. It''s not perfect yet. We will make it our
    focus for this chapter, which will include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Better understanding the big picture of *RESTless data fetching* solutions and
    the similarities and differences between Falcor and Relay/GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to secure routes in order to authenticate users on the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle errors on the backend and send them seamlessly to the frontend
    with the help of errorSelectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed look at Falcor's sentinels and how exactly `$ref` , `$atom` , and
    `$error` work in Falcor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a JSON graph is and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the virtual JSON concept is in Falcor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem that Falcor aims to solve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the era of single-page applications, there weren't problems with fetching
    data on the client, as all of the data was always fetched on the server, and even
    then, the server would send the HTML markup to the client. Each time someone clicked
    on a URL (`href` ), our browser requested totally new HTML markup from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the preceding principles of non-SPA applications, Ruby on Rails became
    the king of web development's technical stack, but later things changed. Since
    2009-2010, we've been creating more and more JavaScript client applications, which
    are more likely fetched once from the backend as, for example, a `bundle.js` file.
    They're called SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this SP Apps trend, some new problems emerged that weren't known
    to non-SP Apps developers, such as fetching data from the API endpoint on the
    backend in order to consume that JSON data on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the old-fashioned workflow for RESTful applications was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create endpoints on the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the fetching mechanism on the frontend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch data from the backend by coding POST/GET requests on the frontend based
    on the API's specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you fetch the JSON from the backend to the frontend, you can consume the
    data and use it in order to create the UI view based on a certain use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process is kind of frustrating if someone such as a client or boss changes
    their mind, because you were implementing the entire code on the backend and frontend.
    Later the backend API endpoints become irrelevant, so you need to start working
    on them from scratch based on the changed requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual JSON - one model everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Falcor, one model everywhere is the main tagline of this great library.
    In general, the main purpose of using it is to create a single JSON model that
    is exactly the same on the frontend and backend. What does this mean for us? It
    means that if anything changes, we need to change the model, which is exactly
    the same on the backend and frontend--so in case of any changes, we need to tweak
    our model without worrying about how the data is provided on the backend and fetched
    on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Falcor''s innovation is to introduce a new concept called virtual JSON (analogical
    to virtual DOM for React). This lets you represent all your remote data sources
    (for example, MongoDB in our case) as a single domain model. The whole idea is
    that you code the same way without caring where your data is: is it on the client-side
    memory cache or on the server? You don''t need to care, as Falcor, with its innovative
    approach, does a lot of the job (for example, querying with `xhr` requests) for
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching is a problem for developers. Falcor is here to help to make it
    simpler. You can fetch data from the backend to the frontend, writing fewer lines
    of code than ever!
  prefs: []
  type: TYPE_NORMAL
- en: It's May 2016, and the only viable competitors that I see on the horizon are
    the Facebook libraries called Relay (on the client side) and GraphQL (on the backend).
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to compare both.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falcor versus Relay/GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any tool, there are always pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: For certain, Falcor is always better than Relay/GraphQL in small/mid-sized projects,
    at least unless you have master developers (or you are a master yourself) who
    know Relay/GraphQL very well. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: In general, Relay (for the frontend) and GrapQL (for the backend) are two different
    tools and you must be efficient in order to use properly.
  prefs: []
  type: TYPE_NORMAL
- en: Very often in commercial environments, you don't have too much time to learn
    things from scratch. This is also a reason behind the success of React.
  prefs: []
  type: TYPE_NORMAL
- en: Why has React succeeded? React is much easier to grasp in order to be an efficient
    frontend developer. A CTO or technical director hires a newbie developer who knows
    jQuery (for example), and then the CTO can easily project that this junior developer
    will be effective in React in 7 to 14 days; I was teaching junior frontend developers
    with basic knowledge of JavaScript/jQuery, and I found out that they quite quickly
    become efficient in creating client-side apps with React.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the same situation with Falcor. Falcor, in comparison to Relay +
    GraphQL, is like the simplicity of React compared to the monolithic framework
    of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: This single factor described in the previous few paragraphs means that Falcor
    is better for small/mid-size projects with a limited budget.
  prefs: []
  type: TYPE_NORMAL
- en: You may find some opportunities to learn Relay/GraphQL in bigger companies with
    much bigger budgets, such as Facebook, when you have 6 months to master a technology.
  prefs: []
  type: TYPE_NORMAL
- en: FalcorJS can be mastered effectively in two weeks, but GraphQL + Relay cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Big-picture similarities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both these tools are trying to solve the same problem. They are efficient by
    design for both developers and the network (trying to optimize the number of queries
    in comparison to a RESTful approach).
  prefs: []
  type: TYPE_NORMAL
- en: They have the ability to query the backend server in order to fetch data and
    also have batching ability (so you can fetch more than two different sets of data
    with one network request). Both have some caching abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Technical differences - overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a technical overview, we can find out that in general, Relay allows you
    to query an undefined number of items from the GraphQL server. In Falcor, for
    comparison, you need to first ask the backend how many items it has before being
    able to query for the collection objects' details (such as articles, in our book's
    case).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the biggest difference here is that GraphQL/Relay is a query language
    tool and Falcor is not. What is a query language? It''s one with which you can
    make queries from the frontend similar to SQL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be made a query from the frontend via `Relay.QL` , and
    then GraphQL processes the query in the same way as SQL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Things may get harder if there are, for example, a million articles in the DB
    and you didn't expect so many on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Falcor, you do it differently, as you''ve already learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding Falcor example, you must first know how many records there
    are in the MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of most important differences and creates some challenges for both
    sides.
  prefs: []
  type: TYPE_NORMAL
- en: For GraphQL and Relay, the question is whether the power of those query languages
    is worth the complexity created in the learning curve, because that complexity
    may not be worth it for small/mid-sized projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the basic differences have been discussed, let's focus on Falcor and
    improving our current publishing app.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our application and making it more reliable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to improve things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: After a login, we shall send user details in each request (the token, username,
    and a role; you can find a screenshot later in the section *Improving our Falcor
    code on the frontend* )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backend needs to be secured so that authorization is checked before running
    add/edit/delete operations on the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to provide the ability to catch errors on the backend and give a notification
    to the user on the frontend about something not working correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the auth required routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our app has the ability to add/edit/delete a route. The problem with
    our current implementation is that we don't check whether a client making a CRUD
    operation has the privileges to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The solution of securing Falcor routes requires some changes to our current
    implementation, so for each request, before performing the operation, we will
    check whether we have got the correct token from the client and whether the user
    making the call has the ability to edit (in our case, it means that if anyone
    has an editor role and is authenticated correctly with his username and password,
    then he can add/edit/delete an article).
  prefs: []
  type: TYPE_NORMAL
- en: JSON Graph and JSON envelopes in Falcor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Falcor documentation states, "JSON Graph is a convention for modeling
    graph information as a JSON object. Applications that use Falcor represent all
    their domain data as a single JSON Graph object."
  prefs: []
  type: TYPE_NORMAL
- en: In general, JSON Graph in Falcor is valid JSON with some new features. To be
    more precise, JSON Graph introduces a new types of data besides strings, numbers,
    and Booleans. The new data type in Falcor is called a **sentinel** . I will try
    to explain it later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the second most important thing to understand in Falcor are JSON
    envelopes. The great thing is that they work out of the box, so you don't have
    to worry too much about them. But if you want to know what the short and sweet
    answer is, JSON envelopes help send JSON's model via HTTP's protocol. It's a way
    of transferring data from frontend to backend (with the `.call` , `.set` , and
    `.get` methods). In the same way, before the backend (after processing a request's
    details), before sending the improved model's details to the client side, Falcor
    puts it into an *envelope* so that it can be easily transferred via a network.
  prefs: []
  type: TYPE_NORMAL
- en: A good (but not perfect) analogy for JSON envelopes is that you put a written
    list into an envelope because you don't want to send some valuable information
    over from point *A* to point *B* ; the network doesn't care what you send in that
    envelope. The most important thing is that the sender and the receiver know the
    context of the application model.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the JSON Graph and envelopes at [http://netflix.github.io/falcor/documentation/jsongraph.html](http://netflix.github.io/falcor/documentation/jsongraph.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Falcor code on the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, after a user authorizes himself, all the data is saved into local
    storage. We need to close the loop by sending that data--token, username, and
    role--back to the backend with each request so we can check again whether a user
    is authenticated correctly. If not, then we need to send an authentication error
    with the request and show it back on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrangement in the following screenshot is specifically important for security
    reasons so that no unauthorized user can add/edit/delete an article in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the screenshot, you can find out where you can get information about the
    `localStorage` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our current code in `src/falcorModel.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change this to a new, improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What have we done in the previous code snippet? The `extends` keyword from ECMAScript6
    shows an example of where the simplicity of the class syntax shines. Extending
    the `FalcorDataSource` means that `PublishingAppDataSource` inherits everything
    that the `FalcorDataSource` has and it makes the `onBeforeRequest` method have
    our custom behavior (by mutating `config.headers` ). The `onBeforeRequest` method
    is checking the configuration mutated by us before our `xhr` instance is created.
    This helps us modify the `XMLHttpRequest` with a token, username, and role--in
    case our app's user logs out in the meantime, we can send that information to
    the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you implement the previous code in `falcorModel.js` and a user is logged,
    those variables will be added to each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving server.js and routes.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, we currently export an array of objects from the `server/routes.js`
    file. We need to improve it, so we will return a function that will modify our
    array of objects so we have control over which route is returned to which user,
    and in case a user does not have a valid token or enough privileges, we will return
    an error. This will improve the security of our whole app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server/server.js` file, find this old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this improved one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our new version, we assume that the `routes` variable is a function with
    the `req` and `res` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve the routes itself so we won't return an array anymore, but a function
    that returns an array (so we end up with more flexibility).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to improve the `server/routes.js` file in order to make a
    function that receives the `currentSession` object, which stores all the information
    about a request. We need to change this in `routes.js` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of exporting an array of routes, we need to export a function that will
    return routes based on a current request's header details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top part of the `server/routes.js` file (with imports) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow this by exporting a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we receive the `req` (request details) and `res` (object that
    represents the HTTP response) variables into the arrow functions. Based on the
    information provided by `req` , we get the header details (`let { token, role,
    username } = req.headers;` ). Next, we have `userDetailsToHash` and then we check
    what will be the correct `authToken` with `let authSignToken = jwt.sign(userDetailsToHash,
    jwtSecret.secret)` . Afterward, we check whether the user is authorized with `let
    isAuthorized = authSign === token` . Then we create a `sessionObject` , which
    will be reused across all the Falcor routes later (`let sessionObject = {isAuthorized,
    role, username};` ).
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have one route (`articles.length` ), which was described in [Chapter
    2](text00058.html) , *Full-Stack Login and Registration for Our Publishing App*
    (so there's nothing new so far).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous code, instead of exporting `PublishingAppRoutes`
    directly, we are exporting with the arrow function `export default (req, res)`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to re-add (under `articles.length` ) the second route, called `articles[{integers}]["_id","articleTitle","articleContent"]`
    , with the following code in the `server/routes` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the route that fetches articles from databases and returns `falcor-route`
    for it. It's exactly the same as introduced before; the only different is that
    now it's part of the function (`export default ( req, res ) => { ... }` ).
  prefs: []
  type: TYPE_NORMAL
- en: Before we start to implement add/edit/delete on the backend with `falcor-router`
    , we need to introduce ourselves to the concept of sentinels, as it will be very
    important for the well-being of our full-stack application, the reason for which
    will be explained in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Falcor's sentinel implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand what sentinels are. They are required to make Fullstack's Falcor
    application work. It's a set of tools you have to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are new primitive value types created exclusively for making data transportation
    between the backend and client side much easier and out of the box (examples of
    new Falcor primitive values are `$error` and `$ref` ). Here''s an analogy: you
    have types in a regular JSON such as string, number, and object and. On the other
    hand, in Falcor''s virtual JSON, you can additionally use sentinels such as `$error`
    , `$ref` , or `$atom` alongside the standard JSON types listed previously.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional information about sentinels is available at [https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata](https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata)
    .
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it's important to understand how Falcor's sentinels are working.
    The different types of sentinel in Falcor are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The $ref sentinel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the documentation, "a reference is a JSON object with a `$type`
    key that has a value of `ref` and a `value` key that has a `Path` array as its
    value."
  prefs: []
  type: TYPE_NORMAL
- en: '"A reference is like a symbolic link in the UNIX filesystem," as the documentation
    states, and this comparison is very good.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `$ref` is as a follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you use `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])` , it's equal to
    the preceding example. The `$ref` sentinel is a function that changes the array's
    details into that `$type` and value's notation object.
  prefs: []
  type: TYPE_NORMAL
- en: You can find both approaches in order to deploy/use `$ref` in any Falcor-related
    project, but in our project, we will stick to the `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make it clear, this is how to import a `$ref` sentinel in our codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After you import `falcor-json-graph` , you can use the `$ref` sentinel. You
    will already have installed the `falcor-json-graph` library as the installation
    has been described in the previous chapter; if not, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But what does `articlesById` mean in that whole `$ref` gig? And what does `STRING_ARTICLE_ID_HERE`
    mean in the preceding example? Let's look at an example from our project that
    might make it clearer for you.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed example of the $ref sentinel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have two articles in our MongoDB instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So based on our array''s example with mocked articles (IDs `987654` and `123456`
    ), the `$ref` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An even more detailed answer is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that `articlesById` is a new route that hasn't
    been created yet (we will do so in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: But why do we need those `$ref` in our articles?
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can keep a reference (like a symbolic link in Unix) in many
    places to one object in the database. In our case, it's an article with a certain`_id`
    in the article's collection.
  prefs: []
  type: TYPE_NORMAL
- en: When do `$ref` sentinels come in handy? Imagine that in our publishing app's
    model, we add a *recently visited* articles feature and provide the ability to
    like an article (like on Facebook).
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these two new features, our new model will look as follows (this is
    just an example; don''t code it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Based on our preceding example's model, if someone likes an article with ID
    `123456` , we will need to update the model in two places. That's exactly where
    `$ref` comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving our articles' numberOfLikes with $ref
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s improve our example to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In our new improved `$ref` example, you can find the notation where you need
    to tell Falcor the ID of the article you want to have in `articles` or `recentlyVisitedArticles`
    . Falcor on its own will follow the `$ref` sentinel, knowing the route name (the
    `articlesById` route in this case) and ID of the object we are looking for (in
    our example, `123456` or `987654` ). We will use it in practice in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Understand that this is a simplified version of how it works, but the best analogy
    to use in order to understand `$ref` is UNIX's symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: Practical use of $ref in our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, that was a lot of theory--let's start coding! We will improve our Mongoose
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we''ll add the `$ref` sentinels described before into the `server/routes.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will also add two Falcor routes, `articlesById` and `articles.add` . On the
    frontend, we will make some improvements to `src/layouts/PublishingApp.js` and
    `src/views/articles/AddArticleView.js` .
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the fun.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose config improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First thing we will do is open the Mongoose model at `server/configMongoose.js`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll improve it to this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you''ll find we import `new const Schema = mongoose.Schema`
    . Later, we improve our `articleSchema` with `articleContentJSON: Object` . This
    is required, because the state of draft-js will be kept in a JSON object. This
    will be useful if a user creates an article, saves it to the database, and later
    would like to edit the article. In such a case, we''ll use this `articleContentJSON`
    in order to restore the content state of the draft-js editor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing is providing options with `{ minimize: false }` . This is
    required because by default Mongoose gets rid of all empty objects, such as `{
    emptyObject: {}, nonEmptyObject: { test: true } }` , so if `minimize: false` isn''t
    set up then we would get incomplete objects in our database (it''s a very important
    step to have this flag here). There are some draft-js objects that are required,
    but by default are empty (specifically the `entityMap` property of a draft-js
    object).'
  prefs: []
  type: TYPE_NORMAL
- en: The server/routes.js improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `server/routes.js` file, we need to start using the `$ref` sentinel.
    Your import in that file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the only new thing is that we import `jsonGraph`
    from `'falcor-json-graph';` and then add `let $ref = jsonGraph.ref;` and `let`
    `$atom = jsonGraph.atom` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added the `$ref` sentinel in our `routes.js` scope. We need to prepare
    a new route, `articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]`
    , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `articlesById[{keys}]` route is defined, and the keys are the IDs of the
    request URL that we need to return in the request, as you can see with `const
    articlesIDs = pathSet[1];` .
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more specific regarding `pathSet` , check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `falcor-router` will follow `articlesById` , and in the `pathSet`
    , you will get this (you can see the exact value of the `pathSet` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `articlesIDs` from `const articlesIDs = pathSet[1]` `;` you
    can find here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will find later, we use this `articlesIDs` value next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in `''_id'': { $in: articlesIDs}` , we are passing an array
    of `articlesIDs` . Based on those IDs, we will receive an array of certain articles
    found by IDs (the SQL `WHERE` equivalent). The next step here is iterating over
    received articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the object into the `results` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost nothing is new in the preceding code snippet. The only new thing is
    this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are explicitly using the `$atom` sentinel from Falcor here: `$atom(articleResObj.articleContentJSON);`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Graph atoms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$atom` sentinel is metadata attached to values, which has to be handled
    differently by the model. You can very simply return a value of a number type
    or a value of a string type with Falcor. It's more tricky for Falcor to return
    an object. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Falcor is diffing with heavy usage of JavaScript's objects and arrays, and when
    we tell that an object/array is wrapped by an `$atom` sentinel (such as `$atom(articleResObj.articleContentJSON`
    ) in our example), then Falcor knows that it shouldn't go deeper into that array/object.
    It's made that way by design for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'What performance reasons? For example, if you return an array of 10,000 very
    deep objects without wrapping the array, it may take a very, very long time to
    build and diff the model. Generally, for performance reasons, any objects and
    arrays that you want to return via `falcor-router` to the frontend have to be
    wrapped by an `$atom` before doing so; otherwise, you will get an error like this
    (if you don''t wrap by `$atom` this object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This error will be shown on the client side while Falcor tries to fetch those
    deeper objects without being wrapped by an `$atom` sentinel beforehand on the
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the articles[{integers}] route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to return a `$ref` sentinel to `articlesById` instead of all of
    the articles'' details, so we need to change this old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll improve that to this new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'What has been changed? Look at the route in the old codebase: `articles[{integers}]["_id","articleTitle","articleContent"]`
    . Currently, our `articles[{integers}]` route doesn''t directly return (in the
    new version) the `for["_id","articleTitle","articleContent"]` data, so we had
    to delete it in order to get Falcor know about this fact (the `articlesById` is
    returning detailed information now).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that has been changed is that we create a new `$ref` sentinel
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you see, by doing this, we are informing (with `$ref` ) `falcor-router` that
    if the frontend requests any more information about `article[{integers}]` , then
    the `falcor-router` should follow the `articlesById` route in order to retrieve
    that data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, look at this old path''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll find that it has been replaced by the value of `articleRef` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably spot, in the old version we were returning all of the information
    about an article (the `singleArticleObject` variable), but in the new version
    we return only the `$ref` sentinel`(articleRef)` .
  prefs: []
  type: TYPE_NORMAL
- en: The `$ref` sentinels make `falcor-router` automatically follow on the backend,
    so if there are any refs in the first route, Falcor resolves all the `$ref` sentinels
    until it gets all the pending data; after that, it returns the data in a single
    request, which saves a lot of latency (instead of performing several HTTP requests,
    everything followed with `$refs` is fetched in one browser-to-backend call).
  prefs: []
  type: TYPE_NORMAL
- en: 'New route in server/routes.js: articles.add'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only thing left that we need to do is add into the router a new `articles.add`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we receive from the frontend a new article''s details
    with `const newArticleObj = args[0];` , and later we create a new `Article` model
    with `var article = new Article(newArticleObj);` . After that, the `article` variable
    has a `.save` method, which is called in the following query. We perform two queries
    that return a promise from Mongoose. Here''s the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This `.save` method simply helps us insert the document into the database.
    After we have saved the article, we need to count how many there are in our database,
    so we run a second query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have saved the article and counted it, we return that information
    (`return { count, data };` ). The last thing is to return the new article ID and
    the count number from the backend to the frontend with the help of `falcor-router`
    , so we replace this comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In its place, we''ll have this new code that helps us make things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we get the `newArticleDetail`
    details here. Next, we take the new ID with `newArticleID` and make sure that
    it's a string. After all that, we define a new `$ref` sentinel with `let NewArticleRef
    = $ref(['articlesById', newArticleID]);` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `results` variable, you can find three new paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path: [''articles'', res.count-1]` : This path builds up the model, so we
    can have all the information in the Falcor model after we receive the response
    on the client side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path: [''articles'', ''newArticleID'']` : This helps us quickly fetch the
    new ID on the frontend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path: [''articles'', ''length'']` : This, of course, updates the length of
    our articles'' collections, so the frontend''s Falcor model can have up-to-date
    information after we have added a new article'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just have made a backend route for adding an article. Let's now start working
    on the frontend so that we will be able to push all our new articles into the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend changes in order to add articles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/layouts/PublishingApp.js` file, find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to an improved version with `articleContentJSON` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to improve our `_submitArticle` function in `src/views/articles/AddArticleView.js`
    and add a `falcorModel` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this code with the following improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, at the top of the `AddArticleView.js` file, add this import; otherwise,
    `async_articleSumbit` won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have added the `async` keyword before the function name
    (`async _articleSubmit()` ). The new thing is this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we wait for `falcorModel.call` . In the `.call` arguments, we add `newArticle`
    . Then, after the promise is resolved, we check what the `newArticleID` is with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, we simply use exactly the same stuff as in the old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This simply pushes the updated `newArticle` with a real ID from MongoDB via
    the `articleActions` into the article's reducer. We also use `setState` with the
    `newArticleID` so you can see that the new article has been created correctly
    with a real Mongo ID.
  prefs: []
  type: TYPE_NORMAL
- en: Important note about route returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should be aware that in every route, we return an object or an array of
    an object; both approaches are fine even with one route to return. Take this,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also return an array with one object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even with one `articles.length` , we are returning an array
    (instead of a single object), and this will also work.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason as described previously, this is why, in `articlesById`
    , we have pushed multiple routes into the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is one thing that may be worth mentioning in the Falcor chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack - editing and deleting an article
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a route in the `server/routes.js` file for updating an existing
    document (edit feature):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we still use the `article.save` approach similar to the
    `articles.add` route. The important thing to note is that Mongoose requires the
    `isNew` flag to be `false` (`article.isNew = false;` ). If you don''t give this
    flag, then you will get a Mongoose error similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is quite simple; we save the article''s model and then
    return the updated model via `falcor-router` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The new thing is the `invalidate` flag. As it states in the documentation, "invalidate
    method synchronously removes several Paths or PathSets from a Model cache." In
    other words, you need to tell the Falcor model on the frontend that something
    has been changed in the `["articlesById", articleID]` path so that you will have
    synced data on both backend and frontend.
  prefs: []
  type: TYPE_NORMAL
- en: For more stuff about `invalidate` in Falcor, you can go to [https://netflix.github.io/falcor/doc/Model.html#invalidate](https://netflix.github.io/falcor/doc/Model.html#invalidate)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an article
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to implement the `delete` feature, we need to create a new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This also uses `invalidate` , but this time, this is the only thing that we
    return here, as the document has been deleted, so the only thing we need to do
    is to inform the browser's cache that the old article has been invalidated and
    there is nothing to replace it as in the update example.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend - edit and delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have implemented the `update` and `delete` routes on the backend. Next,
    in the `src/views/articles/EditArticleView.js` file, you need to find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this `async _articleEditSubmit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the most important thing is that we implemented the `.call`
    function in the `_articleEditSubmit` function that sends details of an edited
    object with the `editedArticle` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, find the `_handleDeletion` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the new improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the deletion, the only difference is that we only send `articleID`
    of a deleted article with `.call` .
  prefs: []
  type: TYPE_NORMAL
- en: Securing the CRUD routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to implement a way to secure all add/edit/delete routes and also make
    a universal **DRY** (**don''t repeat yourself** ) way of informing the user of
    errors that occurred on the backend. For example, errors that may occur on the
    frontend, and we need to inform the user with an error message in our React instance''s
    client-side app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auth error** : You are not authorized to perform the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout error** : For example, you use an external API''s service; we need
    to inform the user of any potential errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data doesn''t exist** : There may be a case where a user will call for the
    ID of an article that doesn''t exist in our DB, so let''s inform him'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, our goal for now is to create one universal way of moving all potential
    error messages on the backend to the client side so that we can improve the general
    experience of using our application.
  prefs: []
  type: TYPE_NORMAL
- en: The $error sentinel basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is the `$error` sentinel (variable type related to Falcor), which is generally
    an approach to returning errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, as you should already know, Falcor batches requests. Thanks to them,
    you can fetch data from different falcor-routes in one HTTP request. The following
    example is what you can fetch in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One dataset** : Complete and ready to retrieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second dataset** : Second dataset, may contain an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't want to influence the fetching process of one dataset when there is
    an error in the second dataset (you need to remember that the two datasets from
    our example are fetched in one request).
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful parts from the documentation that may help you understand error handling
    in Falcor are available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://netflix.github.io/falcor/doc/Model.html#~errorSelector](https://netflix.github.io/falcor/doc/Model.html#~errorSelector)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://netflix.github.io/falcor/documentation/model.html#error-handling](https://netflix.github.io/falcor/documentation/model.html#error-handling)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://netflix.github.io/falcor/documentation/router.html](http://netflix.github.io/falcor/documentation/router.html)
    (search for `$error` on this page to find more examples from the documentation)'
  prefs: []
  type: TYPE_NORMAL
- en: DRY error management on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with improvements to the CoreLayout (`src/layouts/CoreLayout.js`
    ). Under `AppBar` , import a new `snackbar` component with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, under the imports, outside the CoreLayout, create a new function and
    export it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then find the `CoreLayout` constructor to change it to use the exported function
    called `errorFuncUtil` as a callback in the base in case of an error returned
    by the Falcor `$error` sentinel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can find here, we have introduced a new `errorValue` state (the default
    state is `null` ). Then, on the frontend only (because of `if(typeof window !==
    'undefined')` ), we assign `this.handleErrors.bind(this)` to our `errorFuncUtil`
    .
  prefs: []
  type: TYPE_NORMAL
- en: As you will find in a moment, this is so because the exported `errorFuncUtil`
    will be imported in our `falcorModel.js` , where we will use the best possible
    DRY way to inform our CoreLayout about any error occurring on the backend with
    Falcor. The great thing about this is that we will implement it just once, but
    it will be a universal way of informing our client-side app users of any errors
    (and it will also save us development effort in the future, as any error will
    be handled by the approach that we are implementing now).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a new function to our CoreLayout called `handleFalcorErrors`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `handleFalcorErrors` function is setting the new state of our error. We
    will compose our error for the user with an `errMsg` (we create this on the backend,
    as you will learn in a moment) and the `errPath` (optional, but this is the `falcor-route`
    path where the error has occurred).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we have everything in place; the only thing missing from the `CoreLayout`
    function is the improved render. The new render of the CoreLayout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can find here, the new parts are related to the Material-UI `snackbar`
    component. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet is preparing our `erroSnackbarJSX` and the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Make sure `{errorSnackbarJSX}` is placed exactly the same way as in this example.
    Otherwise, you may find some problems during the app's test run. You now have
    completed everything related to the CoreLayout improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaks - FalcorModel.js on the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/falcorModel.js` file, identify the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has to be improved by adding a new option to the `falcor.Model` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we added is an import of `errorFunc` to the top of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Besides `errorFunc` , we have introduced the `falcorOptions` variable. The source
    stays the same as in the previous version. We have added `errorSelector` , which
    is run every time the client side calls the backend and the `falcor-router` on
    the backend returns an `$error` sentinel.
  prefs: []
  type: TYPE_NORMAL
- en: More details on the error selector can be found at [https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value](https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Backend implementation of the $error sentinel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will perform the backend implementation in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: An error example, just to test our client-side code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we are sure that the error handling is working correctly, we will secure
    the endpoints properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing our $error-related code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with imports in the `server/routes.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing is that you need to import the `$error` sentinel from `falcor-json-graph`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The goal of our `$error` test is to replace a working route that is responsible
    for fetching articles `(articles[{integers}])` . After we break this route, we
    will be able to test whether our frontend and backend setup is working. After
    we test the errors (refer to the next screenshot), we will delete this breaking
    `$error` code from `articles[{integers}]` . Read on for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test it with the `article` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is only a test. We will improve this code in a moment,
    but let's test whether the text in the `$error('auth error')` sentinel will be
    shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the server in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run both these, point your browser to `http://localhost:3000` , and
    you will see for this error for 8 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is white text on a black background in the bottom of
    the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you run the app, and on the main page you see the error message as on the
    screenshot, then it tells you that you are good!
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up $error after a successful test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you are sure that the error handling is working for you, you can replace
    the old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following, without error returning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now, the app will start working normally without throwing an error when you
    try to fetch an article from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the routes' security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already implemented some logic in `server/routes.js` that checks whether
    a user is authorized, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you will find that we can create the following logic in the beginning
    of each role that requires authorization and the editor role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, this is only an example (don't change it yet; we will implement
    it in a moment), with `path['HERE_GOES_THE_REAL_FALCOR_PATH']` .
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check whether a user is authorized at all with `isAuthorized ===
    false` ; if not authorized, he will see an error (with the universal error mechanism
    that we just implemented):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In future, we may have more roles in our publishing app, so in case someone
    isn''t an editor, then he will see the following in the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What routes to secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For routes (`server/routes.js` ) that require authorization in our application''s
    articles, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code with `auth` checks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can find here, we have added two checks with `isAuthorized === false`
    and role `!== 'editor'` . The following routes content will be almost the same
    (just the path changes a little).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `articles` update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code with the `auth` checks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Find this old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with this new code with the `auth` checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the returns are almost the same--we can lower the code duplication.
    We can make a helper function for them so there will be less code, but you need
    to remember that you need to set a path similar to the one that you request when
    returning an error. For example, if you are on `articles.update` , then you need
    return an error in the article's path (or if you are on `XYZ.update` , then the
    error goes to the `XYZ` path).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement AWS S3 in order to have the ability to
    upload articles' cover photos. Besides that, we will generally improve our publishing
    application with new features.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

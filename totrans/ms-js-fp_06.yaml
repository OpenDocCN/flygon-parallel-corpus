- en: Producing Functions - Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we worked with some predefined higher-order functions and were
    able to see how their usage let us write declarative code, gaining in understandability
    as well as in compactness. In this new chapter, we are going to go further in
    the direction of higher-order functions, and we are going to develop our own.
    We can roughly classify the kinds of functions that we are going into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrapped functions**, that keep their original functionality, adding some
    kind of new feature. In this group, we can consider *logging* (adding log production
    capacity to any function), *timing* (producing time and performance data for a
    given function), and *memoization* (that caches results to avoid future re-work).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Altered functions**, that differ in some key point with their original versions.
    Here we can include the `once()` function (we wrote it in [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*) that changes the original function
    to run only once, functions such as `not()` or `invert()` that alter what the
    function would return, and arity-related conversions that produce a new function
    with a fixed number of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other productions**, that provide for new operations, turn functions into
    promises, provide enhanced search functions, or allow decoupling a method from
    objects, so we can use them in other contexts as if they were common functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's consider some higher-order functions that provide a *wrapper*
    around other function, to enhance it in some way, but without altering its original
    objective. In terms of d*esign patterns* (which we'll be revisiting in [Chapter
    11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml), *Implementing Design Patterns
    - The Functional Way*), we could also speak of *decorators*. This pattern is based
    on the concept of adding some behavior to an object (in our case, a function)
    without affecting other objects. The term *decorator* is also popular because
    of its usage in frameworks such as Angular, or (in an experimental mode) for general
    programming in JS.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are being considered for general adoption in JS, but are currently
    (August 2017) at Stage 2, *Draft* level, and it may be a while until they get
    to Stage 3 (*Candidate*) and finally Stage 4 (*Finished*, meaning officially adopted).
    You can read more about decorators for JS at [https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)
    and about the JS adoption process itself, called TC39, in [https://tc39.github.io/process-document/](https://tc39.github.io/process-document/).
    See the *Questions* section in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the term *wrapper*, it''s more important and pervasive that you might
    have thought; in fact, JavaScript uses it widely. Where? You already know that
    object properties and methods are accessed through dot notation. However, you
    also know that you can write code such as `myString.length` or `22.9.toPrecision(5)`
    -- where are those properties and methods coming from, given that neither strings
    nor numbers are objects? JavaScript actually creates a *wrapper object* around
    your primitive value. This object inherits all the methods appropriate to the
    wrapped value. As soon as the needed evaluation has been done, JavaScript throws
    away the just-created wrapper. We cannot do anything about these transient wrappers,
    but there is a concept we will come back to: a wrapper allows methods to be called
    on things that are not of the appropriate type -- and that''s an interesting idea;
    see [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better
    Containers - Functional Data Types*, for more applications of that!'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a common problem. When debugging code, you usually need to
    add some kind of logging information, to see if a function was called, with what
    arguments, and what it returned, and so on. (Yes, of course, you can simply use
    a debugger and set breakpoints, but bear with me for this example!) Working normally,
    that means that you''ll have to modify the code of the function itself, both at
    entry and on exit. You''ll have to code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'to something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the function can return at several places, you'll have to modify all the
    `return` statements, to log the values that are to be returned. Of course, if
    you are just calculating the return expression on the fly, you'll need an auxiliar
    variable to capture that value.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in a functional way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doing this is not difficult but modifying code is always dangerous and prone
    to "accidents". So, let's put our FP hats on, and think of a new way of doing
    this. We have a function that performs some kind of work and we want to know the
    arguments it receives and the value it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a higher-order function that will have a single parameter, the
    original function, and return a new function that will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log the received arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the original function, catching its returned value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log that value; and finally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible solution would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returned by `addLogging()` behaves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `console.log()` line shows the original function's name and its list
    of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the original function `fn()` is called, and the returned value is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `console.log()` line shows the function name (again) and its returned
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the value that `fn()` calculated, was returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you were doing this for a Node.js application, you would probably opt for
    a better way of logging, by using libraries such as Winston, Morgan, or Bunyan
    -- but our focus is in showing how to wrap the original function, and the needed
    changes for using those libraries would be small.
  prefs: []
  type: TYPE_NORMAL
- en: For an example, we can use it with an upcoming functions -- which are written,
    I agree, in an overtly complicated way, just to have an appropriate example!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of executing the last line would be the production of the following
    lines of logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All the changes we had to do in our code were the reassignments of `subtract()`
    and `changeSign()`, which essentially replaced them everywhere with their new
    log-producing wrapped versions. Any call to those two functions will produce this
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see a possible error because of not reassigning the wrapped logging function
    in the *Memoizing* in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Taking exceptions into account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s enhance our logging function a bit, by considering a needed adjustment.
    What happens to your log if the function throws an error? Fortunately, that''s
    easy to solve. We just have to add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Other changes would be up to you -- adding date and time data, enhancing the
    way parameters are listed, and so on. However, our implementation still has an
    important defect; let's make it better.
  prefs: []
  type: TYPE_NORMAL
- en: Working in a more pure way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we wrote the `addLogging()` preceding function, we laid by the roadside
    some precepts we saw in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, because we included an impure element (`console.log()`)
    right in our code. With this, not only did we lose flexibility (would you be able
    to select an alternate way of logging?) but we also complicated our testing. We
    could, certainly, manage to test it by spying on the `console.log()` method, but
    that isn''t very clean: we depend on knowing the internals of the function we
    want to test, instead of doing a purely black box test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running this test shows that `addLogging()` behaves as expected, so this is
    a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even so, being able to test our function in this way doesn''t solve the lack
    of flexibility we mentioned. We should pay attention to what we wrote in section
    *Injecting impure functions*: the logging function should be passed as an argument
    to the wrapper function, so we can change it if we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t do anything, the logging wrapper will obviously produce the same
    results as in the previous section. However, we could provide a different logger
    -- for example, with Node.js, we could use *winston* and the results would vary
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: See [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)
    for more on the *winston* logging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have followed our own earlier advice, we can take advantage of
    stubs. The code for testing is practically the same as before but we are using
    a stub, `dummy.logger()`, with no provided functionality or side effects, so it''s
    safer all around. True: in this case, the real function that was being invoked
    originally, `console.log()`, could do no harm, but that''s not always the case,
    so using a stub is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When applying FP techniques, always keep in mind that if you are somehow complicating
    your own job --for example, making it difficult to test any of your functions--
    then you must be doing something wrong. In our case, the mere fact that the output
    of `addLogging()` was an impure function should have raised an alarm. Of course,
    given the simplicity of the code, in this particular case, you might decide that
    it's not worth a fix, that you can do without testing, and that you don't need
    to be able to change the way logging is produced. However, long experience in
    software development suggests that sooner or later you'll come to regret that
    sort of decision, so try to go with the cleaner solution instead.
  prefs: []
  type: TYPE_NORMAL
- en: Timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another possible application for wrapped functions is to record and log, in
    a fully transparent way, the timing of each function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan to optimize your code, remember the rules: *Don''t do it*, then
    *Don''t do it yet*, and finally *Don''t do it without measuring*. It has been
    often been mentioned that much bad code arises from early attempts at optimization,
    so don''t start by trying to write optimal code, don''t try to optimize until
    you recognize the need for it, and don''t do it haphazardly, without trying to
    determine the reasons for the slowdown by measuring all parts of your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Somehow, along the lines of the preceding example, we can write an `addTiming()`
    function that, given any function, will produce a wrapped version that will write
    out timing data on the console but will otherwise work in the same exact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that, along the lines of the enhancement we applied in the previous section
    to the logging function, we are providing separate logger and time access functions.
    Writing tests for our `addTiming()` function should prove easy, given that we
    can inject both impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using `performance.now()` provides the highest accuracy. If you don't need such
    precision as provided by that function (and it's arguable that it is overkill),
    you could simply substitute `Date.now()`. For more on these alternatives, see
    [https://developer.mozilla.org/en-US/docs/Web/API/Performance/now](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)
    and [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date/now).
    You could also consider using `console.time()` and `console.timeEnd()`; see [https://developer.mozilla.org/en-US/docs/Web/API/Console/time](https://developer.mozilla.org/en-US/docs/Web/API/Console/time).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be able to fully try out the logging functionality, I modified the
    `subtract()` function, so it would throw an error if you attempted to subtract
    zero. You could also list the input parameters, if desired, for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code is quite similar to the previous `addLogging()` function, and that's
    reasonable - in both cases, we are adding some code before the actual function
    call, and then some new code after the function returns. You might even consider
    writing a *higher*-higher-order function, that would receive three functions,
    and would produce a higher-order function as output (such as `addLogging()` or
    `addTiming()`) that would call the first function at the beginning, and then the
    second function if the wrapped function returned a value, or the third function
    if an error had been thrown! What about it?
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*, we considered the case of the Fibonacci function and
    saw how we could transform it, by hand, into a much more efficient version by
    means of *memoization*: caching calculated values, to avoid recalculations. For
    simplicity, let''s now only consider functions with a single, non-structured parameter,
    and leave for later functions with more complex parameters (objects, arrays) or
    more than one parameter for later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kind of values we can handle with ease are JS''s primitive values: data
    that isn''t objects and has no methods. JS has six of these: `boolean`, `null`,
    `number`, `string`, `symbol`, and `undefined`. It''s likely we would only see
    the first four as actual arguments. See more in [https://developer.mozilla.org/en-US/docs/Glossary/Primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).'
  prefs: []
  type: TYPE_NORMAL
- en: Simple memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will work with the Fibonacci function we mentioned, which is a simple case:
    it receives a single numeric parameter. The function, as we saw it, was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution we did there was general in concept, but particularly in its implementation:
    we had to directly modify the code of the function in order to take advantage
    of said memoization. Now we should look into a way of doing it automatically,
    in the same fashion as with other wrapped functions. The solution would be a `memoize()`
    function that wraps any other function, to apply memoization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? The returned function, for any given argument, first checks
    whether the argument was already received; that is, whether it can be found as
    a key in the cache object. If so, there's no need for calculation, and the cached
    value is returned. Otherwise, we calculate the missing value and store it in the
    cache. (We are using a closure to hide the cache from external access.) We are
    assuming here that the memoized function receives only one argument (`x`) and
    that it is a primitive value, which can then be directly used as a key value for
    the cache object; we'll consider other cases later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this working? We''ll have to time it -- and we happen to have a useful `addTiming()`
    function for that! First, we take some timings for the original `fib()` function.
    We want to time the complete calculation and not each individual recursive call,
    so we write an auxiliar `testFib()` function and that''s the one we''ll time.
    We should repeat the timing operations and do an average but, since we just want
    to confirm that memoizing works, we''ll tolerate differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Your times may vary, of course, but the results seem logical: the exponential
    growth we mentioned in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, appears to be present, and times grow quickly.
    Now, let''s memoize `fib()`, and we should get shorter times -- or shouldn''t
    we?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Something's wrong! The times should have gone down--but they are just about
    the same. This is because of a common error, which I've even seen in some articles
    and web pages. We are timing `memofib()` -- but nobody calls that function, except
    for timing, and that only happens once! Internally, all recursive calls are to
    `fib()`, which isn't memoized. If we called `testMemoFib(45)` again, *that* call
    would be cached, and it would return almost immediately, but that optimization
    doesn't apply to the internal `fib()` calls. This is the reason, also, why the
    calls for `testMemoFib(40)` and `testMemoFib(35)` weren't optimized -- when we
    did the calculation for `testMemoFib(45)`, that was the only value that got cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, when calculating `fib(45)`, in fact, all the intermediate Fibonacci values
    (from `fib(0)` to `fib(45)` itself) are stored, so the forthcoming calls have
    practically no work to do.
  prefs: []
  type: TYPE_NORMAL
- en: More complex memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What can we do if we have to work with a function that receives two or more
    arguments, or that can receive arrays or objects as arguments? Of course, like
    in the problem that we saw in [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, about having a function do its job
    only once, we could simply ignore the question: if the function to be memoized
    is unary, we do the memoization thing; otherwise, if the function has a different
    arity, we just don''t do anything!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of parameters of a function is called the *arity* of the function,
    or its *valence*. You may speak in three different ways: you can say a function
    has arity 1, 2, 3, and so on., or you can say that a function is unary, binary,
    ternary, and so on, or you can also say it''s monadic, dyadic, triadic, and so
    on: take your pick!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Working more seriously, if we want to be able to memoize any function, we must
    find a way to generate cache keys. To do this, we have to find a way to convert
    any kind of argument, into a string. We cannot directly use a non-primitive as
    a cache key. We could attempt to convert the value to a string with something
    like `strX = String(x)` but we''ll have problems. With arrays, it seems it could
    work, but see these three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The three cases produce the same result. If we were only considering a single
    array argument, we'd probably be able to make do, but when different arrays produce
    the same key, that's a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things become worse if we have to receive objects as arguments, because the
    `String()` representation of any object is, invariably, `"[object Object]"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest solution is to use `JSON.stringify()` to convert whatever arguments
    we have received into a useful, distinct, and string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For performance, our logic should be as follows: if the function that we are
    memoizing receives a single argument, that is a primitive value, use that argument
    directly as a cache key; in other cases, use the result of `JSON.stringify()`
    as applied to the array of arguments. Our enhanced memoizing higher-order function
    could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of universality, this is the safest version. If you are sure about
    the type of parameters in the function you are going to process, it''s arguable
    that our first version was faster. And, on the other hand, if you want to have
    easier to understand code, even at the cost of some wasted CPU cycles, you could
    go with a simpler version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you want to know about the development of a top-performance memoizing function,
    read Caio Gondim's *How I wrote the world's fastest JavaScript memoization library*
    article, available online at [https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/](https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/).
  prefs: []
  type: TYPE_NORMAL
- en: Memoization testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing the memoization higher-order function poses an interesting problem
    -- just how would you go about it? The first idea would be to look into the cache
    -- but that''s private and not visible. Of course, we could change `memoize()`
    to use a global cache, or to somehow allow external access to the cache, but doing
    that sort of internal exam is frowned upon: you should try to do your tests based
    on external properties only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accepting that we should omit trying to examine the cache, we could go for
    a time control: calling a function such as `fib()`, for a large value of n, should
    take quite longer if the function were not memoized. This is certainly possible,
    but it''s also prone to possible failures: something external to your tests could
    run at just the wrong time and it could be possible that your memoized run would
    take longer than the original one. OK, it''s possible, but not probable -- but
    your test isn''t fully reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go then for a more direct analysis of the number of actual calls to
    the memoized function. Working with a non-memoized, original, `fib()`, we could
    first test whether the function works normally and check how many calls it makes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that `fib(6)` equals 8 is easy to verify, but where do you get that
    the function is called 25 times? For the answer, let''s revisit the diagram we
    saw earlier in [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a11cde8-aa6d-4f15-ac1d-007e56138d1c.png)Figure 6.1\. All the recursive
    calls needed for calculating fib(6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each node is a call; just counting, we get that in order to calculate `fib(6)`,
    25 calls are actually made to `fib()`. Now, let''s turn to the memoized version
    of the function. Testing that it still produces the same results is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But why is it called 11 times for calculating `fib(6)`, and then three times
    more after calculating `fib(5)`, `fib(4)`, and `fib(3)`? To answer the first part
    of the question, let''s analyze the figure we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we call `fib(6)`, which calls `fib(4)` and `fib(5)`: three calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calculating `fib(4)`, `fib(2)` and `fib(3)` are called; the count is up
    to five
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calculating `fib(5)`, `fib(3)` and `fib(4)` are called; the count climbs
    to 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `fib(6)` is calculated and cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(3)` and `fib(4)` are both cached, so no more calls are done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(5)` is calculated and cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calculating `fib(2)`, `fib(0)` and `fib(1)` are called; now we have seven
    calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calculating `fib(3)`, `fib(1)` and `fib(2)` are called; the count is up
    to nine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(4)` is calculated and cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(1)` and `fib(2)` are both already cached, so no further calls are made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(3)` is calculated and cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calculating `fib(0)` and `fib(1)`, no extra calls are made, and both are
    cached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fib(2)` is calculated and cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whew! So the count of calls for `fib(6)` is 11 -- and now, given that all the
    values of `fib(n)` have been cached, for n from 0 to 6, it''s easy to see why
    calculating `fib(5)`, `fib(4)`, and `fib(3)` only adds three calls: all the other
    required values are already cached.'
  prefs: []
  type: TYPE_NORMAL
- en: Altering functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we considered some ways of wrapping functions, so they
    would maintain their original functionality, though enhanced in some ways. Now
    we'll turn to actually modifying what the functions do, so the new results will
    actually differ from the original function's ones.
  prefs: []
  type: TYPE_NORMAL
- en: Doing things once, revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in Chapter 2, *Thinking Functionally - A First Example*, we went through
    an example of developing an FP-style solution for a simple problem: fixing things
    so a given function would work only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a perfectly fine solution, and we have nothing to object to. We can,
    however, think of a variation. We could observe that the given function gets called
    once, but its return value gets lost. That''s easy to fix, however; all we require
    is adding a `return` statement. However, that wouldn''t be enough; what would
    the function return if called more times? We can take a page out of the memoizing
    solution and store the function''s return value for future calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also think of making the function work only once, but for each set
    of arguments... but you wouldn''t have to do any work for that: `memoize()` would
    be enough!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the mentioned [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, we considered a possible alternative
    to `once()`: another higher-order function that took two functions as parameters
    and allowed the first function to be called only once, calling the second function
    from that point on. Adding a `return` statement as earlier, it would have been
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this if we remember that functions are first-order objects.
    Instead of using a flag to remember which function to call, we can use a variable
    (`toCall`) to directly store whichever function needs to be called. Logically,
    that variable will be initialized to the first function, but will then change
    to the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The very same example we saw before would still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In terms of performance, the difference may be negligible. The reason for showing
    this further variation is just to keep in mind that by storing functions, you
    can often produce results in a simpler way. Using flags to store state is a common
    technique, used everywhere in procedural programming. However, here we manage
    to skip that usage, and yet produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Logically negating a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider the `.filter()` method from [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*. Given a predicate, we can filter
    the array to only include those elements for which the predicate is true. But
    how would you do a reverse filter and *exclude* the elements for which the predicate
    is true?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first solution should be pretty obvious: rework the predicate, so it will
    return the opposite of whatever it originally returned. In the previously mentioned
    chapters, we saw this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we could just write it the other way round, in either of these two equivalent
    fashions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s perfectly fine, but we could also have had something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, rewriting the original function isn''t possible. However, working
    in a functional way, we can just write a higher-order function that will take
    any predicate, evaluate it, and then negate its result. A possible implementation
    would be quite simple, thanks to ES8''s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Working in this way, we could have rewritten the preceding filter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an additional solution we might want to try out -- instead of reversing
    the condition (as we did), we could write a new filtering method (possibly `filterNot()`?)
    that would work in the opposite way to `filter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This solution doesn't fully match `.filter()`, since you cannot use it as a
    method, but we could either add it to `Array.prototype`, or apply some methods
    that we'll be seeing in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*. It's more interesting, though,
    to note that we used the negated function, so `not()` is actually necessary for
    both solutions to the reverse filtering problem. In the upcoming Demethodizing
    section, we will see that we have yet another solution since we will be able to
    decouple methods such as `.filter()` from the objects they apply to, changing
    them into common functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for negating the function *versus* using a new `filterNot()`, even though
    both possibilities are equally valid, I think using `not()` is more clear; if
    you already understand how filtering works, then you can practically read it aloud
    and it will be understandable: we want those that don''t have a negative balance,
    right?'
  prefs: []
  type: TYPE_NORMAL
- en: Inverting results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same vein as the preceding filtering problem, let''s now revisit the
    sorting problem from the *Injection - sorting* it out section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*. We wanted to sort an array with
    some specific method, and we used `.sort()`, providing it with a comparison function
    that basically pointed out which of two strings should go first. To refresh your
    memory, given two strings, the function should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a negative number, it the first string should precede the second one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return zero if both strings are the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a positive number, if the first string should follow the second one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go back to the code we saw earlier for sorting in Spanish. We had to write
    a special comparison function, so sorting would take into account the special
    character order rules from Spanish, such as including letter *Ã±* between *n* and
    *o*, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We are facing a similar problem: how can we manage to sort in a *descending*
    order? Given what we just saw in the previous section, two alternatives should
    immediately come to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that will invert the result from the comparing function. This
    will invert the result of all decisions as to which string should precede, and
    the final result will be an array sorted in exactly the opposite way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a `sortDescending()` function or method, that does its work in the opposite
    fashion to `sort()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write an `invert()` function that will take change the result of a comparison.
    The code itself is quite similar to that of preceding `not()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this higher-order function, we can now sort in descending order by just
    providing a suitably inverted comparison function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as expected: when we `invert()` the comparison function, the
    results are in the opposite order. By the way, writing unit tests would be quite
    easy, given that we already have some test cases with their expected results,
    wouldn''t it?'
  prefs: []
  type: TYPE_NORMAL
- en: Arity changing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in the *Parsing numbers s*ection *tacitly* of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, we saw that using `parseInt()` with
    `.reduce()` would produce problems, because of the unexpected arity of that function,
    which took more than one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have more than one way to solve this. In the mentioned chapter, we went
    with an arrow function, that is a simple solution, with the added advantage of
    being clear to understand. In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*, we will see yet another,
    based on partial application. But, here, let''s go with a higher-order function.
    What we need, is a function that will take another function as a parameter, and
    turn it into a unary function. Using JS''s spread operator and an arrow function,
    that''s easy to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function, our number parsing problem goes away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It goes without saying that it would be equally simple to define further `binary()`,
    `ternary()`, and so on functions that would turn any function into an equivalent,
    restricted-arity, version.
  prefs: []
  type: TYPE_NORMAL
- en: You may think there aren't many cases in which you would want to apply this
    kind of solution, but in fact, there are many more than you would expect. Going
    through all of JavaScript's functions and methods, you can easily produce a list
    starting with `.apply()`, `.assign()`, `.bind()`, `.concat()`, `.copyWithin()`...
    and many more! If you wanted to use any of those in a tacit way, you would probably
    need to fix its arity, so it would work with a fixed, non-variable, number of
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a nice list of JavaScript functions and methods, check out the pages
    at [https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Functions)
    and at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Methods_Index).
    As for tacit (or point freestyle) programming, we'll be coming back to it in [Chapter
    8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions - Pipelining
    and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: Other higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's end this chapter by considering other sundry functions that provide results
    such as new finders, decoupling method from objects, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Turning operations into functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen several cases in which we needed to write a function just
    to add or multiply a pair of numbers. For example, in the *Summing an array* section
    of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we had to write code equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same chapter, in the section *Working with ranges*, to calculate a factorial,
    we then needed this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It would have been easier if we could just turn a binary operator into a function
    that calculates the same result. The preceding two examples could have been written
    more succinctly, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implementing operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would we write this `binaryOp()` function? There are at least two ways
    of doing so: a safe but long one and a riskier and shorter alternative. The first
    would require listing each possible operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This solution is perfectly fine but requires too much work. The second is more
    dangerous, but shorter. Please consider this just as an example, for learning
    purposes; using `eval()` isn't recommended for security reasons!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you follow this trail of thought, you may also define an `unaryOp()` function,
    even though there are fewer applications for it. (I leave this implementation
    to you; it's quite similar to what we already wrote.) In the upcoming [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*, we will see an alternative way of creating this unary
    function by using partial application.
  prefs: []
  type: TYPE_NORMAL
- en: A handier implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get ahead of ourselves. Doing FP doesn''t mean always getting down to
    the very basic, simplest possible functions. For example, in the *Converting to
    free point style* section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, we will need a function to
    check if a number is negative, and we''ll consider using `binaryOp2()` to write
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Never mind about the `curry()` function now (we''ll get to it soon in [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*) but the idea is that it fixes the first argument to
    zero, so our function will check, for a given number *n*, whether *0>n*. The point
    here is that the function we just wrote isn''t quite clear. We could do better
    if we defined a binary operation function that also let us specify one of its
    parameters, the left one or the right one, in addition to the operator to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could have gone back to the `new Function()` style of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With these new functions, we could simply write either of the following --
    though I think the second is clearer: I''d rather test whether a number is less
    than zero, rather than whether zero is greater than the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: What is the point of this? Don't strive for some kind of *basic simplicity*
    or *going down to basics* code. We can transform an operator into a function,
    true -- but if you can do better, and simplify your coding, by also allowing to
    specify one of the two parameters for the operation, just do it! The idea of FP
    is helping write better code, and creating artificial limitations won't help anybody.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, for a simple function such as checking whether a number is negative,
    I would never want to complicate things with currying or binary operators or point
    freestyle or anything else, and I''d just write the following with no further
    ado:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Turning functions into promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Node, most asynchronous functions require a callback such as `(err,data)=>{...}`:
    if `err` is `null`, the function was successful, and `data` is its result, and
    if `err` has some value, the function failed, and `err` gives the cause. (See
    [https://nodejs.org/api/errors.html#errors_node_js_style_callbacks](https://nodejs.org/api/errors.html#errors_node_js_style_callbacks)
    for more on this.)'
  prefs: []
  type: TYPE_NORMAL
- en: However, you might prefer to work with promises instead. So, we can think of
    writing a higher-order function that will transform a function that requires a
    callback into a promise that lets you use `.then()` and `.catch()` methods. (In
    [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better Containers
    - Functional Data Types*, we will see that promises are actually monads, so this
    transformation is interesting in yet another way.)
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we manage this? The transformation is rather simple. Given a function,
    we produce a new one: this will return a promise that, upon calling the original
    function with some parameters, will either `reject()` or `resolve()` the promise
    appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function, instead of writing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can go with promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now you would be able to use `fspromise()` instead of the original method. We
    had to bind `fs.readFile`, as we mentioned in the *An unnecessary mistake* section
    of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property from an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a simple, but often used, function that we could also produce. Extracting
    an attribute from an object is a commonly required operation. For example, in
    [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we had to get latitudes and longitudes to be able to calculate
    an average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We had another example when we saw how to filter an array; in our example,
    we wanted to get the IDs for all accounts with a negative balance and, after filtering
    out all other accounts, we still needed to extract the ID field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We could have joined those two lines, and produced the desired result with a
    one-liner, but that's not relevant here. In fact, unless the `delinquent` intermediate
    result was needed for some reason, most FP programmers would go for the one-line
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need? We need a higher-order function that will receive the name
    of an attribute, and produce as its result a new function that will be able to
    extract said attribute from an object. Using ES8 syntax, this function is easy
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the *Getters and Setters* section of [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*, we'll write an even more general version of
    this function, able to "go deep" into an object, to get any attribute of it, no
    matter its location within the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function, the coordinates extraction could have been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For variety, we could have used an auxiliary variable to get the delinquent
    ID's.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to fully understand what's going on here. The result of the `getField()`
    call is a function, which will be used in further expressions. The `map()` method
    requires a mapping function and that's what `getField()` produces.
  prefs: []
  type: TYPE_NORMAL
- en: Demethodizing - turning methods into functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods such as `.filter()` or `.map()` are only available for arrays -- but
    in fact, you could want to apply them to, say, a `NodeList` or a `String`, and
    you'd be out of luck. Also, we are focusing on strings, so having to use these
    functions as methods is not exactly what we had in mind. Finally, whenever we
    create a new function (such as `none()`, which we saw in the *Checking Negatives*
    section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*), it cannot be applied in the same way as its
    peers (`.some()` and `.every()`, in this case) unless you do some prototype trickery
    -- which is rightly frowned upon, and not recommended at all... but do see the
    *Extending current data types* section of [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, where we will make `.map()`
    available for most basic types!
  prefs: []
  type: TYPE_NORMAL
- en: So... what can we do? We can apply the old saying *If the mountain won't come
    to Muhammad, then Muhammad must go to the mountain* and, instead of worrying about
    not being able to create new methods, we will turn the existing methods into functions.
    We can do that, if we convert each method into a function that will receive, as
    its first parameter, the object it will work on.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling methods from objects can help you, because once you achieve this
    separation, everything turns out to be a function, and your code will be simpler.
    (Remember what we wrote preceding, in the *Logically negating a function*, regarding
    a possible `filterNot()` function in comparison to the `.filter()` method?) A
    decoupled method works in a fashion somewhat similar to what are called *generic*
    functions in other languages since they can be applied to diverse data types.
  prefs: []
  type: TYPE_NORMAL
- en: There are three distinct, but similar, ways to implement this in ES8\. The first
    argument in the list will correspond to the object; the other arguments, to the
    actual ones for the called method;
  prefs: []
  type: TYPE_NORMAL
- en: See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for explanations on `apply()`, `call()`, and `bind()`. By the way, back in [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, we saw the equivalence between `.apply()` and `.call()` when you used
    the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s yet another way of doing this: `demethodize = Function.prototype.bind.bind(Function.prototype.call)`.
    If you want to understand how this works, read Leland Richardson''s *Clever way
    to* demethodize *Native JS Methods*, at [http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods](http://www.intelligiblebabble.com/clever-way-to-demethodize-native-js-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some applications for those! Starting with a simple example, we
    can use `.map()` to loop over a string, without first converting it into an array
    of characters. Say you wanted to separate a string into individual letters and
    turn them into upper case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we demethodize both `.map()` and `.toUpperCase()`, we can simply
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Yes, for this particular case, we could have first turned the string into uppercase,
    and then split it into separate letters, as in `name.toUpperCase().split("")`
    -- but it wouldn't have been such a nice example, with two usages of demethodizing
    no less, would it?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we could convert an array of decimal amounts into properly
    formatted strings, with thousands of separators and decimal points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, given the preceding map function, this would have also worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The idea of demethodizing a method to turn it into a function will prove to
    be quite useful in diverse situations. We have already seen some examples where
    we could have applied it and there will be more such cases in the rest of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the optimum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s end this section by creating an extension of the `.find()` method. Suppose
    we want to find the optimum value --let''s suppose it''s the maximum-- of an array
    of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, is this sufficiently general? There are at least a pair of problems with
    this approach. First, are you sure that the optimum of a set will always be the
    maximum? If you were considering several mortgages, the one with *lowest* interest
    rate could be the best, couldn't it? Assuming that we would always want the *maximum*
    of a set is too constrictive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do a roundabout trick: if you change the signs of all the numbers
    in an array, find its maximum, and change its sign, then you actually get the
    minimum of the array. In our case, `-findOptimum(myArray.map((x) => -x))` would
    produce 4 -- but it''s not easily understandable code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, this way of finding the maximum depends on each option having a numeric
    value. But how would you find the optimum, if such a value didn''t exist? The
    usual way depends on comparing elements with each another and picking the one
    that comes on top of the comparison: compare the first element with the second
    and keep the best of those two; then compare that value with the third element
    and keep the best; and keep at it until you have finished going through all the
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The way to solve this problem with more generality is to assume the existence
    of a `comparator()` function, that takes two elements as arguments, and returns
    the best of those. If you could associate a numeric value to each element, then
    the comparator function could simply compare those values. In other cases, it
    could do whatever logic is needed in order to decide what element comes out on
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to create an appropriate higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can easily replicate maximum- and minimum-finding functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go one better, and compare non-numeric values. Let''s imagine a superheroes
    card game: each card represents a hero, with several numeric attributes, such
    as Strength, Powers, and Tech. When two heroes fight each other, the one with
    more categories with higher values than the other is the winner. Let''s implement
    a comparator for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can apply this to our "tournament" of heroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When you rank elements according to one-to-one comparisons, unexpected results
    may be produced. For instance, with our superheroes comparison rules, you could
    find three heroes such that the first beats the second, the second beat the third,
    but the third beats the first! In mathematical terms, this means that the comparison
    function is not transitive and you don't have a *total ordering* for the set.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.1\. **A border case**. What happens with our `getField()` function if we apply
    it to a null object? What should its behavior be? If necessary, modify the function.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. **How many?** How many calls would be needed to calculate `fib(50)` without
    memoizing? For example, to calculate `fib(0)` or `fib(1)`, one call is enough
    with no further recursion needed, and for `fib(6)` we saw that 25 calls were required.
    Can you find a formula to do this calculation?
  prefs: []
  type: TYPE_NORMAL
- en: 6.3\. **A randomizing balancer**. Write a higher-order function `randomizer(fn1,
    fn2, ...)` that will receive a variable number of functions as arguments, and
    return a new function that will, on each call, randomly call one of `fn1`, `fn2`,
    and so on. You could possibly use this to balance calls to different services
    on a server if each function was able to do an Ajax call. For bonus points, ensure
    that no function will be called twice in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4\. **Just say no!** In this chapter, we wrote a `not()` function that worked
    with boolean functions and a `negate()` function that worked with numerical ones.
    Can you go one better and just write a single `opposite()` function that will
    behave as `not()` or `negate()` as needed?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to write higher-order functions of our own,
    which can either wrap another function to provide some new feature, alter a function's
    objective so it will do something else, or even totally new features, such as
    decoupling methods from objects or creating better finders.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions
    - Currying and Partial Application*, we'll still keep working with higher-order
    functions, and we'll see how to produce specialized versions of existing functions,
    with predefined arguments, by currying and partial application.
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 9*:Leveraging the V4L2 API from the User Space'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of device drivers is controlling and leveraging the underlying
    hardware while exposing functionalities to users. These users may be applications
    running in user space or other kernel drivers. While the two previous chapters
    dealt with V4L2 device drivers, in this chapter, we will learn how to take advantage
    of V4L2 device functionalities exposed by the kernel. We will start by describing
    and enumerating user space V4L2 APIs, and then we will learn how to leverage those
    APIs to grab video data from the sensor, including mangling the sensor properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: V4L2 user space APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video device property management from user space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer management from user space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: V4L2 user space tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make the most out of this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced computer architecture knowledge and C programming skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to V4L2 from user space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main purpose of writing device drivers is to ease the control and usage
    of the underlying device by the application. There are two ways for user space
    to deal with V4L2 devices: either by using all-in-one utilities such as `GStreamer`
    and its `gst-*` tools or by writing a dedicated application using user space V4L2
    APIs. In this chapter, we only deal with the code, thus we will cover how to write
    applications that use the V4L2 API.'
  prefs: []
  type: TYPE_NORMAL
- en: The V4L2 user space API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The V4L2 user space API has a reduced number of functions and a lot of data
    structures, all defined in `include/uapi/linux/videodev2.h`. In this section,
    we will try to describe the most important of them—or, better said, the most commonly
    used. Your code should include the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This API relies on the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open()`: To open a video device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close()`: To close a video device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ioctl()`: To send ioctl commands to the display driver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmap()`: To memory map a driver-allocated buffer to user space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read()` or `write()`, depending on the streaming method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This reduced set of APIs is extended by a very large number of ioctl commands,
    the most important of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VIDIOC_QUERYCAP`: This is used to query the capabilities of the driver. People
    used to say it is used to query the device''s capabilities, but this is not true
    as the device may be capable of things that are not implemented in the driver.
    User space passes a `struct v4l2_capability` structure, which will be filled by
    the video driver with the relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_ENUM_FMT`: This is used to enumerate the image formats that are supported
    by the driver. The driver user space passes a `struct v4l2_fmtdesc` structure,
    which will be filled by the driver with the relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_G_FMT`: For a capture device, this is used to get the current image
    format. However, for a display device, you use this to get the current display
    window. In either case, user space passes a `struct v4l2_format` structure, which
    will be filled by the driver with the relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_TRY_FMT` should be used when you are unsure about the format to be
    submitted to the device. This is used to validate a new image format for a capture
    device or a new display window depending on an output (display) device. User space
    passes a `struct v4l2_format` structure with the properties it would like to apply,
    and the driver may change the given values if they are not supported. The application
    should then check what is granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_S_FMT` is used to set a new image format for a capture device or a
    new display window for a display (output device). The driver may change the values
    passed by user space if they are not supported. The application should check what
    is granted if `VIDIOC_TRY_FMT` is not used first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_CROPCAP` is used to get the default cropping rectangle based on the
    current image size and the current display panel size. The driver fills a `struct
    v4l2_cropcap` structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_G_CROP` is used to get the current cropping rectangle. The driver fills
    a `struct v4l2_crop` structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_S_CROP` is used to set a new cropping rectangle. The driver fills a
    `struct v4l2_crop` structure. The application should check what is granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_REQBUFS`: This ioctl is used to request a number of buffers that can
    later be memory mapped. The driver fills a `struct v4l2_requestbuffers` structure.
    As the driver may allocate more or less than the actual number of buffers requested,
    the application should check how many buffers are really granted. No buffer is
    queued yet after this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VIDIOC_QUERYBUF` ioctl is used to get a buffer's information, which can
    be used by the `mmap()` system call in order to map that buffer to user space.
    The driver fills a `struct v4l2_buffer` structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_QBUF` is used to queue a buffer by passing a `struct v4l2_buffer` structure
    associated with that buffer. On the execution path of this ioctl, the driver will
    add this buffer to its list of buffers so that it is filled when there are no
    more pending queued buffers before it. Once the buffer is filled, it is passed
    to the V4L2 core, which maintains its own list (that is, a ready buffer list)
    and it is moved off the driver''s list of DMA buffers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_DQBUF` is used to dequeue a filled buffer (from the V4L2''s list of
    ready buffers for the input device) or a displayed (output device) buffer by passing
    a `struct v4l2_buffer` structure associated with that buffer. This will block
    if no buffer is ready unless `O_NONBLOCK` was used with `open()`, in which case
    `VIDIOC_DQBUF` will immediately return with an `EAGAIN` error code. You should
    call `VIDIOC_DQBUF` only after `STREAMON` has been called. In the meantime, calling
    this ioctl after `STREAMOFF` would return `-EINVAL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_STREAMON` is used to turn on streaming. After that, any `VIDIOC_QBUF`
    results in an image are rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIDIOC_STREAMOFF` is used to turn off streaming. This ioctl removes all buffers.
    It actually flushes the buffer queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more ioctl commands than those we have just enumerated. There
    are actually at least as many ioctls as there are ops in the kernel''s `v4l2_ioctl_ops`
    data structure. However, the preceding ioctls are enough to go deeper into the
    V4L2 user space API. In this section, we will not go into detail about each data
    structure. You should then keep open the `include/uapi/linux/videodev2.h` file,
    also available at [https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h),
    as it contains all the V4L2 APIs and data structures. That being said, the following
    pseudo-code shows a typical ioctl sequence to grab video from user space using
    V4L2 APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sequence will serve as a guideline to deal with the V4L2 API in
    user space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that it is possible for the `ioctl` system call to return a `-1` value
    while `errno = EINTR`. In this case, it would not mean an error but simply that
    the system call was interrupted, in which case it should be tried again. To address
    this (rare but possible) issue, we can consider writing our own wrapper for `ioctl`,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with the video grabbing sequence overview, we can figure
    out what steps are required to proceed to video streaming from device opening
    to closing, through format negotiation. We can now jump to the code, starting
    with the device opening, from which everything begins.
  prefs: []
  type: TYPE_NORMAL
- en: Video device opening and property management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drivers expose node entries in the `/dev/` directory corresponding to the video
    interfaces they are responsible for. These file nodes correspond to the `/dev/videoX`
    special files for capture devices (in our case). The application must open the
    appropriate file node prior to any interaction with the video device. It uses
    the `open()` system call for that, which will return a file descriptor that will
    be the entry point for any command sent to the device, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is an opening in blocking mode. Passing `O_NONBLOCK`
    to `open()` would prevent the application from being blocked if there is no ready
    buffer while trying to dequeue. Once you''re done with the video device, it should
    be closed using the `close()` system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After we are able to open the video device, we can start our interaction with
    it. Generally, the first action that takes place once the video device is opened
    is to query its capabilities, through which we can make it operate optimally.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the device capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is common to query the capabilities of the device in order to make sure
    it supports the mode we need to work with. You do this using the `VIDIOC_QUERYCAP`
    ioctl command. To achieve this, the application passes a `struct v4l2_capability`
    structure (defined in `include/uapi/linux/videodev2.h`), which will be filled
    by the driver. This structure has a `.capabilities` field that has to be checked.
    That field contains the capabilities of the whole device. The following excerpt
    from the kernel source shows the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block shows a common use case that shows how to query the
    device capabilities from the code using the `VIDIOC_QUERYCAP` ioctl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `struct v4l2_capability` is first zeroed thanks to `memset()`
    prior to being given to the `ioctl` command. At this step, if no error occurs,
    then our `cap` variable now contains the device capabilities. You can use the
    following to check for the device type and the I/O methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that we first zeroed our `cap` variable prior to using
    it. It is good practice to always clear parameters that will be given to V4L2
    APIs in order to avoid stale content. Let''s then define a macro—say, `CLEAR`—that
    will zero any variable given as a parameter, and use it in the rest of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are done with querying the video device capabilities. This allows us
    to configure the device and tweak the image format according to what we need to
    achieve. By negotiating the appropriate image format, we can leverage the video
    device, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should consider that in V4L2, two buffer queues are maintained: one for
    the driver (referred to as the `VIDIOC_QBUF` ioctl for this). Buffers are filled
    by the driver in the order they have been enqueued. Once filled, each buffer is
    moved off the INPUT queue and put into the OUTPUT queue, which is the user queue.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the user application calls `VIDIOC_DQBUF` in order to dequeue a buffer,
    this buffer is looked for in the OUTPUT queue. If it's in there, the buffer will
    be dequeued and *pushed* to the user application; otherwise, the application will
    wait until a filled buffer is there. After the user finishes using the buffer,
    it must call `VIDIOC_QBUF` on this buffer in order to enqueue it back in the INPUT
    queue so that it can be filled again.
  prefs: []
  type: TYPE_NORMAL
- en: After driver initialization, the application calls the `VIDIOC_REQBUFS` ioctl
    to set the number of buffers it needs to work with. Once this is granted, the
    application queues all the buffers using `VIDIOC_QBUF`, and then calls the `VIDIOC_STREAMON`
    ioctl. Then, the driver goes ahead on its own and fills all the queued buffers.
    If there are no more queued buffers, then the driver will be waiting for a buffer
    to be queued in by the application. If such a case arises, then it means that
    some frames are lost in the capture itself.
  prefs: []
  type: TYPE_NORMAL
- en: Image (buffer) format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After making sure that the device is of the correct type and supports the modes
    it can work with, the application must negotiate the video format it needs. The
    application has to make sure that the video device is configured to send video
    frames in a format that the application can deal with. It has to do this before
    starting to grab and gather data (or video frames). The V4L2 API uses `struct
    v4l2_format` to represent the buffer format, whatever the type of the device is.
    This structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding structure, the `type` field represents the type of the data
    stream and should be set by the application. Depending on its value, the `fmt`
    field will be of the appropriate type. In our case, `type` must be `V4L2_BUF_TYPE_VIDEO_CAPTURE`
    as we are dealing with video capture devices. `fmt` will then be of the `struct
    v4l2_pix_format` type.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Almost all (if not all) ioctls playing directly or indirectly with the buffer
    (such as cropping, buffer requesting/queue/dequeue/querying) need to specify the
    buffer type, which makes sense. We will use `V4L2_BUF_TYPE_VIDEO_CAPTURE` as it
    is the only choice we have for our device type. The whole list of buffer types
    is of the `enum v4l2_buf_type` type defined in `include/uapi/linux/videodev2.h`.
    You should have a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common for applications to query the current format of the video device
    and then only change the properties of interest in it, and send back the new,
    mangled buffer format to the video device. However, this is not mandatory. We
    have only done it here to demonstrate how you can either get or set the current
    format. The application queries the current buffer format using the `VIDIOC_G_FMT`
    ioctl command. It has to pass a fresh (by fresh, I mean zeroed) `struct v4l2_format`
    structure with the `type` field set. The driver will fill the rest in the return
    path of the ioctl. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the current format, we can change the relevant properties and
    send back the new format to the device. These properties may be pixel format,
    memory organization for each color component, and interlaced capture memory organization
    for each field. We can also describe the size and pitch of the buffer. Common
    (but not the only) pixel formats supported by devices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V4L2_PIX_FMT_YUYV`: YUV422 (interleaved)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V4L2_PIX_FMT_NV12`: YUV420 (semi-planar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V4L2_PIX_FMT_NV16`: YUV422 (semi-planar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V4L2_PIX_FMT_RGB24`: RGB888 (packed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s write the piece of code that changes the properties we need. However,
    sending the new format to the video device requires using a new ioctl command—that
    is, `VIDIOC_S_FMT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We could have used the preceding code without needing the current format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ioctl may succeed. However, this does not mean your parameters have been
    applied as is. By default, a device may not support every combination of image
    width and height, or even the required pixel format. In this case, the driver
    will apply the closest values it supports according to the ones you requested.
    You then have to check whether your parameters have been accepted or whether the
    ones that are granted are good enough for you to proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even go further by changing the streaming parameters, such as the number
    of frames per second. We can achieve this by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `VIDIOC_G_PARM` ioctl to query the video device's streaming parameters.
    This ioctl accepts as a parameter a fresh `struct v4l2_streamparm` structure with
    its `type` member set. This type should be one of the `enum v4l2_buf_type` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking `v4l2_streamparm.parm.capture.capability` and making sure the `V4L2_CAP_TIMEPERFRAME`
    flag is set. This means that the driver allows changing the capture frame rate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, we can (optionally) use the `VIDIOC_ENUM_FRAMEINTERVALS` ioctl in order
    to get the list of possible frame intervals (the API uses the frame interval,
    which is the inverse of the frame rate).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `VIDIOC_S_PARM` ioctl and filling in the `v4l2_streamparm.parm.capture.timeperframe`
    members with the appropriate values. That should allow setting the capture-side
    frame rate. It's your task to make sure you're reading fast enough to not get
    frame drops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can negotiate image formats and set the streaming parameter. The next
    logical continuation would be requesting buffers and proceeding to further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once done with format preparation, it is time to instruct the driver to allocate
    memory that is to be used to store video frames. The `VIDIOC_REQBUFS` ioctl is
    there to achieve this. This ioctl takes a fresh `struct v4l2_requestbuffers` structure
    as an argument. Prior to being given to the ioctl, `v4l2_requestbuffers` must
    have some of its fields set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v4l2_requestbuffers.count`: This member should be set with the number of memory
    buffers to be allocated. This member should be set with a value ensuring that
    frames won''t be dropped because of a lack of queued buffers in the INPUT queue.
    Most of the time, `3` or `4` are correct values. Therefore, the driver may not
    be comfortable with the requested number of buffers. In this case, the driver
    will set `v4l2_requestbuffers.count` with the granted number of buffers on the
    return path of the ioctl. The application should then check this value in order
    to make sure this granted value fits its needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v4l2_requestbuffers.type`: This must be set with the video buffer type, of
    the `enum 4l2_buf_type` type. Here, again, we use `V4L2_BUF_TYPE_VIDEO_CAPTURE`.
    This would be `V4L2_BUF_TYPE_VIDEO_OUTPUT` for an output device, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v4l2_requestbuffers.memory`: This must be one of the possible `enum v4l2_memory`
    values. Possible values of interest are `V4L2_MEMORY_MMAP`, `V4L2_MEMORY_USERPTR`,
    and `V4L2_MEMORY_DMABUF`. These are all streaming methods. However, depending
    on the value of this member, the application may have additional tasks to perform.Unfortunately,
    the `VIDIOC_REQBUFS` command is the only way for an application to discover which
    types of streaming I/O buffer are supported by a given driver. The application
    can then try `VIDIOC_REQBUFS` with each of these values and adapt its logic according
    to which one failed or succeeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting user pointer buﬀers – VIDIOC_REQBUFS and malloc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This step involves the driver supporting streaming mode, especially user pointer
    I/O mode. Here, the application informs the driver that it is about to allocate
    a given number of buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the application allocates the buffer memory from user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first type of streaming, where buffers are malloced in user space
    and given to the kernel in order to be filled with video data: the so-called user
    pointer I/O mode. There is another fancy streaming mode, where almost everything
    is done from the kernel. Without delay, let''s introduce it.'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting the memory mappable buﬀer – VIDIOC_REQBUFS, VIDIOC_QUERYBUF, and
    mmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In driver buffer mode, this ioctl also returns the actual number of buffers
    allocated in the `count` member of the `v4l2_requestbuffer` structure. This streaming
    method also requires a new data structure, `struct v4l2_buffer`. After buffers
    are allocated by the driver in the kernel, this structure is used along with the
    `VIDIOC_QUERYBUFS` ioctl in order to query the physical address of each allocated
    buffer, which can be used with the `mmap()` system call. The physical address
    returned from the driver will be stored in `buffer.m.offset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code excerpt instructs the driver to allocate memory buffers
    and check the number of buffers granted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, the application should call the `VIDIOC_QUERYBUF` ioctl on each
    allocated buffer in order to get their corresponding physical addresses, as the
    following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In order for the application to internally track the memory mapping (obtained
    with `mmap()`) of each buffer, we defined a custom data structure, `struct buffer_addr`,
    allocated for each granted buffer, which will hold the mapping corresponding to
    this buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting DMABUF buffers – VIDIOC_REQBUFS, VIDIOC_EXPBUF, and mmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DMABUF is mostly used on `mem2mem` devices and introduces the concept of the
    **exporter** and **importer**. Say driver **A** wants to use buffers created by
    driver **B**; then we call **B** as the exporter and **A** as the buffer user/importer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export` method instructs the driver to export its DMA buffers to user
    space by means of the file descriptor. The application achieves this using the
    `VIDIOC_EXPBUF` ioctl and requires a new data structure, `struct v4l2_exportbuffer`.
    On the return path of this ioctl, the driver will set the `v4l2_requestbuffers.md`
    member with the file descriptor corresponding to the given buffer. This is a DMABUF
    file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is possible for the application to export those buffers as DMABUF file descriptors
    so that they can be memory mapped to access the captured video content. The application
    should use the `VIDIOC_EXPBUF` ioctl for this. This ioctl extends the memory mapping
    I/O method, so it is only available for `V4L2_MEMORY_MMAP` buffers. However, it
    is actually useless at exporting capture buffers using `VIDIOC_EXPBUF` and then
    mapping them. You should use `V4L2_MEMORY_MMAP` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`VIDIOC_EXPBUF` becomes very interesting when it comes to V4L2 output devices.
    This way, the application allocates buffers on both capture and output devices
    using the `VIDIOC_REQBUFS` ioctl, and then the application exports the output
    device''s buffers as DMABUF file descriptors and uses these file descriptors to
    set the `v4l2_buffer.m.fd` field before the enqueueing ioctl on the capture device.
    The queued buffer will then have its counterpart (the output device buffer corresponding
    to `v4l2_buffer.m.fd`) filled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we export output device buffers as DMABUF file descriptors.
    This assumes buffers for this output device have been allocated using the `VIDIOC_REQBUFS`
    ioctl with `req.type` set to `V4L2_BUF_TYPE_VIDEO_OUTPUT` and `req.memory` set
    to `V4L2_MEMORY_DMABUF`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have learned about DMABUF-based streaming and introduced the concepts
    it comes with. The next and last streaming method is much simpler and requires
    less code. Let's jump to it.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting read/write I/O memory
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the simpler streaming mode from a coding point of view. In the case
    of **read/write I/O**, there is nothing to do except to allocate the memory location
    where the application will store the read data, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we have defined the same custom data structure,
    `struct buffer_addr`. However, there is no real buffer request here (`VIDIOC_REQBUFS`
    is not used) because nothing goes to the kernel yet. The buffer memory is simply
    allocated and that is all.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are done with buffer requests. The next step is to enqueue the requested
    buffers so that they can be filled with video data by the kernel. Let's now see
    how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueueing the buffer and enabling streaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to a buffer being accessed and its data being read, this buffer must be
    enqueued. This consists of using the `VIDIOC_QBUF` ioctl on the buffer when using
    the streaming I/O method (everything except read/write I/O). Enqueueing a buffer
    will lock the memory pages of that buffer in physical memory. This way, those
    pages cannot be swapped out to disk. Do note that those buffers remain locked
    until they are dequeued, until the `VIDIOC_STREAMOFF` or `VIDIOC_REQBUFS` ioctls
    are called, or until the device is closed.
  prefs: []
  type: TYPE_NORMAL
- en: In the V4L2 context, locking a buffer means passing this buffer to the driver
    for hardware access (usually DMA). If an application accesses (reads/writes) a
    locked buffer, then the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: To enqueue a buffer, the application must prepare `struct v4l2_buffer`, and
    `v4l2_buffer.type`, `v4l2_buffer.memory`, and `v4l2_buffer.index` should be set
    according to the buffer type, the streaming mode, and the index of the buffer
    when it has been allocated. Other fields depend on the streaming mode.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The *read/write I/O* method does not require enqueueing.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of prime buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For capturing applications, it is customary to enqueue a number (most of the
    time, the number of allocated buffers) of empty buffers before you start capturing
    and enter the read loop. This helps improve the smoothness of the application
    and prevent it from being blocked because of the lack of a filled buffer. This
    should be done right after the buffers are allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Enqueuing user pointer buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enqueue a user pointer buffer, the application must set the `v4l2_buffer.memory`
    member to `V4L2_MEMORY_USERPTR`. The particularity here is the `v4l2_buffer.m.userptr`
    field, which must be set with the address of the buffer previously allocated and
    `v4l2_buffer.length` set to its size. When the multi-planar API is used, the `m.userptr`
    and `length` members of the passed array of `struct v4l2_plane` have to be used
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Enqueuing memory mappable buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enqueue a memory mappable buffer, the application must fill `struct v4l2_buffer`
    by setting the `type`, `memory` (which must be `V4L2_MEMORY_MMAP`), and `index`
    members, just as in the following excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Enqueuing DMABUF buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enqueue an output device''s DMABUF buffer into the capture device''s one,
    applications should fill `struct v4l2_buffer`, setting the `memory` field to `V4L2_MEMORY_DMABUF`,
    the `type` field to `V4L2_BUF_TYPE_VIDEO_CAPTURE`, and the `m.fd` field to a file
    descriptor associated with a DMABUF buffer of the output device, as in the following
    excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code excerpt shows how a V4L2 DMABUF import works. The `fd` argument
    in the ioctl is the file descriptor associated with the capture device, obtained
    at the `open()` syscall. `outdev_dmabuf_fd` is the array that contains the output
    device's DMABUF file descriptors. You may wonder how this can work on output devices
    that are not V4L2 but are DRM-compatible, for example. The following is a brief
    explanation.
  prefs: []
  type: TYPE_NORMAL
- en: First, the DRM subsystem provides APIs in a driver-dependent way, which you
    can use to allocate a (dumb) buffer on the GPU, which will return a GEM handle.
    The DRM also provides the `DRM_IOCTL_PRIME_HANDLE_TO_FD` ioctl, which allows exporting
    a buffer into the DMABUF file descriptor through `PRIME`, then the `drmModeAddFB2()`
    API to create a `framebuffer` object (which is something that will be read and
    displayed onscreen, or should I say, the CRT controller, to be exact) corresponding
    to this buffer so that it can finally be rendered using the `drmModeSetPlane()`
    or `drmModeSetPlane()` APIs. The application can then set the `v4l2_requestbuffers.m.fd`
    field with the file descriptor returned by the `DRM_IOCTL_PRIME_HANDLE_TO_FD`
    ioctl. Then, in the read loop, after each `VIDIOC_DQBUF` ioctl, the application
    can change the plane's frame buffer and position using the `drmModeSetPlane()`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`drm dma-buf` interface layer integrated with `GEM`, which is one of the memory
    managers supported by the DRM subsystem'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enabling streaming is kind of like informing V4L2 that the *OUTPUT* queue will
    be accessed as of now. The application should use `VIDIOC_STREAMON` to achieve
    this. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding excerpt is short but is mandatory to enable streaming, without
    which buffers can't be dequeued later.
  prefs: []
  type: TYPE_NORMAL
- en: Dequeuing buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is actually part of the application's read loop. The application dequeues
    buffers using the `VIDIOC_DQBUF` ioctl. This is only possible if the streaming
    has been enabled before. When the application calls the `VIDIOC_DQBUF` ioctl,
    it instructs the driver to check whether there are any filled buffers in the `O_NONBLOCK`
    flag has been set during the `open()` system call) until a buffer is queued and
    filled.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Trying to dequeue a buffer without queuing it first is an error, and the `VIDIOC_DQBUF`
    ioctl should return `-EINVAL`. When the `O_NONBLOCK` flag is given to the `open()`
    function, `VIDIOC_DQBUF` returns immediately with an `EAGAIN` error code when
    no buffer is available.
  prefs: []
  type: TYPE_NORMAL
- en: After dequeuing a buffer and processing its data, the application must immediately
    queue back this buffer again so that it can be refilled for the next reading,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Dequeuing memory-mapped buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an example of dequeuing a buffer that has been memory mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This could have been done in a loop. For example, let''s say you need 200 images.
    The read loop could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This preceding snippet is just a reimplementation of the buffer dequeuing using
    a loop, where the counter represents the number of images needed to grab.
  prefs: []
  type: TYPE_NORMAL
- en: Dequeuing user pointer buﬀers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an example of dequeuing a buffer using the **user pointer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how to dequeue a user pointer buffer, and is well commented
    enough to not require any further explanation. However, this could be implemented
    in a loop if many buffers were needed.
  prefs: []
  type: TYPE_NORMAL
- en: Read/write I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the last example, showing how to dequeue a buffer using the `read()`
    system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: None of the previous examples have been discussed in detail because each of
    them uses a concept that was already introduced in the *The V4L2 user space API*
    section. Now that we are familiar with writing V4L2 user space code, let's see
    how not to write any code by using dedicated tools that can be used for quickly
    prototyping your camera system.
  prefs: []
  type: TYPE_NORMAL
- en: V4L2 user space tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to write user space code to interact with the driver
    in the kernel. For rapid prototyping and testing, we could leverage some community-provided
    V4L2 user space tools. By using those tools, we can focus on the system design
    and validate the camera system. The most well-known tool is `v4l2-ctl`, which
    we will focus on; it is shipped with the `v4l-utils` package.
  prefs: []
  type: TYPE_NORMAL
- en: Though it is not discussed in this chapter, there is also the **yavta** tool
    (which stands for **Yet Another V4L2 Test Application**), which can be used to
    test, debug, and control the camera subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Using v4l2-ctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`v4l2-utils` is a user space application that can be used to query or configure
    V4L2 devices (including subdevices). This tool can help in setting up and designing
    fine-grained V4L2-based systems as it helps tweak and leverage the device''s features.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`qv4l2` is the Qt GUI equivalent of `v4l2-ctl`. `v4l2-ctl` is ideal for embedded
    systems, while `qv4l2` is ideal for interactive testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing the video devices and their capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we would need to list all the available video devices using the
    `--list-devices` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If several devices are available, we can use the `-d` option after any `v4l2-ctl`
    commands in order to target a specific device. Do note that if the `-d` option
    is not specified, `/dev/video0` is targeted by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have information on a specific device, you must use the `-D` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command shows the device information (such as the driver and its
    version) as well as its capabilities. That being said, the `--all` command gives
    better verbosity. You should give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the device properties (controlling the device)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we look at changing the device properties, we first need to know what
    controls the device supports, what their value types (integer, Boolean, string,
    and so on) are, what their default values are, and what values are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the list of controls supported by the device, we can use `v4l2-ctl`
    with the `-L` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the `"value="` field returns the current value of the
    control, and the other fields are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are aware of the list of controls supported by the device, a control
    value can be changed thanks to the `--set-ctrl` option, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can check the current value with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could have used the `--get-ctrl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now it may be time to tweak the device. Before that, let's check the video characteristics
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the pixel format, resolution, and frame rate
  prefs: []
  type: TYPE_NORMAL
- en: 'Before selecting a specific format or resolution, we need to enumerate what
    is available for the device. In order to get the supported pixel format, as well
    as the resolution and frame rate, the `--list-formats-ext` option needs to be
    given to `v4l2-ctl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From the previous output, we can see what is supported by the target device,
    which is the `mjpeg`) compressed format and the YUYV raw format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to change the camera configuration, first select the frame rate
    using the `--set-parm` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can select the required resolution and/or pixel format using the
    `--set-fmt-video` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to the frame rate, you would want to use `v4l2-ctl` with the
    `--set-parm` option, giving the frame rate numerator only—the denominator is fixed
    to `1` (only integer frame rate values are allowed)—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Capturing frames and streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`v4l2-ctl` supports many more options than you can imagine. In order to see
    the possible options, you can print the help message of the appropriate section.
    Common help commands related to streaming and video capture are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--help-streaming`: Prints the help message for all options that deal with
    streaming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help-subdev`: Prints the help message for all options that deal with `v4l-subdevX`
    devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help-vidcap`: Prints the help message for all options that get/set/list
    video capture formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From those help commands, I''ve built the following command in order to capture
    a QVGA MJPG compressed frame on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve also managed to capture a raw YUV image with the same resolution with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw YUV image cannot be displayed unless you use a decent raw image viewer.
    In order to do so, the raw image must be converted using the `ffmpeg` tool, for
    example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can notice a big difference in terms of the size between the raw and the
    compressed image, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Do note that it is good practice to include the image format in the filename
    of a raw capture (such as `yuyv` in `grab-320x240-yuyv.raw`) so that you can easily
    convert from the right format. This rule is not necessary with compressed image
    formats because these formats are image container formats with a header that describes
    the pixel data that follows, and can be easily read with the `gst-typefind-1.0`
    tool. JPEG is such a format and the following is how its header can be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with tool usages, let's see how to go deeper and learn
    about V4L2 debugging and from user space.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging V4L2 in user space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our video system setup may not be free of bugs, V4L2 provides a simple
    but large backdoor for debugging from user space, in order to track and shoot
    down trouble coming from either the VL4L2 framework core or the user space API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Framework debugging can be enabled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will instruct V4L2 to add core traces to the kernel
    log message. This way, it will easily track where the trouble is coming from,
    assuming it''s coming from the core. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous kernel log messages, we can see the kernel-related V4L2 core
    functions call, along with some other details. If for any reason the V4L2 core
    tracing is not necessary or not enough for you, you can also enable V4L2 userland
    API tracing with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the command, allowing you to capture a raw image, we can see
    the following in the kernel log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can trace the different V4L2 userland API calls,
    which correspond to the different `ioctl` commands and their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: V4L2 compliance driver testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order for a driver to be V4L2-compliant, it must meet some criteria, which
    includes passing the `v4l2-compliance` tool test, which is used to test V4L devices
    of all kinds. `v4l2-compliance` attempts to test almost all aspects of a V4L2
    device and it covers almost all V4L2 ioctls.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other V4L2 tools, a video device can be targeted using the `-d` or
    `--device=` commands. If a device is not specified, `/dev/video0` is targeted.
    The following is an output excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding logs, we can see that `/dev/video0` has been targeted. Additionally,
    we notice that `Debug ioctls` and `Output ioctls` are not supported by our driver
    (these are not failures). Though the output is verbose enough, it is better to
    use the `--verbose` command as well, which makes the output more user friendly
    and much more detailed. It then goes without saying that if you want to submit
    a new V4L2 driver, that driver must pass the V4L2 compliance tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the user space implementation of V4L2\. We
    started with V4L2 buffer management, from video streaming. We also learned how
    to deal with video device property management, all from user space. However, V4L2
    is a heavy framework, not just in terms of code but also in terms of power consumption.
    So, in the next chapter, we will address Linux kernel power management in order
    to keep the system at the lowest consumption level possible without degrading
    the system properties.
  prefs: []
  type: TYPE_NORMAL

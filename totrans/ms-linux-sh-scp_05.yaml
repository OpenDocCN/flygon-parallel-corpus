- en: Chapter 5. Alternative Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the scripting journey, we have seen that we can use the `test` command
    to determine a conditional status. We have taken this a little further and discovered
    that we can also make use of the single square bracket. Here, we will recap the
    `test` command and look at the single square bracket in more detail. After having
    learned more about the square bracket, we will move onto more advanced variable
    or parameter management; thus, providing defaults and understating quoting issues.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are going to see that within advanced shells like bash, korn, and
    zsh we can go with double brackets! Making use of the double round parenthesis
    and double square bracket can simplify the overall syntax and allow the standardization
    of the use of mathematical symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Test conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing parameter defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt – quote!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced tests using `[[`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced tests using `((`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recapping test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have used the built-in `test` command to drive our conditional statements.
    Using other options with `test`, we can look at the returned value to determine
    the status of files in the file system. Running the test without any option will
    return a false output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Testing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commonly, we can use `test` to check the conditions based around files. For
    example, to test that a file is present, or not, we can use the`-e` option. The
    following command will test the existence of the `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can run this test again, but this time check that the file not only exists
    but is a regular file as opposed to having some special purpose. Specific file
    types can be directories, pipes, links, and so on. The option for a regular file
    is `-f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to open a file from within our script, we will test that the file
    is both a regular file and has the read permission set. To achieve this with `test`,
    we can also include the `-a` option to `AND` multiple conditions together. In
    the following example code, we will use the `-r` condition to check that the file
    is readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the use of `-o` is supported to `OR` two conditions within an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets as not seen before
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to the `test` command, we can implement the same conditional
    tests using the single square bracket. Repeating the previous conditional test
    and omitting the command itself. We will rewrite this, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Many times, even as experienced administrators, we are used to language elements
    and we accept them as they are. I feel many Linux administrators will be surprised
    to learn that `[` is a command for both a shell built-in and a standalone file.
    Using the `type` command we can verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output of this command in the following screenshot confirming
    its existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Square brackets as not seen before](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that on the Raspbian distribution that I am using, there is the built-in
    `[` command and the `/usr/bin/[` command. As we have seen, both these commands
    imitate the `test` command but it requires a closing bracket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know a little more about the `[` command, which is found in bash and
    the earlier Bourne shell; we can now continue to add a little command-line list
    syntax. In addition to the command-line list, we can see the desired functionality
    working in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having set the parameter `FILE` variable, we can test that it is both a regular
    file and is readable by the user before attempting to list the file contents.
    In this way, the script becomes more robust without the need for a complex script
    logic. We can see the code in use in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Square brackets as not seen before](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This type of abbreviation is quite common and is easily recognizable. We should
    always be cautious of using abbreviations if they do not add readability. Our
    aim in scripting should be to write a clear and understandable code and avoid
    shortcuts if they do not add to this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Providing parameter defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within bash parameters, there are named spaces in the memory that allow us
    access to stored values. There are two types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special parameters are read-only and are pre-set by the shell. Variables are
    maintained by ourselves as well as bash. In general, when talking about syntax,
    bash will refer to variables by their family name of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables are one type of parameter. These can be set by the system or by ourselves.
    For example, `$USER` is a variable parameter that is set by the system but can
    be written by us. As such, it is not a read-only requisite of special parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Special parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Special parameters are the second parameter type and are managed by the shell
    itself and are presented as read-only. We have come across these before in parameters,
    such as `$0` but let''s take a look at another `$-`. We can expand these parameters
    to gain an understanding of their use, using the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the annotated text that I have added, we can understand that the `$-` option
    represents the shell options that are configured. These can be displayed using
    the `set -o` command but it can be read programmatically using `$-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Special parameters](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The options set here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`h`: This is hashall that allows for programs to be found using the `PATH`
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: This shows that this is an interactive shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: This is short for monitor, which allows the use of the `bg` and `fg` commands
    to bring commands in and out of the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`B`: This allows the brace expansion or `mkdirdir{1,2}` where we create `dir1`
    and `dir2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This allows history expansion or running commands, such as `!501` to repeat
    commands from history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using either the `test` command or the brackets, we can provide default values
    for variables, including command-line parameters. Taking the `hello4.sh` script
    we worked with earlier, we can modify it and set the `name` parameter if it is
    zero bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is functional but it is our choice how we code in the default value.
    We can alternatively assign a default value directly to the parameter. Consider
    the following code, where a default assignment is made directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In bash, this is known as **parameter substitution** and can be written in
    the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Wherever a variable (parameter) has not been declared and has a null value
    the default value will be used. If the parameter has been explicitly declared
    with a null value, we will use the `:-` syntax, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By editing the script now, we can create `hello8.sh` to make use of bash parameter
    substitution to provide the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This script and its output, both with and without a supplied value, are shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting defaults](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `hello8.sh` script provides the functionality that we need with the logic
    built directly into the parameter assignment. The logic and assignment now are
    a single line of code within the script and it is a major step in keeping the
    script simple and maintaining the readability.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt – Quote!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having established that variables are a type of parameter, we should always
    keep this in mind, especially, when reading manuals and HOWTOs. Often the documentation
    refers to parameters and in doing so they include variables, as well as, the bash
    special parameters, such as `$1` and so on. In keeping with this, we will look
    at why it is advisable to quote the parameters when we use them on the command
    line or within scripts. Learning this now can save us a lot of pain and heartache
    later, especially, when we start looking at loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the correct term that we should use for reading the value of variables
    is **parameter expansion**. To you and me this is reading a variable, but to bash
    this would be too simple. The assignment of a correct name, such as parameter
    expansion reduces any ambiguity to its meaning but adds complexity at the same
    time. In the following example, the first line of code assigns the value of `fred`
    to the `name` parameter. The second line of code uses parameter expansion to print
    the stored value from memory. The `$` symbol is used to allow the expansion of
    the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we have used the double quotes to allow `echo` to print the
    single string as we have used spaces. Without the use of quotes, the echo might
    have seen this as multiple arguments. The space being the default field separator
    in most shells including bash. Often, when we do not think to use the quotes,
    we do not see the spaces directly. Consider the following extract of command-line
    code that we made use of earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this worked, we may have been a little fortunate, especially, if
    we were populating the `FILE` parameter from a list of files that we had not created
    ourselves. It is quite conceivable that a file can have spaces within its name.
    Let''s now replay this code using a different file. Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even though structurally there has been no change to the code, it now fails.
    This is because we are providing too many arguments to the `[` command. The failing
    result will be the same even if we use the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we have correctly quoted the assignment of the file name to the
    parameter `FILE`, we have `NOT` protected the spaces when the parameter is expanded.
    We can see the code failing, as it is captured in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When in doubt – Quote!](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that this will not be ready for our scripts. Alas, what we once thought
    as robust, is now in tatters and like the Titanic, our code has sunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a simple solution is to revert to quoting parameter expansion unless,
    specifically, not desired. We can make this ship unsinkable by a simple edit to
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proudly stand on the White Star Line dock, as we see the Titanic
    II get launched in the following code example, which is captured in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When in doubt – Quote!](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is truly amazing and sometimes just a little unbelievable what affect these
    tiny quotes can have. We should never ignore the quotes when expanding variables.
    To ensure that we drill home this point, we can highlight this phenomenon in another
    even simpler example. Let''s take the scenario where we now just want to remove
    the file. In the first example we do not use quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce failures as the parameter expansion will lead to the
    following perceived command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code will fail because it is unable to find the `my` file or the `file`
    file. Even worse, potentially, we could be deleting incorrect files if any of
    the names could be resolved accidently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas quoting the parameter expansion will save the day, as we see in the
    second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is correctly expanded to the desired command that we illustrate in the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I certainly hope that these examples demonstrate the need for care when expanding
    parameters and you are aware of the pit-falls.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced test using [[
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of the double brackets `[[ condition ]]` allows us to do more advanced
    condition testing but is not compatible with the Bourne Shell. The double brackets
    were first introduced as a defined keyword in the korn shell and are also available
    in bash and zsh. Unlike the single bracket, this is not a command but a keyword.
    The use of the type command can confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Whitespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fact that `[[` is not a command is significant where whitespace is concerned.
    As a keyword, `[[` parses its arguments before bash expands them. As such, a single
    parameter will always be represented as a single argument. Even though it goes
    against best practice, `[[` can alleviate some of the issues associated with whitespace
    within parameter values. Reconsidering the condition we tested earlier, we can
    omit the quotes when using `[[` ,as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We still need to quote the parameter when using `cat` as you can see and we
    can use quotes within the double brackets but they become optional. Note we can
    also use the more traditional `&&` and `||` to represent `-a` and`-o` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Other advanced features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the extra features that we can include with the double brackets. Even
    if we lose portability in using them, there are some great features that overcome
    the loss. Remember that if we only use bash then we can use the double brackets
    but can't run our scripts in the Bourne Shell. The advanced features that we gain
    which are covered in the following sections include pattern matching and regular
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the double brackets we can do more than just match strings, we can use
    pattern matching. For example, we may need to work exclusively with Perl scripts,
    files that end with `.pl`. We will be able to implement this easily within a condition
    by including the pattern as a match, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are not limited to simple pattern matches using the `=~` operator, we can
    additionally match regular expressions. We could rewrite the last example using
    a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the single dot or period has a special meaning in regular expressions, we
    need to escape it with `\`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the regular expression matching working with
    a file called `my.pl` and another called `my.apl`. The match correctly shows for
    the file that ends in `.pl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regular expressions](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expression script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The power of regular expressions cannot be dismissed. Another simple demonstration
    of conditional testing using regular expressions will be to expose the US and
    UK spelling of color: being color and colour. We may prompt the user if they want
    a color or mono output for the script but at the same time cater for both spellings.
    The line that will do the work in the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The regular expression caters to both spellings of color by making the u optional:
    u?. Furthermore, we can disable case sensitivity allowing for *COLOR* and color
    by setting a shell option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This option can be disabled again at the end of the script with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we use the variable parameters that we have named `$GREEN` and `$RESET`
    we affect the color of the output. The color green will only be shown where we
    have sourced the color definition file. This is set when we choose the color display.
    Selecting mono will ensure that the variable parameters are null and have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Regular expression script](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Arithmetic operations using ((
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using bash and some other advanced shells, we may make use of the `(( ))`
    notation to simplify mathematical operations with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Simple math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The double parenthesis construct in bash allows for arithmetic expansion. Using
    this in the simplest format, we can easily carry out integer arithmetic. This
    becomes a replacement for the `let` built-in. The following examples show the
    use of the `let` command and the double parenthesis to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the `a` parameter is populated with the sum of `2 + 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps, a little more useful to us in scripting is the C-style parameter manipulation
    that we can include using the double parenthesis. We can often use this to increment
    a counter within a loop and also put a limit on the number of times the loop iterates.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this example, we first set `COUNT` to `1` and then we increment it with
    the `++` operator. When it is echoed in the final line, the parameter will have
    a value of `2`. We can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parameter manipulation](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can achieve the same result in long-hand by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This of course allows for any increment of the `COUNT` parameter and not just
    a single unit increase. Similarly, we can count down using the `--` operator,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start using a value of `10`, reducing the value by `1` within the double
    parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we do not use the `$` to expand the parameters within the parenthesis.
    They are used for parameter manipulation and as such we do not need to expand
    parameters explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Standard arithmetic tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another advantage that we can gain from these double parentheses is with the
    tests. Rather than having to use `-gt` for greater than we can simply use `>`.
    We can demonstrate this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates this for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard arithmetic tests](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is this standardization, both in the C-style manipulation and tests, that
    make the double parenthesis so useful to us. This use extends to both, the command
    line and in scripts. We will use this feature extensively when we look at looping
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this chapter, I really hope that we have introduced many new and interesting
    choices to you. This was an area with a wide range where we began recapping on
    the use of test and discovered that the `[` is a command is not a syntax construct.
    The main effect that it is a command is on whitespace and we looked at the need
    to quote variables.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we may commonly call variables as variables. We have also seen that
    their correct name, especially in documentation is parameters. Reading a variable
    is a parameter expansion. Understanding parameter expansion can help us understand
    the use of the keyword `[[`. The double square brackets are not commands and do
    not expand the parameters. This means that we do not need to quote variables even
    if they do contain whitespace. Moreover, we can use advanced tests with double
    square brackets, such as pattern matching or regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at arithmetic expansion and parameter manipulation using
    the double parenthesis notation. The biggest feature this delivers is the possibility
    to easily increment and decrement counters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move into the looping constructs found in bash
    and make use of some of our new found skills from this chapter.
  prefs: []
  type: TYPE_NORMAL

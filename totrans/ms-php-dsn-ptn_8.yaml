- en: Chapter 8. How to Write Better Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter in this book. We've discussed a lot of patterns, but
    in this final chapter I want us to discuss how these patterns can be applied.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: I want us here to talk about the bigger picture about how our code fits together,
    and what the key takeaways are for us to write great code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, I would like to discuss where patterns are suited to our
    application in the development phase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following points:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The nature of an HTTP request
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful API design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep It Simple, Stupid
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software development life cycle and engineering practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A light introduction to BDD
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nature of a HTTP request
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers find HTTP requests are abstracted away from them; indeed, many
    PHP developers will never need to understand how an HTTP request actually works
    under the hood.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: PHP developers often work with HTTP networks when developing. Indeed, PHP contains
    some core functions that are great when working with HTTP communication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an HTTP request at a high-level using a tool called **curl**.
    The curl is essentially a command-line tool that allows us to simulate network
    requests. It allows you to simulate the transfer of data using various protocols.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of *cURL* originally stood for *see URL*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The curl projects produce both the `libcurl` and `curl` command line tool. Libcurl
    is a library that PHP supports, allowing you to connect and communicate over a
    list of protocols in PHP, providing your installation has it installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In this case, however, we will be using the command-line tool to simulate requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by making a simple `curl` request to a given website, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Depending on the site you query in the command you will notice that the Terminal
    output is blank:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Nature of a HTTP request](graphics/image_08_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: What's going on here? In order to find out, we need to dig a little further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-v` argument in the `curl` command so we see a verbose output
    of what''s going on:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This output of this is substantially different:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Nature of a HTTP request](graphics/image_08_002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: With this output we can see the headers that are sent and the headers that are
    received.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The block starting with asterisks `*` indicates the connection being established.
    We can see how curl has rebuilt the URL so it is correct (containing a forward
    slash at the end), then resolved the IP address of the server (in my case, an
    IPv6 address), and then finally established the connection to the web server:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The hostname is turned into an IP address by querying the DNS server; we'll
    go into more detail about this later on. But at this point, it is important to
    remember that, after this point, the connection to the server is established using
    an IP address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to get rid of the forward slash at the end, we can actually see
    that in the first line, rebuilding the URL will disappear, as it will already
    be in the correct format before we even make the request:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Nature of a HTTP request](graphics/image_08_003.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Next let's look at the succeeding lines the asterisks. We see the outbound headers
    in the greater than signs `>`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'These headers look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So the first message we see is the request method `GET`, followed by the endpoint
    `/` and the protocol `HTTP/1.1`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `Host` header, which tells us the domain name of the server
    and can also contain the TCP port number on which the server is listening, but
    this is often amended if the port is standard for the service requested. Why is
    this needed, though? Suppose a server contains many VirtualHosts; this is what
    actually allows the server to determine between VirtualHosts using the header.
    VirtualHosting essentially allows a server to host more than one domain name.
    In order to do this, we need this header; when a server sees a HTTP request coming
    in they won't see the header.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Remember when I said a connection is established using an IP address? This `Host`
    header is what allows us to send through that hostname variable indicating what
    an IP address is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我说过连接是使用IP地址建立的吗？这个`Host`头部允许我们通过发送主机名变量来指示IP地址是什么。
- en: Next, we see the `User-Agent` header, indicating what browser the client is
    using; our `User-Agent` header in this request indicates we are sending our HTTP
    request using curl command. Remember not to trust any HTTP headers from the client,
    as they can be manipulated to contain whatever data a malicious adversary wants
    to put into them. They can contain everything from a fake browser identifier to
    a SQL injection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`User-Agent`头部，指示客户端使用的浏览器；在这个请求中，我们的`User-Agent`头部表示我们正在使用curl命令发送我们的HTTP请求。记住不要相信来自客户端的任何HTTP头部，因为它们可以被操纵以包含恶意对手想要放入其中的任何数据。它们可以包含从伪造的浏览器标识符到SQL注入的一切。
- en: 'Finally, the `Accept` header indicates the `Content-Type` headers that are
    acceptable for the response. Here, we see a wildcard acceptance, indicating we
    are happy to receive whatever the server is sending us. In other cases, we can
    use `Accept: text/plain` to indicate that we want to see plaintext, or `Accept:application/json`
    for JSON. We can even specify if we want to receive a JPG image by using `Accept:
    image/jpg`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`Accept`头部指示了响应可接受的`Content-Type`头部。在这里，我们看到了通配符接受，表示我们愿意接收服务器发送给我们的任何内容。在其他情况下，我们可以使用`Accept:
    text/plain`来表示我们想要看到纯文本，或者`Accept:application/json`来表示JSON。我们甚至可以通过使用`Accept:
    image/jpg`来指定是否要接收JPG图像。'
- en: 'There are various parameters that can also be sent to over an `Accept` header;
    for example, we can request HTML using a UTF-8 charset with Accept: `text/html`;
    `charset=UTF-8`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '还有各种参数也可以通过`Accept`头部发送；例如，我们可以使用`Accept: text/html; charset=UTF-8`来请求使用UTF-8字符集的HTML。'
- en: 'At a basic level, the syntax that is permissible in this header looks like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本级别上，这个头部中允许的语法看起来像这样：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The server can indicate the content type being returned to the user using a
    `Content-Type` header in the response. So the server can send a header back to
    the end user as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以使用响应中的`Content-Type`头部指示返回给用户的内容类型。因此，服务器可以向最终用户发送一个头部，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Moving onto the topic of the response, let''s take a look at the response.
    These are prefixed with <:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于响应的话题，让我们来看看响应。这些都是以<:为前缀的。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So the first thing we get in the response indicating the format and the status
    code. HTTP/1.1 indicates that we are receiving a `HTTP/1.1` response, and a `301
    Moved Permanently` message indicates a permanent redirect. Accordingly, we also
    receive a `Location: https://junade.com/ header`, which tells us where to go next.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，我们在响应中首先得到的是格式和状态码。HTTP/1.1表示我们正在接收一个`HTTP/1.1`响应，而`301 Moved Permanently`消息表示永久重定向。因此，我们还收到了一个`Location:
    https://junade.com/`头部，告诉我们接下来去哪里。'
- en: The `Server` header indicates the signature of the web server that is supplying
    our request. It could be Apache or Nginx; in this case, it's the modified version
    of Nginx that CloudFlare use for their network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server`头部指示了提供我们请求的网络服务器的签名。它可以是Apache或Nginx；在这种情况下，它是CloudFlare用于他们的网络的修改版本的Nginx。'
- en: The Set-Cookie header is used to indicate what cookies the browser should set;
    the standard for this is in a document known as RFC 6265.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set-Cookie`头部用于指示浏览器应该设置哪些cookie；这方面的标准在一份名为RFC 6265的文档中。'
- en: '**RFC** stands for **Request for Comments**; there are a number of types of
    RFC. Standards Track RFCs are those intending to become Internet Standards (STDs),
    whereas Informational RFCs can be anything. There are a number of other types
    of RFC, such as Experimental, Best Current Practice, Historic, and even an Unknown
    RFC type for those where the status is unclear if they were to be published today.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**RFC**代表**请求评论**；有许多类型的RFC。标准跟踪RFC是那些打算成为互联网标准（STDs）的RFC，而信息性RFC可以是任何东西。还有许多其他类型的RFC，比如实验性的，最佳当前实践，历史性的，甚至是未知的RFC类型，用于那些如果今天发布的话状态不清楚的RFC。'
- en: The `Transfer-Encoding` header indicates the encoding used to transfer the entity
    to the user, which could be anything from chunked even to something such as gzip,
    which is a compressed entity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transfer-Encoding`头部指示了用于将实体传输给用户的编码，可以是任何东西，从分块甚至到像gzip这样的压缩实体。'
- en: Interestingly, the `HTTP/2` protocol that was published in RFC 7540 in May 2015
    actually allows header compression. Nowadays, we send more in header data than
    was originally transmitted when the `HTTP/1` protocol was created (the original
    `HTTP` protocol didn't even contain a `Host` header!).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，2015年5月发布的RFC 7540实际上允许头部压缩。如今，我们发送的头部数据比创建`HTTP/1`协议时原始传输的数据更多（原始的`HTTP`协议甚至没有`Host`头部！）。
- en: The `Connection` header provides control options for the connection. It allows
    the sender to specify the options that are desired for the current connection.
    Finally, the `Date` header indicates the date and time when the message was sent.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection`头部提供了连接的控制选项。它允许发送者指定当前连接所需的选项。最后，`Date`头部指示了消息发送的日期和时间。'
- en: 'Consider this: can an HTTP request/response contain more than one of the same
    header of the name?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下：一个HTTP请求/响应中是否可以包含多个相同名称的头部？
- en: Yes, this is particularly useful in some headers, such as the `Link` header.
    This header is used to perform `HTTP/2` Server Push; Server Push allows the server
    to push requests to the client before they are requested. One asset can be specified
    per header; therefore, multiple headers are needed to push multiple assets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这在一些头部中特别有用，比如`Link`头部。这个头部用于执行`HTTP/2`服务器推送；服务器推送允许服务器在被请求之前向客户端推送请求。每个头部可以指定一个资源；因此，需要多个头部来推送多个资源。
- en: 'This is something we can do in PHP. Take the following `header` function call
    in PHP:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在PHP中可以做的事情。在PHP中，使用以下`header`函数调用：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While the first argument is the string of the actual header we're sending, the
    second argument (`false`) states that we don't want to replace a previous header
    of the same, instead we want to send this one as well but not replace it. By setting
    this flag to `true` we instead state that we want to override the previous header;
    this is the default option if the flag isn't specified at all.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个参数是我们发送的实际标头的字符串，但第二个参数（“false”）表示我们不希望替换同样的先前标头，而是希望发送这个标头，但不替换它。通过将此标志设置为“true”，我们反而声明要覆盖先前的标头；如果根本没有指定标志，则这是默认选项。
- en: 'Finally, when the request is closed you will see a final asterisk indicating
    the connection was closed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当请求关闭时，您将看到最终的星号，表示连接已关闭：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Typically, this will become below the body if there is one. In this request,
    there wasn't one as it was merely a redirect.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果有主体，它将出现在主体下面。在此请求中，由于只是重定向，所以没有主体。
- en: 'I now make a `curl` request to where that `Location` header is pointing using
    the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用以下命令向“Location”标头指向的位置发出“curl”请求：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will now notice that the connection close message came after the end of
    the HTML body:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在会注意到，连接关闭消息出现在HTML主体结束后：
- en: '![Nature of a HTTP request](graphics/image_08_004.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_004.jpg)'
- en: Let's now try exploring a few HTTP methods. In REST APIs you will frequently
    use `GET`, `POST`, `PUT`, and `DELETE`; but first we'll start by exploring two
    others, `HEAD` and `OPTIONS`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试探索一些HTTP方法。在REST API中，您经常会使用“GET”、“POST”、“PUT”和“DELETE”；但首先，我们将先探索另外两种方法，“HEAD”和“OPTIONS”。
- en: An `HTTP OPTIONS` request details which requests methods you can use on a given
    endpoint. It provides information about which communication options are available
    to that particular endpoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “HTTP OPTIONS”请求详细说明了您可以在给定端点上使用哪些请求方法。它提供了有关特定端点可用的通信选项的信息。
- en: Let me demonstrate this. I'm going to be using a service called `HTTPBin`, which
    allows me to make requests to over curl to get some responses back from a real
    server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我演示一下。我将使用一个名为“HTTPBin”的服务，它允许我通过curl向真实服务器发出请求并获得一些响应。
- en: 'Here''s an `OPTIONS` request I''m making using curl:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用curl发出的“OPTIONS”请求：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-X` option allows us to specify a particular HTTP request type instead
    of just defaulting to curl.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “-X”选项允许我们指定特定的HTTP请求类型，而不仅仅是默认的curl。
- en: 'Let''s see what this looks like once executed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行后的样子：
- en: '![Nature of a HTTP request](graphics/image_08_005.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_005.jpg)'
- en: Firstly, you'll notice that, given the request is over HTTP, you will see some
    extra information in the asterisk; this information contains the TLS certificate
    information that is used to encrypt the connection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会注意到，由于请求是通过HTTP进行的，您将在星号中看到一些额外的信息；这些信息包含用于加密连接的TLS证书信息。
- en: 'Take a look at the following line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下一行：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`TLS 1.2` indicates the version of transport layer security we''re dealing
    with; the second part, which states `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, indicates
    the cipher suite for the connection.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “TLS 1.2”表示我们正在处理的传输层安全版本；第二部分，即“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”，表示连接的密码套件。
- en: The cipher suite starts by detailing that we're dealing with `TLS. ECDHE_RSA`
    indicates that the key exchange is done using elliptic curve Diffie-Hellman. The
    key exchange essentially allows the encryption keys to be transmitted securely.
    By using elliptic curve cryptography, a particular key can be shared, which can
    then be used to encrypt data later on. `ECDHE_RSA` means that we use elliptic
    curve Diffie-Hellman to share a key based on an RSA key that the server has gotten.
    There are a number of other key exchange algorithms; for example, `ECDH_ECDSA`
    uses Fixed ECDH with ECDSA-signed certificates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 密码套件首先详细说明了我们正在处理的“TLS”。 ECDHE_RSA表示密钥交换是使用椭圆曲线Diffie-Hellman完成的。密钥交换基本上允许安全地传输加密密钥。通过使用椭圆曲线密码学，可以共享特定的密钥，然后可以用于以后加密数据。
    “ECDHE_RSA”表示我们使用椭圆曲线Diffie-Hellman来共享基于服务器获取的RSA密钥的密钥。还有许多其他密钥交换算法；例如，“ECDH_ECDSA”使用带有ECDSA签名证书的固定ECDH。
- en: The access-control prefixed headers are used for a mechanism called CORS, which
    essentially allows JavaScript to make cross-origin API requests; let's not worry
    about this here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以access-control为前缀的标头用于一种称为CORS的机制，它基本上允许JavaScript进行跨源API请求；让我们不在这里担心这个。
- en: The header we do need to worry about with an `OPTIONS` request is the `Allow`
    header. This details what request methods we're allowed to submit back to that
    particular endpoint.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要担心的“OPTIONS”请求的标头是“Allow”标头。这详细说明了我们被允许向特定端点提交哪些请求方法。
- en: 'Therefore, this is the request we get when we query the `/get` endpoint:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们查询“/get”端点时收到的请求：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the endpoint I use here uses the `/get` endpoint. Instead, let''s
    make another `OPTIONS` request to the `/post` endpoint using the following `curl`
    request:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在此处使用的端点使用了“/get”端点。相反，让我们使用以下“curl”请求向“/post”端点发出另一个“OPTIONS”请求：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the response we get back:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们收到的回复：
- en: '![Nature of a HTTP request](graphics/image_08_006.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_006.jpg)'
- en: You'll notice that the `Allow` header now contains `POST` and `OPTIONS`. Also
    note that the `HEAD` option has gone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，“Allow”标头现在包含“POST”和“OPTIONS”。还要注意，“HEAD”选项已经消失。
- en: You'll soon find out that a `HEAD` request is very similar to a `GET` request
    except without a message body. It merely returns the headers of a HTTP request
    but not the body of a request. Thus, it allows you to get the meta information
    about an entity without needing to get the complete response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您很快会发现，“HEAD”请求与“GET”请求非常相似，只是没有消息主体。它仅返回HTTP请求的标头，而不是请求的主体。因此，它允许您获取有关实体的元信息，而无需获取完整的响应。
- en: 'Let''s make a HEAD request to a `/get` endpoint:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向“/get”端点发出HEAD请求：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of using the `-v` (verbose) option in this request, I''m using the
    `-I` option, which will merely get the `HTTP` header. This is well suited to making
    an HTTP request using the `HEAD` option:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个请求中，我没有使用`-v`（冗长）选项，而是使用了`-I`选项，它只会获取`HTTP`头。这非常适合使用`HEAD`选项进行HTTP请求：
- en: '![Nature of a HTTP request](graphics/image_08_007.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_007.jpg)'
- en: As you can see, we get the type of the response in the `Content-Type` header.
    Alongside this, you'll get the length of the request in the `Content-Length` header.
    The length is measured in octets (8 bits); you might think that is is the same
    as a byte, but a byte is not necessarily 8 bits on all architectures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在`Content-Type`头部中得到了响应的类型。除此之外，您还将在`Content-Length`头部中得到请求的长度。长度以八位字节（8位）来衡量；您可能认为这与字节相同，但在所有架构上，字节并不一定是8位。
- en: There are a number of other headers that can be sent to express meta information.
    This may include standard headers or non-standard headers to express other information
    that you can't express in standardized RFC-backed headers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他头部可以发送以表达元信息。这可能包括标准头部或非标准头部，以表达您无法在标准化的RFC支持的头部中表达的其他信息。
- en: '**HTTP ETags** (**entity tags**) are a mechanism that provide cache validation.
    You can use them in the context of RESTful APIs for optimistic concurrency control;
    this basically allows multiple requests to complete without needing to interfere
    with each other. This is quite an advanced API concept, so I won''t go into too
    much detail here.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP ETags**（实体标签）是一种提供缓存验证的机制。您可以在RESTful API的上下文中使用它们进行乐观并发控制；这基本上允许多个请求完成而无需相互干预。这是一个非常先进的API概念，所以我在这里不会详细介绍。'
- en: Note that in both our `HTTP HEAD` and `OPTIONS` request we both got `200 OK`
    header messages. A `200` status code indicates a successful HTTP request.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的`HTTP HEAD`和`OPTIONS`请求中，我们都收到了`200 OK`头消息。`200`状态代码表示成功的HTTP请求。
- en: 'There are many different types of status code. They are categorized as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的状态代码。它们被分类如下：
- en: '**1xx messages**: Informational'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1xx消息**：信息'
- en: '**2xx messages**: Success'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2xx消息**：成功'
- en: '**3xx messages**: Redirect'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3xx消息**：重定向'
- en: '**4xx messages**: Client Error'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4xx消息**：客户端错误'
- en: '**5xx messages**: Server Error'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5xx消息**：服务器错误'
- en: An informational header could be a `101` response, which indicates the client
    is switching protocols and the server has agreed to do so. You probably won't
    encounter informational header messages if you're developing RESTful APIs; these
    are most likely things that will be sent by the web server, which is abstracted
    away from you as a developer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 信息头可能是`101`响应，表示客户端正在切换协议，服务器已同意这样做。如果您正在开发RESTful API，您可能不会遇到信息头消息；这些最有可能是由Web服务器发送的，这对于您作为开发人员来说是抽象的。
- en: Correct use of the other HTTP status codes is vital for correct development
    of a API, particularly one that is RESTful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他HTTP状态代码的正确方式对于正确开发API至关重要，特别是对于RESTful API。
- en: Success status codes aren't just limited to a `200 OK` message; 201 Created
    indicates a request has been fulfilled that has created a new resource. This is
    particularly useful when a `PUT` request is made to create a new resource or using
    `POST` to create a subsidiary resource. `202 Accepted` indicates a request has
    been accepted for processing but processing has not been completed, which is useful
    in a distributed system. `204 No Content` indicates the server has processed the
    request and is not returning any information; a `205 Reset Content` header does
    the same but asks the requester to reset their document view. These are just a
    few 200's messages; there are obviously many more.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 成功状态代码不仅限于`200 OK`消息；201 Created表示已满足已创建新资源的请求。当使用`PUT`请求创建新资源或使用`POST`创建子资源时，这是特别有用的。`202
    Accepted`表示已接受请求进行处理，但处理尚未完成，这在分布式系统中非常有用。`204 No Content`表示服务器已处理请求并且不返回任何信息；`205
    Reset Content`头部也是如此，但要求请求者重置其文档视图。这只是一些200的消息；显然还有许多其他消息。
- en: Redirection messages include `301 Moved Permanently`, which we showed in our
    first `curl` example, whereas `302 Found` can be used for more temporary redirects.
    Again, there are other message codes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向消息包括`301 Moved Permanently`，这是我们在第一个`curl`示例中展示的，而`302 Found`可以用于更临时的重定向。同样，还有其他消息代码。
- en: Client error codes include the infamous `404 Not Found` message when a resource
    cannot be found. Alongside this, we have `401 Unauthorized` when authentication
    is required but not provided, `403 Forbidden` is where a server refuses to respond
    to a request at all (for example, incorrect permissions). `405 Method Not Allowed`
    allows us to deny requests on the basis of them being submitted using an invalid
    request method, which is, again, very useful for RESTful APIs. `405 Not Acceptable`
    is a response where the server cannot generate a response in accordance with the
    `Accept` header sent to it. Again, there are numerous other 4xx HTTP codes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端错误代码包括臭名昭著的`404 Not Found`消息，当找不到资源时。除此之外，我们还有`401 Unauthorized`，表示需要身份验证但未提供，`403
    Forbidden`表示服务器拒绝响应请求（例如，权限不正确）。`405 Method Not Allowed`允许我们基于使用无效请求方法提交请求来拒绝请求，这对于RESTful
    API非常有用。`405 Not Acceptable`是一个响应，其中服务器无法根据发送给它的`Accept`头部生成响应。同样，还有许多其他4xx的HTTP代码。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: HTTP code 451 indicates a request is unavailable for legal reasons. The code
    chosen after *Fahrenheit 451*, a novel named after the author claimed 451 Fahrenheit
    was the auto-ignition temperature of paper.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代码451表示由于法律原因请求不可用。选择的代码是*华氏451度*，一部以451华氏度为书名的小说，作者声称451华氏度是纸张的自燃温度。
- en: Finally, `Server Errors` allow the server to indicate they failed to fulfill
    a request that was apparently valid. These messages included the `500 Internal
    Server Error`, which is a generic error message given when an unexpected condition
    is encountered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`服务器错误`允许服务器指示他们未能满足明显有效的请求。这些消息包括`500 Internal Server Error`，这是在遇到意外条件时给出的通用错误消息。
- en: 'Let''s now look at making a `GET` request. The `curl`, by default will make
    a `GET` request if we don''t specify any data to send or a particular method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何进行`GET`请求。默认情况下，`curl`会发出一个`GET`请求，如果我们没有指定要发送的数据或特定的方法：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also specify that we want a `GET` request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以指定我们想要一个`GET`请求：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出如下：
- en: '![Nature of a HTTP request](graphics/image_08_008.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_008.jpg)'
- en: Here, you can see we get the same headers as we did in the `HEAD` request, with
    the addition of a body; some JSON data of whatever resource we're trying to access.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们得到了与`HEAD`请求中相同的标头，另外还有一个主体；一些JSON数据，无论我们试图访问的资源是什么。
- en: 'There we get a `200 Success` message, but let''s make a HTTP request to an
    endpoint that doesn''t exist so we can trigger a 404 message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们得到了一个`200 Success`的消息，但让我们向一个不存在的端点发出HTTP请求，这样我们就可以触发一个404消息：
- en: '![Nature of a HTTP request](graphics/image_08_009.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_009.jpg)'
- en: As you can see, we get a header stating `404 NOT FOUND` instead of our usual
    `200 OK` message.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们得到了一个标头，上面写着`404 NOT FOUND`，而不是我们通常的`200 OK`消息。
- en: '`HTTP 404` responses can also come without a body:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP 404`响应也可以没有主体：'
- en: '![Nature of a HTTP request](graphics/image_08_010.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_010.jpg)'
- en: While `GET` requests merely show an existing resource, `POST` requests allow
    us to modify and update a resource. `PUT` requests instead allow us to create
    a new resource or override one, but specifically at a given endpoint.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`GET`请求只是显示一个现有的资源，`POST`请求允许我们修改和更新一个资源。相反，`PUT`请求允许我们创建一个新资源或覆盖一个资源，但是特定于给定的端点。
- en: What's the difference? `PUT` is idempotent, while `POST` is not idempotent.
    A `PUT` is like setting a variable, `$x = 3`. You can do it over and over again,
    but the output is the same, `$x` is `3`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么区别？`PUT`是幂等的，而`POST`不是幂等的。`PUT`就像设置一个变量，`$x = 3`。你可以一遍又一遍地做，但输出是一样的，`$x`是`3`。
- en: '`POST` is, instead, a lot like running `$x++`; it causes a change that is not
    idempotent, the same way as `$x++` can''t be repeated over and over to give the
    same exact variable. `POST` updates a resource, adds a subsidiary resource, or
    causes a change. `PUT` is instead used when you know the URL you want to create.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`就像运行`$x++`一样；它会引起一个不是幂等的变化，就像`$x++`不能一遍又一遍地重复以得到完全相同的变量一样。`POST`更新一个资源，添加一个辅助资源，或者引起一个变化。当你知道要创建的URL时，就会使用`PUT`。'
- en: '`POST` can be used to create when you know the URL of the factory that creates
    the resource for you.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道创建资源的工厂的URL时，可以使用`POST`来创建。
- en: 'So, for example, if the endpoint/user wants to generate a user account with
    a unique ID, we would use this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果端点/用户想要生成一个具有唯一ID的用户帐户，我们将使用这个：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But if we wanted to create a user account at a particular endpoint, we would
    use `PUT`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要在特定的端点创建一个用户帐户，我们将使用`PUT`：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, if we want to overwrite `tom` at the given endpoint, we can put
    another `PUT` request there:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想要在给定的端点上覆盖`tom`，我们可以在那里放置另一个`PUT`请求：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But suppose we don''t know Tom''s endpoint; instead, we just want to `PUT`
    to an endpoint with a user ID argument and some information will be updated:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们不知道Tom的端点；相反，我们只想向一个带有用户ID参数的端点发送`PUT`请求，并且一些信息将被更新：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hopefully that makes sense!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这是有意义的！
- en: Now let's take a look at a given`HTTP POST` request.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个给定的`HTTP POST`请求。
- en: 'We can create a request using URL encoded data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用URL编码的数据创建一个请求：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that if we specify data but not a request type in `curl` it will default
    to `POST`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在`curl`中指定了数据但没有指定请求类型，它将默认为`POST`。
- en: 'If we execute this, you can see the `Content-Type` is `x-www-form-urlencoded`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个，你会看到`Content-Type`是`x-www-form-urlencoded`：
- en: '![Nature of a HTTP request](graphics/image_08_011.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_011.jpg)'
- en: 'However, we can also submit JSON data to the endpoint if the API allows us
    to and accepts that format:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果API允许我们并接受这种格式，我们也可以向端点提交JSON数据：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This provides the following output, noting the `Content-Type` is now JSON instead
    of `x-www-form-urlencoded` form it was before:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了以下输出，注意`Content-Type`现在是JSON，而不是之前的`x-www-form-urlencoded`表单：
- en: '![Nature of a HTTP request](graphics/image_08_012.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_012.jpg)'
- en: 'We can now make a HTTP request using `PUT` by sending the same data to the
    `/put` endpoint:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过向`/put`端点发送相同的数据来进行`PUT`的HTTP请求：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s change the request type over to `PUT`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把请求类型改成`PUT`：
- en: '![Nature of a HTTP request](graphics/image_08_013.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_013.jpg)'
- en: 'Let''s make the same request to a `DELETE` endpoint using the following `curl`
    request (in this example, we will submit data):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下`curl`请求向`DELETE`端点发送相同的请求（在这个例子中，我们将提交数据）：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This has the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这有以下输出：
- en: '![Nature of a HTTP request](graphics/image_08_014.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP请求的性质](graphics/image_08_014.jpg)'
- en: In the real world, you might not necessarily need to submit back any information
    related to the fact we've just deleted a resource (that's what `DELETE` is for).
    Instead, we may simply want to submit a `204 No Content` message. Typically, I
    would not pass a message back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你可能并不一定需要提交与我们刚刚删除一个资源相关的任何信息（这就是`DELETE`的作用）。相反，我们可能只想提交一个`204 No Content`消息。通常，我不会传回消息。
- en: '`HTTP/2` at a high level maintains this request structure. Remember that most
    `HTTP/2` implementations require TLS (`h2`) and most browsers do not support `HTTP/2`
    over cleartext (`h2c`), even though it is de facto possible in the RFC standard.
    If using `HTTP/2` you realistically need TLS encryption on the request.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP/2`在高层次上维护了这个请求结构。请记住，大多数`HTTP/2`实现都需要TLS（`h2`），而大多数浏览器不支持明文传输的`HTTP/2`（`h2c`），尽管在RFC标准中实际上是可能的。如果使用`HTTP/2`，你实际上需要在请求上使用TLS加密。'
- en: Woo! That was a mouthful, but that is everything you will need to know about
    an HTTP request, at a very high level. We didn't go into network detail, but this
    understanding is necessary for API architecture.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这真是一大堆，但这就是你需要了解的关于HTTP请求的一切，从一个非常高的层次来看。我们没有深入网络细节，但这种理解对于API架构是必要的。
- en: Now that we have a good understanding of HTTP requests and the methods used
    in HTTP communication, we can move on to understanding what makes an API RESTful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对HTTP请求和HTTP通信中使用的方法有了很好的理解，我们可以继续了解什么使API成为RESTful。
- en: RESTful API design
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API设计
- en: Many developers use and build REST APIs without understanding what makes them
    RESTful. So what actually is *REpresentational State Transfer*? Moreover, why
    is it important that an API is *RESTful*?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员在不了解何为RESTful的情况下使用和构建REST API。那么*REpresentational State Transfer*到底是什么？此外，为什么API是*RESTful*很重要？
- en: There are some key architectural constraints to an API being RESTful, the first
    of these is being stateless in nature.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: API成为RESTful的一些关键架构约束，其中第一个是其无状态性质。
- en: Stateless nature
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态性质
- en: RESTful APIs are stateless; the client's context is not stored on the server
    between requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是无状态的；客户端的上下文在请求之间不会存储在服务器上。
- en: Suppose you create a basic PHP app that has login functionality. After validating
    the user credentials that are put into the login form, you may then go ahead and
    use a session to store a state of the logged in user as they proceed to their
    next state to carry out the next task.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您创建了一个具有登录功能的基本PHP应用程序。在验证放入登录表单的用户凭据之后，您可以使用会话来存储已登录用户的状态，因为他们继续进行下一个状态以执行下一个任务。
- en: This is unacceptable when it comes to a REST API; REST is a stateless protocol.
    The *ST* in REST stand for *State Transfer*; the state of a request should be
    transferred around rather than merely stored on the server. By transferring sessions
    instead of storing them you avoid having *sticky sessions* or *session affinity*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这在REST API中是不可接受的；REST是一种无状态协议。REST中的*ST*代表*State Transfer*；请求的状态应该被传输而不仅仅存储在服务器上。通过传输会话而不是存储它们，您可以避免具有*粘性会话*或*会话亲和性*。
- en: In order for this to be implemented well the HTTP request happens in total isolation.
    Everything the server needs to carry out a `GET`, `POST`, `PUT`, or `DELETE` request
    is in the HTTP request itself. The server never relies on information from a previous
    request.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了很好地实现这一点，HTTP请求在完全隔离的情况下发生。服务器需要执行`GET`，`POST`，`PUT`或`DELETE`请求的所有内容都在HTTP请求本身中。服务器从不依赖于先前请求的信息。
- en: What are the benefits of doing this? Well, firstly it scales so much better;
    the most obvious benefit is that you don't need to store sessions on the server
    at all. This comes with additional functionalities too, when you put your API
    webservers behind a load balancer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是什么？首先，它的扩展性更好；最明显的好处是您根本不需要在服务器上存储会话。这还带来了额外的功能，当您将API Web服务器放在负载均衡器后面时。
- en: Clustering is difficult; clustering a web server with states either means you
    need to have sticky load balancing or you need to have a common store when it
    comes to sessions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是困难的；使用状态对Web服务器进行集群意味着您需要具有粘性负载平衡，或者在会话方面需要具有共同的存储。
- en: Versioning
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: Version your API, you will need to make changes and you don't want them breaking
    your client implementations. This can be done either using headers or in a URL
    itself. For example instead of `/api/resource.json`, you can have space for a
    version tag such as `/api/v1/resource.json`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对API进行版本控制，您需要进行更改，而不希望它们破坏客户端的实现。这可以通过标头或URL本身来完成。例如，可以使用`/api/resource.json`而不是`/api/v1/resource.json`这样的版本标签。
- en: You can also implement the `HTTP Accept` header to perform this behavior or
    even put in place your own header. The client could send a request with the `API-Version`
    header set to `2` and the server will know to communicate to the client using
    version 2 of the API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以实现`HTTP Accept`标头来执行此行为，甚至可以设置自己的标头。客户端可以发送一个带有`API-Version`标头设置为`2`的请求，服务器将知道使用API的第2个版本与客户端进行通信。
- en: Filtering
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: Using a parameter query, we can filter a given by using a parameter. If we're
    dealing with an ordering system on the `/orders` endpoint, it is fairly easy to
    implement basic filtering.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数查询，我们可以使用参数来过滤给定的内容。如果我们在`/orders`端点上处理订单系统，那么实现基本过滤就相当容易。
- en: 'Here, we filter for open orders using the `state` parameter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`state`参数来过滤未完成的订单：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sorting
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: We can also add a `sort` parameter to sort by field. The `sort` field in turn
    contains a list of comma separated columns to sort on; the first in the list is
    the highest sort priority. In order to negatively sort you prefix a column with
    a negative sign `-`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个`sort`参数来按字段排序。`sort`字段反过来包含一个逗号分隔的列列表，以便进行排序；列表中的第一个是最高的排序优先级。为了进行负排序，您可以在列前加上负号`-`
- en: '`GET /tickets?sort=-amount`: sort orders by descending order of amount (highest
    first).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /tickets?sort=-amount`：按金额降序排序订单（最高优先）。'
- en: '`GET /tickets?sort=-amount,created_at`: sort orders by descending order of
    amount (highest first). Within those amounts (with orders of equal amounts), older
    orders are listed first.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /tickets?sort=-amount,created_at`：按金额降序排序订单（最高优先）。在这些金额中（具有相同金额的订单），较早的订单首先列出。'
- en: Searching
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: We can then search using a simple parameter that applies a search query that
    can then be routed through a search service (for example, ElasticSearch).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用一个简单的参数进行搜索查询，然后可以通过搜索服务（例如ElasticSearch）路由该查询。
- en: 'Suppose we want to search orders for the phrase refund, we can define a field
    for search queries:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要搜索包含“refund”短语的订单，我们可以为搜索查询定义一个字段：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Limiting fields
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制字段
- en: 'Additionally, using a `fields` parameter we can query for specific fields:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`fields`参数，我们可以查询特定字段：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Returning new fields
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回新字段
- en: A `PUT`, `POST`, or `PATCH` can change other criteria than the fields we update.
    This might be new timestamps or newly generated IDs. Accordingly, we should return
    the new resource representation on update.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PUT，POST或PATCH可以更改我们更新的字段以外的其他条件。这可能是新的时间戳或新生成的ID。因此，我们应该在更新时返回新的资源表示。
- en: In a `POST` request that has created a resource, you can send an `HTTP 201 CREATED`
    message back, alongside a `Location` header that points to the resource.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt – KISS
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**KISS** is an acronym for **Keep it simple, stupid**.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The KISS principle states that most systems work best if they are kept simple
    rather than complicated. Throughout your programming journey, it is vital that
    this principle in mind.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Deciding to write a program with some predefined design patterns is often a
    poor idea. Code should never be forced into patterns. While writing code for a
    design pattern may work for a *Hello World* demonstration pattern, it doesn't
    usually work well the other way around.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns exist to resolve common recurring problems in code. It is vital
    they are used to address problems and not implemented where no such problems actually
    exist. By keeping your code as simple as possible and reducing the complexity
    of the overall program you are able to reduce the chance of failure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The British Computer Society has published advice called *Senior Management
    in IT Projects* demonstrating that it is vital that the project, people, benefit,
    complexity, and progress are all thoroughly understood; beyond this, it is vital
    the project is fully understood upfront. Why is the project being completed? What
    are the risks? What is the recovery mechanism should the project derail?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Complex systems must handle errors gracefully to be robust. Redundancy must
    be balanced with complexity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Software development life cycle
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chart is an open source diagram that describes the steps of software development:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Software development life cycle](graphics/image_08_015.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: There are many different types of process to produce software, but all must
    contain the steps shown in the chart as they are fundamental to the software engineering
    process.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: While nowadays it almost universally agreed that waterfall software engineering
    methodologies are no longer fit for purpose, the Agile counterparts that replace
    it still require some design (albeit smaller and more iterative) alongside strong
    testing practices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: It is vital that software development is not seen through a microscope and it's
    seen in the broader vision of software engineering.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: On Scrum, and real Agility
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scrum is an iterative software development framework that claims to be Agile,
    based on the process published by the Scrum Alliance. It is graphed out as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![On Scrum, and real Agility](graphics/image_08_016.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Many of us see the disasters left by the Certified Scrum Masters within software
    development teams, who largely use Agile as a buzzword to deliver some simply
    inane processes for writing software.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The Agile manifesto starts with the words, *individuals and interactions over
    processes and tools*. Scrum is a process, and a tightly defined process at that.
    Scrum is often implemented in a way where the development process is emphasized
    over the team. If there is one takeaway from this section, remember the phrase
    *people over processes*. If you choose to implement Scrum, you must be willing
    to adapt and change its processes to cope with change.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of Agile is to be agile; we want to adapt to changing requirements
    rapidly. We want flexibility, we don't want a tightly defined process that restricts
    us from adapting to rapidly changing requirements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Filling in a time sheet, a purchase order, and dealing with bureaucratic governance
    processes do not help put software in customers' hands, so it has to be made as
    light as possible if it cannot go.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Time sheets are the perfect idea of something that is entirely wasteful. They
    are simply used to monitor developer performance, though in some those in management
    will pretend they have some magical agile benefit. They certainly will not help
    you make better software estimations, in any regard; Agile environments should
    seek to use projections over predictions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: I've seen Scrum Masters who endlessly repeat the quote: *no battle plan ever
    survives contact with the enemy*; while simultaneously enforcing rigid prediction
    schemes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些Scrum Master不断重复这句话：“没有一个战斗计划能在与敌人接触后生存下来”；同时又强制执行严格的预测方案。
- en: Accurate predictions are an oxymoron in the real world. You can't predict accurately
    for things that aren't certain, and in almost all cases, developers won't know
    the systems they are dealing with fully enough. Moreover, they don't know their
    own personal efficiency from day to day; it just can't be foreseen accurately.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，准确的预测是个矛盾。你无法对不确定的事情进行准确预测，而且在几乎所有情况下，开发人员都不会充分了解他们正在处理的系统。此外，他们也不知道自己的个人效率从一天到另一天的变化；这是无法准确预测的。
- en: I've even encountered environments where these strict predictions (often not
    even made by the developers themselves) are enforced by strict disciplinary procedures.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至遇到过这样的环境，严格的预测（通常甚至不是由开发人员自己制定的）是通过严格的纪律程序强制执行的。
- en: Reducing complexity by dividing problems and addressing them in small chunks
    is great practice; reducing your huge teams of programmers into smaller teams
    is also amazing practice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将问题分解并以小块的方式解决问题来减少复杂性是很好的做法；将庞大的程序员团队分成小团队也是很好的做法。
- en: Between the systems that developers are building in these small teams (commonly
    known as *tribes*), a system architect is often needed to ensure there is consistency
    between the teams.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些小团队（通常被称为*部落*）中开发的系统之间，通常需要系统架构师来确保团队之间保持一致性。
- en: Spotify use this tribe architecture to develop software; indeed, I would highly
    recommend reading the paper *Scaling Agile @ Spotify with Tribes, Squads*, *Chapters
    & Guilds* by Henrik Kniberg and Anders Ivarsson.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Spotify使用部落架构来开发软件；事实上，我强烈建议阅读Henrik Kniberg和Anders Ivarsson的论文*Scaling Agile
    @ Spotify with Tribes, Squads*, *Chapters & Guilds*。
- en: This system architect ensures there is consistency between all the different
    services that are built.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这位系统架构师确保所有构建的不同服务之间保持一致性。
- en: Turning to specifically Scrum, Scrum is an Agile process. The Scrum Guide (yes,
    it is even a trademark) defines the rules of Scrum in a 16-page document.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 转向具体的Scrum，Scrum是一种敏捷流程。Scrum指南（是的，它甚至是一个商标）在一份16页的文件中定义了Scrum的规则。
- en: Agile, however, contains many different processes alongside many other methodologies;
    Agile is a very broad knowledge base.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法包含许多不同的流程以及许多其他方法论；敏捷是一个非常广泛的知识库。
- en: Scrum Masters like to pretend Agile happens in an isolated environment in a
    development team. This is far from the truth; the entire organization structure
    plays into Scrum.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum Master喜欢假装敏捷发生在开发团队的孤立环境中。这与事实相去甚远；整个组织结构都影响Scrum。
- en: '**Extreme Programming** (**XP**) is a very broad process and it is largely
    understood the interactions between these processes. By cherry-picking these processes,
    you end up with an ineffective process; this is why Scrum struggles.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**极限编程**（**XP**）是一个非常广泛的流程，人们在很大程度上理解这些流程之间的互动。通过挑选这些流程，你最终得到的是一个无效的流程；这就是为什么Scrum会遇到困难。'
- en: Requirements change; this includes them changing mid-Sprint. When Scrum Masters
    insist on no changes after a Sprint has started, which leaves the team more ineffective
    to respond to real change.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 需求会变化；这包括它们在Sprint进行中发生变化。当Scrum Master坚持在Sprint开始后不进行任何更改时，这会使团队更无法有效地应对真正的变化。
- en: When developing in an Agile mechanism, we must remember that our software must
    be resilient enough to cope with the ever-changing requirements (resulting in
    ever-changing software design). Your software architecture must be able to cope
    with the stress of change. It is therefore vital that developers also understand
    and engage with the technical processes required to achieve software resilient
    enough to cope with the pace of change.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷机制中开发时，我们必须记住我们的软件必须足够弹性以应对不断变化的需求（导致软件设计不断变化）。你的软件架构必须能够应对变化的压力。因此，开发人员也必须理解并参与到实现足够弹性的软件所需的技术流程中。
- en: Companies that can't be flexible and respond to change are less effective than
    those who can; accordingly, they have a significant edge in the business world.
    When picking a company, them being Agile is not merely about the quality of the
    job you do but it is also vital to your job security.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不能灵活应对变化的公司比能够灵活应对变化的公司效率低；因此，他们在商业世界中具有重要优势。在选择公司时，它们的敏捷性不仅仅关乎你的工作质量，也关乎你的工作安全。
- en: My message is simple here; take technical practices seriously when implementing
    a process, and remember not to blindly follow obscene processes as it can harm
    an entire business.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点很简单；在实施流程时要认真对待技术实践，并且不要盲目遵循荒谬的流程，因为这可能会损害整个业务。
- en: Developers shouldn't be treated like children. If they can't code or write bad
    code they can't continue to be employed as developers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员不应该被像孩子一样对待。如果他们不能编码或者编写糟糕的代码，他们就不能继续作为开发人员被雇佣。
- en: In essence, in order to manage risk, it's best to look at your backlog and use
    historical progress to create projections as to where your project will be. The
    role of the manager should be to take away obstacles that stop developers doing
    their jobs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，为了管理风险，最好查看你的积压工作并利用历史进展来创建关于项目进展的预测。经理的角色应该是消除阻碍开发人员工作的障碍。
- en: Finally, if you ever are in a team with a Scrum Master with a terrible understanding
    of software development (and Agile for that matter), remind them strongly that
    people must come above process and that true agility is aided by code that can
    withstand the stresses of change.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在一个Scrum Master对软件开发（甚至对敏捷）理解很差的团队中，要坚决提醒他们，人必须高于流程，真正的敏捷性是由能够经受变化压力的代码所支持的。
- en: Scrum Masters will sometimes will argue that Agile means no upfront design.
    This is untrue, Agile means no *big* upfront design.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum Master有时会争辩说敏捷意味着没有预先设计。这是不正确的，敏捷意味着没有*大量*的预先设计。
- en: You need to sack people sometimes
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时候你需要解雇人
- en: I have worked in development environments where managers are too scared to sack,
    they either just torture developers by punishing them for a job they evidently
    can't do by trying to put perverse restrictions on development teams or let them
    wreak havoc on the development processes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在开发环境中工作过，那里的经理们太害怕解雇员工，要么就是通过对开发人员进行惩罚来折磨他们，因为他们显然无法胜任工作，要么就是让他们在开发过程中肆意破坏。
- en: Talented developers get disillusioned by the production of bad code or the unequal
    skill-basis. Other developers get away with poor code when they are often forced
    into a maintenance nightmare. Faced with the prospect of a maintenance nightmare
    (or in all likelihood, an increasing maintenance nightmare), they then resign.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有才华的开发人员对糟糕的代码或不公平的技能基础感到失望。其他开发人员在被迫进行维护时，往往会陷入维护噩梦。面对维护噩梦的前景（或很可能是不断加剧的维护噩梦），他们会辞职。
- en: Alternatively, the restrictive work conditions imposed to compensate for bad
    developers disillusion talented developers. Sick of being treated like idiots
    (because the other developers are idiots), they then take a job offer at a far
    better firm that offers them far better career prospects, and a better working
    environment with happier, more talented staff. They accept this offer as the company
    they are moving to will probably also have better business prospects and better
    compensation alongside happier engineers in a better work environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了弥补糟糕的开发人员而施加的限制性工作条件会让有才华的开发人员感到失望。厌倦了被当作白痴对待（因为其他开发人员是白痴），他们会接受更好的公司提供的工作机会，那里有更好的职业前景，更好的工作环境和更快乐、更有才华的员工。他们接受这个工作机会，因为他们要去的公司很可能也有更好的业务前景和更好的补偿，同时还有更快乐的工程师和更好的工作环境。
- en: There is one more extreme to this scenario; the business gains such an adverse
    reputation they cannot hire permanent developers; they then pay exorbitant fees
    for expensive contract developers while taking chances on their skillsets. While
    hemorrhaging money on contract developers, the business out of desperation will
    then probably pick up anyone who is willing to work on these projects. Interviewers
    of these developers will probably have not asked the right questions for the systems
    they will be building, leading to a big gamble on the quality of contractors being
    hired. The company decreases its chances of hiring good permanent staff, and the
    business enters tailspin as the company's demise gets worse. I have seen this
    exact scenario multiple times; each time the company has faced a slow and painful
    recession. If you are ever invited to work for a company which is similar to this,
    I strongly advise you to look elsewhere, unless you truly believe you are able
    to bring reform to such an organization.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下还有一个更极端的情况；企业声誉受损，无法雇佣永久开发人员；他们会支付昂贵的合同开发人员费用，同时冒险使用他们的技能。在支付合同开发人员的费用时，企业可能会选择任何愿意参与这些项目的人。这些开发人员的面试官可能没有问对问题，导致对被雇佣的承包商的质量进行了大赌注。公司减少了雇佣优秀永久员工的机会，企业陷入了恶性循环，公司的衰落变得更加严重。我曾多次见到这种情况；每次公司都面临着缓慢而痛苦的衰退。如果你曾被邀请加入类似的公司，我强烈建议你寻找其他地方，除非你真的相信你能够为这样的组织带来改革。
- en: If you ever take a management job in an organization such as this, ensure you
    have the powers to make meaningful change, the powers to hire the right people
    and fire the wrong people. If not, your tenure at such an organization will merely
    be spent trying to shift the deckchairs while suffering from a high staff churn
    rate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这样的组织中担任管理工作，确保你有能力进行有意义的改变，有权雇用合适的人并解雇错误的人。如果没有，你在这样的组织中的任期只会是在试图转移责任，同时遭受高员工流失率的困扰。
- en: Talented staff can be trusted; those passionate about what they are doing will
    not need restrictions to prevent them from slacking off.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有才华的员工是值得信任的；那些对自己的工作充满热情的人不需要限制来防止他们偷懒。
- en: If there are talented staff who can't perform their duties, it is highly unlikely
    your developers are merely slackers; you need to remove the bureaucratic processes
    that are restrictions to development.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有才华的员工无法履行职责，那么你的开发人员很可能不只是懒惰；你需要消除对开发的限制性官僚流程。
- en: Compulsively performing rituals that add nothing to putting software in users'
    hands adds nothing of value to the development team.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 强迫执行对将软件交付给用户没有任何价值的仪式是对开发团队没有任何帮助的。
- en: Lean project management
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精益项目管理
- en: Lean project management allows you to regularly deliver business value without
    being based on lists of requirements, features, and functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 精益项目管理使您能够定期交付业务价值，而不是基于需求、功能和功能列表。
- en: The book *The Machine That Changed the World* was based on the Massachusetts
    Institute of Technology's $5 million 5-year study on the automotive industry,
    making the term lean production world famous.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 《改变世界的机器》一书是基于麻省理工学院对汽车工业进行的500万美元、5年的研究，使精益生产这个术语世界闻名。
- en: 'This book proposed the following principles of lean:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书提出了精益的以下原则：
- en: Identify customers and specify values
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定客户并明确价值
- en: Identify and map the value stream
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定和映射价值流
- en: Create flow by eliminating waste
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除浪费来创造流程
- en: Respond to customer pull
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应客户需求
- en: Persue perfection
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追求完美
- en: 'From this, there are the following Lean Principles when it comes to software
    development, which are largely based on the manufacturing principles of lean production:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，软件开发的精益原则主要基于精益生产的制造原则：
- en: Eliminate waste
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除浪费
- en: Amplify learning
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加强学习
- en: Decide as late as possible
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量晚做决定
- en: Deliver as fast as possible
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快交付
- en: Empower the team
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激发团队的力量
- en: Build integrity in
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立完整性
- en: See the whole
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看整体
- en: Good architecture through reusable components, automated deployments, and good
    architecture can all assist in attaining this goal.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可重用的组件、自动化部署和良好的架构，可以帮助实现这一目标。
- en: YAGNI and defering decisions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI和推迟决策
- en: '*You aren''t going to need it* – you don''t need to add functionality until
    it''s necessary. Only add things that are vital to the success of your project.
    You probably won''t need a lot of functionality for the first version of your
    web app; it''s best to defer this until necessary.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不会需要它* - 你不需要添加功能，直到有必要。只添加对项目成功至关重要的东西。你可能不需要很多功能来完成你的Web应用的第一个版本；最好推迟到必要时再添加。'
- en: By deferring unnecessary functionality, you are able to keep your software design
    as simple as it needs to be. This helps you cope with the pace of change. Later
    in the software development process you will be more educated regarding the requirements,
    and more importantly, your client will have a more precise projection as to where
    they want the product to head.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过推迟不必要的功能，你可以保持软件设计尽可能简单。这有助于你应对变化的速度。在软件开发过程的后期，你将更加了解需求，更重要的是，你的客户将对他们想要产品发展的方向有更精确的预测。
- en: When you make decisions on software later, you have more data and more education.
    Some decisions have to be made upfront, but if you can defer them, that's often
    a good idea.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在以后做软件决策时，你会有更多的数据和更多的教育。有些决策必须提前做出，但如果你能推迟它们，那通常是一个好主意。
- en: Monitoring
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring systems become critical as you scale. Effective monitoring can drastically
    ease the maintenance of services.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 随着规模的扩大，监控系统变得至关重要。有效的监控可以极大地简化服务的维护。
- en: 'Having spoken to multiple experts in this field, this is the advice I have
    collected on the subject:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一领域与多位专家交谈后，这是我收集到的建议：
- en: Choose your key statistics carefully. Users don't care if your machine is low
    on CPU but they do care if your API is slow.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小心选择你的关键统计数据。用户不在乎你的机器CPU是否低，但他们在乎你的API是否慢。
- en: Use aggregators; think about services, not machines. If you have more than a
    handful of machines, you should treat them as an amorphous blob.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聚合器；考虑服务，而不是机器。如果你有超过几台机器，你应该将它们视为一个无定形的块。
- en: Avoid the Wall of Graphs. They are slow and it's information overload for a
    human. Each dashboard should have five graphs with no more than five lines per
    graphs.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免图表墙。它们很慢，对人类来说信息过载。每个仪表板应该有五个图表，每个图表不超过五条线。
- en: Quantiles aren't aggregable, they're hard to get meaningful information from.
    However, averages are easy to reason. A response time of 10 ms in the first quartile
    isn't really useful as information, but a 400 ms average response time shows a
    clear problem that needs to be addressed.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分位数不可聚合，很难得到有意义的信息。然而，平均数更容易理解。第一四分位的响应时间为10毫秒并不是真正有用的信息，但平均响应时间为400毫秒显示出一个明显的需要解决的问题。
- en: In addition to this, averages are far easier to calculate than quantiles. They
    are computationally easy, and especially useful as soon as you need scale the
    monitoring system.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，平均数比分位数更容易计算。它们在计算上很容易，并且在需要扩展监控系统时特别有用。
- en: Monitoring has a cost. Consider whether the resources are really worth it. Is
    a 1 second monitoring frequency really better than 10 second monitoring? Is the
    cost worth it? Monitoring isn't free, it has a computational cost.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控是有成本的。要考虑资源是否真的值得。1秒的监控频率真的比10秒的监控更好吗？成本是否值得？监控不是免费的，它有计算成本。
- en: That said, the Nyquist-Shannon sampling theorem demonstrates that if you sample
    every 20 seconds you can't reconstruct patterns at 10 seconds apart. Let's suppose
    there is a service that is crashing or reducing the speed of your computer system
    every 10 seconds - it can't be detected. Bear this in mind throughout your data
    analysis process.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也就是说，Nyquist-Shannon采样定理表明，如果你每20秒采样一次，就无法重建10秒间隔的模式。假设有一个服务每10秒就崩溃或减慢你的计算机系统的速度-这是无法检测到的。在数据分析过程中要牢记这一点。
- en: Correlation not causation - beware of conformation bias. Be sure to achieve
    a formal relationship of what is causing a particular issue before doing anything
    drastic.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关性不等于因果关系-小心确认偏见。在采取任何激烈行动之前，一定要确保建立起导致特定问题的正式关系。
- en: Both logs and metrics are good. Logs let you figure out details, metrics give
    you the high level.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和指标都很好。日志让你了解细节，指标让你了解高层次。
- en: Have a way to deal with non-critical alerts. What do you do with all those 404
    errors in your web server log files?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种方法来处理非关键警报。你在Web服务器日志文件中的所有404错误该怎么办？
- en: Remember the KISS principle mentioned earlier; keep your monitoring as simple
    as possible.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住之前提到的KISS原则；尽可能保持你的监控简单。
- en: Tests fight legacy
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试对抗遗留
- en: Automated tests are the best tool to fight legacy code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是对抗遗留代码的最佳工具。
- en: By having automated tests such as unit tests or behavioral tests, you are able
    to refactor legacy code effectively with confidence that little can be broken.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有自动化测试，如单元测试或行为测试，你能够有信心有效地重构遗留代码，几乎不会破坏。
- en: Badly written systems often consist of tightly coupled functions. One change
    to a function in one class may well break a function in a completely different
    class, leading to a domino effect of more classes being broken until the entire
    application is broken.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的系统通常由紧密耦合的函数组成。一个类中的函数的更改很可能会破坏完全不同类中的函数，导致更多类被破坏，直到整个应用程序被破坏。
- en: In order to decouple classes and follow practices such as the Single Responsibility
    Principle, refactoring must be carried out. Any refactoring effort must be sure
    not to break code elsewhere in an application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解耦类并遵循单一职责原则等实践，必须进行重构。任何重构工作都必须确保不会破坏应用程序中的其他代码。
- en: 'This brings us onto the topic of test coverage: is it a truly meaningful figure?'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了测试覆盖率的话题：这是一个真正有意义的数字吗？
- en: 'Alberto Savoia answered this question best in an amusing anecdote he placed
    online on artima.com; let''s take a read:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔贝托·萨沃亚在artima.com上发布了一个有趣的轶事，最好地回答了这个问题；让我们来看一下：
- en: '*Early one morning, a programmer asked the great master: "I am ready to write
    some unit tests. What code coverage should I aim for?"*'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '*The great master replied: "Don''t worry about coverage, just write some good
    tests."*'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '*The programmer smiled, bowed, and left.*'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '*...*'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '*Later that day, a second programmer asked the same question. The great master
    pointed at a pot of boiling water and said: "How many grains of rice should I
    put in that pot?"*'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '*The programmer, looking puzzled, replied: "How can I possibly tell you? It
    depends on how many people you need to feed, how hungry they are, what other food
    you are serving, how much rice you have available, and so on."*'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '*"Exactly," said the great master.*'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '*The second programmer smiled, bowed, and left.*'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '*...*'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '*Toward the end of the day, a third programmer came and asked the same question
    about code coverage.*'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*"Eighty percent and no less!" Replied the master in a stern voice, pounding
    his fist on the table.*'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*The third programmer smiled, bowed, and left.*'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '*...*'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '*After this last reply, a young apprentice approached the great master:*'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '*"Great master, today I overheard you answer the same question about code coverage
    with three different answers. Why?"*'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '*The great master stood up from his chair: "Come get some fresh tea with me
    and let''s talk about it."*'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '*After they filled their cups with smoking hot green tea, the great master
    began to answer: "The first programmer is new and just getting started with testing.
    Right now he has a lot of code and no tests. He has a long way to go; focusing
    on code coverage at this time would be depressing and quite useless. He''s better
    off just getting used to writing and running some tests. He can worry about coverage
    later."*'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '*"The second programmer, on the other hand, is quite experienced both at programming
    and testing. When I replied by asking her how many grains of rice I should put
    in a pot, I helped her realize that the amount of testing necessary depends on
    a number of factors, and she knows those factors better than I do - it''s her
    code after all. There is no single, simple, answer, and she''s smart enough to
    handle the truth and work with that."*'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '*"I see," said the young apprentice, "but if there is no single simple answer,
    then why did you answer the third programmer ''Eighty percent and no less''?"*'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '*The great master laughed so hard and loud that his belly, evidence that he
    drank more than just green tea, flopped up and down.*'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '*"The third programmer wants only simple answers - even when there are no simple
    answers ... and then does not follow them anyway."*'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '*The young apprentice and the grizzled great master finished drinking their
    tea in contemplative silence.*'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Alberto is portraying a simple message: focusing on having as much business
    logic and functionality is the best way forward. Test coverage is not something
    you should follow an arbitrary figure for.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: There are things which it makes sense not to test, and there are different logical
    paths even of code that has already been tested.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in distributed systems the communication between APIs or systems can
    be what breaks the system. In distributed architectures, testing code may not
    be enough. Strong monitoring systems become vital. Infrastructure as code to ensure
    consistent deployments and upgrades comes to the foreground. Moreover, achieving
    loosely coupled services and proper inter-process communication is more beneficial
    to the overall architecture than some unit tests.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative approach to Test-Driven Development (TDD). Behavior-Driven
    Development (BDD) provides us a different mechanism of testing our code; let's
    discuss it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BDD works by implementing tests using human-readable stories.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Cucumber is a tool that implements a BDD workflow by using human-readable feature
    files written in plain English language, for example:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, this section is going to be an incredibly simple exploration of Behat to
    pique your curiosity. If you want to learn more, please head to [http://www.behat.org](http://www.behat.org).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The Behat guide contains an example of a user story for the `ls` command. It''s
    quite a respectable example, so here it is:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to install Behat, you can amend your `composer.json` file so that
    it is required in your development environments:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will install Behat version 2.5, there is also Behat version 3, which contains
    a whole suite of new features without losing too much backward compatibility.
    That said, many projects out there are still utilizing Behat 2.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can run Behat using the following command:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get the following output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_017.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'By using the `init` flag we can then create a features directory with some
    basic information to get us started:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_018.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: 'Accordingly, let''s write our `feature/ls.feature` file with the following
    feature and scenario, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_019.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'If we now run Behat we''ll find the following output:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_020.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: 'Behat accordingly returns some code snippets so we can implement the undefined
    steps:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, in the feature directory that was created for us is a bootstrap folder
    that contains a `FeatureContext.php` file. Within this file, you will be able
    to find the body of your class:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_021.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed this block in the class body. We can put the generated
    methods here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I''ve done this as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_022.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: 'You may notice the body is full of `PendingException` messages. We need to
    replace these bodies with the actual functionality; fortunately, the Behat documentation
    contains functions with these methods populated:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can run Behat and we should see our scenario and its various steps completed:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-Driven Development](graphics/image_08_023.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: By using Mink with Behat we are able to accordingly use Selenium to run browser
    tests. Selenium will spin up a browser using Mink and we can then run Behat tests
    in the browser.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I've sought to tie up some loose ends. We've discussed some
    of the networking side of web development by learning about HTTP. In addition
    to this, we've learned about how RESTful APIs can be effectively designed.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'This book is now coming to an end; let''s revisit some core values that make
    our code great:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Favor composition over inheritance
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid repetitive coding (the DRY principle means Don't Repeat Yourself)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep It Simple, Stupid
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use design patterns just for using design patterns, introduce design patterns
    when you identify a recurring issue that they can solve
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction is awesome, interfaces help you abstract
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code in line with good standards
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate responsibilities throughout your code
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use dependency management and dependency injection; Composer is now available
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests save development time; they are critical for any refactoring effort and
    reduce breakages
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thank you for making it through this book; this book is a collection of my rants
    about software development; having had an incredibly diverse career, there are
    many lessons I have learned brutally and lot of eyesore code I have had to refactor.
    I have seen some of the worst, but also been a part of some of the most exciting
    PHP projects around. I hope in this book I have been able to share some of my
    experiences in this field.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: It is easy for developers to hide themselves away from the reality of development;
    there are few people who know best practices when it comes to software design
    and architecture, and a very limited set of those choose PHP as their development
    language of choice.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: For many of us, the code we produce is more than a hobby or a job, it is the
    limit of our expression as software engineers. Accordingly, writing it in a poetic,
    expressive, and a lasting fashion is our duty.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们许多人来说，我们所创造的代码不仅仅是一种爱好或工作，它是我们作为软件工程师表达的极限。因此，以诗意、表达力和持久的方式编写代码是我们的责任。
- en: Think about the code you would love to maintain; that is the code you have a
    duty to produce. Minimalism, reducing complexity, and separating concerns are
    key to achieving this.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你希望维护的代码；那就是你有责任创造的代码。极简主义、减少复杂性和分离关注点是实现这一目标的关键。
- en: Computer science may be grounded in mathematics and theorems, but our code sits
    above this. By utilizing the basis of a Turing complete language we are able to
    write code that is creative and functional.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学可能根植于数学和定理，但我们的代码超越了这一点。通过利用图灵完备语言的基础，我们能够编写创造性和功能性的代码。
- en: This locates software engineering in an odd vacuum compared to many other disciplines;
    while being very metricized, it also must be appealing to humans. I hope this
    book has helped you achieve these ends.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得软件工程处于与许多其他学科相比的奇特真空中；虽然它非常度量化，但也必须吸引人类。我希望这本书能帮助你实现这些目标。

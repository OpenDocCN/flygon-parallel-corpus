- en: Embracing Standards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受标准
- en: Every profession and industry has its own set of standards. Whether formal or
    informal, they govern the way of doing things. The software industry tends to
    formalize standards into documents that establish various specifications and procedures
    designed to ensure the quality and reliability of products and services. They
    further incite the compatibility and interoperability processes, which otherwise
    might not be possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个行业都有自己的一套标准。无论是正式还是非正式，它们都规范着事物的做法。软件行业倾向于将标准规范化为文件，以确保产品和服务的质量和可靠性。它们进一步激发了兼容性和互操作性的过程，否则可能无法实现。
- en: Putting the code into the context of products, various coding standards have
    emerged over the years. Their use yields greater code quality and reduced cognitive
    friction over our codebase. With code quality being one of the pillars of sustainable
    software development, it's no surprise standards are of impeccable importance
    to any professional developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码放入产品的背景中，多年来出现了各种编码标准。它们的使用可以提高代码质量，减少我们代码库中的认知摩擦。代码质量是可持续软件开发的支柱之一，因此标准对于任何专业开发人员都非常重要，这并不奇怪。
- en: When it comes to PHP, there are several layers of standards we need to take
    into consideration. There are coding standards specific to the language itself,
    and those specific to the individual library, framework, or platform. While some
    of these standards follow each other, others tend to clash sometimes. Usually,
    this clash is about little things, such as putting the opening function bracket
    in a new line or leaving it on the same line. That being the case, specific library,
    framework, and platform standards should take precedence over the pure language
    standards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及PHP时，我们需要考虑几个层面的标准。有一些是特定于语言本身的编码标准，还有一些是特定于个别库、框架或平台的标准。虽然其中一些标准是相互兼容的，但有些时候它们会发生冲突。通常，这种冲突是关于一些小事情，比如将开放函数括号放在新行上还是保留在同一行上。在这种情况下，特定的库、框架和平台标准应优先于纯语言标准。
- en: Back in 2009, at the **php[tek]** conference in Chicago, a number of developers
    joined forces and founded the *PHP Standards Group*. Organized around the mailing
    list at `standards@lists.php.net`, the initial goal was to establish the proper
    autoloading standard. Autoloading was a serious challenge for framework and platform
    developers. Different developers were using different conventions when naming
    their class files. This had a serious impact on interoperability. The **PHP Standards
    Recommendations**, codenamed **PSR-0**, set out to solve this issue by outlining
    practices and constraints that must be followed for autoloader interoperability.
    At its early stages, group acceptance into the PHP community was quite reserved.
    They had yet to earn the right to call themselves that in the eyes of the community.
    Two years later, the group renamed itself into **Framework Interoperability Group**,
    abbreviated to **PHP-FIG**. To this date, PHP-FIG has produced several PSRs, reaffirming
    its position among developers with each of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，在芝加哥的**php[tek]**会议上，许多开发人员联合起来成立了*PHP标准组*。组织在`standards@lists.php.net`的邮件列表周围，最初的目标是建立适当的自动加载标准。自动加载对框架和平台开发人员来说是一个严峻的挑战。不同的开发人员在为其类文件命名时使用了不同的约定。这对互操作性产生了严重影响。**PHP标准建议**，代号**PSR-0**，旨在通过概述必须遵循的自动加载器互操作性实践和约束来解决这个问题。在早期阶段，组织被PHP社区保留。他们还没有赢得社区的认可。两年后，该组织将自己改名为**框架互操作性组**，缩写为**PHP-FIG**。迄今为止，PHP-FIG已经制定了几个PSR，用每一个都重新确立了自己在开发人员中的地位。
- en: The PHP-FIG and its PSRs were predated by the PEAR Coding Standard, which is
    still quite dominant today. It focuses mostly on the elements of the PHP language
    itself. These elements address the way we write functions, variables, classes,
    and so on. The PSRs on the other hand mostly focus on the interoperability side
    of things. The PHP-FIG and PEAR intersect within the bounds of PSR-1 and PSR-2;
    this makes developers free to follow a single set of standards now, the ones provided
    by the PHP-FIG group.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FIG及其PSR是由PEAR编码标准先于的，这在今天仍然相当占主导地位。它主要关注PHP语言本身的元素。这些元素涉及我们编写函数、变量、类等的方式。另一方面，PSR主要关注互操作性方面。PHP-FIG和PEAR在PSR-1和PSR-2的范围内交叉；这使开发人员现在可以自由遵循PHP-FIG组提供的一套标准。
- en: 'In this chapter, we will take a detailed look at currently published and accepted
    PSR standards:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细了解当前发布和接受的PSR标准：
- en: PSR-1 - basic coding standard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-1 - 基本编码标准
- en: PSR-2 - coding style guide
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-2 - 编码风格指南
- en: PSR-3 - logger interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-3 - 记录器接口
- en: PSR-4 - autoloading standard
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-4 - 自动加载标准
- en: PSR-6 - caching interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-6 - 缓存接口
- en: PSR-7 - HTTP message interface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-7 - HTTP消息接口
- en: PSR-13 - hypermedia links
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSR-13 - 超媒体链接
- en: Throughout the PSRs, there is an extensive use of the **MUST**, **MUST NOT**,
    **REQUIRED, SHALL,** **SHALL NOT**, **SHOULD**, **SHOULD NOT**, **RECOMMENDED**,
    **MAY**, and **OPTIONAL** keywords. The meaning of these keywords is described
    in more detail under RFC 2119 ([http://www.ietf.org/rfc/rfc2119.txt](http://www.ietf.org/rfc/rfc2119.txt)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在PSR中，广泛使用了**MUST**、**MUST NOT**、**REQUIRED**、**SHALL**、**SHALL NOT**、**SHOULD**、**SHOULD
    NOT**、**RECOMMENDED**、**MAY**和**OPTIONAL**等关键字。这些关键字的含义在RFC 2119 ([http://www.ietf.org/rfc/rfc2119.txt](http://www.ietf.org/rfc/rfc2119.txt))中有更详细的描述。
- en: PSR-1 - basic coding standard
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-1 - 基本编码标准
- en: PSR-1 is the basic coding standard. It outlines the rules our code should follow,
    as seen by the members of PHP-FIG. The standard itself is quite short.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-1是基本的编码标准。它概述了我们的代码应该遵循的规则，这是PHP-FIG成员的看法。标准本身非常简短。
- en: '*Files MUST use only <?php and <?= tags***.** At one time, PHP supported several
    different tags (`<?php ?>`, `<? ?>`, `<?= ?>`, `<% %>`, `<%= %>`, `<script language="php"></script>`).
    The use of some depend on the configuration directives `short_open_tag` (`<? ?>`)
    and `asp_tags` (`<% %>`, `<%= %>`). The PHP 7 release removed ASP tags (`<%`,
    `<%=`), and the script tag (`<script language="php">`) altogether. The use of
    only `<?php ?>` and `<?= ?>` tags is now recommended in order to maximize compatibility.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '*Files MUST use only UTF-8 without BOM for PHP code***.** The **byte order
    mark** (**BOM**) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), appearing
    at the beginning of a document. When used correctly, BOM is invisible. The HTML5
    browsers are required to recognize the UTF-8 BOM and use it to detect the encoding
    of the page. PHP, on the other hand, can experience issues with BOM. Positioned
    at the start of the file, BOM clashes with PHP headers by causing the page to
    begin output before the header command is interpreted.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '*Files SHOULD either declare symbols (classes, functions, constants, and so
    on) or cause side-effects (for example, generate output, change .ini settings,
    and so on) but SHOULD NOT do both***.** Quite often, the simplicity of PHP becomes
    its downside. The language is quite loose when it comes to its use. We can easily
    start from a blank file and code an entire application in it. This implies having
    dozens of different classes, functions, constants, variables, includes, requires,
    and other directives, all stacked one next to another. While this might come in
    handy for a quick prototyping, it is, by no means, an approach to be taken when
    building our applications.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Namespaces and classes MUST follow an autoloading PSR: [PSR-0, PSR-4].* Autoloading
    plays a big role in PHP. The concept cuts down the use of require constructs by
    pulling in our classes and functions automatically from various files. By default,
    the language itself provides the `__autoload()` and `spl_autoload_register()`
    functions to assist with that. The PHP-FIG group produced two autoloading standards.
    The PSR-0 standard was the first PSR to come out, and it soon became widely adopted
    across many PHP frameworks. As of October 2014, PSR-0 has been marked as deprecated,
    leaving PSR-4 as an alternative. We will touch upon PSR-4 in more detail later
    on. For the moment, it''s suffice to say that the code written for PHP 5.3 and
    after must use formal namespaces.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Class names MUST be declared in* **StudlyCaps***.* The class names, among
    other things, sometimes comprise of multiple words. Imagine, for example, the
    class in charge of XML parsing. Reasonably enough, we might call it `Xml_Parser`,
    `XmlParser`, `XML_Parser`, `XMLParser`, or some similar combination. There are
    many different rules used to squeeze together multiple words that contribute to
    better readability of the code, such as camel case, kebab case, snake case, and
    so on. This standard proposes the use of StudlyCaps, where capitalization of letters
    varies arbitrarily. They resemble the , but might be carried out in a more random
    fashion.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Class constants MUST be declared in all upper case with underscore separators.*
    The PHP system has two types of constants, the ones that live outside the class
    and are defined using the define construct, and the other ones that live inside
    the class. Given that constants represent immutable variables, their name is supposed
    to stand out. This standard clearly states that any class constant name should
    be fully capitalized. It, however, avoids any recommendation regarding the property
    names. We are free to use any of the following combinations (`$StudlyCaps`, `$camelCase`,
    or `$under_score`) as long as we are being consistent.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量必须以大写字母和下划线分隔符声明。PHP系统有两种常量，一种是在类外部定义的，使用define结构定义，另一种是在类内部定义的。鉴于常量代表不可变的变量，它们的名称应该突出显示。这个标准明确规定任何类常量名称都应该完全大写。然而，它避免了对属性名称的任何建议。只要我们保持一致，我们可以自由使用以下任何组合（$StudlyCaps，$camelCase或$under_score）。
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Method names MUST be declared in camelCase.* Functions enclosed within a class
    are called **methods**. The naming pattern here differs from previously mentioned
    StudlyCaps, as it uses camelCase, which is less arbitrary. More specifically,
    lowercase camelCase is used, which implies method names starting with lowercase
    letters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名必须以camelCase声明。类中的函数称为方法。这里的命名模式与前面提到的StudlyCaps不同，它使用较少武断的camelCase。更具体地说，使用小写的camelCase，这意味着方法名以小写字母开头。
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The official, full-length *PSR-1 Basic Coding Standard* guide is available at
    [http://www.php-fig.org/psr/psr-1/](http://www.php-fig.org/psr/psr-1/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的完整的PSR-1基本编码标准指南可在[http://www.php-fig.org/psr/psr-1/](http://www.php-fig.org/psr/psr-1/)上找到。
- en: PSR-2 - coding style guide
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-2 - 编码风格指南
- en: PSR-2 is an extension of PSR-1\. This means that when talking about PSR-2, the
    PSR-1 standard is sort of implicitly understood. The difference is that PSR-2
    expands beyond basic class and function formatting by enumerating a set of rules
    on how to format PHP code. The outlined style rules are derived shared similarities
    across the various PFP-FIG member projects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-2是PSR-1的扩展。这意味着在谈论PSR-2时，PSR-1标准在某种程度上是隐含的。不同之处在于，PSR-2扩展了基本的类和函数格式，通过列举一组规则来格式化PHP代码。所述的样式规则源自PFP-FIG成员项目之间的共同相似之处。
- en: '*Code MUST follow a coding style guide PSR (PSR-1).* Goes to say that every
    PSR-2 code is implicitly PSR-1 compliant.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须遵循编码风格指南PSR（PSR-1）。可以说每个PSR-2代码都隐含地符合PSR-1。
- en: '*Code MUST use 4 spaces for indenting, not tabs.* The spaces versus tabs dilemma
    is quite an old one in the programming world. There are those who the PHP-FIG
    group voted for the use of spaces, whereas 4 spaces represent what is usually
    a single tab indent. The benefit of a space over a tab is consistency. Whereas,
    a tab could show up as a different number of columns depending on the environment,
    a single space is always one column. While this might not be the most convincing
    argument of all, the standards goes on to say that 4 spaces constitute for a single
    indent. Think of it as 4 spaces for what was once a single indent. Most modern
    IDE editors nowadays, such as PhpStorm, handle this automatically for us.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须使用4个空格进行缩进，而不是制表符。空格与制表符的困境在编程世界中已经存在很久了。有些人PHP-FIG组投票使用空格，而4个空格代表通常的单个制表符缩进。空格胜过制表符的好处在于一致性。而制表符可能会根据环境显示为不同数量的列，单个空格始终是一个列。虽然这可能不是最令人信服的论点，但标准继续说4个空格构成一个单独的缩进。可以将其视为曾经单个缩进的4个空格。大多数现代IDE编辑器，如PhpStorm，现在都会自动处理这个问题。
- en: '*There MUST NOT be a hard limit on line length; the soft limit MUST be 120
    characters; lines SHOULD be 80 characters or less.* The 80 characters line length
    argument is as old as programming itself. The IBM punch card, designed in 1928,
    had the 80 columns with 12 punch locations each, one character to each column.
    This 80 characters per row design choice was later passed on to character-based
    terminals. Although the display device advancements are far beyond these limitations,
    even today, some command prompts remain set at 80 columns. This standard basically
    says that while we might use any length we want, it is highly preferable to keep
    it below 80 characters.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 行长度不得有硬限制；软限制必须为120个字符；行应为80个字符或更少。80个字符的行长度论点与编程本身一样古老。1928年设计的IBM穿孔卡每行有80列，每列有12个穿孔位置，每列一个字符。这种每行80个字符的设计选择后来传递给基于字符的终端。尽管显示设备的进步远远超出了这些限制，但即使在今天，一些命令提示仍然设置为80列。这个标准基本上是说，虽然我们可以使用任何长度，但最好保持在80个字符以下。
- en: '*There MUST be one blank line after the namespace declaration, and there MUST
    be one blank line after the block of use declarations.* Although this is not a
    technical requirement imposed by the language itself, the standard mandates it.
    The requirement itself is more of a cosmetic nature. The resulting use impacts
    code readability for the better.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间声明后必须有一个空行，并且在使用声明块后必须有一个空行。虽然这不是语言本身强加的技术要求，但标准要求如此。这个要求本身更多是为了美观。结果使用对代码可读性更好。
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Opening braces for classes MUST go on the next line, and closing braces MUST
    go on the next line after the body.* Similarly, this is not a technical requirement
    of the language, rather a cosmetic one.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类的大括号必须放在下一行，而右括号必须放在主体的下一行。同样，这不是语言的技术要求，而是美学上的要求。
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行演示了一个要避免的例子：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Opening braces for methods MUST go on the next line, and closing braces MUST
    go on the next line after the body.* Again, this is a cosmetic type of requirement,
    it is not really imposed by the language itself.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Visibility MUST be declared on all properties and methods; abstract and final
    MUST be declared before the visibility; static MUST be declared after the visibility.* Visibility
    is merely a shorthand for what is officially called **access modifiers**. The
    class methods in PHP can use more than one access modifier. The order of access
    modifiers in such cases is not relevant; we can easily say `abstract public function`
    and `public abstract function` or `final public function` and `public final function`.
    The same goes when we add the `static` access modifier to the mix, where we effectively
    might have three different access modifiers on a single method. This standard
    clearly specifies that the `abstract` and `final` modifiers, if used, need to
    be set first, while the `static` modifiers, if used, need to follow `public` and
    `private` modifiers.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code demonstrates an example to avoid:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following block of code demonstrates an example to follow:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Control structure keywords MUST have one space after them; method and function
    calls MUST NOT.* This is a rather cosmetic requirement, which merely affects code
    readability.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code demonstrate an example to avoid:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following lines of code demonstrate an example to follow:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Opening braces for control structures MUST go on the same line, and closing
    braces MUST go on the next line after the body.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code demonstrates an example to avoid:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following block of code demonstrates an example to follow:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Opening parenthesis for control structures MUST NOT have a space after them,
    and closing parenthesis for control structures MUST NOT have a space before them.*
    The closing parenthesis space might be a bit confusing here to grasp, because,
    earlier, we saw the standard enforcing spaces for indention instead of tabs. This means
    that we will have spaces preceding closing brackets. However, there should only
    be enough space to represent the actual indention at the point of the closing
    bracket, nothing more.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The demonstrates an example to avoid (notice the space on line 7, after the
    opening curly brace):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2aab1815-76f4-4efd-8201-1109cdbd24ff.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'The demonstrates an example to follow:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a86bc8b6-a227-41b7-aaf3-520416bc1094.png)The official, full-length
    *PSR-2 Coding Style* guide is available at [http://www.php-fig.org/psr/psr-2/](http://www.php-fig.org/psr/psr-2/).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: PSR-3 - logger interface
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging different type of events is a common practice for applications. While
    one application might categorize these types of events into errors, informational
    events, and warnings, others might throw in more elaborate levels of severity
    logging. The same goes for the actual format of the log message itself. Goes to
    say that every application might easily have its own flavor of logging mechanism.
    This stands in a way of interoperability.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The PSR-3 standard sets out to fix this by defining a standard for the actual
    logger interface. Such a standardized interface then enables us to write PHP application
    logs in a simple and universal way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The *syslog protocol* (RFC 5424), defined by **Internet Engineering Task Force**
    (**IETF**), differentiates the following eight severity levels:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`emergency`: This states the system is unusable'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert`: This states action must be taken immediately'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`critical`: This states critical conditions'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This states error conditions'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning`: This states warning conditions'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notice`: This states normal but significant condition'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: This states informational messages'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: This states debug-level messages'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PSR-3 standard builds upon the RFC 5424 by specifying `LoggerInterface`,
    which exposes a special method for each of the eight severity levels, shown as
    follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-3标准建立在RFC 5424之上，通过指定`LoggerInterface`，为八个严重级别中的每一个公开了一个特殊方法，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can also notice the ninth `log()` method, whose signature differs than the
    first eight. The `log()` method is more of a convenience method, whose level parameter
    needs to indicate one of the eight severity levels. Calling this method must have
    the same result as calling the level-specific methods. Every method accepts a
    string as `$message`, or an object with a `__toString()` method. Trying to call
    these methods with an unknown severity level must throw `Psr\Log\InvalidArgumentException`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到第九个`log()`方法，其签名与前八个不同。`log()`方法更像是一个便利方法，其级别参数需要指示八个严重级别中的一个。调用此方法必须与调用特定级别的方法具有相同的结果。每个方法都接受一个字符串作为`$message`，或者具有`__toString()`方法的对象。尝试使用未知严重级别调用这些方法必须抛出`Psr\Log\InvalidArgumentException`。
- en: 'The `$message` string may contain one or more placeholders, which the interface
    implementors might interpolate with key-value parameters passed into the `$context`
    string, as shown in the following abstract example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`$message`字符串可能包含一个或多个占位符，接口实现者可能将其与传递到`$context`字符串中的键值参数进行插值，如下面的抽象示例所示：'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Without going into the implementation details, it's suffice to say that PSR-3
    is a simple standard set to sort an important role of a logger mechanism. Using
    the logger interface, we are freed from having to rely on a specific logger implementation. We
    can type-hint our application code against `LoggerInterface` to acquire a PSR-3
    compliant logger.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要深入实现细节，可以说PSR-3是一个简单的标准，用于对记录器机制的重要角色进行排序。使用记录器接口，我们不必依赖特定的记录器实现。我们可以在应用程序代码中对`LoggerInterface`进行类型提示，以获取符合PSR-3的记录器。
- en: 'If we were using **Composer** with our project, we could easily include the
    `psr/log` package into it. This would enable us to integrate a PSR compliant logger
    with our project in one of the following ways:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在项目中使用**Composer**，我们可以很容易地将`psr/log`包包含到其中。这将使我们能够以以下一种方式之一将符合PSR标准的记录器集成到我们的项目中：
- en: Implementing the `LoggerInterface` interface and defining all of its methods
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`LoggerInterface`接口并定义其所有方法
- en: Inheriting the `AbstractLogger` class and defining the `log` method
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承`AbstractLogger`类并定义`log`方法
- en: Using `LoggerTrait` and defining the `log` method
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LoggerTrait`并定义`log`方法
- en: However, it is much easier to use an existing Composer package, such as `monolog/monolog` or
    `katzgrau/klogger`, and avoid writing our own logger implementation altogether.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用现有的Composer包，如`monolog/monolog`或`katzgrau/klogger`，并完全避免编写自己的记录器实现会更容易。
- en: 'The *Monolog* project is a nice example of a popular and robust PHP library
    that implements the PSR-3 logger interface. It can be used to send our logs to
    files, sockets, inboxes, databases, and various web services.The official, full-length
    *PSR-3: Logger Interface* guide is available at [http://www.php-fig.org/psr/psr-3/](http://www.php-fig.org/psr/psr-3/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*Monolog*项目是一个流行且强大的PHP库的很好的例子，它实现了PSR-3记录器接口。它可以用于将日志发送到文件、套接字、收件箱、数据库和各种网络服务。官方的完整的*PSR-3:
    Logger Interface*指南可在[http://www.php-fig.org/psr/psr-3/](http://www.php-fig.org/psr/psr-3/)上找到。'
- en: PSR-4 - autoloading standard
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-4 - 自动加载标准
- en: To this date, the PHP-FIG group has released two autoloading standards. Predating
    PSR-4 was PSR-0\. It was the first standard released by the PHP-FIG group. Its
    class naming had certain backward compatibility features aligned with an even
    older PEAR standard. Whereas, each level of the hierarchy was separated with a
    single underscore, indicating pseudo-namespaces and directory structure. The PHP
    5.3 release then brought official namespace support to the language. PSR-0 allowed
    both the old PEAR underscore mode and the use of the new namespace notation. Allowing
    the underscores for some time to follow eased the transition to namespaces and
    encouraged wider adoption. Pretty soon, Composer came on the scene.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，PHP-FIG小组已发布了两个自动加载标准。在PSR-4之前是PSR-0。这是PHP-FIG小组发布的第一个标准。其类命名具有与更旧的PEAR标准对齐的某些向后兼容特性。而每个层次的分隔符都是用单个下划线，表示伪命名空间和目录结构。然后，PHP
    5.3发布了官方的命名空间支持。PSR-0允许同时使用旧的PEAR下划线模式和新的命名空间表示法。允许一段时间使用下划线来进行过渡，促进了命名空间的采用。很快，Composer出现了。
- en: Composer is a popular dependency manager for PHP that deals with packages and
    libraries by installing them in a `vendor/` directory of our project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Composer是一个流行的PHP依赖管理器，通过将包和库安装在项目的`vendor/`目录中来处理它们。
- en: With Composer's `vendor/` directory philosophy, there was no single main directory for
    PHP sources as with PEAR. PSR-0 became a bottleneck and was marked as deprecated
    as of October 2014.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer的`vendor/`目录哲学，没有像PEAR那样的单一主目录用于PHP源代码。PSR-0成为瓶颈，并于2014年10月被标记为废弃。
- en: PSR-4 is the recommended autoloading standard nowadays.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-4是目前推荐的自动加载标准。
- en: 'According to PSR-4, a fully qualified class name now has the form as per the
    following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PSR-4，完全限定的类名现在具有如下示例所示的形式：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The term *class* here does not just refer to classes. It also refers to *interfaces*,
    *traits*, and other similar structures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的术语*class*不仅指类。它还指*interfaces*、*traits*和其他类似的结构。
- en: 'To put this into context, let''s take a look at the partial class code taken
    from the *Magento 2* commerce platform, which is shown as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其放入上下文中，让我们来看一下从*Magento 2*商业平台中摘取的部分类代码，如下所示：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding `Subscriber` class is defined within the `Subscriber.php` file
    present at  `vendor\Magento\module-newsletter\Model\`, relative to the root of
    the *Magento* project. We can see `__construct` using all sorts of fully classified
    class names. The Magento platform has these types of robust constructors all over its
    codebase because of the way it handles dependency injection. We can imagine the
    amount of additional code needed to individually `require` all of these classes
    manually if it weren't for the unified autoloading standard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Subscriber`类定义在`vendor\Magento\module-newsletter\Model\`中的`Subscriber.php`文件中，相对于*Magento*项目的根目录。我们可以看到`__construct`使用了各种完全分类的类名。Magento平台在其代码库中到处都有这种强大的构造函数，这是因为它处理依赖注入的方式。我们可以想象，如果没有统一的自动加载标准，需要手动单独`require`所有这些类所需的额外代码量。
- en: The PSR-4 standard also states that the autoloader implementation must not throw
    an exception or raise an error of any level. This is to ensure that possible multiple
    autoloaders do not break one another.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-4标准还规定，自动加载程序实现不能抛出异常或引发任何级别的错误。这是为了确保可能的多个自动加载程序不会相互破坏。
- en: 'The official, full-length *PSR-4: Autoloader Standard* guide is available at
    [http://www.php-fig.org/psr/psr-4/](http://www.php-fig.org/psr/psr-4/).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的完整*PSR-4：自动加载程序标准*指南可在[http://www.php-fig.org/psr/psr-4/](http://www.php-fig.org/psr/psr-4/)上找到。
- en: PSR-6 - caching interface
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-6 - 缓存接口
- en: Performance issues are the ever-hot topic of application development. The effects
    of poorly performing applications can sometimes have serious financial impact.
    Back in 2007, Amazon reported a 100 ms increase in [https://www.amazon.com/](https://www.amazon.com/)
    load time and their sales decreased by 1%. Several studies have also shown that
    nearly half of the users are likely to abandon the website if the page load time
    is over 3 seconds. To address the performance issues, we look into caching solutions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题一直是应用程序开发中的热门话题。性能不佳的应用程序可能会对财务产生严重影响。早在2007年，亚马逊报告称[https://www.amazon.com/](https://www.amazon.com/)加载时间增加了100毫秒，销售额减少了1%。几项研究还表明，将近一半的用户可能会在页面加载时间超过3秒时放弃网站。为了解决性能问题，我们需要研究缓存解决方案。
- en: Both browsers and servers allow caching of various resources, such as images,
    web pages, CSS/JS files. Sometimes, however, this is not enough as we need to
    be able to control the caching of various other bits on the application level,
    such as objects themselves. Over time, various libraries rolled out their own
    caching solutions. This made it tough for developers, as they needed to implement
    specific caching solutions in their code. This made it impossible to easily change
    caching implementation later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和服务器都允许缓存各种资源，如图像、网页、CSS/JS文件。然而，有时这还不够，因为我们需要能够在应用程序级别控制各种其他位的缓存，比如对象本身。随着时间的推移，各种库推出了它们自己的缓存解决方案。这让开发人员感到困难，因为他们需要在其代码中实现特定的缓存解决方案。这使得以后很难轻松更改缓存实现。
- en: To solve these problems, the PHP-FIG group brought forth the PSR-6 standard.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，PHP-FIG小组提出了PSR-6标准。
- en: This standard defines two main interfaces, `CacheItemPoolInterface` and `CacheItemInterface`,
    for working with **Pool** and **Items**. The pool represents a collection of items
    in the caching system. Whereas, item represents a single **key**/value pair stored
    within the pool. The key part acts as a unique identifier, so it must be immutable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该标准定义了两个主要接口，`CacheItemPoolInterface`和`CacheItemInterface`，用于处理**Pool**和**Items**。池表示缓存系统中的项目集合。而项目表示存储在池中的单个**键**/值对。键部分充当唯一标识符，因此必须是不可变的。
- en: 'The following code snippet reflects the PSR-6 `CacheItemInterface` definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-6 `CacheItemInterface` 的定义：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code snippet reflects the PSR-6 `CacheItemPoolInterface` definition:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-6 `CacheItemPoolInterface` 的定义：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Libraries that implement the PSR-6 standard must support the following serializable
    PHP data types:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现PSR-6标准的库必须支持以下可序列化的PHP数据类型：
- en: Strings
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Integers
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Floats
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: Boolean
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Null'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Arrays
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Object
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: The compound structures such as arrays and objects are always tricky ones. The
    standard says that the indexed, associative, and multidimensional arrays of arbitrary
    depth must be supported. Since arrays in PHP are not necessarily of a single data
    type, this is the one to be careful about. Objects might utilize the PHP `Serializable`
    interface, `__sleep()` or `__wakeup()` magic methods, or similar language functionality.
    The important bit is that any data passed to libraries that implement PSR-6 is
    expected to come back exactly as passed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 复合结构，如数组和对象，总是棘手的。标准规定，必须支持任意深度的索引、关联和多维数组。由于PHP中的数组不一定是单一数据类型，这是需要小心的地方。对象可能利用PHP的`Serializable`接口、`__sleep()`或`__wakeup()`魔术方法，或类似的语言功能。重要的是，传递给实现PSR-6的库的任何数据都应该如传递时一样返回。
- en: 'There are several PSR-6 cache implementations available via Composer, all of
    which support tags. The following is a partial list of the most popular ones:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Composer可以获得几种PSR-6缓存实现，它们都支持标签。以下是最受欢迎的一些缓存实现的部分列表：
- en: '`cache/filesystem-adapter`: Using filesystem'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/filesystem-adapter`：使用文件系统'
- en: '`cache/array-adapter`: Using a PHP array'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/array-adapter`：使用PHP数组'
- en: '`cache/memcached-adapter`: Using Memcached'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/memcached-adapter`：使用Memcached'
- en: '`cache/redis-adapter`: Using Redis'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/redis-adapter`：使用Redis'
- en: '`cache/predis-adapter`: Using Redis (Predis)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/predis-adapter`：使用Redis（Predis）'
- en: '`cache/void-adapter`: Using Void'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/void-adapter`：使用Void'
- en: '`cache/apcu-adapter`: Using APCu'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/apcu-adapter`：使用APCu'
- en: '`cache/chain-adapter`: Using chain'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/chain-adapter`：使用链'
- en: '`cache/doctrine-adapter`: Using Doctrine'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache/doctrine-adapter`：使用Doctrine'
- en: We can easily add any one of these caching libraries to our project just by
    using `Composer require new/package`. The PSR-6 compliance makes it possible for
    us to easily swap these libraries in our project without changing any of its code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Composer require new/package`轻松地将这些缓存库中的任何一个添加到我们的项目中。PSR-6的兼容性使我们能够在项目中轻松地交换这些库，而无需更改任何代码。
- en: 'The *Redis* is an open source in-memory data structure store used as a database,
    cache, and message broker. It is quite popular with PHP developers as a caching
    solution. The official *Redis* page is available at [https://redis.io/](https://redis.io/).The
    official, full-length *PSR-6: Caching Interface* guide is available at [http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redis*是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它在PHP开发人员中非常受欢迎作为缓存解决方案。官方*Redis*页面可在[https://redis.io/](https://redis.io/)找到。官方的完整*PSR-6：缓存接口*指南可在[http://www.php-fig.org/psr/psr-6/](http://www.php-fig.org/psr/psr-6/)找到。'
- en: PSR-7 - HTTP message interface
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-7 - HTTP消息接口
- en: The HTTP protocol has been around for quite some time now. Its development was
    initiated by Tim Berners-Lee at CERN way back in 1989\. Throughout the years,
    **Internet Engineering Task Force** (**IETF**) and the **World Wide Web Consortium**
    (**W3C**) defined series of standards for it, known as **Requests for Comments**
    (**RFCs**). The first definition of HTTP/1.1 occurred in RFC 2068 in 1997, and
    was later deprecated by RFC 2616 in 1999\. Over a decade later, HTTP/2 was standardized
    in 2015\. Although HTTP/2 is now supported by major web servers, HTTP/1.1 is still
    widely used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议已经存在了相当长的时间。它的发展始于1989年，由CERN的Tim Berners-Lee发起。多年来，**互联网工程任务组**（**IETF**）和**万维网联盟**（**W3C**）为其定义了一系列标准，称为**请求评论**（**RFCs**）。HTTP/1.1的第一个定义出现在1997年的RFC
    2068中，后来在1999年被RFC 2616废弃。十多年后，HTTP/2在2015年被标准化。尽管HTTP/2现在得到了主要Web服务器的支持，但HTTP/1.1仍然被广泛使用。
- en: The underlying HTTP communication comes down to requests and responses, commonly
    referred to as **HTTP messages**. Abstracted away from average consumers, these
    messages form the foundation of web development, and are therefore of interest
    to every web application developer. While RFC 7230, RFC 7231, and RFC 3986 spec
    out the details of HTTP itself, PSR-7 describes common interfaces for representing
    the HTTP messages in accordance with these RFCs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 底层的HTTP通信归结为请求和响应，通常称为**HTTP消息**。这些消息被抽象出来，形成了Web开发的基础，因此对每个Web应用程序开发人员都很重要。虽然RFC
    7230、RFC 7231和RFC 3986规定了HTTP本身的细节，但PSR-7描述了根据这些RFC表示HTTP消息的常见接口。
- en: 'PSR-7 defines a total of the following seven interfaces:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-7总共定义了以下七个接口：
- en: '`Psr\Http\Message\MessageInterface`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\MessageInterface`'
- en: '`Psr\Http\Message\RequestInterface`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\RequestInterface`'
- en: '`Psr\Http\Message\ServerRequestInterface`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\ServerRequestInterface`'
- en: '`Psr\Http\Message\ResponseInterface`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\ResponseInterface`'
- en: '`Psr\Http\Message\StreamInterface`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\StreamInterface`'
- en: '`Psr\Http\Message\UriInterface`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\UriInterface`'
- en: '`Psr\Http\Message\UploadedFileInterface`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Http\Message\UploadedFileInterface`'
- en: They can be fetched via Composer as a part of the `psr/http-message` package.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过Composer作为`psr/http-message`包的一部分获取。
- en: 'The following block of code reflects the PSR-7 `Psr\Http\Message\MessageInterface`
    definition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块反映了PSR-7 `Psr\Http\Message\MessageInterface` 的定义：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding `MessageInterface` methods common to both the request and response
    type of message. Messages are considered immutable. A class that implements the `MessageInterface` interface
    needs to assure this immutability by returning a new message instance for every
    method call that changes the message state.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`MessageInterface`方法适用于请求和响应类型的消息。消息被认为是不可变的。实现`MessageInterface`接口的类需要通过为每个改变消息状态的方法调用返回一个新的消息实例来确保这种不可变性。
- en: 'The following block of code reflects the PSR-7 `Psr\Http\Message\RequestInterface` definition:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块反映了PSR-7 `Psr\Http\Message\RequestInterface` 的定义：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `RequestInterface` interface extends  `MessageInterface` serving as a representation
    of an outgoing, client-side request. Like previously mentioned messages, requests
    are also considered immutable. This means that the same class behavior applies.
    If the class method is to change the request state, the new instance of request
    needs to be returned for every such method call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestInterface`接口扩展了`MessageInterface`，作为对外的客户端请求的表示。与前面提到的消息一样，请求也被认为是不可变的。这意味着相同的类行为适用。如果类方法要改变请求状态，需要为每个这样的方法调用返回新的请求实例。'
- en: 'The following `Psr\Http\Message\ServerRequestInterface` definition reflects
    the PSR-7 standard:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Psr\Http\Message\ServerRequestInterface`定义反映了PSR-7标准：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The implementations of `ServerRequestInterface` serve as a representation of
    an incoming server-side HTTP request. They too are considered immutable; this
    means that the same rules of state changing methods apply as previously mentioned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerRequestInterface`的实现作为对内的服务器端HTTP请求的表示。它们也被认为是不可变的；这意味着与前面提到的状态改变方法相同的规则适用。'
- en: 'The following code snippet reflects the PSR-7 `Psr\Http\Message\ResponseInterface` definition:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-7 `Psr\Http\Message\ResponseInterface` 的定义：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With only three methods defined, the implementations of `ResponseInterface`
    serve as a representation of an outgoing server-side response. These types of
    messages are considered immutable as well.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 只定义了三种方法，`ResponseInterface`的实现作为对外的服务器端响应的表示。这些类型的消息也被认为是不可变的。
- en: 'The following piece of code reflects the PSR-7 `Psr\Http\Message\StreamInterface` definition:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-7 `Psr\Http\Message\StreamInterface` 的定义：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`StreamInterface` provides a wrapper around the common PHP stream operations, including
    serialization of the entire stream to a string.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamInterface`提供了一个包装器，包括对整个流进行序列化为字符串的常见PHP流操作。'
- en: 'The following piece of code reflects the PSR-7 `Psr\Http\Message\UriInterface` definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-7 `Psr\Http\Message\UriInterface` 的定义：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `UriInterface` interface here represents the URIs according to RFC 3986. The
    interface methods force the implementor to provide methods for most common operations
    around the URI object. The instances of URI objects are also considered immutable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`UriInterface`接口表示了根据RFC 3986的URI。接口方法强制实现者提供URI对象的大多数常见操作的方法。URI对象的实例也被认为是不可变的。
- en: 'The following code snippet reflects the PSR-7 `Psr\Http\Message\UploadedFileInterface` definition:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-7 `Psr\Http\Message\UploadedFileInterface` 的定义：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `UploadedFileInterface` interface represents a file uploaded through an
    HTTP request, which is a frequent role of web applications. The handful of methods
    force the class implementation to cover the most common actions performed on files.
    Like with all of the previous interfaces, class implementation needs to ensure
    object immutability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`UploadedFileInterface` 接口代表通过HTTP请求上传的文件，这是Web应用程序的常见角色。少数方法强制类实现覆盖文件上执行的最常见操作。与之前的所有接口一样，类的实现需要确保对象的不可变性。'
- en: '*Guzzle* is a popular PSR-7 compliant HTTP client library that makes it easy
    to work with requests, responses, and streams. It is available at [https://github.com/guzzle/guzzle](https://github.com/guzzle/guzzle),
    or as a Composer `guzzlehttp/guzzle` package.The official, full-length *PSR-7:
    HTTP Message Interface* guide is available at [http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Guzzle* 是一个流行的符合PSR-7标准的HTTP客户端库，它可以轻松处理请求、响应和流。它可以在[https://github.com/guzzle/guzzle](https://github.com/guzzle/guzzle)获取，也可以作为Composer
    `guzzlehttp/guzzle` 包获取。官方的完整的*PSR-7: HTTP消息接口*指南可以在[http://www.php-fig.org/psr/psr-7/](http://www.php-fig.org/psr/psr-7/)获取。'
- en: PSR-13 - hypermedia links
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-13 - 超媒体链接
- en: The hypermedia links form an essential part of any web application, whether
    we are speaking about HTML or API formats. At the very minimum, each hypermedia
    link consists of a URI representing the target resource and a relationship defining
    how the target resource relates to the source. The target link must be an absolute
    URI or a relative URI, as defined by RFC 5988, or possibly a URI template as defined
    by RFC 6570.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体链接是任何Web应用程序的重要组成部分，无论是HTML还是API格式。至少，每个超媒体链接都包括一个代表目标资源的URI和一个定义目标资源与源资源关系的关系。目标链接必须是绝对URI或相对URI，由RFC
    5988定义，或者可能是由RFC 6570定义的URI模板。
- en: 'The PSR-13 standard defines a series of interfaces that outline a common hypermedia
    format and a way to represent links between these formats:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PSR-13标准定义了一系列接口，概述了一个常见的超媒体格式以及表示这些格式之间链接的方法：
- en: '`Psr\Link\LinkInterface`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Link\LinkInterface`'
- en: '`Psr\Link\EvolvableLinkInterface`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Link\EvolvableLinkInterface`'
- en: '`Psr\Link\LinkProviderInterface`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Link\LinkProviderInterface`'
- en: '`Psr\Link\EvolvableLinkProviderInterface`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psr\Link\EvolvableLinkProviderInterface`'
- en: These interfaces can be fetched via Composer as a part of the `psr/link` package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口可以通过Composer作为`psr/link`包的一部分获取。
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\LinkInterface` definition,
    which represents a single readable link object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-13 `Psr\Link\LinkInterface` 的定义，代表了一个单一的可读链接对象：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\LinkProviderInterface` definition,
    which represents a single link provider object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-13 `Psr\Link\LinkProviderInterface` 的定义，代表了一个单一的链接提供者对象：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\EvolvableLinkInterface` definition,
    which represents a single evolvable link value object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-13 `Psr\Link\EvolvableLinkInterface` 的定义，代表了一个单一的可发展链接值对象：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code snippet reflects the PSR-13 `Psr\Link\EvolvableLinkProviderInterface` definition,
    which represents a single evolvable link provider value object:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段反映了PSR-13 `Psr\Link\EvolvableLinkProviderInterface` 的定义，代表了一个单一的可发展链接提供者值对象：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: here means that object instances of these interfaces exhibit the same behavior
    as those in PSR-7\. By default, objects need to be immutable. The moment an object
    state needs to change, that change should be reflected into a new object instance. Thanks
    to PHP's copy-on-write behavior, this is easy for the class to implement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这些接口的对象实例表现出与PSR-7相同的行为。默认情况下，对象需要是不可变的。当对象状态需要改变时，该变化应该反映到一个新的对象实例中。由于PHP的写时复制行为，这对类来说很容易实现。
- en: The copy-on-write behavior is a built-in mechanism of PHP code, whereas PHP
    takes care of avoiding unnecessary variable duplicates. Until one or more bytes
    of variable are changed, the variable is not being copied.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: PHP代码的写时复制行为是一个内置机制，PHP会避免不必要的变量复制。直到一个或多个字节的变量被改变，变量才会被复制。
- en: 'The official, full-length *PSR-13: Hypermedia Links* guide is available at
    [http://www.php-fig.org/psr/psr-13/](http://www.php-fig.org/psr/psr-13/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '官方的完整的*PSR-13: 超媒体链接*指南可以在[http://www.php-fig.org/psr/psr-13/](http://www.php-fig.org/psr/psr-13/)获取。'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The PHP-FIG group addresses a wide range of things through its PSRs. Some of
    them focus on the structure and readability of the code, others strive for increased
    interoperability by defining numerous interfaces. These PSRs, directly or indirectly, contribute
    to improved quality of our project and the third-party libraries we might use.
    The RFC 2119 standard was a common base for each of the PSR. It removes any ambiguity
    around may, must, should, and similar words that describe the standard. This ensures that
    the documentation gets read just as PHP-FIG intended it. While we might not be
    in touch with each of the standards on a day-to-day basis, it is worth paying
    attention to them when choosing the libraries for our project. Standard compliant
    libraries, such as Monolog, usually mean more flexibility, as we can easily switch
    between different libraries in later stages of the project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: PHP-FIG组通过其PSR解决了各种问题。其中一些关注代码的结构和可读性，其他则通过定义众多接口来增加互操作性。这些PSR，直接或间接地，有助于提高我们项目和我们可能使用的第三方库的质量。RFC
    2119标准是每个PSR的共同基础。它消除了围绕may、must、should等词语描述标准的任何歧义。这确保了文档被阅读时与PHP-FIG的意图一致。虽然我们可能不会每天都接触到这些标准中的每一个，但在选择项目的库时，注意它们是值得的。符合标准的库，比如Monolog，通常意味着更多的灵活性，因为我们可以在项目的后期轻松地在不同的库之间切换。
- en: Moving forward, we will look into configuration options, mechanisms, and libraries
    behind error handling and logging.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究错误处理和日志记录背后的配置选项、机制和库。

- en: The Realm of CLI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of modern application development evolves around visible bits and
    pieces. Whether we are talking about the server infrastructure, development tools,
    or the resulting application itself, graphical interfaces dominate our experience
    nowadays. While the diversity and overall list of available GUI tools seems endless,
    the console still remains an important part of development that any self-respectful
    developer should be familiar with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There are countless reasons why the console is simply the right tool for the
    job. Take large database backups, for example. Trying to backup gigabytes of MySQL
    data via the GUI tool is likely to result in a complete failure or a corrupt backup
    file, whereas the console-based `mysqldump` tool is impervious to the size of
    the backup or the time it takes for it to execute. Things such as large and time-consuming
    data imports, data exports, data synchronizations, and so on are common operations
    of many PHP applications. These are just some of the operations we would want
    to move away from the browser and into the console.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP CLI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Console component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input/output streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Process control:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ticks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alarms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiprocessing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PHP CLI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the console in PHP is quite easy via the help of PHP CLI SAPI,
    or just PHP CLI for short. PHP CLI was first introduced in PHP 4.2.0 as an experimental
    feature, and, soon after, it became fully supported and enabled by default in
    the later versions of PHP. The great thing about it is that it is available on
    all popular operating systems (Linux, Windows, OSX, Solaris). This makes it easy
    to write console applications that execute pretty much on any platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://en.wikipedia.org/wiki/Command-line_interface](https://en.wikipedia.org/wiki/Command-line_interface)
    and [https://en.wikipedia.org/wiki/Server_Application_Programming_Interface](https://en.wikipedia.org/wiki/Server_Application_Programming_Interface)
    for more elaborate descriptions of general CLI and SAPI abbreviations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: PHP CLI is not the only SAPI interface supported by PHP. Using the `php_sapi_name()`
    function, we can get a name of the current interface that PHP is using. Other
    possible interfaces include aolserver, apache, apache2handler, cgi, cgi-fcgi,
    cli, cli-server, continuity, embed, fpm-fcgi, and others.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a simple `php -v` command within our operating system console should
    give us an output similar to the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should serve as confirmation that PHP CLI SAPI is up and running. The
    CLI version of PHP has its own `php.ini` configuration, separate from other SAPI
    interfaces. Running the `php --ini` command on console will expose the following
    details about the currently used `php.ini` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see the location of the main configuration file (`php.ini`) and
    extension-specific configuration files. Chaining the configuration of these configuration
    files takes immediate effect, as they are loaded each time we invoke PHP.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Console component
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of popular PHP frameworks and platforms utilize some sort of console
    application in order to assist with development, deployment, and maintenance of
    our projects. The Symfony framework, for example, comes with its own console application
    empowered with dozens of nifty commands. These can be accessed by executing the
    `php bin/console` command within the root directory of a Symfony project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/086af8a0-b484-4fb2-bec4-888e392047ae.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Each of the listed commands executes a very specific purpose; therefore, assisting
    our project in various ways. While the Symfony framework installation and overall
    details are out of the scope of this book, there is a component within it that
    we are interested in. The Console component, while part of the Symfony framework,
    can also be used as a standalone component to build these types of console applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Console component
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Console component is available in two flavors:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台组件有两种风格：
- en: Composer package (`symfony/console` on Packagist)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Composer包（Packagist上的`symfony/console`）
- en: Git repository ([https://github.com/symfony/console](https://github.com/symfony/console))
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git存储库（[https://github.com/symfony/console](https://github.com/symfony/console)）
- en: 'Given that Composer is a de facto standard when it comes to dealing with PHP
    components, we will use the `composer require` command to quickly kick off our
    first console application, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Composer在处理PHP组件时是事实上的标准，我们将使用`composer require`命令快速启动我们的第一个控制台应用程序，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this command triggers the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会触发以下输出：
- en: '![](assets/b36d8c6f-3084-456e-b8b1-e3e52611e179.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b36d8c6f-3084-456e-b8b1-e3e52611e179.png)'
- en: 'Upon completion, Composer generates the following structure within our `foggyline`
    directory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Composer在我们的`foggyline`目录中生成以下结构：
- en: '![](assets/395e36f6-a466-45c8-a0ee-8034db47b8f3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/395e36f6-a466-45c8-a0ee-8034db47b8f3.png)'
- en: 'All it takes for us now is to create an application entry file, let''s say, `app.php`,
    and include the `vendor/autoload.php` file generated by Composer, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要创建一个应用程序入口文件，比如`app.php`，并包含由Composer生成的`vendor/autoload.php`文件，如下所示：
- en: '![](assets/af3d0eb5-355b-41f4-8a36-59865f0a107f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/af3d0eb5-355b-41f4-8a36-59865f0a107f.png)'
- en: 'The very first line of our file, known as *shebang*, contains the instructions
    required for autodetection of the type of script. While the line itself is not
    really necessary, it makes a difference between normally running `php app.php`
    or just `./app.php` in order to execute our application script. Following the
    *shebang* line is the PHP code that deals with the inclusion of `autoload.php` and
    instantiation of the `Console\Application` class. The `Console\Application` class
    accepts two parameters: the name of the application and the version we wish to
    assign to it. In between instantiating and running the app, we have a few commented-out
    lines that merely demonstrate where we would normally register our individual
    application commands.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行，称为*shebang*，包含自动检测脚本类型所需的指令。虽然这行本身并不是必需的，但它使得在执行应用程序脚本时，`php app.php`和`./app.php`之间有所不同。在*shebang*行之后是处理`autoload.php`的PHP代码和实例化`Console\Application`类。`Console\Application`类接受两个参数：应用程序的名称和我们希望分配给它的版本。在实例化和运行应用程序之间，我们有一些被注释掉的行，仅仅是演示我们通常会注册个别应用程序命令的地方。
- en: To learn more about the *shebang* character sequence, check out the Wikipedia
    article at [https://en.wikipedia.org/wiki/Shebang_(Unix)](https://en.wikipedia.org/wiki/Shebang_(Unix)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于*shebang*字符序列的信息，请查看维基百科文章[https://en.wikipedia.org/wiki/Shebang_(Unix)](https://en.wikipedia.org/wiki/Shebang_(Unix))。
- en: 'To put the *shebang* line into effect, the `app.php` file needs to be flagged
    as :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要使*shebang*行生效，`app.php`文件需要标记为：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these four lines of PHP code in place, we already have enough to execute
    our
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这四行PHP代码，我们已经有足够的条件来执行我们的
- en: '![](assets/3c023b4e-5e48-4cb3-9f95-af17274c9224.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c023b4e-5e48-4cb3-9f95-af17274c9224.png)'
- en: The output comes out colored and nicely formatted, just as we would expect from
    modern console applications. This is merely but a fraction of things that the
    Console component takes care for us. With this, we conclude our Console component
    setup. We can now go ahead and start registering our application commands using
    the `add()` method of an `$app` instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以彩色和良好的格式呈现，正如我们从现代控制台应用程序所期望的那样。这只是控制台组件为我们处理的一小部分。通过这个，我们完成了控制台组件的设置。现在我们可以继续使用`$app`实例的`add()`方法来注册我们的应用程序命令。
- en: Creating a console command
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个控制台命令
- en: 'Now that we have our *barebone* console application set up, let''s create three
    commands to handle the following imaginary actions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了*裸骨*控制台应用程序，让我们创建三个命令来处理以下虚构的操作：
- en: Customer register
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户注册
- en: Customer status set
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户状态设置
- en: Customer export
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户导出
- en: The word imaginary simply flags that we will not actually concern ourselves
    with the inner details of the executed commands, as our focus is understanding
    how to reuse the Console component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: “虚构”一词只是表示我们实际上不会关注执行命令的内部细节，因为我们的重点是理解如何重用控制台组件。
- en: We start by creating `CustomerRegisterCommand.php`, `CustomerStatusSetCommand.php`,
    and `CustomerExportCommand.php` within our project's `src/Foggyline/Console/Command/`
    directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在项目的`src/Foggyline/Console/Command/`目录中创建`CustomerRegisterCommand.php`，`CustomerStatusSetCommand.php`和`CustomerExportCommand.php`。
- en: '`CustomerRegisterCommand.php` file has the following content:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegisterCommand.php`文件的内容如下：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`CustomerStatusSetCommand.php` file has the following content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerStatusSetCommand.php`文件的内容如下：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CustomerExportCommand.php` file has the following content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerExportCommand.php`文件的内容如下：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that all three commands extend `Symfony\Component\Console\Command\Command`
    and provide their own implementation of the `configure()` and `execute()` methods.
    The `configure()` method is sort of like the constructor, where we would place
    our initial configuration, such as name of the command, its description, options,
    arguments, and so on. The `execute()` method is where our actual command logic
    needs to be implemented, or called if implemented elsewhere. With these three
    commands in place, we need to go back to the `app.php` file and modify its content
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有三个命令都扩展了`Symfony\Component\Console\Command\Command`，并提供了它们自己的`configure()`和`execute()`方法的实现。`configure()`方法有点像构造函数，我们可以在其中放置我们的初始配置，比如命令的名称、描述、选项、参数等。`execute()`方法是我们需要实现的实际命令逻辑的地方，或者在其他地方实现了则调用它。有了这三个命令，我们需要回到`app.php`文件并修改其内容如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compared to our initial `app.php` file, there are a few changes here. Notice
    the line where we require the `autoload.php` file. If we actually took a look
    at that file, we would see it returns an instance of the `Composer\Autoload\ClassLoader`
    class. This is the Composer's PSR-0, PSR-4, and classmap class loader that we
    can use to our advantage to load our commands. This is exactly what the `$loader->add('Foggyline'...`
    line is doing. Finally, we register our newly created commands using the application's
    `add()` method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初的`app.php`文件相比，这里有一些变化。请注意我们需要`autoload.php`文件的行。如果我们实际查看该文件，我们会发现它返回`Composer\Autoload\ClassLoader`类的一个实例。这是Composer的PSR-0、PSR-4和classmap类加载器，我们可以利用它来加载我们的命令。这正是`$loader->add('Foggyline'...`行所做的。最后，我们使用应用程序的`add()`方法注册我们新创建的命令。
- en: 'With these changes in place, executing our application yields the following
    output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，执行我们的应用程序会产生以下输出：
- en: '![](assets/079ca9bf-07c3-4f8f-bcd3-5ad1163b7797.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/079ca9bf-07c3-4f8f-bcd3-5ad1163b7797.png)'
- en: 'Our three commands are now appearing on the list of available commands. The
    `name` and `description` values we set within the command class `configure()`
    method are being shown for each command. We can now easily execute one these commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的三个命令现在出现在可用命令列表中。我们在`configure()`方法中设置的`name`和`description`值显示在每个命令中。我们现在可以轻松地执行其中一个命令：
- en: '![](assets/7cdae145-6fd9-4045-8634-f60bddbda2b7.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cdae145-6fd9-4045-8634-f60bddbda2b7.png)'
- en: The `Customer disabled.` label confirms the execution of our `CustomerStatusSetCommand`
    `execute()` method. While the overall concept of our console application and its
    commands was fairly easy to grasp so far, our commands are hardly useful at the
    moment, as we are not passing any inputs to them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer disabled.`标签确认了我们的`CustomerStatusSetCommand`的`execute()`方法的执行。虽然到目前为止，我们的控制台应用程序及其命令的整体概念相当容易理解，但我们的命令目前几乎没有用处，因为我们没有向它们传递任何输入。'
- en: Dealing with inputs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理输入
- en: 'Making practical and useful commands usually requires the ability to pass on
    the dynamic information from the operating system console to our application command. The
    Console component differentiates two types of inputs--`arguments` and `options`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 制作实用和有用的命令通常需要能够将操作系统控制台的动态信息传递给我们的应用程序命令。控制台组件区分两种类型的输入--`arguments`和`options`：
- en: Arguments are ordered, space-separated (`John Doe`), optional or required, string
    types of information. Assignment of arguments comes after the command name itself.
    We use the `addArgument()` method of the `Symfony\Component\Console\Command\Command` instance
    to assign arguments to our custom command.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是有序的，以空格分隔（`John Doe`），可选或必需，是字符串类型的信息。参数的分配在命令名称之后。我们使用`Symfony\Component\Console\Command\Command`实例的`addArgument()`方法来为我们的自定义命令分配参数。
- en: Options are unordered, two-dashes-separated (`--name=John --surname=Doe`), always
    optional, assigned type of information. The assignment of options comes after
    the command name itself. We use the `addOption()` method of the `Symfony\Component\Console\Command\Command` instance
    to assign options to our custom command.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项是无序的，以双破折号分隔（`--name=John --surname=Doe`），始终是可选的，分配的信息类型。选项的分配在命令名称之后。我们使用`Symfony\Component\Console\Command\Command`实例的`addOption()`方法来为我们的自定义命令分配选项。
- en: 'The `addArgument()` method accepts four parameters, as per the following synopsis:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`addArgument()`方法接受四个参数，如下概要所示：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whereas, the `addArgument()` method parameters have the following meanings:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 而`addArgument()`方法的参数具有以下含义：
- en: '`$name`: This is the argument name'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`: 这是参数名称'
- en: '`$mode`: This is the argument mode, which can be `InputArgument::REQUIRED`
    or `InputArgument::OPTIONAL`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$mode`: 这是参数模式，可以是`InputArgument::REQUIRED`或`InputArgument::OPTIONAL`'
- en: '`$description`: This is the description text'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$description`: 这是描述文本'
- en: '`$default`: This is the default value (for the `InputArgument::OPTIONAL` mode
    only)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$default`: 这是默认值（仅适用于`InputArgument::OPTIONAL`模式）'
- en: 'The `addOption()` method accepts five parameters, as per the following synopsis:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`addOption()`方法接受五个参数，如下概要所示：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Whereas, the `addOption()` method parameters have the following meanings:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 而`addOption()`方法的参数具有以下含义：
- en: '`$name`: This is the option name'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$name`: 这是选项名称'
- en: '`$shortcut`: This is the shortcut (it can be `null`)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$shortcut`: 这是快捷方式（可以为`null`）'
- en: '`$mode`: This is the option mode, which is one of the `InputOption::VALUE_*`
    constants'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$mode`: 这是选项模式，是`InputOption::VALUE_*`常量之一'
- en: '`$description`: This is the description text'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$description`: 这是描述文本'
- en: '`$default`: This is the default value (must be `null` for `InputOption::VALUE_NONE`)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$default`: 这是默认值（对于`InputOption::VALUE_NONE`必须为`null`）'
- en: We could easily build our commands such that they use the two input types together,
    as they do not exclude each other.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地构建我们的命令，使它们同时使用这两种输入类型，因为它们不互斥。
- en: 'Let''s go ahead and modify our `src\Foggyline\Console\Command\CustomerRegisterCommand.php`
    file with the following changes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修改我们的`src\Foggyline\Console\Command\CustomerRegisterCommand.php`文件，进行以下更改：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our modifications mainly extend the *group use* declaration and the `configure()`
    method. Within the `configure()` method, we are utilizing the `addArgument()`
    and `addOption()` instance methods to add the number of inputs to our command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的修改主要扩展了*group use*声明和`configure()`方法。在`configure()`方法中，我们利用`addArgument()`和`addOption()`实例方法来向我们的命令添加输入数量。
- en: 'Trying to execute our console command now, with no arguments, would trigger `RuntimaException`,
    as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试现在执行我们的控制台命令，不带任何参数，将触发`RuntimaException`，如下截图所示：
- en: '![](assets/db5aefff-19f3-4d51-8cbf-ae4c4d7486b7.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db5aefff-19f3-4d51-8cbf-ae4c4d7486b7.png)'
- en: 'The error is descriptive enough to provide a list of missing arguments. However,
    it does not trigger our own argument and option descriptions. To get those to
    show up, we could easily run a `./app.php customer:register --help` command. This
    tells the Console component to show the command details we specified:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 错误足够描述，可以提供缺少参数的列表。但它不会触发我们自己的参数和选项描述。要显示这些内容，我们可以轻松运行`./app.php customer:register
    --help`命令。这告诉控制台组件显示我们指定的命令详情：
- en: '![](assets/40788798-82a1-4754-a4e8-6e6e03806baa.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/40788798-82a1-4754-a4e8-6e6e03806baa.png)'
- en: 'Now that we see the exact descriptions behind our arguments and options, we
    can issue a more valid command that would not trigger an error, such as `./app.php
    customer:register John Doe --log=true`. Passing all required arguments progresses
    us to the `execute()` method, which has been modified to do a raw dump of the
    passed on values for our inspection, as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了我们参数和选项背后的确切描述，我们可以发出一个更有效的命令，不会触发错误，例如`./app.php customer:register John
    Doe --log=true`。传递所有必需的参数使我们进入`execute()`方法，该方法已被修改以对我们传递的值进行原始转储，如下面的截图所示：
- en: '![](assets/3b6b941a-3d2b-4c9c-b7a2-551bc977b841.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b6b941a-3d2b-4c9c-b7a2-551bc977b841.png)'
- en: We now have a simple, but working version of a command that is able to accept
    inputs. The `addArgument()` and `addOption()` methods made it really easy to define
    and describe these inputs via a single expression. The Console component has proven
    itself to be a really handy addition to our console application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个简单但有效的命令版本，可以接受输入。`addArgument()`和`addOption()`方法使得通过单个表达式定义和描述这些输入变得非常容易。控制台组件已经证明是我们控制台应用程序的一个非常方便的补充。
- en: Using Console component helpers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制台组件助手
- en: Understanding arguments and options is a first step towards utilizing the Console
    component. Once we understand how to deal with inputs, we turn our attention to
    other, more advanced features. The helpers feature helps us ease the common tasks,
    such as format outputs, show running processes, show updatable progress information,
    provide interactive QA process, display tabular data, and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理解参数和选项是利用控制台组件的第一步。一旦我们了解如何处理输入，我们就会转向其他更高级的功能。助手功能帮助我们轻松处理常见任务，如格式化输出，显示运行进程，显示可更新的进度信息，提供交互式问答过程，显示表格数据等。
- en: 'The following are several Console component helpers available for us to use:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以使用的几个控制台组件助手：
- en: Formatter Helper
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化助手
- en: Process Helper
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程助手
- en: Progress Bar
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条
- en: Question Helper
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题助手
- en: Table
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格
- en: Debug Formatter Helper
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试格式化助手
- en: You can see the full helper implementations within our project's `vendor\symfony\console\Helper`
    directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们项目的`vendor\symfony\console\Helper`目录中看到完整的助手实现。
- en: To showcase the ease of use of these helpers, let's go ahead and implement the
    simple *progress bar* and *table* helper within our *customer export* command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些助手的易用性，让我们继续在*customer export*命令中实现简单的*进度条*和*表格*助手。
- en: 'We do so by modifying the `execute()` method of the `src\Foggyline\Console\Command\CustomerExportCommand.php`
    class file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过修改`src\Foggyline\Console\Command\CustomerExportCommand.php`类文件的`execute()`方法来实现：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We start our code by adding a fake customer data. We then instantiate `ProgressBar`,
    passing it the count of entries in our fake customer data array. The progress
    bar instance requires explicit `start()`, `advance()`, and `finish()` method calls
    to actually advance the progress bar. Once the progress bar is done, we instantiate `Table`,
    passing it proper headers and the row data from our customer data array.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过添加虚假的客户数据来启动我们的代码。然后我们实例化`ProgressBar`，传递给它我们虚假客户数据数组中的条目数。进度条实例需要显式调用`start()`、`advance()`和`finish()`方法来实际推进进度条。一旦进度条完成，我们实例化`Table`，传递适当的标题和我们客户数据数组中的行数据。
- en: The console component helpers provide great deal of configuration options. To
    find out more, check out [http://symfony.com/doc/current/components/console/helpers/index.html](http://symfony.com/doc/current/components/console/helpers/index.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台组件助手提供了大量的配置选项。要了解更多信息，请查看[http://symfony.com/doc/current/components/console/helpers/index.html](http://symfony.com/doc/current/components/console/helpers/index.html)。
- en: 'With the preceding changes in place, triggering the `./app.php customer:export`
    command on console should now give the following output whilst the command is
    executing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行上述更改，触发控制台上的`./app.php customer:export`命令现在应该在执行命令时给出以下输出：
- en: '![](assets/c98e8d9b-b290-41b5-904e-9914b59fbd21.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c98e8d9b-b290-41b5-904e-9914b59fbd21.png)'
- en: 'We will first see the progress par kicking in, showing the exact progress.
    Once the progress bar is done, the table helper kicks in, making for the final
    output, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们会看到进度条显示确切的进度。一旦进度条完成，表格助手开始工作，生成最终输出，如下面的截图所示：
- en: '![](assets/23d67443-8fce-4e45-a208-fe95408d7e53.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23d67443-8fce-4e45-a208-fe95408d7e53.png)'
- en: Using helpers impacts our console application user experience for better. We
    are now able to write applications that provide informative and structured feeedback
    for user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用助手可以改善我们的控制台应用程序用户体验。我们现在能够编写提供信息丰富和结构化反馈的应用程序。
- en: Input/output streams
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入/输出流
- en: 'Quite early in development, every programmer stumbles upon the **streams**
    term. This seemingly frightening term represents a form of data. Unlike the typical
    finite type of data, streams represent a potentially unlimited *sequence* of data.
    In PHP terms, a stream is a resource object exhibiting streamable behavior. Using
    various wrappers, the PHP language supports a wide range of streams. The `stream_get_wrappers()`
    function can retrieve a list of all the registered stream wrappers available on
    the currently running system, such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的早期阶段，每个程序员都会遇到**流**这个术语。这个看似可怕的术语代表一种数据形式。与典型的有限数据类型不同，流代表一种潜在无限的数据*序列*。在PHP术语中，流是一种展现可流动行为的资源对象。使用各种包装器，PHP语言支持各种流。`stream_get_wrappers()`函数可以检索当前运行系统上所有已注册的流包装器的列表，例如以下内容：
- en: '`php`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php`'
- en: '`file`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`'
- en: '`glob`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob`'
- en: '`data`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`'
- en: '`http`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`'
- en: '`ftp`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftp`'
- en: '`zip`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`'
- en: '`compress.zlib`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress.zlib`'
- en: '`compress.bzip2`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress.bzip2`'
- en: '`https`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https`'
- en: '`ftps`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftps`'
- en: '`phar`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phar`'
- en: 'The list of wrappers is quite extensive, but not finite. We can also register
    our own wrappers using the `stream_wrapper_register()` function. Each wrapper
    tells the stream how to handle specific protocols and encodings. Each stream is
    therefore accessed through the `scheme://target` syntax, such as the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器的列表非常广泛，但并非无限。我们还可以使用`stream_wrapper_register()`函数注册自己的包装器。每个包装器告诉流如何处理特定的协议和编码。因此，每个流都是通过`scheme://target`语法访问的，例如以下内容：
- en: '`php://stdin`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`php://stdin`'
- en: '`file:///path/to/file.ext`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file:///path/to/file.ext`'
- en: '`glob://var/www/html/*.php`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob://var/www/html/*.php`'
- en: '`data://text/plain;base64,Zm9nZ3lsaW5l`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data://text/plain;base64,Zm9nZ3lsaW5l`'
- en: '`http://foggyline.net/`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://foggyline.net/`'
- en: The `scheme` part of the syntax indicates the name of the wrapper to be used,
    while the `target` part depends on the wrapper used. As a part of this section,
    we are interested in the `php` wrapper and its target values because they deal
    with the standard streams.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的`scheme`部分表示要使用的包装器的名称，而`target`部分取决于所使用的包装器。作为本节的一部分，我们对`php`包装器及其目标值感兴趣，因为它们涉及标准流。
- en: 'The standard streams are the following three I/O connections made available
    to all programs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标准流是以下三个I/O连接，可供所有程序使用：
- en: standard input (`stdin`) - file descriptor `0`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入（`stdin`）- 文件描述符`0`
- en: standard output (`stdout`) - file descriptor `1`
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输出（`stdout`）- 文件描述符`1`
- en: standard error (`stderr`) - file descriptor `2`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准错误（`stderr`）- 文件描述符`2`
- en: The file descriptor is an integer representing a handle used to access an I/O resource.
    As a part of the POSIX application programming interface, Unix processes are expected
    to have these three file descriptors. Knowing the file descriptor value, we could
    use `php://fd` to gain direct access to the given file descriptor, such as `php://fd/1`.
    However, there is a more elegant way of doing it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是一个表示用于访问I/O资源的句柄的整数。作为POSIX应用程序编程接口的一部分，Unix进程应该具有这三个文件描述符。知道文件描述符的值，我们可以使用`php://fd`来直接访问给定的文件描述符，例如`php://fd/1`。但是，还有一种更优雅的方法。
- en: To learn more about POSIX, check out [https://en.wikipedia.org/wiki/POSIX](https://en.wikipedia.org/wiki/POSIX).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于POSIX的信息，请查看[https://en.wikipedia.org/wiki/POSIX](https://en.wikipedia.org/wiki/POSIX)。
- en: 'Out of the box, the PHP CLI SAPI provides three constants for these three standard
    streams:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PHP CLI SAPI默认提供了这三个标准流的三个常量：
- en: '`define(''STDIN'', fopen(''php://stdin'', ''r''));`: This represents an already
    opened stream to `stdin`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define(''STDIN'', fopen(''php://stdin'', ''r''));`：这表示已经打开了一个到`stdin`的流'
- en: '`define(''STDOUT'', fopen(''php://stdout'', ''w''));`: This represents an already
    opened stream to `stdout`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define(''STDOUT'', fopen(''php://stdout'', ''w''));`：这表示已经打开了一个到`stdout`的流'
- en: '`define(''STDERR'', fopen(''php://stderr'', ''w''));`: This represents an already
    opened stream to `stderr`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`define(''STDERR'', fopen(''php://stderr'', ''w''));`：这表示已经打开了一个到`stderr`的流'
- en: 'The following simple code snippet demonstrates the use of these standard streams:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的代码片段演示了这些标准流的使用：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing it, we would first see Type something: on screen, after which, we would
    need to provide a string and hit *Enter*, which finally gives the following an
    output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它，我们首先会在屏幕上看到“输入一些内容：”，之后，我们需要提供一个字符串并按*Enter*，最后得到以下输出：
- en: '![](assets/d6efa063-fe02-445e-b39b-27e0de5ba669.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d6efa063-fe02-445e-b39b-27e0de5ba669.png)'
- en: While the example itself is ultimately simplified, it does showcase the ease
    of obtaining the stream handles. What we do with those streams, further depends
    on the functions that utilize the streams (`fopen()`, `fputs()`, and so on) and
    the actual stream functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例本身最终是简化的，但它展示了获得流句柄的简便性。我们对这些流做什么取决于使用流的函数（`fopen()`，`fputs()`等）和实际的流函数。
- en: PHP provides over forty stream functions, as well as the `streamWrapper` class
    prototype. These provide us with a means of creating and manipulating streams
    in pretty much any way imaginable. Check out [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)
    for more details.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了超过四十个流函数，以及`streamWrapper`类原型。这些为我们提供了一种以几乎任何想象得到的方式创建和操作流的方法。查看[http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)了解更多详情。
- en: Process control
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程控制
- en: Building CLI applications quite often implies working with the system processes.
    PHP provides a **powerful process control extension** called **PCNTL**. The extension
    allows us to handle process creation, program execution, signal handling, and
    process termination. It only works on Unix-like machines, where PHP is compiled
    with the `--enable-pcntl` configuration option.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 构建CLI应用程序往往意味着与系统进程一起工作。PHP提供了一个称为**PCNTL**的**强大的进程控制扩展**。该扩展允许我们处理进程创建、程序执行、信号处理和进程终止。它仅在类Unix机器上工作，其中PHP是使用`--enable-pcntl`配置选项编译的。
- en: 'To confirm that PCNTL is available on our system, we can execute the following
    console command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认PCNTL在我们的系统上可用，我们可以执行以下控制台命令：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Given the power it bares, the use of the PCNTL extension is discouraged in production
    web environments. Writing PHP daemons scripts for command-line applications is
    what we want to use it for.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它的功能，不鼓励在生产Web环境中使用PCNTL扩展。编写PHP守护进程脚本用于命令行应用程序是我们想要使用它的方式。
- en: To start putting things into perspective, let's go ahead and see how we would use
    the PCNTL features to handle process signals.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始有所了解，让我们继续看看如何使用PCNTL功能来处理进程信号。
- en: Ticks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ticks
- en: 'PCNTL relies on ticksfor its signal handling callback mechanism. The official
    definition ([http://php.net/manual/en/control-structures.declare.php](http://php.net/manual/en/control-structures.declare.php))
    of a tick says:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PCNTL依赖于ticks来进行信号处理回调机制。关于tick的官方定义（[http://php.net/manual/en/control-structures.declare.php](http://php.net/manual/en/control-structures.declare.php)）如下：
- en: A tick is an event that occurs for every N low-level tickable statements executed
    by the parser within the declare block. The value for N is specified using ticks=N
    within the declare block's directive section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: tick是在`declare`块内由解析器执行的N个低级tickable语句的事件。N的值是在`declare`块的指令部分使用`ticks=N`指定的。
- en: To elaborate on that, a tick is an event. Using the `declare()` language construct,
    we control how many statements it takes to set off a tick. We then use `register_
    tick_ function()` to execute our function upon each *fired tick*. Ticks are basically
    a side-effect of a number of evaluated expressions; the side effect we can react
    to with our custom functions. While most of the statements are tickable, certain condition
    expressions and argument expressions are not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明，tick是一个事件。使用`declare()`语言结构，我们控制了多少语句需要触发一个tick。然后我们使用`register_ tick_
    function()`在每个*触发的tick*上执行我们的函数。Ticks基本上是一系列被评估表达式的副作用；这是我们可以用我们的自定义函数来做出反应的副作用。虽然大多数语句是可tick的，但某些条件表达式和参数表达式是不可tick的。
- en: A *statement* is executed, while an *expression* is evaluated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行一个*语句*，而*表达式*是被评估的。
- en: 'Alongside the `declare()` language construct, PHP provides the following two
    functions to work with ticks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`declare()`语言结构，PHP还提供了以下两个函数来处理ticks：
- en: '`register_ tick_ function()`: This registers a function to be executed on each
    tick'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register_ tick_ function()`：这将注册一个函数，在每个tick上执行'
- en: '`unregister_ tick_ function()`: This deregisters a previously registered function'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unregister_ tick_ function()`：这将取消之前注册的函数'
- en: 'Let''s take a look at the following example, where the `declare()` construct
    uses the `{}` blocks to wrap the expressions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例，在这个示例中，`declare()`结构使用`{}`块来包装表达式：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is pretty much what we would expect, based on the carefully wrapped expressions
    within the `{}` blocks of the `declare()` construct. A tick is being nicely fired
    every second iteration of the loop.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们所期望的，基于`declare()`结构的`{}`块中精心包装的表达式。在循环的每秒迭代中，tick被很好地触发了。
- en: 'Let''s take a look at the following example, where the `declare()` construct
    is added as the first line of the PHP script without any `{}` blocks to wrap the
    expressions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例，在这个示例中，`declare()`结构被添加为PHP脚本的第一行，没有任何`{}`块来包装表达式：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This results in the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output here is not what we might expect at first. The *N* value, `ticks
    = 2`, does not seem to be respected as the tick seems to be fired after each and
    every statement. Even the last finished output is followed by one more tick.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出并不是我们一开始所期望的。`N`值，`ticks = 2`，似乎并没有被尊重，因为tick似乎在每个语句之后都被触发。即使最后完成的输出后面还跟着一个tick。
- en: Ticks provide the type of feature that may be useful to run monitoring, cleanup,
    notification, debugging, or other similar tasks. They should be used with utmost care,
    or else we might get some unexpected results, as we saw in the preceding example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Ticks提供了一种可能有用的功能，用于运行监视、清理、通知、调试或其他类似任务。它们应该被非常小心地使用，否则我们可能会得到一些意想不到的结果，就像我们在前面的例子中看到的那样。
- en: Signals
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: 'Signals are asynchronous messages sent to a running process within the POSIX-compliant
    operating systems. They can be sent both by users of programs. The following is
    a list of Linux-supported standard signals:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是在POSIX兼容的操作系统中发送给运行中进程的异步消息。它们可以被程序的用户发送。以下是Linux支持的标准信号列表：
- en: '`SIGHUP`: Hangup (POSIX)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP`：挂断（POSIX）'
- en: '`SIGINT`: Terminal interrupt (ANSI)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT`：终端中断（ANSI）'
- en: '`SIGQUIT`: Terminal quit (POSIX)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGQUIT`：终端退出（POSIX）'
- en: '`SIGILL`: Illegal instruction (ANSI)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGILL`：非法指令（ANSI）'
- en: '`SIGTRAP`: Trace trap (POSIX)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTRAP`：跟踪陷阱（POSIX）'
- en: '`SIGIOT`: IOT Trap (4.2 BSD)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGIOT`：IOT陷阱（4.2 BSD）'
- en: '`SIGBUS`: BUS error (4.2 BSD)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGBUS`：总线错误（4.2 BSD）'
- en: '`SIGFPE`: Floating point exception (ANSI)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGFPE`：浮点异常（ANSI）'
- en: '`SIGKILL`: Kill (can''t be caught or ignored) (POSIX)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL`：杀死（无法被捕获或忽略）（POSIX）'
- en: '`SIGUSR1`: User-defined signal 1 (POSIX)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR1`：用户定义信号1（POSIX）'
- en: '`SIGSEGV`: Invalid memory segment access (ANSI)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGSEGV`：无效的内存段访问（ANSI）'
- en: '`SIGUSR2`: User-defined signal 2 (POSIX)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR2`：用户定义信号2（POSIX）'
- en: '`SIGPIPE`: Write on a pipe with no reader, Broken pipe (POSIX)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGPIPE`：在没有读取器的管道上写入，管道中断（POSIX）'
- en: '`SIGALRM`: Alarm clock (POSIX)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGALRM`：闹钟（POSIX）'
- en: '`SIGTERM`: Termination (ANSI)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`：终止（ANSI）'
- en: '`SIGSTKFLT`: Stack fault'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGSTKFLT`：堆栈故障'
- en: '`SIGCHLD`: Child process has stopped or exited, changed (POSIX)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGCHLD`：子进程已停止或退出，已更改（POSIX）'
- en: '`SIGCONT`: Continue executing, if stopped (POSIX)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGCONT`：继续执行，如果停止（POSIX）'
- en: '`SIGSTOP`: Stop executing (can''t be caught or ignored) (POSIX)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGSTOP`：停止执行（无法被捕获或忽略）（POSIX）'
- en: '`SIGTSTP`: Terminal stop signal (POSIX)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTSTP`：终端停止信号（POSIX）'
- en: '`SIGTTIN`: Background process trying to read, from TTY (POSIX)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTTIN`：后台进程试图从TTY读取（POSIX）'
- en: '`SIGTTOU`: Background process trying to write, to TTY (POSIX)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTTOU`：后台进程试图写入TTY（POSIX）'
- en: '`SIGURG`: Urgent condition on socket (4.2 BSD)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGURG`：套接字上的紧急情况（4.2 BSD）'
- en: '`SIGXCPU`: CPU limit exceeded (4.2 BSD)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGXCPU`：CPU限制超过（4.2 BSD）'
- en: '`SIGXFSZ`: File size limit exceeded (4.2 BSD)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGXFSZ`：文件大小限制超过（4.2 BSD）'
- en: '`SIGVTALRM`: Virtual alarm clock (4.2 BSD)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGVTALRM`：虚拟闹钟（4.2 BSD）'
- en: '`SIGPROF`: Profiling alarm clock (4.2 BSD)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGPROF`：性能分析闹钟（4.2 BSD）'
- en: '`SIGWINCH`: Window size change (4.3 BSD, Sun)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGWINCH`：窗口大小改变（4.3 BSD，Sun）'
- en: '`SIGIO`: I/O now possible (4.2 BSD)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGIO`：现在可以进行I/O（4.2 BSD）'
- en: '`SIGPWR`: Power failure restart (System V)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGPWR`：电源故障重启（System V）'
- en: The user can initiate a signal message from the console manually using the `kill` command,
    such as `kill -SIGHUP 4321`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用`kill`命令从控制台手动发出信号消息，比如`kill -SIGHUP 4321`。
- en: The signals `SIGKILL` and `SIGSTOP` are the ultimate kill switch as they cannot
    be caught, blocked, or ignored.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGKILL`和`SIGSTOP`信号是终极的关闭开关，因为它们无法被捕获、阻止或忽略。'
- en: 'PHP provides several functions to work with signals, some of which are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了几个函数来处理信号，其中一些如下：
- en: '`pcntl_ signal()`: This installs a signal handler'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pcntl_ signal()`：这将安装一个信号处理程序'
- en: '`pcntl_ signal_ dispatch()`: This calls signal handlers for pending signals'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigprocmask()`: This sets and retrieves blocked signals'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigtimedwait()`: This waits for signals, with a timeout'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigwaitinfo()`: This waits for signals'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pcntl_ signal()` function is the most interesting one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example utilizing the `pcntl_ signal()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We start our code with the *declare ticks* definition. Without it, the installation
    of our custom `signalHandler` function via the `pcntl_signal()` function would
    have no effect. The `pcntl_signal()` function itself installs the `signalHandler()`
    function for the `SIGINT` signal. Running the preceding code will yield the following
    output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `^C` string indicates the moment when we hit *Ctrl* + *C* on our keyboard. We
    can see that it was immediately followed by a `Triggered signalHandler: *N*` output
    from our custom `signalHandler()` function. While we were successful at catching
    the `SIGINT` signal, we did not follow up and actually execute it once we were
    done with our `signalHandler()` function, which left the signal to be ignored,
    and allowed our program to continue executing. As it turns out, we just killed
    the default operating system functionality by allowing the program to keep executing
    after *Ctrl* + *C* is pressed.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: How do signals help us out? First of, a simple `exit;` call within the `signalHandler()`
    function would sort out the broken functionality in this case. Beyond that, we
    are left with a powerful mechanism where we get to tap into (almost) any system
    signal and execute any arbitrary code we choose to.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Alarms
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pcntl_alarm()` function enriches the PHP signals functionality by providing
    an alarm clock for delivery of a signal. Simply put, it creates a timer that sends
    a `SIGALRM` signal to the process after a given number of seconds.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Once the alarm is fired, the signal handler function kicks in. Once the signal
    handler function code is done executing, we are taken back to the point in code
    where the application stopped before jumping into a signal handler function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following piece of code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are using the `pcntl_signal()` function to register `signalHandler` as a
    signal handler function for the `SIGALRM` signal. We then call the `pcntl_alarm()`
    function, passing it the integer value of 7 seconds. The while loop is set to
    merely output something to the console, in order for us to understand the alarm
    behavior more easily. Once executed, the following output is shown:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see that the `Triggered signalHandler: 14` string is shown only once.
    This is because the alarm was triggered only once. The timing shown in the output
    indicates the exact seven seconds of delay between the first loop iteration and
    the alarm. We could easily fire another `pcntl_alarm()` function call within the `signalHandler()`
    function itself:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This would then transform our output into something like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Though specifying multiple alarms is possible, doing so before the previous
    alarm was reached, makes the new alarm replace the old alarm. The usefulness of
    alarms becomes obvious when performing a non-linear processing inside our application.
    The `pcntl_alarm()` function is non-blocking, making it easy to toss around, without
    worrying about blocking the program execution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Multiprocessing
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When speaking of **multiprocessing**, we often come across two seemingly colliding terms:
    **process** and **thread**. Where the process can be thought of as a currently
    running instance of an application, a thread is a path of execution within a process.
    A thread can do pretty much anything a process can do. However, given that threads
    reside within the process, we look at them as a solution for lightweight tasks,
    or at least tasks lighter than those employed by a process.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP language leaves a lot to be desired in terms of multiprocessing/multithreading.
    The following two stand out as the most popular solutions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`pcntl_fork()`: This is a function that forks the currently running process'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pcntl_fork()`：这是一个分叉当前运行进程的函数'
- en: '`pthreads`: This is an object-orientated API that provides multithreading based
    on Posix threads'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthreads`：这是一个基于Posix线程提供多线程的面向对象API'
- en: The `pcntl_fork()` function is a part of the PCNTL extension, whose functions
    we used in previous sections as well. The function only forks processes and cannot
    make threads. While `pthreads` is a more modern and OOP-aligned solution, we will
    continue our journey throughout this section with the `pcntl_fork()` function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcntl_fork()`函数是PCNTL扩展的一部分，我们在之前的部分中也使用了它的函数。该函数只能分叉进程，不能创建线程。虽然`pthreads`是一种更现代和面向对象的解决方案，但在本节中我们将继续使用`pcntl_fork()`函数。'
- en: 'When we run the `pcntl_fork()` function, it creates a child process for us.
    This child process differs from the parent process only by its `PID` and `PPID`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`pcntl_fork()`函数时，它为我们创建了一个子进程。这个子进程与父进程的唯一区别在于它的`PID`和`PPID`：
- en: '`PID`: This is the Process ID'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID`：这是进程ID'
- en: '`PPID`: This is the Parent Process ID, the one that launched this PID'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PPID`：这是父进程ID，启动此PID的进程'
- en: While the actual process forking with the `pcntl_fork()` function is quite easy,
    it leaves several challenges for us to tackle. Challenges such as *communication
    between processes* and *zombie children processes* make it tedious to deliver
    stable applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`pcntl_fork()`函数进行实际进程分叉非常简单，但它给我们留下了一些挑战。诸如*进程间通信*和*僵尸子进程*之类的挑战使得交付稳定的应用程序变得繁琐。
- en: 'Let''s take a look at the following use of the `pcntl_fork()` function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`pcntl_fork()`函数的以下用法：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code results in the following output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出结果如下：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The console returned the control immediately, despite having five children processes running.
    The control was first returned right before the Child 1 string was outputted,
    and then, a few seconds later, all of the Child strings were outputted and the
    console returned the control once again. The output clearly shows that the children
    are not necessarily executed in the order they are forked in. The operating system
    decides on this, not us. We can further tune the behavior using the `pcntl_waitpid()`
    and `pcntl_wexitstatus()` functions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有五个子进程在运行，但控制台立即返回了控制权。控制权首先在输出Child 1字符串之前返回，然后几秒钟后，所有Child字符串都被输出，控制台再次返回了控制权。输出清楚地显示子进程不一定按照它们被分叉的顺序执行。这由操作系统决定，而不是我们。我们可以进一步使用`pcntl_waitpid()`和`pcntl_wexitstatus()`函数来调整行为。
- en: 'The `pcntl_waitpid()` function instructs PHP to wait for a child, whereas the
    `pcntl_wexitstatus()` function fetches the value returned by a terminated child.
    The following example demonstrates this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcntl_waitpid()`函数指示PHP等待子进程，而`pcntl_wexitstatus()`函数获取终止子进程返回的值。以下示例演示了这一点：'
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While the majority of this example is similar to the previous one, notice the
    whole `while` loop at the bottom. The `while` loop will loop until the `pcntl_waitpid()`
    function returns `-1` (no children left). Each iteration of the `while` loop checks
    for the return code of a terminated child, and stores it into the `$status` variable,
    which is then again evaluated in the `while` loop expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子的大部分内容与上一个例子相似，但请注意底部的整个`while`循环。`while`循环将一直循环直到`pcntl_waitpid()`函数返回`-1`（没有子进程了）。`while`循环的每次迭代都会检查终止子进程的返回代码，并将其存储到`$status`变量中，然后再次在`while`循环表达式中进行评估。
- en: Check out [http://php.net/manual/en/ref.pcntl.php](http://php.net/manual/en/ref.pcntl.php)
    for more details about the `pcntl_fork()`, `pcntl_waitpid()`, and `pcntl_wexitstatus()`
    function parameters and return values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://php.net/manual/en/ref.pcntl.php](http://php.net/manual/en/ref.pcntl.php)以获取有关`pcntl_fork()`、`pcntl_waitpid()`和`pcntl_wexitstatus()`函数参数和返回值的更多详细信息。
- en: 'The preceding code results in the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出结果如下：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The console did not return the control now until all of the children finished
    executing, which is probably the preferred solution for most of the tasks we might
    be doing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台直到所有子进程执行完毕才会返回控制权，这可能是大多数任务的首选解决方案。
- en: Though process forking opens up several possibilities for us, we need to ask ourselves,
    Is it really worth the effort? If simply restructuring our application to use
    more message queues, CRONs, and other simpler technologies can yield a similar performance
    with the benefit of easier scaling, maintenance, and debugging, then we should
    probably avoid forking.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进程分叉为我们打开了几种可能性，但我们需要问自己，这真的值得吗？如果简单地重组我们的应用程序以使用更多的消息队列、CRON和其他更简单的技术，可以获得类似的性能，并且更容易扩展、维护和调试，那么我们可能应该避免分叉。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we have familiarized ourselves with some of the interesting
    features and tooling around PHP CLI. This chapter started with a basic introduction
    to PHP CLI SAPI, as one of the many SAPI interfaces in PHP. We then took a look
    into a simple but powerful Console component, learning how easy it is to create
    our own console applications. The I/O streams section helped us understand the
    standard streams, and how they are handled by PHP. Finally, we looked into the
    process control functions offered by the PCNTL extension. Combined together, these
    functions open up a wide range of possibilities to write our console applications.
    While the overall console application development might not seem interesting enough
    in comparison to more browser-facing applications, it certainly has its role in
    modern development. The CLI environment simply allows much greater control of
    our application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了PHP CLI周围一些有趣的特性和工具。本章以PHP CLI SAPI的基本介绍开始，作为PHP中众多SAPI接口之一。然后我们深入了解了一个简单但功能强大的控制台组件，学习了如何轻松创建自己的控制台应用程序。I/O流部分帮助我们理解标准流以及它们如何被PHP处理。最后，我们深入了解了PCNTL扩展提供的进程控制函数。这些函数的组合为我们编写控制台应用程序打开了广阔的可能性。虽然与面向浏览器的应用程序相比，整体控制台应用程序开发可能不够有趣，但它在现代开发中肯定有其作用。CLI环境简单地允许我们更好地控制我们的应用程序。
- en: Moving forward, we will take a look into one of the most important and interesting
    OOP features in PHP.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 往前看，我们将深入了解PHP中最重要和有趣的面向对象编程特性之一。

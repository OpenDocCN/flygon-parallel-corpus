["```py\nIn [ ]:\n    from alpha_vantage.timeseries import TimeSeries\n\n     # Update your Alpha Vantage API key here...\n     ALPHA_VANTAGE_API_KEY = 'PZ2ISG9CYY379KLI'\n\n     ts = TimeSeries(key=ALPHA_VANTAGE_API_KEY, output_format='pandas')\n     df_spx_data, meta_data = ts.get_daily_adjusted(\n         symbol='^GSPC', outputsize='full')\n```", "```py\nIn [ ]:\n    df_vix_data, meta_data = ts.get_daily_adjusted(\n         symbol='^VIX', outputsize='full')\n```", "```py\nIn [ ]:\n    df_spx_data.info()\nOut[ ]:   \n    <class 'pandas.core.frame.DataFrame'>\n    Index: 4774 entries, 2000-01-03 to 2018-12-21\n    Data columns (total 8 columns):\n    1\\. open                 4774 non-null float64\n    2\\. high                 4774 non-null float64\n    3\\. low                  4774 non-null float64\n    4\\. close                4774 non-null float64\n    5\\. adjusted close       4774 non-null float64\n    6\\. volume               4774 non-null float64\n    7\\. dividend amount      4774 non-null float64\n    8\\. split coefficient    4774 non-null float64\n    dtypes: float64(8)\n    memory usage: 317.0+ KB\n```", "```py\nIn [ ]:\n    df_vix_data.info()\nOut[ ]: \n    <class 'pandas.core.frame.DataFrame'>\n    Index: 4774 entries, 2000-01-03 to 2018-12-21\n    Data columns (total 8 columns):\n    1\\. open                 4774 non-null float64\n    2\\. high                 4774 non-null float64\n    3\\. low                  4774 non-null float64\n    4\\. close                4774 non-null float64\n    5\\. adjusted close       4774 non-null float64\n    6\\. volume               4774 non-null float64\n    7\\. dividend amount      4774 non-null float64\n    8\\. split coefficient    4774 non-null float64\n    dtypes: float64(8)\n    memory usage: 317.0+ KB\n```", "```py\nIn [ ]:\n    import pandas as pd\n\n    df = pd.DataFrame({\n        'SPX': df_spx_data['5\\. adjusted close'],\n        'VIX': df_vix_data['5\\. adjusted close']\n    })\n    df.index = pd.to_datetime(df.index)\n```", "```py\nIn [ ]:\n    df.head(3)\n```", "```py\nIn [ ]:\n    df.index\nOut[ ]:\n    DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n                   '2000-01-07', '2000-01-10', '2000-01-11', '2000-01-12',\n                   '2000-01-13', '2000-01-14',\n                   ...\n                   '2018-10-11', '2018-10-12', '2018-10-15', '2018-10-16',\n                   '2018-10-17', '2018-10-18', '2018-10-19', '2018-10-22',\n                   '2018-10-23', '2018-10-24'],\n                  dtype='datetime64[ns]', name='date', length=4734, freq=None)\n```", "```py\nIn [ ]:\n    df.describe()\n```", "```py\nIn [ ]:\n    df.info()\nOut[ ]:    \n    <class 'pandas.core.frame.DataFrame'>\n    DatetimeIndex: 4734 entries, 2000-01-03 to 2018-10-24\n    Data columns (total 2 columns):\n    SPX    4734 non-null float64\n    VIX    4734 non-null float64\n    dtypes: float64(2)\n    memory usage: 111.0 KB\n```", "```py\nIn [ ]:\n    %matplotlib inline\n    import matplotlib.pyplot as plt\n\n    plt.figure(figsize = (12, 8))\n\n    ax_spx = df['SPX'].plot()\n    ax_vix = df['VIX'].plot(secondary_y=True)\n\n    ax_spx.legend(loc=1)\n    ax_vix.legend(loc=2)\n\n    plt.show();\n```", "```py\nIn [ ]:\n    df.diff().hist(\n        figsize=(10, 5),\n        color='blue',\n        bins=100);\n```", "```py\nIn [ ]:\n    df.pct_change().hist(\n         figsize=(10, 5),\n          color='blue',\n          bins=100);\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    log_returns = np.log(df / df.shift(1)).dropna()\n    log_returns.plot(\n        subplots=True,\n        figsize=(10, 8),\n        color='blue',\n        grid=True\n    );\n    for ax in plt.gcf().axes:\n        ax.legend(loc='upper left')\n```", "```py\nIn [ ]:\n    log_returns.corr()\n```", "```py\nIn [ ]:\n    import statsmodels.api as sm\n\n    log_returns.plot(\n        figsize=(10,8),\n         x=\"SPX\",\n         y=\"VIX\",\n         kind='scatter')\n\n    ols_fit = sm.OLS(log_returns['VIX'].values,\n    log_returns['SPX'].values).fit()\n\n    plt.plot(log_returns['SPX'], ols_fit.fittedvalues, 'r');\n```", "```py\nIn [ ]:\n    plt.ylabel('Rolling Annual Correlation')\n\n    df_corr = df['SPX'].rolling(252).corr(other=df['VIX'])\n    df_corr.plot(figsize=(12,8));\n```", "```py\nIn [ ]:\n    import csv \n\n    META_DATA_ROWS = 3  # Header data starts at line 4\n    COLS = 7  # Each option data occupy 7 columns\n\n    def read_file(filepath):\n        meta_rows = []\n        calls_and_puts = []\n\n        with open(filepath, 'r') as file:\n            reader = csv.reader(file)\n            for row, cells in enumerate(reader):\n                if row < META_DATA_ROWS:\n                    meta_rows.append(cells)\n                else:\n                    call = cells[:COLS]\n                    put = cells[COLS:-1]\n\n                    calls_and_puts.append((call, put))                        \n\n        return (meta_rows, calls_and_puts)\n```", "```py\nIn [ ]:\n    (meta_rows, calls_and_puts) = \\\n        read_file('files/chapter07/SPX_EOD_2018_10_15.csv')\n```", "```py\nIn [ ]:\n    for line in meta_rows:\n        print(line)\nOut[ ]:\n    ['SPX (S&P 500 INDEX)', '2750.79', '-16.34']\n    ['Oct 15 2018 @ 20:00 ET']\n    ['Calls', 'Last Sale', 'Net', 'Bid', 'Ask', 'Vol', 'Open Int', 'Puts', 'Last Sale', 'Net', 'Bid', 'Ask', 'Vol', 'Open Int']\n```", "```py\nIn [ ]:\n    from dateutil import parser\n\n    def get_dt_current(meta_rows):\n        \"\"\"\n        Extracts time information.\n\n        :param meta_rows: 2D array\n        :return: parsed datetime object\n        \"\"\"\n        # First cell of second row contains time info\n        date_time_row = meta_rows[1][0]\n\n        # Format text as ET time string\n        current_time = date_time_row.strip()\\\n            .replace('@ ', '')\\\n            .replace('ET', '-05:00')\\\n            .replace(',', '')\n\n        dt_current =  parser.parse(current_time)\n        return dt_current\n```", "```py\nIn [ ]:\n    dt_current =  get_dt_current(meta_rows)\n    print(dt_current)\nOut[ ]:    \n    2018-10-15 20:00:00-05:00\n```", "```py\nIn [ ]:\n    for line in calls_and_puts[:2]:\n        print(line)\nOut[ ]:\n    (['2018 Oct 15 1700.00 (SPXW1815J1700)', '0.0', '0.0', '1039.30', '1063.00', '0',     '0'], ['2018 Oct     15 1700.00 (SPXW1815V1700)', '0.15', '0.0', ' ', '0.05', '0'])\n    (['2018 Oct 15 1800.00 (SPXW1815J1800)', '0.0', '0.0', '939.40', '963.00', '0',     '0'], ['2018 Oct     15 1800.00 (SPXW1815V1800)', '0.10', '0.0', ' ', '0.05', '0'])\n```", "```py\nIn [ ]:\n    from decimal import Decimal\n\n    def parse_expiry_and_strike(text):\n        \"\"\"\n        Extracts information about the contract data.\n\n        :param text: the string to parse.\n        :return: a tuple of expiry date and strike price\n        \"\"\"\n        # SPXW should expire at 3PM Chicago time.\n        [year, month, day, strike, option_code] = text.split(' ')\n        expiry = '%s %s %s 3:00PM -05:00' % (year, month, day)\n        dt_object = parser.parse(expiry)    \n\n        \"\"\"\n        Third friday SPX standard options expire at start of trading\n        8.30 A.M. Chicago time.\n        \"\"\"\n        if is_third_friday(dt_object):\n            dt_object = dt_object.replace(hour=8, minute=30)\n\n        strike = Decimal(strike)    \n        return (dt_object, strike)\n```", "```py\nIn [ ]:\n    def is_third_friday(dt_object):\n        return dt_object.weekday() == 4 and 15 <= dt_object.day <= 21\n```", "```py\nIn [ ]:\n    test_contract_code = '2018 Sep 26 1800.00 (*)'\n    (expiry, strike) = parse_expiry_and_strike(test_contract_code)\nIn [ ]:\n    print('Expiry:', expiry)\n    print('Strike price:', strike)\nOut[ ]:\n    Expiry: 2018-09-26 15:00:00-05:00\n    Strike price: 1800.00\n```", "```py\nIn [ ]:\n    test_contract_code = '2018 Oct 19 2555.00 (*)'\n    (expiry, strike) = parse_expiry_and_strike(test_contract_code)\nIn [ ]:    \n    print('Expiry:', expiry)\n    print('Strike price:', strike)\nOut[ ]:\n    Expiry: 2018-10-19 08:30:00-05:00\n    Strike price: 2555.00\n```", "```py\nIn [ ]:\n    def format_option_data(option_data):\n        [desc, _, _, bid_str, ask_str] = option_data[:5]\n        bid = Decimal(bid_str.strip() or '0')\n        ask = Decimal(ask_str.strip() or '0')\n        mid = (bid+ask) / Decimal(2)\n        (expiry, strike) = parse_expiry_and_strike(desc)\n        return (expiry, strike, bid, ask, mid)\n```", "```py\nIn [ ]:\n    CALL_COLS = ['call_bid', 'call_ask', 'call_mid']\n    PUT_COLS = ['put_bid', 'put_ask', 'put_mid']\n    COLUMNS = CALL_COLS + PUT_COLS + ['diff']\n```", "```py\nIn [ ]:\n    import pandas as pd\n\n    def generate_options_chain(calls_and_puts):\n        chain = {}\n\n        for row in calls_and_puts:\n            (call, put) = row\n\n            (call_expiry, call_strike, call_bid, call_ask, call_mid) = \\\n                format_option_data(call)\n            (put_expiry, put_strike, put_bid, put_ask, put_mid) = \\\n                format_option_data(put)\n\n            # Ensure each line contains the same put and call maturity\n            assert(call_expiry == put_expiry)\n\n            # Get or create the DataFrame at the expiry\n            df = chain.get(call_expiry, pd.DataFrame(columns=COLUMNS))\n\n            df.loc[call_strike, CALL_COLS] = \\\n                [call_bid, call_ask, call_mid]\n            df.loc[call_strike, PUT_COLS] = \\\n                [put_bid, put_ask, put_mid]\n            df.loc[call_strike, 'diff'] = abs(put_mid-call_mid)\n\n            chain[call_expiry] = df\n\n        return chain\nIn [ ]:\n    chain = generate_options_chain(calls_and_puts)\n```", "```py\nIn [ ]:\n    chain_keys = list(chain.keys())\n    for row in chain_keys[:2]:\n        print(row)\n    print('...')\n    for row in chain_keys[-2:]:\n        print(row)\nOut[ ]:\n    2018-10-15 15:00:00-05:00\n    2018-10-17 15:00:00-05:00\n    ...\n    2020-06-19 08:30:00-05:00\n    2020-12-18 08:30:00-05:00\n```", "```py\nIn [ ]:\n    def find_option_terms(chain, dt_current):\n        \"\"\"\n        Find the near-term and next-term dates from\n        the given indexes of the dictionary.\n\n        :param chain: dictionary object\n        :param dt_current: DateTime object of option quotes\n        :return: tuple of 2 datetime objects\n        \"\"\"\n        dt_near = None\n        dt_next = None\n\n        for dt_object in chain.keys():\n            delta = dt_object - dt_current\n            if delta.days > 23:\n                # Skip non-fridays\n                if dt_object.weekday() != 4:\n                    continue\n\n                # Save the near term date\n                if dt_near is None:\n                    dt_near = dt_object            \n                    continue\n\n                # Save the next term date\n                if dt_next is None:\n                    dt_next = dt_object            \n                    break\n\n        return (dt_near, dt_next)\nOut[ ]:\n    (dt_near, dt_next) = find_option_terms(chain, dt_current)\n```", "```py\nIn [ ]:\n    print('Found near-term maturity', dt_near, \n          'with', dt_near-dt_current, 'to expiry')\n    print('Found next-term maturity', dt_next, \n          'with', dt_next-dt_current, 'to expiry')\nOut[ ]:\n    Found near-term maturity 2018-11-09 15:00:00-05:00 with 24 days, 19:00:00 to expiry\n    Found next-term maturity 2018-11-16 08:30:00-05:00 with 31 days, 12:30:00 to expiry\n```", "```py\nIn [ ]:\n    dt_start_year = dt_current.replace(\n        month=1, day=1, hour=0, minute=0, second=0)\n    dt_end_year = dt_start_year.replace(year=dt_current.year+1)\n\n    N_t1 = Decimal((dt_near-dt_current).total_seconds() // 60)\n    N_t2 = Decimal((dt_next-dt_current).total_seconds() // 60)\n    N_30 = Decimal(30 * 24 * 60)\n    N_365 = Decimal((dt_end_year-dt_start_year).total_seconds() // 60)\n```", "```py\nIn [ ]:\n    print('N_365:', N_365)\n    print('N_30:', N_30)\n    print('N_t1:', N_t1)\n    print('N_t2:', N_t2)\nOut[ ]:\n    N_365: 525600\n    N_30: 43200\n    N_t1: 35700\n    N_t2: 45390\n```", "```py\nIn [ ]:\n    t1 = N_t1 / N_365\n    t2 = N_t2 / N_365\nIn [ ]:\n    print('t1:%.5f'%t1)\n    print('t2:%.5f'%t2)\nOut[ ]:\n    t1:0.06792\n    t2:0.08636\n```", "```py\nIn [ ]:\n    import math\n\n    def determine_forward_level(df, r, t):\n        \"\"\"\n        Calculate the forward SPX Index level.\n\n        :param df: pandas DataFrame for a single option chain\n        :param r: risk-free interest rate for t\n        :param t: time to settlement in years\n        :return: Decimal object\n        \"\"\"\n        min_diff = min(df['diff'])\n        pd_k = df[df['diff'] == min_diff]\n        k = pd_k.index.values[0]\n\n        call_price = pd_k.loc[k, 'call_mid']\n        put_price = pd_k.loc[k, 'put_mid']\n        return k + Decimal(math.exp(r*t))*(call_price-put_price\n```", "```py\nIn [ ]:\n    r = Decimal(2.17/100)\nIn [ ]:\n    df_near = chain.get(dt_near)\n    f1 = determine_forward_level(df_near, r, t1)\nIn [ ]:\n    print('f1:', f1)\nOut[ ]:\n    f1: 2747.596459994546094129930225\n```", "```py\nIn [ ]:\n    def find_k0(df, f):\n        return df[df.index<f].tail(1).index.values[0]\n```", "```py\nIn [ ]:\n    k0_near = find_k0(df_near, f1)\nIn [ ]:\n    print('k0_near:', k0_near)\nOut[ ]:\n    k0_near: 2745.00\n```", "```py\nIn [ ]:\n    def find_lower_and_upper_bounds(df, k0):\n        \"\"\"\n        Find the lower and upper boundary strike prices.\n\n        :param df: the pandas DataFrame of option chain\n        :param k0: the forward strike price\n        :return: a tuple of two Decimal objects\n        \"\"\"\n        # Find lower bound\n        otm_puts = df[df.index<k0].filter(['put_bid', 'put_ask'])\n        k_lower = 0\n        for i, k in enumerate(otm_puts.index[::-1][:-2]):\n            k_lower = k\n            put_bid_t1 = otm_puts.iloc[-i-1-1]['put_bid']\n            put_bid_t2 = otm_puts.iloc[-i-1-2]['put_bid']\n            if put_bid_t1 == 0 and put_bid_t2 == 0:\n                break\n            if put_bid_t2 == 0:\n                k_lower = otm_puts.index[-i-1-1]\n\n        # Find upper bound\n        otm_calls = df[df.index>k0].filter(['call_bid', 'call_ask'])    \n        k_upper = 0\n        for i, k in enumerate(otm_calls.index[:-2]):\n            call_bid_t1 = otm_calls.iloc[i+1]['call_bid']\n            call_bid_t2 = otm_calls.iloc[i+2]['call_bid']\n            if call_bid_t1 == 0 and call_bid_t2 == 0:\n                k_upper = k\n                break\n\n        return (k_lower, k_upper)\n```", "```py\nIn [ ]:\n    (k_lower_near, k_upper_near) = \\\n        find_lower_and_upper_bounds(df_near, k0_near)\nIn [ ]:\n    print(k_lower_near, k_upper_near\nOut[ ]:\n    1250.00 3040.00\n```", "```py\nIn [ ]:\n    def calculate_contrib_by_strike(delta_k, k, r, t, q):\n        return (delta_k / k**2)*Decimal(math.exp(r*t))*q\n```", "```py\nIn [ ]:\n    def find_prev_k(k, i, k_lower, df, bid_column):\n        \"\"\"\n        Finds the strike price immediately below k \n        with non-zero bid.\n\n        :param k: current strike price at i\n        :param i: current index of df\n        :param k_lower: lower strike price boundary of df\n        :param bid_column: The column name that reads the bid price.\n            Can be 'put_bid' or 'call_bid'.\n        :return: strike price as Decimal object.\n        \"\"\"    \n        if k <= k_lower:\n            k_prev = df.index[i-1]\n            return k_prev\n\n        # Iterate backwards to find put bids           \n        k_prev = 0\n        prev_bid = 0\n        steps = 1\n        while prev_bid == 0:                                \n            k_prev = df.index[i-steps]\n            prev_bid = df.loc[k_prev][bid_column]\n            steps += 1\n\n        return k_prev\n```", "```py\nIn [ ]:\n    def find_next_k(k, i, k_upper, df, bid_column):\n        \"\"\"\n        Finds the strike price immediately above k \n        with non-zero bid.\n\n        :param k: current strike price at i\n        :param i: current index of df\n        :param k_upper: upper strike price boundary of df\n        :param bid_column: The column name that reads the bid price.\n            Can be 'put_bid' or 'call_bid'.\n        :return: strike price as Decimal object.\n        \"\"\"    \n        if k >= k_upper:\n            k_next = df.index[i+1]\n            return k_next\n\n        k_next = 0\n        next_bid = 0\n        steps = 1\n        while next_bid == 0:\n            k_next = df.index[i+steps]\n            next_bid = df.loc[k_next][bid_column]\n            steps += 1\n\n        return k_next\n```", "```py\nIn [ ]:\n    import pandas as pd\n\n    def tabulate_contrib_by_strike(df, k0, k_lower, k_upper, r, t):\n        \"\"\"\n        Computes the contribution to the VIX index\n        for every strike price in df.\n\n        :param df: pandas DataFrame containing the option dataset\n        :param k0: forward strike price index level\n        :param k_lower: lower boundary strike price\n        :param k_upper: upper boundary strike price\n        :param r: the risk-free interest rate\n        :param t: the time to expiry, in years\n        :return: new pandas DataFrame with contributions by strike price\n        \"\"\"\n        COLUMNS = ['Option Type', 'mid', 'contrib']\n        pd_contrib = pd.DataFrame(columns=COLUMNS)\n\n        for i, k in enumerate(df.index):\n            mid, bid, bid_column = 0, 0, ''\n            if k_lower <= k < k0:\n                option_type = 'Put'\n                bid_column = 'put_bid'\n                mid = df.loc[k]['put_mid']\n                bid = df.loc[k][bid_column]\n            elif k == k0:\n                option_type = 'atm'\n            elif k0 < k <= k_upper:\n                option_type = 'Call'\n                bid_column = 'call_bid'\n                mid = df.loc[k]['call_mid']\n                bid = df.loc[k][bid_column]\n            else:\n                continue  # skip out-of-range strike prices\n\n            if bid == 0:\n                continue  # skip zero bids\n\n            k_prev = find_prev_k(k, i, k_lower, df, bid_column)\n            k_next = find_next_k(k, i, k_upper, df, bid_column)\n            delta_k = Decimal((k_next-k_prev)/2)\n\n            contrib = calculate_contrib_by_strike(delta_k, k, r, t, mid)\n            pd_contrib.loc[k, COLUMNS] = [option_type, mid, contrib]\n\n        return pd_contrib\n```", "```py\nIn [ ]:\n    pd_contrib_near = tabulate_contrib_by_strike(\n        df_near, k0_near, k_lower_near, k_upper_near, r, t1)\n```", "```py\nIn [ ]:\n    pd_contrib_near.head()\n```", "```py\nIn [ ]:\n    pd_contrib_near.tail()\n```", "```py\nIn [ ]:\n    def calculate_volatility(pd_contrib, t, f, k0):\n        \"\"\"\n        Calculate the volatility for a single-term option\n\n        :param pd_contrib: pandas DataFrame \n            containing contributions by strike\n        :param t: time to settlement of the option\n        :param f: forward index level\n        :param k0: immediate strike price below the forward level\n        :return: volatility as Decimal object\n        \"\"\"\n        term_1 = Decimal(2/t)*pd_contrib['contrib'].sum()\n        term_2 = Decimal(1/t)*(f/k0 - 1)**2\n        return term_1 - term_2\n```", "```py\nIn [ ]:\n    volatility_near = calculate_volatility(\n        pd_contrib_near, t1, f1, k0_near)\nIn [ ]:\n    print('volatility_near:', volatility_near)\nOut[ ]:\n    volatility_near: 0.04891704334249740486501736967\n```", "```py\nIn [ ] :\n    df_next = chain.get(dt_next)\n\n    f2 = determine_forward_level(df_next, r, t2)\n    k0_next = find_k0(df_next, f2)\n    (k_lower_next, k_upper_next) = \\\n        find_lower_and_upper_bounds(df_next, k0_next)\n    pd_contrib_next = tabulate_contrib_by_strike(\n        df_next, k0_next, k_lower_next, k_upper_next, r, t2)\n    volatility_next = calculate_volatility(\n        pd_contrib_next, t2, f2, k0_next)\nIn [ ]:\n    print('volatility_next:', volatility_next)\nOut[ ]:\n    volatility_next: 0.04524308316212813982254693873\n```", "```py\nIn [ ]:\n    def calculate_vix_index(t1, volatility_1, t2, \n                            volatility_2, N_t1, N_t2, N_30, N_365):\n        inner_term_1 = t1*Decimal(volatility_1)*(N_t2-N_30)/(N_t2-N_t1)\n        inner_term_2 = t2*Decimal(volatility_2)*(N_30-N_t1)/(N_t2-N_t1)\n        sqrt_terms = math.sqrt((inner_term_1+inner_term_2)*N_365/N_30)\n        return 100 * sqrt_terms\n```", "```py\nIn [ ]:\n    vix = calculate_vix_index(\n        t1, volatility_near, t2, \n        volatility_next, N_t1, N_t2, \n        N_30, N_365)\nIn [ ]:\n    print('At', dt_current, 'the VIX is', vix)\nOut[ ]:\n    At 2018-10-15 20:00:00-05:00 the VIX is 21.431114075693934\n```", "```py\nIn [ ]:\n    def process_file(filepath):\n        \"\"\"\n        Reads the filepath and calculates the VIX index.\n\n        :param filepath: path the options chain file\n        :return: VIX index value\n        \"\"\"\n        headers, calls_and_puts = read_file(filepath)    \n        dt_current = get_dt_current(headers)\n\n        chain = generate_options_chain(calls_and_puts)\n        (dt_near, dt_next) = find_option_terms(chain, dt_current)\n\n        N_t1 = Decimal((dt_near-dt_current).total_seconds() // 60)\n        N_t2 = Decimal((dt_next-dt_current).total_seconds() // 60)\n        t1 = N_t1 / N_365\n        t2 = N_t2 / N_365\n\n        # Process near-term options\n        df_near = chain.get(dt_near)\n        f1 = determine_forward_level(df_near, r, t1)\n        k0_near = find_k0(df_near, f1)\n        (k_lower_near, k_upper_near) = find_lower_and_upper_bounds(\n            df_near, k0_near)\n        pd_contrib_near = tabulate_contrib_by_strike(\n            df_near, k0_near, k_lower_near, k_upper_near, r, t1)\n        volatility_near = calculate_volatility(\n            pd_contrib_near, t1, f1, k0_near)\n\n        # Process next-term options\n        df_next = chain.get(dt_next)\n        f2 = determine_forward_level(df_next, r, t2)\n        k0_next = find_k0(df_next, f2)\n        (k_lower_next, k_upper_next) = find_lower_and_upper_bounds(\n            df_next, k0_next)\n        pd_contrib_next = tabulate_contrib_by_strike(\n            df_next, k0_next, k_lower_next, k_upper_next, r, t2)\n        volatility_next = calculate_volatility(\n            pd_contrib_next, t2, f2, k0_next)\n\n        vix = calculate_vix_index(\n            t1, volatility_near, t2, \n            volatility_next, N_t1, N_t2, \n            N_30, N_365)\n\n        return vix\n```", "```py\nIn [ ]:\n    FILE_DATES = [\n        '2018_10_15',\n        '2018_10_16',\n        '2018_10_17',\n        '2018_10_18',\n        '2018_10_19',\n    ]\n    FILE_PATH_PATTERN = 'files/chapter07/SPX_EOD_%s.csv'\n```", "```py\nIn [ ] :\n    pd_calcs = pd.DataFrame(columns=['VIX'])\n\n    for file_date in FILE_DATES:\n        filepath = FILE_PATH_PATTERN % file_date\n\n        vix = process_file(filepath)    \n        date_obj = parser.parse(file_date.replace('_', '-'))\n\n        pd_calcs.loc[date_obj, 'VIX'] = vix\n```", "```py\nIn [ ]:\n    pd_calcs.head(5)\n```", "```py\nIn [ ]:\n    df_vix = df_vix_data['2018-10-14':'2018-10-21']['5\\. adjusted close']\n```", "```py\nIn [ ]:\n    df_vix.head(5)\nOut [ ]:\n    date\n    2018-10-15    21.30\n    2018-10-16    17.62\n    2018-10-17    17.40\n    2018-10-18    20.06\n    2018-10-19    19.89\n    Name: 5\\. adjusted close, dtype: float64\n```", "```py\nIn [ ]:\n    df_merged = pd.DataFrame({\n         'Calculated': pd_calcs['VIX'],\n         'Actual': df_vix,\n    })\n    df_merged.plot(figsize=(10, 6), grid=True, style=['b', 'ro']);\n\n```"]
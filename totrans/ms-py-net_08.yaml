- en: Network Monitoring with Python – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml), *Network Monitoring
    with Python – Part 1*, we used SNMP to query information from network devices.
    We did this by using an SNMP manager to query the SNMP agent residing on the network
    device. The SNMP information is structured in a hierarchy format with a specific
    object ID as the way to represent the value of the object. Most of the time, the
    value we care about is a number, such as CPU load, memory usage, or interface
    traffic. It's something we can graph against time to give us a sense of how the
    value has changed over time.
  prefs: []
  type: TYPE_NORMAL
- en: We can typically classify the SNMP approach as a `pull` method as we are constantly
    asking the device for a particular answer. This particular method adds burden
    to the device because it needs to spend a CPU cycle on the control plane to find
    answers from the subsystem, package the answer in an SNMP packet, and transport
    the answer back to the poller. If you have ever been to a family reunion where
    you have that one family member who keeps asking you the same questions over and
    over again, that would be analogous to the SNMP manager polling the managed node.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, if we have multiple SNMP pollers querying the same device every 30
    seconds (you would be surprised how often this happens), the management overhead
    would become substantial. In the same family reunion example we have given, instead
    of one family member, imagine there are many other people interrupting you every
    30 seconds to ask you a question. I don't know about you, but I know I would be
    very annoyed even if it was a simple question (or worse if all of them are asking
    the same question).
  prefs: []
  type: TYPE_NORMAL
- en: Another way we can provide more efficient network monitoring is to reverse the
    relationship between the management station from a pull to a push model. In other
    words, the information can be pushed from the device toward the management station
    in an agreed-upon format. This concept is what flow-based monitoring is based
    on. In a flow-based model, the network device streams the traffic information,
    called flow, to the management station. The format can be the Cisco proprietary
    NetFlow (version 5 or version 9), the industry standard IPFIX, or the open source
    sFlow format. In this chapter, we will spend some time looking into NetFlow, IPFIX,
    and sFlow with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Not all monitoring comes in the form of time series data. You can represent
    information such as network topology and Syslog in a time series format if you
    really want to, but, this is not ideal. We can use Python to check network topology
    information and see if the topology has changed over time. We can use tools, such
    as Graphviz, with a Python wrapper, to illustrate the topology. As already seen
    in [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml), *Network Security
    with Python*, Syslog contains security information. In this chapter, we will look
    at using the ELK stack (Elasticsearch, Logstash, Kibana) as an efficient way to
    collect and index network log information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz, which is an open source graph visualization software that can help
    us quickly and efficiently graph our network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow-based monitoring, such as NetFlow, IPFIX, and sFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ntop to visualize the flow information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Elasticsearch to index and analyze our collected data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at how to use Graphviz as a tool to monitor network topology
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphviz is an open source graph visualization software. Imagine if we have
    to describe our network topology to a colleague without the benefit of a picture.
    We might say, our network consists of three layers: core, distribution, and access.
    The core layer comprises two routers for redundancy, and both of the routers are
    full-meshed toward the four distribution routers; the distribution routers are
    also full-meshed toward the access routers. The internal routing protocol is OSPF,
    and externally, we use BGP for peering with our service provider. While this description
    lacks some details, it is probably enough for your colleague to paint a pretty
    good high-level picture of your network.'
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz works similarly to the process by describing the graph in the text
    format that Graphviz can understand, then we can feed the file to the Graphviz
    program to construct the graph for us. Here, the graph is described in a text
    format called DOT ([https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)))
    and Graphviz renders the graph based on the description. Of course, because the
    computer lacks human imagination, the language has to be very precise and detailed.
  prefs: []
  type: TYPE_NORMAL
- en: For Graphviz-specific DOT grammar definitions, take a look at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the **Link Layer Discovery Protocol** (**LLDP**)
    to query the device neighbors and create a network topology graph via Graphviz.
    Upon completing this extensive example, we will see how we can take something
    new, such as Graphviz, and combine it with things we have already learned to solve
    interesting problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by constructing the lab we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use VIRL to construct our lab. As in the previous chapters, we will
    put together a lab with multiple routers, a server, and a client. We will use
    five IOSv network nodes along with two server hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3166a522-47db-4a53-bd7f-0e15ad415b04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are wondering about our choice of IOSv as opposed to NX-OS or IOS-XR
    and the number of devices, here are a few points for you to consider when you
    build your own lab:'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes virtualized by NX-OS and IOS-XR are much more memory-intensive than IOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VIRL virtual manager I am using has 8 GB of RAM, which seems enough to sustain
    nine nodes but could be a bit unstable (nodes changing from reachable to unreachable
    at random)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish to use NX-OS, consider using NX-API or other API calls that would
    return structured data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, we are going to use LLDP as the protocol for link layer neighbor
    discovery because it is vendor-neutral. Note that VIRL provides an option to automatically
    enable CDP, which can save you some time and is similar to LLDP in functionality;
    however, it is a Cisco proprietary technology so we will disable it for our lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7ffca5b5-9a64-4fdd-b214-e5af0d08b772.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the lab is up and running, proceed to installing the necessary software
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphviz can be obtained via `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is complete, note that verification is performed by
    using the `dot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the Python wrapper for Graphviz, so let''s install it now while
    we are at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at how we can use the software.
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most popular open source projects, the documentation of Graphviz ([http://www.graphviz.org/Documentation.php](http://www.graphviz.org/Documentation.php))
    is extensive. The challenge for someone new to the software is often where to
    start. For our purpose, we will focus on the dot graph, which draws directed graphs
    as hierarchies (not to be confused with the DOT language, which is a graph description
    language).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some of the basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes represent our network entities, such as routers, switches, and servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge represents the link between the network entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph, nodes, and edges each have attributes ([https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html))
    that can be tweaked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After describing the network, we can output the network graph ([https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html))
    in either PNG, JPEG, or PDF format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first example is an undirected dot graph consisting of four nodes (`core`,
    `distribution`, `access1`, and `access2`). The edges, represented by the dash `-` sign,
    join the core node to the distribution node, as well as the distribution node
    to both of the access nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph can be output in the `dot -T<format> source -o <output file>` command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant graph can be viewed from the following output folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89a0f1b3-4b29-4dd0-a5f8-58ee33fbd5c5.png)Just like [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml),
    *Network Monitoring with Python – Part 1*, it might be easier to work in the Linux
    desktop window while working with these graphs so you can see the graphs right
    away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can use a directional graph by specifying the graph as a digraph
    as well as using the arrow (`->`) sign to represent the edges. There are several
    attributes we can modify in the case of nodes and edges, such as the node shape,
    edge labels, and so on. The same graph can be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will output the file in PDF this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the directional arrows in the new graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9856fec1-2710-4661-8be9-99f9a65151de.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's take a look at the Python wrapper around Graphviz.
  prefs: []
  type: TYPE_NORMAL
- en: Python with Graphviz examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can reproduce the same topology graph as before using the Python Graphviz
    package which we have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code basically produces what you would normally write in the DOT language
    but in a more Pythonic way. You can view the source of the graph before the graph
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph can be rendered by the `render()` method; by default, the output
    format is PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Python package wrapper closely mimics all the API options of Graphviz. You
    can find documentation about the options on the Graphviz Read the Docs website
    ([http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html)).
    You can also refer to the source code on GitHub for more information ([https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz)).
    We are now ready to use the tool to map out our network.
  prefs: []
  type: TYPE_NORMAL
- en: LLDP neighbor graphing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use the example of mapping out LLDP neighbors to illustrate
    a problem-solving pattern that has helped me over the years:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularize each task into smaller pieces, if possible. In our example, we can
    combine a few steps, but if we break them into smaller pieces, we will be able
    to reuse and improve them more easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an automation tool to interact with the network devices, but keep the more
    complex logic aside at the management station. For example, the router has provided
    an LLDP neighbor output that is a bit messy. In this case, we will stick with
    the working command and the output and use a Python script at the management station
    to parse out the output we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When presented with choices for the same task, pick the one that can be reused.
    In our example, we can use low-level Pexpect, Paramiko, or Ansible playbooks to
    query the routers. In my opinion, Ansible is a more reusable option, so that is
    what I have picked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get started, since LLDP is not enabled on the routers by default, we will
    need to configure them on the devices first. By now, we know we have a number
    of options to choose from; in this case, I chose the Ansible playbook with the
    `ios_config` module for the task. The `hosts` file consists of five routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cisco_config_lldp.yml` playbook consists of one play with variables embedded
    in the playbook to configure LLDP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, to allow LLDP exchange, we can verify that LLDP is indeed
    active on the routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the output, you will see that `G0/0` is configured as the MGMT interface;
    therefore, you will see LLDP peers as if they are on a flat management network.
    What we really care about is the `G0/1` and `G0/2` interfaces connected to other
    peers. This knowledge will come in handy as we prepare to parse the output and
    construct our topology graph.
  prefs: []
  type: TYPE_NORMAL
- en: Information retrieval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use another Ansible playbook, namely `cisco_discover_lldp.yml`,
    to execute the LLDP command on the device and copy the output of each device to
    a `tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `./tmp` directory now consists of all the routers'' output (showing LLDP
    neighbors) in its own file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `r1_lldp_output.txt` content is the `output.stdout_lines` variable from
    our Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Python parser script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now use a Python script to parse the LLDP neighbor output from each device
    and construct a network topology graph from the results. The purpose is to automatically
    check the device to see whether any of the LLDP neighbors have disappeared due
    to link failure or other issues. Let's take a look at the `cisco_graph_lldp.py`
    file and see how that is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the necessary imports of the packages: an empty list that we
    will populate with tuples of node relationships. We also know that `Gi0/0` on
    the devices are connected to the management network; therefore, we are only searching
    for `Gi0/[1234]` as our regular expression pattern in the `show LLDP neighbors`
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `glob.glob()` method to traverse the `./tmp` directory of all
    the files, parse out the device name, and find the neighbors that the device is
    connected to. There are some embedded print statements in the script that we can
    comment out for the final version; if the statements were uncommented, we can
    see the parsed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The fully populated edge list contains tuples that consist of the device and
    its neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now construct the network topology graph using the Graphviz package.
    The most important part is the unpacking of the tuples that represent the edge
    relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to print out the resulting source dot file, it would be an accurate
    representation of our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it is confusing to see the same link twice; for example, the `r2`
    to `r5-tor` link appeared twice in the previous diagram for each of the directions
    of the link. As network engineers, we understand that sometimes a fault in the
    physical link will result in a unidirectional link, which we want to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to graph the diagram as is, the placement of the nodes would be
    a bit funky. The placement of the nodes is auto-rendered. The following diagram
    illustrates the rendering in a default layout as well as the `neato` layout, namely
    a digraph (`My_Network`, `engine=''neato''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dde9bc1b-9f98-4da2-ac4e-4bea01181aa1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `neato` layout represents an attempt to draw undirected graphs with even
    less hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54d47a85-be7a-4294-acf5-056fae7ad784.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, the default layout presented by the tool is just fine, especially
    if your goal is to detect faults as opposed to making it visually appealing. However,
    in this case, let''s see how we can insert raw DOT language knobs into the source
    file. From research, we know that we can use the `rank` command to specify the
    level where some nodes can stay on the same level. However, there is no option
    presented in the Graphviz Python API. Luckily, the dot source file is just a string,
    which we can insert as raw dot comments using the `replace()` method with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is a new source that we can render the final topology graph
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph is now good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0444bef-47f9-44c4-a33c-e9b8aca1caee.png)'
  prefs: []
  type: TYPE_IMG
- en: Final playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to incorporate this new parser script back into our playbook.
    We can now add the additional task of rendering the output with graph generation
    in `cisco_discover_lldp.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This playbook will now include four tasks, covering the end-to-end process of
    executing the `show lldp` command on the Cisco devices, displaying the output
    on the screen, copying the output to a separate file, and then rendering the output
    via a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook can now be scheduled to run regularly via `cron` or other means.
    It will automatically query the devices for LLDP neighbors and construct the graph,
    and the graph will represent the current topology as known by the routers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this by shutting down the `Gi0/1` and `Go0/2` interfaces on `r6-edge`.
    When the LLDP neighbor passes the hold timer, they will disappear from the LLDP
    table on `r6-edge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the playbook, the graph will automatically show that `r6-edge`
    only connects to `r3` and we can start to troubleshoot why that is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/061f359c-1354-4204-a779-51bf15a11c9c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a relatively long example. We used the tools we have learned so far
    in the book—Ansible and Python—to modularize and break tasks into reusable pieces.
    We then used a new tool, namely Graphviz, to help monitor the network for non-time
    series data, such as network topology relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Flow-based monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the chapter introduction, besides polling technology, such as
    SNMP, we can also use a push strategy, which allows the device to push network
    information toward the management station. NetFlow and its closely associated
    cousins, IPFIX and sFlow, are examples of such information pushed from the direction
    of the network device toward the management station. We can make the argument
    that the `push` method is more sustainable since the network device is inherently
    in charge of allocating the necessary resources to push the information. If the
    device CPU is busy, for example, it can choose to skip the flow export process
    in favor of routing packets, which is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: A flow, as defined by IETF ([https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm](https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm)),
    is a sequence of packets moving from an application sending something to the application
    receiving it. If we refer back to the OSI model, a flow is what constitutes a
    single unit of communication between two applications. Each flow comprises a number
    of packets; some flows have more packets (such as a video stream), while some
    have just a few (such as an HTTP request). If you think about flows for a minute,
    you'll notice that routers and switches might care about packets and frames, but
    the application and user usually care more about the network flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flow-based monitoring usually refers to NetFlow, IPFIX, and sFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NetFlow**: NetFlow v5 is a technology where the network device caches flow
    entries and aggregate packets by matching the set of tuples (source interface,
    source IP/port, destination IP/port, and so on). Here, once a flow is completed,
    the network device exports the flow characteristics, including total bytes and
    packet counts in the flow, to the management station.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPFIX**: IPFIX is the proposed standard for structured streaming and is similar
    to NetFlow v9, also known as Flexible NetFlow. Essentially, it is a definable
    flow export, which allows the user to export nearly anything that the network
    device knows about. The flexibility often comes at the expense of simplicity compared
    to NetFlow v5\. The configuration of IPFIX is more complex than the traditional
    NetFlow v5\. Additional complexity makes it less ideal for introductory learning.
    However, once you are familiar with NetFlow v5, you will be able to parse IPFIX
    as long as you match the template definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sFlow**: sFlow actually has no notion of a flow or packet aggregation by
    itself. It performs two types of sampling of packets. It randomly samples one
    out of *n* packets/applications and has a time-based sampling counter. It sends
    the information to the management station, and the station derives the network
    flow information by referring to the type of packet sample received along with
    the counters. As it doesn''t perform any aggregation on the network device, you
    can argue that sFlow is more scalable than NetFlow and IPFIX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to learn about each one of these is probably to dive right into
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow parsing with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use Python to parse the NetFlow datagram being transported on the wire.
    This gives us a way to look at the NetFlow packet in detail as well as troubleshoot
    any NetFlow issues when it is not working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s generate some traffic between the client and server across the
    VIRL network. We can use the built-in HTTP server module from Python to quickly
    launch a simple HTTP server on the VIRL host acting as the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For Python 2, the module is named `SimpleHTTPServer`; for example, `python2
    -m SimpleHTTPServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a short `while` loop in a Python script to continuously send
    `HTTP GET` to the web server on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The client should get a very plain HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also see the requests continuously coming in from the client every
    five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can export NetFlow from any of the devices, but since `r6-edge` is the first
    hop for the client host, we will have this router export NetFlow to the management
    host at port `9995`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use only one device for demonstration; therefore, we manually
    configure it with the necessary commands. In the next section, when we enable
    NetFlow on all the devices, we will use an Ansible playbook to configure all the
    routers at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configurations are necessary for exporting NetFlow on the Cisco
    IOS devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take a look at the Python parser script.
  prefs: []
  type: TYPE_NORMAL
- en: Python socket and struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script, `netFlow_v5_parser.py`, was modified from Brian Rak's blog post
    at [http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html).
    The modification was mainly for Python 3 compatibility as well as parsing additional
    NetFlow version 5 fields. The reason we choose NetFlow v5 instead of NetFlow v9
    is that v9 is more complex and uses templates to map out the fields, making it
    more difficult to learn in an introductory session. However, since NetFlow version
    9 is an extended format of the original NetFlow version 5, all the concepts we
    introduced in this section are applicable to it.
  prefs: []
  type: TYPE_NORMAL
- en: Because NetFlow packets are represented in bytes over the wire, we will use
    the Python struct module included in the standard library to convert bytes into
    native Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find more information about the two modules at [https://docs.python.org/3.5/library/socket.html](https://docs.python.org/3.5/library/socket.html)
    and [https://docs.python.org/3.5/library/struct.html](https://docs.python.org/3.5/library/struct.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by using the socket module to bind and listen for the UDP datagrams.
    With `socket.AF_INET`, we intend on listing for the IPv4 address sockets; with
    `socket.SOCK_DGRAM`, we specify that we''ll see the UDP datagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start a loop and retrieve information off the wire 1,500 bytes at a
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line is where we begin to deconstruct or unpack the packet. The
    first argument of `!HH` specifies the network''s big-endian byte order with the
    exclamation sign (big-endian) as well as the format of the C type (`H = 2` byte
    unsigned short integer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four bytes include the version and the number of flows exported in
    this packet. If you do not remember the NetFlow version 5 header off the top of
    your head (that was a joke, by the way; I only read the header when I want to
    fall asleep quickly), here is a quick glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cb08f1a-95f9-4402-a1b2-ee4753fc54b8.png)NetFlow v5 header (source:  http://www.cisco.com/c/en/us/td/docs/net_mgmt/netflow_collection_engine/3-6/user/guide/format.html#wp1006108)'
  prefs: []
  type: TYPE_IMG
- en: 'The rest of the header can be parsed accordingly, depending on the byte location
    and data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop that follows will fill the `nfdata` dictionary with the flow
    record that unpacks the source address and port, destination address and port,
    packet count, and byte count, and print the information out on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script allows you to visualize the header as well as the
    flow content at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in NetFlow version 5, the size of the record is fixed at 48 bytes;
    therefore, the loop and script are relatively straightforward. However, in the
    case of NetFlow version 9 or IPFIX, after the header, there is a template FlowSet
    ([http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html))
    that specifies the field count, field type, and field length. This allows the
    collector to parse the data without knowing the data format in advance.
  prefs: []
  type: TYPE_NORMAL
- en: By parsing the NetFlow data in a script, we gained a solid understanding of
    the fields, but this is very tedious and hard to scale. As you may have guessed,
    there are other tools that save us the problem of parsing NetFlow records one
    by one. Let's look at one such tool, called **ntop**, in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: ntop traffic monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the PySNMP script in [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml),
    *Network Monitoring with Python – Part 1*, and the NetFlow parser script in this
    chapter, we can use Python scripts to handle low-level tasks on the wire. However,
    there are tools such as Cacti, which is an all-in-one open source package, that
    include data collection (poller), data storage (RRD), and a web frontend for visualization.
    These tools can save you a lot of work by packing the frequently used features
    and software in one package.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of NetFlow, there are a number of open source and commercial NetFlow
    collectors you can choose from. If you do a quick search for top N open source
    NetFlow analyzers, you will see a number of comparison studies for different tools.
    Each one of them has its own strong and weak points; which one to use is really
    a matter of preference, platform, and your appetite for customization. I would
    recommend choosing a tool that would support both v5 and v9, and potentially sFlow
    as well. A secondary consideration would be if the tool is written in a language
    that you can understand; I imagine having Python extensibility would be a nice
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the open source NetFlow tools that I like and have used before are NfSen
    (with NFDUMP as the backend collector) and `ntop` (or `ntopng`). Between the two
    of them, `ntop` is the better-known traffic analyzer; it runs on both Windows
    and Linux platforms and integrates well with Python. Therefore, let's use `ntop`
    as an example in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of our Ubuntu host is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation process will prompt for the necessary interface for listening
    and setting the administrator password. By default, the `ntop` web interface listens
    on port `3000`, while the probe listens on UDP port `5556`. On the network device,
    we need to specify the location of the NetFlow exporter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: By default, IOSv creates a VRF called `Mgmt-intf` and places `Gi0/0` under VRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to specify the direction of traffic exports, such as ingress
    or egress, under the interface configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For your reference, I have included the Ansible playbook, `cisco_config_netflow.yml`,
    to configure the lab device for the NetFlow export.
  prefs: []
  type: TYPE_NORMAL
- en: The `r5-tor` and `r6-edge` have two interfaces more than `r1`, `r2`, and `r3` do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and make sure the changes were applied properly on the
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything is set up, you can check the ntop web interface for local IP
    traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e414a37d-aacc-43ef-a619-d95d026509cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the most often used features of ntop is using it to look at the top
    talker graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5516589-b8af-4feb-b605-e603552db5bd.png)'
  prefs: []
  type: TYPE_IMG
- en: The ntop reporting engine is written in C; it is fast and efficient, but the
    need to have adequate knowledge of C in order to do something as simple as change
    the web frontend does not fit the modern agile development mindset.
  prefs: []
  type: TYPE_NORMAL
- en: After a few false starts with Perl in the mid-2000s, the good folks at ntop
    finally settled on embedding Python as an extensible scripting engine. Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Python extension for ntop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use Python to extend ntop through the ntop web server. The ntop web
    server can execute Python scripts. At a high level, the scripts will perform the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods to access the state of ntop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python CGI module to process forms and URL parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making templates that generate dynamic HTML pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Python script can read from `stdin` and print out `stdout/stderr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stdout` script is the returned HTTP page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several resources that come in handy with the Python integration.
    Under the web interface, you can click on About|Show Configuration to see the
    Python interpreter version as well as the directory for your Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df42b61f-c658-4b7b-b622-3d0a1e38244d.png)Python version'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the various directories where the Python script should reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f76bf24a-6008-4e58-90a9-cd40ddd4b3e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Plugin directories
  prefs: []
  type: TYPE_NORMAL
- en: 'Under About | Online Documentation | Python ntop Engine, there are links for
    the Python API as well as the tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb5f4a60-be4f-443f-b572-5b0cab30ba76.png)Python ntop documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the `ntop` web server directly executes the Python script placed
    under the designated directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place our first script, namely `chapter8_ntop_1.py`, in the directory.
    The Python `CGI` module processes forms and parses URL parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`ntop` implements three Python modules; each one of them has a specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ntop`: This module interacts with the `ntop` engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: This module is used to drill down into a specific host''s information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces**: This module represents the information about the localhost
    interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our script, we will use the `ntop` module to retrieve the `ntop` engine
    information as well as use the `sendString()` method to send the HTML body text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the Python script using `http://<ip>:3000/python/<script name>`.
    Here is the result of our `chapter8_ntop_1.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/869976ca-1508-4a7b-a9ba-4bdd8c66b83e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can look at another example that interacts with the interface module, `chapter8_ntop_2.py`.
    We will use the API to iterate through the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting page will display the ntop interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6140fbbb-7e30-4897-ad3f-fabcd4ce6fa6.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides the community version, ntop also offers a few commercial products that
    you can choose from. With the active open source community, commercial backing,
    and Python extensibility, ntop is a good choice for your NetFlow monitoring needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at NetFlow''s cousin: sFlow.'
  prefs: []
  type: TYPE_NORMAL
- en: sFlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: sFlow, which stands for sampled flow, was originally developed by InMon ([http://www.inmon.com](http://www.inmon.com))
    and later standardized by way of RFC. The current version is v5\. Many in the
    industry believe the primary advantage of sFlow is its scalability. sFlow uses
    random one in `n` packets flow samples along with the polling interval of counter
    samples to derive an estimate of the traffic; this is less CPU-intensive than
    NetFlow for the network devices. sFlow's statistical sampling is integrated with
    the hardware and provides real-time, raw exports.
  prefs: []
  type: TYPE_NORMAL
- en: For scalability and competitive reasons, sFlow is generally preferred over NetFlow
    for newer vendors, such as Arista Networks, Vyatta, and A10 Networks. While Cisco
    supports sFlow on its Nexus line of products, sFlow is generally *not* supported
    on Cisco platforms.
  prefs: []
  type: TYPE_NORMAL
- en: SFlowtool and sFlow-RT with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, at this point, sFlow is something that our VIRL lab devices do
    not support (not even with the NX-OSv virtual switches). You can either use a
    Cisco Nexus 3000 switch or other vendor switches, such as Arista, that support
    sFlow. Another good option for the lab is to use an Arista vEOS virtual instance.
    I happen to have access to a Cisco Nexus 3048 switch running 7.0 (3), which I
    will be using for this section as the sFlow exporter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of Cisco Nexus 3000 for sFlow is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to ingest sFlow is to use `sflowtool`. For installation instructions,
    refer to the document at [http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, you can launch `sflowtool` and look at the datagram
    Nexus 3048 is sending on the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of good usage examples on the `sflowtool` GitHub repository
    ([https://github.com/sflow/sflowtool](https://github.com/sflow/sflowtool)); one
    of them is to use a script to receive the `sflowtool` input and parse the output.
    We can use a Python script for this purpose. In the `chapter8_sflowtool_1.py`
    example, we will use `sys.stdin.readline` to receive the input and use a regular
    expression search to print out only the lines containing the word `agent` when
    we see the sFlow packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The script can be piped to `sflowtool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of other useful output examples, such as `tcpdump`, output
    as NetFlow version 5 records, and a compact line-by-line output. This makes `sflowtool`
    very flexible to suit your monitoring environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'ntop supports sFlow, which means you can directly export your sFlow to the
    ntop collector. If your collector is only NetFlow-aware, you can use the `-c`
    option for the `sflowtool` output in the NetFlow version 5 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can also use InMon's sFlow-RT ([http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php))
    as your sFlow analytics engine. What sets sFlow-RT apart from an operator perspective
    is its vast REST API that can be customized to support your use cases. You can
    also easily retrieve the metrics from the API. You can take a look at its extensive
    API reference at [http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that sFlow-RT requires Java to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, downloading and running sFlow-RT is straightforward ([https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can point the web browser to HTTP port `8008` and verify the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ac593583-04c5-4b0b-8ade-4a925b583726.png)sFlow-RT about'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as sFlow-RT receives any sFlow packets, the agents and other metrics
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a438b4c-45c7-459a-953f-54991e570b6e.png)sFlow-RT agents'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of using Python requests to retrieve information from
    sFlow-RT''s REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Consult the reference documentation for additional REST endpoints available
    for your needs. Next, we will take a look at another tool called **Elasticsearch**,
    which is becoming pretty popular for both Syslog index and general network monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch (ELK stack)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far in this chapter, using just the Python tools as we have
    done would adequately monitor your network with enough scalability for all types
    of networks, large and small alike. However, I would like to introduce one additional
    open source, general-purpose, distributed search and analytics engine called **Elasticsearch**
    ([https://www.elastic.co/](https://www.elastic.co/)). It is often referred to
    as just **Elastic** or **ELK stack** for combining **Elastic** with the frontend
    and input packages **Logstash**, and **Kibana**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at network monitoring in general, it is really about analyzing network
    data and making sense out of it. The ELK stack contains Elasticsearch, Logstash,
    and Kibana as a full stack to ingest information with Logstash, index and analyze
    data with Elasticsearch, and present the graphics output via Kibana. It is really
    three projects in one. It also has the flexibility to substitute Logstash with
    another input, such as **Beats**. Alternatively, you can use other tools, such
    as **Grafana**, instead of Kibana for visualization. The ELK stack by Elastic
    Co*.* also provides many add-on tools, referred to as **X-Pack**, for additional
    security, alerting, monitoring, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably tell by the description, ELK (or even Elasticsearch alone)
    is a deep topic to cover, and there are many books written on the subject. Even
    covering the basic usage would take up more space than we can spare in this book.
    I have considered leaving the subject out of the book simply because of its depth.
    However, ELK has become a very important tool for many of the projects that I
    am working on, including network monitoring. I feel leaving it out would be a
    huge disservice to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, I am going to take a few pages to briefly introduce the tool and
    a few use cases along with information for you to dig deeper if desired. We will
    go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a hosted ELK service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Logstash format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's helper script for Logstash formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a hosted ELK service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire ELK stack can be installed as a standalone server or distributed
    across multiple servers. The installation steps are available at [https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html](https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html).
    In my experience, even with a minimal amount of data, a single VM running the
    ELK stack often stretches the resources. My first attempt at running ELK as a
    single VM lasted no more than a few days with barely two or three network devices
    sending log information toward it. After a few more unsuccessful attempts at running
    my own cluster as a beginner, I eventually settled on running the ELK stack as
    a hosted service, and this is what I would recommend you to start with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a hosted service, there are two providers that you can consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elasticsearch Service** ([https://aws.amazon.com/elasticsearch-service/](https://aws.amazon.com/elasticsearch-service/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic Cloud** ([https://cloud.elastic.co/](https://cloud.elastic.co/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, AWS offers a free tier which is easy to get started with and is tightly
    integrated with the current suite of AWS tools, such as identity services ([https://aws.amazon.com/iam/](https://aws.amazon.com/iam/))
    and lambda functions ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)).
    However, AWS's Elasticsearch Service does not have the latest features as compared
    to Elastic Cloud, nor does it have extended x-pack integration. However, because
    AWS offers a free tier, my recommendation would be that you start with the AWS
    Elasticsearch Service. If you find out later that you need more features than
    AWS can provide, you can always move to Elastic Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the service is straightforward; we just need to choose our region
    and give a name for our first domain. After setting it up, we can use the access
    policy to restrict input via an IP address; make sure this is the IP that AWS
    will see as the source IP (specify your corporate public IP if your host''s IP
    address is translated behind the NAT firewall):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75b38547-2d30-40f8-a951-7af6777231e8.png)'
  prefs: []
  type: TYPE_IMG
- en: The Logstash format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logstash can be installed on the server where you are comfortable sending your
    network log to. The installation steps are available at [https://www.elastic.co/guide/en/logstash/current/installing-logstash.html](https://www.elastic.co/guide/en/logstash/current/installing-logstash.html).
    By default, you can put the Logstash configuration file under `/etc/logstash/conf.d/`.
    The file is in the `input-filter-output` format ([https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html](https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html)).
    In the following example, we specified the input as a `network log file`, with
    a placeholder for filtering the input, and the output as both printing out messages
    to the console as well as having the output exported toward our AWS Elasticsearch
    Service instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at other things we can do with Python and Logstash.
  prefs: []
  type: TYPE_NORMAL
- en: Python helper script for Logstash formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding Logstash configuration will allow us to ingest network logs and
    create the index on Elasticsearch. What would happen if the text format we intend
    on putting into ELK is not a standard log format? This is where Python can help.
    In the next example, we will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Python script to retrieve a list of IPs that the Spamhaus project considers
    to be a drop list ([https://www.spamhaus.org/drop/drop.txt](https://www.spamhaus.org/drop/drop.txt))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Python logging module to format the information in such a way that Logstash
    can ingest it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the Logstash configuration file so any new input could be sent to the
    AWS Elasticsearch Service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `chapter8_logstash_1.py` script contains the code we will use. Besides
    the module imports, we will define the basic logging configuration. This section
    directly configures what the output would be and should be matched closely to
    the Logstash format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define a few more variables and save the list of IP addresses from
    the requests in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The final section of the script is a loop meant for parsing the output and
    writing it to the new log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a sample of the log file entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then modify the Logstash configuration file accordingly to our new log
    format, starting with adding the input file location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add more filter configurations using `grok`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can leave the output section unchanged, as the additional entries will be
    stored in the same index. We can now use the ELK stack to query, store, and view
    the network log as well as the Spamhaus IP information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at additional ways in which we can utilize Python
    to enhance our network monitoring effort. We began by using Python's Graphviz
    package to create network topology graphs with real-time LLDP information reported
    by the network devices. This allows us to effortlessly show the current network
    topology as well as easily notice any link failures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we used Python to parse NetFlow version 5 packets to enhance our understanding
    and troubleshooting of NetFlow. We also looked at how to use ntop and Python to
    extend ntop for NetFlow monitoring. sFlow is an alternative packet sampling technology
    that we looked at where we use `sflowtool` and sFlow-RT to interpret the results.
    We ended the chapter with a general-purpose data analyzing tool, namely Elasticsearch,
    or the ELK stack.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](3f5f47a9-8e88-40e9-a7f5-53113862d966.xhtml), *Building Network
    Web Services with Python*, we will explore how to use the Python web framework
    Flask to build network web services.
  prefs: []
  type: TYPE_NORMAL

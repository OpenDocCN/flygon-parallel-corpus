- en: Building Microservices with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the last chapter, we are moving toward architectures with
    smaller, independently deployable microservices. This would mean that there will
    be a huge number of smaller microservices developed.
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence is that we would need to be able to quickly get off
    the ground and get running with new components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot aims to solve the problem of getting off fast with a new component.
    In this chapter, we will start with understanding the capabilities Spring Boot
    brings to the table. We will answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Spring Boot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the features that Spring Boot provides?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is auto-configuration?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Spring Boot not?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens in the background when you use Spring Boot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you use Spring Initializr to create new Spring Boot projects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you create basic RESTful services with Spring Boot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Spring Boot?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s start with clearing out a few misconceptions about Spring
    Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is not a code generation framework. It does not generate any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot is neither an application server, nor is it a web server. It provides
    good integration with different ranges of applications and web servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot does not implement any specific frameworks or specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These questions still remain:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Spring Boot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why has it become so popular in the last couple of years?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer these questions, let's build a quick example. Let's consider an example
    application that you want to quickly prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Building a quick prototype for a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we want to build a microservice with Spring MVC and use JPA (with
    Hibernate as the implementation) to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the steps in setting up such an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide which versions of Spring MVC, JPA and Hibernate to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a Spring context to wire all the different layers together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up a web layer with Spring MVC (including Spring MVC configuration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure beans for DispatcherServlet, handler, resolvers, view resolvers, and
    so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set up Hibernate in the data layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure beans for SessionFactory, data source, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide and implement how to store your application configuration, which varies
    between different environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide how you would want to do your unit testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide and implement your transaction management strategy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide and implement how to implement security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your logging framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide and implement how you want to monitor your application in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide and implement a metrics management system to provide statistics about
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decide and implement how to deploy your application to a web or application
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At least a few of the steps mentioned have to be completed before we can start
    with building our business logic. And this might take a few weeks at the least.
  prefs: []
  type: TYPE_NORMAL
- en: When we build microservices, we would want to make a quick start. All the preceding
    steps will not make it easy to develop a microservice. And that's the problem
    Spring Boot aims to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following quote is an extract from the Spring Boot website ([http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation](http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation)):'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot makes it easy to create stand-alone, production-grade Spring based
    applications that you can "just run". We take an opinionated view of the Spring
    platform and third-party libraries so you can get started with minimum fuss. Most
    Spring Boot applications need very little Spring configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot enables developers to focus on the business logic behind their microservice.
    It aims to take care of all the nitty-gritty technical details involved in developing
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Primary goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary goals of Spring Boot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable quickly getting off the ground with Spring-based projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be opinionated. Make default assumptions based on common usage. Provide configuration
    options to handle deviations from defaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a wide range of nonfunctional features out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use code generation and avoid using a lot of XML configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonfunctional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few of the nonfunctional features provided by Spring Boot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Default handling of versioning and configuration of a wide range of frameworks,
    servers, and specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default options for application security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default application metrics with possibilities to extend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic application monitoring using health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple options for externalized configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with building our first Spring Boot application in this chapter.
    We will use Maven to manage dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are involved in starting up with a Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure `spring-boot-starter-parent` in your `pom.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `pom.xml` file with the required starter projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `spring-boot-maven-plugin` to be able to run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your first Spring Boot launch class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with step 1: configuring the starter projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Configure spring-boot-starter-parent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple `pom.xml` file with `spring-boot-starter-parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first question is this: why do we need `spring-boot-starter-parent`?'
  prefs: []
  type: TYPE_NORMAL
- en: A `spring-boot-starter-parent` dependency contains the default versions of Java
    to use, the default versions of dependencies that Spring Boot uses, and the default
    configuration of the Maven plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The `spring-boot-starter-parent` dependency is the parent POM providing dependency
    and plugin management for Spring Boot-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the code inside `spring-boot-starter-parent` to get a
    deeper understanding about `spring-boot-starter-parent`.
  prefs: []
  type: TYPE_NORMAL
- en: spring-boot-starter-parent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `spring-boot-starter-parent` dependency inherits from `spring-boot-dependencies`,
    which is defined at the top of the POM. The following code snippet shows an extract
    from `spring-boot-starter-parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `spring-boot-dependencies` provides default dependency management for all
    the dependencies that Spring Boot uses. The following code shows the different
    versions of various dependencies that are configured in `spring-boot-dependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to override a specific version of a dependency, we can do that by
    providing a property with the right name in the `pom.xml` file of our application.
    The following code snippet shows an example of configuring our application to
    use version 1.10.20 of Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some of the other things defined in `spring-boot-starter-parent`:'
  prefs: []
  type: TYPE_NORMAL
- en: The default Java version `<java.version>1.8</java.version>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default configuration for Maven plugins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maven-failsafe-plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maven-surefire-plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git-commit-id-plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility between different versions of frameworks is one of the major problems
    faced by developers. How do I find the latest Spring Session version that is compatible
    with a specific version of Spring? The usual answer would be to read the documentation.
    However, if we use Spring Boot, this is made simple by `spring-boot-starter-parent`.
    If we want to upgrade to a newer Spring version, all that we need to do is to
    find the `spring-boot-starter-parent` dependency for that Spring version. Once
    we upgrade our application to use that specific version of `spring-boot-starter-parent`,
    we would have all the other dependencies upgraded to the versions compatible with
    the new Spring version. One less problem for developers to handle. Always make
    me happy.
  prefs: []
  type: TYPE_NORMAL
- en: Configure pom.xml with the required starter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to build an application in Spring Boot, we would need to start
    looking for starter projects. Let's focus on understanding what a starter project
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding starter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starters are simplified dependency descriptors customized for different purposes.
    For example, `spring-boot-starter-web` is the starter for building web application,
    including RESTful, using Spring MVC. It uses Tomcat as the default embedded container.
    If I want to develop a web application using Spring MVC, all we would need to
    do is include `spring-boot-starter-web` in our dependencies, and we get the following
    automatically pre-configured:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible versions of jackson-databind (for binding) and hibernate-validator
    (for form validation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-tomcat` (starter project for Tomcat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet shows some of the dependencies configured in `spring-boot-starter-web`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding snippet, when we use
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-boot-starter-web`, we get a lot of frameworks auto-configured.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the web application we would like to build, we would also want to do some
    good unit testing and deploy it on Tomcat. The following snippet shows the different
    starter dependencies that we would need. We would need to add this to our `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We add three starter projects:'
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed `spring-boot-starter-web`. It provides us with the frameworks
    needed to build a web application with Spring MVC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `spring-boot-starter-test` dependency provides the following test frameworks
    needed for unit testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JUnit**: Basic unit test framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mockito**: For mocking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamcrest**, **AssertJ**: For readable asserts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Test**: A unit testing framework for spring-context based applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spring-boot-starter-tomcat` dependency is the default for running web applications.
    We include it for clarity. `spring-boot-starter-tomcat` is the starter for using
    Tomcat as the embedded servlet container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have our `pom.xml` file configured with the starter parent and the required
    starter projects. Let's add `spring-boot-maven-plugin` now, which would enable
    us to run Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring spring-boot-maven-plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we build applications using Spring Boot, there are a couple of situations
    that are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: We would want to run the applications in place without building a JAR or a WAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would want to build a JAR and a WAR for later deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `spring-boot-maven-plugin` dependency provides capabilities for both of
    the preceding situations. The following snippet shows how we can configure `spring-boot-maven-plugin`
    in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `spring-boot-maven-plugin` dependency provides several goals for a Spring
    Boot application. The most popular goal is run (this can be executed as `mvn spring-boot:run`
    on the command prompt from the root folder of the project).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Spring Boot launch class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following class explains how to create a simple Spring Boot launch class.
    It uses the static run method from the `SpringApplication` class, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a simple Java `main` method executing the static `run`
    method on the `SpringApplication` class.
  prefs: []
  type: TYPE_NORMAL
- en: SpringApplication class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SpringApplication` class can be used to Bootstrap and launch a Spring application
    from a Java `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps that are typically performed when a Spring Boot
    application is bootstrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of Spring's `ApplicationContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the functionality to accept command-line arguments and expose them as
    Spring properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load all the Spring beans as per the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The @SpringBootApplication annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@SpringBootApplication` annotation is a shortcut for three annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`: Indicates that this a Spring application context configuration
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: Enables auto-configuration, an important feature
    of Spring Boot. We will discuss auto-configuration later in a separate section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`: Enables scanning for Spring beans in the package of this
    class and all its subpackages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our Hello World application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run the Hello World application in multiple ways. Let''s start running
    it with the simplest option--running as a Java application. In your IDE, right-click
    on the application class and run it as Java Application. The following screenshot
    shows some of the log from running our `Hello World` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6a0b877-9c74-4923-a170-15a6b785f429.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the key things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tomcat server is launched on port 8080--`Tomcat started on port(s): 8080 (http)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DispatcherServlet is configured. This means that Spring MVC Framework is ready
    to accept requests--`Mapping servlet: ''dispatcherServlet'' to [/]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four filters--`characterEncodingFilter`, `hiddenHttpMethodFilter`, `httpPutFormContentFilter`
    and `requestContextFilter`--are enabled by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default error page is configured--`Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String,
    java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebJars are autoconfigured. As we discussed in Chapter 3, *Building a Web Application
    with Spring MVC*, WebJars enable dependency management for static dependencies
    such as Bootstrap and query--`Mapped URL path [/webjars/**] onto handler of type
    [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the application layout as of now. We have just
    two files, `pom.xml` and `Application.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e655ff16-7ab2-4315-a699-feb964551b5c.png)'
  prefs: []
  type: TYPE_IMG
- en: With a simple `pom.xml` file and one Java class, we were able to get to launch
    the Spring MVC application, with all the preceding functionality described. The
    most important thing about Spring Boot is to understand what happens in the background.
    Understanding the preceding start up log is the first. Let's look at the Maven
    dependencies to get a deeper picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows some of the dependencies that are configured
    with the basic configuration in the `pom.xml` file that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e30c01a-0fd3-4d2f-8705-277e5c29045a.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Boot does a lot of magic. Once you have the application configured and
    running, I recommend that you play around with it to gain a deeper understanding
    that will be useful when you are debugging problems.
  prefs: []
  type: TYPE_NORMAL
- en: As Spiderman says, <q>with great power, comes great responsibility</q>. This
    is absolutely true in the case of Spring Boot. In the time to come, the best developers
    with Spring Boot would be the ones who understand what happens in the background--dependencies
    and auto-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable us to understand auto-configuration further, let''s expand our application
    class to include a few more lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We get all the beans that are defined in the Spring application context and
    print their names. When `Application.java` is run as a Java program, it prints
    the list of beans, as shown in the following output :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Important things to think about are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Where are these beans defined?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are these beans created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's the magic of Spring auto-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we add a new dependency to a Spring Boot project, Spring Boot auto-configuration
    automatically tries to configure the beans based on the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we add a dependency in `spring-boot-starter-web`, the following
    beans are auto-configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basicErrorController`, `handlerExceptionResolver`: Basic exception handling.
    Shows a default error page when an exception occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beanNameHandlerMapping`: Used to resolve paths to a handler (controller).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`characterEncodingFilter`: Provides default character encoding UTF-8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatcherServlet`: DispatcherServlet is the Front Controller in Spring MVC
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jacksonObjectMapper`: Translates objects to JSON and JSON to objects in REST
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageConverters`: The default message converters to convert from objects
    into XML or JSON and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipartResolver`: Provides support to upload files in web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvcValidator`: Supports validation of HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewResolver`: Resolves a logical view name to a physical view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propertySourcesPlaceholderConfigurer`: Supports the externalization of application
    configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestContextFilter`: Defaults the filter for requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restTemplateBuilder`: Used to make calls to REST services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tomcatEmbeddedServletContainerFactory`: Tomcat is the default embedded servlet
    container for Spring Boot-based web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, let's look at some of the starter projects and the auto-configuration
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: Starter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows some of the important starter projects provided by
    Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Starter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web-services` | This is a starter project to develop
    XML-based web services. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | This is a starter project to build Spring MVC-based
    web applications or RESTful applications. It uses Tomcat as the default embedded
    servlet container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-activemq` | This supports message-based communication
    using JMS on ActiveMQ. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-integration` | This supports the Spring Integration
    Framework that provides implementations for Enterprise Integration Patterns. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | This provides support for various unit testing
    frameworks, such as JUnit, Mockito, and Hamcrest matchers. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | This provides support for using Spring JDBC.
    It configures a Tomcat JDBC connection pool by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-validation` | This provides support for the Java Bean
    Validation API. Its default implementation is hibernate-validator. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-hateoas` | HATEOAS stands for Hypermedia as the Engine
    of Application State. RESTful services that use HATEOAS return links to additional
    resources that are related to the current context in addition to data. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jersey` | JAX-RS is the Java EE standard to develop
    REST APIs. Jersey is the default implementation. This starter project provides
    support to build JAX-RS-based REST APIs. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-websocket` | HTTP is stateless. WebSockets allow you
    to maintain a connection between the server and the browser. This starter project
    provides support for Spring WebSockets. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-aop` | This provides support for Aspect Oriented Programming.
    It also provides support for AspectJ for advanced aspect-oriented programming.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-amqp` | With RabbitMQ as the default, this starter project
    provides message passing with AMQP. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-security` | This starter project enables auto-configuration
    for Spring Security. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | This provides support for Spring Data JPA.
    Its default implementation is Hibernate. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | This is a base starter for Spring Boot applications.
    It provides support for auto-configuration and logging. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-batch` | This provides support to develop batch applications
    using Spring Batch. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cache` | This is the basic support for caching using
    Spring Framework. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-rest` | This is the support to expose REST services
    using Spring Data REST. |'
  prefs: []
  type: TYPE_TB
- en: 'Until now, we have set up a basic web application and understood some of the
    important concepts related to Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starter projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-maven-plugin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-parent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation `@SpringBootApplication`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's shift our focus to understanding what REST is and building a REST
    Service.
  prefs: []
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is basically an architectural
    style for the web. REST specifies a set of constraints. These constraints ensure
    that clients (service consumers and browsers) can interact with servers in flexible
    ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first understand some common terminologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: Service provider. Exposes services which can be consumed by clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: Service consumer. Could be a browser or another system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource**: Any information can be a resource: a person, an image, a video,
    or a product you want to sell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representation**: A specific way a resource can be represented. For example,
    the product resource can be represented using JSON, XML, or HTML. Different clients
    might request different representations of the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the important REST constraints are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server**: There should be a server (service provider) and a client
    (service consumer). This enables loose coupling and independent evolution of the
    server and client as new technologies emerge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Each service should be stateless. Subsequent requests should
    not depend on some data from a previous request being temporarily stored. Messages
    should be self-descriptive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: Each resource has a resource identifier. In the case
    of web services, we use this URI example: `/users/Jack/todos/1`. In this, URI
    Jack is the name of the user. `1` is the ID of the todo we would want to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: The service response should be cacheable. Each response should
    indicate whether it is cacheable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: The consumer of the service should not assume a direct
    connection to the service provider. Since requests can be cached, the client might
    be getting the cached response from a middle layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulation of resources through representations**: A resource can have
    multiple representations. It should be possible to modify the resource through
    a message with any of these representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia as the engine of application state** (**HATEOAS**): The consumer
    of a RESTful application should know about only one fixed service URL. All subsequent
    resources should be discoverable from the links included in the resource representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example response with the HATEOAS link is shown here. This is the response
    to a request to retrieve all todos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding response includes links to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specific todos (`http://localhost:8080/todos/1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search resource (`http://localhost:8080/todos/search`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  prefs: []
  type: TYPE_NORMAL
- en: The initial services we develop will not be adhering to all these constraints.
    As we move on to the next chapters, we will introduce you to the details of these
    constraints and add them to the services to make them more RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: First REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with creating a simple REST service returning a welcome message.
    We will create a simple POJO `WelcomeBean` class with a member field called message
    and one argument constructor, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Simple method returning string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with creating a simple REST Controller method returning a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController`: The `@RestController` annotation provides a combination
    of `@ResponseBody` and `@Controller` annotations. This is typically used to create
    REST Controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping("welcome")`: `@GetMapping` is a shortcut for `@RequestMapping(method
    = RequestMethod.GET)`. This annotation is a readable alternative. The method with
    this annotation would handle a Get request to the `welcome` URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run `Application.java` as a Java application, it would start up the embedded
    Tomcat container. We can launch up the URL in the browser, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3e4c6eb-ad9e-40c3-b8a5-88b1be0bbf7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly write a unit test to test the preceding `controller` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding unit test, we will launch up a Mock MVC instance with `BasicController`.
    A few quick things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(SpringRunner.class)`: SpringRunner is a shortcut to the `SpringJUnit4ClassRunner`
    annotation. This launches up a simple Spring context for unit testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@WebMvcTest(BasicController.class)`: This annotation can be used along with
    SpringRunner to write simple tests for Spring MVC controllers. This will load
    only the beans annotated with Spring-MVC-related annotations. In this example,
    we are launching a Web MVC Test context with the class under test being BasicController.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Autowired private MockMvc mvc`: Autowires the MockMvc bean that can be used
    to make requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))`:
    Performs a request to `/welcome` with the `Accept` header value `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect(status().isOk())`: Expects that the status of the response is 200
    (success).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect(content().string(equalTo("Hello World")))`: Expects that the content
    of the response is equal to `"Hello World"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we do integration testing, we would want to launch the embedded server
    with all the controllers and beans that are configured. This code snippet shows
    how we can create a simple integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    Provides additional functionality on top of the Spring TestContext. Provides support
    to configure the port for fully running the container and TestRestTemplate (to
    execute requests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@LocalServerPort private int port`: `SpringBootTest` would ensure that the
    port on which the container is running is autowired into the port variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private String createURL(String uri)`: The method to append the local host
    URL and port to the URI to create a full URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private TestRestTemplate template = new TestRestTemplate()`: `TestRestTemplate`
    is typically used in integration tests. It provides additional functionality on
    top of RestTemplate, which is especially useful in the integration test context.
    It does not follow redirects so that we can assert response location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template.getForEntity(createURL("/welcome"), String.class)`: Executes a get
    request for the given URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThat(response.getBody(), equalTo("Hello World"))`: Asserts that the
    response body content is `"Hello World"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple REST method returning an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous method, we returned a string. Let''s create a method that returns
    a proper JSON response. Take a look at the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding method returns a simple `WelcomeBean` initialized with a message:
    `"Hello World"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40d5ea71-69db-451d-80f6-92736cb39929.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response for the `http://localhost:8080/welcome-with-object` URL is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The question that needs to be answered is this: how does the `WelcomeBean`
    object that we returned get converted into JSON?'
  prefs: []
  type: TYPE_NORMAL
- en: Again, it's the magic of Spring Boot auto-configuration. If Jackson is on the
    classpath of an application, instances of the default object to JSON (and vice
    versa) converters are auto-configured by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly write a unit test checking for the JSON response. Let''s add
    the test to `BasicControllerTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test is very similar to the earlier unit test except that we are using
    `containsString` to check whether the content contains a substring `"Hello World"`.
    We will learn how to write proper JSON tests a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s shift our focus to writing an integration test. Let''s add a method
    to `BasicControllerIT`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method is similar to the earlier integration test except that we are asserting
    for a sub-string using the `String` method.
  prefs: []
  type: TYPE_NORMAL
- en: Get method with path variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s shift our attention to path variables. Path variables are used to bind
    values from the URI to a variable on the controller method. In the following example,
    we want to parameterize the name so that we can customize the welcome message
    with a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@GetMapping("/welcome-with-parameter/name/{name}")`: `{name}` indicates that
    this value will be the variable. We can have multiple variable templates in a
    URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`welcomeWithParameter(@PathVariable String name)`: `@PathVariable` ensures
    that the variable value from the URI is bound to the variable name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.format(helloWorldTemplate, name)`: A simple string format to replace
    `%s` in the template with the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ec666d-e2ec-4a15-9a46-5babdcddbf66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response for the `http://localhost:8080/welcome-with-parameter/name/Buddy`
    URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the name in the URI is used to form the message in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly write a unit test for the preceding method. We would want to
    pass a name as part of the URI and check whether the response contains the name.
    The following code shows how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")`: This matches
    against the variable template in the URI. We pass in the name `Buddy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.andExpect(content().string(containsString("Hello World, Buddy”)))`: We expect
    the response to contain the message with the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integration test for the preceding method is very simple. Take a look at
    the following test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createURL("/welcome-with-parameter/name/Buddy")`: This matches against the
    variable template in the URI. We are passing in the name, Buddy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThat(response.getBody(), containsString("Hello World, Buddy”))`: We
    expect the response to contain the message with the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at the basics of creating a simple REST service with
    Spring Boot. We also ensured that we have good unit tests and integration tests.
    While these are really basic, they lay the foundation for more complex REST services
    we will build in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The unit tests and integration tests we implemented can have better asserts
    using a JSON comparison instead of a simple substring comparison. We will focus
    on it in the tests we write for the REST services we will create in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a todo resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will focus on creating REST services for a basic todo management system.
    We will create services for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a list of todos for a given user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving details for a specific todo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a todo for a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request methods, operations, and URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best practices of REST services is to use the appropriate HTTP request
    method based on the action we perform. In the services we exposed until now, we
    used the `GET` method, as we focused on services that read data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the appropriate HTTP Request method based on the
    operation that we perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Request Method** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Read--Retrieve details for a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Create--Create a new item or resource |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Update/replace |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Update/modify a part of the resource |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s quickly map the services that we want to create to the appropriate request
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieving a list of todos for a given user**: This is `READ`. We will use
    `GET`. We will use a URI: `/users/{name}/todos`. One more good practice is to
    use plurals for static things in the URI: users, todo, and so on. This results
    in more readable URIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieving details for a specific todo**: Again, we will use `GET`. We will
    use a URI `/users/{name}/todos/{id}`. You can see that this is consistent with
    the earlier URI that we decided for the list of todos.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating a todo for a user**: For the create operation, the suggested HTTP
    Request method is `POST`. To create a new todo, we will post to `URI /users/{name}/todos`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beans and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to retrieve and store details of a todo, we need a Todo bean and
    a service to retrieve and store the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Todo Bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have a created a simple Todo bean with the ID, the name of user, the description
    of the todo, the todo target date, and an indicator for the completion status.
    We added a constructor and getters for all fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `TodoService` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Quick things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, this service does not talk to the database. It maintains
    an in-memory array list of todos. This list is initialized using a static initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are exposing a couple of simple retrieve methods and a method to add a to-do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the service and bean ready, we can create our first service
    to retrieve a list of to-do's for a user.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a Todo list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new `RestController` annotation called `TodoController`. The
    code for the retrieve todos method is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are autowiring the todo service using the `@Autowired` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `@GetMapping` annotation to map the Get request for the `"/users/{name}/todos"`
    URI to the `retrieveTodos` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eee8995-485d-414b-bd47-f0aec4e91d9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response for the `http://localhost:8080/users/Jack/todos` URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to unit test the `TodoController` class is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are writing a unit test. So, we want to test only the logic present in the
    `TodoController` class. So, we initialize a Mock MVC framework with only the `TodoController`
    class using `@WebMvcTest(TodoController.class)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MockBean private TodoService service`: We are mocking out the TodoService
    using the `@MockBean` annotation. In test classes that are run with SpringRunner,
    the beans defined with `@MockBean` will be replaced by a mock, created using the
    Mockito framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when(service.retrieveTodos(anyString())).thenReturn(mockList)`: We are mocking
    the retrieveTodos service method to return the mock list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MvcResult result = ..`: We are accepting the result of the request into an
    MvcResult variable to enable us to perform assertions on the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`: JSONAssert is a very useful framework to perform asserts on JSON. It
    compares the response text with the expected value. JSONAssert is intelligent
    enough to ignore values that are not specified. Another advantage is a clear failure
    message in case of assertion failures. The last parameter, false, indicates using
    non-strict mode. If it is changed to true, then the expected should exactly match
    the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to perform integration testing on the `TodoController` class is shown
    in the following code snippet. It launches up the entire Spring context with all
    the controllers and beans defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This test is very similar to the integration test for `BasicController`, except
    that we are using `JSONAssert` to assert the response.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving details for a specific Todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add the method to retrieve details for a specific Todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The URI mapped is `/users/{name}/todos/{id}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have two path variables defined for `name` and `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s send a test request and see what response we will get, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aa9de2d-c774-4c1c-879c-1b421738da2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response for the `http://localhost:8080/users/Jack/todos/1` URL is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to unit test `retrieveTodo` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`when(service.retrieveTodo(anyInt())).thenReturn(mockTodo)`: We are mocking
    the retrieveTodo service method to return the mock todo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MvcResult result = ..`: We are accepting the result of the request into an
    MvcResult variable to enable us to perform assertions on the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`: Asserts whether the result is as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to perform integration testing on `retrieveTodos` in `TodoController`
    is shown in the following code snippet. This would be added to the `TodoControllerIT`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add the method to create a new Todo. The HTTP method to be used
    for creation is `Post`. We will post to a `"/users/{name}/todos"` URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@PostMapping("/users/{name}/todos")`: `@PostMapping` annotations map the `add()`
    method to the HTTP Request with a `POST` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseEntity<?> add(@PathVariable String name, @RequestBody Todo todo)`:
    An HTTP post request should ideally return the URI to the created resources. We
    use `ResourceEntity` to do this. `@RequestBody` binds the body of the request
    directly to the bean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseEntity.noContent().build()`: Used to return that the creation of the
    resource failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri()`:
    Forms the URI for the created resource that can be returned in the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseEntity.created(location).build()`: Returns a status of `201(CREATED)`
    with a link to the resource created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are on Mac, you might want to try the Paw application as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e7d4629-6213-4a71-a769-9579f3e87b9f.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use Postman app to interact with the REST Services. You can install
    it from the website, [https://www.getpostman.com/](https://www.getpostman.com/).
    It is available on Windows and Mac. A Google Chrome plugin is also available.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the POST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Todo using `POST`, we would need to include the JSON for the
    Todo in the body of the request. The following screenshot shows how we can use
    the Postman app to create the request and the response after executing the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd150c03-a64e-40d0-8ff7-603c781e3b82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are sending a POST request. So, we choose the POST from the top-left dropdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To send the Todo JSON as part of the body of the request, we select the raw
    option in the Body tab (highlighted with a blue dot). We choose the content type
    as JSON (`application/json`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the request is successfully executed, you can see the status of the request
    in the bar in the middle of the screen: Status: 201 Created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location is `http://localhost:8080/users/Jack/todos/5`. This is the URI
    of the newly created todo that is received in the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complete details of the request to `http://localhost:8080/users/Jack/todos`
    are shown in the block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to unit test the created Todo is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String todo = "{"user":"Jack","desc":"Learn Spring MVC","done":false}"`: The
    Todo content to post to the create todo service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo)`:
    Mocks the service to return a dummy todo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))`:
    Creates a POST to a given URI with the given content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect(status().isCreated())`: Expects that the status is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect(header().string("location",containsString("/users/Jack/todos/" +
    CREATED_TODO_ID)))`: Expects that the header contains `location` with the URI
    of created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to perform integration testing on the created todo in `TodoController`
    is shown as follows. This would be added to the `TodoControllerIT` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`URI location = template.postForLocation(createUrl("/users/Jill/todos"), todo)`:
    `postForLocation` is a utility method especially useful in tests to create new
    resources. We are posting the todo to the given URI and getting the location from
    the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThat(location.getPath(), containsString("/users/Jill/todos/4"))`: Asserts
    that the location contains the path to the newly created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you want to auto-generate Spring Boot projects? Do you want to quickly get
    started with developing your application? Spring Initializr is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Initializr is hosted at [http://start.spring.io](http://start.spring.io).
    The following screenshot shows how the website looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '***![](img/aebe0da6-f812-409d-94b2-c11f40ad574a.png)***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Initializr provides a lot of flexibility in creating projects. You have
    options to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose your build tool: Maven or Gradle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the Spring Boot version you want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a Group ID and Artifact ID for your component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the starters (dependencies) that you would want for your project. You
    can click on the link at the bottom of the screen, Switch to the full version,
    to see all the starter projects you can choose from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose how to package your component: JAR or WAR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the Java version you want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the JVM language you want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows some of the options Spring Initializr provides
    when you expand (click on the link) to the full version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df21a0ab-8ee6-4b69-ad86-db4f5206184b.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your first Spring Initializr project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the full version and enter the values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/064b95c0-d6ec-4b51-8315-3bddedeb0431.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build tool: `Maven`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Boot version: Choose the latest available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Group: `com.mastering.spring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artifact: `first-spring-initializr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selected dependencies: Choose `Web, JPA, Actuator and Dev Tools`. Type in each
    one of these in the textbox and press *Enter* to choose them. We will learn more
    about Actuator and Dev Tools in the next section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java version: `1.8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go ahead and click on the Generate Project button. This will create a `.zip`
    file and you can download it to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the structure of the project created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef3d2f76-c0ba-4fbe-9855-5266a920c53b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now import this project into your IDE. In Eclipse, you can perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to File | Import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the existing Maven projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse and select the folder that is the root of the Maven project (the one
    containing the `pom.xml` file ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceed with the defaults and click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will import the project into Eclipse. The following screenshot shows the
    structure of the project in Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb2f4b68-7e2b-4233-a748-192b28282c91.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at some of the important files from the generated project.
  prefs: []
  type: TYPE_NORMAL
- en: pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following snippet shows the dependencies that are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A few other important observations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The packaging for this component is `.jar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.boot:spring-boot-starter-parent` is declared as the parent
    POM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<java.version>1.8</java.version>`: The Java version is 1.8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot Maven Plugin (`org.springframework.boot:spring-boot-maven-plugin`)
    is configured as a plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FirstSpringInitializrApplication.java class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FirstSpringInitializrApplication.java` is the launcher for Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: FirstSpringInitializrApplicationTests class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FirstSpringInitializrApplicationTests` contains the basic context that can
    be used to start writing the tests as we start developing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A quick peek into auto-configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auto-configuration is one of the most important features of Spring Boot. In
    this section, we will take a quick peek behind the scenes to understand how Spring
    Boot auto-configuration works.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Spring Boot auto-configuration magic comes from `spring-boot-autoconfigure-{version}.jar`.
    When we start any Spring Boot applications, a number of beans get auto-configured.
    How does this happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an extract from `spring.factories` from `spring-boot-autoconfigure-{version}.jar`.
    We have filtered out some of the configuration in the interest of space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c3c6692-d315-4041-b6d5-a57aec4e75ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding list of auto-configuration classes is run whenever a Spring Boot
    application is launched. Let''s take a quick look at one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a small snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class
    })` : This auto-configuration is enabled if any of the mentioned classes are in
    the classpath. When we add a web starter project, we bring in dependencies with
    all these classes. Hence, this auto-configuration will be enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`: This auto-configuration
    is enabled only if the application does not explicitly declare a bean of the `WebMvcConfigurationSupport.class`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)`: This specifies the
    precedence of this specific auto-configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at another small snippet showing one of the methods from the same
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'View resolvers are one of the beans configured by `WebMvcAutoConfiguration`
    class. The preceding snippet ensures that if a view resolver is not provided by
    the application, then Spring Boot auto-configures a default view resolver. Here
    are a few important points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ConditionalOnBean(ViewResolver.class)`: Create this bean if `ViewResolver.class`
    is on the classpath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)`:
    Create this bean if there are no explicitly declared beans of the name `viewResolver`
    and of type `ContentNegotiatingViewResolver.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the method is configured in the view resolver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, all the auto-configuration logic is executed at the start of a
    Spring Boot application. If a specific class (from a specific dependency or starter
    project) is available on the classpath, then the auto configuration classes are
    executed. These auto-configuration classes look at what beans are already configured.
    Based on the existing beans, they enable the creation of the default beans.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot makes the development of Spring-based applications easy. It enables
    us to create production-ready applications from day one of a project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of Spring Boot and REST services. We
    discussed the different features of Spring Boot and created a few REST services
    with great tests. We understood what happens in the background with an in-depth
    look at auto-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention toward adding more features
    to the REST services.
  prefs: []
  type: TYPE_NORMAL

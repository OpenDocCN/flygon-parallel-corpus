- en: Extending Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built a basic component offering a few services in Chapter 5, *Building Microservices
    with Spring Boot*. In this chapter, we will focus on adding more features to make
    ;our microservice production ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss how to add these features to our microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalisation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also discuss how to document our microservice using Swagger. We will
    look at the basics of securing the microservice with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is one of the important parts of developing web services.
    When something goes wrong, we would want to return a good description of what
    went wrong to the service consumer. You would not want the service to crash without
    returning anything useful to the service consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides good default exception handling. We will start with looking
    at the default exception handling features provided by Spring Boot before moving
    on to customizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot default exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the default exception handling provided by Spring Boot, let's
    start with firing a request to a nonexistent URL.
  prefs: []
  type: TYPE_NORMAL
- en: Nonexistent resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's send a `GET` request to `http://localhost:8080/non-existing-resource`
    using a header (Content-Type:application/json).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when we execute the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51cba3ab-d570-4eb9-a226-3c27456647af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response is as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The response header has an HTTP status of `404 - Resource Not Found`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot returns a valid JSON ;message as a ;response with the ;message stating
    that the resource is not found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource throwing an exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a resource that throws an exception, and send a `GET` request to
    it in order to understand how the application reacts to runtime exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a dummy service that throws an exception. The following code
    snippet shows a simple service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a `GET` service with the URI `/users/dummy-service`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service throws ;`RuntimeException`. We chose `RuntimeException` to be able
    to create the exception easily. We can easily replace it with a custom exception
    ;if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s fire a `GET` request to the preceding service at `http://localhost:8080/users/dummy-service`
    using Postman. The response is as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The response header has an HTTP status of `500`; `Internal server error`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot also returns the message with which the exception is thrown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in the preceding two examples, Spring Boot provides good default
    exception handling. In the next section, we will focus on understanding how the
    application reacts to custom exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a custom exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a custom exception and throw it from a service. Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It's a very simple piece of code that defines ;`TodoNotFoundException` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s enhance our `TodoController` ;class to throw `TodoNotFoundException`
    when a `todo` with a given ID is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If `todoService` returns a null `todo`, we throw ;`TodoNotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the service with a `GET` request to a nonexistent ;`todo` (`http://localhost:8080/users/Jack/todos/222`),
    we get the response shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, a clear exception response is sent back to the service consumer.
    However, there is one thing that can be improved further--the response status.
    When a resource is not found, it is recommended that you return a `404 - Resource
    Not Found` status. We will look at how to customize the response ;status ;in the
    next example.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the exception message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how to customize the preceding exception and return the proper
    response status with a customized message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a bean to define the structure of our custom exception message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have created a simple exception response bean with an auto-populated timestamp
    with a few additional properties namely messages and details.
  prefs: []
  type: TYPE_NORMAL
- en: 'When ;`TodoNotFoundException` is thrown, we would want to return a response
    using the `ExceptionResponse` bean. The following code shows how we can create
    a global exception handling for `TodoNotFoundException.class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    We are extending ;`ResponseEntityExceptionHandler`, which is the base class provided
    by Spring MVC for centralised exception handling `ControllerAdvice` classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ExceptionHandler(TodoNotFoundException.class)`: This defines that the method
    to follow will handle the specific exception `TodoNotFoundException.class`. Any
    other exceptions for which custom exception handling is not defined will follow
    the default exception handling provided by Spring Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: This creates a custom exception response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: This is the definition to return a `404 Resource Not Found`
    response with the custom exception defined earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we execute the service with a `GET` request to a nonexistent ;`todo` (`http://localhost:8080/users/Jack/todos/222`),
    we get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you want to create a generic exception message for all exceptions, we can
    add a method to `RestResponseEntityExceptionHandler` with the ;`@ExceptionHandler(Exception.class)`
    ;annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Any exception for which a custom exception handler is not defined ;will be handled
    by the preceding method.
  prefs: []
  type: TYPE_NORMAL
- en: Response status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the important things to focus on with REST services is the response
    status of an error response. The following table shows the scenarios and the error
    response status to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Situation** | **Response Status** |'
  prefs: []
  type: TYPE_TB
- en: '| The request body does not meet the API specification. It does not contain
    enough details or contains validation errors. | ;400 BAD REQUEST |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication or authorization failure. | 401 UNAUTHORIZED |'
  prefs: []
  type: TYPE_TB
- en: '| The user cannot perform the operation due to various factor, such as exceeding
    limits. | 403 FORBIDDEN |'
  prefs: []
  type: TYPE_TB
- en: '| The resource does not exist. | 404 NOT FOUND |'
  prefs: []
  type: TYPE_TB
- en: '| Unsupported operation, for example, trying POST on a resource where only
    `GET` is allowed. ; | 405 METHOD NOT ALLOWED |'
  prefs: []
  type: TYPE_TB
- en: '| Error on a server. Ideally, this should not happen. The consumer ;would not
    be able to fix this. ; | 500 INTERNAL SERVER ERROR |'
  prefs: []
  type: TYPE_TB
- en: In this section, we looked at the default exception handling provided by Spring
    Boot and how we can customize it further to suit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HATEOAS** (**Hypermedia as the Engine of Application State**) is one of the
    constraints of the REST application architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a situation where a service consumer is consuming numerous services
    from a service provider. The easiest way to develop this kind of system is to
    have the service consumer store the individual resource URIs of every resource
    they need from the service provider. However, this would create tight coupling
    between the service provider and the service consumer. Whenever any of the resource
    URIs change on the service provider, the service consumer needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a ;typical web application. Let's say I navigate to my bank account
    details page. Almost all banking websites would show links to all the transactions
    that are possible on my bank account on the screen so that I can easily navigate
    using the link.
  prefs: []
  type: TYPE_NORMAL
- en: What if we can bring a ;similar concept to RESTful services so that a service
    returns not only the data about the requested resource, but also provides details
    of other related resources?
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS brings this concept of displaying related links for a given resource
    to RESTful services. When we return the details of a specific resource, we also
    return links to operations that can be performed on the resource, as well as links
    to related resources. If a service consumer can use the links from the response
    to perform transactions, then it would not need to hardcode all links.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extract of constraints related to HATEOAS presented by Roy Fielding ([http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>A REST API must not define fixed resource names or hierarchies (an obvious
    coupling of client and server). Servers must have the freedom to control their
    own namespace. Instead, allow servers to instruct clients on how to construct
    appropriate URIs, such as is done in HTML forms and URI templates, by defining
    those instructions within media types and link relations.</q> A REST API should
    be entered with no prior knowledge beyond the initial URI (bookmark) and set of
    standardized media types that are appropriate for the intended audience (i.e.,
    expected to be understood by any client that might use the API). From that point
    on, all application state transitions must be driven by client selection of server-provided
    choices that are present in the received representations or implied by the user's
    manipulation of those representations. The transitions may be determined (or limited
    by) the client's knowledge of media types and resource communication mechanisms,
    both of which may be improved on-the-fly (e.g., code-on-demand).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example response with HATEOAS link is shown here. This is the response to
    the `/todos` request in order to retrieve all todos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding response includes links to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specific `todos` (`http://localhost:8080/todos/1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search resource (`http://localhost:8080/todos/search`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Sending HATEOAS links in response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand what HATEOAS is, let's look at how we can send links
    related to a resource in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot starter HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot has a specific starter for HATEOAS called `spring-boot-starter-hateoas`.
    We need to add it to the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the dependency block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the important dependencies of `spring-boot-starter-hateoas` is `spring-hateoas`,
    which provides the HATEOAS features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s enhance the `retrieveTodo` resource (`/users/{name}/todos/{id}`) to
    return a link to retrieve all `todos` (`/users/{name}/todos`) in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`:
    We want to get a link to the `retrieveTodos` method on the current class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linkTo.withRel("parent")`: Relationship with the current resource is parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows the response when a `GET` request is sent to ;`http://localhost:8080/users/Jack/todos/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `_links` section will contain all the links. Currently, we have one link
    with the relation parent and `href` ; as `http://localhost:8080/users/Jack/todos`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have problems executing the preceding request, ;try executing using an
    Accept header--`application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS is not something that is commonly used in most of the resources today.
    However, it has the potential to be really useful in reducing the coupling between
    the ;service provider and the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good service always validates data before processing it. In this section,
    we will look at the ;Bean Validation API and use its reference implementation
    to implement validation in our services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bean Validation API provides a number of annotations that can be used to
    validate beans. The ;*JSR 349* ;specification defines Bean Validation API 1.1\.
    Hibernate-validator is the reference implementation. ;Both are already defined
    as dependencies in the `spring-boot-web-starter` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hibernate-validator-5.2.4.Final.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validation-api-1.1.0.Final.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a simple validation for the createTodo service method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating validations involves two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling validation on the controller method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding validations on the bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling validation on ;the controller method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s very simple to enable validation on the controller method. The following
    snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `@Valid(package javax.validation)` annotation is used to mark a parameter
    for validation. Any validation that is defined in the `Todo` bean is executed
    before the `add` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining validations on the bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a few validations on the `Todo` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NotNull`: Validates that the user field is not empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`: Checks whether
    the `desc` field has at least nine characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of other annotations that can be used to validate beans.
    The following are some of the Bean Validation annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@AssertFalse`, `@AssertTrue`: For Boolean elements. Checks the annotated element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AssertFalse`: Checks for false. `@Assert` checks for true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Future`: The annotated element must be a date in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Past`: The annotated element must be a date in the past.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Max`: The annotated element must be a number whose value must be lower or
    equal to the specified maximum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Min`: The annotated element must be a number whose value must be higher or
    equal to the specified minimum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotNull`: The annotated element cannot be null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Pattern`: The annotated `{@code CharSequence}` ;element must match the specified
    regular expression. The regular expression follows the Java regular expression
    conventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Size`: The annotated element size must be within the specified boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows how we can unit test the validations we added in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"desc":"Learn"`: We are using a desc value of length `5`. This would cause
    a validation failure for the `@Size(min = 9, message = "Enter atleast 10 Characters.")`
    check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.andExpect(status().is4xxClientError())`: Checks for validation error status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before a service provider can consume a service, they need a service contract.
    A service contract defines all the ;details about a service:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I call a service? What is the URI of the service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What should be the request format?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of response should I expect?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple options to define a service contract for RESTful services.
    The most popular one in the last couple of years is ;**Swagger**. ;Swagger is
    gaining a lot of ground, with support from major vendors in the last couple of
    years. In this section, we will generate Swagger documentation for our services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following quote from the Swagger website ([http://swagger.io](http://swagger.io))
    defines the purpose of the Swagger specification:'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger specification creates the RESTful contract for your API, detailing all
    of its resources and operations in a human and machine readable format for easy
    development, discovery, and integration.
  prefs: []
  type: TYPE_NORMAL
- en: Generating ;a Swagger specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the interesting developments in the last few years of RESTful services
    development is the evolution of tools to generate service documentation (specification)
    from the code. This ensures that the code and documentation are always in sync.
  prefs: []
  type: TYPE_NORMAL
- en: '**Springfox Swagger** can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called **Swagger
    UI**, which, when integrated into the application, provides human-readable documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can add both these tools ;to the ;`pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the configuration class to enable and generate Swagger
    documentation. The following snippet shows how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`: Defines a Spring configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableSwagger2`: The annotation to enable Swagger support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Docket` : A simple builder class to configure the generation of Swagger documentation
    using the Swagger Spring MVC framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new Docket(DocumentationType.SWAGGER_2)` : Configures Swagger 2 as the Swagger
    version to be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: Includes
    all APIs and paths in the documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we bring the server up, we can launch the API Docs URL (`http://localhost:8080/v2/api-docs`).
    The following screenshot shows some of the generated documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfce5d48-ef55-4393-9a25-e6c695125f13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at some of the generated documentation. Listed here is the documentation
    to retrieve the ;`todos` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The service definition clearly defines the request ;and response ;of the service.
    Also defined are the different response statuses that the service can return in
    different situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the definition of the `Todo` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It defines all the elements in the `Todo` bean, along with their formats.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger UI (`http://localhost:8080/swagger-ui.html`) can also be used to look
    at the documentation. Swagger UI is enabled by the dependency (`io.springfox:springfox-swagger-ui`)
    that was added in our `pom.xml`, in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) is also
    available online. We can visualise any Swagger documentation (swagger JSON) using
    Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the list of controller-exposing services. When
    we click on any controller, it expands to show the list of request methods and
    URIs each controller supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c9a0fb3-d07a-4b93-8a02-50c3d01812f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the details for the POST service to create a
    `todo` for the user in Swagger UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29b7ef2-eb45-4e26-9310-cfb09e9f0950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters show all the important parameters including the request body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Parameter Type body (for the ;`todo` parameter) shows the expected structure
    for the ;body of the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Response Messages sections show ;different HTTP status codes returned by
    the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swagger UI provides an excellent way to expose service definitions for your
    API without a lot of additional effort.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Swagger documentation using annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swagger UI also provides annotations to further customize your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed here is some of the ;documentation to retrieve the `todos` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the documentation generated is very raw. There are a number
    of things we can improve in the documentation to describe the services better.
    Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a better summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add application/JSON to produces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger provides annotations we can add to our RESTful services in order to
    customize the documentation. ;Let''s add a few annotations to the controller in
    order to improve the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ApiOperation(value = "Retrieve all todos for a user by passing in his name")`:
    Produced in the documentation as a summary of the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notes = "A list of matching todos is returned. Current pagination is not supported."`:
    Produced in the documentation as a description of the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`produces = "application/json‚Äù`: Customizes the `produces` section of the service
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an extract of the documentation after the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Swagger provides a lot of other annotations to customize the documentation.
    Listed here are some of the important annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Api`: Marks a class as a Swagger resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiModel`: Provides additional information about Swagger models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiModelProperty`: Adds and manipulates the data of a model property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiOperation`: Describes an operation or an HTTP method against a specific
    path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiParam`: Adds additional metadata for operation parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiResponse`: Describes an example response of an operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ApiResponses`: A wrapper to allow a list of multiple `ApiResponse` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Authorization`: Declares an authorization scheme to be used on a resource
    or an operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AuthorizationScope`: Describes an OAuth 2 authorization scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseHeader`: Represents a header that can be provided as part of the
    response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger provides a few Swagger definition annotations that can be ;used to
    customize high-level information about a group of services--contacts, licensing,
    and other general information. Listed here are some of the important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@SwaggerDefinition`: Definition-level properties to be added to the generated
    Swagger definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Info`: General metadata for a Swagger definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Contact`: ;Properties to describe the person to be contacted for a Swagger
    definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@License`: Properties to describe the license for a Swagger definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing REST services with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the services we have created up until ;now are unsecured. A consumer does
    not need to provide any credentials to access these services. However, all services
    in the real world are usually secured.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss two ways of authenticating REST services:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement these two types of authentication with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides a starter for Spring Security using ;`spring-boot-starter-security`.
    We will start with adding Spring Security starter to our `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Security starter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following dependency to your file `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Spring-boot-starter-security` dependency ;brings in three important Spring
    Security dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-security-config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-security-core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-security-web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Spring-boot-starter-security` dependency ;also auto-configures basic authentication
    for all services by default.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to access any of the services now, we would get `"Access Denied"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response when we send a request to `http://localhost:8080/users/Jack/todos`
    is shown as an example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The response status is `401 - Unauthorized`.
  prefs: []
  type: TYPE_NORMAL
- en: When a resource is secured with basic authentication, we would need to send
    a user ID and password to authenticate our request. Since we did not configure
    a user ID and password, Spring Boot auto-configures a default user ID and password.
    The default user ID is `user`. The default password is usually printed in the
    log.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Underlined in the preceding code snippet is the default security password printed
    in the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Postman to fire a request with basic authentication. The following
    screenshot shows how basic authentication details can be sent along with a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/579ca5d7-bcc6-4814-8079-65b2b715a312.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, authentication succeeds and we get a proper response back.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the user ID and password of our choice in `application.properties`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Spring Security also provides options to authenticate with LDAP or JDBC or any
    other data source with user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integration test we wrote for the service earlier will start failing because
    of invalid credentials. We will now update the integration test to supply basic
    authentication credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createHeaders("user-name", "user-password")`: This method creates `Base64\.
    getEncoder().encode` basic authentication headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    ;HttpMethod.GET,new HttpEntity<String>(null, headers), String.class)`: The key
    change is the use of `HttpEntity` to supply the headers that we created earlier
    to the REST template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would not want to use security for our unit tests. The following code snippet
    shows how we can disable security for the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The key part is the `secure = false` parameter on the `WebMvcTest` annotation.
    This will disable Spring Security for the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is a protocol that provides flows in order to exchange authorization and
    authentication information between a range of web-enabled applications and services.
    It enables third-party applications to get restricted access to user information
    from a service, for example, Facebook, Twitter, or GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details, it would be useful to review the terminology
    typically used with respect to OAuth 2 authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example. Let's say we want to expose the Todo API to third-party
    applications on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important players in a typical OAuth 2 exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: This is the user of the third-party application that wants
    to use our Todo API. It decides how much of the information available with our
    API can be made available to the third-party application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: This hosts the Todo API, the resource ;we want to secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This is the third-party application that wants to consume our API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: This is the server that provides the OAuth service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level ;flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps show a ;high-level flow of a typical OAuth authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: The application requests that the user authorizes access to API resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the ;user provides access, the application receives an authorization grant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application provides user authorization grant and its own client credentials
    to the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the authentication is successful, the authorization server responds with
    an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application calls the API (the resource server) that provides the access
    token for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the access token is valid, the resource server returns the details of the
    resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing OAuth 2 authentication for our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth 2 for Spring Security (`spring-security-oauth2`) is the module to provide
    OAuth 2 support to Spring Security. We will add it as a dependency in our `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting up authorization and resource servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: spring-security-oauth2 has not yet been (June 2017) been updated with the changes
    for Spring Framework 5.x and Spring Boot 2.x. We will use Spring Boot 1.5.x for
    examples related to OAuth 2 authentication. Code examples are here in the GitHub
    repository ;[https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an authorization server would be a different server from the application
    where the API is exposed. To keep things simple, we will make our current API
    server act both as the resource server and as the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can enable our application to act as
    the resource and authorization server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of important things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableResourceServer`: A convenient annotation for OAuth 2 resource servers,
    enabling a Spring Security filter that authenticates requests via an incoming
    OAuth 2 token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAuthorizationServer`: A convenience annotation to enable an authorization
    server with ;`AuthorizationEndpoint` and ;`TokenEndpoint` in the current application
    context, which must be a `DispatcherServlet` context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can configure the access details in `application.properties`, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`security.user.name` and ;`security.user.password` are the authentication details
    of the resource owner that is an end user of a third-party application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.oauth2.client.clientId` and ;`security.oauth2.client.clientSecret`
    are the authentication details of the client that is the third-party application
    (the service consumer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing OAuth requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a two-step process to access the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the request using the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining an access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an access token, we call the authorization server (`http://localhost:8080/oauth/token`),
    providing the client authentication details in the basic authentication mode and
    the user credentials as part of the form data. The following screenshot shows
    how we can configure the client authentication details in basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5c2d818-4bee-47bc-a05f-73b94568d12d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how to configure the user authentication details
    as part of the POST parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bf1640a-be2f-4728-993b-9869b1f095bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are using `grant_type` ;as the password, indicating that we are sending
    the user authentication details to get the access token. When we execute the request,
    we get a response similar to the one shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of important details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`access_token`: Client application can use the access token to authenticate
    further API calls. However, the access token will expire, typically in a very
    short time period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_token`: Client application can submit a new request to the authentication
    server with the `refresh_token` to get a new `access_token`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the request using the access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have ;`access_token`, we can execute the request using ;`access_token`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c549b7c3-2c0e-41ec-bf28-57580a2d3173.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, we provide the access token in the
    request header called Authorization. We use the value of the format `"Bearer {access_token}"`.
    Authentication succeeds and we get the expected resource details.
  prefs: []
  type: TYPE_NORMAL
- en: Integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now update our integration test to provide the OAuth 2 credentials.
    The following test highlights the important details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`:
    We set up `ResourceOwnerPasswordResourceDetails` with the user credentials and
    the client credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`: Configures the URL
    of the authentication server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`:
    `OAuth2RestTemplate` is an extension of `RestTemplate`, which supports the OAuth
    2 protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at how to enable OAuth 2 authentication in our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internationalization** (**i18n**) is the process of developing applications
    and services so that they can be customized for different languages and cultures
    across the world. It is also called ;**localization**. The goal of internationalization
    or localization is to build applications that can offer content in multiple languages
    and formats.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot has built-in support for internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a simple service to understand how we can build internationalization
    in our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need to add a `LocaleResolver` and a message source to our Spring
    Boot application. The following code snippet should be included in `Application.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Some important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`: We are a setting a default
    locale of `Locale.US`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageSource.setBasenames("messages")`: We''re setting the base name of the
    message source as `messages`. If we are in fr locale (France), we would use messages
    from `message_fr.properties`. If a message is not available in `message_fr.properties`,
    it would be searched for in the default `message.properties`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageSource.setUseCodeAsDefaultMessage(true)`: If a message is not found,
    then the code is returned as the default message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure the messages in the respective files. Let''s start with the
    `messages` properties. The messages in this file would act as the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also configure `messages_fr.properties`. The messages in this file would
    be used for the locale. If a message is not present here, then the defaults from
    `messages.properties` will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a service that returns a specific message using the locale specified
    in the ;`"Accept-Language"` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`:
    The locale is picked up from the request header `Accept-Language`. It is not required.
    If a locale is not specified, the default locale is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`
    is autowired into the controller. We get the welcome message based on the given
    locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when the preceding service is called
    without specifying a default `Accept-Language`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c66a5e37-0172-4460-a7d3-c17a862ae5ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The default message from `messages.properties` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when the preceding service is called
    with `Accept-Language fr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da4bb0b-3be3-4efd-bd29-0f7aee72b0a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The localized message from `messages_fr.properties` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we customized the service to return localized messages
    based on the locale in the request. A similar approach can be used to internationalize
    ;all services in a component.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching data from services plays a crucial role in improving the performance
    and scalability of applications. In this section, we will look at the implementation
    options that Spring Boot provides.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a caching abstraction based on annotations. We will start with
    using Spring caching annotations. Later, we will introduce *JSR-107* caching annotations
    and compare them with Spring abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Spring-boot-starter-cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot provides a starter project for caching `spring-boot-starter-cache`.
    Adding this to an application brings in all the dependencies to enable *JSR-107*
    and Spring caching annotations. The following code snippet shows the dependency
    details for `spring-boot-starter-cache`. Let''s add this to our file `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Enabling caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start using caching, we need to enable caching on the application.
    The following code snippet shows how we can enable caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`@EnableCaching` would enable caching in a Spring Boot application.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot automatically configures a suitable CacheManager ;framework to serve
    as a provider for the relevant cache. We will look at the details of how Spring
    Boot decides the CacheManager a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have enabled caching, we can add the ;`@Cacheable` annotation to
    the methods where we want to cache the data. The following code snippet shows
    how to enable caching on `retrieveTodos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `todos` for a specific user are cached. On the
    first call to the method for a specific user, the `todos` will be retrieved from
    the service. On subsequent calls for the same user, the data will be returned
    from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring also provides conditional caching. In the following snippet, caching
    is enabled only if the specified condition is satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring also provides additional annotations to evict data from the cache and
    add some custom data to cache. A few important ones are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@CachePut`: Used to explicitly add data to the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheEvict`: Used to remove stale data from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Caching`: Allows multiple nested `@Cacheable`, `@CachePut` ;, and `@CacheEvict`
    ;annotations to be used on the same method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSR-107 caching annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*JSR-107* aims to standardize caching annotations. Listed here are some of
    the important *JSR-107* annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@CacheResult`: Similar to `@Cacheable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheRemove`: Similar to `@CacheEvict`; ;`@CacheRemove` supports conditional
    eviction if an exception occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheRemoveAll`: Similar to `@CacheEvict(allEntries=true)`; used to remove
    all entries from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSR-107* and Spring''s caching annotations are fairly similar in terms of
    the features they offer. Either of them is a good choice. We lean slightly toward
    *JSR-107* because it''s a standard. However, make sure you are not using both
    in the same project.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-detection order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When caching is enabled, Spring Boot auto-configuration starts looking for
    a caching provider. The following list shows the order in which Spring Boot searches
    for caching providers. The list is in order of decreasing preference:'
  prefs: []
  type: TYPE_NORMAL
- en: JCache (*JSR-107*) (EhCache 3, Hazelcast, Infinispan, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EhCache 2.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hazelcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinispan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Couchbase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffeine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot makes developing Spring-based applications easy. It enables us to
    create production-ready applications very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered how to add features such as exception handling,
    caching, and internationalization to our application. We discussed the best practices
    of documenting REST services using Swagger. We looked at the basics of securing
    our microservice with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention toward advanced features in
    Spring Boot. We will look at how to provide monitoring on top of our REST services,
    learn how to deploy the microservice to the Cloud, and understand how to become
    more productive when developing applications with Spring Boot.
  prefs: []
  type: TYPE_NORMAL

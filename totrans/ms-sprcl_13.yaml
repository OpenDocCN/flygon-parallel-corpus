- en: Testing Java Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Java微服务
- en: While developing a new application, we should never forget about automated tests.
    These are especially important if we are thinking about microservices-based architecture.
    Testing microservices requires a different approach than the tests created for
    monolithic applications. As far as monoliths are concerned, the main focus is
    on unit testing and  integration tests, together with the database layer. In the
    case of microservices, the most important thing is to provide coverage for each
    of the communications at the finest possible granularity. Although each microservice
    is independently developed and released, a change in one of them can affect all
    of the others that are interacting with that service. The communication between
    them is realized through messages. Usually, these are messages that are sent via
    REST or AMQP protocols.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发新应用程序时，我们不应忘记自动化测试。如果我们考虑基于微服务的架构，这些测试尤为重要。测试微服务需要与为单体应用程序创建的测试不同的方法。就单体应用程序而言，主要关注单元测试和集成测试，以及数据库层。对于微服务来说，最重要的是为每个通信提供尽可能精细的覆盖。尽管每个微服务都是独立开发和发布的，但其中一个的更改可能会影响与该服务交互的所有其他服务。它们之间的通信是通过消息实现的。通常，这些是通过REST或AMQP协议发送的消息。
- en: 'Topics we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Spring support for automated testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring对自动化测试的支持
- en: Differences between a component and integration testing for Spring Boot microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot微服务的组件和集成测试之间的差异
- en: Implementing contract tests using Pact
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pact实施合同测试
- en: Implementing contract tests using Spring Cloud Contract
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract实施合同测试
- en: Implementing performance tests using Gatling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gatling实施性能测试
- en: Testing strategies
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试策略
- en: 'There are five different microservices testing strategies. The first three
    of them are the same as for monolithic applications:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种不同的微服务测试策略。前三种与单体应用程序相同：
- en: '**Unit tests**: With unit tests, we test the smallest pieces of code, for example,
    a single method or component, and mock every call of other methods and components.
    There are many popular frameworks that support unit tests in Java, such as JUnit,
    TestNG, and Mockito (for mocking). The main task of this type of testing is to
    confirm that the implementation meets requirements. Unit testing can be a powerful
    tool, especially when combined with test-driven development.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：通过单元测试，我们测试代码的最小部分，例如单个方法或组件，并模拟每个其他方法和组件的调用。有许多流行的框架支持Java中的单元测试，例如JUnit、TestNG和Mockito（用于模拟）。这种测试的主要任务是确认实现是否符合要求。单元测试可以是一个强大的工具，特别是与测试驱动开发结合使用时。'
- en: '**Integration tests**: Using only unit testing doesn''t guarantee that you
    will verify the behavior of the whole system. Integration tests take the modules
    and try to test them together. This approach gives you an opportunity to exercise
    communication paths within the subsystem. We are testing the interaction and communication
    between components based on their interfaces with external services mocked-up.
    In a microservices-based system, integration tests can be used in order to include
    other microservices, data sources, or caches.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：仅使用单元测试不能保证您验证整个系统的行为。集成测试将模块组合在一起进行测试。这种方法使您有机会在子系统内部进行通信路径的测试。我们正在测试基于其接口与外部服务的组件之间的交互和通信，使用模拟。在基于微服务的系统中，可以使用集成测试来包括其他微服务、数据源或缓存。'
- en: '**End-to-end tests**: End-to-end tests are also known as **functional tests**.
    The main goal of these tests is to verify whether the system meets the external
    requirements. It means that we should design test scenarios that test all the
    microservices taking part in that process. The design of a good end-to-end test
    is not a trivial task. Since we need to test the whole system, it is very important
    to place a particular emphasis on the test''s scenario design.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：端到端测试也称为**功能测试**。这些测试的主要目标是验证系统是否满足外部要求。这意味着我们应设计测试场景，测试参与该过程的所有微服务。设计一个良好的端到端测试并不是一项琐碎的任务。由于我们需要测试整个系统，因此非常重要的是对测试场景的设计进行特别强调。'
- en: '**Contract tests**: Contract tests are used to ensure that the explicit and
    implicit contract of a microservice work as expected. A contract is always formed
    when a consumer integrates with the interface of a component in order to use it.
    Usually, in microservice-based systems, there are many consumers of a single component.
    Each of them usually requires a different contract that meets its demands. Following
    these assumptions, every consumer is responsible for a source component''s interface
    behavior.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同测试**：合同测试用于确保微服务的显式和隐式合同按预期工作。当消费者与组件的接口集成以便使用时，就会形成合同。通常，在基于微服务的系统中，有许多消费者使用单个组件。它们通常需要满足其需求的不同合同。根据这些假设，每个消费者都负责源组件的接口行为。'
- en: '**Component tests**: After we have completed unit testing of all the objects
    and methods within a microservice, we should test the whole microservice in isolation.
    In order to run the tests in isolation, we need to mock or stub the calls of the
    other microservices. An external data store should be replaced with an equivalent
    in-memory data store, which also provides significant test performance improvements.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件测试**：在完成微服务内所有对象和方法的单元测试后，我们应该在隔离环境中测试整个微服务。为了在隔离环境中运行测试，我们需要模拟或存根其他微服务的调用。外部数据存储应该被等效的内存数据存储替换，这也可以显著提高测试性能。'
- en: 'The differences between contract and component tests are obvious. The following
    diagram illustrates those differences in our sample `order-service` microservice:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试和组件测试之间的差异是显而易见的。以下图表说明了我们示例`order-service`微服务中的这些差异：
- en: '![](img/ce6b981a-9c68-4f29-926f-f51f4ca22502.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce6b981a-9c68-4f29-926f-f51f4ca22502.png)'
- en: Now, there is a question of whether we really need two additional strategies
    for testing a microservices-based system. Through the proper unit and integration
    tests, we may be confident in the correctness of the implementation of the individual
    components that form part of the microservice. However, without more specific
    test strategies for microservices, we cannot be sure how they work together in
    order to meet our business requirements. Therefore, component and contract tests
    have been added. This is a really important change in order to help us understand
    the differences between component, contract, and integration tests. Since component
    tests are performed in isolation from the outside world, integration tests are
    responsible for verifying interactions with that world. That's why we should provide
    stubs for an integration test in contrast with a components test. Contract tests,
    much like integration tests, emphasize interactions between microservices, but
    they treat them as a black box and verify only the format of the responses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是我们是否真的需要为测试基于微服务的系统而添加两种额外的策略。通过适当的单元测试和集成测试，我们可以对微服务的各个组件的实现正确性感到自信。但是，如果没有针对微服务的更具体的测试策略，我们无法确定它们如何一起工作以满足我们的业务需求。因此，我们添加了组件测试和契约测试。这是一个非常重要的变化，可以帮助我们理解组件、契约和集成测试之间的区别。由于组件测试是在与外部世界隔离的情况下进行的，集成测试负责验证与该世界的交互。这就是为什么我们应该为集成测试提供存根，而不是为组件测试。契约测试与集成测试类似，强调微服务之间的交互，但将它们视为黑匣子，并仅验证响应的格式。
- en: 'Once you provide functional tests for your microservices, you should also think
    about performance testing. We can distinguish the following strategies of performance
    testing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为微服务提供了功能测试，您还应考虑性能测试。我们可以区分以下性能测试策略：
- en: '**Load tests**: These are used to determine a system''s behavior under the
    normal and anticipated load conditions. The main idea here is to identify some
    weaknesses, such as response time latencies, aberrant outages, or too many retries
    if network timeouts are not set properly.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：用于确定系统在正常和预期负载条件下的行为。这里的主要思想是识别一些弱点，如响应时间延迟、异常中断或者如果网络超时未正确设置则会有太多的重试。'
- en: '**Stress tests**: These check the upper limits of your system to examine how
    it behaves under an extremely heavy load. In addition to load testing, it also
    checks out memory leaks, security issues, and data corruption. It may be using
    the same tools as for load testing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：检查系统的上限，以查看在极端重载下它的行为如何。除了负载测试，它还检查内存泄漏、安全问题和数据损坏。它可能使用与负载测试相同的工具。'
- en: 'The following diagram illustrates the logical order of performing all of the
    test strategies on your system. We are starting from the simplest unit testing,
    which verifies small pieces of software, and going through the next stages to
    finally finish with stress testing that pushes the whole system to the limit:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了在系统上执行所有测试策略的逻辑顺序。我们从最简单的单元测试开始，验证软件的小部分，然后经过下一个阶段，最终进行压力测试，将整个系统推向极限：
- en: '![](img/79c6864e-6185-4be3-8573-fe3fdcd8330e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79c6864e-6185-4be3-8573-fe3fdcd8330e.png)'
- en: Testing Spring Boot applications
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Spring Boot应用程序
- en: 'As you might have read in the previous section, there are some different strategies
    and approaches to the tests in your application. I have briefly mentioned all
    of them, so now we may proceed to the practical aspects. Spring Boot provides
    a set of utilities that help in the implementation of automated tests. In order
    to enable these features in the project, you have to include the `spring-boot-starter-test`
    starter to the dependencies. It imports not only the `spring-test` and `spring-boot-test`
    artifacts, but also some other useful test libraries, such as JUnit, Mockito,
    and AssertJ:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能在前一节中所读到的，您的应用程序中有一些不同的测试策略和方法。我已经简要提到了所有这些，所以现在我们可以继续进行实际方面的工作。Spring
    Boot提供了一组实用工具，可帮助实现自动化测试。为了在项目中启用这些功能，您必须将`spring-boot-starter-test` starter包含在依赖项中。它不仅导入了`spring-test`和`spring-boot-test`工件，还包括一些其他有用的测试库，如JUnit、Mockito和AssertJ：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Building the sample application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: 'Before we start to work on automated tests, we need to prepare a sample business
    logic for testing purposes. We may use the same example system from the previous
    chapters, but it has to be modified a little. Until now, we have never used an
    external data source for storing and collecting test data. In this chapter, it
    would be helpful to do this in order to illustrate how the different strategies
    approach the issue of persistence testing. Now, each service has its own database
    although, generally, it doesn''t really matter which database is chosen. There
    is a large choice of solutions supported by Spring Boot, including both relational
    and NoSQL databases. I have decided to use Mongo. Let us remind ourselves of the
    architecture of the sample system. The current model shown in the following diagram
    takes into account the assumptions described previously regarding dedicated databases
    per service:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行自动化测试之前，我们需要为测试目的准备一个样本业务逻辑。我们可以使用前几章中的相同示例系统，但需要进行一些修改。到目前为止，我们从未使用外部数据源来存储和收集测试数据。在本章中，这样做将有助于说明不同策略如何处理持久性测试的问题。现在，每个服务都有自己的数据库，尽管通常选择哪个数据库并不重要。Spring
    Boot支持多种解决方案，包括关系型数据库和NoSQL数据库。我决定使用Mongo。让我们回顾一下示例系统的架构。以下图表显示的当前模型考虑了先前描述的有关每个服务专用数据库的假设：
- en: '![](img/2b538768-b0e9-4e90-bc9e-df506778371a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b538768-b0e9-4e90-bc9e-df506778371a.png)'
- en: Integration with the database
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库集成
- en: 'In order to enable Mongo support for our Spring Boot application, include the
    `spring-boot-starter-data-mongo` starter to the dependencies. This project provides
    some interesting features to simplify integration with MongoDB. Among these features,
    it is worth mentioning particular rich object mapping, `MongoTemplate`, and of
    course support for the repository writing style, well-known from other Spring
    Data projects. Here''s the required dependency declaration in `pom.xml`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的Spring Boot应用程序启用Mongo支持，将`spring-boot-starter-data-mongo`启动器包含到依赖项中。该项目提供了一些有趣的功能，以简化与MongoDB的集成。其中，值得一提的是特别丰富的对象映射，`MongoTemplate`，当然还有对来自其他Spring
    Data项目的仓库写入风格的支持。以下是在`pom.xml`中的必需依赖声明：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The instance of MongoDB may be easily started using its Docker image. Run the
    following command to launch the Docker container that exposes the Mongo database
    on port `27017`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其Docker镜像可以轻松启动MongoDB的实例。运行以下命令启动暴露Mongo数据库端口`27017`的Docker容器：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to connect the application with a previously started data source,
    we should override some `auto-configured` settings in `application.yml`. This
    can be achieved with the `spring.data.mongodb.*` properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将应用程序连接到先前启动的数据源，我们应该覆盖`application.yml`中的一些`自动配置`设置。这可以通过`spring.data.mongodb.*`属性实现：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I have already mentioned the object mapping feature. Spring Data Mongo provides
    some annotations that may be used for this. Every object stored in the database
    should be annotated with `@Document`. The primary key of the target collection
    is a 12 byte string, which should be indicated in every mapped class with Spring
    Data `@Id`. Here''s the fragment of `Account` object implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了对象映射功能。Spring Data Mongo提供了一些注解可用于此。存储在数据库中的每个对象都应该用`@Document`进行注释。目标集合的主键是一个12字节的字符串，应该在每个映射类中用Spring
    Data `@Id`进行指示。以下是`Account`对象实现的片段：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unit tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: I have taken a lot of time to describe integration with MongoDB. However, testing
    persistence is one of the key points of automated tests, so it is very important
    to configure it properly. Now, we may proceed to the test's implementation. Spring
    Test provides support for the most typical testing scenarios, such as integration
    with other services through a REST client or integration with databases. We have
    a set of libraries available that allows us to easily mock interactions with external
    services, which is especially important for unit tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了很多时间来描述与MongoDB的集成。然而，测试持久性是自动化测试的关键点之一，因此正确配置它非常重要。现在，我们可以继续进行测试的实现。Spring
    Test提供了对最典型的测试场景的支持，例如通过REST客户端与其他服务集成或与数据库集成。我们有一套可用的库，可以让我们轻松地模拟与外部服务的交互，这对于单元测试尤为重要。
- en: 'The following test class is a typical unit test implementation for a Spring
    Boot application. We have used the JUnit framework, which is the de facto standard
    for Java. The Mockito library is used here for replacing the real repository and
    controller with their stubs. Such an approach allows us to easily verify the correctness
    of every method implemented by the `@Controller` class. The test is performed
    in isolation from the external components, which is the main assumption of unit
    testing:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试类是Spring Boot应用程序的典型单元测试实现。我们使用了Java的事实标准JUnit框架。Mockito库在这里用于用其存根替换真实的存储库和控制器。这种方法使我们能够轻松验证`@Controller`类的每个方法的正确性。该测试是在与外部组件隔离的情况下进行的，这是单元测试的主要假设：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The good news, especially within the context of microservices, is that we may
    easily mock Feign client communication. The following example test class verifies
    the endpoint from `order-service` used for withdrawing money by calling the endpoint
    exposed by `account-service`. As you have probably noticed, that endpoint has
    in turn been tested by the previously introduced test class. Here''s the class
    with unit test implementation for `order-service`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在微服务的背景下，好消息是我们可以轻松地模拟Feign客户端通信。以下示例测试类验证了通过调用`account-service`暴露的端点来从`order-service`中提取资金的端点。您可能已经注意到，该端点反过来已经由先前介绍的测试类进行了测试。以下是`order-service`的单元测试实现的类：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Component tests
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: If you have provided the unit tests for all the key classes and interfaces in
    the application, you may proceed to the component tests. The main idea of component
    tests is to instantiate the full microservice in memory using in-memory test doubles
    and data stores. This allows us to skip the network connections. While for unit
    tests we were mocking all the database or HTTP clients, here we do not mock anything.
    We provide an in-memory data source for the database client and we simulate HTTP
    responses for the REST client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经为应用程序中的所有关键类和接口提供了单元测试，可以继续进行组件测试。组件测试的主要思想是使用内存中的测试替身和数据存储在内存中实例化完整的微服务。这使我们可以跳过网络连接。而对于单元测试，我们是在模拟所有数据库或HTTP客户端，这里我们不模拟任何东西。我们为数据库客户端提供了内存数据源，并为REST客户端模拟HTTP响应。
- en: Running tests with an in-memory database
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存数据库运行测试
- en: 'One of the reasons I chose MongoDB is that it can be easily embedded with a
    Spring Boot application for testing purposes. To enable an embedded MongoDB for
    your project, include the following dependency in Maven `pom.xml`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择MongoDB的一个原因是它可以轻松地与Spring Boot应用程序嵌入在一起进行测试。要为项目启用嵌入式MongoDB，请在Maven的`pom.xml`中包含以下依赖项：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Spring Boot provides auto-configuration for an embedded MongoDB, so we don''t
    need to do anything else other than setting the local address and port in `application.yml`.
    Because, by default, we use Mongo running on Docker container, we should declare
    such a configuration in an additional Spring profile. This specific profile is
    activated during test case execution by annotating the test class with `@ActiveProfiles`.
    Here''s a fragment of `application.yml`, where we defined two profiles, `dev`
    and `test`, with different MongoDB connection settings:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为内置的MongoDB提供了自动配置，因此我们无需做任何其他设置，只需在`application.yml`中设置本地地址和端口。因为默认情况下我们使用在Docker容器上运行的Mongo，我们应该在额外的Spring配置文件中声明这样的配置。这个特定的配置文件通过在测试类上注释`@ActiveProfiles`来在测试用例执行期间激活。以下是`application.yml`的片段，其中我们定义了两个配置文件，`dev`和`test`，具有不同的MongoDB连接设置：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you use databases other than MongoDB, for example, MySQL or Postgres, you
    may easily replace them with alternative, in-memory, embedded, relational databases,
    such as H2 or Derby. Spring Boot supports them and provides auto-configuration
    for the tests that may be activated with `@DataJpaTest`. Instead of using `@SpringBootTest`,
    you can also use the `@DataMongoTest` annotation for embedded MongoDB. As well
    as an in-memory, embedded MongoDB, this will configure a `MongoTemplate`, scan
    for `@Document` classes, and configure Spring Data MongoDB repositories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的数据库不是MongoDB，例如MySQL或Postgres，您可以轻松地将它们替换为替代的内存嵌入式关系数据库，如H2或Derby。Spring
    Boot支持它们，并为可以使用`@DataJpaTest`激活的测试提供自动配置。您还可以使用`@DataMongoTest`注解来使用内置的MongoDB，而不是使用`@SpringBootTest`。除了使用内存嵌入式MongoDB之外，这还将配置`MongoTemplate`，扫描`@Document`类，并配置Spring
    Data MongoDB存储库。
- en: Handling HTTP clients and service discovery
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTTP客户端和服务发现
- en: The issue regarding testing persistence with an in-memory database is resolved.
    However, we still need to consider some other aspects of the test, such as simulating
    HTTP responses from other services or integration with a service discovery. When
    you implement some tests for microservices, you may choose between two typical
    approaches to a service discovery. The first of these is to embed the discovery
    server to the application during the test case execution, and the second is just
    to disable discovery on the client side. The second option is relatively easy
    to configure with Spring Cloud. For the Eureka Server, it can be disabled using
    the `eureka.client.enabled=false` property.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用内存数据库进行持久性测试的问题已解决。但是，我们仍然需要考虑测试的其他方面，比如模拟来自其他服务的HTTP响应或与服务发现的集成。当您为微服务实施一些测试时，您可以选择两种典型的服务发现方法。其中之一是在测试用例执行期间将发现服务器嵌入到应用程序中，另一种方法是在客户端上禁用发现。使用Spring
    Cloud相对容易配置第二个选项。对于Eureka Server，可以使用`eureka.client.enabled=false`属性来禁用它。
- en: 'This is only the first part of the exercise. We should also disable discovery
    for the Ribbon client, which is responsible for load balancing in an interservice
    communication. If there is more than one target service, we have to label every
    client with the service name. The value of the last property in the following
    configuration, `listOfServers`, is strictly related to the framework used for
    automated test implementation. I''m going to show you the sample based on the
    Hoverfly Java library, which has already been introduced in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml),
    *Advanced Load Balancing and Circuit Breakers*. It was used then for simulating
    delays in calling target services in order to present how the Ribbon client and
    Hystrix deal with network timeouts. Here, we will just use it to return prepared
    responses to make our component tests to touch the network communications. Here''s
    a fragment of the configuration file with the profile responsible for disabling
    Eureka''s discovery and setting the test properties of the Ribbon client. That
    profile should also be activated for the test class by annotating it with `@ActiveProfiles`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是练习的第一部分。我们还应该禁用Ribbon客户端的发现，它负责负载均衡在服务间通信中。如果有多个目标服务，我们必须用服务名称标记每个客户端。在以下配置中最后一个属性的值，`listOfServers`，与用于自动化测试实现的框架密切相关。我将根据Hoverfly
    Java库展示样本，该库已经在[第7章](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml)中介绍过，*高级负载均衡和断路器*。当时它用于模拟调用目标服务时出现延迟，以展示Ribbon客户端和Hystrix如何处理网络超时。在这里，我们只是用它返回准备好的响应，使我们的组件测试接触网络通信。以下是配置文件的片段，其中包含负责禁用Eureka发现和设置Ribbon客户端测试属性的配置文件。该配置文件还应通过使用`@ActiveProfiles`对测试类进行激活：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I wouldn''t like to go into the details of Hoverfly usage because it has already
    been discussed in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml), *Advanced
    Load Balancing and Circuit Breakers*. As you probably remember, Hoverfly can be
    activated for the JUnit test by declaring `@ClassRule` with `HoverflyRule`, defining
    the list of services and endpoints that should be simulated. The name of each
    service has to be the same as its address defined with the `listOfServers` property.
    Here''s a definition of the Hoverfly test rule that simulates responses from three
    different services:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想深入讨论Hoverfly的使用，因为它已经在[第7章](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml)中讨论过，*高级负载均衡和断路器*。您可能还记得，可以通过声明`@ClassRule`和`HoverflyRule`来激活Hoverfly进行JUnit测试，定义应该模拟的服务和端点列表。每个服务的名称必须与`listOfServers`属性定义的地址相同。以下是模拟来自三个不同服务的响应的Hoverfly测试规则的定义：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing sample tests
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施样本测试
- en: 'To conclude everything that has been said in the last two sections, we will
    now prepare component tests using an in-memory, embedded MongoDB, Hoverfly (to
    simulate HTTP responses), and disabled service discovery. The correct configuration
    settings prepared especially for our testing purposes are available under profiles
    `test` and `no-discovery`. Every component test is initialized by the `TestRestTemplate`,
    which calls `order-service` HTTP endpoints. The test result verification may be
    performed based on the HTTP response or data stored in the embedded MongoDB. Here''s
    a sample implementation of component tests for `order-service`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在过去的两个部分中所说的一切，我们现在将使用内存中的嵌入式MongoDB、Hoverfly（用于模拟HTTP响应）和禁用的服务发现来准备组件测试。专为我们的测试目的准备的正确配置设置在`test`和`no-discovery`配置文件中可用。每个组件测试都由`TestRestTemplate`初始化，该模板调用`order-service`的HTTP端点。测试结果验证可以基于HTTP响应或存储在嵌入式MongoDB中的数据进行。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Integration tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: After creating unit and component tests, we have verified all the functionalities
    inside the microservices. However, we still need to test the interaction with
    other services, external data stores, and caches. In microservices-based architecture
    integration, tests are treated differently than they are in monolithic applications.
    Because all the relationships between internal modules have been tested through
    the component tests, we have tested only those modules that interact with external
    components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建单元测试和组件测试之后，我们已经验证了微服务内部的所有功能。然而，我们仍然需要测试与其他服务、外部数据存储和缓存的交互。在基于微服务的架构集成中，测试的处理方式与单体应用程序中的处理方式不同。因为所有内部模块之间的关系都已经通过组件测试进行了测试，所以我们只测试与外部组件交互的那些模块。
- en: Categorizing tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类测试
- en: 'It also makes sense to separate integration tests in the CI pipeline so that
    external outages don''t block or break the build of the project. You should consider
    categorizing your tests by annotating them with `@Category`. You may create the
    interface especially for integration tests, for example, `IntegrationTest`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI流水线中分离集成测试也是有意义的，这样外部故障就不会阻塞或破坏项目的构建。您应该考虑通过使用`@Category`为测试进行分类。您可以创建专门用于集成测试的接口，例如`IntegrationTest`：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, you can mark your test with that interface using the `@Category` annotation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，您可以使用`@Category`注解将您的测试标记为该接口： '
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you can configure Maven to run only the selected type of tests, for
    example, with `maven-failsafe-plugin`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以配置Maven仅运行所选类型的测试，例如使用`maven-failsafe-plugin`：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Capturing HTTP traffic
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获HTTP流量
- en: Categorization is one of the ways of dealing with problems in communication
    with external microservices during automated tests. Another popular approach to
    that issue involves recording outgoing requests and incoming responses in order
    to use them in the future without establishing a connection to the external services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 分类是在自动化测试中处理与外部微服务通信问题的一种方式。解决这个问题的另一种流行方法涉及记录出站请求和入站响应，以便在将来使用它们而不需要连接到外部服务。
- en: In the previous examples, we have only used Hoverfly in simulation mode. However,
    it can also be run in capture mode, which means that requests will be made to
    the real service as normal, but they will be intercepted, recorded, and stored
    in the file by Hoverfly. The file that stores the captured traffic in JSON format
    may then be used in simulation mode. You can create a Hoverfly Rule in your JUnit
    test class, which is started in capture mode if the simulation file does not exist
    and in simulate mode if it does exist. It is always stored inside the `src/test/resources/hoverfly`
    directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们只在模拟模式下使用了Hoverfly。然而，它也可以在捕获模式下运行，这意味着请求将像正常情况下一样发送到真实服务，但它们将被Hoverfly拦截、记录并存储在文件中。以JSON格式存储捕获的流量的文件可以在模拟模式下使用。您可以在您的JUnit测试类中创建一个Hoverfly规则，如果模拟文件不存在，则以捕获模式启动，如果存在则以模拟模式启动。它始终存储在`src/test/resources/hoverfly`目录中。
- en: This is a simple way of breaking dependencies to the external service. For example,
    if you know that there were no changes there, it is not necessary to interact
    with the real service. If such a service were to be modified, you can remove the
    JSON simulation file and thereby switch to capture mode. If your test fails, it
    means that the modification affected your service and you have to perform some
    fixes before moving back to capture mode.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，用于打破对外部服务的依赖关系。例如，如果您知道那里没有发生变化，就没有必要与真实服务进行交互。如果这样的服务被修改，您可以删除JSON模拟文件，从而切换到捕获模式。如果您的测试失败，这意味着修改影响了您的服务，您必须在返回捕获模式之前进行一些修复。
- en: 'Here''s a sample integration test located inside `order-service`. It adds a
    new account and then calls a method for withdrawing money from that account. Thanks
    to using the `inCaptureOrSimulationMode` method, the real service is invoked only
    if the `account.json` file does not exist or you change the input data passed
    to the services in the test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个位于`order-service`内部的样本集成测试。它添加了一个新的账户，然后调用一个方法从该账户中提取资金。由于使用了`inCaptureOrSimulationMode`方法，只有在`account.json`文件不存在或者您改变了传递给测试服务的输入数据时，才会调用真实的服务：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Contract tests
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: There are some interesting tools especially dedicated to contract testing. We
    will discuss this concept by looking at two of the most popular tools—Pact and
    Spring Cloud Contract.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门用于合同测试的有趣工具。我们将通过查看两种最流行的工具——Pact和Spring Cloud Contract来讨论这个概念。
- en: Using Pact
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pact
- en: 'As we have already mentioned, the main concept around contract tests is to
    define a contract between the consumer and provider, and then verify it independently
    for each service. Since the responsibility for creating and maintaining a contract
    lies mainly on the consumer side, this type of test is usually referred to as
    a consumer-driven test. The division into a consumer and provider side is clearly
    visible in Pact JVM. It provides two separated libraries, the first prefixed by
    `pact-jvm-consumer` and the second prefixed by `pact-jvm-provider`. Of course,
    the contract is created by the consumer in agreement with the provider, which
    has been illustrated in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33b5f96-1fa5-40cf-a968-da07cb4ad39e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Pact is, in fact, a collection of frameworks that provide support for consumer-driven
    contract testing. These implementations are available for different languages
    and frameworks. Fortunately, Pact may be used together with JUnit and Spring Boot.
    Let''s consider one of the integrations implemented in our sample system, namely
    the one between `customer-service` and `account-service`. The microservice named
    `customer-service` uses the Feign client for communication with `account-service`.
    The Feign client definition on the consumer side de facto represents our contract:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Consumer side
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable Pact with JUnit support on the consumer side, include the following
    dependency to your project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the only thing we have to do is to create the JUnit test class. We may
    implement it as a standard Spring Boot test by annotating it with `@SpringBootTest`
    and running it using Spring Runner. To perform the created test successfully,
    we first need to disable the discovery client and ensure that the Ribbon client
    will communicate with the stub of the `account-service` represented by `@Rule`
    `PactProviderRuleMk2`. The key point of the test is the `callAccountClient` method,
    which is annotated with `@Pact` and returns a `RequestResponsePact`. It defines
    the format of the request and the content of the response. During the test case
    execution, Pact automatically generates the JSON representation of that definition,
    which is available in the `target/pacts/addressClient-customerServiceProvider.json`
    file. Finally, the method implemented in the Feign client is invoked and the response
    returned by Pact `@Rule` is verified in the test method annotated with `@PactVerification`.
    Here''s a sample implementation of a consumer-side contract test for `customer-service`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The JSON test result file generated in the `target/pacts` directory has to
    be available on the provider side. The simplest possible solution assumes that
    it can just access the generated file using the `@PactFolder` annotation. Of course,
    it requires the provider to have access to the `target/pacts` directory. Although
    it would work for our sample since its source code is stored in the same Git repository,
    it is not our target solution. Fortunately, we may publish the Pact test result
    in the network using Pact Broker. Pact Broker is a repository server that provides
    an HTTP API for publication and consumption of Pact files. We may start Pact Broker
    locally using its Docker image. It requires a Postgres database as a backend store,
    so we also start the container with Postgres. Here are the required Docker commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After running Pact Broker on Docker, we have to publish our test report there.
    We may easily perform this using the Maven plugin `pact-jvm-provider-maven_2.12`.
    If you run the `mvn clean install pack:publish` command, all the files placed
    in the `/target/pacts` directory will be sent to the broker''s HTTP API:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The full list of published Pacts can be displayed using the web console available
    at `http://192.168.99.100:9080`. It also provides the information about the last
    verification date and the details of every Pact in the list, as shown in the following
    screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55c94e0d-75da-45aa-a98f-2d8af546530e.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Producer side
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming the consumer has created a Pact and published it on the broker, we
    may proceed to implement a verification test on the provider side. To enable Pact
    with JUnit support on the provider side, include the `pact-jvm-provider-junit`
    dependency to your project. There is also another framework available, `pact-jvm-provider-spring`.
    This library allows you to run contract tests against a provider using Spring
    and JUnit. The list of required dependencies is visible on the following fragment
    of Maven `pom.xml`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设消费者已经创建了一个Pact并将其发布到代理商，我们可以继续在提供者端实现验证测试。要在提供者端启用Pact并支持JUnit，请将`pact-jvm-provider-junit`依赖项包含到您的项目中。还有另一个可用的框架，`pact-jvm-provider-spring`。这个库允许您使用Spring和JUnit来运行针对提供者的合同测试。所需依赖项的列表可见于Maven
    `pom.xml`的以下片段：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thanks to the dedicated library for Spring, we may use `SpringRestPactRunner`
    instead of the default `PactRunner`. This, in turn, allows you to use the Spring
    test annotations, such as `@MockBean`. In the following JUnit test, we mock the
    `AccountRepository` bean. It returns three objects expected by the test on the
    consumer side. The test automatically starts the Spring Boot application and calls
    the `/customer/{customerId}` endpoint. There are also two other important things.
    By using the `@Provider` and `@State` annotations, we need to set the same names
    as were set for the test on the consumer side inside the `@Pact` annotation. Finally,
    by declaring `@PactBroker` on the test class, we provide the connection settings
    to the Pact''s repository. Here''s sample test using Pact, that verifies contract
    published by `customer-service`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring专用库，我们可以使用`SpringRestPactRunner`而不是默认的`PactRunner`。这反过来允许您使用Spring测试注释，例如`@MockBean`。在以下JUnit测试中，我们模拟了`AccountRepository`
    bean。它返回了消费者端测试所期望的三个对象。测试会自动启动Spring Boot应用程序并调用`/customer/{customerId}`端点。还有另外两件重要的事情。通过使用`@Provider`和`@State`注释，我们需要设置与在消费者端测试中设置的相同名称，这些名称在`@Pact`注释内。最后，通过在测试类上声明`@PactBroker`，我们提供了与Pact存储库的连接设置。以下是使用Pact的示例测试，用于验证由`customer-service`发布的合同：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using Spring Cloud Contract
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Contract
- en: 'Spring Cloud Contract presents a slightly different approach to contract testing
    than Pack. While in Pack the consumer is responsible for publishing the contract,
    in Spring Cloud Contract the initiator of this action is the provider. The contracts
    are stored in a Maven repository as JARs, containing the stubs automatically generated
    based on the contract definition file. These definitions may be created using
    the Groovy DSL syntax. Each of them consists of two main parts: the request and
    the response specification. On the basis of these files, Spring Cloud Contract
    generates JSON stub definitions, which are used by WireMock for integration testing
    on the client side. In contrast to Pact, which is used as the tool supporting
    consumer-driven contracts testing for REST APIs, it has been designed especially
    for testing JVM-based microservices. It consists of three subprojects:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Contract提出了与Pact略有不同的合同测试方法。在Pact中，消费者负责发布合同，而在Spring Cloud Contract中，发起者是提供者。合同存储在Maven存储库中作为JAR文件，其中包含根据合同定义文件自动生成的存根。这些定义可以使用Groovy
    DSL语法创建。它们每个都由两个主要部分组成：请求和响应规范。基于这些文件，Spring Cloud Contract生成JSON存根定义，这些定义由WireMock用于客户端的集成测试。与Pact相比，Pact用作支持REST
    API的消费者驱动合同测试的工具，而Spring Cloud Contract专为测试基于JVM的微服务而设计。它由三个子项目组成：
- en: Spring Cloud Contract Verifier
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Contract Verifier
- en: Spring Cloud Contract Stub Runner
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Contract Stub Runner
- en: Spring Cloud Contract WireMock
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Contract WireMock
- en: Let's analyze how they should be used in our contract tests based on the same
    example that was previously described in the section about the Pact framework.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析如何根据Pact框架部分中先前描述的相同示例来使用它们在我们的合同测试中。
- en: WireMock is a simulator for HTTP-based APIs. Some might consider it a service
    virtualization tool or a mock server. It is able to get up and running quickly
    by capturing traffic to and from an existing API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: WireMock是一个基于HTTP的API的模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。它能够通过捕获对现有API的流量来快速启动和运行。
- en: Defining contracts and generating stubs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义合同并生成存根
- en: 'As I have already mentioned in contrast to Pact, in Spring Cloud Contract,
    the provider (server side) is responsible for publishing the contract specification.
    Therefore, we will begin the implementation from `account-service`, which serves
    the endpoint invoked by `customer-service`. But before proceeding to the implementation,
    take a look at the following diagram. It illustrates the main components taking
    part in our testing process. The source code of the sample application is available
    in the same GitHub repository as the previous samples, but on a different branch
    contract:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，与Pact相反，在Spring Cloud Contract中，提供者（服务器端）负责发布合同规范。因此，我们将从`account-service`开始实现，该服务端点由`customer-service`调用。但在进行实现之前，请看一下以下图表。它说明了参与我们测试过程的主要组件。示例应用程序的源代码可在与先前示例相同的GitHub存储库中找到，但在不同的分支合同中：
- en: '![](img/03bc1e16-89eb-4c5a-bc68-a00382569392.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03bc1e16-89eb-4c5a-bc68-a00382569392.png)'
- en: 'To enable Spring Cloud Contract functionalities for the provider-side application,
    first you have to include Spring Cloud Contract Verifier to your project dependencies:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在提供者端应用程序中启用Spring Cloud Contract功能，首先必须将Spring Cloud Contract Verifier包含到您的项目依赖项中：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to add the Spring Cloud Contract Verifier Maven plugin, which
    generates and runs your contract tests. It also produces and installs stubs in
    the local Maven repository. The only parameter you have to define for it is the
    package where the base classes extended by the generated test classes are located:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加Spring Cloud Contract Verifier Maven插件，它生成并运行您的合同测试。它还会生成并安装存根到本地Maven存储库。您唯一需要为其定义的参数是生成的测试类所在的基类的包：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we have to create a base class for the contract tests. It should be placed
    within the `pl.piomin.services.account` package. In the following base class,
    we set up a Spring Boot application with `@SpringBootTest` and then mock away
    the `AccountRepository`. We also use `RestAssured` to mock Spring MVC and send
    requests only to our controller. Thanks to all these mocks, the test does not
    interact with any external components, such as a database or an HTTP endpoint,
    and tests only the contract:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为合同测试创建一个基类。它应该放在`pl.piomin.services.account`包中。在下面的基类中，我们使用`@SpringBootTest`设置了一个Spring
    Boot应用程序，然后模拟了`AccountRepository`。我们还使用`RestAssured`来模拟Spring MVC，并且只向我们的控制器发送请求。由于所有这些模拟，测试不会与任何外部组件交互，比如数据库或HTTP端点，并且只测试合同。
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have provided all the configuration and base classes needed for running tests
    with Spring Cloud Contract. Therefore, we may proceed to the most important part,
    defining the contract using the Spring Cloud Contract Groovy DSL. All the specifications
    of the contracts should be located in the `/src/test/resources/contracts` directory.
    The specific location under this directory, which contains stub definitions, is
    treated as a base test class name. Each stub definition represents a single contract
    test. Based on this rule, `spring-cloud-contract-maven-plugin` automatically finds
    the contract and assigns it to the base test class. In the example we are currently
    discussing, I have placed my stub definition in the `/src/test/resources/contracts/accountService`
    directory. So the generated test class name is `AccountServiceTest`, and it also
    extends the `AccountServiceBase` class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了运行Spring Cloud Contract测试所需的所有配置和基类。因此，我们可以继续进行最重要的部分，使用Spring Cloud
    Contract Groovy DSL定义合同。所有合同的规范都应该位于`/src/test/resources/contracts`目录下。这个目录下的特定位置包含存根定义，被视为基本测试类名。每个存根定义代表一个单独的合同测试。根据这个规则，`spring-cloud-contract-maven-plugin`会自动找到合同并将其分配给基本测试类。在我们当前讨论的例子中，我将我的存根定义放在了`/src/test/resources/contracts/accountService`目录下。因此生成的测试类名是`AccountServiceTest`，它也扩展了`AccountServiceBase`类。
- en: 'Here''s the sample contract specification that returns a list of accounts belonging
    to the customer. This contract is not very trivial, so some things need to be
    explained. You can use regular expressions to write your requests in Contract
    DSL. You can also provide different values for every property depending on the
    communication side (consumer or producer). Contract DSL also gives you the ability
    to reference a request in your response by using the `fromRequest` method. The
    following contract returns a list of three accounts, taking the `customerId` field
    from the request path and the `id` field, consisting of five digits:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回属于客户的账户列表的样本合同规范。这份合同并不是非常琐碎，所以有些事情需要解释。您可以使用正则表达式在合同DSL中编写您的请求。您还可以根据通信方的不同为每个属性提供不同的值（消费者或生产者）。合同DSL还可以通过使用`fromRequest`方法在响应中引用请求。以下合同返回一个包含三个账户的列表，从请求路径中获取`customerId`字段和由五位数字组成的`id`字段。
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Test classes are generated under the `target/generated-test-sources` directory
    during the test phase of the Maven build. Here''s the class generated from the
    contract specification described earlier:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven构建的测试阶段，测试类会生成在`target/generated-test-sources`目录下。这是从之前描述的合同规范生成的类：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Verifying a contract on the consumer side
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在消费者端验证合同
- en: 'Assuming we have successfully built and run tests on the provider side, the
    stubs will have been generated and then published in our local Maven repository.
    To be able to use them during the consumer application test, we should include
    Spring Cloud Contract Stub Runner to the project dependencies:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功在提供者端构建并运行了测试，存根将已经生成并发布在我们的本地Maven存储库中。为了在消费者应用程序测试期间使用它们，我们应该将Spring
    Cloud Contract Stub Runner包含到项目依赖中。
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then we should annotate our test class with `@AutoConfigureStubRunner`. It takes
    two input parameters—`ids` and `workOffline`. The `Ids` field is a concatenation
    of the `artifactId`, `groupId`, version number, `stubs` qualifier, and port number,
    and generally points out to the JAR which stubs are published by the provider.
    The `workOffline` flag indicates where the repository with the stubs is located.
    By default, the consumer tries to download artifacts automatically from Nexus
    or Artifactory. If you would like to force Spring Cloud Contract Stub Runner to
    download stubs only from the local Maven repository, you can switch the value
    of the `workOffline` parameter to `true`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该用`@AutoConfigureStubRunner`注解我们的测试类。它有两个输入参数——`ids`和`workOffline`。`Ids`字段是`artifactId`、`groupId`、版本号、`stubs`限定符和端口号的连接，通常指向提供者发布的JAR。`workOffline`标志指示存根所在的存储库位置。默认情况下，消费者会尝试从Nexus或Artifactory自动下载构件。如果您想要强制Spring
    Cloud Contract Stub Runner只从本地Maven存储库下载存根，您可以将`workOffline`参数的值切换为`true`。
- en: 'Here''s a JUnit test class that uses the Feign client to invoke the endpoint
    from the stub published by the provider side. Spring Cloud Contract looks for
    the newest version of the `pl.piomin.services:account-service` artifact. It has
    been indicated by passing the `+` sign as a version of the stub inside the `@AutoConfigureStubRunner`
    annotation. If you would like to use the concrete version of that artifact, you
    may set the current version from your `pom.xml` file instead of `+`, for example,
    `@AutoConfigureStubRunner(ids = {"pl.piomin.services:account-service:1.0-SNAPSHOT:stubs:8091"})`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JUnit测试类，它使用Feign客户端调用提供者端发布的存根的端点。Spring Cloud Contract会寻找`pl.piomin.services:account-service`构件的最新版本。通过在`@AutoConfigureStubRunner`注解中传递`+`号作为存根版本的指示，来指定它。如果您想要使用该构件的具体版本，您可以在`pom.xml`文件中设置当前版本，而不是使用`+`，例如`@AutoConfigureStubRunner(ids
    = {"pl.piomin.services:account-service:1.0-SNAPSHOT:stubs:8091"})`：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only thing left is to build the whole project using the `mvn clean install`
    command in order to verify that tests are running successfully. However, we should
    remember that the tests created before cover only integration between `customer-service`
    and `account-service`. In our sample system, there are some other integrations
    between microservices that should be verified. I'll show you one more example,
    which tests the whole system. It tests methods exposed `order-service`, which
    communicates with all the other microservices. For this, we are going to use another
    interesting feature of Spring Cloud Contract scenarios.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是使用 `mvn clean install` 命令构建整个项目，以验证测试是否成功运行。但是，我们应该记住，之前创建的测试仅涵盖了 `customer-service`
    和 `account-service` 之间的集成。在我们的示例系统中，还有一些其他微服务之间的集成需要进行验证。我将向您展示另一个示例，它测试整个系统。它测试了暴露给
    `order-service` 的方法，该方法与所有其他微服务进行通信。为此，我们将使用 Spring Cloud Contract 场景的另一个有趣特性。
- en: Scenarios
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: 'Defining scenarios with Spring Cloud Contract is not difficult. The only thing
    you have to do is to provide the proper naming convention while creating a contract.
    This convention assumes that every contract''s name that is a part of the scenario
    is prefixed by an order number and an underscore. All the contracts included in
    a single scenario have to be located in the same directory. Spring Cloud Contract
    scenarios are based on WireMock''s scenarios. Here''s a directory structure with
    contracts defined for the needs of scenario that creates and accepts an order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Contract 定义场景并不困难。您唯一需要做的就是在创建合同时提供适当的命名约定。该约定假定属于场景的每个合同的名称都以订单号和下划线为前缀。包含在单个场景中的所有合同必须位于同一目录中。Spring
    Cloud Contract 场景基于 WireMock 的场景。以下是为创建和接受订单的场景定义的合同的目录结构：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the test''s source code generated for this scenario:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为此场景生成的测试源代码：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s imagine that we have a lot of microservices, and most of them communicate
    with one or more other microservices. So, even if you test a single contract,
    you can''t be sure that all other contracts during interservice communication
    work as expected. However, with Spring Cloud Contract, you may easily include
    all required stubs to your test class. That gives you the ability to verify all
    the contracts in the defined scenarios. This is required to include both `spring-cloud-starter-contract-verifier`
    and `spring-cloud-starter-contract-stub-runner` dependencies to the project. The
    following class definition acts as a base for the Spring Cloud Contract test class
    and includes stubs generated by other microservices. The stub generated for `order-service`
    endpoints may be used by any other external service that needs to verify the contract
    with `order-service`. A test such as the following code will verify not only the
    contract between this service and `order-service`, but also the contract between
    `order-service` and other services used by that service:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，我们有很多微服务，其中大多数与一个或多个其他微服务进行通信。因此，即使您测试了单个合同，也不能确定在服务之间的通信期间所有其他合同是否按预期工作。但是，使用
    Spring Cloud Contract，您可以轻松地将所有所需的存根包含到测试类中。这使您能够验证在定义的场景中的所有合同。这需要将 `spring-cloud-starter-contract-verifier`
    和 `spring-cloud-starter-contract-stub-runner` 依赖项包含到项目中。以下类定义充当 Spring Cloud Contract
    测试类的基础，并包含其他微服务生成的存根。为 `order-service` 端点生成的存根可以被任何需要验证与 `order-service` 的合同的外部服务使用。像下面的代码一样的测试将不仅验证该服务与
    `order-service` 之间的合同，还将验证 `order-service` 与该服务使用的其他服务之间的合同：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Performance testing
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: We still have one last type of automated test to discuss. It has already been
    mentioned at the beginning of the chapter. I am, of course, talking about performance
    tests. There are some really interesting tools and frameworks that help you to
    create and run this kind of test. There is a large choice of instruments, especially
    if we are talking about HTTP API tests. I wouldn't like to discuss all of them,
    but I will talk about one framework that might be helpful. It's Gatling. Let's
    take a closer look at it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一种自动化测试类型要讨论。它已经在本章开头提到过。我当然是在谈论性能测试。有一些真正有趣的工具和框架可以帮助您创建和运行这种类型的测试。有很多选择，特别是当我们谈论
    HTTP API 测试时。我不想讨论所有这些，但我会谈一下可能有帮助的一个框架。那就是 Gatling。让我们仔细看看它。
- en: Gatling
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gatling
- en: Gatling is an open source performance testing tool written in Scala. It allows
    you to develop the tests in an easily readable and writable **domain-specific
    language** (**DSL**). It stands out from the competition by generating comprehensive,
    graphical load reports illustrating all the metrics collected during a test case.
    There are plugins available for integrating Gatling with Gradle, Maven, and Jenkins.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Gatling 是一个用 Scala 编写的开源性能测试工具。它允许您使用易于阅读和编写的**领域特定语言**（**DSL**）开发测试。它通过生成详尽的图形负载报告，展示测试用例期间收集的所有指标而脱颖而出。有可用于将
    Gatling 与 Gradle、Maven 和 Jenkins 集成的插件。
- en: Enabling Gatling
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Gatling
- en: To enable the Gatling framework for a project, we should include the `io.gatling.highcharts:gatling-charts-highcharts`
    artifact in the dependencies.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要为项目启用 Gatling 框架，我们应该在依赖项中包含 `io.gatling.highcharts:gatling-charts-highcharts`
    构件。
- en: Defining the test scenario
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义测试场景
- en: Every Gatling test suite should extend the `Simulation` class. In every test
    class, we may declare a list of scenarios using the Gatling Scala DSL. We usually
    declare the number of simultaneous threads that can call HTTP endpoints and the
    whole number of requests sent per single thread. In the Gatling nomenclature,
    the number of threads is determined by the number of users set using the `atOnceUsers`
    method. The test class should be placed in the `src/test/scala` directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Gatling 测试套件都应该扩展 `Simulation` 类。在每个测试类中，我们可以使用 Gatling Scala DSL 声明一系列场景。通常我们会声明可以调用
    HTTP 端点的同时线程数，以及每个单个线程发送的请求总数。在 Gatling 的术语中，线程数是通过使用 `atOnceUsers` 方法设置用户数来确定的。测试类应该放在
    `src/test/scala` 目录中。
- en: Assuming that we would like to test two endpoints that are exposed by `order-service`
    running 20 clients, where each of them sends 500 requests sequentially, we would
    have 20,000 requests sent in total. By sending them all in a short period of time,
    we would be able to test the performance of our application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试由`order-service`公开的两个端点，每个端点运行20个客户端，每个客户端依次发送500个请求，那么我们总共发送了20,000个请求。通过在短时间内发送所有这些请求，我们将能够测试我们的应用程序的性能。
- en: 'The following test scenario is written in Scala. Let''s take a closer look
    at it. Before running this test, I created some accounts and products by calling
    the HTTP API, exposed by `account-service` and `product-service`. Because they
    are connected to an external database, IDs are automatically generated. In order
    to provide some test data, I have copied them into the test class. Both the lists
    with the account and product IDs are passed to the test scenario as feeds. Then,
    during every iteration, the required values are randomly picked from the lists.
    Our test scenario is named `AddAndConfirmOrder`. It consists of two `exec` methods.
    The first of them creates a new order by calling the `POST /order` HTTP method.
    The order''s ID is automatically generated by the service, so it should be saved
    as an attribute. Then it can be used in the next `exec` method, which confirms
    the order by calling the `PUT /order/{id}` endpoint. The only thing that is validated
    after the test is the HTTP status:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试场景是用Scala编写的。让我们仔细看一下。在运行此测试之前，我通过调用`account-service`和`product-service`公开的HTTP
    API创建了一些帐户和产品。由于它们连接到外部数据库，ID会自动生成。为了提供一些测试数据，我将它们复制到了测试类中。带有帐户和产品ID的列表都作为feed传递给了测试场景。然后，在每次迭代期间，所需的值都是从列表中随机选择的。我们的测试场景名为`AddAndConfirmOrder`。它由两个`exec`方法组成。其中第一个方法通过调用`POST
    /order` HTTP方法创建一个新订单。订单的ID由服务自动生成，因此应该保存为属性。然后它可以在下一个`exec`方法中使用，该方法通过调用`PUT
    /order/{id}`端点确认订单。测试后唯一验证的是HTTP状态：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Running a test scenario
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试场景
- en: 'There are a few different ways of running a Gatling performance test on your
    machine. One of them is through one of the available through Gradle plugins, which
    provide support for running tests during the building of a project. You may also
    use Maven plugins or just try to run it from your IDE. If you build your project
    with Gradle, you can also define simple tasks that just run tests by launching
    the `io.gatling.app.Gatling` main class. Here''s a definition of such a task in
    the `gradle.build` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上运行Gatling性能测试有几种不同的方法。其中一种是通过可用的Gradle插件之一进行的，这些插件支持在构建项目期间运行测试。您还可以使用Maven插件，或者尝试从IDE中运行它。如果您使用Gradle构建项目，还可以定义简单的任务，通过启动`io.gatling.app.Gatling`主类来运行测试。以下是`gradle.build`文件中这样一个任务的定义：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you can run that task just by calling the `gradle loadTest` command. Of
    course, you need to have all the sample microservices, MongoDB, and `discovery-service`
    started before running those tests. By default, Gatling will print all the requests
    sent, the received responses, and the final test result, with time statistics
    and the number of success and failure API calls. If you need more detailed information,
    you should refer to the files generated after the test, which are available under
    the `build/gatling-results` directory. You might find that the HTML files there
    provide visualization in the form of diagrams and graphs. The first of them (shown
    in the following diagram) shows a summary with the total number of generated requests
    and the maximum response time broken down by percentiles. For example, you may
    see that the maximum response time in 95% of responses for the `AddOrder` API
    is 835 ms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过调用`gradle loadTest`命令来运行该任务。当然，在运行这些测试之前，您需要先启动所有示例微服务、MongoDB和`discovery-service`。默认情况下，Gatling将打印所有发送的请求、接收到的响应以及最终的测试结果，包括时间统计和成功和失败API调用的数量。如果您需要更详细的信息，您应该参考测试后生成的文件，这些文件位于`build/gatling-results`目录下。您可能会发现那里的HTML文件以图表和图形的形式提供了可视化。其中第一个（如下图所示）显示了总生成请求数和按百分位数分解的最大响应时间的摘要。例如，您可能会看到`AddOrder`API在95%的响应中的最大响应时间为835毫秒：
- en: '![](img/b0a26700-2d21-4154-a8c2-59a74a404800.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0a26700-2d21-4154-a8c2-59a74a404800.png)'
- en: 'There are also some other interesting statistics visualized. Let''s pay particular
    attention to the following two reports. The first of them shows a graph displaying
    the percentage of requests grouped by the average response time, while the second
    shows the timeline with the average response time by percentile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他有趣的统计数据可视化。让我们特别关注以下两份报告。其中第一份报告显示了按平均响应时间分组的请求百分比的图表，而第二份报告显示了按百分位数的平均响应时间的时间线：
- en: '![](img/94bc93b4-1e8f-465f-9ff6-ba27c5f7f418.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94bc93b4-1e8f-465f-9ff6-ba27c5f7f418.png)'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have introduced some frameworks that can help you effectively
    test your REST-based applications written in Java. Each of these solutions has
    been assigned to a particular type of test. I focused on tests strictly related
    to microservices, such as contract and component tests. The main goal of this
    chapter was to compare the two most popular frameworks used for contract testing,
    namely Pact and Spring Cloud Contract. Despite appearances, there are some significant
    differences between them. I tried to show you the most important similarities
    and differences based on the same sample applications that we looked at in previous
    chapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我介绍了一些可以帮助您有效测试用Java编写的基于REST的应用程序的框架。每个解决方案都被分配给特定类型的测试。我专注于与微服务严格相关的测试，如契约和组件测试。本章的主要目标是比较用于契约测试的两种最流行的框架，即Pact和Spring
    Cloud Contract。尽管外表看起来，它们之间存在一些重大差异。我试图根据前几章中我们查看的相同示例应用程序，向您展示最重要的相似之处和差异。 '
- en: Microservices are strictly related to automation. Remember that migration from
    monolith to microservices gives you an opportunity to refactor your code, and,
    moreover, to improve the quality and code coverage of your automated tests. Frameworks
    such as Mockito, Spring Test, Spring Cloud Contract, and Pact, when used together,
    give you a really powerful solution to develop tests for REST-based Java microservices.
    Automated tests are a significant part of the CI/CD process, which will be discussed
    in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与自动化密切相关。请记住，从单体架构迁移到微服务架构为您提供了重构代码的机会，而且还可以提高自动化测试的质量和代码覆盖率。当一起使用Mockito、Spring
    Test、Spring Cloud Contract和Pact等框架时，可以为基于REST的Java微服务开发测试提供非常强大的解决方案。自动化测试是CI/CD流程的重要组成部分，将在下一章中讨论。

- en: A Solution Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: As a prerequisite, you should have a basic understanding of microservices and
    software architecture style. Having a basic understanding could help you to understand
    the concepts and this book thoroughly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，您应该对微服务和软件架构风格有基本的了解。有基本的了解可以帮助您更好地理解本书中的概念。
- en: After reading this book, you could implement microservices for on-premise or
    cloud production deployment and learn the complete life-cycle from design, development,
    testing, and deployment with continuous integration and deployment. This book
    is specifically written for practical use and to ignite your mind as a solution
    architect. Your learning will help you to develop and ship products for any type
    of premise, including SaaS, PaaS, and so on. We'll primarily use the Java and
    Java-based framework tools such as Spring Boot and Jetty, and we will use Docker
    as a container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书后，您可以在本地或云生产部署中实施微服务，并学习从设计、开发、测试到持续集成和部署的完整生命周期。本书专门为实际应用而撰写，旨在激发您作为解决方案架构师的思维。您的学习将帮助您为任何类型的场景开发和交付产品，包括
    SaaS、PaaS 等。我们将主要使用 Java 和基于 Java 的框架工具，如 Spring Boot 和 Jetty，并且我们将使用 Docker 作为容器。
- en: In this chapter, you will learn the eternal existence of microservices, and
    how it has evolved. It highlights the large problems that on-premise and cloud-based
    products face and how microservices deals with it. It also explains the common
    problems encountered during the development of SaaS, enterprise, or large applications
    and their solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解微服务的永恒存在以及它是如何演变的。它突出了本地和基于云的产品所面临的重大问题，以及微服务如何处理这些问题。它还解释了在开发 SaaS、企业或大型应用程序时遇到的常见问题及其解决方案。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Microservices and a brief background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务和简要背景
- en: Monolithic architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片架构
- en: Limitation of monolithic architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片架构的局限性
- en: The benefits and flexibility that microservices offer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务提供的好处和灵活性
- en: Microservices deployment on containers such as Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器上部署微服务，如 Docker
- en: Evolution of microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的演变
- en: 'Martin Fowler explains:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒解释道：
- en: The term microservice was discussed at a workshop of software architects near
    Venice in May 2011 to describe what the participants saw as a common architectural
    style that many of them had been recently exploring. In May 2012, the same group
    decided on µServices as the most appropriate name.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务这个术语是在 2011 年 5 月威尼斯附近的软件架构师研讨会上讨论的，描述了参与者们最近探索的一个共同的架构风格。2012 年 5 月，同一组人决定
    µServices 是最合适的名称。
- en: Let's get some background on the way it has evolved over the years. Enterprise
    architecture evolved more from historic mainframe computing, through client-server
    architecture (two-tier to n-tier) to **Service-Oriented Architecture** (**SOA**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下它多年来是如何演变的。企业架构更多地是从历史悠久的大型机计算，通过客户端-服务器架构（两层到多层）演变到面向服务的架构（SOA）。
- en: The transformation from SOA to microservices is not a standard defined by an
    industry organization, but a practical approach practiced by many organizations.
    SOA eventually evolved to become microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SOA 到微服务的转变并非是由行业组织定义的标准，而是许多组织实践的实际方法。SOA 最终演变成了微服务。
- en: 'Adrian Cockcroft, a former Netflix Architect, describes it as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 阿德里安·科克罗夫特，前 Netflix 架构师，将其描述为：
- en: Fine grain SOA. So microservice is SOA with emphasis on small ephemeral components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度的 SOA。因此，微服务是强调小型短暂组件的 SOA。
- en: 'Similarly, the following quote from Mike Gancarz, a member that designed the
    X Windows system, which defines one of the paramount precepts of Unix philosophy,
    suits the microservice paradigm as well:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，来自设计 X Windows 系统的成员 Mike Gancarz 的以下引用，定义了 Unix 哲学的一个重要原则，也适用于微服务范式：
- en: Small is beautiful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 小即是美。
- en: Microservices shares many common characteristics with SOA, such as the focus
    on services and how one service decouples from another. SOA evolved around monolithic
    application integration by exposing API that was mostly **Simple Object Access
    Protocol** (**SOAP**) based. Therefore, middleware such as **Enterprise Service
    Bus** (**ESB**) is very important for SOA. Microservices are less complex, and
    even though they may use the message bus it is only used for message transport
    and it does not contain any logic. It is simply based on smart endpoints.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与 SOA 共享许多共同特征，例如对服务的关注以及一个服务如何与另一个服务解耦。SOA 围绕单片应用程序集成发展，通过暴露主要基于简单对象访问协议（SOAP）的
    API。因此，像企业服务总线（ESB）这样的中间件对于 SOA 非常重要。微服务更简单，即使它们可能使用消息总线，但它仅用于消息传输，不包含任何逻辑。它只是基于智能端点。
- en: 'Tony Pujals defined microservices beautifully:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·普哈尔斯美妙地定义了微服务：
- en: In my mental model, I think of self-contained (as in containers) lightweight
    processes communicating over HTTP, created and deployed with relatively small
    effort and ceremony, providing narrowly-focused APIs to their consumers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的心智模型中，我认为是通过 HTTP 通信的自包含（如容器）轻量级进程，相对轻松和简单地创建和部署，为其消费者提供狭义的 API。
- en: Though Tony only talks about the HTTP, event-driven microservices may use the
    different protocol for communication. You can make use of Kafka for implementing
    the event-driven microservices. Kafka uses the wire protocol, a binary protocol
    over TCP.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管托尼只谈到了 HTTP，但事件驱动的微服务可能使用不同的通信协议。您可以利用 Kafka 来实现事件驱动的微服务。Kafka 使用了二进制协议，通过
    TCP 进行通信。
- en: Monolithic architecture overview
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单片架构概述
- en: Microservices is not something new, it has been around for many years. For example,
    Stubby, a general purpose infrastructure based on **Remote** **Procedure** **Call**
    (**RPC**) was used in Google data centers in the early 2000s to connect a number
    of service with and across data centers. Its recent rise is owing to its popularity
    and visibility. Before microservices became popular, there was primarily monolithic
    architecture that was being used for developing on-premise and cloud applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务并不是什么新鲜事物，它已经存在多年。例如，Stubby是一个基于**远程过程调用**（**RPC**）的通用基础设施，在2000年代初曾被用于连接谷歌数据中心中的多个服务和跨数据中心。它最近的崛起归功于其受欢迎程度和可见性。在微服务变得流行之前，主要使用的是单体架构来开发本地和云应用程序。
- en: Monolithic architecture allows the development of different components such
    as presentation, application logic, business logic, and **Data Access Objects**
    (**DAO**), and then you either bundle them together in **Enterprise Archive**
    (**EAR**) or **Web Archive** (**WAR**), or store them in a single directory hierarchy
    (for example, Rails, NodeJS, and so on).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构允许开发不同的组件，如演示、应用程序逻辑、业务逻辑和**数据访问对象**（**DAO**），然后将它们捆绑在**企业存档**（**EAR**）或**Web存档**（**WAR**）中，或者将它们存储在单个目录层次结构中（例如，Rails、NodeJS等）。
- en: Many famous applications such as Netflix have been developed using microservices
    architecture. Moreover, eBay, Amazon, and Groupon have evolved from monolithic
    architecture to a microservices architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多著名的应用程序，如Netflix，都是使用微服务架构开发的。此外，eBay、亚马逊和Groupon已经从单体架构发展到微服务架构。
- en: Now that you have had an insight into the background and history of microservices,
    let's discuss the limitations of a traditional approach, namely monolithic application
    development, and compare how microservices would address them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对微服务的背景和历史有了了解，让我们讨论传统方法的局限性，即单体应用程序开发，并比较微服务如何解决这些问题。
- en: Limitation of monolithic architecture versus its solution with microservices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构的局限性与微服务的解决方案
- en: As we know, change is eternal. Humans always look for better solutions. This
    is how microservices became what it is today and it may evolve further in the
    future. Today, organizations are using Agile methodologies to develop applications--it
    is a fast-paced development environment and it is also on a much larger scale
    after the invention of cloud and distributed technologies. Many argue that monolithic
    architecture could also serve a similar purpose and be aligned with Agile methodologies,
    but microservices still provides a better solution to many aspects of production-ready
    applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，变革是永恒的。人类总是在寻找更好的解决方案。这就是微服务成为今天的样子的原因，它可能在未来进一步发展。今天，组织正在使用敏捷方法来开发应用程序——这是一个快节奏的开发环境，也是在云和分布式技术发明后规模更大。许多人认为，单体架构也可以发挥类似的作用，并与敏捷方法相一致，但微服务仍然为生产就绪应用程序的许多方面提供了更好的解决方案。
- en: To understand the design differences between monolithic and microservices, let's
    take an example of a restaurant table-booking application. This application may
    have many services such as customers, bookings, analytics and so on, as well as
    regular components such as presentation and database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解单体和微服务之间的设计差异，让我们以一个餐厅预订应用程序为例。这个应用程序可能有许多服务，如客户、预订、分析等，以及常规组件，如演示和数据库。
- en: We'll explore three different designs here; traditional monolithic design, monolithic
    design with services, and microservices design.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里探讨三种不同的设计；传统的单体设计、具有服务的单体设计和微服务设计。
- en: Traditional monolithic design
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的单体设计
- en: 'The following diagram explains the traditional monolithic application design.
    This design was widely used before SOA became popular:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了传统的单体应用程序设计。这种设计在SOA变得流行之前被广泛使用：
- en: '![](img/8fb71694-894b-43f1-babd-d1bebad0c078.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fb71694-894b-43f1-babd-d1bebad0c078.png)'
- en: Traditional monolithic application design
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用程序设计
- en: In traditional monolithic design, everything is bundled in the same archive
    such as **Presentation** code, **Application Logic** and **Business Logic** code,
    and **DAO** and related code that interacts with the database files or another
    source.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体设计中，所有内容都捆绑在同一个存档中，如**演示**代码、**应用程序逻辑**和**业务逻辑**代码，以及与数据库文件或其他来源交互的**DAO**和相关代码。
- en: Monolithic design with services
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体设计与服务
- en: 'After SOA, applications started being developed based on services, where each
    component provides the services to other components or external entities. The
    following diagram depicts the monolithic application with different services;
    here services are being used with a **Presentation** component. All services,
    the **Presentation** component, or any other components are bundled together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOA之后，应用程序开始基于服务进行开发，其中每个组件都向其他组件或外部实体提供服务。以下图表描述了具有不同服务的单体应用程序；这里的服务与**演示**组件一起使用。所有服务、**演示**组件或任何其他组件都被捆绑在一起：
- en: '![](img/56e1f42d-382d-47e8-82da-b8014ad4e11a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56e1f42d-382d-47e8-82da-b8014ad4e11a.png)'
- en: Services design
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务设计
- en: The following third design depicts the microservices. Here, each component represents
    autonomy. Each component could be developed, built, tested, and deployed independently.
    Here, even the application **User Interface** (**UI**) component could also be
    a client and consume the microservices. For the purpose of our example, the layer
    designed is used within µService.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下第三个设计描述了微服务。在这里，每个组件都代表自治。每个组件都可以独立开发、构建、测试和部署。在这里，甚至应用程序**用户界面**（**UI**）组件也可以是客户端，并消费微服务。在我们的示例中，设计的层被用于µService。
- en: 'The **API Gateway** provides the interface where different clients can access
    the individual services and solve the following problems:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**API网关**提供了不同客户端访问各个服务的接口，并解决了以下问题：'
- en: What do you do when you want to send different responses to different clients
    for the same service? For example, a booking service could send different responses
    to a mobile client (minimal information) and a desktop client (detailed information)
    providing different details, and something different again to a third-party client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'A response may require fetching information from two or more services:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2111f31f-e230-4141-bd2d-f52e304ca197.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: After observing all the sample design diagrams, which are very high-level designs,
    you might find out that in monolithic design, the components are bundled together
    and tightly coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: All the services are part of the same bundle. Similarly, in the second design
    figure, you can see a variant of the first figure where all services could have
    their own layers and form different APIs, but, as shown in the figure, these are
    also all bundled together.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, in microservices, design components are not bundled together and
    have loose coupling. Each service has its own layers and **DB**, and is bundled
    in a separate archive. All these deployed services provide their specific APIs
    such as Customers, Bookings, or Customer. These APIs are ready to consume. Even
    the UI is also deployed separately and designed using µService. For this reason,
    it provides various advantages over its monolithic counterpart. I would still
    remind you that there are some exceptional cases where monolithic application
    development is highly successful, such as Etsy, and peer-to-peer e-commerce web
    applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Now let us discuss the limitations you'd face while working with Monolithic
    applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: One dimension scalability
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monolithic applications that are large when scaled, scale everything as all
    the components are bundled together. For example, in the case of a restaurant
    table reservation application, even if you would like to scale the table-booking
    service, it would scale the whole application; it cannot scale the table-booking
    service separately. It does not utilize the resources optimally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this scaling is one-dimensional. Running more copies of the application
    provides the scale with increasing transaction volume. An operation team could
    adjust the number of application copies that were using a load-balancer based
    on the load in a server farm or a cloud. Each of these copies would access the
    same data source, therefore increasing the memory consumption, and the resulting
    I/O operations make caching less effective.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Microservices gives the flexibility to scale only those services where scale
    is required and it allows optimal utilization of the resources. As we mentioned
    previously, when it is needed, you can scale just the table-booking service without
    affecting any of the other components. It also allows two-dimensional scaling;
    here we can not only increase the transaction volume, but also the data volume
    using caching (Platform scale).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: A development team can then focus on the delivery and shipping of new features,
    instead of worrying about the scaling issues (Product scale).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Microservices could help you scale platform, people, and product dimensions
    as we have seen previously. People scaling here refers to an increase or decrease
    in team size depending on microservices' specific development and focus needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Microservice development using RESTful web-service development makes it scalable
    in the sense that the server-end of REST is stateless; this means that there is
    not much communication between servers, which makes it horizontally scalable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Release rollback in case of failure
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since monolithic applications are either bundled in the same archive or contained
    in a single directory, they prevent the deployment of code modularity. For example,
    many of you may have experienced the pain of delaying rolling out the whole release
    due to the failure of one feature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: To resolve these situations, microservices gives us the flexibility to rollback
    only those features that have failed. It's a very flexible and productive approach.
    For example, let's assume you are the member of an online shopping portal development
    team and want to develop an application based on microservices. You can divide
    your application based on different domains such as products, payments, cart,
    and so on, and package all these components as separate packages. Once you have
    deployed all these packages separately, these would act as single components that
    can be developed, tested, and deployed independently, and called µService.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些情况，微服务为我们提供了只回滚失败的功能的灵活性。这是一种非常灵活和高效的方法。例如，假设你是在线购物门户开发团队的成员，想要基于微服务开发应用程序。你可以根据不同的领域（如产品、支付、购物车等）划分你的应用程序，并将所有这些组件打包为单独的包。一旦你单独部署了所有这些包，它们将作为单独的组件进行开发、测试和部署，并被称为µService。
- en: Now, let's see how that helps you. Let's say that after a production release
    launching new features, enhancements, and bug fixes, you find flaws in the payment
    service that need an immediate fix. Since the architecture you have used is based
    on microservices, you can rollback the payment service instead of rolling back
    the whole release, if your application architecture allows, or apply the fixes
    to the microservices payment service without affecting the other services. This
    not only allows you to handle failure properly, but it also helps to deliver the
    features/fixes swiftly to a customer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何帮助你。假设在生产发布新功能、增强和错误修复后，你发现支付服务存在缺陷需要立即修复。由于你使用的架构是基于微服务的，你可以回滚支付服务而不是整个发布，如果你的应用程序架构允许的话，或者在不影响其他服务的情况下对微服务支付服务应用修复。这不仅使你能够正确处理故障，还有助于快速向客户交付功能/修复。
- en: Problems in adopting new technologies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用新技术的问题
- en: Monolithic applications are mostly developed and enhanced based on the technologies
    primarily used during the initial development of a project or a product. It makes
    it very difficult to introduce new technology at a later stage of the development
    or once the product is in a mature state (for example, after a few years). In
    addition, different modules in the same project, that depend on different versions
    of the same library, make this more challenging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单片应用程序大多是基于最初开发项目或产品时主要使用的技术进行开发和增强的。这使得在开发的后期阶段或产品成熟后（例如几年后）引入新技术变得非常困难。此外，同一项目中依赖于同一库的不同模块使用不同版本，使得这更具挑战性。
- en: Technology is improving year on year. For example, your system might be designed
    in Java and then, a few years later, you want to develop a new service in Ruby
    on Rails or NodeJS because of a business need or to utilize the advantages of
    new technologies. It would be very difficult to utilize the new technology in
    an existing monolithic application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 技术每年都在不断改进。例如，你的系统可能是用Java设计的，然后几年后，由于业务需要或利用新技术的优势，你想要用Ruby on Rails或NodeJS开发新的服务。在现有的单片应用程序中利用新技术将会非常困难。
- en: It is not just about code-level integration, but also about testing and deployment.
    It is possible to adopt a new technology by re-writing the entire application,
    but it is time-consuming and a risky thing to do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是代码级的集成，还包括测试和部署。可以通过重写整个应用程序来采用新技术，但这是耗时且具有风险的做法。
- en: On the other hand, because of its component-based development and design, microservices
    gives us the flexibility to use any technology, new or old, for its development.
    It does not restrict you to using specific technologies, it gives a new paradigm
    to your development and engineering activities. You can use Ruby on Rails, NodeJS,
    or any other technology at any time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于其基于组件的开发和设计，微服务为我们提供了使用任何技术（新旧）进行开发的灵活性。它不限制你使用特定的技术，它为你的开发和工程活动提供了新的范例。你可以随时使用Ruby
    on Rails、NodeJS或任何其他技术。
- en: So, how is it achieved? Well, it's very simple. Microservices-based application
    code does not bundle into a single archive and is not stored in a single directory.
    Each µService has its own archive and is deployed separately. A new service could
    be developed in an isolated environment and could be tested and deployed without
    any technical issues. As you know, microservices also owns its own separate processes;
    it serves its purpose without any conflict such as shared resources with tight
    coupling, and processes remain independent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何实现的呢？嗯，很简单。基于微服务的应用程序代码不会捆绑成单个存档，也不会存储在单个目录中。每个µService都有自己的存档，并且是单独部署的。新服务可以在隔离的环境中开发，并且可以在没有任何技术问题的情况下进行测试和部署。正如你所知，微服务也拥有自己独立的进程；它可以在没有任何冲突的情况下发挥作用，例如与紧密耦合的共享资源，进程保持独立。
- en: Since a microservice is by definition a small, self-contained function, it provides
    a low-risk opportunity to try a new technology. That is definitely not the case
    where monolithic systems are concerned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务在定义上是一个小型、自包含的功能，它为尝试新技术提供了低风险的机会。而在单片系统中，情况显然不是这样。
- en: You can also make your microservice available as open source software so it
    can be used by others, and if required it may interoperate with a closed source
    proprietary one, which is not possible with monolithic applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将你的微服务作为开源软件提供给他人使用，如果需要，它可以与闭源专有软件进行互操作，而这在单片应用程序中是不可能的。
- en: Alignment with Agile practices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与敏捷实践的一致性
- en: 'There is no question that monolithic applications can be developed using Agile
    practices, and these are being developed. **Continuous Integration (CI)** and
    **Continuous Deployment (CD)** could be used, but the question is—does it use
    Agile practices effectively? Let''s examine the following points:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，可以使用敏捷实践来开发单片应用程序，并且正在开发中。可以使用**持续集成（CI）**和**持续部署（CD）**，但问题是——它是否有效地使用了敏捷实践？让我们来看看以下几点：
- en: For example, when there is a high probability of having stories dependent on
    each other, and there could be various scenarios, a story could not be taken up
    until the dependent story is complete
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当有很高的可能性有相互依赖的故事，并且可能会有各种情况，一个故事在依赖故事完成之前可能无法被接受
- en: The build takes more time as the code size increases
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码规模的增加，构建需要更多时间
- en: The frequent deployment of a large monolithic application is a difficult task
    to achieve
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁部署大型单片应用是一项艰巨的任务
- en: You would have to redeploy the whole application even if you updated a single
    component
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使只更新了一个组件，您也必须重新部署整个应用程序
- en: Redeployment may cause problems to already running components, for example,
    a job scheduler may change whether components impact it or not
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署可能会给已经运行的组件带来问题，例如，作业调度器可能会改变组件是否会受到影响
- en: The risk of redeployment may increase if a single changed component does not
    work properly or if it needs more fixes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署的风险可能会增加，如果单个更改的组件无法正常工作，或者如果它需要更多修复
- en: UI developers always need more redeployment, which is quite risky and time-consuming
    for large monolithic applications
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI开发人员总是需要更多的重新部署，这对于大型单片应用来说是相当危险和耗时的
- en: The preceding issues can be tackled very easily by microservices, for example,
    UI developers may have their own UI component that can be developed, built, tested,
    and deployed separately. Similarly, other microservices might also be deployable
    independently and, because of their autonomous characteristics, the risk of system
    failure is reduced. Another advantage for development purposes is that UI developers
    can make use of the JSON object and mock Ajax calls to develop the UI, which can
    be taken up in an isolated manner. After development completes, developers can
    consume the actual APIs and test the functionality. To summarize, you could say
    that microservices development is swift and it aligns well with the incremental
    needs of businesses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以很容易地解决上述问题，例如，UI开发人员可以拥有自己的UI组件，可以单独开发、构建、测试和部署。同样，其他微服务也可以独立部署，并且由于其自治特性，系统故障的风险降低了。另一个开发目的的优势是，UI开发人员可以利用JSON对象和模拟Ajax调用来开发UI，这可以以隔离的方式进行。开发完成后，开发人员可以使用实际的API并测试功能。总之，可以说微服务开发是迅速的，并且与业务的增量需求很好地契合。
- en: Ease of development – could be done better
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发的便利性-可以做得更好
- en: Generally, large monolithic application code is the toughest to understand for
    developers, and it takes time before a new developer can become productive. Even
    loading the large monolithic application into IDE is troublesome, and it makes
    IDE slower and the developer less productive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大型单片应用的代码对开发人员来说是最难理解的，新开发人员在成为高效之前需要一些时间。甚至将大型单片应用加载到IDE中都很麻烦，这会使IDE变慢，开发人员的效率降低。
- en: A change in a large monolithic application is difficult to implement and takes
    more time due to a large code base, and there will be a high risk of bugs if impact
    analysis is not done properly and thoroughly. Therefore, it becomes a prerequisite
    for developers to do thorough impact analysis before implementing changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大型单片应用的变更由于代码基础庞大，实施起来困难且需要更多时间，如果影响分析没有得到适当和彻底的执行，将会有很高的错误风险。因此，开发人员在实施变更之前进行彻底的影响分析是必要的。
- en: In monolithic applications, dependencies build up over time as all components
    are bundled together. Therefore, the risk associated with code change rises exponentially
    as code changes (number of modified lines of code) grows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在单片应用中，随着所有组件被捆绑在一起，依赖关系会随着时间的推移而积累。因此，随着代码变更（修改的代码行数）的增加，与代码变更相关的风险呈指数级增长。
- en: When a code base is huge and more than 100 developers are working on it, it
    becomes very difficult to build products and implement new features because of
    the previously mentioned reason. You need to make sure that everything is in place,
    and that everything is coordinated. A well-designed and documented API helps a
    lot in such cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码基数庞大，有100多名开发人员在上面工作时，由于前面提到的原因，构建产品和实施新功能变得非常困难。您需要确保一切就绪，并且一切协调一致。在这种情况下，设计良好且有文档记录的API在很大程度上有所帮助。
- en: Netflix, the on-demand internet streaming provider, had problems getting their
    application developed, with around 100 people working on it. Then, they used a
    cloud and broke up the application into separate pieces. These ended up being
    microservices. Microservices grew from the desire for speed and agility and to
    deploy teams independently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点播互联网流媒体提供商Netflix在开发其应用程序时遇到了问题，大约有100人在开发。然后，他们使用了云，并将应用程序分解为单独的部分。这些最终成为了微服务。微服务的发展源于对速度和灵活性的渴望，以及独立部署团队的需求。
- en: Micro-components are made loosely coupled thanks to their exposed API, which
    can be continuously integration tested. With microservices' continuous release
    cycle, changes are small and developers can rapidly exploit them with a regression
    test, then go over them and fix the eventual defects found, reducing the risk
    of a deployment. This results in higher velocity with a lower associated risk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于暴露的API，微组件之间的耦合度较低，可以进行持续集成测试。通过微服务的持续发布周期，变更是小的，开发人员可以迅速利用它们进行回归测试，然后检查并修复发现的缺陷，从而降低部署风险。这导致了更高的速度和更低的相关风险。
- en: Owing to the separation of functionality and single responsibility principle,
    microservices makes teams very productive. You can find a number of examples online
    where large projects have been developed with minimum team sizes such as eight
    to ten developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能的分离和单一责任原则，微服务使团队非常高效。您可以在网上找到许多例子，大型项目只需要八到十名开发人员就可以完成
- en: Developers can have better focus with smaller code and resultant better feature
    implementation that leads to a higher empathic relationship with the users of
    the product. This conduces better motivation and clarity in feature implementation.
    An empathic relationship with users allows a shorter feedback loop and better
    and speedy prioritization of the feature pipeline. A shorter feedback loop also
    makes defect detection faster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以更好地专注于更小的代码，从而实现更好的功能实现，从而与产品用户建立更高的共鸣关系。这有助于更好的动机和功能实现的清晰度。与用户的共鸣关系可以缩短反馈周期，并更快速地对功能管道进行优先排序。更短的反馈周期也使缺陷检测更快。
- en: Each microservices team works independently and new features or ideas can be
    implemented without being coordinated with larger audiences. The implementation
    of end-point failures handling is also easily achieved in the microservices design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务团队都可以独立工作，新功能或想法可以在不与更大的观众协调的情况下实现。在微服务设计中，端点故障处理的实现也很容易实现。
- en: Recently, at one of the conferences, a team demonstrated how they had developed
    a microservices-based transport-tracking application including iOS and Android
    applications within 10 weeks, which had Uber-type tracking features. A big consulting
    firm gave a seven months estimation for the same application to its client. It
    shows how microservices is aligned with Agile methodologies and CI/CD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，在一次会议上，一个团队展示了他们如何在10周内开发了一个基于微服务的运输跟踪应用，包括iOS和Android应用程序，具有类似Uber的跟踪功能。一家大型咨询公司为同一应用程序给出了七个月的估计时间。这表明微服务与敏捷方法和CI/CD是一致的。
- en: Microservices build pipeline
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务构建流水线
- en: Microservices could also be built and tested using the popular CI/CD tools such
    as Jenkins, TeamCity, and so on. It is very similar to how a build is done in
    a monolithic application. In microservices, each microservice is treated like
    a small application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务也可以使用诸如Jenkins、TeamCity等流行的CI/CD工具进行构建和测试。这与单片应用程序的构建方式非常相似。在微服务中，每个微服务都被视为一个小型应用程序。
- en: 'For example, once you commit the code in the repository (SCM), CI/CD tools
    trigger the build process:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦您在代码库（SCM）中提交了代码，CI/CD工具会触发构建过程：
- en: Cleaning code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码
- en: Code compilation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编译
- en: Unit test execution
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试执行
- en: Contract/Acceptance test execution
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同/验收测试执行
- en: Building the application archives/container images
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序存档/容器映像
- en: Publishing the archives/container images to repository management
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存档/容器映像发布到存储库管理中
- en: Deployment on various Delivery environments such as Dev, QA, Stage, and so on
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种交付环境上进行部署，如开发、QA、阶段等
- en: Integration and Functional test execution
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成和功能测试执行
- en: Any other steps
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他步骤
- en: Then, release-build triggers that change the SNAPSHOT or RELEASE version in
    `pom.xml` (in case of Maven) build the artifacts as described in the normal build
    trigger. Publish the artifacts to the artifacts repository. Tag this version in
    the repository. If you use the container image then build the container image
    as a part of the build.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发布构建会触发更改`pom.xml`中的SNAPSHOT或RELEASE版本（如果是Maven的话），构建与正常构建触发器中描述的构件。将构件发布到构件库。在代码库中标记此版本。如果使用容器映像，则将容器映像作为构建的一部分构建。
- en: Deployment using a container such as Docker
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker等容器进行部署
- en: Owing to the design of microservices, you need to have an environment that provides
    flexibility, agility, and smoothness for continuous integration and deployment
    as well as for shipment. Microservices deployments need speed, isolation management,
    and an Agile life-cycle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的设计，您需要一个提供灵活性、敏捷性和平稳性的环境，以进行持续集成和部署以及运输。微服务部署需要速度、隔离管理和敏捷的生命周期。
- en: Products and software can also be shipped using the concept of an intermodal-container
    model. An intermodal-container is a large standardized container, designed for
    intermodal freight transport. It allows cargo to use different modes of transport—truck,
    rail, or ship without unloading and reloading. This is an efficient and secure
    way of storing and transporting stuff. It resolves the problem of shipping, which
    previously had been a time consuming, labor-intensive process, and repeated handling
    often broke fragile goods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 产品和软件也可以使用联运集装箱模型进行运输。联运集装箱是一种大型标准化集装箱，专为联运货物运输而设计。它允许货物使用不同的运输方式——卡车、铁路或船只，而无需卸载和重新装载。这是一种高效和安全的存储和运输方式。它解决了以前耗时、劳动密集型的运输问题，而且重复处理经常会破坏易碎货物。
- en: Shipping containers encapsulate their content. Similarly, software containers
    are starting to be used to encapsulate their contents (products, applications,
    dependencies, and so on).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 集装箱封装其内容。类似地，软件容器开始被用来封装其内容（产品、应用程序、依赖等）。
- en: Previously, **Virtual Machines** (**VMs**) were used to create software images
    that could be deployed where needed. Later, containers such as Docker became more
    popular as they were compatible with both traditional virtual stations systems
    and cloud environments. For example, it is not practical to deploy more than a
    couple of VMs on a developer's laptop. Building and booting a VM is usually I/O
    intensive and consequently slow.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，**虚拟机**（**VMs**）被用来创建可以根据需要部署的软件映像。后来，像Docker这样的容器变得更受欢迎，因为它们与传统的虚拟站系统和云环境兼容。例如，在开发人员的笔记本电脑上部署超过两个VM是不现实的。构建和启动VM通常需要大量I/O操作，因此速度较慢。
- en: Containers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: A container (for example, Linux containers) provides a lightweight runtime environment
    consisting of the core features of virtual machines and the isolated services
    of operating systems. This makes the packaging and execution of microservices
    easy and smooth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 容器（例如Linux容器）提供了一个轻量级的运行时环境，包括虚拟机的核心功能和操作系统的隔离服务。这使得微服务的打包和执行变得简单和顺畅。
- en: As the following diagram shows, a container runs as an application (microservice)
    within the **Operating** **System**. The OS sits on top of the hardware and each
    OS could have multiple containers, with a container running the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，容器作为应用程序（微服务）在**操作系统**中运行。操作系统位于硬件之上，每个操作系统可以有多个容器，其中一个容器运行应用程序。
- en: 'A container makes use of an operating system''s kernel interfaces, such as
    **cnames** and **namespaces**, that allow multiple containers to share the same
    kernel while running in complete isolation to one another. This gives the advantage
    of not having to complete an OS installation for each usage; the result being
    that it removes the overhead. It also makes optimal use of the **Hardware**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 容器利用操作系统的内核接口，如**cnames**和**namespaces**，允许多个容器在完全隔离的情况下共享同一个内核。这使得不必为每次使用都完成一次操作系统安装，从而减少了开销。它还充分利用了**硬件**：
- en: '![](img/a8adb807-2da8-4607-a466-8fe5b9cf4a0f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8adb807-2da8-4607-a466-8fe5b9cf4a0f.png)'
- en: Layer diagram for containers
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的层次结构图。
- en: Docker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Container technology is one of the fastest growing technologies today, and Docker
    leads this segment. Docker is an open source project and it was launched in 2013\.
    10,000 developers tried it after its interactive tutorial launched in August 2013\.
    It was downloaded 2.75 million times by the time of the launch of its 1.0 release
    in June 2013\. Many large companies have signed the partnership agreement with
    Docker, such as Microsoft, Red Hat, HP, OpenStack, and service providers such
    as Amazon Web Services, IBM, and Google.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术是当今增长最快的技术之一，而Docker在这一领域处于领先地位。Docker是一个开源项目，于2013年推出。在2013年8月推出交互式教程后，有1万名开发人员尝试了它。到2013年6月1.0版本发布时，它已被下载了275万次。许多大公司已与Docker签署了合作协议，如微软、红帽、惠普、OpenStack以及亚马逊网络服务、IBM和谷歌等服务提供商。
- en: As we mentioned earlier, Docker also makes use of the Linux kernel features,
    such as cgroups and namespaces, to ensure resource isolation and packaging of
    the application with its dependencies. This packaging of dependencies enables
    an application to run as expected across different Linux operating systems/distributions,
    supporting a level of portability. Furthermore, this portability allows developers
    to develop an application in any language and then easily deploy it from a laptop
    to a test or production server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Docker还利用Linux内核功能，如cgroups和namespaces，以确保资源隔离和应用程序及其依赖项的打包。这种依赖项的打包使应用程序能够在不同的Linux操作系统/发行版上如预期地运行，支持一定程度的可移植性。此外，这种可移植性允许开发人员使用任何语言开发应用程序，然后轻松地从笔记本电脑部署到测试或生产服务器上。
- en: Docker runs natively on Linux. However, you can also run Docker on Windows and
    MacOS using VirtualBox and boot2docker.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在Linux上原生运行。但是，您也可以使用VirtualBox和boot2docker在Windows和MacOS上运行Docker。
- en: Containers are comprised of just the application and its dependencies including
    the basic operating system. This makes it lightweight and efficient in terms of
    resource utilization. Developers and system administrators get interested in container's
    portability and efficient resource utilization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器仅由应用程序及其依赖项组成，包括基本操作系统。这使得它在资源利用方面轻量高效。开发人员和系统管理员对容器的可移植性和高效资源利用感兴趣。
- en: Everything in a Docker container executes natively on the host and uses the
    host kernel directly. Each container has its own user namespace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器中的所有内容都在主机上以本机方式执行，并直接使用主机内核。每个容器都有自己的用户命名空间。
- en: Docker's architecture
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的架构
- en: 'As specified on Docker documentation, Docker architecture uses client-server
    architecture. As shown in the following figure (sourced from Docker''s website:
    [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)),
    the Docker client is primarily a user interface that is used by an end user; clients
    communicate back and forth with a Docker daemon. The Docker daemon does the heavy
    lifting of the building, running, and distributing of your Docker containers.
    The Docker client and the daemon can run on the same system or different machines.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker文档，Docker架构使用客户端-服务器架构。如下图所示（来源自Docker网站：[https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)），Docker客户端主要是用户界面，由最终用户使用；客户端与Docker守护程序来回通信。Docker守护程序负责构建、运行和分发Docker容器。Docker客户端和守护程序可以在同一系统上或不同的机器上运行。
- en: The Docker client and daemon communicate via sockets or through a RESTful API.
    Docker registers are public or private Docker image repositories from which you
    upload or download images, for example, Docker Hub ([hub.docker.com](https://hub.docker.com/))
    is a public Docker registry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端和守护程序通过套接字或RESTful API进行通信。Docker注册表是公共或私有的Docker镜像仓库，您可以从中上传或下载镜像，例如Docker
    Hub（[hub.docker.com](https://hub.docker.com/)）是一个公共的Docker注册表。
- en: '![](img/0ad926bf-861d-4c67-9004-46caa8f4fe7f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad926bf-861d-4c67-9004-46caa8f4fe7f.png)'
- en: Docker's architecture
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的架构
- en: 'The primary components of Docker are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的主要组件包括：
- en: '**Docker image**: A Docker image is a read-only template. For example, an image
    could contain an Ubuntu operating system with Apache web server and your web application
    installed. Docker images are a build component of Docker and images are used to
    create Docker containers. Docker provides a simple way to build new images or
    update existing images. You can also use images created by others and/or extend
    them.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像是一个只读模板。例如，一个镜像可以包含安装了Ubuntu操作系统、Apache Web服务器和您的Web应用程序。Docker镜像是Docker的构建组件，用于创建Docker容器。Docker提供了一种简单的方法来构建新镜像或更新现有镜像。您还可以使用其他人创建的镜像并/或扩展它们。'
- en: '**Docker container**: A Docker container is created from a Docker image. Docker
    works so that the container can only see its own processes, and have its own filesystem
    layered onto a host filesystem and a networking stack, which pipes to the host-networking
    stack. Docker **Containers** can be run, started, stopped, moved, or deleted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：Docker容器是从Docker镜像创建的。Docker工作原理是容器只能看到自己的进程，并且在主机文件系统上有自己的文件系统层和网络堆栈，该堆栈与主机网络堆栈相连。Docker
    **容器**可以运行、启动、停止、移动或删除。'
- en: Deployment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'Microservices deployment with Docker deals with three parts:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker进行微服务部署涉及三个部分：
- en: Application packaging, for example, JAR
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序打包，例如，JAR
- en: Building Docker image with a JAR and dependencies using a Docker instruction
    file, the Dockerfile, and command `docker build`. It helps to repeatedly create
    the image
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker指令文件Dockerfile和命令`docker build`构建带有JAR和依赖项的Docker镜像。它有助于重复创建镜像。
- en: Docker container execution from this newly built image using command `docker
    run`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令`docker run`从这个新构建的镜像中执行Docker容器
- en: 'The preceding information will help you to understand the basics of Docker.
    You will learn more about Docker and its practical usage in [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing*. Source and reference, refer to: [https://docs.docker.com](https://docs.docker.com).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息将帮助您了解Docker的基础知识。您将在[第5章](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml)中更多地了解Docker及其在实际中的用途，*部署和测试*。源和参考，请参阅：[https://docs.docker.com](https://docs.docker.com)。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned or recapped the high-level design of large
    software projects, from traditional monolithic to microservices applications.
    You were also introduced to a brief history of microservices, the limitation of
    monolithic applications, and the benefits and flexibility that microservices offer.
    I hope this chapter helped you to understand the common problems faced in a production
    environment by monolithic applications and how microservices can resolve such
    problem. You were also introduced to lightweight and efficient Docker containers
    and saw how containerization is an excellent way to simplify microservices deployment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习或复习了大型软件项目的高级设计，从传统的单片应用到微服务应用。您还简要介绍了微服务的历史、单片应用的局限性以及微服务提供的好处和灵活性。我希望这一章能帮助您了解单片应用在生产环境中面临的常见问题，以及微服务如何解决这些问题。您还了解了轻量高效的Docker容器，并了解了容器化是简化微服务部署的一种极好方式。
- en: In the next chapter, you will get to know about setting up the development environment
    from IDE, and other development tools, to different libraries. We will deal with
    creating basic projects and setting up Spring Boot configuration to build and
    develop our first microservice. We will be using Java 9 as the language and Spring
    Boot for our project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何从IDE和其他开发工具到不同的库设置开发环境。我们将处理创建基本项目并设置Spring Boot配置来构建和开发我们的第一个微服务。我们将使用Java
    9作为语言，Spring Boot作为项目。

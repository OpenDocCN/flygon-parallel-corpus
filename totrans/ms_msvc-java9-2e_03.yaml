- en: Domain-Driven Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter sets the tone for the rest of the chapters by referring to one
    sample project. The sample project will be used to explain different microservices
    concepts from here onward. This chapter uses this sample project to drive through
    different combinations of functional and domain services, or applications to explain
    **domain-driven design** (**DDD**). It will help you to learn the fundamentals
    of DDD and its practical usage. You will also learn the concepts of designing
    domain models using REST services.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design an application using DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample domain model design based on DDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good software design is as much the key to the success of a product or services
    as the functionalities offered by it. It carries equal weight to the success of
    product; for example, `Amazon.com` provides the shopping platform, but its architecture
    design makes it different from other similar sites and contributes to its success.
    It shows how important a software or architecture design is for the success of
    a product/service. DDD is one of the software design practices, and we'll explore
    it with various theories and practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is a key design practice that helps to design the microservices of the product
    that you are developing. Therefore, we'll first explore DDD before jumping into
    microservices development. After studying this chapter, you will understand the
    importance of DDD for microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enterprise, or cloud application, solves business problems and other real-world
    problems. These problems cannot be resolved without knowledge of the domain. For
    example, you cannot provide a software solution for a financial system such as
    online stock trading if you don't understand the stock exchanges and their functioning.
    Therefore, having domain knowledge is a must for solving problems. Now, if you
    want to offer a solution using software or applications, you need to design it
    with the help of domain knowledge. When we combine the domain and software design,
    it offers a software design methodology known as DDD.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop software to implement real-world scenarios offering the functionalities
    of a domain, we create a model of the domain. A **model** is an abstraction, or
    a blueprint, of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric Evans coined the term DDD in his book *Domain-Driven Design: Tackling
    Complexity in the Heart of Software*, published in 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing this model is not rocket science, but it does take a lot of effort,
    refining, and input from domain experts. It is the collective job of software
    designers, domain experts, and developers. They organize information, divide it
    into smaller parts, group them logically, and create modules. Each module can
    be taken up individually, and can be divided using a similar approach. This process
    can be followed until we reach the unit level, or when we cannot divide it any
    further. A complex project may have more of such iterations; similarly, a simple
    project could have just a single iteration of it.
  prefs: []
  type: TYPE_NORMAL
- en: Once a model is defined and well documented, it can move onto the next stage
    - code design. So, here we have a **software design**—a domain model and code
    design, and code implementation of the domain model. The domain model provides
    a high level of the architecture of a solution (software/application), and the
    code implementation gives the domain model a life, as a working model.
  prefs: []
  type: TYPE_NORMAL
- en: DDD makes design and development work together. It provides the ability to develop
    software continuously, while keeping the design up to date based on feedback received
    from the development. It solves one of the limitations offered by Agile and Waterfall
    methodologies, making software maintainable, including design and code, as well
    as keeping application minimum viable.
  prefs: []
  type: TYPE_NORMAL
- en: Design-driven development involves a developer from the initial stage, and all
    meetings where software designers discuss the domain with domain experts in the
    modeling process. It gives developers the right platform to understand the domain,
    and provides the opportunity to share early feedback of the domain model implementation.
    It removes the bottleneck that appears in later stages when stockholders wait
    for deliverables.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand domain-driven design, we can broadly categorize these three concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language and unified model language (UML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multilayer architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artifacts (components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections explain the usage and importance of ubiquitous language
    and multilayer architecture. There will also be an explanation of the different
    artifacts to be used in the model-driven design.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ubiquitous language** is a common language to communicate within a project.
    As we have seen, designing a model is the collective effort of software designers,
    domain experts, and developers; therefore, it requires a common language to communicate
    with. DDD makes it necessary to use ubiquitous language. Domain models use ubiquitous
    language in their diagrams, descriptions, presentations, speeches, and meetings.
    It removes the misunderstanding, misinterpretation, and communication gap among
    them. Therefore, it must be included in all diagrams, description, presentations,
    meetings, and so on—in short, in everything.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** (**UML**) is widely used and very popular when
    creating models. It also has a few limitations; for example, when you have thousands
    of classes drawn from a paper, it''s difficult to represent class relationships
    and simultaneously understand their abstraction while taking a meaning from it.
    Also, UML diagrams do not represent the concepts of a model and what objects are
    supposed to do. Therefore, UML should always be used with other documents, code,
    or any other reference for effective communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to communicate the domain model include the use of documents, code,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Multilayered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multilayered architecture is a common solution for DDD. It contains four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer or **User Interface** (**UI**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Domain layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Infrastructure layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb42878f-3e3d-4baa-a278-53c9d626d2d3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that only the **Domain** layer is responsible for the domain
    model, and others are related to other components such as UI, application logic,
    and so on. This layered architecture is very important. It keeps domain-related
    code separate from other layers.
  prefs: []
  type: TYPE_NORMAL
- en: In this multilayered architecture, each layer contains its respective code,
    and it helps to achieve loose coupling and avoids mixing code from different layers.
    It also helps the product/service's long-term maintainability and the ease of
    enhancements, as the change of one-layer code does not impact on other components
    if the change is intended for the respective layer only. Each layer can be switched
    with another implementation easily with multi-tier architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer represents the UI, and provides the user interface for the interaction
    and information display. This layer could be a web application, mobile application,
    or a third-party application consuming your services.
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer is responsible for application logic. It maintains and coordinates
    the overall flow of the product/service. It does not contain business logic or
    UI. It may hold the state of application objects, like tasks in progress. For
    example, your product **REST services** would be part of this application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Domain layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain layer is a very important layer, as it contains the domain information
    and business logic. It holds the state of the business object. It persists the
    state of the business objects, and communicates these persisted states to the
    infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This layer provides support to all the other layers and is responsible for communication
    among the other layers. It contains the supporting libraries that are used by
    the other layers. It also implements the persistence of business objects.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the interaction of the different layers, let us use an example
    of table booking at a restaurant. The end user places a request for a table booking
    using UI. The UI passes the request to the application layer. The application
    layer fetches the domain objects, such as the restaurant, the table, a date, and
    so on, from the domain layer. The domain layer fetches these existing persisted
    objects from the infrastructure, and invokes relevant methods to make the booking
    and persist them back to the infrastructure layer. Once domain objects are persisted,
    the application layer shows the booking confirmation to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Artifacts of domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are seven different artifacts used in DDD to express, create, and retrieve
    domain models:'
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities are certain types of objects that are identifiable and remain the same
    throughout the states of the products/services. These objects are not identified
    by their attributes, but by their identity and thread of continuity. These type
    of objects are known as **entities**.
  prefs: []
  type: TYPE_NORMAL
- en: It sounds pretty simple, but it carries complexity. You need to understand how
    we can define the entities. Let's take an example of a table booking system, where
    we have a `restaurant` class with attributes such as restaurant name, address,
    phone number, establishment data, and so on. We can take two instances of the
    `restaurant` class that are not identifiable using the restaurant name, as there
    could be other restaurants with the same name. Similarly, if we go by any other
    single attribute, we will not find any attributes that can singularly identify
    a unique restaurant. If two restaurants have all the same attribute values, they
    are therefore the same and are interchangeable with each other. Still, they are
    not the same entities, as both have different references (memory addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, let's take a class of US citizens. Each citizen has his or her own
    social security number. This number is not only unique, but remains unchanged
    throughout the life of the citizen and assures continuity. This `citizen` object
    would exist in the memory, would be serialized, and would be removed from the
    memory and stored in the database. It even exists after the person is deceased.
    It will be kept in the system for as long as the system exists. A citizen's social
    security number remains the same irrespective of its representation.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, creating entities in a product means creating an **identity**. So,
    now give an identity to any restaurant in the previous example, then either use
    a combination of attributes such as restaurant name, establishment date, and street,
    or add an identifier such as `restaurant_id` to identify it. The basic rule is
    that two identifiers cannot be the same. Therefore, when we introduce an identifier
    for an entity, we need to be sure of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to create a unique identity for objects, described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **primary key** in a table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an **automated generated ID** by a domain module. A domain program generates
    the identifier and assigns it to objects that are being persisted among different
    layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few real-life objects carry **user-defined identifiers** themselves. For example,
    each country has its own country codes for dialing ISD calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite key.** This is a combination of attributes that can also be used
    for creating an identifier, as explained for the preceding `restaurant` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Entities are very important for domain models. Therefore, they should be defined
    from the initial stage of the modeling process*.'
  prefs: []
  type: TYPE_NORMAL
- en: When an object can be identified by its identifier and not by its attributes,
    a class representing these objects should have a simple definition, and care should
    be taken with the life cycle continuity and identity. It's imperative to identify
    objects in this class that have the same attribute values. A defined system should
    return a unique result for each object if queried. Designers should ensure that
    the model defines what it means to be the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Value objects (VOs)** simplify the design. Entities have traits such as identity,
    a thread of continuity, and attributes that do not define their identity. In contrast
    to entities, value objects have only attributes and no conceptual identity. A
    best practice is to keep value objects as immutable objects. If possible, you
    should even keep entity objects immutable too.'
  prefs: []
  type: TYPE_NORMAL
- en: Entity concepts may bias you to keep all objects as entities, as a uniquely
    identifiable object in the memory or database with life cycle continuity, but
    there has to be one instance for each object. Now, let's say you are creating
    customers as entity objects. Each customer object would represent the restaurant
    guest, and this cannot be used for booking orders for other guests. This may create
    millions of customer entity objects in the memory if millions of customers are
    using the system. Not only are there millions of uniquely identifiable objects
    that exist in the system, but each object is being tracked. Tracking as well as
    creating an identity is complex. A highly credible system is required to create
    and track these objects, which is not only very complex, but also resource heavy.
    It may result in system performance degradation. Therefore, it is important to
    use value objects instead of using entities. The reasons are explained in the
    next few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Applications don't always need to have to be trackable and have an identifiable
    customer object. There are cases when you just need to have some or all attributes
    of the domain element. These are the cases when value objects can be used by the
    application. It makes things simple and improves the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects can easily be created and destroyed, owing to the absence of identity.
    This simplifies the design—it makes value objects available for garbage collection
    if no other object has referenced them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the value object's immutability. Value objects should be designed
    and coded as immutable. Once they are created, they should never be modified during
    their life-cycle. If you need a different value of the VO, or any of its objects,
    then simply create a new value object, but don't modify the original value object.
    Here, immutability carries all the significance from **object-oriented programming**
    (**OOP**). A value object can be shared and used without impacting on its integrity
    if, and only if, it is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: FAQs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can a value object contain another value object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, it can
  prefs: []
  type: TYPE_NORMAL
- en: Can a value object refer to another value object or entity?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, it can
  prefs: []
  type: TYPE_NORMAL
- en: Can I create a value object using the attributes of different value objects
    or entities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, you can
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating the domain model, you may encounter various situations where
    behavior may not be related to any object specifically. These behaviors can be
    accommodated in **service objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Service objects are part of domain layer that does not have any internal state.
    The sole purpose of service objects is to provide behavior to the domain that
    does not belong to a single entity or value object.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language helps you to identify different objects, identities, or
    value objects with different attributes and behaviors during the process of domain
    modeling. During the course of creating the domain model, you may find different
    behaviors or methods that do not belong to any specific object. Such behaviors
    are important, and so cannot be neglected. Neither can you add them to entities
    or value objects. It would spoil the object to add behavior that does not belong
    to it. Keep in mind, that behavior may impact on various objects. The use of object-oriented
    programming makes it possible to attach to some objects; this is known as a **service**.
  prefs: []
  type: TYPE_NORMAL
- en: Services are common in technical frameworks. These are also used in domain layers
    in DDD. A service object does not have any internal state; the only purpose of
    it is to provide a behavior to the domain. Service objects provide behaviors that
    cannot be related to specific entities or value objects. Service objects may provide
    one or more related behaviors to one or more entities or value objects. It is
    a practice to define the services explicitly in the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating the services, you need to tick all of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Service objects' behavior performs on entities and value objects, but it does
    not belong to entities or value objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service objects' behavior state is not maintained, and hence, they are stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services are part of the domain model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services may also exist in other layers. It is very important to keep domain-layer
    services isolated. It removes the complexities and keeps the design decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example where a restaurant owner wants to see the report of his
    monthly table bookings. In this case, he will log in as an admin and click the
    **Display Report** button after providing the required input fields, such as duration.
  prefs: []
  type: TYPE_NORMAL
- en: Application layers pass the request to the domain layer that owns the report
    and templates objects, with some parameters such as report ID, and so on. Reports
    get created using the template, and data is fetched from either the database or
    other sources. Then the application layer passes through all the parameters, including
    the report ID to the business layer. Here, a template needs to be fetched from
    the database or another source to generate the report based on the ID. This operation
    does not belong to either the report object or the template object. Therefore,
    a service object is used that performs this operation to retrieve the required
    template from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregate domain pattern is related to the object's life cycle, and defines
    ownership and boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: When you reserve a table at your favorite restaurant online using an application,
    you don't need to worry about the internal system and process that takes place
    to book your reservation, including searching for available restaurants, then
    for available tables on the given date, time, and so on and so forth. Therefore,
    you can say that a reservation application is an **aggregate** of several other
    objects, and works as a **root** for all the other objects for a table reservation
    system.
  prefs: []
  type: TYPE_NORMAL
- en: This root should be an entity that binds collections of objects together. It
    is also called the **aggregate root**. This root object does not pass any reference
    of inside objects to external worlds, and protects the changes performed within
    internal objects.
  prefs: []
  type: TYPE_NORMAL
- en: We need to understand why aggregators are required. A domain model can contain
    large numbers of domain objects. The bigger the application functionalities and
    size and the more complex its design, the greater number of objects present. A
    relationship exists between these objects. Some may have a many-to-many relationship,
    a few may have a one-to-many relationship, and others may have a one-to-one relationship.
    These relationships are enforced by the model implementation in the code, or in
    the database that ensures that these relationships among the objects are kept
    intact. Relationships are not just unidirectional; they can also be bidirectional.
    They can also increase in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The designer's job is to simplify these relationships in the model. Some relationships
    may exist in a real domain, but may not be required in the domain model. Designers
    need to ensure that such relationships do not exist in the domain model. Similarly,
    multiplicity can be reduced by these constraints. One constraint may do the job
    where many objects satisfy the relationship. It is also possible that a bidirectional
    relationship could be converted into a unidirectional relationship.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how much simplification you input, you may still end up with relationships
    in the model. These relationships need to be maintained in the code. When one
    object is removed, the code should remove all the references to this object from
    other places. For example, a record removal from one table needs to be addressed
    wherever it has references in the form of foreign keys and such, to keep the data
    consistent and maintain its integrity. Also, invariants (rules) need to be forced
    and maintained whenever data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships, constraints, and invariants bring a complexity that requires
    an efficient handling in code. We find the solution by using the aggregate represented
    by the single entity known as the root**,** which is associated with the group
    of objects that maintains consistency with regards to data changes.
  prefs: []
  type: TYPE_NORMAL
- en: This root is the only object that is accessible from outside, so this root element
    works as a boundary gate that separates the internal objects from the external
    world. Roots can refer to one or more inside objects, and these inside objects
    can have references to other inside objects that may or may not have relationships
    with the root. However, outside objects can also refer to the root, and not to
    any inside objects.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate ensures data integrity and enforces the invariant. Outside objects
    cannot make any change to inside objects; they can only change the root. However,
    they can use the root to make a change inside the object by calling exposed operations.
    The root should pass the value of inside objects to outside objects if required.
  prefs: []
  type: TYPE_NORMAL
- en: If an aggregate object is stored in the database, then the query should only
    return the aggregate object. Traversal associations should be used to return the
    object when it is internally linked to the aggregate root. These internal objects
    may also have references to other aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate root entity holds its global identity, and holds local identities
    inside their entities.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of an aggregate in the table booking system is the customer.
    Customers can be exposed to external objects, and their root object contains their
    internal object address and contact information.
  prefs: []
  type: TYPE_NORMAL
- en: 'When requested, the value object of internal objects, such as address, can
    be passed to external objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/813a40c6-d3de-48ee-af15-123cafde5086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The customer as an aggregate
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a domain model, at a given point in time, many domain objects may exist.
    Each object may have its own life-cycle, from the creation of objects to their
    removal or persistence. Whenever any domain operation needs a domain object, it
    should retrieve the reference of the requested object efficiently. It would be
    very difficult if you didn't maintain all of the available domain objects in a
    central object. A central object carries the references of all the objects, and
    is responsible for returning the requested object reference. This central object
    is known as the **repository**.
  prefs: []
  type: TYPE_NORMAL
- en: The repository is a point that interacts with infrastructures such as the database
    or file system. A repository object is the part of the domain model that interacts
    with storage such as the database, external sources, and so on, to retrieve the
    persisted objects. When a request is received by the repository for an object's
    reference, it returns the existing object's reference. If the requested object
    does not exist in the repository, then it retrieves the object from storage. For
    example, if you need a customer, you would query the repository object to provide
    the customer with ID `31`. The repository would provide the requested customer
    object if it is already available in the repository, and if not, it would query
    the persisted stores such as the database, fetch it, and provide its reference.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using the repository is having a consistent way to retrieve
    objects where the requestor does not need to interact directly with the storage
    such as the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A repository may query objects from various storage types, such as one or more
    databases, filesystems, or factory repositories, and so on. In such cases, a repository
    may have strategies that also point to different sources for different object
    types or categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8f1ce0c-5528-4b86-9b3c-78c58bcfedfd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Repository object flow
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the repository object flow diagram, the r**epository** interacts
    with the i**nfrastructure layer,** and this interface is part of the **domain
    layer**. The **requestor** may belong to a domain layer, or an application layer.
    The r**epository** helps the system to manage the life cycle of domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **factory** is required when a simple constructor is not enough to create
    the object. It helps to create complex objects, or an aggregate that involves
    the creation of other related objects.
  prefs: []
  type: TYPE_NORMAL
- en: A factory is also a part of the life cycle of domain objects, as it is responsible
    for creating them. Factories and repositories are in some way related to each
    other, as both refer to domain objects. The factory refers to newly created objects,
    whereas the repository returns the already existing objects either from the memory,
    or from external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how control flows, by using a user creation process application. Let's
    say that a user signs up with a username `user1`. This user creation first interacts
    with the factory, which creates the name `user1` and then caches it in the domain
    using the repository, which also stores it in the storage for persistence.
  prefs: []
  type: TYPE_NORMAL
- en: When the same user logs in again, the call moves to the repository for a reference.
    This uses the storage to load the reference and pass it to the requestor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requestor may then use this `user1` object to book the table in a specified
    restaurant, and at a specified time. These values are passed as parameters, and
    a table booking record is created in storage using the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e0af162-b03b-49e1-8570-c8ad9657db94.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Repository object flow
  prefs: []
  type: TYPE_NORMAL
- en: The factory may use one of the object-oriented programming patterns, such as
    the factory or abstract factory pattern, for object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Modules** are the best way to separate related business objects. These are
    best suited to large projects where the size of domain objects is bigger. For
    the end user, it makes sense to divide the domain model into modules and set the
    relationship between these modules. Once you understand the modules and their
    relationship, you start to see the bigger picture of the domain model, thus it''s
    easier to drill down further and understand the model.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules also help in code that is highly cohesive, or that maintains low coupling.
    Ubiquitous language can be used to name these modules. For the table booking system,
    we could have different modules, such as user-management, restaurants and tables,
    analytics and reports, and reviews, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Strategic design and principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enterprise model is usually very large and complex. It may be distributed
    among different departments in an organization. Each department may have a separate
    leadership team, so working and designing together can create difficulty and coordination
    issues. In such scenarios, maintaining the integrity of the domain model is not
    an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, working on a unified model is not the solution, and large enterprise
    models need to be divided into different submodels. These submodels contain the
    predefined accurate relationship and contract in minute detail. Each submodel
    has to maintain the defined contracts without any exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various principles that could be followed to maintain the integrity
    of the domain model, and these are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bounded context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer-supplier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conformist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anticorruption layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Host Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distillation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounded context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have different submodels, it is difficult to maintain the code when
    all submodels are combined. You need to have a small model that can be assigned
    to a single team. You might need to collect the related elements and group them.
    Context keeps and maintains the meaning of the domain term defined for its respective
    submodel by applying this set of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: These domain terms define the scope of the model that creates the boundaries
    of the context.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded context seems very similar to the module that you learned about in the
    previous section. In fact, the module is part of the bounded context that defines
    the logical frame where a submodel takes place and is developed. Whereas, the
    module organizes the elements of the domain model, and is visible in the design
    document and the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as a designer, you would have to keep each submodel well-defined and consistent.
    In this way, you can refactor each model independently without affecting the other
    submodels. This gives the software designer the flexibility to refine and improve
    it at any point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the table reservation example we''ve been using. When you
    started designing the system, you would have seen that the guest would visit the
    application, and would request a table reservation at a selected restaurant, date,
    and time. Then, there is the backend system that informs the restaurant about
    the booking information, and similarly, the restaurant would keep their system
    updated in regard to table bookings, given that tables can also be booked by the
    restaurant themselves. So, when you look at the system''s finer points, you can
    see two domain models:'
  prefs: []
  type: TYPE_NORMAL
- en: The online table reservation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offline restaurant management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both have their own bounded context and you need to make sure that the interface
    between them works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are developing, the code is scattered among many teams and various
    technologies. This code may be organized into different modules, and has applicable
    bounded context for respective submodels.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of development may bring with it a certain level of complexity with
    regard to duplicate code, a code break, or maybe broken-bounded context. It happens
    not only because of the large size of code and domain model, but also because
    of other factors, such as changes in team members, new members, or not having
    a well-documented model, to name just a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: When systems are designed and developed using DDD and Agile methodologies, domain
    models are not designed fully before coding starts, and the domain model and its
    elements evolve over a period of time with continuous improvements and refinement
    happening gradually.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, integration continues, and this is currently one of the key reasons
    for development today, so it plays a very important role. In **continuous integration**,
    the code is merged frequently to avoid any breaks and issues with the domain model.
    Merged code not only gets deployed, but it is also tested on a regular basis.
    There are various continuous integration tools available in the market that merge,
    build, and deploy the code at scheduled times. These days, organizations put more
    emphasis on the automation of continuous integration. Hudson, TeamCity, and Jenkins
    CI are a few of the popular tools available today for continuous integration.
    Hudson and Jenkins CI are open source tools, and TeamCity is a proprietary tool.
  prefs: []
  type: TYPE_NORMAL
- en: Having a test suite attached to each build confirms the consistency and integrity
    of the model. A test suite defines the model from a physical point of view, whereas
    UML does it logically. It informs you of any error or unexpected outcome that
    requires a code change. It also helps to identify errors and anomalies in a domain
    model early on.
  prefs: []
  type: TYPE_NORMAL
- en: Context map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The context map helps you to understand the overall picture of a large enterprise
    application. It shows how many bounded contexts are present in the enterprise
    model, and how they are interrelated. Therefore, we can say that any diagram or
    document that explains the bounded contexts and relationship between them is called
    a **context** **map**.
  prefs: []
  type: TYPE_NORMAL
- en: Context maps help all team members, whether they are on the same team or in
    a different team, to understand the high-level enterprise model in the form of
    various parts (bounded context or submodels) and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives individuals a clearer picture about the tasks one performs, and
    may allow him or her to raise any concern/question about the model''s integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5347ac92-4666-4d87-99d8-12aa816036da.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Context map example
  prefs: []
  type: TYPE_NORMAL
- en: The context map example diagram is a sample of a context map. Here, **Table1**
    and **Table2** both appear in the **Table Reservation Context** and also in the
    **Restaurant Ledger Context**. The interesting thing is that **Table1** and **Table2**
    have their own respective concept in each bounded context. Here, ubiquitous language
    is used to name the bounded context as **table reservation** and **restaurant
    ledger**.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore a few patterns that can be used to
    define the communication between different contexts in the context map.
  prefs: []
  type: TYPE_NORMAL
- en: Shared kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, one part of the bounded context is shared with the other''s
    bounded context. As you can see in the following figure, the **Restaurant** entity
    is being shared between the **Table Reservation Context** and the **Restaurant
    Ledger Context**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66176460-3b14-45e0-bd1d-986c37b642b6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shared kernel
  prefs: []
  type: TYPE_NORMAL
- en: Customer-supplier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customer-supplier pattern represents the relationship between two bounded
    contexts, when the output of one bounded context is required for the other bounded
    context. That is, one supplies the information to the other (known as the customer),
    who consumes the information.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world example, a car dealer could not sell cars until the car manufacturer
    delivers them. Hence, in this domain model, the car manufacturer is the supplier
    and the dealer is the customer. This relationship establishes a customer-supplier
    relationship, because the output (car) of one bounded context (car-manufacturer)
    is required by the other bounded context (dealer).
  prefs: []
  type: TYPE_NORMAL
- en: Here, both customer and supplier teams should meet regularly to establish a
    contract and form the right protocol to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Conformist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is similar to that of the customer and the supplier, where one
    needs to provide the contract and information while the other needs to use it.
    Here, instead of bounded context, actual teams are involved in having an upstream/downstream
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, upstream teams do not provide for the needs of the downstream team,
    because of their lack of motivation. Therefore, it is possible that the downstream
    team may need to plan and work on items that will never be available. To resolve
    such cases, the customer team could develop their own models if the supplier provides
    information that is not worth enough. If the supplier provided information that
    is really of worth or of partial worth, then the customer can use the interface
    or translators that can be used to consume the supplier-provided information with
    the customer's own models.
  prefs: []
  type: TYPE_NORMAL
- en: Anticorruption layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **anticorruption layer** remains part of a domain and it is used when a
    system needs data from external systems, or from their own legacy systems. Here,
    anticorruption is the layer that interacts with external systems and uses external
    system data in the domain model without affecting the integrity and originality
    of the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, a service can be used as an anticorruption layer that may
    use a facade pattern with an adapter and translator to consume external domain
    data within the internal model. Therefore, your system would always use the service
    to retrieve the data. The service layer can be designed using the facade pattern.
    This would make sure that it would work with the domain model to provide the required
    data in a given format. The service could then also use the adapter and translator
    patterns that would make sure that, whatever format and hierarchy the data is
    sent in, by external sources, the service would be provided in the desired format
    and the hierarchy would use adapters and translators.
  prefs: []
  type: TYPE_NORMAL
- en: Separate ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a large enterprise application and a domain where different domains
    have no common elements, and it's made of large submodels that can work independently,
    this still works as a single application for an end user.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, a designer could create separate models that have no relationship,
    and develop a small application on top of them. These small applications become
    a single application when merged together.
  prefs: []
  type: TYPE_NORMAL
- en: An employer's intranet application that offers various small applications, such
    as those that are HR-related, issue trackers, transport, or intra-company social
    networks, is one such application where a designer could use the **separate ways**
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: It would be very challenging and complex to integrate applications that were
    developed using separate models. Therefore, you should take care before implementing
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Open Host Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A translation layer is used when two submodels interact with each other. This
    translation layer is used when you integrate models with an external system. This
    works fine when you have one submodel that uses this external system. The Open
    Host Service is required when this external system is being used by many submodels
    to remove the extra and duplicated code, because then you need to write a translation
    layer for each submodels external system.
  prefs: []
  type: TYPE_NORMAL
- en: An Open Host Service provides the services of an external system using a wrapper
    to all sub-models.
  prefs: []
  type: TYPE_NORMAL
- en: Distillation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, **distillation** is the process of purifying liquid. Similarly,
    in DDD, distillation is the process that filters out the information that is not
    required, and keeps only the meaningful information. It helps you to identify
    the core domain and the essential concepts for your business domain. It helps
    you to filter out the generic concepts until you get the core domain concept.
  prefs: []
  type: TYPE_NORMAL
- en: Core domain should be designed, developed, and implemented with the highest
    attention to detail, using the developers and designers, as it is crucial to the
    success of the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: In our table reservation system example, which is not a large or complex domain
    application, it is not difficult to identify the core domain. The core domain
    here exists to share the real-time accurate vacant tables in the restaurants,
    and allows the user to reserve them in a hassle-free process.
  prefs: []
  type: TYPE_NORMAL
- en: Sample domain service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us create a sample domain service based on our table reservation system.
    As discussed in this chapter, the importance of an efficient domain layer is the
    key to successful products or services. Projects developed based on the domain
    layer are more maintainable, highly cohesive, and decoupled. They provide high
    scalability in terms of business requirement changes, and have a low impact on
    the design of other layers.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven development is based on domain, hence it is not recommended that
    you use a top-down approach where the UI would be developed first, followed by
    the rest of the layers, and finally the persistence layer. Nor should you use
    a bottom-up approach, where the persistence layer like the DB is designed first,
    followed by the rest of the layers, with the UI last.
  prefs: []
  type: TYPE_NORMAL
- en: Having a domain model developed first, using the patterns described in this
    book, gives clarity to all team members functionality-wise, and an advantage to
    the software designer to build a flexible, maintainable, and consistent system
    that helps the organization to launch a world-class product with fewer maintenance
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will create a restaurant service that provides the feature to add
    and retrieve restaurants. Based on implementation, you can add other functionalities,
    such as finding restaurants based on cuisine or ratings.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the entity. Here, the restaurant is our entity, as each restaurant
    is unique and has an identifier. You can use an interface, or set of interfaces,
    to implement the entity in our table reservation system. Ideally, if you go by
    the interface segregation principle, you will use a set of interfaces rather than
    a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle** (**ISP**) states that clients should
    not be forced to depend upon interfaces that they do not use.
  prefs: []
  type: TYPE_NORMAL
- en: Entity implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first interface, you could have an abstract class or interface that
    is required by all the entities. For example, if we consider ID and name, attributes
    would be common for all entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, you could use the abstract class `Entity` as an abstraction of the
    entity in your domain layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on that, you can also have another `abstract` class that inherits `Entity`,
    an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding abstractions, we could create the `Restaurant` entity
    for restaurant management.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we are developing the table reservation system, `Table` is another
    important entity in terms of the domain model. So, if we go by the aggregate pattern,
    `Restaurant` would work as a root, and the `Table` entity would be internal to
    the `Restaurant` entity. Therefore, the `Table` entity would always be accessible
    using the `Restaurant` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the `Table` entity using the following implementation, and you
    can add attributes as you wish. For demonstration purposes only, basic attributes
    are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the aggregator `Restaurant` class shown as follows. Here,
    only basic attributes are used. You could add as many as you want, and you may
    also add other features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Repository implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can implement the repository pattern, as learned in this chapter. To
    start with, you will first create the two interfaces `Repository` and `ReadOnlyRepository`.
    The `ReadOnlyRepository` interface will be used to provide an abstraction for
    read-only operations, whereas `Repository` abstraction will be used to perform
    all types of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this interface, we could create the abstraction of the `Repository`,
    which would execute additional operations such as adding, removing, and updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Repository` abstraction, as defined previously, could be implemented,
    in a way that suits you, to persist your objects. The change in persistence code,
    which is a part of the infrastructure layer, won''t impact on your domain layer
    code, as the contract and abstraction are defined by the domain layer. The domain
    layer uses the abstraction classes and interfaces that remove the use of direct
    concrete class, and provides the loose coupling. For demonstration purposes, we
    could simply use the map that remains in the memory to persist the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Service implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way as the preceding approach, you could divide the abstraction
    of domain service into two parts—main service abstraction and read-only service
    abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we could use this `ReadOnlyBaseService` to create the `BaseService`. Here,
    we are using the dependency inject pattern via a constructor to map the concrete
    objects with abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after defining the service abstraction services, we could implement the
    `RestaurantService` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you could write the implementation for other entities. This code
    is a basic implementation, and you might add various implementations and behaviors
    in the production code.
  prefs: []
  type: TYPE_NORMAL
- en: We can write an application class that would execute and test the sample domain
    model code that we have just written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RestaurantApp.java` file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this program, either execute directly from IDE, or run using Maven.
    It prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the fundamentals of DDD. You have also explored
    multilayered architecture and different patterns that can be used to develop software
    using DDD. By this time, you should be aware that the domain model design is very
    important for the success of the software. To conclude, we demonstrated one domain
    service implementation using the restaurant table reservation system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use the design to implement the sample
    project. The explanation of the design of this sample project is derived from
    the last chapter, and the DDD will be used to build the microservices. This chapter
    not only covers the coding, but also the different aspects of the microservices,
    such as build, unit testing, and packaging. By the end of the next chapter, the
    sample microservice project will be ready for deployment and consumption.
  prefs: []
  type: TYPE_NORMAL

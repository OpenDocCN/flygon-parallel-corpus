- en: Implementing a Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter takes you from the design stage to the implementation of our sample
    project—an **online table reservation system** (**OTRS**). Here, you will use
    the same design explained in the last chapter and enhance it to build the microservices.
    At the end of this chapter, you will have not only learned how to implement the
    design, but also learned the different aspects of microservices—building, testing,
    and packaging. Although the focus is on building and implementing the Restaurant
    microservices, you can use the same approach to build and implement other microservices
    used in the OTRS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: OTRS overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing and implementing the microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the domain-driven design key concepts demonstrated in the last chapter.
    In the last chapter, you saw how domain-driven design is used to develop the domain
    model using core Java. Now, we will move from a sample domain implementation to
    a Spring Framework-driven implementation. You'll make use of Spring Boot to implement
    the domain-driven design concepts and transform them from core Java to a Spring
    Framework-based model.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll also use Spring Cloud, which provides a cloud-ready solution
    that is available through Spring Boot. Spring Boot will allow you to use an embedded
    application container relying on Tomcat or Jetty inside your service, which is
    packaged as a JAR or as a WAR. This JAR is executed as a separate process, a microservice
    that will serve and provide the response to all requests and point to endpoints
    defined in the service.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud can also be integrated easily with Netflix Eureka, a service registry
    and discovery component. The OTRS will use it for registration and the discovery
    of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: OTRS overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on microservice principles, we need to have separate microservices for
    each functionality. After looking at OTRS, we can easily divide it into three
    main microservices—Restaurant service, Booking service, and User service. There
    are other microservices that can be defined in the OTRS. Our focus is on these
    three microservices. The idea is to make them independent, including having their
    own separate databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the functionalities of these services, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restaurant service**: This service provides the functionality for the restaurant
    resource—**create**, **read**, **update**, **delete** (**CRUD**) operation and
    searching based on criteria. It provides the association between restaurants and
    tables. Restaurant would also provide access to the `Table` entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User service**: This service, as the name suggests, allows the end user to
    perform CRUD operations on User entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Booking service**: This makes use of the Restaurant service and User service
    to perform CRUD operations on booking. It will use restaurant searching and its
    associated table lookup and allocation based on table availability for a specified
    time duration. It creates the relationship between the restaurant/table and the
    user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7477a84d-be2b-4e19-88ec-d74b29e6b4c3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Registration, and discovery of the different microservices
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows how each microservice works independently. This
    is the reason microservices can be developed, enhanced, and maintained separately,
    without affecting others. These services can each have their own layered architecture
    and database. There is no restriction to use the same technologies, frameworks,
    and languages to develop these services. At any given point in time, you can also
    introduce new microservices. For example, for accounting purposes, we can introduce
    an accounting service that can be exposed to restaurants for bookkeeping. Similarly,
    analytics and reporting are other services that can be integrated and exposed.
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, we will only implement the three services shown
    in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Developing and implementing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the domain-driven implementation and approach described in the
    last chapter to implement the microservices using Spring Cloud. Let''s revisit
    the key artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities**: These are categories of objects that are identifiable and remain
    the same throughout the states of the product/services. These objects are *not*
    defined by their attributes, but by their identities and threads of continuity.
    Entities have traits such as identity, a thread of continuity, and attributes
    that do not define their identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value objects** (**VOs**) just have the attributes and no conceptual identity.
    A best practice is to keep VOs as immutable objects. In the Spring Framework,
    entities are pure POJOs; therefore, we''ll also use them as VOs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service objects**: These are common in technical frameworks. These are also
    used in the domain layer in domain-driven design. A service object does not have
    an internal state; the only purpose of it is to provide the behavior to the domain.
    Service objects provide behaviors that cannot be related with specific entities
    or VOs. Service objects may provide one or more related behaviors to one or more
    entities or VOs. It is best practice to define the services explicitly in the
    domain model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository objects**: A repository object is a part of the domain model that
    interacts with storage, such as databases, external sources, and so on, to retrieve
    the persisted objects. When a request is received by the repository for an object
    reference, it returns the existing object reference. If the requested object does
    not exist in the repository, then it retrieves the object from storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downloading the example code: detailed steps to download the code bundle are
    mentioned in the preface of this book. Please have a look. The code bundle for
    the book is also hosted on GitHub at: [https://github.com/PacktPublishing/Mastering-Microservices-with-Java](https://github.com/PacktPublishing/Mastering-Microservices-with-Java-9-Second-Edition).
    We also have other code bundles from our rich catalog of books and videos available
    at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  prefs: []
  type: TYPE_NORMAL
- en: Each OTRS microservice API represents a RESTful web service. The OTRS API uses
    HTTP verbs such as `GET`, `POST`, and so on, and a RESTful endpoint structure.
    Request and response payloads are formatted as JSON. If required, XML can also
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Restaurant microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Restaurant microservices will be exposed to the external world using REST
    endpoints for consumption. We''ll find the following endpoints in the Restaurant
    microservice example. One can add as many endpoints as per the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoint for retrieving restaurant by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dd6acef-2a4c-420e-b962-a11cbb7261f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Endpoint for retrieving all the restaurants that matches the value of query
    parameter `Name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4967fca0-9a41-47dc-ba3f-14de1854d494.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Endpoint for creating new restaurant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c3956c15-b2bc-460b-b4a9-0904194f97c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can add various endpoints and their implementations. For demonstration
    purposes, we'll implement the preceding endpoints using Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: OTRS implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create the multi-module Maven project for implementing OTRS. The following
    stack would be used to develop the OTRS application. Please note that at the time
    of writing this book, only the snapshot build of Spring Boot and Cloud was available.
    Therefore, in the final release, one or two things may change:'
  prefs: []
  type: TYPE_NORMAL
- en: Java version 1.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.0.0.M1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Finchley.M2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven Compiler Plugin 3.6.1 (for Java 1.9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All preceding points are mentioned in the root `pom.xml`, along with the following
    OTRS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eureka-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restaurant-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`booking-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The root `pom.xml` file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are developing the REST-based microservices. We'll implement the `restaurant`
    module. The `booking` and `user` modules are developed on similar lines.
  prefs: []
  type: TYPE_NORMAL
- en: Controller class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RestaurantController` class uses the `@RestController` annotation to build
    the Restaurant service endpoints. We have already gone through the details of
    `@RestController` in [Chapter 2](58549a01-e3b9-4702-9326-692008cc32c2.xhtml),
    *Setting Up the Development Environment*. The
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController` is a class-level annotation that is used for resource classes.
    It is'
  prefs: []
  type: TYPE_NORMAL
- en: a combination of the `@Controller` and `@ResponseBody` annotation. It returns
    the domain object.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move forward, I would like to share with you that we are using the `v1`
    prefix on our REST endpoint. That represents the version of the API. I would also
    like to brief you on the importance of API versioning. Versioning APIs is important,
    because APIs change over time. Your knowledge and experience improves with time,
    which leads to changes to your API. A change of API may break existing client
    integrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are various ways of managing API versions. One of these is
    using the version in the path, or some people use the HTTP header. The HTTP header
    can be a custom request header or an accept header to represent the calling API
    version. Please refer to *RESTful Java Patterns and Best Practices* by Bhakti
    Mehta, Packt Publishing, [https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices](https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices),
    for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Service classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RestaurantController` class uses the `RestaurantService` interface. `RestaurantService`
    is an interface that defines CRUD and some search operations, and is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the `RestaurantService` we have just defined. It also
    extends the `BaseService` class you created in the last chapter. We use the `@Service`
    Spring annotation to define it as a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Repository classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `RestaurantRepository` interface defines two new methods: the `containsName`
    and `findByName` methods. It also extends the `Repository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Repository` interface defines three methods: `add`, `remove`, and `update`.
    It also extends the `ReadOnlyRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadOnlyRepository` interface definition contains the `get` and `getAll`
    methods, which return Boolean values, entity, and collection of entity, respectively.
    It is useful if you want to expose only a read-only abstraction of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring Framework makes use of the `@Repository` annotation to define the
    repository bean that implements the repository. In the case of `RestaurantRepository`,
    you can see that a map is used in place of the actual database implementation.
    This keeps all entities saved in memory only. Therefore, when we start the service,
    we find only two restaurants in memory. We can use JPA for database persistence.
    This is the general practice for production-ready implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Entity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Restaurant` entity, which extends `BaseEntity`, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using POJO classes for our entity definitions, we do not need to
    create a VO in many cases. The idea is that the state of the object should not
    be persisted across.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Table` entity, which extends `BaseEntity`, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Entity` abstract class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseEntity` abstract class is defined as follows. It extends the `Entity`
  prefs: []
  type: TYPE_NORMAL
- en: 'abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are done with the Restaurant service implementation. Now, we'll develop the
    Eureka module (service).
  prefs: []
  type: TYPE_NORMAL
- en: Registration and discovery service (Eureka service)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a place where all microservices get registered and can be referenced—a
    service discovery and registration application. Spring Cloud provides the state-of-the-art
    service registry and discovery application Netflix Eureka. We'll make use of it
    for our sample project OTRS.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have configured the Eureka service as described in this section, it
    will be available for all incoming requests to list it on the Eureka service.
    The Eureka service registers/lists all microservices that have been configured
    by the Eureka client. Once you start your service, it pings the Eureka service
    configured in your `application.yml` and once a connection is established, the
    Eureka service registers the service.
  prefs: []
  type: TYPE_NORMAL
- en: It also enables the discovery of microservices through a uniform way to connect
    to other microservices. You don't need any IP, hostname, or port to find the service,
    you just need to provide the service ID to it. Service IDs are configured in the
    `application.yml` of the respective microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following three steps, we can create a Eureka service (service registration
    and discovery service):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maven dependency**: It needs a Spring Cloud dependency, as shown here, and
    a startup class with the `@EnableEurekaApplication` annotation in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Startup class**: The startup `class App` will run the Eureka service seamlessly
    by just using the `@EnableEurekaApplication` class annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Use `<start-class>com.packtpub.mmj.eureka.service.App</start-class>` under the
    `<properties>` tag in the `pom.xml` project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring configuration**:The Eureka service also needs the following Spring
    configuration for the Eureka server configuration (`src/main/resources/application.yml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Eureka client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Eureka server, each OTRS service should also contain the Eureka
    client configuration, so that a connection between the Eureka server and the client
    can be established. Without this, the registration and discovery of services is
    not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your services can use the following Spring configuration to configure the Eureka
    client. Add the following configuration in the Restaurant, Booking, and User services
    (`restaurant-service\src\main\resources\application.yml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Booking and user services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `RestaurantService` implementation to develop the Booking and
    User services. The User service can offer the endpoint related to the User resource
    with respect to CRUD operations. The Booking service can offer the endpoints related
    to the booking resource with respect to CRUD operations and the availability of
    table slots. You can find the sample code of these services on the Packt website
    or on Packt Publishing GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see how our code works, we need to first build it and then execute it. We'll
    use a Maven clean package to build the service JARs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to execute these service JARs, simply execute the following command from
    the project home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute our services in the following order from the project home directory.
    The Eureka service should be started first; the order of the last three microservices
    can be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable testing, add the following dependency in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `RestaurantController`, the following files have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RestaurantControllerIntegrationTests` class, which uses the
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SpringApplicationConfiguration` annotation to pick the same configuration
    that Spring Boot uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An `abstract` class to write our tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `RestaurantControllerTests` class, which extends the previously
    created `abstract` class and also creates the `RestaurantService` and `RestaurantRepository`
    implementations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*RESTful Java Patterns and Best Practices* by Bhakti Mehta, Packt Publishing:
    [https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices](https://www.packtpub.com/application-development/restful-java-patterns-and-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Cloud: [http://cloud.spring.io/](http://cloud.spring.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netflix Eureka: [https://github.com/netflix/eureka](https://github.com/netflix/eureka)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how the domain-driven design model can be used
    in a microservice. After running the demo application, we can see how each microservice
    can be developed, deployed, and tested independently. You can create microservices
    using Spring Cloud very easily. We have also explored how one can use the Eureka
    registry and discovery component with Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to deploy microservices in containers such
    as Docker. We will also understand microservice testing using REST Java clients
    and other tools.
  prefs: []
  type: TYPE_NORMAL

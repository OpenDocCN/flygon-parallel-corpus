- en: Deployment and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和测试
- en: In this chapter, we'll continue from where we left off in [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*. We'll add a few more services to groom our online
    table reservation system (OTRS) application that only depends on three functional
    services (Restaurant, User, and Booking services) and Eureka (service discovery
    and registration) to create a fully functional microservice stack. This stack
    will have gateway (Zuul), load balancing (Ribbon with Zuul and Eureka), and monitoring
    (Hystrix, Turbine, and the Hystrix dashboard). You want to have composite APIs
    and see how one microservice talks to others. This chapter will also explain how
    to containerize microservices using Docker and how to run multiple containers
    together using `docker-compose`. On top of this, we'll also add the integration
    tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从[第4章](4561ba72-866e-45f9-88ac-761a62242e26.xhtml)中离开的地方继续进行，*实现微服务*。我们将添加一些服务来完善我们的在线预订系统（OTRS）应用程序，该应用程序仅依赖于三个功能服务（餐厅、用户和预订服务）和Eureka（服务发现和注册）来创建一个完全功能的微服务堆栈。这个堆栈将具有网关（Zuul）、负载均衡（Ribbon与Zuul和Eureka）和监控（Hystrix、Turbine和Hystrix仪表板）。您希望拥有复合API，并了解一个微服务如何与其他微服务交互。本章还将解释如何使用Docker对微服务进行容器化，以及如何使用`docker-compose`运行多个容器。此外，我们还将添加集成测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of microservice architecture using Netflix OSS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Netflix OSS的微服务架构概述
- en: Edge servers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Load balancing microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡微服务
- en: Circuit breakers and monitoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器和监控
- en: Microservice deployment using containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器进行微服务部署
- en: Microservice integration testing using Docker containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器进行微服务集成测试
- en: Mandatory services for good microservices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好微服务的强制性服务
- en: 'There are a few patterns/services that should be in place for implementing
    microservice-based design. This list consists of the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些模式/服务应该在实现基于微服务的设计时存在。这个列表包括以下内容：
- en: Service discovery and registration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: Edge or proxy server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘或代理服务器
- en: Load balancing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Circuit breaker
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Monitoring
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: We'll implement these services in this chapter to complete our OTRS system.
    Following is a brief overview. We'll discuss these patterns/services in detail
    later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中实现这些服务，以完成我们的OTRS系统。以下是简要概述。我们稍后会详细讨论这些模式/服务。
- en: Service discovery and registration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现和注册
- en: The Netflix Eureka server is used for service discovery and registration. We
    created the Eureka service in the last chapter. It not only allows you to register
    and discover services, but also provides load balancing using Ribbon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器用于服务发现和注册。我们在上一章中创建了Eureka服务。它不仅允许您注册和发现服务，还使用Ribbon进行负载均衡。
- en: Edge servers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: An edge server provides a single point of access to allow the external world
    to interact with your system. All of your APIs and frontends are only accessible
    using this server. Therefore, these are also referred to as gateway or proxy servers.
    These are configured to route requests to different microservices or frontend
    applications. We'll use the Netflix Zuul server as an edge server in the OTRS
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器提供了一个单一访问点，允许外部世界与您的系统进行交互。您的所有API和前端只能使用这个服务器访问。因此，这些也被称为网关或代理服务器。它们被配置为将请求路由到不同的微服务或前端应用程序。我们将在OTRS应用程序中使用Netflix
    Zuul服务器作为边缘服务器。
- en: Load balancing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Netflix Ribbon is used for load balancing. It is integrated with the Zuul and
    Eureka services to provide load balancing for both internal and external calls.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Ribbon用于负载均衡。它与Zuul和Eureka服务集成，为内部和外部调用提供负载均衡。
- en: Circuit breakers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: A fault or break should not prevent your whole system from working. Also, the
    repeated failure of a service or an API should be handled properly. Circuit breakers
    provide these features. Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 故障或中断不应该阻止整个系统工作。此外，服务或API的重复失败应该得到适当处理。断路器提供了这些功能。Netflix Hystrix用作断路器，有助于保持系统运行。
- en: Monitoring
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: The Hystrix dashboard is used with Netflix Turbine for microservice monitoring.
    It provides a dashboard to check the health of running microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix仪表板与Netflix Turbine一起用于微服务监控。它提供了一个仪表板来检查正在运行的微服务的健康状况。
- en: An overview of microservice architecture using Netflix OSS
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix OSS的微服务架构概述
- en: Netflix are pioneers in microservice architecture. They were the first to successfully
    implement microservice architecture on a large scale. They also helped increase
    its popularity and contributed immensely to microservices by open sourcing most
    of their microservice tools with Netflix **Open Source Software Center** (**OSS**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix是微服务架构的先驱。他们是第一个成功在大规模上实现微服务架构的公司。他们还帮助增加了微服务架构的流行度，并通过开源大部分他们的微服务工具与Netflix
    **开源软件中心**（**OSS**）做出了巨大贡献。
- en: According to the Netflix blog, when Netflix was developing their platform, they
    used Apache Cassandra for data storage, which is an open source tool from Apache.
    They started contributing to Cassandra with fixes and optimization extensions.
    This led to Netflix seeing the benefits of releasing Netflix projects with the
    name OSS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Netflix的博客，在Netflix开发他们的平台时，他们使用了Apache Cassandra作为数据存储，这是Apache的一个开源工具。他们开始为Cassandra做出修复和优化扩展的贡献。这导致Netflix看到了通过以Netflix
    OSS的名义发布项目的好处。
- en: Spring took the opportunity to integrate many Netflix OSS projects, such as
    Zuul, Ribbon, Hystrix, the Eureka server, and Turbine, into Spring Cloud. This
    is one of the reasons Spring Cloud provides a ready-made platform for developing
    production-ready microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Spring借此机会整合了许多Netflix OSS项目，如Zuul、Ribbon、Hystrix、Eureka服务器和Turbine到Spring Cloud中。这也是Spring
    Cloud提供了一个现成平台来开发生产就绪微服务的原因之一。
- en: 'Now, let''s take a look at a few important Netflix tools and how they fit into
    microservice architecture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些重要的Netflix工具以及它们如何适用于微服务架构：
- en: '![](img/451c2530-d3dd-4dca-ab1e-04a6f2c8c0a0.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/451c2530-d3dd-4dca-ab1e-04a6f2c8c0a0.jpg)'
- en: Microservice architecture diagram
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构图
- en: 'As you can see in the preceding diagram, for each of the microservice practices,
    we have a Netflix tool associated with it. We can go through the following mapping
    to understand it. Detailed information is covered in the respective sections of
    this chapter except concerning Eureka, which is elaborated on in the last chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，对于每个微服务实践，我们都有一个与之相关的Netflix工具。我们可以通过以下映射来了解它。除了Eureka在上一章节中有详细信息外，本章的各个部分都有详细信息：
- en: '**Edge server**: We use the Netflix Zuul server as an edge server.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘服务器**：我们使用Netflix Zuul服务器作为边缘服务器。'
- en: '**Load balancing**: Netflix Ribbon is used for load balancing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：Netflix Ribbon用于负载均衡。'
- en: '**Circuit breaker**: Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：Netflix Hystrix用作断路器，并有助于保持系统运行。'
- en: '**Service discovery and registration**: The Netflix Eureka server is used for
    service discovery and registration.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现和注册**：Netflix Eureka服务器用于服务发现和注册。'
- en: '**Monitoring dashboard**: The Hystrix dashboard is used with Netflix Turbine
    for microservice monitoring. It provides a dashboard to check the health of running
    microservices.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控仪表板**：使用Netflix Turbine的Hystrix仪表板进行微服务监控。它提供了一个仪表板来检查正在运行的微服务的健康状况。'
- en: Load balancing
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Load balancing is required to service requests in a manner that maximizes speed
    and capacity utilization, and it makes sure that no server is overloaded with
    requests. The load balancer also redirects requests to the remaining host servers
    if a server goes down. In microservice architecture, a microservice can serve
    internal or external requests. Based on this, we can have two types of load balancing—client-side
    and server-side load balancing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡是为了以最大化速度和容量利用率的方式服务请求，并确保没有服务器被请求过载。如果服务器宕机，负载均衡器还会将请求重定向到剩余的主机服务器。在微服务架构中，微服务可以为内部或外部请求提供服务。基于此，我们可以有两种类型的负载均衡——客户端和服务器端负载均衡。
- en: Server-side load balancing
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端负载均衡
- en: We'll discuss server-side load balancing; before that, we'll discuss routing.
    It is important to define the routing mechanism for our OTRS application from
    the microservice architecture point of view. For example, `/` (root) could be
    mapped to our UI application. Similarly, `/restaurantapi` and `/userapi` could
    be mapped to the Restaurant service and User service respectively. The edge server
    also performs routing with load balancing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论服务器端负载均衡；在此之前，我们将讨论路由。从微服务架构的角度来看，为我们的OTRS应用程序定义路由机制非常重要。例如，`/`（根）可以映射到我们的UI应用程序。同样，`/restaurantapi`和`/userapi`可以分别映射到餐厅服务和用户服务。边缘服务器还执行带有负载均衡的路由。
- en: We'll use the Netflix Zuul server as our edge server. Zuul is a JVM-based router
    and server-side load balancer. Zuul supports any JVM language for writing rules
    and filters and has built-in support for Java and Groovy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Netflix Zuul服务器作为我们的边缘服务器。Zuul是基于JVM的路由器和服务器端负载均衡器。Zuul支持任何JVM语言编写规则和过滤器，并内置对Java和Groovy的支持。
- en: Netflix Zuul, by default, has discovery client (Eureka client) support. Zuul
    also makes use of Ribbon and Eureka for load balancing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Zuul默认具有发现客户端（Eureka客户端）支持。Zuul还利用Ribbon和Eureka进行负载均衡。
- en: The external world (the UI and other clients) calls the edge server, which uses
    the routes defined in `application.yml` to call internal services and provide
    the response. Your guess is right if you think it acts as a proxy server, carries
    gateway responsibility for internal networks, and calls internal services for
    defined and configured routes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 外部世界（UI和其他客户端）调用边缘服务器，边缘服务器使用`application.yml`中定义的路由来调用内部服务并提供响应。如果您认为它充当代理服务器，承担内部网络的网关责任，并为已定义和配置的路由调用内部服务，那么您的猜测是正确的。
- en: Normally, it is recommended to have a single edge server for all requests. However,
    a few companies use a single edge server per client to scale. For example, Netflix
    uses a dedicated edge server for each device type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，建议为所有请求使用单个边缘服务器。然而，一些公司使用每个客户端的单个边缘服务器来进行扩展。例如，Netflix为每种设备类型使用专用的边缘服务器。
- en: An edge server will also be used in the next chapter, when we configure and
    implement microservice security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将使用边缘服务器来配置和实现微服务安全。
- en: 'Configuring and using the edge server is pretty simple in Spring Cloud. You
    need to perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud中配置和使用边缘服务器非常简单。您需要执行以下步骤：
- en: 'Define the Zuul server dependency in the `pom.xml` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中定义Zuul服务器依赖项：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Use the `@EnableZuulProxy` annotation in your application class. It also internally
    uses the `@EnableDiscoveryClient` annotation; therefore, it is also registered
    to the Eureka server automatically. You can find the registered Zuul server in
    the figure in *Client-side load balancing section*.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序类中使用`@EnableZuulProxy`注解。它还内部使用`@EnableDiscoveryClient`注解；因此，它也会自动注册到Eureka服务器。您可以在*客户端负载均衡部分*的图中找到注册的Zuul服务器。
- en: 'Update the Zuul configuration in the `application.yml` file, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application.yml`文件中更新Zuul配置，如下所示：
- en: '`zuul:ignoredServices`: This skips the automatic addition of services. We can
    define service ID patterns here. The `*` denotes that we are ignoring all services.
    In the following sample, all services are ignored except `restaurant-service`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zuul:ignoredServices`：这将跳过自动添加服务。我们可以在这里定义服务ID模式。`*`表示我们忽略所有服务。在以下示例中，除了`restaurant-service`，所有服务都被忽略。'
- en: '`Zuul.routes`: This contains the `path` attribute that defines the URI''s pattern.
    Here, `/restaurantapi` is mapped to `restaurant-service` using the `serviceId`
    attribute. The `serviceId` attribute represents the service in the Eureka server.
    You can use a URL in place of a service, if the Eureka server is not used. We
    have also used the `stripPrefix` attribute to strip the prefix (`/restaurantapi`),
    and the resultant `/restaurantapi/v1/restaurants/1` call converts to `/v1/restaurants/1`
    while calling the service:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Please note that Eureka applications only register a single instance of any
    service for each host. You need to use the following value for `metadataMap.instanceid`
    to register multiple instances of the same application on one host for load balancing
    to work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a working edge server. First, we''ll call the Restaurant service
    deployed on port `3402`, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96fe451a-e8c4-48fc-b80a-a09784c1795b.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Direct Restaurant service call
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll call the same service using the edge server that is deployed on
    port `8765`. You can see that the `/restaurantapi` prefix is used for calling
    `/v1/restaurants?name=o`, and it gives the same result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6202f3a7-e83f-4f7f-a992-5f153e395f66.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Restaurant Service call using the edge server
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Client-side load balancing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices need interprocess communication so that services can communicate
    with each other. Spring Cloud uses Netflix Ribbon, a client-side load balancer
    that plays this critical role and can handle both HTTP and TCP. Ribbon is cloud-enabled
    and provides built-in failure resiliency. Ribbon also allows you to use multiple
    and pluggable load balancing rules. It integrates clients with load balancers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we added the Eureka server. Ribbon is integrated with
    the Eureka server in Spring Cloud by default. This integration provides the following
    features:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to hardcode remote server URLs for discovery when the Eureka
    server is used. This is a prominent advantage, although you can still use the
    configured server list (`listOfServers`) in the `application.yml` file if required.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server list gets populated from the Eureka server. The Eureka server overrides
    `ribbonServerList` with the `DiscoveryEnabledNIWSServerList` interface.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request to find out whether the server is up is delegated to Eureka. The
    `DiscoveryEnabledNIWSServerList` interface is used in place of Ribbon's `IPing`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are different clients available in Spring Cloud that use Ribbon, such
    as `RestTemplate` or `FeignClient`. These clients allow microservices to communicate
    with each other. Clients use instance IDs in place of hostnames and ports for
    making an HTTP call to service instances when the Eureka server is used. The client
    passes the service ID to Ribbon and it then uses the load balancer to pick the
    instance from the Eureka server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are multiple instances of services available in Eureka, as shown in
    the following screenshot, Ribbon picks only one for the request, based on load
    balancing algorithms:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff86c7a3-c57c-4228-b6a2-5b87de6eacea.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Multiple service registration - Restaurant service
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `DiscoveryClient` to find all of the available service instances
    in the Eureka server, as shown in the following code. The `getLocalServiceInstance()`
    method of the `DiscoveryClientSample` class returns all of the local service instances
    available in the Eureka server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `DiscoveryClient` sample:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When executed, this code prints the following information. It shows two instances
    of the Restaurant service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following samples showcase how these clients can be used. You can see that
    in both clients, the service name `restaurant-service` is used in place of a service
    hostname and port. These clients call `/v1/restaurants` to get a list of restaurants
    containing the name given in the name query parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the`RestTemplate` sample:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RestTemplate`示例：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the`FeignClient` sample:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`FeignClient`示例：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All preceding examples will print the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的示例将打印以下输出：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For demonstration purposes, we have added all clients—`discovery` client, `RestTemplate`
    client, and `FeignClient` added in the edge application main class Java file.
    Since we have all of these clients implementing the `CommandLineRunner` interface,
    this gets executed immediately after the edge application service starts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们已经在边缘应用的主类Java文件中添加了所有客户端——`discovery`客户端，`RestTemplate`客户端和`FeignClient`。由于所有这些客户端都实现了`CommandLineRunner`接口，这在边缘应用服务启动后立即执行。
- en: Circuit breakers and monitoring
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器和监控
- en: In general terms, a circuit breaker is a*n automatic device for stopping the
    flow of current in an electric circuit as a safety measure.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，断路器是一种用作安全措施的自动设备，用于阻止电路中电流的流动。
- en: The same concept is used for microservice development, known as the **circuit
    breaker** design pattern. It tracks the availability of external services such
    as the Eureka server, API services such as `restaurant-service`, and so on, and
    prevents service consumers from performing any action on any service that is not
    available.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的概念被用于微服务开发，被称为**断路器**设计模式。它跟踪外部服务的可用性，比如Eureka服务器，API服务比如`restaurant-service`等等，并且阻止服务消费者对任何不可用的服务执行任何操作。
- en: It is another important aspect of microservice architecture, a safety measure
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务架构的另一个重要方面，是一种安全措施
- en: (failsafe mechanism) when the service does not respond to a call made by the
    service consumer, which is called a circuit breaker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （保险机制）当服务不响应服务消费者的调用时，即称为断路器。
- en: We'll use Netflix Hystrix as a circuit breaker. It calls the internal fallback
    method in the service consumer when failures occur (for example, due to a communication
    error or timeout). It executes embedded within its consumer of service. In the
    next section, you will find the code that implements this feature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Netflix Hystrix作为断路器。当发生故障（例如由于通信错误或超时）时，它在服务消费者中调用内部回退方法。它在其服务的消费者中嵌入执行。在下一节中，您将找到实现此功能的代码。
- en: Hystrix opens the circuit and failfast when the service fails to respond repeatedly,
    until the service is available again. When calls to a particular service reach
    a certain threshold (the default threshold is 20 failures in five seconds), the
    circuit opens and the call is not made. You must be wondering, if Hystrix opens
    the circuit, then how does it know that the service is available? It exceptionally
    allows some requests to call the service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix在服务重复无响应时打开断路器并快速失败，直到服务再次可用。当对特定服务的调用达到一定阈值（默认阈值是5秒内20次失败），断路器打开并且不进行调用。你一定会想，如果Hystrix打开了断路器，那么它如何知道服务是可用的呢？它特别允许一些请求调用服务。
- en: Using Hystrix's fallback methods
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix的回退方法
- en: 'There are five steps for implementing fallback methods. For this purpose, we''ll
    create another service, `api-service`, in the same way as we have created other
    services. The `api-service` service will consume the other services such as `restaurant-service`
    and so on, and will be configured in the edge server for exposing the OTRS API
    to external use. The five steps are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现回退方法有五个步骤。为此，我们将创建另一个服务`api-service`，方式与我们创建其他服务的方式相同。`api-service`服务将消费其他服务，比如`restaurant-service`等，并且将在边缘服务器中进行配置，以向外部使用暴露OTRS
    API。五个步骤如下：
- en: '**Enable the circuit breaker**: The main class of microservice that consumes
    other services should be annotated with `@EnableCircuitBreaker`. Therefore, we''ll
    annotate `src\main\java\com\packtpub\mmj\api\service\ApiApp.java`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用断路器**：消费其他服务的微服务的主类应该被注解为`@EnableCircuitBreaker`。因此，我们将在`src\main\java\com\packtpub\mmj\api\service\ApiApp.java`中进行注解：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Configure the fallback method**: The annotation `@HystrixCommand` is used
    to configure the `fallbackMethod`. We''ll annotate controller methods to configure
    the fallback methods. This is the file: `src\main\java\com\packtpub\mmj\api\service\restaurant\RestaurantServiceAPI.java`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置回退方法**：注解`@HystrixCommand`用于配置`fallbackMethod`。我们将对控制器方法进行注解以配置回退方法。这是文件：`src\main\java\com\packtpub\mmj\api\service\restaurant\RestaurantServiceAPI.java`：'
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Define the fallback method**: A method that handles the failure and performs
    the steps for safety. Here, we have just added a sample; this can be modified
    based on the way we want to handle the failure:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义回退方法**：处理失败并执行安全步骤的方法。在这里，我们只是添加了一个示例；这可以根据我们想要处理失败的方式进行修改：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Maven dependencies**: We need to add the following dependencies in `pom.xml`
    for an API service or in a project in which we want to failsafe API calls:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Maven依赖**：我们需要在`pom.xml`中为API服务或者我们想要保险的API调用的项目中添加以下依赖：'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Configuring Hystrix in `application.yml`**: We will add the following Hystrix
    properties in our `application.yml` file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在`application.yml`中配置Hystrix**：我们将在我们的`application.yml`文件中添加以下Hystrix属性：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These steps should be enough to failsafe the service calls and return a more
    appropriate response to the service consumer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该足以保护服务调用并向服务消费者返回更合适的响应。
- en: Monitoring
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: 'Hystrix provides a dashboard with a web UI that provides nice graphics of circuit
    breakers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix提供了一个带有Web UI的仪表板，提供了断路器的漂亮图形：
- en: '![](img/88b20511-ffd5-4562-979d-50210d86d46c.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88b20511-ffd5-4562-979d-50210d86d46c.jpg)'
- en: Default Hystrix dashboard
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Hystrix仪表板
- en: Netflix Turbine is a web application that connects to the instances of your
    Hystrix applications in a cluster and aggregates information, which it does in
    real time (updated every 0.5 seconds). Turbine provides information using a stream
    that is known as a Turbine stream.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Turbine是一个Web应用程序，连接到Hystrix应用程序的实例集群并实时聚合信息（每0.5秒更新一次）。Turbine使用称为Turbine流的流提供信息。
- en: If you combine Hystrix with Netflix Turbine, then you can get all of the information
    from the Eureka server on the Hystrix dashboard. This gives you a landscape view
    of all of the information about the circuit breakers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将Hystrix与Netflix Turbine结合使用，则可以从Eureka服务器在Hystrix仪表板上获取所有信息。这为您提供了有关断路器的所有信息的全景视图。
- en: To use Turbine with Hystrix, just type in the Turbine URL `http://localhost:8989/turbine.stream`
    (port `8989` is configured for the Turbine server in `application.yml`) in the
    first textbox shown in the preceding screenshot, and click on Monitor Stream.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Turbine和Hystrix，只需在前面截图中显示的第一个文本框中输入Turbine URL `http://localhost:8989/turbine.stream`（端口`8989`在`application.yml`中配置为Turbine服务器），然后单击“监视流”。
- en: Netflix Hystrix and Turbine use RabbitMQ, an open source message queuing software.
    RabbitMQ works on **Advance Messaging Queue Protocol** (**AMQP**). It is a software
    in which queues can be defined and used by connected applications to exchange
    messages. A message can include any kind of information. A message can be stored
    in the RabbitMQ queue until a receiver application connects and consumes the message
    (taking the message off the queue).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Hystrix和Turbine使用RabbitMQ，这是一种开源消息队列软件。RabbitMQ使用**高级消息队列协议**（**AMQP**）。这是一种软件，可以由连接的应用程序定义和使用队列来交换消息。消息可以包含任何类型的信息。消息可以存储在RabbitMQ队列中，直到接收应用程序连接并消耗消息（从队列中取出消息）。
- en: Hystrix uses RabbitMQ to send metrics data feed to Turbine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix使用RabbitMQ将指标数据发送到Turbine。
- en: Before we configure Hystrix and Turbine, please install the RabbitMQ application
    on your platform. Hystrix and Turbine use RabbitMQ to communicate between themselves.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置Hystrix和Turbine之前，请在您的平台上安装RabbitMQ应用程序。Hystrix和Turbine使用RabbitMQ进行通信。
- en: Setting up the Hystrix dashboard
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Hystrix仪表板
- en: We'll create another project in the IDE for the Hystrix dashboard in the same
    way as we created other services. Inside this new project, we'll add the new Maven
    dependency, `dashboard-server`, for the Hystrix server. Configuring and using
    the Hystrix dashboard is pretty simple in Spring Cloud.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在IDE中为Hystrix仪表板创建另一个项目，方式与我们创建其他服务相同。在这个新项目中，我们将为Hystrix服务器添加新的Maven依赖项`dashboard-server`。在Spring
    Cloud中配置和使用Hystrix仪表板非常简单。
- en: 'When you run the Hystrix dashboard application, it will look like the default
    Hystrix dashboard screenshot shown earlier. You just need to follow these steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Hystrix仪表板应用程序时，它将看起来像之前显示的默认Hystrix仪表板截图。您只需要按照以下步骤：
- en: 'Define the Hystrix dashboard dependency in the `pom.xml` file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中定义Hystrix仪表板依赖项：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `@EnableHystrixDashboard` annotation in the main Java class does everything
    for you to use it. We''ll also use the `@Controller` to forward the request from
    the root URI to the Hystrix dashboard UI URI (`/hystrix`), as shown here:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主Java类中使用`@EnableHystrixDashboard`注解即可完成所有使用。我们还将使用`@Controller`将请求从根URI转发到Hystrix仪表板UI
    URI（`/hystrix`），如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the dashboard application configuration in `application.yml`, as shown
    here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`application.yml`中的仪表板应用程序配置，如下所示：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating Turbine services
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Turbine服务
- en: Turbine aggregates all `/hystrix.stream` endpoints into a combined `/turbine.stream`
    for use in the Hystrix dashboard, which is more helpful as it allows to see the
    overall health of the system in a single dashboard rather than monitoring the
    individual services using `/hystrix.stream`. We'll create another service project
    in the IDE like the others. Then, we'll add Maven dependencies for Turbine in
    `pom.xml`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Turbine将所有`/hystrix.stream`端点聚合到一个组合的`/turbine.stream`中，以供Hystrix仪表板使用，这更有帮助，因为它允许在单个仪表板上查看系统的整体健康状况，而不是使用`/hystrix.stream`监视各个服务。我们将在IDE中创建另一个服务项目，就像其他服务一样。然后，我们将在`pom.xml`中为Turbine添加Maven依赖项。
- en: 'Now, we will configure the Turbine server using the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下步骤配置Turbine服务器：
- en: 'Define the Turbine Server dependency in `pom.xml`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`中定义Turbine服务器依赖项：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use the `@EnableTurbineStream` annotation in your application class, as
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类中使用`@EnableTurbineStream`注解，如
- en: 'shown here. We are also defining a bean that will return the RabbitMQ `ConnectionFactory`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示。我们还在其中定义了一个将返回RabbitMQ `ConnectionFactory`的bean：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the Turbine configuration in `application.yml`, as shown here:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`application.yml`中的Turbine配置，如下所示：
- en: '`server:port`: The main port used by the the Turbine HTTP'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server:port`：Turbine HTTP使用的主要端口'
- en: '`management:port`: Port of Turbine actuator endpoints:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`management:port`：Turbine执行器端点的端口：'
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Earlier, we have added the User and Restaurant services in a cluster using the
    `turbine.aggregator.clusterConfig` property. Here, values are in uppercase because
    Eureka returns the service names in capital letters. Also, the `turbine.appConfig`
    property contains the list of the Eureka service IDs that will be used by the
    Turbine to look up instances. Please be aware that the preceding steps always
    create the respective servers with default configurations. If required, you can
    override the default configuration with specific settings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`turbine.aggregator.clusterConfig`属性将用户和餐厅服务添加到集群中。这里，值都是大写，因为Eureka以大写字母返回服务名称。此外，`turbine.appConfig`属性包含Turbine用于查找实例的Eureka服务ID列表。请注意，前面的步骤总是使用默认配置创建相应的服务器。如果需要，可以使用特定设置覆盖默认配置。
- en: Building and running the OTRS application
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行OTRS应用程序
- en: 'Build all of the projects using `mvn clean install` using the following file:
    `..\Chapter5 \pom.xml`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下文件构建所有项目：`mvn clean install` `..\Chapter5 \pom.xml`。
- en: 'The output should look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, on command prompt, go to `<path to source>/6392_chapter5` and run the
    following commands:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在命令提示符上，转到`<path to source>/6392_chapter5`并运行以下命令：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note: Before starting the Zuul service, please make sure that all of the services
    are up in the Eureka dashboard: `http://localhost:8761/`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在启动Zuul服务之前，请确保Eureka仪表板中的所有服务都正常运行：`http://localhost:8761/`：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, check the Eureka dashboard that all applications should be up. Then,
    perform the testing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查Eureka仪表板，所有应用程序应该正常运行。然后进行测试。
- en: Microservice deployment using containers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器进行微服务部署
- en: You might have got the point about Docker after reading [Chapter 1](8ea8ade6-8194-4739-94ed-92454e884d9d.xhtml),
    *A Solution Approach*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第1章](8ea8ade6-8194-4739-94ed-92454e884d9d.xhtml) *解决方案方法*后，您可能已经了解了Docker的相关内容。
- en: A Docker container provides a lightweight runtime environment, consisting of
    the core features of a virtual machine and the isolated services of operating
    systems, known as a Docker image. Docker makes the packaging and execution of
    microservices easier and smoother. Each operating system can have multiple Dockers,
    and each Docker can run single application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器提供了一个轻量级的运行时环境，包括虚拟机的核心特性和操作系统的隔离服务，称为Docker镜像。Docker使得微服务的打包和执行变得更加简单和顺畅。每个操作系统可以有多个Docker，每个Docker可以运行单个应用程序。
- en: Installation and configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置
- en: Docker needs a virtualized server if you are not using a Linux OS. You can install
    VirtualBox or similar tools such as Docker Toolbox to make it work for you. The
    Docker installation page gives more details about it and lets you know how to
    do it. So, leave it to the Docker installation guide available on Docker's website.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用Linux操作系统，Docker需要一个虚拟化服务器。您可以安装VirtualBox或类似的工具，如Docker Toolbox，使其为您工作。Docker安装页面提供了更多关于此的详细信息，并告诉您如何操作。因此，请参考Docker网站上提供的Docker安装指南。
- en: 'You can install Docker, based on your platform, by following the instructions
    given at: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据您的平台在[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)上的说明安装Docker。
- en: DockerToolbox-1.9.1f was the latest version available at the time of writing.
    This is the version we used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，DockerToolbox-1.9.1f是最新版本。这是我们使用的版本。
- en: Docker machine with 4 GB
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存为4GB的Docker机器
- en: 'Default machines are created with 2 GB of memory. We''ll recreate a Docker
    machine with 4 GB of memory:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认机器创建时内存为2GB。我们将重新创建一个内存为4GB的Docker机器：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Building Docker images with Maven
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven构建Docker镜像
- en: 'There are various Docker Maven plugins that can be used:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种Docker Maven插件可供使用：
- en: '[https://github.com/rhuss/docker-maven-plugin](https://github.com/rhuss/docker-maven-plugin)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/rhuss/docker-maven-plugin](https://github.com/rhuss/docker-maven-plugin)'
- en: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)'
- en: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)'
- en: You can use any of these, based on your choice. I found the Docker Maven plugin
    by `@rhuss` to be best suited for us. It is updated regularly and has many extra
    features when compared to the others.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据自己的选择使用其中任何一个。我发现`@rhuss`的Docker Maven插件最适合我们。与其他插件相比，它经常更新并具有许多额外功能。
- en: 'We need to introduce the Docker Spring profile in `application.yml` before
    we start discussing the configuration of `docker-maven-plugin`. It will make our
    job easier when building services for various platforms. We need to configure
    the following four properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论`docker-maven-plugin`的配置之前，我们需要在`application.yml`中引入Docker Spring配置文件。这将使我们在为各种平台构建服务时更加轻松。我们需要配置以下四个属性：
- en: We'll use the Spring profile identified as Docker.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Spring配置文件标识为Docker。
- en: There won't be any conflict of ports among embedded Tomcat, since services will
    be executed in their own respective containers. We can now use port `8080`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式Tomcat之间不会有端口冲突，因为服务将在它们自己的容器中执行。我们现在可以使用端口`8080`。
- en: We will prefer to use an IP address to register our services in Eureka. Therefore,
    the Eureka instance property `preferIpAddress` will be set to `true`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用IP地址来注册我们的Eureka服务。因此，Eureka实例属性`preferIpAddress`将设置为`true`。
- en: Finally, we'll use the Eureka server hostname in `serviceUrl:defaultZone`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将在`serviceUrl:defaultZone`中使用Eureka服务器主机名。
- en: 'To add a Spring profile in your project, add the following lines in `application.yml`
    after the existing content:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中添加Spring配置文件，请在现有内容之后的`application.yml`中添加以下行：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `mvn -P docker clean package` command will generate the `service` JAR with
    Tomcat's `8080` port and will get registered on the Eureka Server with the hostname
    `eureka`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn -P docker clean package`命令将生成带有Tomcat的`8080`端口的`service` JAR，并将在Eureka服务器上注册主机名为`eureka`。'
- en: 'Now, let''s configure the `docker-maven-plugin` to build the image with our
    restaurant microservice. This plugin has to create a Dockerfile first. The Dockerfile
    is configured in two places—in the `pom.xml` and `docker-assembly.xml` files.
    We''ll use the following plugin configuration in `pom.xml`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置`docker-maven-plugin`来构建我们的餐厅微服务镜像。这个插件必须首先创建一个Dockerfile。Dockerfile在`pom.xml`和`docker-assembly.xml`文件中进行配置。我们将在`pom.xml`中使用以下插件配置：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a Dockerfile before the Docker Maven plugin configuration that extends
    the JRE 8 (`java:8-jre`) base image. This exposes ports `8080` and `8081`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Maven插件配置之前创建一个Dockerfile，它继承自JRE 8 (`java:8-jre`)基础镜像。这会暴露端口`8080`和`8081`。
- en: 'Next, we''ll configure the `docker-assembly.xml` file, which tells the plugin
    which files should be put into the container. It will be placed under the `src/main/docker`
    directory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置`docker-assembly.xml`文件，告诉插件应该将哪些文件放入容器中。它将放置在`src/main/docker`目录下：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding assembly, adds the `service` JAR and the `docker-config.yml`
    file in the generated Dockerfile. This Dockerfile is located under `target/docker/`.
    On opening this file, you will find the content to be similar to this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件将在生成的Dockerfile中添加`service` JAR和`docker-config.yml`文件。这个Dockerfile位于`target/docker/`下。打开这个文件，您会发现内容与以下内容类似：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding file can be found in the `restaurant-service\target\docker\sousharm\restaurant-service\PACKT-SNAPSHOT\build`
    directory. The `build` directory also contains the `maven` directory, which contains
    everything mentioned in the `docker-assembly.xml` file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件可以在`restaurant-service\target\docker\sousharm\restaurant-service\PACKT-SNAPSHOT\build`目录中找到。`build`目录还包含`maven`目录，其中包含`docker-assembly.xml`文件中提到的所有内容。
- en: 'Let''s build the Docker image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建Docker镜像：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once this command completes, we can validate the image in the local repository
    using Docker images, or by running the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此命令后，我们可以通过Docker images验证本地存储库中的镜像，或者通过运行以下命令来验证：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use `-it` to execute this command in the foreground, in place of `-d`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-it`在前台执行此命令，而不是使用`-d`。
- en: Running Docker using Maven
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven运行Docker
- en: 'To execute a Docker image with Maven, we need to add the following configuration
    in the `pom.xml` file. The `<run>` block, to be put where we marked the `To Do`
    under the image block of `docker-maven-plugin` section in the `pom.xml` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Maven执行Docker镜像，我们需要在`pom.xml`文件中添加以下配置。`<run>`块，放在`pom.xml`文件中`docker-maven-plugin`部分的`image`块下的`To
    Do`标记处：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have defined the parameters for running our Restaurant service container.
    We have mapped Docker container ports `8080` and `8081` to the host system's ports,
    which allows us to access the service. Similarly, we have also bound the container's
    `log` directory to the host system's `<home>/logs` directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经定义了运行我们的Restaurant服务容器的参数。我们已经将Docker容器端口`8080`和`8081`映射到主机系统的端口，这允许我们访问服务。同样，我们还将容器的`log`目录绑定到主机系统的`<home>/logs`目录。
- en: The Docker Maven plugin can detect whether the container has finished starting
    up by polling the ping URL of the admin backend until it receives an answer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Maven插件可以通过轮询管理后端的ping URL来检测容器是否已经启动完成。
- en: Please note that the Docker host is not localhost if you are using DockerToolbox
    or boot2docker on Windows or MacOS X. You can check the Docker image IP by executing
    `docker-machine ip default`. It is also shown while starting up.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在Windows或MacOS X上使用DockerToolbox或boot2docker，则Docker主机不是localhost。您可以通过执行`docker-machine
    ip default`来检查Docker镜像IP。它也会在启动时显示。
- en: 'The Docker container is ready to start. Use the following command to start
    it using Maven:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器已准备就绪。使用以下命令使用Maven启动它：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Integration testing with Docker
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker进行集成测试
- en: 'Starting and stopping a Docker container can be done by binding the following
    executions to the `docker-maven-plugin` life cycle phase in `pom.xml`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和停止Docker容器可以通过将以下执行绑定到`pom.xml`中`docker-maven-plugin`的生命周期阶段来完成：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will now configure the Failsafe plugin to perform integration testing with
    Docker. This allows us to execute the integration tests. We are passing the service
    URL in the `service.url` tag, so that our integration test can use it to perform
    integration testing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将配置Failsafe插件以使用Docker执行集成测试。这允许我们执行集成测试。我们正在通过`service.url`标记传递服务URL，以便我们的集成测试可以使用它来执行集成测试。
- en: 'We''ll use the `DockerIntegrationTest` marker to mark our Docker integration
    tests. It is defined as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`DockerIntegrationTest`标记来标记我们的Docker集成测试。它定义如下：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Look at the following integration `plugin` code. You can see that `DockerIT`
    is configured for the inclusion of integration tests (Failsafe plugin), whereas
    it is used for excluding in unit tests (Surefire plugin):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下集成`plugin`代码。您可以看到`DockerIT`被配置为包含集成测试（Failsafe plugin），而在单元测试中被用于排除（Surefire
    plugin）：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A simple integration test looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的集成测试看起来像这样：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can use the following command to perform integration testing using Maven
    (please make sure to run `mvn clean install` from the root of the project directory
    before running integration tests):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令使用Maven执行集成测试（请确保在运行集成测试之前从项目目录的根目录运行`mvn clean install`）：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pushing the image to a registry
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: 'Add the following tags under `docker-maven-plugin` to publish the Docker image
    to the Docker hub:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-maven-plugin`下添加以下标记以将Docker镜像发布到Docker hub：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can skip JAR publishing by using the following configuration for `maven-deploy-plugin`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`maven-deploy-plugin`的以下配置来跳过JAR发布：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Publishing a Docker image in the Docker hub also requires a username and password:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker hub中发布Docker镜像还需要用户名和密码：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also push a Docker image to your own Docker registry. To do this, add
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将Docker镜像推送到自己的Docker注册表。要做到这一点，添加
- en: the `docker.registry.name` tag, as shown in the following code. For example,
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示的`docker.registry.name`标记。例如，
- en: if your Docker registry is available at `xyz.domain.com` on port `4994`, then
    define
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Docker注册表位于端口`4994`上的`xyz.domain.com`，则定义
- en: 'it by adding the following line of code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码行来完成这项工作：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This does the job and we can not only deploy, but also test our Dockerized service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果很好，我们不仅可以部署，还可以测试我们的Docker化服务。
- en: Managing Docker containers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Docker容器
- en: Each microservice will have its own Docker container. Therefore, we'll use `Docker
    Compose` to manage our containers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务将有自己的Docker容器。因此，我们将使用`Docker Compose`来管理我们的容器。
- en: Docker Compose will help us to specify the number of containers and how these
    will be executed. We can specify the Docker image, ports, and each container's
    links to other Docker containers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose将帮助我们指定容器的数量以及这些容器将如何执行。我们可以指定Docker镜像、端口以及每个容器与其他Docker容器的链接。
- en: 'We''ll create a file called `docker-compose.yml` in our root project directory
    and add all of the microservice containers to it. We''ll first specify the Eureka
    server, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在根项目目录中创建一个名为`docker-compose.yml`的文件，并将所有微服务容器添加到其中。我们将首先指定Eureka服务器，如下所示：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `image` represents the published Docker image for the Eureka server and
    `ports` represents the mapping between the host being used for executing the Docker
    image and the Docker host.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`image`代表Eureka服务器的已发布Docker镜像，`ports`代表用于执行Docker镜像的主机与Docker主机之间的映射。
- en: This will start the Eureka server and publish the specified ports for external
    access.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Eureka服务器并发布指定的端口以供外部访问。
- en: 'Now our services can use these containers (dependent containers such as Eureka).
    Let''s see how `restaurant-service` can be linked to dependent containers. It
    is simple; just use the `links` directive:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务可以使用这些容器（例如Eureka这样的依赖容器）。让我们看看`restaurant-service`如何链接到依赖容器。很简单；只需使用`links`指令：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding links declaration will update the `/etc/hosts` file in the `restaurant-service`
    container with one line per service that the `restaurant-service` depends on (let''s
    assume the `security` container is also linked), for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述链接声明将更新`restaurant-service`容器中的`/etc/hosts`文件，每个服务占用一行（假设`security`容器也被链接），例如：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you don't have a Docker local registry set up, then please do this first
    for issueless or smoother execution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有设置Docker本地注册表，请先进行设置，以确保执行无误或更顺畅。
- en: 'Build the docker local registry by running the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建Docker本地注册表：
- en: '**docker run -d -p 5000:5000 --restart=always --name registry registry:2**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker run -d -p 5000:5000 --restart=always --name registry registry:2**'
- en: 'Then, perform push and pull commands for the local images:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对本地镜像执行推送和拉取命令：
- en: '**docker push localhost:5000/sourabhh/restaurant-service:PACKT- SNAPSHOT**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker push localhost:5000/sourabhh/restaurant-service:PACKT- SNAPSHOT**'
- en: '**docker-compose pull**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker-compose pull**'
- en: 'Finally, execute docker-compose:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行docker-compose：
- en: '**docker-compose up -d**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker-compose up -d**'
- en: 'Once all of the microservice containers (service and server) are configured,
    we can start all Docker containers with a single command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有微服务容器（服务和服务器）都配置好，我们可以用一个命令启动所有Docker容器：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will start up all Docker containers configured in Docker Composer. The
    following command will list them:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Docker Composer中配置的所有Docker容器。以下命令将列出它们：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also check Docker image logs using the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令检查Docker镜像日志：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: References
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'The following links will give you more information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将为您提供更多信息：
- en: '**Netflix** **Ribbon**: [https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix** **Ribbon**: [https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)'
- en: '**Netflix** **Zuul**: [https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix** **Zuul**: [https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)'
- en: '**RabbitMQ**: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)'
- en: '**Hystrix**: [https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hystrix**: [https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)'
- en: '**Turbine**: [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Turbine**: [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)'
- en: '**Docker**: [https://www.docker.com/](https://www.docker.com/)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**: [https://www.docker.com/](https://www.docker.com/)'
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have learned about various microservice management features:
    load balancing, edge (gateway) servers, circuit breakers, and monitoring. You
    should now know how to implement load balancing and routing after going through
    this chapter. We have also learned how edge servers can be set up and configured.
    The failsafe mechanism is another important part that you have learned in this
    chapter. Deployment can be made simple by using Docker or any other container.
    Docker was demonstrated and integrated using Maven Build.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了各种微服务管理功能：负载平衡、边缘（网关）服务器、断路器和监控。通过本章的学习，您现在应该知道如何实现负载平衡和路由。我们还学习了如何设置和配置边缘服务器。容错机制是本章中您学到的另一个重要部分。使用Docker或任何其他容器可以简化部署。使用Maven
    Build演示并集成了Docker。
- en: From a testing point of view, we performed the integration testing on the Docker
    image of the service. We also explored the way we can write clients such as `RestTemplate`
    and Netflix Feign.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，我们对服务的Docker镜像进行了集成测试。我们还探讨了如何编写客户端，比如`RestTemplate`和Netflix Feign。
- en: In the next chapter, we will learn to secure the microservices with respect
    to authentication and authorization. We will also explore the other aspects of
    microservice securities.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在认证和授权方面保护微服务。我们还将探讨微服务安全的其他方面。

- en: Securing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, microservices are the components that we deploy in on-premises
    or cloud infrastructures. Microservices may offer APIs or web applications. Our
    sample application, OTRS, offers APIs. This chapter will focus on how to secure
    these APIs using Spring Security and Spring OAuth2\. We'll also focus on OAuth
    2.0 fundamentals, using OAuth 2.0 to secure the OTRS APIs. For more understanding
    on securing REST APIs, you can refer to the *RESTful Java Web Services Security,*
    *Packt Publishing* book. You can also refer to the *Spring Security*, *Packt Publishing*
    video for more information on Spring Security. We'll also learn about cross-origin
    request site filters and cross-site scripting blockers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Secure Socket Layer (SSL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Secure Socket Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the **Hyper Text Transfer Protocol** (**HTTP**). HTTP transfers
    data in plain text, but data transfer over the internet in plain text is not a
    good idea at all. It makes hacker's jobs easy and allows them to get your private
    information, such as your user ID, passwords, and credit card details easily using
    a packet sniffer.
  prefs: []
  type: TYPE_NORMAL
- en: We definitely don't want to compromise user data, so we will provide the most
    secure way to access our web application. Therefore, we need to encrypt the information
    that is exchanged between the end user and our application. We'll use **Secure
    Socket Layer** (**SSL**) or **Transport Security Layer** (**TSL**) to encrypt
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSL is a protocol designed to provide security (encryption) for network communications.
    HTTP associates with SSL to provide the secure implementation of HTTP, known as
    **Hyper Text Transfer Protocol Secure**, or **Hyper Text Transfer Protocol over
    SSL** (**HTTPS**). HTTPS makes sure that the privacy and integrity of the exchanged
    data is protected. It also ensures the authenticity of websites visited. This
    security centers around the distribution of signed digital certificates between
    the server hosting the application, the end user''s machine, and a third-party
    trust store server. Let''s see how this process takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: The end user sends the request to the web application, for example [http://twitter.com](http://twitter.com),
    using a web browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On receiving the request, the server redirects the browser to [https://twitter.com](https://twitter.com)
    using the HTTP code 302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end user's browser connects to [https://twitter.com](https://twitter.com)
    and, in response, the server provides the certificate containing the digital signature
    to the end user's browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end user's browser receives this certificate and checks it against a list
    of trusted **certificate authority** (**CA**) for verification
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the certificate gets verified all the way to the root CA, an encrypted
    communication is established between the end user''s browser and the application
    hosting server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a03a2790-bdc3-48ec-8ce6-d59edc13a93a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Secure HTTP communication
  prefs: []
  type: TYPE_NORMAL
- en: Although SSL ensures security in terms of encryption and web application authenticity,
    it does not safeguard against phishing and other attacks. Professional hackers
    can decrypt information sent using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after going over the basics of SSL, let's implement it for our sample OTRS
    project. We don't need to implement SSL for all microservices. All microservices
    will be accessed using our proxy or Edge server; Zuul-Server by the external environment,
    except our new microservice, security-service, which we will introduce in this
    chapter for authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll set up SSL in an Edge server. We need to have the keystore that
    is required for enabling SSL in embedded Tomcat. We''ll use the self-signed certificate
    for demonstration. We''ll use Java keytool to generate the keystore using the
    following command. You can use any other tool also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It asks for information such as name, address details, organization, and so
    on (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd90065-6c21-4b90-b5e8-baa0af4d1e09.png)'
  prefs: []
  type: TYPE_IMG
- en: The keytool generates keys
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware of the following points to ensure the proper functioning of self-signed
    certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `-ext` to define **Subject Alternative Names** (**SANs**). You can also
    use an IP (for example, `san=ip:190.19.0.11`). Earlier, use of the hostname of
    the machine, where application deployment takes place, was being used as most
    **common name** (**CN**). It prevents the `java.security.cert.CertificateException`
    from returning `No name matching localhost found`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a browser or OpenSSL to download the certificate. Add the newly
    generated certificate to the `cacerts` keystore, located at `jre/lib/security/cacerts`
    inside the active `JDK/JRE` home directory, by using the `keytool -importcert`
    command. Note that `changeit` is the default password for the `cacerts` keystore.
    Run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Self-signed certificates can be used only for development and testing purposes.
    The use of these certificates in a production environment does not provide the
    required security. Always use the certificates provided and signed by trusted
    signing authorities in production environments. Store your private keys safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after putting the generated `keystore.jks` in the `src/main/resources`
    directory of the OTRS project, along with `application.yml`, we can update this
    information in the Edge server `application.yml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild the Zuul-Server JAR to use the HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The keystore file can be stored in the preceding class path in Tomcat version
    7.0.66+ and 8.0.28+. For older versions, you can use the path of the keystore
    file for the `server:ssl:key-store` value.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can configure SSL for other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing authentication and authorization is de facto for web applications.
    We'll discuss authentication and authorization in this section. The new paradigm
    that has evolved over the past few years is OAuth. We'll learn and use OAuth 2.0
    for implementation. OAuth is an open authorization mechanism, implemented in every
    major web application. Web applications can access each other's data by implementing
    the OAuth standard. It has become the most popular way to authenticate oneself
    for various web applications. For example, on [https://www.quora.com/](https://www.quora.com/),
    you can register and log in using your Google or Twitter login IDs. It is also
    more user friendly, as client applications (for example, [https://www.quora.com/](https://www.quora.com/))
    don't need to store the user's passwords. The end user does not need to remember
    one more user ID and password.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ba38134-b0a2-45eb-93b0-1908e43f3234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 example usage
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Internet** **Engineering Task Force** (**IETF**) governs the standards
    and specifications of OAuth. OAuth 1.0a was the most recent version before OAuth
    2.0 that was having a fix for the session-fixation security flaw in OAuth 1.0\.
    OAuth 1.0 and 1.0a are very different from OAuth 2.0\. OAuth 1.0 relies on security
    certificates and channel binding, whereas OAuth 2.0 does not support security
    certification and channel binding. It works completely on **Transport Layer Security**
    (**TLS**). Therefore, OAuth 2.0 does not provide backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The various uses of OAuth are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, it can be used for authentication. You might have seen it in various
    applications, displaying messages such as sign in using Facebook or a sign in
    using Twitter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications can use it to read data from other applications, such as by integrating
    a Facebook widget into the application, or having a Twitter feed on your blog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, the opposite of the previous point can be true: you enable other applications
    to access the end user''s data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 specification - concise details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll try to discuss and understand the OAuth 2.0 specifications in a concise
    manner. Let's first see how signing in using Twitter works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the process mentioned here was used at the time of writing,
    and may change in the future. However, this process describes one of the OAuth
    2.0 processes properly:'
  prefs: []
  type: TYPE_NORMAL
- en: The user visits the Quora home page, which shows various login options. We'll
    explore the process of the Continue with Twitter link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks on the Continue with Twitter link, Quora opens a new window
    (in Chrome) that redirects the user to the [www.twitter.com](http://www.twitter.com)
    application. During this process, few web applications redirect the user to the
    same opened tab/window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this new window/tab, the user signs in to [www.twitter.com](http://www.twitter.com)
    with their credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user has not already authorized the Quora application to use their data,
    Twitter asks for the user's permission to authorize Quora to access the user's
    information. If the user has already authorized Quora, then this step is skipped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After proper authentication, Twitter redirects the user to Quora's redirect
    URI with an authentication code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quora sends the client ID, client secret token, and authentication code (sent
    by Twitter in step five) to Twitter when the Quora redirect URI is entered in
    the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After validating these parameters, Twitter sends the access token to Quora.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is logged in to Quora on successful retrieval of the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quora may use this access token to retrieve user information from Twitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must be wondering how Twitter got Quora's redirect URI, client ID, and secret
    token. Quora works as a client application and Twitter as an authorization server.
    Quora, as a client, is registered on Twitter by using Twitter's OAuth implementation
    to use resource owner (end user) information. Quora provides a redirect URI at
    the time of registration. Twitter provides the client ID and secret token to Quora.
    In OAuth 2.0, user information is known as user resources. Twitter provides a
    resource server and an authorization server. We'll discuss more of these OAuth
    terms in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0c76112-52d8-4051-9e33-442567eee985.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 example process for signing in with Twitter
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four roles defined in the OAuth 2.0 specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7b76513b-0a74-4b4f-bbf6-b09037f4983e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 roles
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the example of a Quora sign in using Twitter, the Twitter user was the resource
    owner. The resource owner is an entity that owns the protected resources (for
    example, user handle, tweets, and so on) that are to be shared. This entity can
    be an application or a person. We call this entity the resource owner because
    it can only grant access to its resources. The specifications also define that
    when the resource owner is a person, they are referred to as an end user.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resource server hosts the protected resources. It should be capable of serving
    the access requests to these resources using access tokens. For the example of
    a Quora sign in using Twitter, Twitter is the resource server.
  prefs: []
  type: TYPE_NORMAL
- en: Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the example of the Quora sign in using Twitter, Quora is the client. The
    client is the application that makes access requests for protected resources to
    the resource server on behalf of the resource owner.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authorization server provides different tokens to the client application,
    such as access tokens or refresh tokens, only after the resource owner authenticates
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 does not provide any specifications for interactions between the resource
    server and the authorization server. Therefore, the authorization server and resource
    server can be on the same server, or can be on a separate one.
  prefs: []
  type: TYPE_NORMAL
- en: A single authorization server can also be used to issue access tokens for multiple
    resource servers.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 client registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client that communicates with the authorization server to obtain the access
    key for a resource should first be registered with the authorization server. The
    OAuth 2.0 specification does not specify the way a client registers with the authorization
    server. Registration does not require direct communication between the client
    and the authorization server. Registration can be done using self-issued or third-party-issued
    assertions. The authorization server obtains the required client properties using
    one of these assertions. Let''s see what the client properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: Client type (discussed in the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client redirect URI, as we discussed in the example of a Quora sign in using
    Twitter. This is one of the endpoints used for OAuth 2.0\. We will discuss other
    endpoints in the *Endpoints* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other information required by the authorization server, for example, client
    name, description, logo image, contact details, acceptance of legal terms and
    conditions, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of client described by the specification, based on their
    ability to maintain the confidentiality of client credentials: confidential and
    public. Client credentials are secret tokens issued by the authorization server
    to clients in order to communicate with them. The client types are described as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidential client type:** This is a client application that keeps passwords
    and other credentials securely or maintains them confidentially. In the example
    of a Quora sign in using Twitter, the Quora application server is secure and has
    restricted access implementation. Therefore, it is of the confidential client
    type. Only the Quora application administrator has access to client credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public client type:** These are client applications that do *not* keep passwords
    and other credentials securely or maintain them confidentially. Any native app
    on mobile or desktop, or an app that runs on a browser, are perfect examples of
    the public client type, as these keep client credentials embedded inside them.
    Hackers can crack these apps and the client credentials can be revealed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client can be a distributed component-based application, for example, it could
    have both a web browser component and a server-side component. In this case, both
    components will have different client types and security contexts. Such a client
    should register each component as a separate client if the authorization server
    does not support such clients.
  prefs: []
  type: TYPE_NORMAL
- en: Client profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the OAuth 2.0 client types, a client can have the following profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web application:** The Quora web application used in the example of a Quora
    sign-in using Twitter is a perfect example of an OAuth 2.0 web application client
    profile. Quora is a confidential client running on a web server. The resource
    owner (end user) accesses the Quora application (OAuth 2.0 client) on the browser
    (user agent) using a HTML user interface on their device (desktop/tablet/cell
    phone). The resource owner cannot access the client (Quora OAuth 2.0 client) credentials
    and access tokens, as these are stored on the web server. You can see this behavior
    in the diagram of the OAuth 2.0 sample flow. See steps six to eight in the following
    figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c9133c30-f9be-4f91-a386-04f8f57aa134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client web application profile
  prefs: []
  type: TYPE_NORMAL
- en: '**User agent-based application:** User agent-based applications are of the
    public client type. Here though, the application resides in the web server, but
    the resource owner downloads it on the user agent (for example, a web browser)
    and then executes the application. Here, the downloaded application that resides
    in the user agent on the resource owner''s device communicates with the authorization
    server. The resource owner can access the client credentials and access tokens.
    A gaming application is a good example of such an application profile. The user
    agent application flow is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4d954ef4-70f8-468d-8564-c67d37a3bb74.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client user agent application profile
  prefs: []
  type: TYPE_NORMAL
- en: '**Native application:** Native applications are similar to user agent-based
    applications, except these are installed on the resource owner''s device and executed
    natively, instead of being downloaded from the web server and then executed inside
    the user agent. Many native clients (mobile applications) you download on your
    mobile are of the native application type. Here, the platform makes sure that
    other applications on the device do not access the credentials and access tokens
    of other applications. In addition, native applications should not share client
    credentials and OAuth tokens with servers that communicate with native applications,
    as shown in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5ee3ee45-fea2-4a0a-b0f6-e3455073aa14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client native application profile
  prefs: []
  type: TYPE_NORMAL
- en: Client identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the authorization server's responsibility to provide a unique identifier
    to the registered client. This client identifier is a string representation of
    the information provided by the registered client. The authorization server needs
    to make sure that this identifier is unique. The authorization server should not
    use it on its own for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2.0 specification does not specify the size of the client identifier.
    The authorization server can set the size, and it should document the size of
    the client identifier it issues.
  prefs: []
  type: TYPE_NORMAL
- en: Client authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authorization server should authenticate the client based on their client
    type. The authorization server should determine the authentication method that
    suits and meets security requirements. It should only use one authentication method
    in each request.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the authorization server uses a set of client credentials, such as
    the client password and some key tokens, to authenticate confidential clients.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server may establish a client authentication method with public
    clients. However, it must not rely on this authentication method to identify the
    client, for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: A client possessing a client password can use basic HTTP authentication. OAuth
    2.0 does not recommend sending client credentials in the request body, but recommends
    using TLS and brute force attack protection on endpoints required for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 protocol endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An endpoint is nothing but a URI we use for REST or web components, such as
    Servlet or JSP. OAuth 2.0 defines three types of endpoints. Two are authorization
    server endpoints and one is a client endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization endpoint (authorization server endpoint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token endpoint (authorization server endpoint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection endpoint (client endpoint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This endpoint is responsible for verifying the identity of the resource owner
    and, once verified, obtaining the authorization grant. We'll discuss the authorization
    grant in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server requires TLS for the authorization endpoint. The endpoint
    URI must not include the fragment component. The authorization endpoint must support
    the HTTP `GET` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification does not specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The way the authorization server authenticates the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the client will receive the authorization endpoint URI. Normally, documentation
    contains the authorization endpoint URI, or the client obtains it at the time
    of registration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client calls the token endpoint to receive the access token by sending the
    authorization grant or refresh token. The token endpoint is used by all authorization
    grants except the implicit grant.
  prefs: []
  type: TYPE_NORMAL
- en: Like the authorization endpoint, the token endpoint also requires TLS. The client
    must use the HTTP `POST` method to make the request to the token endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Like the authorization endpoint, the specification does not specify how the
    client will receive the token endpoint URI.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The authorization server redirects the resource owner''s user agent (for example,
    a web browser) back to the client using the redirection endpoint, once the authorization
    endpoint''s interactions are completed between the resource owner and the authorization
    server. The client provides the redirection endpoint at the time of registration.
    The redirection endpoint must be an absolute URI and not contain a fragment component.
    The OAuth 2.0 endpoints are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91a2c588-bc2c-4ce5-8168-df96b8956dbf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 endpoints
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 grant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client requests an access token from the authorization server, based on
    the obtained authorization from the resource owner. The resource owner gives authorization
    in the form of an authorization grant. OAuth 2.0 defines four types of authorization
    grant:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource owner password credentials grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client credentials grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 also provides an extension mechanism to define additional grant types.
    You can explore this in the official OAuth 2.0 specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first sample flow that we discussed in the OAuth 2.0 example flow for signing
    in with Twitter depicts an authorization code grant. We''ll add a few more steps
    for the complete flow. As you know, after the eighth step, the end user logs in
    to the Quora application. Let''s assume the user is logging in to Quora for the
    first time and requests their Quora profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, the Quora user clicks on their Quora profile page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth client Quora requests the Quora user's (resource owner) resources
    (for example, Twitter profile photo, and so on) from the Twitter resource server
    and sends the access token received in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Twitter resource server verifies the access token using the Twitter authorization
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful validation of the access token, the Twitter resource server
    provides the requested resources to Quora (OAuth client).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quora uses these resources and displays the Quora profile page of the end user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Authorization code requests and responses**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at all of the steps (a total of 13) of the authorization code flow,
    as shown in the following figure, you can see that there are a total of two requests
    made by the client to the authorization server, and the authorization server provides
    two responses: one request-response for the authentication token and one request-response
    for the access token.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the parameters used for each of these requests and responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f9ef543-affa-4dc3-b2d0-a753398f89bc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant flow
  prefs: []
  type: TYPE_NORMAL
- en: 'The authorization request (step four) to the authorization endpoint URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `response_type` | Required | Code (this value must be used). |'
  prefs: []
  type: TYPE_TB
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  prefs: []
  type: TYPE_TB
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and callback (from the authorization server). The specification
    recommends it to protect against cross-site request forgery attacks. |'
  prefs: []
  type: TYPE_TB
- en: 'Authorization response (step five):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `code` | Required | Code (authorization code) generated by the authorization
    server.Code should be expired after it is generated; the maximum recommended lifetime
    is 10 minutes.The client must not use the code more than once.If the client uses
    it more than once, then the request must be denied and all previous tokens issued
    based on the code should be revoked.Code is bound to the client ID and redirect
    URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `state` | Required | It represents the ID issued by the authorization server
    to the client at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: 'Token request (step seven) to token endpoint URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `grant_type` | Required | `authorization_code` (this value must be used).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `code` | Required | Code (authorization code) received from the authorization
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect_uri` | Required | Required if it was included in the authorization
    code request and the values should match. |'
  prefs: []
  type: TYPE_TB
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: 'Token response (step 8):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  prefs: []
  type: TYPE_TB
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in their request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  prefs: []
  type: TYPE_TB
- en: 'Error response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  prefs: []
  type: TYPE_TB
- en: '| `error_description` | Optional | Short description of the error. |'
  prefs: []
  type: TYPE_TB
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  prefs: []
  type: TYPE_TB
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no authorization code steps involved in the implicit grant flow.
    It provides the implicit grant for authorization code. Except the authorization
    code step, everything is the same if you compare the implicit grant flow againstÂ the
    authorization code grant flow. Therefore, it is called implicit grant. Let''s
    find out its flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with the client
    ID, redirect URI, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user may need to authenticate if not already authenticated. On successful
    authentication and other input validation, the resource server sends the access
    token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server verifies the access token using the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application uses these resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicit grant requests and responses**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you looked at all of the steps (a total of six) of the implicit grant flow,
    you can see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the access token validation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the parameters used for each of these requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization request to the authorization endpoint URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `response_type` | Required | Token (this value must be used). |'
  prefs: []
  type: TYPE_TB
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  prefs: []
  type: TYPE_TB
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and the callback (from the authorization server). The
    specification recommends it to protect against cross-site request forgery attacks.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Access token response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  prefs: []
  type: TYPE_TB
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in the request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  prefs: []
  type: TYPE_TB
- en: '| `state` | Optional/Requried | Required if the state was passed in the client
    authorization request. |'
  prefs: []
  type: TYPE_TB
- en: 'Error response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  prefs: []
  type: TYPE_TB
- en: '| `error_description` | Optional | Short description of the error. |'
  prefs: []
  type: TYPE_TB
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  prefs: []
  type: TYPE_TB
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner password credentials grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This flow is normally used on mobile or desktops applications. In this grant
    flow, only two requests are made: one for requesting an access token and another
    for access token verification, similar to implicit grant flow. The only difference
    is the resource owner''s username and password are sent along with the access
    token request. (In implicit grant, which is normally on a browser, redirects the
    user to authenticate itself.) Let''s find out its flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with client ID,
    resource owner's username and password, and so on. On successful parameter validation,
    the resource server sends the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server verifies the access token using the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application uses these resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource owner's password credentials grant requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the previous section, in all of the steps (a total of five) of the
    resource owner password credential grant flow, you can see that there are a total
    of two requests made by the client to the authorization server, and the authorization
    server provides two responses: one request-response for the access token and one
    request-response for resource owner resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the parameters used for each of these requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access token request to the token endpoint URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `grant_type` | Required | Password (this value must be used). |'
  prefs: []
  type: TYPE_TB
- en: '| `username` | Required | Username of the resource owner. |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | Required | Password of the resource owner. |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  prefs: []
  type: TYPE_TB
- en: 'Access token response (step one):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  prefs: []
  type: TYPE_TB
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional parameter | Optional | Additional parameter. |'
  prefs: []
  type: TYPE_TB
- en: Client credentials grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, here, the client''s credentials are used instead of the
    user''s (resource owner''s). Except client credentials, it is very similar to
    the resource owner password credentials grant flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so one) with the grant
    type and scope. The client ID and secrets are added to the authorization header.
    On successful validation, the resource server sends the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server verifies the access token using the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application uses these resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client credentials grant requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: If you looked at all of the steps (a total of five) of the client credentials
    grant flow, you can
  prefs: []
  type: TYPE_NORMAL
- en: 'see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the resource that involves access
    token verification.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the parameters used for each of these requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access token request to the token endpoint URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `grant_type` | Required | `client_credentials` (this value must be used).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  prefs: []
  type: TYPE_TB
- en: 'Access token response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  prefs: []
  type: TYPE_TB
- en: OAuth implementation using Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth 2.0 is a way of securing APIs. Spring Security provides Spring Cloud Security
    and Spring Cloud OAuth2 components for implementing the grant flows we discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create one more service, a security-service, which will control authentication
    and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Maven project and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Spring Security and Spring Security OAuth 2 dependencies in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server. The `@EnableAuthorizationServer`
    annotation is another annotation we will use to enable the authorization server
    as per OAuth 2.0 specifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the security-service configuration in `application.yml`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`server.contextPath`: This denotes the context path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.user.password`: We''ll use the hardcoded password for this demonstration.
    You can reconfigure it for real use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our security server in place, we'll expose our APIs using the
    new `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll modify the Zuul-Server module to make it a resource server also. This
    can be done by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Spring Security and Spring Security OAuth 2 dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'to `pom.xml`. Here, the last two dependencies are required for enabling the
    Zuul-Server as a resource server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the Zuul-Server configuration in `application.yml`, as shown in the
    following code. The `application.yml` file will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `security.oauth2.resource.userInfoUri` property denotes the security
    service user URI. APIs are exposed to the external world using route configuration
    that points to API services.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our security server in place, we are exposing our APIs using
    the `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test and explore how it works for different OAuth 2.0 grant types.
  prefs: []
  type: TYPE_NORMAL
- en: We'll make use of the Postman extension to the Chrome browser to test the different
    flows.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will enter the following URL in our browser. A request for an authorization
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provide the client ID (by default, we have the hardcoded client registered
    in our security service), redirect URI, scope (hardcoded `apiAccess` value in
    security service), and state. You must be wondering about the `state` parameter.
    It contains the random number that we revalidate in response to prevent cross-site
    request forgery.
  prefs: []
  type: TYPE_NORMAL
- en: If the resource owner (user) is not already authenticated, it will ask for the
    username and password. Provide the username as `username` and the password as
    `password`; we have hardcoded these values in the security service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the login is successful, it will ask you to provide your (resource owner)
    approval:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1420332-d7fe-4fdb-8283-dda0ddcce291.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - resource grant approval
  prefs: []
  type: TYPE_NORMAL
- en: Select Approve and click on Authorize. This action will redirect the application
    to `http://localhost:7771/1?code=o8t4fi&state=1234`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it has returned the authorization code and state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll use this code to retrieve the access code, using the Postman Chrome
    extension. First, we''ll add the authorization header using Username as client
    and Password as `clientsecret`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78666832-c5a5-4bc3-add2-f7288380f37c.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - access token request - adding the authentication
  prefs: []
  type: TYPE_NORMAL
- en: This will add the Authorization header to the request with the value `Basic
    Y2xpZW50OmNsaWVudHNlY3JldA==`, which is a base-64 encoding of the 'client client-secret'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add a few other parameters to the request, as shown in the following
    screenshot, and then submit the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f80b3537-1b8e-4e59-8993-ca06c5b9197a.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - access token request and response
  prefs: []
  type: TYPE_NORMAL
- en: 'This returns the following response, as per the OAuth 2.0 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use this information to access the resources owned by the resource
    owner. For example, if `https://localhost:8765/api/restaurant/1` represents the
    restaurant with the ID of `1`, then it should return the respective restaurant
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Without the access token, if we enter the URL, it returns the error `Unauthorized`
    with the message `Full authentication is required to access this resource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s access this URL with the access token, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ad7dda0-294b-4576-a9b4-832beb4312e8.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - using the access token for API access
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added the Authorization header with the access token.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore implicit grant implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit grants are very similar to authorization code grants, except for the
    code grant step. If you remove the first stepâthe code grant step (where the client
    application receives the authorization token from the authorization server)âfrom
    the authorization code grant, the rest of the steps are the same. Let's check
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following URL and parameters in the browser and press Enter. Also,
    make sure to add basic authentication, with the client as `username` and the password
    as `password` if asked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are calling the authorization endpoint with the following request
    parameters: response type, client ID, redirect URI, scope, and state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the request is successful, the browser will be redirected to the following
    URL with new request parameters and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we receive the `access_token`, `token_type`, state, and expiry duration
    for the token. Now, we can make use of this access token to access the APIs, as
    used in the authorization code grant.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner password credential grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this grant, we provide `username` and `password` as parameters when requesting
    the access token, along with the `grant_type`, `client`, and `scope` parameters.
    We also need to use the client ID and secret to authenticate the request. These
    grant flows use client applications in place of browsers, and are normally used
    in mobile and desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following Postman tool screenshot, the authorization header has already
    been added using basic authentication with `client_id` and `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72fb8839-d705-47f9-84ea-8890276bfc61.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 resource owner password credentials grant - access token request and
    response
  prefs: []
  type: TYPE_NORMAL
- en: Once the access token is received by the client, it can be used in a similar
    way to how it is used in the authorization code grant.
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials grant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this flow, the client provides their own credentials and retrieves the access
    token. It does not use the resource owner's credentials and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, we directly enter the token endpoint
    with only two parameters: `grant_type` and `scope`. The authorization header is
    added using `client_id` and `client secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/972a2e60-28b1-423a-adde-38c2fa61afc2.png)'
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client credentials grant - access token request and response
  prefs: []
  type: TYPE_NORMAL
- en: You can use the access token similarly as it is explained for the authorization
    code grant.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*RESTful Java Web Services Security*, *RenÃ© EnrÃ­quez, AndrÃ©s Salazar C*, *Packt
    Publishing*: [https://www.packtpub.com/application-development/restful-java-web-services-security](https://www.packtpub.com/application-development/restful-java-web-services-security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spring Security [Video]*, *Packt Publishing*: [https://www.packtpub.com/application-development/spring-security-video](https://www.packtpub.com/application-development/spring-security-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 Authorization Framework: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Security: [http://projects.spring.io/spring-security](http://projects.spring.io/spring-security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring OAuth2: [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how important it is to have the TLS layer or
    HTTPS in place for all web traffic. We have added a self-signed certificate to
    our sample application. I would like to reiterate that, for a production application,
    you must use the certificates offered by certificate-signing authorities. We have
    also explored the fundamentals of OAuth 2.0 and various OAuth 2.0 grant flows.
    Different OAuth 2.0 grant flows are implemented using Spring Security and OAuth
    2.0\. In the next chapter, we'll implement the UI for the sample OTRS project
    and explore how all of the components work together.
  prefs: []
  type: TYPE_NORMAL

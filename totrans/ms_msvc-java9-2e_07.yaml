- en: Securing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护微服务
- en: As you know, microservices are the components that we deploy in on-premises
    or cloud infrastructures. Microservices may offer APIs or web applications. Our
    sample application, OTRS, offers APIs. This chapter will focus on how to secure
    these APIs using Spring Security and Spring OAuth2\. We'll also focus on OAuth
    2.0 fundamentals, using OAuth 2.0 to secure the OTRS APIs. For more understanding
    on securing REST APIs, you can refer to the *RESTful Java Web Services Security,*
    *Packt Publishing* book. You can also refer to the *Spring Security*, *Packt Publishing*
    video for more information on Spring Security. We'll also learn about cross-origin
    request site filters and cross-site scripting blockers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，微服务是我们部署在本地或云基础设施中的组件。微服务可能提供API或网络应用程序。我们的示例应用程序OTRS提供API。本章将重点介绍如何使用Spring
    Security和Spring OAuth2来保护这些API。我们还将重点介绍OAuth 2.0的基础知识，使用OAuth 2.0来保护OTRS的API。要了解有关保护REST
    API的更多信息，您可以参考*RESTful Java Web Services Security*，*Packt Publishing*书籍。您还可以参考*Spring
    Security*，*Packt Publishing*视频以获取有关Spring Security的更多信息。我们还将学习有关跨源请求站点过滤器和跨站点脚本阻止器的知识。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Enabling Secure Socket Layer (SSL)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用安全套接字层（SSL）
- en: Authentication and authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: OAuth 2.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: Enabling Secure Socket Layer
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用安全套接字层
- en: So far, we have used the **Hyper Text Transfer Protocol** (**HTTP**). HTTP transfers
    data in plain text, but data transfer over the internet in plain text is not a
    good idea at all. It makes hacker's jobs easy and allows them to get your private
    information, such as your user ID, passwords, and credit card details easily using
    a packet sniffer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了**超文本传输协议**（**HTTP**）。HTTP以纯文本传输数据，但在互联网上以纯文本传输数据绝对不是一个好主意。这使得黑客的工作变得容易，并允许他们使用数据包嗅探器轻松获取您的私人信息，例如用户ID、密码和信用卡详细信息。
- en: We definitely don't want to compromise user data, so we will provide the most
    secure way to access our web application. Therefore, we need to encrypt the information
    that is exchanged between the end user and our application. We'll use **Secure
    Socket Layer** (**SSL**) or **Transport Security Layer** (**TSL**) to encrypt
    the data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对不想 compromise 用户数据，因此我们将提供访问我们的网络应用程序的最安全方式。因此，我们需要加密最终用户和我们的应用程序之间交换的信息。我们将使用**安全套接字层**（**SSL**）或**传输安全层**（**TSL**）来加密数据。
- en: 'SSL is a protocol designed to provide security (encryption) for network communications.
    HTTP associates with SSL to provide the secure implementation of HTTP, known as
    **Hyper Text Transfer Protocol Secure**, or **Hyper Text Transfer Protocol over
    SSL** (**HTTPS**). HTTPS makes sure that the privacy and integrity of the exchanged
    data is protected. It also ensures the authenticity of websites visited. This
    security centers around the distribution of signed digital certificates between
    the server hosting the application, the end user''s machine, and a third-party
    trust store server. Let''s see how this process takes place:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SSL是一种旨在为网络通信提供安全（加密）的协议。HTTP与SSL相关联，以提供HTTP的安全实现，称为**超文本传输安全协议**，或**基于SSL的超文本传输协议**（**HTTPS**）。HTTPS确保交换数据的隐私和完整性得到保护。它还确保所访问的网站的真实性。这种安全性围绕着在托管应用程序的服务器、最终用户的计算机和第三方信任存储服务器之间分发签名数字证书。让我们看看这个过程是如何进行的：
- en: The end user sends the request to the web application, for example [http://twitter.com](http://twitter.com),
    using a web browser
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终用户使用Web浏览器向Web应用程序发送请求，例如[http://twitter.com](http://twitter.com)
- en: On receiving the request, the server redirects the browser to [https://twitter.com](https://twitter.com)
    using the HTTP code 302
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到请求后，服务器使用HTTP代码302将浏览器重定向到[https://twitter.com](https://twitter.com)
- en: The end user's browser connects to [https://twitter.com](https://twitter.com)
    and, in response, the server provides the certificate containing the digital signature
    to the end user's browser
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终用户的浏览器连接到[https://twitter.com](https://twitter.com)，作为响应，服务器向最终用户的浏览器提供包含数字签名的证书
- en: The end user's browser receives this certificate and checks it against a list
    of trusted **certificate authority** (**CA**) for verification
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终用户的浏览器接收到这个证书，并根据可信**证书颁发机构**（**CA**）的列表进行验证
- en: 'Once the certificate gets verified all the way to the root CA, an encrypted
    communication is established between the end user''s browser and the application
    hosting server:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦证书得到根CA的验证，最终用户的浏览器和应用程序托管服务器之间建立了加密通信：
- en: '![](img/a03a2790-bdc3-48ec-8ce6-d59edc13a93a.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a03a2790-bdc3-48ec-8ce6-d59edc13a93a.jpg)'
- en: Secure HTTP communication
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的HTTP通信
- en: Although SSL ensures security in terms of encryption and web application authenticity,
    it does not safeguard against phishing and other attacks. Professional hackers
    can decrypt information sent using HTTPS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SSL在加密和Web应用程序真实性方面确保安全，但它并不能防范钓鱼和其他攻击。专业黑客可以解密使用HTTPS发送的信息。
- en: Now, after going over the basics of SSL, let's implement it for our sample OTRS
    project. We don't need to implement SSL for all microservices. All microservices
    will be accessed using our proxy or Edge server; Zuul-Server by the external environment,
    except our new microservice, security-service, which we will introduce in this
    chapter for authentication and authorization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在了解了SSL的基础知识之后，让我们为我们的示例OTRS项目实施它。我们不需要为所有微服务实施SSL。所有微服务将通过我们的代理或边缘服务器访问；Zuul-Server由外部环境访问，除了我们在本章中介绍的新微服务security-service，用于身份验证和授权。
- en: 'First, we''ll set up SSL in an Edge server. We need to have the keystore that
    is required for enabling SSL in embedded Tomcat. We''ll use the self-signed certificate
    for demonstration. We''ll use Java keytool to generate the keystore using the
    following command. You can use any other tool also:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在边缘服务器中设置SSL。我们需要具有在嵌入式Tomcat中启用SSL所需的密钥库。我们将使用自签名证书进行演示。我们将使用Java keytool使用以下命令生成密钥库。您也可以使用任何其他工具：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It asks for information such as name, address details, organization, and so
    on (see the following screenshot):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd90065-6c21-4b90-b5e8-baa0af4d1e09.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: The keytool generates keys
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware of the following points to ensure the proper functioning of self-signed
    certificates:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Use `-ext` to define **Subject Alternative Names** (**SANs**). You can also
    use an IP (for example, `san=ip:190.19.0.11`). Earlier, use of the hostname of
    the machine, where application deployment takes place, was being used as most
    **common name** (**CN**). It prevents the `java.security.cert.CertificateException`
    from returning `No name matching localhost found`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a browser or OpenSSL to download the certificate. Add the newly
    generated certificate to the `cacerts` keystore, located at `jre/lib/security/cacerts`
    inside the active `JDK/JRE` home directory, by using the `keytool -importcert`
    command. Note that `changeit` is the default password for the `cacerts` keystore.
    Run the following command:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Self-signed certificates can be used only for development and testing purposes.
    The use of these certificates in a production environment does not provide the
    required security. Always use the certificates provided and signed by trusted
    signing authorities in production environments. Store your private keys safely.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after putting the generated `keystore.jks` in the `src/main/resources`
    directory of the OTRS project, along with `application.yml`, we can update this
    information in the Edge server `application.yml`, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rebuild the Zuul-Server JAR to use the HTTPS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The keystore file can be stored in the preceding class path in Tomcat version
    7.0.66+ and 8.0.28+. For older versions, you can use the path of the keystore
    file for the `server:ssl:key-store` value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can configure SSL for other microservices.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing authentication and authorization is de facto for web applications.
    We'll discuss authentication and authorization in this section. The new paradigm
    that has evolved over the past few years is OAuth. We'll learn and use OAuth 2.0
    for implementation. OAuth is an open authorization mechanism, implemented in every
    major web application. Web applications can access each other's data by implementing
    the OAuth standard. It has become the most popular way to authenticate oneself
    for various web applications. For example, on [https://www.quora.com/](https://www.quora.com/),
    you can register and log in using your Google or Twitter login IDs. It is also
    more user friendly, as client applications (for example, [https://www.quora.com/](https://www.quora.com/))
    don't need to store the user's passwords. The end user does not need to remember
    one more user ID and password.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ba38134-b0a2-45eb-93b0-1908e43f3234.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 example usage
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Internet** **Engineering Task Force** (**IETF**) governs the standards
    and specifications of OAuth. OAuth 1.0a was the most recent version before OAuth
    2.0 that was having a fix for the session-fixation security flaw in OAuth 1.0\.
    OAuth 1.0 and 1.0a are very different from OAuth 2.0\. OAuth 1.0 relies on security
    certificates and channel binding, whereas OAuth 2.0 does not support security
    certification and channel binding. It works completely on **Transport Layer Security**
    (**TLS**). Therefore, OAuth 2.0 does not provide backward compatibility.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Usage of OAuth
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The various uses of OAuth are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, it can be used for authentication. You might have seen it in various
    applications, displaying messages such as sign in using Facebook or a sign in
    using Twitter.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications can use it to read data from other applications, such as by integrating
    a Facebook widget into the application, or having a Twitter feed on your blog.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, the opposite of the previous point can be true: you enable other applications
    to access the end user''s data.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 specification - concise details
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll try to discuss and understand the OAuth 2.0 specifications in a concise
    manner. Let's first see how signing in using Twitter works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试以简洁的方式讨论和理解OAuth 2.0规范。让我们首先看看使用Twitter登录的工作原理。
- en: 'Please note that the process mentioned here was used at the time of writing,
    and may change in the future. However, this process describes one of the OAuth
    2.0 processes properly:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处提到的流程是在撰写时使用的，可能会在将来发生变化。但是，此流程正确描述了OAuth 2.0流程之一：
- en: The user visits the Quora home page, which shows various login options. We'll
    explore the process of the Continue with Twitter link.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问Quora主页，显示各种登录选项。我们将探讨继续使用Twitter链接的过程。
- en: When the user clicks on the Continue with Twitter link, Quora opens a new window
    (in Chrome) that redirects the user to the [www.twitter.com](http://www.twitter.com)
    application. During this process, few web applications redirect the user to the
    same opened tab/window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击继续使用Twitter链接时，Quora会在新窗口（在Chrome中）中打开一个重定向用户到[www.twitter.com](http://www.twitter.com)应用程序的页面。在此过程中，一些Web应用程序会将用户重定向到同一打开的标签/窗口。
- en: In this new window/tab, the user signs in to [www.twitter.com](http://www.twitter.com)
    with their credentials.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的窗口/标签中，用户使用他们的凭据登录到[www.twitter.com](http://www.twitter.com)。
- en: If the user has not already authorized the Quora application to use their data,
    Twitter asks for the user's permission to authorize Quora to access the user's
    information. If the user has already authorized Quora, then this step is skipped.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尚未授权Quora应用程序使用其数据，Twitter会要求用户授权Quora访问用户信息。如果用户已经授权了Quora，则跳过此步骤。
- en: After proper authentication, Twitter redirects the user to Quora's redirect
    URI with an authentication code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过适当的身份验证后，Twitter将用户重定向到带有认证代码的Quora重定向URI。
- en: Quora sends the client ID, client secret token, and authentication code (sent
    by Twitter in step five) to Twitter when the Quora redirect URI is entered in
    the browser.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Quora重定向URI在浏览器中输入时，Quora将客户端ID、客户端秘密令牌和认证代码（由Twitter在第五步发送）发送给Twitter。
- en: After validating these parameters, Twitter sends the access token to Quora.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证这些参数之后，Twitter将访问令牌发送给Quora。
- en: The user is logged in to Quora on successful retrieval of the access token.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户成功检索访问令牌后，将登录到Quora。
- en: Quora may use this access token to retrieve user information from Twitter.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quora可以使用此访问令牌从Twitter检索用户信息。
- en: You must be wondering how Twitter got Quora's redirect URI, client ID, and secret
    token. Quora works as a client application and Twitter as an authorization server.
    Quora, as a client, is registered on Twitter by using Twitter's OAuth implementation
    to use resource owner (end user) information. Quora provides a redirect URI at
    the time of registration. Twitter provides the client ID and secret token to Quora.
    In OAuth 2.0, user information is known as user resources. Twitter provides a
    resource server and an authorization server. We'll discuss more of these OAuth
    terms in the following sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道Twitter如何获得Quora的重定向URI、客户端ID和秘密令牌。Quora作为客户端应用程序，Twitter作为授权服务器。Quora作为客户端，通过使用Twitter的OAuth实现在Twitter上注册，以使用资源所有者（最终用户）信息。Quora在注册时提供重定向URI。Twitter向Quora提供客户端ID和秘密令牌。在OAuth
    2.0中，用户信息称为用户资源。Twitter提供资源服务器和授权服务器。我们将在以下部分讨论更多这些OAuth术语。
- en: '![](img/b0c76112-52d8-4051-9e33-442567eee985.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0c76112-52d8-4051-9e33-442567eee985.jpg)'
- en: OAuth 2.0 example process for signing in with Twitter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Twitter进行登录的OAuth 2.0示例流程
- en: OAuth 2.0 roles
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0角色
- en: 'There are four roles defined in the OAuth 2.0 specifications:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范中定义了四个角色：
- en: Resource owner
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者
- en: Resource server
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源服务器
- en: Client
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端
- en: Authorization server
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器
- en: '![](img/7b76513b-0a74-4b4f-bbf6-b09037f4983e.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b76513b-0a74-4b4f-bbf6-b09037f4983e.jpg)'
- en: OAuth 2.0 roles
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0角色
- en: Resource owner
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者
- en: For the example of a Quora sign in using Twitter, the Twitter user was the resource
    owner. The resource owner is an entity that owns the protected resources (for
    example, user handle, tweets, and so on) that are to be shared. This entity can
    be an application or a person. We call this entity the resource owner because
    it can only grant access to its resources. The specifications also define that
    when the resource owner is a person, they are referred to as an end user.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以Quora使用Twitter进行登录的示例中，Twitter用户是资源所有者。资源所有者是拥有受保护资源（例如用户句柄、推文等）的实体，这些资源将被共享。这个实体可以是应用程序或个人。我们称这个实体为资源所有者，因为它只能授予对其资源的访问权限。规范还定义了当资源所有者是一个人时，他们被称为最终用户。
- en: Resource server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器
- en: The resource server hosts the protected resources. It should be capable of serving
    the access requests to these resources using access tokens. For the example of
    a Quora sign in using Twitter, Twitter is the resource server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 资源服务器托管受保护的资源。它应该能够使用访问令牌为这些资源提供访问请求。以Quora使用Twitter进行登录的示例中，Twitter是资源服务器。
- en: Client
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: For the example of the Quora sign in using Twitter, Quora is the client. The
    client is the application that makes access requests for protected resources to
    the resource server on behalf of the resource owner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以Quora使用Twitter进行登录的示例，Quora是客户端。客户端是代表资源所有者向资源服务器请求受保护资源的应用程序。
- en: Authorization server
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权服务器
- en: The authorization server provides different tokens to the client application,
    such as access tokens or refresh tokens, only after the resource owner authenticates
    themselves.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器仅在资源所有者进行身份验证后，才向客户端应用程序提供不同的令牌，例如访问令牌或刷新令牌。
- en: OAuth 2.0 does not provide any specifications for interactions between the resource
    server and the authorization server. Therefore, the authorization server and resource
    server can be on the same server, or can be on a separate one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0不提供资源服务器和授权服务器之间的交互规范。因此，授权服务器和资源服务器可以在同一台服务器上，也可以在不同的服务器上。
- en: A single authorization server can also be used to issue access tokens for multiple
    resource servers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单个授权服务器也可以用于为多个资源服务器发放访问令牌。
- en: OAuth 2.0 client registration
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0客户端注册
- en: 'The client that communicates with the authorization server to obtain the access
    key for a resource should first be registered with the authorization server. The
    OAuth 2.0 specification does not specify the way a client registers with the authorization
    server. Registration does not require direct communication between the client
    and the authorization server. Registration can be done using self-issued or third-party-issued
    assertions. The authorization server obtains the required client properties using
    one of these assertions. Let''s see what the client properties are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与授权服务器通信以获取资源的访问密钥的客户端应首先向授权服务器注册。OAuth 2.0规范未指定客户端向授权服务器注册的方式。注册不需要客户端和授权服务器之间的直接通信。注册可以使用自行发行或第三方发行的断言来完成。授权服务器使用其中一种断言获取所需的客户端属性。让我们看看客户端属性是什么：
- en: Client type (discussed in the next section).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端类型（在下一节中讨论）。
- en: Client redirect URI, as we discussed in the example of a Quora sign in using
    Twitter. This is one of the endpoints used for OAuth 2.0\. We will discuss other
    endpoints in the *Endpoints* section.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端重定向URI，就像我们在Quora使用Twitter登录的示例中讨论的那样。这是OAuth 2.0中使用的端点之一。我们将在*端点*部分讨论其他端点。
- en: Any other information required by the authorization server, for example, client
    name, description, logo image, contact details, acceptance of legal terms and
    conditions, and so on.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器需要的任何其他信息，例如客户端名称、描述、徽标图像、联系方式、接受法律条款和条件等。
- en: Client types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端类型
- en: 'There are two types of client described by the specification, based on their
    ability to maintain the confidentiality of client credentials: confidential and
    public. Client credentials are secret tokens issued by the authorization server
    to clients in order to communicate with them. The client types are described as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范描述了两种客户端类型，根据它们保持客户端凭据保密的能力：机密和公共。客户端凭据是授权服务器发给客户端的秘密令牌，以便与它们通信。客户端类型描述如下：
- en: '**Confidential client type:** This is a client application that keeps passwords
    and other credentials securely or maintains them confidentially. In the example
    of a Quora sign in using Twitter, the Quora application server is secure and has
    restricted access implementation. Therefore, it is of the confidential client
    type. Only the Quora application administrator has access to client credentials.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密客户端类型：**这是一个安全地保留密码和其他凭据或保密地维护它们的客户端应用程序。在使用Twitter登录Quora的示例中，Quora应用服务器是安全的，并且实施了受限访问。因此，它属于机密客户端类型。只有Quora应用程序管理员可以访问客户端凭据。'
- en: '**Public client type:** These are client applications that do *not* keep passwords
    and other credentials securely or maintain them confidentially. Any native app
    on mobile or desktop, or an app that runs on a browser, are perfect examples of
    the public client type, as these keep client credentials embedded inside them.
    Hackers can crack these apps and the client credentials can be revealed.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共客户端类型：**这些是客户端应用程序，它们*不*安全地保留密码和其他凭据，也不保密地维护它们。移动设备或桌面上的任何本机应用程序，或者在浏览器上运行的应用程序，都是公共客户端类型的完美示例，因为它们在其中嵌入了客户端凭据。黑客可以破解这些应用程序，客户端凭据可能会被泄露。'
- en: A client can be a distributed component-based application, for example, it could
    have both a web browser component and a server-side component. In this case, both
    components will have different client types and security contexts. Such a client
    should register each component as a separate client if the authorization server
    does not support such clients.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以是分布式基于组件的应用程序，例如，它可以具有Web浏览器组件和服务器端组件。在这种情况下，两个组件将具有不同的客户端类型和安全上下文。如果授权服务器不支持这样的客户端，这样的客户端应将每个组件注册为单独的客户端。
- en: Client profiles
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置文件
- en: 'Based on the OAuth 2.0 client types, a client can have the following profiles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据OAuth 2.0客户端类型，客户端可以具有以下配置文件：
- en: '**Web application:** The Quora web application used in the example of a Quora
    sign-in using Twitter is a perfect example of an OAuth 2.0 web application client
    profile. Quora is a confidential client running on a web server. The resource
    owner (end user) accesses the Quora application (OAuth 2.0 client) on the browser
    (user agent) using a HTML user interface on their device (desktop/tablet/cell
    phone). The resource owner cannot access the client (Quora OAuth 2.0 client) credentials
    and access tokens, as these are stored on the web server. You can see this behavior
    in the diagram of the OAuth 2.0 sample flow. See steps six to eight in the following
    figure:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web应用程序：**在使用Twitter登录Quora的示例中使用的Quora Web应用程序是OAuth 2.0 Web应用程序客户端配置文件的完美示例。Quora是在Web服务器上运行的机密客户端。资源所有者（最终用户）使用其设备（桌面/平板电脑/手机）上的HTML用户界面在浏览器（用户代理）上访问Quora应用程序（OAuth
    2.0客户端）。资源所有者无法访问客户端（Quora OAuth 2.0客户端）凭据和访问令牌，因为这些信息存储在Web服务器上。您可以在OAuth 2.0示例流程的图表中看到这种行为。请参见以下图中的步骤六至八：'
- en: '![](img/c9133c30-f9be-4f91-a386-04f8f57aa134.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9133c30-f9be-4f91-a386-04f8f57aa134.jpg)'
- en: OAuth 2.0 client web application profile
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0客户端Web应用程序配置文件
- en: '**User agent-based application:** User agent-based applications are of the
    public client type. Here though, the application resides in the web server, but
    the resource owner downloads it on the user agent (for example, a web browser)
    and then executes the application. Here, the downloaded application that resides
    in the user agent on the resource owner''s device communicates with the authorization
    server. The resource owner can access the client credentials and access tokens.
    A gaming application is a good example of such an application profile. The user
    agent application flow is shown as follows:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用户代理的应用程序：**基于用户代理的应用程序属于公共客户端类型。在这里，应用程序虽然驻留在Web服务器上，但资源所有者将其下载到用户代理（例如Web浏览器）上，然后执行该应用程序。在这里，驻留在资源所有者设备上的用户代理中的下载应用程序与授权服务器进行通信。资源所有者可以访问客户端凭据和访问令牌。游戏应用程序是这种应用程序配置文件的一个很好的例子。用户代理应用程序流程如下所示：'
- en: '![](img/4d954ef4-70f8-468d-8564-c67d37a3bb74.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d954ef4-70f8-468d-8564-c67d37a3bb74.jpg)'
- en: OAuth 2.0 client user agent application profile
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Native application:** Native applications are similar to user agent-based
    applications, except these are installed on the resource owner''s device and executed
    natively, instead of being downloaded from the web server and then executed inside
    the user agent. Many native clients (mobile applications) you download on your
    mobile are of the native application type. Here, the platform makes sure that
    other applications on the device do not access the credentials and access tokens
    of other applications. In addition, native applications should not share client
    credentials and OAuth tokens with servers that communicate with native applications,
    as shown in the following figure:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5ee3ee45-fea2-4a0a-b0f6-e3455073aa14.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client native application profile
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Client identifier
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the authorization server's responsibility to provide a unique identifier
    to the registered client. This client identifier is a string representation of
    the information provided by the registered client. The authorization server needs
    to make sure that this identifier is unique. The authorization server should not
    use it on its own for authentication.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2.0 specification does not specify the size of the client identifier.
    The authorization server can set the size, and it should document the size of
    the client identifier it issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Client authentication
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authorization server should authenticate the client based on their client
    type. The authorization server should determine the authentication method that
    suits and meets security requirements. It should only use one authentication method
    in each request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the authorization server uses a set of client credentials, such as
    the client password and some key tokens, to authenticate confidential clients.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server may establish a client authentication method with public
    clients. However, it must not rely on this authentication method to identify the
    client, for security reasons.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A client possessing a client password can use basic HTTP authentication. OAuth
    2.0 does not recommend sending client credentials in the request body, but recommends
    using TLS and brute force attack protection on endpoints required for authentication.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 protocol endpoints
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An endpoint is nothing but a URI we use for REST or web components, such as
    Servlet or JSP. OAuth 2.0 defines three types of endpoints. Two are authorization
    server endpoints and one is a client endpoint:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Authorization endpoint (authorization server endpoint)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token endpoint (authorization server endpoint)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection endpoint (client endpoint)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization endpoint
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This endpoint is responsible for verifying the identity of the resource owner
    and, once verified, obtaining the authorization grant. We'll discuss the authorization
    grant in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server requires TLS for the authorization endpoint. The endpoint
    URI must not include the fragment component. The authorization endpoint must support
    the HTTP `GET` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification does not specify the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The way the authorization server authenticates the client.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the client will receive the authorization endpoint URI. Normally, documentation
    contains the authorization endpoint URI, or the client obtains it at the time
    of registration.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token endpoint
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client calls the token endpoint to receive the access token by sending the
    authorization grant or refresh token. The token endpoint is used by all authorization
    grants except the implicit grant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Like the authorization endpoint, the token endpoint also requires TLS. The client
    must use the HTTP `POST` method to make the request to the token endpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Like the authorization endpoint, the specification does not specify how the
    client will receive the token endpoint URI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Redirection endpoint
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The authorization server redirects the resource owner''s user agent (for example,
    a web browser) back to the client using the redirection endpoint, once the authorization
    endpoint''s interactions are completed between the resource owner and the authorization
    server. The client provides the redirection endpoint at the time of registration.
    The redirection endpoint must be an absolute URI and not contain a fragment component.
    The OAuth 2.0 endpoints are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器将资源所有者的用户代理（例如，Web浏览器）重定向回客户端，使用重定向端点，一旦授权端点的交互完成，资源所有者和授权服务器之间的交互。客户端在注册时提供重定向端点。重定向端点必须是绝对URI，不得包含片段组件。OAuth
    2.0端点如下：
- en: '![](img/91a2c588-bc2c-4ce5-8168-df96b8956dbf.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/91a2c588-bc2c-4ce5-8168-df96b8956dbf.jpg)
- en: OAuth 2.0 endpoints
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0端点
- en: OAuth 2.0 grant types
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0授权类型
- en: 'The client requests an access token from the authorization server, based on
    the obtained authorization from the resource owner. The resource owner gives authorization
    in the form of an authorization grant. OAuth 2.0 defines four types of authorization
    grant:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端基于从资源所有者获得的授权，从授权服务器请求访问令牌。资源所有者以授权授予的形式给出授权。OAuth 2.0定义了四种授权授予类型：
- en: Authorization code grant
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权代码授予
- en: Implicit grant
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式授予
- en: Resource owner password credentials grant
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭据授予
- en: Client credentials grant
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭据授予
- en: OAuth 2.0 also provides an extension mechanism to define additional grant types.
    You can explore this in the official OAuth 2.0 specifications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0还提供了一个扩展机制来定义其他授权类型。您可以在官方的OAuth 2.0规范中探索这一点。
- en: Authorization code grant
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权代码授予
- en: 'The first sample flow that we discussed in the OAuth 2.0 example flow for signing
    in with Twitter depicts an authorization code grant. We''ll add a few more steps
    for the complete flow. As you know, after the eighth step, the end user logs in
    to the Quora application. Let''s assume the user is logging in to Quora for the
    first time and requests their Quora profile page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在OAuth 2.0示例流程中讨论的第一个示例流程描述了授权代码授予。我们将为完整流程添加一些步骤。您知道，在第八步之后，最终用户登录到Quora应用程序。假设用户是第一次登录到Quora并请求其Quora个人资料页面：
- en: After logging in, the Quora user clicks on their Quora profile page.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，Quora用户点击其Quora个人资料页面。
- en: The OAuth client Quora requests the Quora user's (resource owner) resources
    (for example, Twitter profile photo, and so on) from the Twitter resource server
    and sends the access token received in the previous step.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端Quora从Twitter资源服务器请求Quora用户（资源所有者）的资源（例如，Twitter个人资料照片等），并发送在上一步中收到的访问令牌。
- en: The Twitter resource server verifies the access token using the Twitter authorization
    server.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Twitter资源服务器使用Twitter授权服务器验证访问令牌。
- en: After successful validation of the access token, the Twitter resource server
    provides the requested resources to Quora (OAuth client).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问令牌成功验证后，Twitter资源服务器将请求的资源提供给Quora（OAuth客户端）。
- en: Quora uses these resources and displays the Quora profile page of the end user.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quora使用这些资源并显示最终用户的Quora个人资料页面。
- en: '**Authorization code requests and responses**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权代码请求和响应**'
- en: 'If you look at all of the steps (a total of 13) of the authorization code flow,
    as shown in the following figure, you can see that there are a total of two requests
    made by the client to the authorization server, and the authorization server provides
    two responses: one request-response for the authentication token and one request-response
    for the access token.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看授权代码流程的所有步骤（共13步），如下图所示，您会发现客户端向授权服务器发出了两个请求，并且授权服务器提供了两个响应：一个用于身份验证令牌的请求-响应，一个用于访问令牌的请求-响应。
- en: 'Let''s discuss the parameters used for each of these requests and responses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个请求和响应使用的参数：
- en: '![](img/1f9ef543-affa-4dc3-b2d0-a753398f89bc.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1f9ef543-affa-4dc3-b2d0-a753398f89bc.jpg)
- en: OAuth 2.0 authorization code grant flow
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0授权代码授予流程
- en: 'The authorization request (step four) to the authorization endpoint URI:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 授权请求（第四步）到授权端点URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `response_type` | Required | Code (this value must be used). |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `response_type` | 必需 | Code（必须使用此值）。|'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `client_id` | 必需 | 它代表授权服务器在注册时向客户端发放的ID。|'
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `redirect_uri` | 可选 | 它代表客户端在注册时提供的重定向URI。|'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选 | 请求的范围。如果未提供，则授权服务器将根据定义的策略提供范围。|'
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and callback (from the authorization server). The specification
    recommends it to protect against cross-site request forgery attacks. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 推荐 | 客户端使用此参数在请求和回调（来自授权服务器）之间维护客户端状态。规范建议使用它来防止跨站点请求伪造攻击。|'
- en: 'Authorization response (step five):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 授权响应（第五步）：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `code` | Required | Code (authorization code) generated by the authorization
    server.Code should be expired after it is generated; the maximum recommended lifetime
    is 10 minutes.The client must not use the code more than once.If the client uses
    it more than once, then the request must be denied and all previous tokens issued
    based on the code should be revoked.Code is bound to the client ID and redirect
    URI. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `code` | 必需 | 授权服务器生成的代码（授权代码）。代码在生成后应过期；最大推荐寿命为10分钟。客户端不得多次使用代码。如果客户端多次使用代码，则必须拒绝请求，并撤销基于代码发放的所有先前的令牌。代码绑定到客户端ID和重定向URI。|'
- en: '| `state` | Required | It represents the ID issued by the authorization server
    to the client at the time of registration. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`state` | 必需 | 它代表授权服务器在注册时向客户端发放的ID。'
- en: 'Token request (step seven) to token endpoint URI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌请求（第七步）到令牌端点URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `grant_type` | Required | `authorization_code` (this value must be used).
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '`grant_type` | 必需 | `authorization_code`（必须使用此值）。'
- en: '| `code` | Required | Code (authorization code) received from the authorization
    server. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '`code` | 必需 | 从授权服务器接收的代码（授权码）。'
- en: '| `redirect_uri` | Required | Required if it was included in the authorization
    code request and the values should match. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '`redirect_uri` | 必需 | 如果在授权码请求中包含了它，则为必需，并且值应匹配。'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`client_id` | 必需 | 它代表授权服务器在注册时向客户端发放的ID。'
- en: 'Token response (step 8):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌响应（第8步）：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`access_token` | 必需 | 授权服务器发放的访问令牌。'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`token_type` | 必需 | 授权服务器定义的令牌类型。基于此，客户端可以利用访问令牌。例如，Bearer或Mac。'
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`refresh_token` | 可选 | 客户端可以使用此令牌使用相同的授权授予获取新的访问令牌。'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`expires_in` | 推荐 | 以秒为单位表示访问令牌的生命周期。值为600表示访问令牌的生命周期为10分钟。如果响应中未提供此参数，则文档应突出显示访问令牌的生命周期。'
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in their request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`scope` | 可选/必需 | 如果与客户端请求的范围相同，则为可选。如果访问令牌范围与客户端在其请求中提供的范围不同，则为必需，以通知客户端授予的访问令牌的实际范围。如果客户端在请求访问令牌时未提供范围，则授权服务器应提供默认范围，或拒绝请求，指示无效的范围。'
- en: 'Error response:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '`error` | 必需 | 规范中定义的错误代码之一，例如`unauthorized_client`或`invalid_scope`。'
- en: '| `error_description` | Optional | Short description of the error. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '`error_description` | 可选 | 错误的简短描述。'
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '`error_uri` | 可选 | 描述错误的错误页面的URI。'
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在客户端授权请求中传递了状态，则在错误响应中还会发送一个额外的错误参数状态。
- en: Implicit grant
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式授权
- en: 'There are no authorization code steps involved in the implicit grant flow.
    It provides the implicit grant for authorization code. Except the authorization
    code step, everything is the same if you compare the implicit grant flow against the
    authorization code grant flow. Therefore, it is called implicit grant. Let''s
    find out its flow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式授权流程中没有涉及授权码步骤。它为授权码提供了隐式授权。如果将隐式授权流程与授权码授权流程进行比较，除了授权码步骤外，其他都是相同的。因此，它被称为隐式授权。让我们找出它的流程：
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with the client
    ID, redirect URI, and so on.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序（例如Quora）使用客户端ID，重定向URI等向资源服务器（例如Facebook，Twitter等）发送访问令牌请求。
- en: The user may need to authenticate if not already authenticated. On successful
    authentication and other input validation, the resource server sends the access
    token.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户尚未经过身份验证，则可能需要进行身份验证。在成功验证和其他输入验证后，资源服务器发送访问令牌。
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端从资源服务器请求用户（资源所有者）的资源（例如Twitter个人资料照片等），并发送在上一步中收到的访问令牌。
- en: The resource server verifies the access token using the authorization server.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器使用授权服务器验证访问令牌。
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功验证访问令牌后，资源服务器向客户端应用程序（OAuth客户端）提供请求的资源。
- en: The client application uses these resources.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用这些资源。
- en: '**Implicit grant requests and responses**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式授权请求和响应**'
- en: 'If you looked at all of the steps (a total of six) of the implicit grant flow,
    you can see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the access token validation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看了隐式授权流程的所有步骤（共六步），您会发现客户端向授权服务器发出了两个请求，并且授权服务器提供了两个响应：一个用于访问令牌的请求-响应，一个用于访问令牌验证的请求-响应。
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个请求和响应使用的参数。
- en: 'Authorization request to the authorization endpoint URI:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 授权请求到授权端点URI：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `response_type` | Required | Token (this value must be used). |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `response_type` | 必需 | Token（必须使用此值）。|'
- en: '| `client_id` | Required | It represents the ID issued by the authorization
    server to the client at the time of registration. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `client_id` | 必需 | 表示授权服务器在注册时向客户端发放的ID。|'
- en: '| `redirect_uri` | Optional | It represents the redirect URI given by the client
    at the time of registration. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `redirect_uri` | 可选 | 表示客户端在注册时提供的重定向URI。|'
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选 | 请求的范围。如果未提供，则授权服务器将根据定义的策略提供范围。|'
- en: '| `state` | Recommended | The client uses this parameter to maintain the client
    state between the requests and the callback (from the authorization server). The
    specification recommends it to protect against cross-site request forgery attacks.
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 推荐 | 客户端使用此参数在请求和回调（来自授权服务器）之间维护客户端状态。规范建议使用它来防止跨站点请求伪造攻击。|'
- en: 'Access token response:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `access_token` | 必需 | 授权服务器发放的访问令牌。|'
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `token_type` | 必需 | 授权服务器定义的令牌类型。基于此，客户端可以利用访问令牌。例如，Bearer或Mac。|'
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `refresh_token` | 可选 | 客户端可以使用此令牌使用相同的授权授予来获取新的访问令牌。|'
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `expires_in` | 推荐 | 表示访问令牌的生命周期，以秒为单位。值为600表示访问令牌的生命周期为10分钟。如果响应中未提供此参数，则文档应突出显示访问令牌的生命周期。|'
- en: '| `scope` | Optional/Required | Optional if identical to the scope requested
    by the client.Required if the access token scope is different from the one the
    client provided in the request to inform the client about the actual scope of
    the access token granted.If the client does not provide the scope while requesting
    the access token, then the authorization server should provide the default scope,
    or deny the request, indicating the invalid scope. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 可选/必需 | 如果与客户端请求的范围相同，则为可选。如果访问令牌的范围与客户端在请求中提供的范围不同，则为必需，以通知客户端访问令牌的实际范围。如果客户端在请求访问令牌时未提供范围，则授权服务器应提供默认范围，或拒绝请求，指示无效的范围。|'
- en: '| `state` | Optional/Requried | Required if the state was passed in the client
    authorization request. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `state` | 可选/必需 | 如果状态在客户端授权请求中传递，则为必需。|'
- en: 'Error response:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应：
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **必需**/**可选** | **描述** |'
- en: '| `error` | Required | One of the error codes defined in the specification,
    for example, `unauthorized_client` or `invalid_scope`. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 必需 | 规范中定义的错误代码之一，例如`unauthorized_client`或`invalid_scope`。|'
- en: '| `error_description` | Optional | Short description of the error. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `error_description` | 可选 | 错误的简短描述。|'
- en: '| `error_uri` | Optional | The URI of the error page describing the error.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `error_uri` | 可选 | 描述错误的错误页面的URI。|'
- en: An additional error parameter state is also sent in the error response if the
    state was passed in the client authorization request.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态在客户端授权请求中传递，则错误响应中还会发送一个额外的错误参数状态。
- en: Resource owner password credentials grant
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭据授予
- en: 'This flow is normally used on mobile or desktops applications. In this grant
    flow, only two requests are made: one for requesting an access token and another
    for access token verification, similar to implicit grant flow. The only difference
    is the resource owner''s username and password are sent along with the access
    token request. (In implicit grant, which is normally on a browser, redirects the
    user to authenticate itself.) Let''s find out its flow:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程通常用于移动或桌面应用程序。在此授权流程中，只进行两个请求：一个用于请求访问令牌，另一个用于访问令牌验证，类似于隐式授权流程。唯一的区别是资源所有者的用户名和密码与访问令牌请求一起发送。（在隐式授权中，通常在浏览器上，重定向用户进行身份验证。）让我们了解其流程：
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so on) with client ID,
    resource owner's username and password, and so on. On successful parameter validation,
    the resource server sends the access token.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序（例如Quora）向资源服务器（例如Facebook、Twitter等）发送访问令牌请求，带有客户端ID、资源所有者的用户名和密码等。在成功的参数验证后，资源服务器发送访问令牌。
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端从资源服务器请求用户（资源所有者）的资源（例如Twitter个人资料照片等），并发送在上一步中收到的访问令牌。
- en: The resource server verifies the access token using the authorization server.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器使用授权服务器验证访问令牌。
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功验证访问令牌后，资源服务器向客户端应用程序（OAuth客户端）提供请求的资源。
- en: The client application uses these resources.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序使用这些资源。
- en: The resource owner's password credentials grant requests and responses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者的密码凭据授予请求和响应。
- en: 'As seen in the previous section, in all of the steps (a total of five) of the
    resource owner password credential grant flow, you can see that there are a total
    of two requests made by the client to the authorization server, and the authorization
    server provides two responses: one request-response for the access token and one
    request-response for resource owner resources.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Access token request to the token endpoint URI:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `grant_type` | Required | Password (this value must be used). |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `username` | Required | Username of the resource owner. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `password` | Required | Password of the resource owner. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: 'Access token response (step one):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `refresh_token` | Optional | This token can be used by the client to get
    a new access token using the same authorization grant. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| Optional parameter | Optional | Additional parameter. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: Client credentials grant
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, here, the client''s credentials are used instead of the
    user''s (resource owner''s). Except client credentials, it is very similar to
    the resource owner password credentials grant flow:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The client application (for example, Quora) sends the access token request to
    the resource server (for example, Facebook, Twitter, and so one) with the grant
    type and scope. The client ID and secrets are added to the authorization header.
    On successful validation, the resource server sends the access token.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth client requests the user's (resource owner) resources (for example,
    Twitter profile photo, and so on) from the resource server and sends the access
    token received in the previous step.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server verifies the access token using the authorization server.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successful validation of the access token, the resource server provides
    the requested resources to the client application (OAuth client).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client application uses these resources.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client credentials grant requests and responses.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: If you looked at all of the steps (a total of five) of the client credentials
    grant flow, you can
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'see that there are a total of two requests made by the client to the authorization
    server, and the authorization server provides two responses: one request-response
    for the access token and one request-response for the resource that involves access
    token verification.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the parameters used for each of these requests and responses.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Access token request to the token endpoint URI:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `grant_type` | Required | `client_credentials` (this value must be used).
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Optional | The scope of the request. If not provided, then the
    authorization server provides the scope based on the defined policy. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: 'Access token response:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Required**/**optional** | **Description** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `access_token` | Required | The access token issued by the authorization
    server. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `token_type` | Required | The token type defined by the authorization server.
    Based on this, the client can utilize the access token. For example, Bearer or
    Mac. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `expires_in` | Recommended | Denotes the lifetime of the access token in
    seconds. A value of 600 denotes 10 minutes of lifetime for the access token. If
    this parameter is not provided in the response, then the document should highlight
    the lifetime of the access token. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: OAuth implementation using Spring Security
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth 2.0 is a way of securing APIs. Spring Security provides Spring Cloud Security
    and Spring Cloud OAuth2 components for implementing the grant flows we discussed
    earlier.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: We'll create one more service, a security-service, which will control authentication
    and authorization.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Maven project and follow these steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Spring Security and Spring Security OAuth 2 dependencies in `pom.xml`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server. The `@EnableAuthorizationServer`
    annotation is another annotation we will use to enable the authorization server
    as per OAuth 2.0 specifications:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the security-service configuration in `application.yml`, as shown in
    the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`server.contextPath`: This denotes the context path'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.user.password`: We''ll use the hardcoded password for this demonstration.
    You can reconfigure it for real use:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have our security server in place, we'll expose our APIs using the
    new `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll modify the Zuul-Server module to make it a resource server also. This
    can be done by following these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Add the Spring Security and Spring Security OAuth 2 dependencies
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'to `pom.xml`. Here, the last two dependencies are required for enabling the
    Zuul-Server as a resource server:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the `@EnableResourceServer` annotation in your application class. This
    will allow this application to work as a resource server:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the Zuul-Server configuration in `application.yml`, as shown in the
    following code. The `application.yml` file will look something like this:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `security.oauth2.resource.userInfoUri` property denotes the security
    service user URI. APIs are exposed to the external world using route configuration
    that points to API services.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our security server in place, we are exposing our APIs using
    the `api-service` microservice, which will be used for communicating with external
    applications and UIs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test and explore how it works for different OAuth 2.0 grant types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We'll make use of the Postman extension to the Chrome browser to test the different
    flows.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code grant
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will enter the following URL in our browser. A request for an authorization
    code is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we provide the client ID (by default, we have the hardcoded client registered
    in our security service), redirect URI, scope (hardcoded `apiAccess` value in
    security service), and state. You must be wondering about the `state` parameter.
    It contains the random number that we revalidate in response to prevent cross-site
    request forgery.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If the resource owner (user) is not already authenticated, it will ask for the
    username and password. Provide the username as `username` and the password as
    `password`; we have hardcoded these values in the security service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the login is successful, it will ask you to provide your (resource owner)
    approval:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1420332-d7fe-4fdb-8283-dda0ddcce291.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - resource grant approval
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Select Approve and click on Authorize. This action will redirect the application
    to `http://localhost:7771/1?code=o8t4fi&state=1234`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it has returned the authorization code and state.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll use this code to retrieve the access code, using the Postman Chrome
    extension. First, we''ll add the authorization header using Username as client
    and Password as `clientsecret`, as shown in the following screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78666832-c5a5-4bc3-add2-f7288380f37c.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - access token request - adding the authentication
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: This will add the Authorization header to the request with the value `Basic
    Y2xpZW50OmNsaWVudHNlY3JldA==`, which is a base-64 encoding of the 'client client-secret'.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add a few other parameters to the request, as shown in the following
    screenshot, and then submit the request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f80b3537-1b8e-4e59-8993-ca06c5b9197a.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - access token request and response
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'This returns the following response, as per the OAuth 2.0 specification:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can use this information to access the resources owned by the resource
    owner. For example, if `https://localhost:8765/api/restaurant/1` represents the
    restaurant with the ID of `1`, then it should return the respective restaurant
    details.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Without the access token, if we enter the URL, it returns the error `Unauthorized`
    with the message `Full authentication is required to access this resource`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s access this URL with the access token, as shown in the following
    screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ad7dda0-294b-4576-a9b4-832beb4312e8.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 authorization code grant - using the access token for API access
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added the Authorization header with the access token.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore implicit grant implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Implicit grant
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implicit grants are very similar to authorization code grants, except for the
    code grant step. If you remove the first step—the code grant step (where the client
    application receives the authorization token from the authorization server)—from
    the authorization code grant, the rest of the steps are the same. Let's check
    it out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following URL and parameters in the browser and press Enter. Also,
    make sure to add basic authentication, with the client as `username` and the password
    as `password` if asked:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are calling the authorization endpoint with the following request
    parameters: response type, client ID, redirect URI, scope, and state.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'When the request is successful, the browser will be redirected to the following
    URL with new request parameters and values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we receive the `access_token`, `token_type`, state, and expiry duration
    for the token. Now, we can make use of this access token to access the APIs, as
    used in the authorization code grant.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner password credential grant
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this grant, we provide `username` and `password` as parameters when requesting
    the access token, along with the `grant_type`, `client`, and `scope` parameters.
    We also need to use the client ID and secret to authenticate the request. These
    grant flows use client applications in place of browsers, and are normally used
    in mobile and desktop applications.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following Postman tool screenshot, the authorization header has already
    been added using basic authentication with `client_id` and `password`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72fb8839-d705-47f9-84ea-8890276bfc61.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 resource owner password credentials grant - access token request and
    response
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Once the access token is received by the client, it can be used in a similar
    way to how it is used in the authorization code grant.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials grant
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this flow, the client provides their own credentials and retrieves the access
    token. It does not use the resource owner's credentials and permissions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, we directly enter the token endpoint
    with only two parameters: `grant_type` and `scope`. The authorization header is
    added using `client_id` and `client secret`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/972a2e60-28b1-423a-adde-38c2fa61afc2.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: OAuth 2.0 client credentials grant - access token request and response
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: You can use the access token similarly as it is explained for the authorization
    code grant.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to these links:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '*RESTful Java Web Services Security*, *René Enríquez, Andrés Salazar C*, *Packt
    Publishing*: [https://www.packtpub.com/application-development/restful-java-web-services-security](https://www.packtpub.com/application-development/restful-java-web-services-security)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RESTful Java Web Services Security*，*René Enríquez, Andrés Salazar C*，*Packt
    Publishing*：[https://www.packtpub.com/application-development/restful-java-web-services-security](https://www.packtpub.com/application-development/restful-java-web-services-security)'
- en: '*Spring Security [Video]*, *Packt Publishing*: [https://www.packtpub.com/application-development/spring-security-video](https://www.packtpub.com/application-development/spring-security-video)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Security [视频]*，*Packt Publishing*：[https://www.packtpub.com/application-development/spring-security-video](https://www.packtpub.com/application-development/spring-security-video)'
- en: 'The OAuth 2.0 Authorization Framework: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0授权框架：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)
- en: 'Spring Security: [http://projects.spring.io/spring-security](http://projects.spring.io/spring-security)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security：[http://projects.spring.io/spring-security](http://projects.spring.io/spring-security)
- en: 'Spring OAuth2: [http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring OAuth2：[http://projects.spring.io/spring-security-oauth/](http://projects.spring.io/spring-security-oauth/)
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how important it is to have the TLS layer or
    HTTPS in place for all web traffic. We have added a self-signed certificate to
    our sample application. I would like to reiterate that, for a production application,
    you must use the certificates offered by certificate-signing authorities. We have
    also explored the fundamentals of OAuth 2.0 and various OAuth 2.0 grant flows.
    Different OAuth 2.0 grant flows are implemented using Spring Security and OAuth
    2.0\. In the next chapter, we'll implement the UI for the sample OTRS project
    and explore how all of the components work together.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习到了为所有网络流量建立TLS层或HTTPS的重要性。我们已经向我们的示例应用程序添加了自签名证书。我想重申，对于生产应用程序，您必须使用由证书颁发机构提供的证书。我们还探讨了OAuth
    2.0的基本原理和各种OAuth 2.0授权流程。使用Spring Security和OAuth 2.0实现了不同的OAuth 2.0授权流程。在下一章中，我们将为示例OTRS项目实现UI，并探索所有组件如何一起工作。

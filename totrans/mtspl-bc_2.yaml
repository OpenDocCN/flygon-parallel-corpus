- en: Identifying and Scanning Targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the basics of Metasploit in the [Chapter 1](part0020.html#J2B80-a731d733dba14ccabae643b74e2c8790),
    *Getting Started with Metasploit*. Let us now shift our focus to an essential
    aspect of every penetration test, that is, the scanning phase. One of the most
    critical aspects of penetration testing, the scanning phase involves identification
    of various software and services running on the target, hence, making it the most
    time consuming and the most crucial aspect of a professional penetration test.
    They say, and I quote, "*If you know the enemy and know yourself, you need not
    fear the result of a hundred battles*". If you want to gain access to the target
    by exploiting vulnerable software, the first step for you to take is to figure
    out if a particular version of the software is running on the target. The scanning
    and identification should be conducted thoroughly, so that you don't end up performing
    a DOS attack on the wrong version of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will try uncovering the scanning aspects of Metasploit
    and we will try gaining hands-on knowledge of various scanning modules. We will
    cover the following key aspects of scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with scanning modules for services such as FTP, MSSQL, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning SNMP services and making use of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out SSL and HTTP information with Metasploit auxiliaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentials required in developing a customized module for scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of existing modules to create custom scanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's run a basic FTP scanner module against a target network and analyze its
    functionality in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Working with FTP servers using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module we will be using for this demonstration is `ftp_version.rb` from
    scanners in the auxiliary section.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning FTP services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us select the module using the `use` command and check what different options
    are required by the module for it to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see we have a number of modules to work with. However, for now, let
    us use the `ftp_version` module, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To scan the entire network, let''s set `RHOSTS to 192.168.10.0/24` (0-255)
    and also increase the number of threads for a speedy operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the module and analyze the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see we have scanned the entire network and found two hosts running FTP
    services, which are TP-LINK FTP server and FTP Utility FTP server. So now that
    we know what services are running on the target, it will be easy for us to find
    any matching exploit if the version of these FTP services is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that some lines are displaying the progress of the scan and
    generating a messy output. We can turn the show progress feature off by setting
    the value to false for the `ShowProgress` option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, we have a better output as shown in the preceding screenshot. However,
    wait! We never had `ShowProgress` in the options, right? So where did it magically
    come from? It would be great if you were to stop at this point and try figuring
    it out yourself. In case you know that we have the advanced option command that
    can be invoked by passing show advanced in Metasploit, we can proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be required, during a penetration test, that you need minute details
    of the test and want a verbose output. Metasploit does offer a verbose feature,
    which can be set by passing set verbose true in the Metasploit console. Verbose
    output will generate data similar to the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The module is now printing details such as connection status and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying scanner modules for fun and profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a large testing environment, it would be a little difficult to analyze hundreds
    of different services and to find the vulnerable ones. I keep a list of vulnerable
    services in my customized scanning modules so that, as soon as a particular service
    is encountered, it gets marked as vulnerable if it matches a particular banner.
    Identifying vulnerable services is a good practice. For example, if you are given
    a vast network of 10000 systems, it would be difficult to run the default Metasploit
    module and expect a nicely formatted output. In such cases, we can customize the
    module accordingly and run it against the target. Metasploit is such a great tool
    that it provides inline editing. Hence, you can modify the modules on the fly
    using the `edit` command. However, you must have selected a module to edit. We
    can see in the following screenshot that Metasploit has opened the `ftp_version`
    module in the VI editor, and the logic of the module is also shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is quite straightforward. If the `banner` variable is set, the status
    message gets printed on the screen with details such as `rhost`, `rport`, and
    the `banner` itself. Suppose we want to add another functionality to the module,
    that is, to check if the banner matches a particular banner of a commonly vulnerable
    FTP service, we can add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we did in the preceding module is just an addition of another if-else block,
    which matches the banner to the regex expression `/FTP\sUtility\sFTP\sserver/`. If
    the banner matches the regex, it will denote a successful match of a vulnerable
    service, or else it will print Not Vulnerable. Quite simple, huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, after you commit changes and write the module, you need to reload
    the module using the `reload` command. Let us now run the module and analyze the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Yeah! We did it successfully. Since the banner of the TP-LINK FTP server does
    not match our regex expression, Not Vulnerable gets printed on the console, and
    the banner for the other service matches our regex, so the Vulnerable message
    gets printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on editing and building new modules, refer to *Chapter
    2*, of *Mastering Metasploit 2nd Edition*.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning MSSQL servers with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now jump into Metasploit-specific modules for testing the MSSQL server
    and see what kind of information we can gain by using them.
  prefs: []
  type: TYPE_NORMAL
- en: Using the mssql_ping module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first auxiliary module that we will be using is `mssql_ping`. This
    module will gather service information related to the MSSQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us load the module and start the scanning process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can clearly see that `mssql_ping` has generated an excellent output of the
    fingerprinted MSSQL service.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-forcing MSSQL passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit also offers brute-force modules. A successful brute-force does exploit
    low entropy vulnerabilities; if it produces results in a reasonable amount of
    time it is considered a valid finding. Hence, we will cover brute-forcing in this
    phase of the penetration test itself. Metasploit has a built-in module named `mssql_login`,
    which we can use as an authentication tester for brute-forcing the username and
    password of an MSSQL server database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us load the module and analyze the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00001.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as we ran this module, it tested for the default credentials at the
    very first step, that is, with the USERNAME sa and PASSWORD as blank, and found
    that the login was successful. Therefore, we can conclude that default credentials
    are still being used. Additionally, we must try testing for more credentials if
    in case the sa account is not immediately found. To achieve this, we will set
    the USER_FILE and PASS_FILE parameters with the name of the files that contain
    dictionaries to brute-force the username and the password of the DBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us set the required parameters; these are the `USER_FILE` list, the `PASS_FILE`
    list, and `RHOSTS` for running this module successfully as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running this module against the target database server, we will have output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding result, we have two entries that correspond
    to the successful login of the user in the database. We found a default user sa
    with a blank password and another user nipun having a password as 12345.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://github.com/danielmiessler/SecLists/tree/master/Passwords](https://github.com/danielmiessler/SecLists/tree/master/Passwords)
    for some excellent dictionaries that can be used in password brute-force.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on testing databases, refer to *Chapter 5*, from *Mastering
    Metasploit First/Second Edition*.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to set the `USER_AS_PASS` and `BLANK_PASSWORDS` options to
    `true` while conducting a brute-force, since many of the administrators keep default
    credentials for various installations.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning SNMP services with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us perform a TCP port scan of a different network as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be using the tcp scan module listed under `auxiliary/scanner/portscan`,
    as shown in the preceding screenshot. Let''s run the module and analyze the results
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we found two services only that don''t look that appealing.
    Let us also perform a UDP sweep of the network and check if we can find something
    interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To carry out a UDP sweep, we will use the `auxiliary/scanner/discovery/udp_sweep`
    module as shown in the preceding screenshot. Next, we only need to provide the
    network range by setting the `RHOSTS` option. Additionally, you can increase the
    number of threads as well. Let''s run the module and analyze results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Amazing! We can see plenty of results generated by the UDP sweep module. Additionally,
    a **Simple Network Management Protocol** (**SNMP**) service is also discovered
    on `192.168.1.19`.
  prefs: []
  type: TYPE_NORMAL
- en: The SNMP, is a commonly used service that provides network management and monitoring
    capabilities. SNMP offers the ability to poll networked devices and monitor data
    such as utilization and errors for various systems on the host. SNMP is also capable
    of changing the configurations on the host, allowing the remote management of
    the network device. SNMP is vulnerable because it is often automatically installed
    on many network devices with `public` as the read string and `private` as the
    write string. This would mean that systems might be fitted to a network without
    any knowledge that SNMP is functioning and using these default keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'This default installation of SNMP provides an attacker with the means to perform
    reconnaissance on a system, and, an exploit that can be used to create a denial
    of service. SNMP MIBs provide information such as the system name, location, contacts,
    and sometimes even phone numbers. Let''s perform an SNMP sweep over the target
    and analyze what interesting information we encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use `snmp_enum` from `auxiliary/scanner/snmp` to perform an SNMP sweep.
    We set the value of `RHOSTS` to `192.168.1.19`, and we can additionally provide
    the number of threads as well. Let''s see what sort of information pops up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Wow! We can see that we have plenty of system information such as Host IP,
    hostname, contact, uptime, description of the system, and even user accounts.
    The found usernames can be handy in trying brute-force attacks as we did in the
    previous sections. Let''s see what else we got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also have the list of listening ports (TCP and UDP), connection information,
    a list of network services, processes, and even a list of installed applications,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hence, SNMP sweep provides us with tons of reconnaissance features for the target
    system, which may help us perform attacks such as social engineering and getting
    to know what various applications might be running on the target, so that we can
    prepare the list of services to exploit and focus on specifically.
  prefs: []
  type: TYPE_NORMAL
- en: More on SNMP sweeping can be found at [https://www.offensive-security.com/metasploit-unleashed/snmp-scan/](https://www.offensive-security.com/metasploit-unleashed/snmp-scan/).
  prefs: []
  type: TYPE_NORMAL
- en: Scanning NetBIOS services with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netbios services also provide vital information about the target and help us
    uncover the target architecture, operating system version, and many other things.
    To scan a network for NetBIOS services, we can use the `nbname` module from `auxiliary/scanner/netbios`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we did previously, we set the `RHOSTS` to the entire network by providing
    the CIDR identifier. Let''s run the module and analyze the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we have almost every system running the NetBIOS service on the
    network listed in the preceding screenshot. This information provides us with
    useful evidence for the operating system type, name, domain, and related IP addresses
    of the systems.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning HTTP services with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit allows us to perform fingerprinting of various HTTP services. Additionally,
    Metasploit contains a large number of exploit modules targeting different kinds
    of web servers. Hence, scanning HTTP services not only allows for fingerprinting
    the web servers, but it builds a base of web server vulnerabilities that Metasploit
    can attack later. Let us use the `http_version` module and run it against the
    network as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s execute the module after setting up all the necessary options such as
    `RHOSTS` and `Threads` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `http_version` module from Metasploit has successfully fingerprinted various
    web server software and applications in the network. We will exploit some of these
    services in [Chapter 3](part0049.html#1ENBI0-a731d733dba14ccabae643b74e2c8790), *Exploitation
    and Gaining Access*. We saw how we could fingerprint HTTP services, so let's try
    figuring out if we can scan its big brother, the HTTPS with Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning HTTPS/SSL with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit contains the SSL scanner module that can uncover a variety of information
    related to the SSL service on a target. Let us quickly set up and run the module
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have the SSL module from `auxiliary/scanner/http`, as shown in the preceding
    screenshot. We can now set the `RHOSTS`, a number of threads to run, and `RPORT`
    if it is not `443`, and execute the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing the preceding output, we can see that we have a self-signed certificate
    in place on the IP address `192.168.1.8` and other details such as CA authority,
    e-mail address, and much more. This information becomes vital to law enforcement
    agencies and in cases of fraud investigation. There have been many cases where
    the CA has accidentally signed malware spreading sites for SSL services.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about various Metasploit modules. Let us now delve deeper and look
    at how the modules are built.
  prefs: []
  type: TYPE_NORMAL
- en: Module building essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to start learning about module development is to delve deeper into
    the existing Metasploit modules and see how they work. Let's look at some modules
    to find out what happens when we run these modules.
  prefs: []
  type: TYPE_NORMAL
- en: The format of a Metasploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The skeleton for Metasploit modules is relatively simple. We can see the universal
    header section in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A module starts by including the necessary libraries with the required keyword,
    which in the preceding code is followed by the `msf/core` libraries. Thus, it
    includes the `core` libraries from the `msf` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The next major thing is to define the class type in place of `MetasploitModule`,
    which is `Metasploit3` or `Metasploit4`, based on the intended version of Metasploit.
    In the same line where we define the class type, we need to set the type of module
    we are going to create. We can see that we have defined `MSF::Auxiliary` for the
    same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In the initialize method, which is a default constructor in Ruby, we define
    the `Name`, `Description`, `Author`, `Licensing`, `CVE details`, and so on; this
    method covers all the relevant information for a particular module. The name contains
    the software name which is being targeted; `Description` contains the excerpt
    on the explanation of the vulnerability, `Author` is the name of the person who
    develops the module, and `License` is `MSF_LICENSE` as stated in the preceding
    code example. The `Auxiliary` module's primary method is the run method. Hence,
    all the operations should be performed on it unless, and until, you have plenty
    of other methods. However, the execution will still begin from the run method.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *Chapters 2, 3,* and *4* from *Mastering Metasploit First/Second Edition*
    for more on developing modules.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://www.offensive-security.com/metasploit-unleashed/skeleton-creation/](https://www.offensive-security.com/metasploit-unleashed/skeleton-creation/)
    for more information on module structure.
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling existing HTTP server scanner modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work with a simple module that we used previously, that is, the HTTP version
    scanner and see how it works. The path to this Metasploit module is `/modules/auxiliary/scanner/http/http_version.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine this module systematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss how things are arranged here. The copyright lines starting with
    the `#` symbol are the comments and they are included in all Metasploit modules.
    The required `''rex/proto/http''` statement asks the interpreter to include a
    path to all the HTTP protocol methods from the `rex` library. Therefore, the path
    to all the files from the `/lib/rex/proto/http` directory is now available to
    the module, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All these files contain a variety of HTTP methods, which include functions to
    set up a connection, the `GET` and `POST` request, response handling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, the required `''msf/core''` statement is used to include
    a path for all the necessary `core` libraries as discussed previously. The `Metasploit3`
    class statement defines the given code intended for Metasploit version 3 and above.
    However, `Msf::Auxiliary` describes the code as an auxiliary type module. Let''s
    now continue with the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding section includes all the necessary library files that contain
    methods used in the modules. Let''s list down the path for these included libraries
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Include Statement | Path | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Exploit::Remote::HttpClient` | `/lib/msf/core/exploit/http/client.rb`
    | This library file will provide various methods such as connecting to the target,
    sending a request, disconnecting a client, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::WmapScanServer` | `/lib/msf/core/auxiliary/wmapmodule.rb`
    | You might be wondering, what is WMAP? WMAP is a web-application-based vulnerability
    scanner add-on for the Metasploit framework that aids web testing using Metasploit.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | This file
    contains all the various functions for scanner-based modules. This file supports
    different methods such as running a module, initializing and scanning the progress,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: Important information to make a note of, is that we can include these libraries
    only because we have defined the required `'msf/core'` statement in the preceding
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the next piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the module defines the initialize method, which initializes the
    basic parameters such as `Name`, `Author`, `Description`, and `License` for this
    module and initializes the WMAP parameters as well. Now let''s have a look at
    the last section of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function is the meat of the scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see some important functions from the libraries that are used in this
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Library File | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | The main method that
    will run once for each host. |'
  prefs: []
  type: TYPE_TB
- en: '| `connect` | `/lib/msf/core/auxiliary/scanner.rb` | Used to make a connection
    to the target host. |'
  prefs: []
  type: TYPE_TB
- en: '| `send_raw_request` | `/core/exploit/http/client.rb` | This function is used
    to make raw HTTP requests to the target. |'
  prefs: []
  type: TYPE_TB
- en: '| `request_raw` | `/rex/proto/http/client.rb` | Library to which `send_raw_request`
    passes data. |'
  prefs: []
  type: TYPE_TB
- en: '| `http_fingerprint` | `/lib/msf/core/exploit/http/client.rb` | Parses HTTP
    responses into usable variables. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s now understand the module. Here, we have a method named `run_host` with
    an IP as the parameter to establish a connection to the required host. The `run_host`
    method is referred from the `/lib/msf/core/auxiliary/scanner.rb` library file.
    This method will run once for each host, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we have the begin keyword, which denotes the beginning of the code block.
    In the next statement, we have the connect method, which establishes the HTTP
    connection to the server as discussed in the table previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a variable named `res`, which will store the response. We will
    use the `send_raw_request` method from the `/core/exploit/http/client.rb` file
    with the parameter URI as/and the method for the request as `GET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding method will help you to connect to the server, create a request,
    send a request, and read the response. We save the response in the `res` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method passes all the parameters to the `request_raw` method from the
    `/rex/proto/http/client.rb` file, where all these parameters are checked. We have
    plenty of parameters that can be set in the list of parameters. Let''s see what
    they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, `res` is a variable that stores the results. The next instruction returns
    the result of if not `res` statement. However, when it comes to a successful request,
    execute the next command that will run the `http_fingerprint` method from the
    `/lib/msf/core/exploit/http/client.rb` file and store the result in a variable
    named `fp`. This method will record and filter out information such as set-cookie,
    powered-by, and other such headers. This method requires an HTTP response packet
    to make the calculations. So we will supply `:response => res` as a parameter,
    which denotes that fingerprinting should occur on the data received from the request
    generated previously using `res`. However, if this parameter is not given, it
    will redo everything and get the data again from the source. In the next line,
    we simply print out the response. The last line, `rescue:: Timeout::Error`, `::
    Errno::EPIPE`, will handle exceptions if the module times out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us run this module and see what the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have now seen how a module works. The concepts remain similar for all the
    other modules where you can easily navigate to the library functions and can build
    your modules.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we covered scanning extensively over various types
    of services such as databases, FTP, HTTP, SNMP, NetBIOS, SSL, and more. We looked
    at how the stuff works for developing custom modules and dismantled some library
    functions and modules. This chapter will help you answer the following set of
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you scan FTP, SNMP, SSL, MSSQL, NetBIOS, and various other services with
    Metasploit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it necessary to scan both TCP and UDP ports?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can a Metasploit module be edited inline for fun and profit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are various libraries added to Metasploit modules?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you look for functions used in a Metasploit module to build a new module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the format of a Metasploit module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you print status, information, and error messages in Metasploit modules?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can try the following self-paced exercises to learn more about the scanners:'
  prefs: []
  type: TYPE_NORMAL
- en: Try executing system commands through MSSQL using the credentials found in the
    tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try finding a vulnerable web server on your network and find a matching exploit;
    you can use Metasploitable 2 and Metasploitable 3 for this exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try writing a simple custom HTTP scanning module with checks for a particularly
    vulnerable web server (like we did for FTP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's now time to switch to the most action-packed chapter of this book-the exploitation
    phase. We will exploit numerous vulnerabilities based on the knowledge that we
    learned from this chapter, and we will look at various scenarios and bottlenecks
    that mitigate exploitation.
  prefs: []
  type: TYPE_NORMAL

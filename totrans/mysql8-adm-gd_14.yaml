- en: MySQL 8 Best Practices and Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to extend MySQL 8\. It covered a lot
    of interesting aspects, such as extending plugins and calling them by using services
    in MySQL 8, adding and debugging new functions to MySQL 8, and so on. In this
    chapter, we will go through the best practices of MySQL 8, which is a much-awaited
    version that promises to address many of the shortfalls of the prior versions
    and has exciting new features. MySQL 8 promises not to be just a standalone database,
    but it will also play a significant role in various areas, including big data
    solutions. We will learn how best practices can be implemented for optimal use
    of features in MySQL 8\. Benchmarking will enhance our understanding further.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL benchmarking and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for the memcached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for data partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for queries and indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to prominent optimizations and changes, MySQL 8 advanced its version directly
    from the release of MySQL 5.7\. MySQL 8 will not have the limitation of files,
    which was previously restricting the number of databases that you could have.
    There are many more exciting features, which we have covered in [Chapter 1](c24bf065-eb70-47cb-9482-807a8431c1ba.xhtml),
    *Introduction to MySQL 8*. MySQL 8 can now store millions of tables in a database.
    It will also make modifications to tables swiftly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am excited to go through this chapter, as MySQL 8 best practices not only
    impact your database performance, scalability, security, and availability, but
    will also, on the whole, expose how your system performs for the end user. This
    is our end goal, isn''t it? Let''s look at some benchmarks that have been derived
    in our test lab, which will raise your eyebrows for sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2c522ae-4e7a-492e-9109-48619517320c.png)'
  prefs: []
  type: TYPE_IMG
- en: MySQL benchmarking and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through various new features and improvements in MySQL 8\. It makes
    us more excited, as performance is always what we crave. With MySQL 8 not being
    generally available yet, Oracle hasn't published its benchmark results. We didn't
    wait for it to do so and carried out our own analysis in a few areas.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration best practices of MySQL is the cherry on the cake; without the
    cherry, the cake seems incomplete. In addition to configurations, benchmarking
    helps us validate and find bottlenecks and address them. Let's look at a few specific
    areas that will help us understand the best practices for configuration and performance
    benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: Resource utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IO activity, CPU, and memory usage is something that you should not miss out.
    These metrics help us know how the system is performing while doing benchmarking
    and at the time of scaling. It also helps us derive impacts per transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Stretching your benchmarking timelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may often like to have a quick glance at performance metrics; however, ensuring
    that MySQL behaves in the same way for a longer duration of testing is also a
    key element. There is some basic stuff that might impact on performance when you
    stretch your benchmark timelines, such as memory fragmentation, degradation of
    IO, impact after data accumulation, cache management, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want our database to get restarted just to clean up junk items, correct?
    Therefore, it is suggested to run benchmarking for a long duration for stability
    and performance validation.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating production settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's benchmark in a production-replicated environment. Wait! Let's disable
    database replication in a replica environment until we are done with benchmarking.
    Gotcha! We have got some good numbers!
  prefs: []
  type: TYPE_NORMAL
- en: It often happens that we don't simulate everything completely that we are going
    to configure in the production environment. It could prove to be costly, as we
    might unintentionally be benchmarking something in an environment that might have
    an adverse impact when it's in production. Replicate production settings, data,
    workload, and so on in your replicated environment while you do benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency of throughput and latency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughput and latency go hand in hand. It is important to keep your eyes primarily
    focused on throughput; however, latency over time might be something to look out
    for. Performance dips, slowness, or stalls were noticed in `InnoDB` in its earlier
    days. It has improved a lot since then, but as there might be other cases depending
    on your workload, it is always good to keep an eye on throughput along with latency.
  prefs: []
  type: TYPE_NORMAL
- en: Sysbench can do more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sysbench is a wonderful tool to simulate your workloads, whether it be thousands
    of tables, transaction intensive, data in-memory, and so on. It is a splendid
    tool to simulate and gives you nice representation.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would like to keep this simple; bare metal as compared to virtualization isn't
    the same. Hence, while doing benchmarking, measure your resources according to
    your environment. You might be surprised to see the difference in results if you
    compare both.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big data is seated on heavy data workload; high concurrency is important. MySQL
    8 is extending its maximum CPU core support in every new release, optimizing concurrency
    based on your requirements and hardware resources should be taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do not miss out factors that run in the background, such as reporting for big
    data analytics, backups, and on-the-fly operations while you are benchmarking.
    The impact of such hidden workloads or obsolete benchmarking workloads can make
    your days (and nights) miserable.
  prefs: []
  type: TYPE_NORMAL
- en: Nerves of your query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oops! Did we miss the optimizer? Not yet. An optimizer is a powerful tool that
    will read the nerves of your query and provide recommendations. It's a tool that
    I use before making changes to a query in production. It's a savior when you have
    complex queries to be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: These are a few areas that we should look out for. Let's now look at a few benchmarks
    that we did on MySQL 8 and compare them with the ones on MySQL 5.7.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with, let''s fetch all the column names from all the `InnoDB` tables.
    The following is the query that we executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how MySQL 8 performed a thousand times faster when
    having four instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/876aec71-3b72-4bf0-b7c9-15628da2a272.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following this, we also performed a benchmark to find static table metadata.
    The following is the query that we executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how MySQL 8 performed around 30 times faster than
    MySQL 5.7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6e32571-2a40-4490-89e1-5565083dd017.png)'
  prefs: []
  type: TYPE_IMG
- en: It made us eager to go into a bit more detail. So, we thought of doing one last
    test to find dynamic table metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the query that we executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how MySQL 8 performed around 30 times faster than
    MySQL 5.7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b1fa168-25c6-4b45-a79d-5e1fafd21ebe.png)'
  prefs: []
  type: TYPE_IMG
- en: MySQL 8.0 brings enormous performance improvements to the table. Scaling to
    one million tables, which is a need for many big data requirements, is now achievable.
    We look forward to many more benchmarks being officially released once MySQL 8
    is available for general purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at our next topic, which will make your life easier. It's all
    about taking things into consideration for best practices of memcached.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for memcached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple `get` operations are now possible with the `InnoDB` memcached plugin,
    which will really help in improving the read performance. Now, multiple key value
    pairs can be fetched in a single memcached query. Frequent communication traffic
    has also been minimized, as we can get multiple data in a single shot.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaways that you should consider for memcached configuration best
    practices are what we will be going through now.
  prefs: []
  type: TYPE_NORMAL
- en: Resource allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory allocation for memcached shouldn't be allocated over the available physical
    memory or without considering other resources that would be utilizing memory.
    If we over-allocate memory, there is a high chance that memcached would have memory
    allocated from the swap space. This may lead to delays while inserting or fetching
    values because the swap space is stored on the disk, which is slower than in-memory.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the operating system architecture has 32-bits, one needs to be cautious.
    As we know, there are limitations to provision resources in a 32-bit operating
    system architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, memcached with 4 GB RAM with a 32-bit operating system architecture
    shouldn't be set more than 3.5 GB RAM, as it can behave strangely in performance
    and can also result in crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Default configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key default configuration parameters should always be fine-tuned based
    on your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory allocation**: By default, this is 64 MB; instead it should be reconfigured
    based on your requirements and testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connections**: By default, this is 1,024 concurrent connections; instead
    it should be reconfigured based on your requirements and testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: By default, this listens on port `11211`; instead it should listen
    to another port for security purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network interface**: By default, this accepts connections from all network
    interfaces; instead it should be limited for security purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max object size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should look at configuring the maximum object size, which by default is
    1 MB. However, it can be bumped up to 128 MB. It is purely based on what type
    of data you are going to store and, accordingly, its maximum object size should
    be allowed. Allowing overhead data to be stored in memcached can have an adverse
    impact, as there may be much more data to retrieve, which can cause failures.
  prefs: []
  type: TYPE_NORMAL
- en: Backlog queue limit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backlog queue limit is all about the number of connections to memcached
    that should be kept in queue if it reaches the limit of allowed connections. Ideally,
    your number of connections allowed should be configured in a way that should suffice
    for most of your needs. The backlog queue limit can be helpful when there is an
    unexpected peak load on memcached. Ideally, it should not go beyond 20% of the
    total connections or it could impact the experience of system fetching information
    from memcached because of heavy delays.
  prefs: []
  type: TYPE_NORMAL
- en: Large pages support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On systems that support large memory pages, you should enable memcached to leverage
    them. Large pages support helps allocate a large data chunk to store data and
    also reduces the number of caches missed calls using this.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storing sensitive data in memcached could be a security threat, as somebody
    with access to memcached could view the sensitive information. You should obviously
    take precautions to limit the exposure of memcached. You can also have sensitive
    information encrypted before storing it on memcached.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting exposure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcached doesn't have many security features built in. One measure involves
    exposing memcached access within the required boundaries. If your application
    server needs to talk to memcached, it only allows memcached to be accessed from
    that server with the help of system firewall rules, such as IP Tables or similar
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Failover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcached doesn't have good failover techniques. It is suggested that you have
    your application configured in a way to failover to an unavailable node and regenerate
    data into another instance. It is good to have at least two memcached configured
    to avoid failure owing to the unavailability of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can leverage namespaces provided by memcached, which basically adds prefixes
    to the data before storing it in memcached. It can help when you have multiple
    applications talking to memcached. This is helpful and, using some basic principles
    of naming conventions, you can derive a solution. If there is data that is storing
    first names and last names, you can use prefixes, such as FN and LN, respectively.
    This would help you easily identify and retrieve data from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Caching mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to start leveraging caching in memcached is to use a
    two-column table; you can leverage namespaces provided by memcached, which basically
    adds prefixes. The first columns would be a primary key, and database schema should
    be the address requirement of a unique identifier with the help of primary key
    mapping along with unique constraints. In case you want to have a single item
    value by combining multiple column values, you should make sure you choose appropriate
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Queries with a single `WHERE` clause can be mapped easily into memcached lookups
    while using `=` or `IN` operators in the queries themselves. In cases where multiple
    `WHERE` clauses are used or complex operations are parsed, such as `<`, `>`, `LIKE`,
    and `BETWEEN`, memcached would get you through challenges. It is suggested that
    you have such complex operations using traditional SQL queries added to your database.
  prefs: []
  type: TYPE_NORMAL
- en: It would be beneficial to cache entire objects in memcached instead of opting
    to cache individual rows from MySQL 8\. For instance, for a blogging website,
    you should cache the entire object of the blog port in memcached.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached general statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you understand the statistics of memcached better, we will provide
    an overview of health and performance. Statistics returned by memcached and their
    meaning are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terms used to define the value for each of the statistics are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**32u**: 32-bit unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**64u**: 64-bit unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**32u:32u**: Two 32-bit unsigned integers separated by a colon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: Character string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Statistic** | **Datatype** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pid` | 32u | Process ID of the memcached instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `uptime` | 32u | Uptime (in seconds) for this memcached instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | 32u | Current time (as epoch). |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | string | Version string of this instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `pointer_size` | string | Size of pointers for this host specified in bits
    (32 or 64). |'
  prefs: []
  type: TYPE_TB
- en: '| `rusage_user` | 32u:32u | Total user time for this instance (seconds:microseconds).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rusage_system` | 32u:32u | Total system time for this instance (seconds:microseconds).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `curr_items` | 32u | Current number of items stored by this instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `total_items` | 32u | Total number of items stored during the life of this
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | 64u | Current number of bytes used by this server to store items.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `curr_connections` | 32u | Current number of open connections. |'
  prefs: []
  type: TYPE_TB
- en: '| `total_connections` | 32u | Total number of connections opened since the
    server started running. |'
  prefs: []
  type: TYPE_TB
- en: '| `connection_structures` | 32u | Number of connection structures allocated
    by the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `cmd_get` | 64u | Total number of retrieval requests (`get` operations).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmd_set` | 64u | Total number of storage requests (`set` operations). |'
  prefs: []
  type: TYPE_TB
- en: '| `get_hits` | 64u | Number of keys that have been requested and found present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get_misses` | 64u | Number of items that have been requested and not found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_hits` | 64u | Number of keys that have been deleted and found present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_misses` | 64u | Number of items that have been delete and not found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `incr_hits` | 64u | Number of keys that have been incremented and found present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `incr_misses` | 64u | Number of items that have been incremented and not
    found. |'
  prefs: []
  type: TYPE_TB
- en: '| `decr_hits` | 64u | Number of keys that have been decremented and found present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `decr_misses` | 64u | Number of items that have been decremented and not
    found. |'
  prefs: []
  type: TYPE_TB
- en: '| `cas_hits` | 64u | Number of keys that have been compared and swapped and
    found present. |'
  prefs: []
  type: TYPE_TB
- en: '| `cas_misses` | 64u | Number of items that have been compared and swapped
    and not found. |'
  prefs: []
  type: TYPE_TB
- en: '| `cas_badvalue` | 64u | Number of keys that have been compared and swapped,
    but the comparison (original) value did not match the supplied value. |'
  prefs: []
  type: TYPE_TB
- en: '| `evictions` | 64u | Number of valid items removed from cache to free memory
    for new items. |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes_read` | 64u | Total number of bytes read by this server from network.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes_written` | 64u | Total number of bytes sent by this server to network.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_maxbytes` | 32u | Number of bytes this server is permitted to use
    for storage. |'
  prefs: []
  type: TYPE_TB
- en: '| `threads` | 32u | Number of worker threads requested. |'
  prefs: []
  type: TYPE_TB
- en: '| `conn_yields` | 64u | Number of yields for connections (related to the -R
    option). |'
  prefs: []
  type: TYPE_TB
- en: 'Reference: [https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html](https://dev.mysql.com/doc/refman/8.0/en/ha-memcached-stats-general.html)'
  prefs: []
  type: TYPE_NORMAL
- en: These are a few useful items that should be kept handy for best practices of
    memcached. It's now time for us to move ahead and look at best practices for replication.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 has made some great improvements on the replication side. MySQL 8 is
    all about scalability, performance, and security with the utmost integrity of
    data, which is expected to be a game-changer in big data too.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput in group replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Group replication basically takes care of committing transactions once most
    of the members in group replication have acknowledged the transaction received
    concurrently. This results in a better throughput if the overall number of writes
    doesn't exceeding the capacity of the members in group replication. If there is
    a case where capacity is not planned appropriately, you would notice lags on affected
    members as compared to other members in the group.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure sizing is a common success factor for performance and the best
    practices checklist. If infrastructure sizing is not proper or uneven across the
    nodes in group replication, it could adversely impact the replication fundamentals
    topology. Each component should be considered while considering the throughput
    required from the components.
  prefs: []
  type: TYPE_NORMAL
- en: Constant throughput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To achieve constant throughput is a good success factor. What if you start experiencing
    a workload that starts affecting the rest of the members in group replication?
    It might be a case where your master keeps on accepting additional workload and
    is lagging behind, after which it might return to an acceptable level before burning
    out all the resources. Additionally, you can implement a queuing methodology that
    can prevent you from burning down resources and only allows you to pass on workloads
    to the members that are predefined based on capacity.
  prefs: []
  type: TYPE_NORMAL
- en: While considering a queuing methodology, you mustn't allow queues grow exponentially.
    This would impact the end user, as there would be a lag in the data being updated.
    However, you needs to decide based on your needs and the business requirement
    to achieve constant throughput across the system.
  prefs: []
  type: TYPE_NORMAL
- en: Contradictory workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, group replication is designed to allow updates from any of the
    members in the group. Rollback of transactions based on overlap of rows is checked
    for each of the transactions; the rest are committed and sent to be updated to
    other members in the group. If several updates on the same row happen frequently,
    it can result in multiple rollbacks. You might come across cyclic situations where
    one server updates, requests others to update, and, in parallel, another has already
    updated for the same row. This would result in rollback.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent such a scenario, you can have the last member of the group apply
    the update, after which you proceed to another one. You can have similar updates
    routed only from the same node where the earlier one had been executed to prevent
    the chances of cyclic rollback conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Write scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distribute your write workload by sharing out write operations, which might
    result in better throughput and better scalability on write performance. It would
    be dependent on contradictory workloads that you would be expecting in the system.
    This is helpful when your peak workload is being executed is one that can share
    the load. In common cases, if you have good capacity planning done with write
    scalability, you would see trivial improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram that depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/075cbe70-3905-4d30-a306-147bdfb015ff.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that with the help of multi-masters to distribute, your load
    has better throughput. It also considers the group size in multi-master configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for data partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general terms, partitioning is logically dividing anything into multiple
    subgroups so that each subgroup can be identified independently and can be combined
    into a single partition.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn different partitioning methods and how partitioning can help
    where there are large data tables.
  prefs: []
  type: TYPE_NORMAL
- en: For any organization, it is very important to store data in such a way that
    the database provides scalability, performance, availability, and security. For
    instance, in a highly accessed e-commerce store, there are thousands, or more,
    of orders placed frequently. So to maintain day-to-day order delivery showing
    a dashboard of current orders, what is required is to query a table showing orders
    from the past five years; the process will take a long time to execute with the
    current data. Here, historical order data is needed for the analytical purpose
    of finding user behavior or trends, but this will be required to be performed
    on limited datasets.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to achieve the best suitable solution for high availability,
    scalability, and highly performing architecture; the key ingredient is partitioning.
    In a database, data in each table is stored in physical file groups. So by dividing
    this data table from a single file group to a multiple file group can reduce the
    file size and help us create a scalable and high-performing database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key benefits of using partitioning in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: As data will be shared among more than one partition, servers
    can be configured to use multiple nodes and partitions can be configured among
    multiple nodes. Doing so will eliminate any hardware limits and allow the database
    to scale up to a large extent to accommodate high volume data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High performance**: As data is stored among multiple partitions, each query
    will be executed on a small portion of the data. For example, in an e-commerce
    store with an order history of more than two years, to get a list of orders placed
    in the current month will require checking only a single partition and not the
    entire order history, thus reducing the query execution time. To fetch the query
    on more than one partition, we can also run this in parallel, thus reducing the
    overall time to fetch data from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High availability**: In partitioning, data is divided across multiple file
    groups. Each file group is logically connected but can be accessed and worked
    on independently. So if one of the file groups or partitions gets corrupted or
    one of the nodes in the server fails, then we will not lose access to the entire
    table, but only a section of the database will not be available, thus eliminating
    the chances of system failure and making your system highly available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: It may be that some of the data in tables requires high security
    measurements to avoid data theft or data leaks. By partitioning, you can provide
    additional security to one or more partitions to avoid any security issues, thus
    improving data accessibility with data security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general terms, partitioning is logically dividing anything into multiple
    subgroups so that each subgroup can be identified independently and can be combined
    into a single partition. Let's understand what partitioning means in terms of
    RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning is generally used to divide data into multiple logical file groups
    for the purpose of performance, availability, and manageability. When dealing
    with big data, the normal tendency of data is to be in terms of billions of records.
    So to improve performance of the database, it is better to divide data among multiple
    file groups. These file groups can be on a single machine or shared across multiple
    machines and identified by a key. These file groups are known as partitioned data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in the table can be partitioned in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the number of rows in the table is very large, the table can be divided
    into multiple partitions; this is known as **horizontal partitioning**. When horizontal
    partitioning is used, each partition of the table contains the same number of
    columns. It is possible to access all partitions at once, or you can access each
    partition individually.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In vertical partitioning, the columns of the tables are partitioned to achieve
    performance and better management of the database. Vertical partitioning can be
    achieved in two ways. The first one is by normalizing tables. Instead of having
    too many columns in the table, columns can be divided into multiple tables by
    dividing the data. The second one is by creating separate physical file groups
    for defined columns in the table. Vertical partitioning is currently not supported
    in MySQL 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few of the benefits associated with partitioning:'
  prefs: []
  type: TYPE_NORMAL
- en: If a table contains historical data, such as logs of an application, data older
    than six months does not provide any significance to the application to be active.
    If partitioning is created based on months, you can easily remove one of the partitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same preceding case of logs, if we want to filter data between two dates,
    the MySQL optimizer can identify the specific partitions, where it can find the
    filtered records, which can result in much faster query results, as the number
    of rows to check is reduced drastically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL 8 also supports querying data on particular partitions. It can reduce
    the number of records to check when you know the partition that needs to be queried
    for the data required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pruning partitions in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pruning is the selective extraction of data. As we have multiple partitions,
    it will go through each partition during retrieval, which is time consuming and
    impacts on performance. Some of the partitions will also be included in searching
    while the requested data is not available inside that partition, which is an overhead
    process. Pruning helps here to search for only those partitions that have the
    relevant data, which will avoid the unnecessary inclusion of those partitions
    during retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: This optimization that avoids the scanning of partitions where there can be
    no matching values is known as the **pruning of partitions**. In partition pruning,
    the optimizer analyzes `FROM` and `WHERE` clauses in SQL statements to eliminate
    unneeded partitions, and scans those database partitions that are relevant to
    the SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for queries and indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be difficult to write the best queries for reference and reuse. It
    will always vary based on the nature of your application, architecture, design,
    table structure, and so on. However, precautions can be taken while writing MySQL
    queries for better performance, scalability, and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through a few of the best practices that we should keep in mind while
    designing or writing MySQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A database table could consist of multiple columns with data types, such as
    numerics or strings. MySQL 8 provides various data types rather than just limiting
    to numerics or strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Small is good. As MySQL loads data in memory, a large data size would have an
    adverse impact on its performance. Smaller sets can accommodate more data in memory
    and reduce overheads of resource utilization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix your length. If you don't fix the data type length, it would have to go
    and fetch the required information each time it needs to. So, wherever it's possible,
    you can limit the data length by using the char data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not null data is something that MySQL doesn't like much. Not null columns use
    more storage, impact the performance, and require additional processing within
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing such queries referring to null data is difficult as well. When a
    null data column is indexed, it uses additional bytes for each entry.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing is important, as it can improve the performance of your badly designed
    query and table structure or it can even turn a well-designed query into a bad
    one, which can impact performance too.
  prefs: []
  type: TYPE_NORMAL
- en: Search fields index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, we do indexing on fields that are used as filters in MySQL queries.
    It obviously helps reading faster but can adversely impact writes/updates so indexing
    only what you need would be a smart decision.
  prefs: []
  type: TYPE_NORMAL
- en: Data types and joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL can do joins for data types that are different but the performance can
    be impacted if MySQL is asked to use different data types for join fields, as
    it would have to convert from one to another for each row.
  prefs: []
  type: TYPE_NORMAL
- en: Compound index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a query is supposed to refer to multiple columns of a table, a composite
    index for such columns might be helpful. A compound index refers the columns from
    the results set by the first column, second column, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The order of columns plays a significant role in the performance of the query,
    so while designing the table structure and index, you need to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Shortening up primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Small is good for primary keys too. Shortening up primary keys would benefit
    analogously to how we discussed datatypes. Because of smaller primary keys, your
    index size would be smaller and hence the usage of cache would be less, so it
    can accommodate more data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: It is preferred to use numeric types, as these would be much smaller than characters
    to achieve the goal of shortening up primary keys. It can be helpful while doing
    joins, as generally, primary keys are referred for the joining.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing everything is a good idea; however, MySQL won't do this. Do you know
    that MySQL will do a full table scan if it is supposed to scan an index higher
    than 30%? Do not index values that don't need to be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that indexing helps—if done correctly—in fetching data;
    however, while writing/updating data, it is an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`select *...` - Arrghh! Do not use this unless it is really needed. So far,
    my experience hasn''t needed this. Fetching all data will slow down the execution
    time and impact heavily on resource utilization of the MySQL server. You need
    to provide a specific column name or appropriate conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: Letting the application do the job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let the application also do the job for MySQL. You can avoid having clauses
    such as `order by` by letting applications do the ordering. Doing ordering in
    MySQL is much slower than in applications. You can identify queries that should
    be planned to be taken care of by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Existence of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking the existence of data with the help of the `EXISTS` clause is much
    faster. The `EXISTS` clause will return the output as soon as it fetches the first
    row from the fetched data.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Limit yourself to the data that you need to fetch. Always ensure that you use
    appropriate limits while fetching the data, as unwanted data being fetched wouldn't
    be useful and would impact performance. Use the `LIMIT` clause in your SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing slow queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a good practice to follow. We might miss out queries to either optimize
    or realize having adverse impact as data grows. You might have changes in the
    requirement of the data to be fetched where we might miss seeing the impact of
    the queries. It is good to always keep a watch on slow queries that can be configured
    in MySQL and optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: Query cost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the cost of your query? Explain is the right answer to this. Use the
    `explain` query parameter to know what is impacting your query—whether it is a
    full table scan, index scans, range access, and so on. Use the information provided
    by explain wisely, to optimize the query further. It is a wonderful, quick handy
    tool of MySQL. If you know that you have done your best, indexing comes as a savior
    to optimize it further based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices while writing a query start with requirements, designs, implementations,
    and ongoing maintenance. It's a complete life cycle that we can't diversify. Understanding
    schemas, indexes, and analyses plays a significant role. What matters to us is
    the response time and optimum resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: I personally love to deep dive into this much more than we can mention here—it's
    a world of relations! Your query will meet a row or column of a table or get joined
    with another table. On top of this, if you haven't done it right, you are trying
    to find a relation from a subset that is not required. How do we forget indexes
    that are saviors if used appropriately? All these together would show our relations
    and would promptly respond to a requested query.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am sure that while reading the chapter, you have kept in mind the things to
    be taken care of or recollecting them, if there's anything missing in your MySQL
    8 implementation. In these chapter, we discussed best practices for MySQL 8 which
    would be helpful at various stages, such as implementation, usage, management,
    and troubleshooting and would act as pointers for best practices of MySQL 8; these
    might vary based on different use cases. Proper testing and verification would
    help affirm the benefits of having best practices implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We have broadly covered some exciting topics about MySQL 8 benchmarks and a
    few configuration parameters along with best practices of memcached. We discussed
    MySQL replication best practices, in which we went through a few critical pointers.
    Lastly, MySQL queries and indexing pointers were also discussed with best practices
    for data partitioning. Anything written in this chapter would be less, but the
    pointers provided are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we should have a good understanding of MySQL 8; it's now time to solve
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next chapter and look at how we could come across many
    common issues, identifying error codes along with real-world scenarios for troubleshooting
    MySQL 8.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every web developer relies heavily on one web framework or another (sometimes
    more if their services have different requirements) and companies will rely on
    many frameworks, but each has its own pros and cons. These frameworks provide
    just that, a frame for developers to build on top of, providing the basic functionality
    that any web framework must provide in order to be considered as a good choice
    for a developer or company to use in their tech stack. In this book, we will talk
    about many of those parts of the framework you would expect to see in a progressive
    framework such as Nest. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REST API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Websockets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explanation of Nest specific tools
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenApi (Swagger) Documentation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server-side rendering with Universal and Angular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Nest provides more of these features because it is a modern web framework built
    on top of a Node.js Express server. By leveraging the power of modern ES6 JavaScript
    for flexibility and TypeScript to enforce type safety during compile time, Nest
    helps bring scalable Node.js servers to a whole new level when designing and building
    server-side applications. Nest combines three different techniques into a winning
    combination that allows for highly testable, scalable, loosely coupled and maintainable
    applications. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-Oriented Programming (OOP): A model that builds around objects instead
    of actions and reusability rather than niche functionality.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Functional Programming (FP): The designing of determinate functionality that
    does not rely upon global states, ie. a function f(x) returns the same result
    every time for some set parameters that do not change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Functional Reactive Programming (FRP): An extension of FP from above and Reactive
    programming. Functional Reactive Programming is at its core Functional Programming
    that accounts for a flow across time. It is useful in applications such as UI,
    simulations, robotics and other applications where the exact answer for a specific
    time period may differ from that of another time period.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Topics discussed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the topics below will be discussed in more detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Nest CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New in version 5 of Nest there is a CLI that allows for command line generation
    of projects and files. The CLI can be installed globally with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or through Docker with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A new Nest project can be generated with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This process will create the project from a [typescript-starter](https://github.com/nestjs/typescript-starter)
    and will ask for the `name`, `description`, `version` (defaults to 0.0.0), and
    `author` (this would be your name). After this process is finished you will have
    a fully setup Nest project with the dependencies installed in your `node_modules`
    folder. The `new` command will also ask what package manager you would like to
    use, in the same way that either `yarn` or `npm` can be used. Nest gives you this
    choice during creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most used command from the CLI will be the `generate` (g) command, this
    will allow you to create new `controllers`, `modules`, `servies` or any other
    components that Nest supports. The list of available components is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class` (cl)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`controller` (co)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`decorator` (d)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exception` (e)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filter` (f)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gateway` (ga)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`guard` (gu)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`interceptor` (i)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`middleware` (mi)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`module` (mo)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pipe` (pi)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`provider` (pr)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`service` (s)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the string in the brackets is the alias for that specific command.
    This means that instead of typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In your console, you can enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the Nest CLI provides the `info` (i) command to display information
    about your project. This command will output information that looks something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection is the technique of supplying a dependent object, such
    as a module or component, with a dependency like a service, thereby injecting
    it into the component’s constructor. An example of this taken from the sequelize
    chapter is below. Here we are injecting the `UserRespository` service into the
    constructor of the `UserService`, thereby providing access to the User Database
    repository from inside the `UserService` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In turn this `UsersService` will be injected into the UsersController in the
    `src/users/users.controller.ts` file, which will provide access to the `UsersService`
    from the routes that point to this controller. More about Routes and Dependency
    injection in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is one of the most important aspects of developing. As developers,
    we always want to make sure that users can only access the resources they have
    permission to access. Authentication can take many forms, from showing your drivers
    license or passport to providing a username and password for a login portal. In
    recent years these authentication methods have expanded out to become more complicated,
    but we still need the same server-side logic to make sure that these authenticated
    users are always who they say they are and persist this authentication so they
    do not need to reauthenticate for every single call to a REST API or Websocket
    because that would provide a pretty terrible user experience. The chosen library
    for this is ironically named Passport as well, and is very well known and used
    in the Node.js ecosystem. When integrated into Nest it uses a JWT (JSON Web Token)
    strategy. Passport is a Middleware that the HTTP call is passed through before
    hitting the endpoint at the controller. This is the `AuthenticationMiddleware`
    written for the example project that extends `NestMiddleware`, authenticating
    each user based on the email in the request payload.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Nest also implements Guards, which are decoratorated with the same `@Injectable()`
    as other providers. Guards restrict certain endpoints based on what the authenticated
    user has access to. Guards will be discussed more in the Authentication chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An ORM is an Object-relational mapping and is one of the most important concepts
    when dealing with communication between a server and a database. An ORM provides
    a mapping between objects in memory (Defined classes such a `User` or `Comment`)
    and Relational tables in a database. This allows you to create a Data Transfer
    Object that knows how to write objects stored in memory to a database, and read
    the results from an SQL or another query language, back into memory. In this book,
    we will talk about three different ORMs: two relational and one for a NoSQL database.
    TypeORM is one of the most mature and popular ORMs for Node.js and thus has a
    very wide and flushed out feature set. It is also one of the packages that Nest
    provides its own packages for: `@nestjs/typeorm`. It is incredibly powerful and
    has support for many databases like MySQL, PostgreSQL, MariaDB, SQLite, MS SQL
    Server, Oracle, and WebSQL. Along with TypeORM, Sequelize is also another ORM
    for relational data.'
  prefs: []
  type: TYPE_NORMAL
- en: If TypeORM is one of the most popular ORMs, then Sequelize is THE most popular
    in the Node.js world. It is written in plain JavaScript but has TypeScript bindings
    through the `sequelize-typescript` and `@types/sequelize` packages. Sequelize
    boasts strong transaction support, relations, read replication and many more features.
    The last ORM covered in this book is one that deals with a non-relational, or
    NoSQL, database. The package `mongoose` handles object relations between MongoDB
    and JavaScript. The actual mapping between the two is much closer than with relational
    databases, as MongoDB stores its data in JSON format, which stands for JavaScript
    Object Notation. Mongoose is also one of the packages that has a `@nestjs/mongoose`
    package and provides the ability to query the database through query chaining.
  prefs: []
  type: TYPE_NORMAL
- en: REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is one of the main design paradigms for creating APIs. It stands for Representative
    State Transfer, and uses JSON as a transfer format, which is in line with how
    Nest stores objects, thus it is a natural fit for consuming and returning HTTP
    calls. A REST API is a combination of many techniques that are talked about in
    this book. They are put together in a certain way; a client makes an HTTP call
    to a server. That server will Route the call to the correct Controller based on
    the URL and HTTP verb, optionally passing it through one or more Middlewares prior
    to reaching the Controller. The Controller will then hand it off to a Service
    for processing, which could include communication with a Database through an ORM.
    If all goes well, the server will return an OK response to the client with an
    optional body if the client requested resources (GET request), or just a 200/201
    HTTP OK if it was a POST/PUT/DELETE and there is no response body.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets are another way to connect to and send/receive data from a server.
    With WebSockets, a client will connect to the server and then subscribe to certain
    channels. The clients can then push data to a subscribed channel. The server will
    receive this data and then broadcast it to every client that is subscribed to
    that specific channel. This allows multiple clients to all receive real-time updates
    without having to make API calls manually, potentially flooding the server with
    GET requests. Most chat apps use WebSockets to allow for real-time communication,
    and everyone in a group message will receive the message as soon as one of the
    other members sends one. Websockets allow for more of a streaming approach to
    data transfer than traditional Request-Response API’s, because Websockets broadcast
    data as it’s received.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices allow for a Nest application to be structured as a collection
    of loosely coupled services. In Nest, microservices are slightly different, because
    they are an application that uses a different transport layer other than HTTP.
    This layer can be TCP or Redis pub/sub, among others. Nest supports TCP and Redis,
    although if you are married to another transport layer it can be implemented by
    using the `CustomTransportStrategy` interface. Microservices are great because
    they allow a team to work on their own service within the global project and make
    changes to the service without affecting the rest of the project since it is loosely
    coupled. This allows for continuous delivery and continuous integration independent
    of other teams microservices.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw above, REST is one paradigm when designing APIs, but there is a new
    way to think about creating and consuming APIs: GraphQL. With GraphQL, instead
    of each resource having its own URL pointing to it, a URL will accept a query
    parameter with a JSON object in it. This JSON object defines the type and format
    of the data to return. Nest provides functionality for this through the `@nestjs/graphql`
    package. This will include the `GraphQLModule` in the project, which is a wrapper
    around the Apollo server. GraphQL is a topic that could have an entire book written
    about it, so we don’t go into it any further in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is one of the core principles when discussing web frameworks. Somehow
    the clients need to know how to access the endpoints for the server. Each of these
    endpoints describes how to retrieve/create/manipulate data that is stored on the
    server. Each `Component` that describes an API endpoint must have a `@Controller(‘prefix’)`
    decorator that describes the API prefix for this component’s set of endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The above Controller is the API endpoint for `GET /hello/world` and will return
    an `HTTP 200 OK` with `Hello World` in the body. This will be discussed more in
    the Routing chapter where you will learn about using URL params, Query params,
    and the Request object.
  prefs: []
  type: TYPE_NORMAL
- en: Nest specific tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nest provides a set of Nest.js specific tools that can be used throughout the
    application to help with writing reusable code and following SOLID principles.
    These decorators will be used in each of the subsequent chapters, as they define
    a specific functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '@Module: The definition for this reusable package of code within the project,
    it accepts the following parameters to define its behavior. ⋅⋅ *Imports: These
    are the modules that contain the components used within this module. ⋅⋅* Exports:
    These are the components that will be used in other modules, that import this
    module. ⋅⋅ *Components: These are the components that will be available to be
    shared across at least this module through the Nest Injector. ⋅⋅* Controllers:
    The controllers created within this module, these will define the API endpoints
    based on the routes defined.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '@Injectable: Almost everything in Nest is a provider that can be injected through
    constructors. Providers are annotated with `@Injectable()`. .. *Middleware: A
    function that is run before a request is passed to the route handler. In this
    chapter, we will talk about the difference between Middleware, Async Middlewares
    and Functional Middleware. ..* Interceptor: Similar to Middleware, they bind extra
    logic before and after the execution of a method, and they can both transform
    or completely override a function. Interceptors are inspired by Aspect-Oriented
    Programming (AOP). .. *Pipe: Similar to part of an Interceptors functionality,
    Pipe transforms input data to the desired output. ..* Guard: A smarter and more
    niche Middleware, Guards have the singular purpose of determining if a request
    should be handled by the router handler or not. ..* Catch: Tell an `ExceptionFilter`
    what exception to look for and then bind data to it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '@Catch: Binds metadata to the exception filter and tells Nest that a filter
    is looking only for the exceptions listed in the `@Catch`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: In Nest Version 4 not everything under `@Injectable()` listed above uses
    the `@Injectable()` decorator. Components, Middlewares, Interceptors, Pipes, and
    Guards each have their own decorator. In Nest Version 5 these have all been combined
    to `@Injectable()` to reduced the differences between Nest and Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI (Swagger)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation is very important when writing a Nest server, and is especially
    so when creating an API that will be consumed by others, otherwise the developer
    writing the clients that will eventually be consuming the API do not know what
    to send or what they get back. One of the most popular documentation engines out
    there is Swagger. Like with others, Nest provides a dedicated module for the OpenAPI
    (Swagger) spec, `@nestjs/swagger`. This module provides decorators to help describe
    the inputs/outputs and endpoints of your API. This documentation is then accessible
    through an endpoint on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS) is the idea that each method
    should either be one that performs an action (command) or requests data (query),
    but not both. In the context of our sample app, we would not have the database
    access code directly within the Controller for an endpoint, but rather create
    a Component (Database Service) that has a method such as `getAllUsers()` that
    will return all the users that the Controllers Service can call, thus separating
    the question and the answer into different Components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing your Nest server will be imperative so that once it is deployed their
    are no unforseen issure and it all runs smoothly. There are two different kinds
    of tests you will learn about in this book: Unit Tests and E2E Tests (End-to-end
    Tests). Unit Testing is the art of testing small snippets or blocks of code, and
    this could be as granular as testing individual functions or writing a test for
    a `Controller`, `Interceptor`, or any other `Injectable`. There are many popular
    unit testing frameworks out there, and `Jasmine` and `Jest` are two popular ones.
    Nest provides special packages, `@nestjs/testing` specifically, for writing unit
    tests in `*.spec.ts` and `*.test.ts` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: E2E Testing is the other form of testing that is commonly used and is different
    from unit testing only in that it tests entire functionality rather than individual
    functions or components, which is where the name end-to-end testing came from.
    Eventually applications will become so large that it is hard to test absolutely
    every piece of code and endpoint. In this case you can use E2E tests to test the
    application from beginning to the end to make sure everything works along the
    way. For E2E testing a Nest application can use the `Jest` library again to mock
    up components. Along with `Jest` you can use the `supertest` library to simulate
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a very important part of writing applications and should not be ignored.
    This is a chapter that will be relevant no matter what language or framework you
    end up working with. Most large scale development companies have entire teams
    dedicated to writing tests for the code that is pushed to production applications,
    and these are called QA developers.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering with Angular Universal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a client side application development framework and Angular Universal
    is a technology that allows our Nest server to pre-render the webpages and serve
    them to the client, which has numerous benefits that will be discussed in the
    Server-side Rendering with Angular Universal chapter. Nest and Angular pair very
    well together due to both using TypeScript and Node.js. Many of the packages that
    can be used in the Nest server can also be used in the Angular app because they
    both compile to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, you will go through each of the above topics in more detail,
    continuously building on top of prior concepts. Nest provides a clean well-organized
    framework that implements each of these concepts in a simple yet efficient way
    that is consistent across all modules because of the modular design of the framework.
  prefs: []
  type: TYPE_NORMAL

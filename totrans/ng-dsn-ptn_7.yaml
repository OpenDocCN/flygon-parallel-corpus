- en: Operation Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final chapter, we will focus on patterns to improve the operation of
    enterprise-scale Angular applications. While the previous chapters focused on
    stability, performance, and navigation, it might all fall apart if we cannot operate
    our apps smoothly. While operating your apps, there are several desirable things
    to consider, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagnostics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, operations strategies and patterns for backend applications can be easier
    to implement. While backend applications can run in different flavors of containers,
    virtual machines, or even barebones, it is easier to operate them compared to
    frontend applications. Indeed, you can register ongoing procedures, CPU usage,
    Ram usage, disk usage, and so on, and you can do this because, directly or indirectly
    (via your service provider), you have access to these servers. For frontend applications,
    these statistics are still desirable. Let's imagine that we have a frontend application
    written in Angular that performs well in all regards during our testing, but fails
    while live. Why would this happen? Well, for example, if you develop Angular applications
    that are consuming locally deployed APIs, you will have to take into consideration
    that your users suffer network latencies. These latencies could make your application
    misbehave.
  prefs: []
  type: TYPE_NORMAL
- en: General health metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first action we can take towards the observability of our Angular application
    is to monitor some general health metrics. General health metrics that we will
    be working with are divided into a few categories. First, we have two metrics
    coming from the Angular profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msPerTick`: The average `ms` it took per tick. A tick can be considered a
    refresh operation or repaint. In other words, the number of milliseconds it takes
    to repaint all your variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numTicks`: The number of elapsed ticks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other kinds of metrics we collect are related to the client workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core`: The number of logical cores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appVersion`: The browser used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also extract information about the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cnxDownlink`: Downlink connection speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cnxEffectiveType`: The connection type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the last set of metrics deals with the heap size of JavaScript itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsHeapSizeLimit`: The max size of the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalJSHeapSize`: This is the current size of the JavaScript heap, including
    free space not occupied by any JavaScript objects. This means that `usedJsHeapSize`
    cannot be greater than `totalJsHeapSize`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usedJSHeapSize`: Total amount of memory being used by JavaScript objects including
    V8 internal objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to collect these metrics, we will create a dedicated Angular service.
    This service will be in charge of accessing the right variables, assembling them
    into a perfect object, and sending them back to our infrastructure with an API
    post.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first set of metrics is accessible via the Angular profiler. The profiler
    is injecting a variable named `ng` that is accessible via your browser command
    line. Most tools that can be used to monitor Angular application performances
    are used while developing them. In order to access this, we can use the `window`
    variable and grab it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, we have access to the `timeChangeDetection` method, which provides us
    with the `msPerTick` and `numTicks` metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a method, this translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Another useful variable that can be found in any JavaScript application is the
    navigator. The navigator variable, as its name suggests, exposes information about
    the browser used by our users. `window.navigator.hardwareConcurrency` and `window.navigator.appVersion`
    give us the number of logical cores and the app version, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: While the previously mentioned variables are accessible on any browser capable
    of running an *Angular* app, the rest of the metrics are, at the time of writing,
    only available on Chrome. If our users use something other than Chrome, then we
    will not have access to these metrics. Chrome, however, is still the most used
    browser, and there is no sign that this will change anytime soon. Consequently,
    for a large portion of our user base, we will be able to retrieve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next batch of metrics are the ones related to the memory performances of
    our applications: `jsHeapSizeLimit`, `totalJSHeapSize`, and `usedJSHeapSize`.
    On Chrome, they are properties of the `window.performance["memory"]` object. For
    other browsers, however, we need to provide a polyfill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check for the existence of the `memory` object. If
    the object exists, we assign it to the local `memory` variable. If the object
    does not exist, we provide a trivial polyfill that has 0-valued metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last set of metrics are the ones related to the connection of our user.
    Like the memory object, it is only accessible on Chrome. We will use the same
    technique as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of the `Monitor` service with the gathering of the
    metrics inside the `metric` method. At the end of the method, we send the metrics
    to an API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the variables within the `perf` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msPerTick`: 0.0022148688576149405'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numTicks`: 225747'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core`: 12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appVersion`: `5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537....L, like
    Gecko) Chrome/66.0.3359.139 Safari/537.36" jsHeapSizeLimit: 2190000000, ...}appVersion:
    "5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139
    Safari/537.36`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cnxDownlink`: 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cnxEffectiveType`: `4g`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core`: 12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsHeapSizeLimit`: 2190000000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msPerTick`: 0.0022148688576149405'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numTicks`: 225747'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalJSHeapSize`: 64000000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usedJSHeapSize`: 56800000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the server side, these metrics can be fed into an ELK stack or something
    similar of your choosing and enhance the observability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Specific metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the metric we looked at earlier, we can add a method in our
    service so that we are able to send specific metrics, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Error reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to enhance the transparency and observability of your application
    is to report each and every JavaScript error that occurs on the client side. Doing
    so is relatively simple in JavaScript; you simply need to attach a callback function
    to the `window.onerror` event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will simply create an alert each time an error occurs. With Angular, however,
    you cannot use the same simple technique—not because it is complicated, but because
    it requires the creation of the `ne` class. This new class will implement the
    Angular error handler interface like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will continue to improve upon the `monitor` service so that it can also
    be our `ErrorHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, these errors can be fed to your `ELK` stack or even plugged in directly
    to your Slack channel, as we do at [Toolwatch.io](http://www.toolwatch.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc5e08d9-3cf7-4eba-96b8-46d75956f9dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For this error handler to be used in place of Angular''s default one, you need
    to provide it when declaring your modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Method metrics with AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of now, we only managed to monitor our system with specific moments: calls
    to metrics, metrics, and errors occurring. A sure way to monitor everything in
    our application is to use **AOP** (**Aspect-oriented programming**) within our
    *Angular* apps. AOP is not a new technique, but it isn''t widely used in the JavaScript
    ecosystem. AOP consists of defining aspects. Aspects are subprograms that are
    associated with specified pieces of our application. Aspects are woven into methods
    at compilation time and are executed before and/or after the method they are woven
    into. In the case of Angular-based applications, the method will be woven at transpilation
    from TypeScript to JavaScript. Weaving an aspect to a method in vanilla JavaScript
    is simple. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we declare three functions: `myBeforeAspect`, `myFunc`, and
    `myAfterAspect`. After their respective declarations, we create the `oldFunc`
    variable and assign it to `myFunc`. Then, we replace the implementation of `myFunc`
    with a new implementation. In this new implementation, we call `myBeforeAspect`
    and `myAfterAspect` in addition to `oldFunc`. This is a simple way of doing aspects
    in JavaScript. We have behaviors that have been added to the call of `myFunc`
    without breaking our internal API. Indeed, if in another part of the program we
    called the `myFunc` function, then our program would still be valid and would
    execute as if nothing had changed. In addition, we can continue to add other aspects
    to the augmented function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also achievable in Angular-flavored TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our constructor wove two aspects into the `click` method. The `click`
    method will execute its behavior in addition to that of the aspect. In the HTML,
    nothing about the AOP transpires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we could apply this technique manually to all our methods, and call the
    `metric` method of our monitoring service. Fortunately, various libraries exist
    that can handle this for us. The best one to date is called `aspect.js` ([https://github.com/mgechev/aspect.js](https://github.com/mgechev/aspect.js)).
  prefs: []
  type: TYPE_NORMAL
- en: '`aspect.js` leverages the decorator pattern of ECMAScript 2016.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install it using `npm install aspect.js -save`, and then we can define
    an aspect like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this aspect, we have several parts. First, we have the `@afterMethod` method
    which takes a `classNamePattern` and a `methodNamePattern`. These patterns are
    regular expressions and are used to define which classes and methods are woven
    into that particular aspect. Then, in `invokeAfterMethod`, we define the behavior
    we want to apply. In this method, we simply log the method that was called and
    the argument values with which said method was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: We repeat this operation with `@beforeMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to keep things like this, the log would be printed out on the client
    side. If we want to get hold of these logs, we will have to modify our `Monitor`
    service once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a static method called `log` and a static `HTTP` client. These
    are static because we will likely weave components that do not receive an injection
    of the `Monitor` service. This way, all services, with or without injection, will
    be able to send their logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of the `Monitor` service, we populate the static client.
    This will be done as soon as our applications boot up and the services are singleton.
    Consequently, we do this only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete implementation of the `Monitor` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The aspect can be modified to call the new static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `className`, `methodName`, and `args`, we can populate the meta
    variable of each component with the `@Wove` syntax, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An interesting use case of the custom meta variables is to use them to store
    the execution time of each method, as the meta variable value is carried from
    the before to the after method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we could have a variable called `startTime` in our `@Wove` annotation
    and use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have another aspect that will be woven into our class, which will measure
    its execution time and report it with the `metric` method of`MonitorService`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operating Angular applications can be complex, because it is relatively hard
    to observe our applications when they are running. While observing backend applications
    is straightforward, because we have access to the running environment, the techniques
    we are used to cannot be applied directly. In this chapter, we saw how to have
    an Angular application monitor itself by using collection performance metrics,
    custom metrics, and logs, and applied all of this automatically by using aspect-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: While the techniques exposed in this chapter can provide 100% observability
    of your applications, they have also some drawbacks. Indeed, if your applications
    are popular, you will be overcharging your backend infrastructure not only to
    serve your pages and answer your API calls, but to accepts logs and metrics. Another
    drawback is that ill-intentioned people could feed you bad metrics via your APIs
    and provide you with a biased picture of what is currently happening within your
    live applications.
  prefs: []
  type: TYPE_NORMAL
- en: These drawbacks can be addressed by only monitoring a subset of your clients.
    For example, you could activate logging and tracing for only 5% of your clients
    based on a randomly generated number. In addition, you could verify the authenticity
    of the users that want to send you metrics by providing CSRF tokens for each request.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 2. Details of JavaScript Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practicing TDD is a great way to get good quality software with satisfactory
    accuracy, even with fewer people. For web applications, JavaScript has become
    the most popular scripting language and it has become a challenge to test JavaScript
    code. Browser-based testing is actually a time killer and is difficult to follow
    for TDD, but then the solution to this comes with some cool tools that support
    automated testing for JavaScript. Most web application projects were limited to
    unit tests only, and without automated test tools, end-to-end tests or functional
    tests were almost impossible.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of tools and frameworks focusing on JavaScript testing are coming out,
    which serve different solutions, making developers' lives easy. Besides inventing
    new JavaScript frameworks, the developer's community invented some tool sets to
    make testing easy. Like the Angular team, they come with cool tools like **Karma**.
    We also have the duplication of testing frameworks or tools, where both solve
    similar problems but in different ways. Which tools or frameworks to choose is
    up to the developer; they have to choose the tool that suits their requirements
    best.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief about automated testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of testing focused on JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief idea about some testing tools and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The craft of JavaScript testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that JavaScript is a dynamically typed, interpreted language. Therefore,
    there are no compilation steps that help you figure out errors, unlike other compiled
    languages similar to Java. So, a JavaScript developer should allocate more time
    to test code. However, life is easier now, as a developer can cover testing with
    minimal steps and time using the latest tool techniques. It's a part of an automated
    test, where the code will be automatically tested whenever it changes. In that
    process, a test could be a task running in the background, which could be integrated
    into the IDE or the CLI, and it will provide the test result during development.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent sections, we will discuss how to automate the test process
    in multiple browsers with a test runner and a headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is fun, and writing a test will make the code better; it's a good practice,
    but the procedural manual testing is a bit time consuming, error prone, and irreproducible.
    In this process, there is a need to write the test spec, change the code to pass
    the test, refresh the browser to get the result, and repeat this process several
    times. As a programmer, it's kind of boring to repeat the same things.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from being monotonous, it also slows down the development process a lot,
    which demotivates developers from practicing TDD. So, when the manual process
    slows down progress, we have to look for some automated process to do the job
    and save time for other tasks that could add more business value.
  prefs: []
  type: TYPE_NORMAL
- en: So, it would be great to have some tools or techniques that can help programmers
    get rid of these repetitive and boring manual steps that slow down the process
    and get things done automatically, faster, and save time to make them more valuable
    for the business. Fortunately, there are some tools to automate these tests. We
    will cover more about those tools and techniques, but not in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the issue of slowing down the development process, another important
    point comes in view when we talk about the testing features, and that is the cross-browser
    compatibility issue. As web applications should run perfectly on modern platforms
    and browsers, and it's almost impossible to test them one-by-one manually, automated
    testing could be the solution with a web driver and headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recap the basic test flow that we explained in the previous chapter--test
    it, make it run, and make it better. To make this process automatic, a developer
    can implement the tool set in the CLI or even in the development IDE, and these
    tests will run continuously in a separate process without any input from the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think of a registering or signing up feature for any application, where
    we have to manually fill up the form and click on the submit button every time
    we want to test the feature and repeat the process by changing the data. This
    is actually known as a functional test (which we will discuss at the end of this
    chapter). To perform these processes automatically, we will use the tool set (the
    test runner, web driver, and headless browser) in the CLI and complete the process
    with a single command with some parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Testing JavaScript in automated testing is not a new concept, indeed, it is
    the most commonly used automated browser. Selenium was invented for this in 2004,
    and after that, a lot of tools have emerged, including PhantomJS, Karma, Protractor,
    and CasperJS. In this chapter, we will discuss some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TDD, developers have to follow a flow to fulfill the goal of the test. On
    this flow, every step has an individual goal of testing. For example, some tests
    are written just to test the behavior of each function in several ways and some
    are for testing the flow of a module/feature. Based on that, we will discuss two
    major types of testing here. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: This is mostly used for behavior tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end testing**: This is mostly known as e2e testing and is used for
    functional tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unit testing** is a software development process, where the smallest testable
    part of any application is individually called a unit, and the behavior of that
    small part should be testable in isolation, without any dependency on the other
    parts. If we think of a JavaScript application as software, then every individual
    method/function of that application which has a specific behavior will be a unit
    of code. The behavior of these methods or units of code should be testable in
    an isolated way.'
  prefs: []
  type: TYPE_NORMAL
- en: An important point about unit testing is that any unit of code should run/be
    testable in isolation and should run in any order, which means that if unit testing
    runs successfully in any application, it represents the isolation of the components
    or modules of that application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we had already shown a small test example in the previous chapter
    about how to get a method tested; though we showed that without using any test
    framework, the idea is the same. We called the method by passing some parameters,
    got a result of that method, and then we compared the result with the expected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we will write such tests using a unit testing framework of our choice.
    There are many testing frameworks and tools now, and we have to decide and pick
    the best one based on our requirements. The most commonly used frameworks are
    Jasmine, Mocha, and QUnit. We will discuss these tools in depth in this chapter
    and real-life examples will be covered in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should run fast and be automated with a clear output. For example, you
    can verify that if a function is called with particular arguments, it should return
    an expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing can run the test anytime, such as in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: From the very beginning of the development process, even with a failing test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing the development of any feature to verify that the behavior
    is correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After modifying any existing feature to verify that the behavior hasn't changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After adding a new feature in the existing application, we need to verify that
    the new feature is isolated and it's not breaking any other feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: End-to-end testing is a methodology used to test whether the flow of an application
    is performing as designed from start to finish. For example, if a user clicks
    on a product from a product list, it should prompt the modal to display detailed
    information of the selected product. In this case, the product/project owner will
    define the project requirements step by step in the specification. The project
    will be tested based on the specification's workflow after the development process.
    This is called the function/flow test and is another name for an end-to-end test.
  prefs: []
  type: TYPE_NORMAL
- en: Besides unit testing, end-to-end testing is important for confirming that individual
    components are working together as an application, passing information, and communicating
    among them. The main difference with unit testing is that it does not test any
    components in isolation; instead, it is a combined test of the flow with all the
    dependent components together.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a registration module where users should provide some valid information
    to complete the registration, and the function/flow test for that module/application
    should follow some steps to complete the testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Load/compile the form
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the DOM of the form's elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger the click event of the submit button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the value from the input fields for validation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the input fields
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the fake API to store data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In every step, there will be some result which will be compared to the expected
    result set.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of functional/flow tests can be tested manually by a person filling
    out the forms by clicking on the buttons for the next steps, completing the application
    flow, and comparing the result with the specification that is defined earlier
    in the implementation process.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some techniques available to do this functional/flow testing
    in an automated way without getting input from any person, which is known as end-to-end
    testing. To make this test process easier, there are a few tools available; the
    ones used most commonly are Selenium, PhantomJS, and Protractor. These tools can
    easily integrate with any application test system. In this chapter, we will discuss
    these test tools in a bit more detail, and in the subsequent chapters, we will
    integrate these in an application's test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Testing tools and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowing what the different testing tools are is half the battle. A few of them
    are very important to know in depth for Angular testing; we will learn them in
    detail throughout this book. However, in this section, we will learn about some
    well-known tools and frameworks that are used in different web applications for
    various kinds of testing and approaches. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Karma**: This is the test runner for JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor**: This is the end-to-end testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine**: This refers to the behavior-driven JavaScript testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha**: This is the JavaScript testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QUnit**: This stands for the unit testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium**: This is the tool that automates the web browsers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PhantomJS**: This is the headless webkit browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before discussing what Karma is, it is best to discuss what it isn''t. It isn''t
    a framework to write tests; it is a test runner. What this means is that Karma
    gives us the ability to run tests in several different browsers in an automated
    way. In the past, developers had to perform manual steps to do this, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening up a browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointing the browser to the project URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirming that all the tests have passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Karma, automation gives a developer the ability to run a single command
    and determine whether an entire test suite has passed or failed. From a TDD perspective,
    this gives us the ability to find and fix failing tests quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pros of using Karma as compared to a manual process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to automate tests in multiple browsers and devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to watch files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online documentation and support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does one thing--running JavaScript tests--and does it well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it easy to integrate with a continuous integration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantage of using Karma:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires an additional tool to learn, configure, and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the process of testing and using Karma is extremely advantageous.
    In the TDD journey through this book, Karma will be one of our primary tools.
    We will learn about Karma in detail in [Chapter 3](ch03.html "Chapter 3. The Karma
    Way"), *The Karma Way*.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protractor is an end-to-end testing tool that allows developers to mimic user
    interactions. It automates the testing of functionality and features through the
    interaction of a web browser. Protractor has specific methods to assist in the
    testing of Angular, but they are not exclusive to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pros of using Protractor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configurable to test multiple environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy integration with Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax and testing can be similar to the testing framework chosen for unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disadvantage of using Protractor:'
  prefs: []
  type: TYPE_NORMAL
- en: Its documentation and examples are limited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For end-to-end testing of the examples in this book, Protractor will be our
    main framework. Protractor will be further introduced in detail in [Chapter 4](ch04.html
    "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing with Protractor*.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jasmine is a behavior-driven development framework for testing JavaScript code.
    It can be easily integrated and run for websites and is agnostic to Angular. It
    provides spies and other features. It can also be run on its own without Karma.
    In this chapter, we will learn details of the commonly used built-in global functions
    of Jasmine and will see how the Jasmine test suite serves the testing requirements
    for a web application. Also, throughout this book, we will use Jasmine as our
    testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pros of using Jasmine are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Default integration with Karma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides additional functions to assist with testing, such as test spies, fakes,
    and the pass-through functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleans readable syntax that allows tests to be formatted in a way that relates
    to the behavior being tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with several output reporters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some cons of using Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: No file-watching feature is available when running tests. This means that tests
    have to be rerun by the user as they change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning curve can be steep for all the Protractor methods and features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mocha is a testing framework originally written for Node.js applications, but
    it supports browser testing as well. It is very similar to Jasmine and mirrors
    much of its syntax. The main difference with Mocha is that it can't run standalone
    as a test framework--it needs some plugin and library to run as a test framework,
    while Jasmine is standalone. It's more configurable and flexible to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some of the pros of Mocha:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good documentation available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has several reporters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugs in with several node projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate plugins/modules are required for assertions, spies, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional configuration required to use it with Karma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QUnit is a powerful, easy-to-use JavaScript unit test suite. It's used by jQuery
    and the jQuery UI and jQuery Mobile projects and is capable of testing any generic
    JavaScript code. QUnit focuses on testing JavaScript in the browser, while providing
    as much convenience to the developer as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pros of QUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good documentation available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a con of using QUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: Mostly developed for jQuery, not good for use with other frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) defines
    itself as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Selenium automates browsers. That''s it!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Automation of browsers means that developers can interact with browsers easily.
    They can click on buttons or links, enter data, and so on. Selenium is a powerful
    toolset that, when used and set up properly, has lots of benefits; however, it
    can be confusing and cumbersome to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the pros of Selenium are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Large feature set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SaaS support through services such as **Sauce Labs** ([https://saucelabs.com/](https://saucelabs.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation and resources available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some cons of Selenium:'
  prefs: []
  type: TYPE_NORMAL
- en: Has to be run as a separate process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several steps to configure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As Protractor is a wrapper around Selenium, it won't be discussed in detail.
  prefs: []
  type: TYPE_NORMAL
- en: PhantomJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PhantomJS is a headless WebKit scriptable with a JavaScript API. It has *fast*
    and *native* support for various web standards; DOM handling, CSS selector, JSON,
    Canvas, and SVG. PhantomJS is used in the test workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, PhantomJS is a browser that runs headlessly (that is, doesn't draw
    out the screen). The benefits that it brings are speed--if you're controlling
    an actual program on your computer, you've a certain overhead in booting up the
    browser, configuring a profile, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: PhantomJS is not meant to replace a testing framework; it will work in conjunction
    with one.
  prefs: []
  type: TYPE_NORMAL
- en: The choice is ours
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, there are a lot of toolsets and frameworks for testing JavaScript
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: For the assertion framework, we will go with Jasmine as Angular itself uses
    Jasmine as assertions; but in some cases, mostly for Node.js projects, Mocha is
    fun as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as we focus on the automated test suite, the test runner is of most
    importance to us, and nothing can be compared to Karma when it's about an Angular
    project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For end-to-end testing, Protractor is the best framework, and we will use that
    in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as it's end-to-end testing, it must be automated, and Selenium is here
    to automate the browser for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to run tests as cross-browser support, and PhantomJS is here
    for us to serve as a headless browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Say hello to Jasmine test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as we have to use a testing framework to build a test suite, there are
    some basic and common assertions on all frameworks. It's important to understand
    those assertions and spies and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will explain the assertions and spies from Jasmine, as Jasmine
    will be our testing framework throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Suites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any test suite begins with a global Jasmine `describe` function, which receives
    two parameters. The first one is a string and the second one is a function. The
    string is the suite name/title, and the function is for the code block that will
    be implemented in the suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Spec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any spec defined with Jasmine''s global `it` function, similar to the suite''s
    that receives two params, involves the first one being a string and the second
    one being a function. The string is the spec name/title and the function is for
    the code block that will be implemented in the spec. Take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Expectation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any expectation defined with an `expect` function, which receives one param
    value that is called actual. This function is a chain with the matcher function,
    which takes an expected value as a parameter to match with the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few commonly used matchers; all of them implement a Boolean comparison
    between the actual value and the expected value. Any matcher can evaluate a negative
    value by chaining the `expect` method with a `not` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Some common matchers are `toBe`, `toEqual`, `toMatch`, `toBeNull`, `toBeDefined`,
    `toBeUndefined`, and `toContain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the given example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the test suite by DRY (Don't repeat yourself) up duplicated setup
    and teardown code, Jasmine provides some global functions for the setup and teardown.
    Those global functions (`beforeEach`, `afterEach`, and so on) are as follows and
    they run as the name implies.
  prefs: []
  type: TYPE_NORMAL
- en: Every function runs against a test spec. Jasmine's global setup and the teardown
    functions are `beforeEach`, `afterEach`, `beforeAll`, and `afterAll`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spies are test double functions in Jasmine; they can stub any function and track
    calls on it and to all its arguments. There are a few matchers around to track
    if any spy has been called or not. These are `toHaveBeenCalled`, `toHaveBeenCalledTimes`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are some useful chained methods used with spy, such as `returnValue`/
    `returnValues`, which will return one or more values when called by chaining with
    spy. There are a few more similar useful methods, such as `callThrough`, `call`,
    `stub`, `call.allArgs`, `call.first`, and `call.reset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The test suite of Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, we looked over some commonly used assertions that
    all test frameworks, including Jasmine, use in any kind of test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Though in this book, we will build an automated test suite for Angular testing,
    let's try some assertion in a Jasmine test suite and see how it works. This sample
    test suite will give us some hands on experience of how the assertions work on
    a test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test suite, we will use Jasmine''s sample spec runner project (which
    is available in the Jasmine downloaded bundle in the example), and the project''s
    folder structure will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test suite of Jasmine](graphics/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a quick look at the files that we have to update in the Jasmine''s
    sample `SpecRunner` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as it''s a browser-based test suite, we have to point `SpecRunner.html` to
    a web browser to get the test result. We will have all the tests passed and our
    test result will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test suite of Jasmine](graphics/image_02_002-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Jasmine test suite for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, we saw a Jasmine test suite for JavaScript testing,
    but what about for Angular, how should that look? Actually, there is no direct
    answer as, for the Angular project test suite, we will not use a browser-based
    test suite; we have a test runner with Karma for the test suite. But as we are
    familiar with the browser-based Jasmine test suite in the preceding example, let's
    see what that will look like if we make a similar one for the Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to add a subfolder as `src` in the Angular project for the test
    spec, and then the project''s folder structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Jasmine test suite for Angular](graphics/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Angular project, we will use TypeScript rather than plain JavaScript
    as Angular officially suggests using TypeScript. So, we hope that we all know
    the TypeScript syntax and know how to compile to JS.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, for the Angular test suite, we will use SystemJS as the module
    loader, as Angular officially suggests it; we will take a look at SystemJS.
  prefs: []
  type: TYPE_NORMAL
- en: This sample Angular test suite is just to show how easily we can make a test
    suite for an Angular project, though it's not following the best practices and
    the best way to load the modules.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, we will
    update this test suite with real-life examples and use SystemJS as the module
    loader.
  prefs: []
  type: TYPE_NORMAL
- en: There is a seed project from the Angular team in GitHub called as `Angular2-seed`
    to bootstrap any Angular project with test suite; we will follow that one for
    our real Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the folder structure, it''s almost the same as the previous one,
    and there are minimum changes in the spec file as well; the only change in spec
    is with TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is also a browser-based test suite, we have to point `unit-tests.html`
    in a web browser to get the test result. We will have all the tests passed, and
    our test result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Jasmine test suite for Angular](graphics/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Self-test questions will help you further test your knowledge of using TDD for
    JavaScript application testing.
  prefs: []
  type: TYPE_NORMAL
- en: Q1\. End-to-end testing means what kind of test?
  prefs: []
  type: TYPE_NORMAL
- en: Functional test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q2\. Protractor is a Unit testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q3\. PhantomJS is a type of browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q4\. What is QUnit a test framework for?
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NodeJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q5\. Setup and teardown is a feature of Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed different mechanisms of testing TDD and covered
    automated testing. We reviewed different kinds of JavaScript testing frameworks
    and tools and reviewed the uses of those frameworks with their pros and cons.
    We also reviewed some common assertions from Jasmine and tried, hands on, how
    they worked.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Karma and see how that works with the
    Angular test suite.
  prefs: []
  type: TYPE_NORMAL

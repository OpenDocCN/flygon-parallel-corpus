- en: Chapter 6. The First Step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is always the most difficult. This chapter provides an initial
    introductory walk-through of how to use TDD to build an Angular application with
    a component, class, and model. We will be able to begin the TDD journey and see
    the fundamentals in action. Up to this point, this book has focused on a foundation
    of TDD and the tools required for it. Now, we will switch gear and dive into TDD
    with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be the first step of TDD. We have already seen how to install
    Karma and Protractor, in addition to small examples and a walk-through on how
    to apply them. In this chapter, we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple comments application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Karma and Protractor with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering the components of testing and its associated classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the application's specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an application to enter comments. The specifications of the application
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If I am posting a new comment, when I click on the **Submit** button, the comment
    should be added to the comment list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a comment, when I click on the **Like** button, the number of likes for
    the comment should increase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have the specifications of the application, we can create our development
    to-do list. It won''t be easy to create an entire to-do list of the whole application.
    Based on the user specifications, we have an idea of what needs to be developed.
    Here is a rough sketch of the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the application''s specifications](graphics/image_06_001-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hold back from jumping into the implementation and thinking about how we will
    use a component class, `*ngFor`, and so on. Resist, resist, resist! Although we
    can think of how this will be developed in the future, it is never clear until
    we delve into the code, and that is where we will start getting into trouble.
    TDD and its principles are here to help us get our mind and focus in the right
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Angular project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed in detail how a project should be set up,
    looked at the different components involved, and walked through the entire process
    of testing. We will skip these details and provide a list in the following section
    for the initial actions to get the project set up and ready with a test configuration
    for unit and end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will get a simple Angular project from the Angular team's examples and modify it for
    our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will clone the `quickstart` project from the Angular GitHub repo and start
    with that one. We should have Git installed globally besides `node`/`npm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will copy the project locally as `angular-project`; this project may contain
    some extra files (they may be updated continuously), but we will try to keep our
    project folder structure looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an existing project](graphics/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will keep it simple initially, and then, we will add our required files step
    by step. This will make us more confident.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed with it and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `npm install` command will install the required modules for project dependencies
    that are defined in the `package.json` file that is in the project's root.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous examples, we put the component, unit test spec, and e2e test spec
    in the same folder just to keep it simpler. For a larger project, it's difficult
    to manage all in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: To make that manageable, we will put the test spec in a separate folder. Here,
    our sample `quickstart` project has already put test specs in the default folder,
    but we will have a new structure and will put our test files in the new structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start setting up the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project''s root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the test (`spec`) directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `unit` test directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the end-to-end (`e2e`) test directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the initialization is complete, our folder structure should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the directory](graphics/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up Karma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The details for Karma can be found in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. Here, we will mostly take a look at the Karma configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In this `quickstart` project, we have already installed and configured Karma,
    and we have the `karma.conf.js` file in the project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that we have Karma in the system, let''s install it globally using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, we already have Karma configured in this project as part
    of a `quickstart` project, and we have the `karma.conf.js` file in the project
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at some basic configuration options that everyone should know.
    In this configuration file, there are some advanced options, such as test reporting
    and bug reporting. We will skip those as they are not very important to know at
    this initial stage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's know more about a few of the configurations that we will need to proceed
    further.
  prefs: []
  type: TYPE_NORMAL
- en: The `basePath` should be updated when we have a custom path for the project
    in the server. For now, it's `''`, as this project is running in the root path.
    The next option is the `frameworks`; by default, we are using `jasmine` here,
    but we can change the framework name if we want to use others, such as `mocha`.
    One point to remember is that if we plan for a different framework, we will have
    to add the relevant plugin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugins are required, as Karma will use these `npm` modules inside to perform
    the actions; for example, if we plan to use PhantomJS as the browser, we will
    need to add `''karma-phantomjs-launcher''` to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next and most important option is `files[]`; with this, Karma will include
    all the required files for testing. It loads a file based on dependency. We will
    have all the required files in the `files[]` array.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add `System.js` since we use `systemjs` as the module loader
    in the app. Then, add `polyfills` for shim support on all browsers, `zone.js`
    for Async support in the app, RxJS as the reactive library, Angular library files,
    shim for Karma test, the components file, and, finally, the test specs. There
    might be some other files in the list for debug and reporting; we are skipping
    their explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our `files[]` array will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need to know for now in the `karma.conf` file. We will proceed
    by updating these settings if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the complete `karma.conf.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Test directory updated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen details of `karma-test-shim.js` in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. This is needed to run unit testing via Karma.
  prefs: []
  type: TYPE_NORMAL
- en: We have changed the test specs directory/location, and `karma-test-shim.js`
    is configured based on the default structure of the project. Because we have moved
    the test to a different location and out of the `app/` folder, we need to update
    `karma-test-shim.js` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the change that will need to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Protractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End
    Testing with Protractor*, we discussed the full installation and setup of Protractor.
    This sample application already has Protractor installed and configured. So, we
    will just take a look at the `protractor.conf.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: This configured Protractor instance has test reporting implemented. We will
    skip those parts from the config file here and just have a look at the common
    setting options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go to the config file overview, to be sure, we will install Protractor
    globally on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update Selenium WebDriver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will have to make sure that Selenium is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, `protractor.conf.js` is located at the root of the application.
    Here is the complete configuration of the `protractor.conf.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Top-down versus bottom-up approach - which one do we use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a development perspective, we have to determine where to start. The approaches
    that we will discuss in this book are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The bottom-up approach**: With this approach, we think about the different
    components we will need (class, service, module, and so on) and then pick the
    most logical one and start coding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The top-down approach**: With this approach, we work from the user scenario
    and UI. We then create the application around the components in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are merits to both these approaches, and the choice can be based on your
    team, the existing components, requirements, and so on. In most cases, it is best
    for you to make the choice based on the least resistance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the approach of the specification is top-down; everything is
    laid out for you from the user scenario and will allow you to organically build
    the application around the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into the specifications and the mindset of the feature being
    delivered, it is important to understand the fundamentals of testing a component
    class. A component in Angular is a key feature used in most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready to go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our sample application (`quickstart`) has some very basic test specs for unit
    and end-to-end testing. We will start the TDD approach from the very beginning,
    so we will not use any of the test specs and the existing component's code in
    our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For that, what can we do is just clean up this sample application, and we will
    just keep the folder structure and application bootstrap files.
  prefs: []
  type: TYPE_NORMAL
- en: So, first of all, we will have to remove the unit test file (`app.component.spec.ts`)
    and end-to-end test files (`app.e2e-spec.ts`). These are two test specs that existed
    in the application structure.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a simple component test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing a component, it's important to inject the component into the test
    suite and then initiate the component class as the second task. The tests confirm
    that either the objects or methods in the component's scope are available as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the component instance in the test suite, we will use the simple `import`
    statement in the test suite and initiate the component object in the `beforeEach`
    method so that we have a new instance of the component object for every test spec
    with that test suite. Here is an example of what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, as long as the component class is initiated for every test spec, it will
    have a new instance for every spec, and the internal scope will act based on that.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test a component, it's important to initialize the component class so that
    we have the component object available to the test suite's scope and all the members
    of the object are available around the specific test suite.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the component contains the template to render the UI, it's important
    to initialize the component before beginning e2e testing, and it depends on DOM
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when we plan to do e2e testing for any component, we should initiate that
    in the DOM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: End-to-end versus unit test for components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we looked at the component test suite, which is for
    unit testing, and we have to import and create an instance of the component class
    as the unit test. We will test the functionality or feature of every method that
    is defined in the component.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, for end-to-end testing, we do not need to import or create
    an instance of the component class as we will not need to comment with the competent
    object or all its members. Rather, it needs to interact with the DOM elements
    of the landing page of the application that is running.
  prefs: []
  type: TYPE_NORMAL
- en: So, for that, we will need to run the application and navigate the test suite
    to the application landing page, and we can do so with the global `browser` object
    provided by Protractor itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can navigate to all the URLs of the application using `browser.get('path')`
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into our comment application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the setup and approach have been decided, we can start our first test.
    From a testing point of view, as we will be using a top-down approach, we will
    write our Protractor tests first and then build the application. We will follow
    the same TDD life cycle we have already reviewed: test first, make it run, and
    make it better.'
  prefs: []
  type: TYPE_NORMAL
- en: Test first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scenario given is already in a well-specified format and fits our Protractor
    testing template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing the scenario in the template, we get the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Following the 3 A's (assemble, act, assert), we will fit the user scenario in
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: Assemble
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The browser will need to point to the first page of the application. As the
    base URL has already been defined, we can add the following to the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the test has been prepared, we can move on to the next step: act.'
  prefs: []
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we need to do, based on the user specification, is to add an
    actual comment. The easiest thing is to just put some text into an input box.
    The test for this, again without knowing what the element will be called or what
    it will do, is to write it based on what it should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to add the comment section for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last assembly component, as a part of the test, is to click on the **Submit**
    button. This can be easily achieved in Protractor using the `click` function.
    Even though we don''t have a page yet, or any attributes, we can still name the
    button that will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will hit the crux of the test and assert the user's expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The user expectation is that once the **Submit** button is clicked on, the comment
    is added. This is a little ambiguous, but we can determine that somehow the user
    needs to get notified that the comment was added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest approach is to display all comments on the page. In Angular, the
    easiest way to do this is to add an `*ngFor` object that displays all comments.
    To test this, we will add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the test has been constructed and meets the user specifications. It is
    small and concise. Here is the completed test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Make it run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the errors and output of the test, we will build our application as
    we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the web server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the Protractor test to see the first error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first error could be that it''s not getting the element the locator expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the error is simple: it''s not getting the element as defined
    in the locator. We can see the current application and why it''s not getting the
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: Recap the present application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as we have cloned the sample Angular `quickstart` project as our application
    to test, it has a ready Angular environment. It Bootstraps the Angular project
    with a simple application component defined with `My First Angular 2 App` as the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: So, in our TDD approach, we should not have any environment/Angular Bootstrap-related
    error, and it seems we are on the right path.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what we have right now in our sample application. On our
    landing page, `index.html`, we have included all required library files and implemented
    `system.js` to load the application files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `<body>` tag in the `index.html` file, we have initiated the application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML tag expects a component with `my-app` as the selector for that component,
    and yes, we have that as `app.component.ts`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Angular introduced `ngModule` as an `appModule` to modularize and manage dependencies
    for every component. With this `appModule`, an application can define all the
    required dependencies at a glance. Besides that, it helped lazy-load the modules.
    We will look at the details of `ngModule` in the Angular docs.
  prefs: []
  type: TYPE_NORMAL
- en: It imports all the required modules in the application, declares all the modules
    from a single entry point, and also defines the Bootstrapping component.
  prefs: []
  type: TYPE_NORMAL
- en: The application always Bootstraps based on this file's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is located at the application root as `app.module.ts`, and it looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point to the application is the `main.ts` file, which will import
    the `appModule` file and instruct to Bootstrap the application based on that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The test couldn't find our input locator. We need to add the input to the page,
    and we need to do that via the component's template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the steps we need to follow to add the input to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to add a simple `input` tag to the template of the application
    component, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the test again, it seems that there are no more errors related
    to the input locator, but it has a new error as the `button` tag was missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the previous error, we need to add a `button` to the template with
    the appropriate text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the test again, it seems that there are no more errors related
    to the `button` locator, but again, it has a new error, as follows, as the repeater
    locator is missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This appears to be a result of our assumption that a submitted comment will
    be available on the page through `*ngFor`. To add this to the page, we will use
    a method in the component class to provide the data for the repeater.
  prefs: []
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, the error occurs because there is no
    `comments` object. In order to add the `comments` object, we will use the component
    class that has an array of `comments` in its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a `comments` object to the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already have `AppComponent` as a class in our component, we will need
    to define the comments array, which we can use in a repeater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add a repeater for the comments in the template, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the Protractor test and see where we are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Oops! We are still getting the same error. However, don't worry; there might
    be some other issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the actual page that gets rendered and see what's going on. In
    Chrome, navigate to `http://localhost:3000` and open the console to see the page
    source (*Ctrl + Shift + J*). Note that the repeater and component are both there;
    however, the repeater is commented out. Since Protractor is only looking at visible
    elements, it won't find the list.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now we know why the repeater list isn't visible, but we have to fix it.
    In order for a comment to show up, it has to exist on the component's `comments`
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest change is to add something to the array to initialize it, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the test, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Great, it seems we are getting closer as the errors have gone down! We have
    tackled almost all the unexpected errors and met our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: So let's take a look at the changes that we have made so far and what our codes
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `body` tag of the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The application component file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Make it pass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With TDD, we want to add the smallest possible component to make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have hard coded the comments array for the moment to be initialized
    to three items and the first items to be `First comment`, change `First comment`
    to `a sample comment`; this should make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test, and bam! We get a passing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a second! We still have some work to do. Although we got the test to pass,
    it is not done. We added some hacks just to get it to pass. Two things stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: We clicked on the **Submit** button, which really doesn't have any functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We hardcoded the initialization of the expected value for a comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding changes are critical steps that we need to perform before we move
    forward. They will be tackled in the next phase of the TDD life cycle, that is,
    make it better (refactor).
  prefs: []
  type: TYPE_NORMAL
- en: Make it better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two components that need to be reworked are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior to the **Submit** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the hardcoded value of the comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Submit button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Submit** button needs to actually do something. We were able to sidestep
    the implementation by just hardcoding the value. Using our tried-and-trusted TDD
    techniques, switch to an approach focused on unit testing. So far, the focus has
    been on the UI and pushing changes to the code; we haven't written a single unit
    test.
  prefs: []
  type: TYPE_NORMAL
- en: For this next bit of work, we will switch gears and focus on driving the development
    of the **Submit** button through tests. We will be following the TDD life cycle
    (test first, make it run, and make it better).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Karma
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We did something very similar for the to-do list application in [Chapter 3](ch03.html
    "Chapter 3. The Karma Way"), *The Karma Way*. We won't spend as much time diving
    into the code, so review the previous chapters for a deeper discussion of some
    of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps we need to follow to configure Karma:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `files` section with the added files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Start Karma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that Karma is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Test first
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s start with a new file in the `spec/unit` folder, called `app.component.spec.ts`.
    This will contain the test spec for the unit test. We will use the base template,
    including all necessary imports, such as `TestBed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: According to the specification, when the **Submit** button is clicked on, it
    needs to add a comment. We will need to fill in the blanks of the three components
    of a test (assemble, act, and assert).
  prefs: []
  type: TYPE_NORMAL
- en: '**Assemble**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior needs to be part of a component for the frontend to use it. The
    object under testing in this case is the component''s scope. We need to add this
    to the assembly of this test. Like we did in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*, we will do the same in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, the component object and its member are available in the test suite and
    will be testable as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Act**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification determines that we need to call an `add` method in the component
    object. Add the following code to the `beforeEach` section of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, the assertion should get the first comment to test.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assert**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assert that the comment items in the `component` object now contain any comment
    as the first element. Add the following code to the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, and let's move on to the next step of the life cycle and make
    it run (execute).
  prefs: []
  type: TYPE_NORMAL
- en: Make it run
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have prepared the test, we need to make the test pass. Looking
    at the output of the console where Karma is running, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at our unit test, we see that this is the `add` function. Let''s go
    ahead and put in an `add` function into the controller''s `scope` object using
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the controller scope and create a function named `add`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Check Karma''s output, and let''s see where we are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have hit the expectation. Remember to think of the smallest change
    to get this to work. Modify the `add` function to set the `$scope.comments` array
    to any comment when called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `unshift` function is a standard JavaScript function that adds an item to
    the front of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we check Karma''s output, we''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Success! The test passes, but again needs some work. Let's move on to the next
    stage and make it better (refactor).
  prefs: []
  type: TYPE_NORMAL
- en: Make it better
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The main point that needs to be refactored is the `add` function. It doesn''t
    take any arguments! This should be straightforward to add, and simply confirms
    that the test still runs. Update the `add` function of `app.component.ts` to take
    an argument and use that argument to add to the `comments` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the output window of Karma and ensure that the test still passes. The
    complete unit test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppComponent` class file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Backing up the test chain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We completed the unit test and added the `add` function. Now we can add the
    function to specify the behavior of the **Submit** button. The way to link the
    `add` method to the button is to use the `(click)` event. The steps to add the
    behavior to the **Submit** button are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Hold on! Is the value hardcoded? Well, again, we want to make the smallest change
    and ensure that the test still passes. We will work through our refactors until
    the code is how we want it to be, but instead of a Big Bang approach, we want
    to make small, incremental changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's rerun the Protractor test and ensure that it still passes. The output
    says that it passed, and we are okay. The hardcoded value wasn't removed from
    the comments. Let's go ahead and remove that now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `AppComponent` class file should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Run the test and see that we still get a passing test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to mop up is the hardcoded value in `(click)`. The comment
    being added should be determined by the input in the comment input text.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps we need to follow to bind the input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to bind the input to something meaningful, add an `ngModel` attribute
    to the `input` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `(click)` attribute, simply use the `newComment` model as the
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have to import the form module in the app module (`app.module.ts`)
    as it''s a dependency for `ngModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Run the Protractor test and confirm that everything has passed and is good to
    go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Onward and upward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the first specification working, and it is end-to-end and unit
    tested, we can start the next specification. The next specification states that
    the user wants the ability to like a comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the top-down approach and start our test from Protractor. We will
    continue to follow the TDD life cycle: test first, make it run, and make it better.'
  prefs: []
  type: TYPE_NORMAL
- en: Test first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the pattern, we will start with a basic Protractor test template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When we fill in the specification, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With the template in place, we are ready to construct the test.
  prefs: []
  type: TYPE_NORMAL
- en: Assemble
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The assembly of this test will require a comment to exist. Place the comment
    within the existing posted comment test. It should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Act
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user specification we test is that the **Like** button performs an action
    for a specific comment. Here are the steps that will be required and the code
    required to carry them out (note that the following steps will be added to the
    `beforeEach` text):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the first comment so that it can be used in the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the first comment''s `likeButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the **Like** button when it is clicked on is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Assert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The specification expectation is that once the comment has been liked, it is
    liked. This is best done by putting an indicator of the number of likes and ensuring
    that the count is `1`. The code will then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The created test now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Make it run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test has been prepared and is itching to run. We will now run it and fix
    the code until the test passes. The following steps will detail the error and
    fix the cycle required to make the test path:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Protractor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the error message in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As the error states, there is no **like** button. Go ahead and add the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Run Protractor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the next error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: By adding the **like** button, we caused our other test to fail. The reason
    is our use of the `getText()` method. Protractor's `getText()` method gets the
    inner text, including inner elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To fix this, we need to update the previous test to include **like** as part
    of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Run Protractor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the next error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to add a `likes` binding. This one is a little more involved. The `likes`
    needs to be bound to a comment. We need to change the way the comments are held
    in the component. Comments need to hold the `comment` title and the number of
    likes. A comment should be an object like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Again, the focus of this step is just to get the test to pass. The next step
    is to update the component's `add` function to create comments based on the object
    that we described in the preceding steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `app.component.ts` and edit the `add` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the page to use the value for the comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Before rerunning the Protractor test, we need to add the new `comment.likes`
    binding to the HTML page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now rerun the Protractor tests, and let''s see where the errors are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'As the inner text of the comment has changed, we need to change the expectation
    of the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Run Protractor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are down to the expectation of the test. In order to make this
    test pass, the smallest change will be to make the **like** button update the
    likes on the `comment` array. The first step is to add a `like` method to the
    controller, which will update the number of likes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Link the `like` method to the HTML page using a `(click)` attribute on the
    button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Run Protractor and confirm that the tests pass!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The page now looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make it run](graphics/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compared with the diagram at the beginning of this chapter, all the features
    have been created. Now that we've made the test pass in Protractor, we need to
    check the unit tests to ensure that our changes didn't break the them.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the primary changes required was to make the comment an object consisting
    of a value and the number of likes. Before thinking too much about how the unit
    tests could have been affected, let''s kick them off. Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the error is related to the new `comment` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Reviewing the expectation, it seems like the only thing required is for `comment.value`
    to be used in the expectation, as opposed to the `comment` object itself. Change
    the expectation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and check the Karma output. Confirm that the test passes. Both
    the Karma and Protractor tests pass, and we have completed the primary user behaviors
    of adding a comment and liking it. We are now free to move on to the next step
    and make things better.
  prefs: []
  type: TYPE_NORMAL
- en: Make it better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All in all, the approach ended with the result we wanted. Users are now able
    to like a comment in the UI and see the number of likes. The major thing from
    a refactor standpoint is that we have not unit-tested the `like` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing our development to-do list, we see that the list is an action that
    we wrote down. Before completely wrapping up the feature, let's discuss the option
    of adding a unit test for the `like` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Coupling the test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already discussed, tests are tightly coupled to the implementation. This
    is a good thing when there is a complicated logic involved or we need to ensure
    that certain aspects of the application behave in certain ways. It is important
    to be aware of the coupling and know when it is important to bring it into the
    application and when it is not. The `like` function, which we created, simply
    increments a counter on an object. This can be easily tested; however, the coupling
    that we will bring in with a unit test will not give us the extra value.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will not add another unit test for the `like` method. As the
    application progresses, we may find the need to add a unit test in order to develop
    and extend the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some things I consider when adding a test:'
  prefs: []
  type: TYPE_NORMAL
- en: Does adding a test outweigh the cost of maintaining it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the test adding value to the code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it help other developers understand the code better?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the functionality being tested in some or the other way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on our decision, there is no more refactoring or testing required. In
    the next section, we will take a step back and review the main points of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Karma needs the Selenium WebDriver to run tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Q2\. Given the following code segment, how would you select the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '`element.all(by.button(''button''))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`element.all(by.css(''type=button''))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`element(by.buttonText(''Click Me'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the TDD techniques of using Protractor and
    Karma together. As the application was developed, we were able to see where, why,
    and how to apply TDD testing tools and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The approach, top-down, was different from the bottom-up approach discussed
    in [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, and [Chapter
    4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing
    with Protractor*. With the bottom-up approach, the specifications are used to
    build unit tests and then build the UI layer on top of that. In this chapter,
    a top-down approach was shown to focus on the user's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-down approach tests the UI and then filters the development through
    the other layers. Both the approaches have their merits. When applying TDD, it
    is essential to know how to use both. In addition to walking through a different
    TDD approach, we saw some of the core testing components of Angular, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component from end-to-end and unit perspectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a component class to the test suite and initiating it for unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protractor's ability to bind to `ngModel`, send keystrokes to input columns,
    and get an element's text by its inner HTML code and all subelements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will build on the techniques used here and look into headless
    browser testing, advanced techniques for Protractor, and how to test Angular routes.
  prefs: []
  type: TYPE_NORMAL

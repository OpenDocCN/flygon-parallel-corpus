- en: Chapter 8. Telling the World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build up of TDD focused on fundamental components, namely the life cycle
    and process, using step-by-step walk-throughs. We have studied several applications
    from the ground up, understanding how to build Angular applications and use tools
    to test them.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to expand further into the depths of Angular and integrate services,
    EventEmitters, and routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be slightly different from the others in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of building a brand new application, we will use the search application
    from [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will add the unit tests for Angular routes and navigation that were skipped
    in previous chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will make the existing search application more modern by separating the commonly
    used actions into services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take advantage of the Angular `EventEmitter` class to communicate between
    the different components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready to communicate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow a different approach in this chapter, as we've already learned the
    TDD approach. We developed a small project in the previous chapter, and our plan
    is to work with that project and make it better in order to present it to the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: So, before the walk-through, we will have to review and identify any problems
    and the scope for improvement of the project. To do so, we have to be confident
    of the code base of the search application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, we will copy the project from [Chapter 7](ch07.html "Chapter 7. Flip
    Flop"), *Flip Flop*, which was originally from [https://github.com/angular/quickstart](https://github.com/angular/quickstart), and
    rename it `angular-member-search`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed and get ready to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To confirm the installation and run the project, the application will automatically
    run it in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output we should get when we will run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading the existing project](graphics/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oh! We have our end-to-end test ready in the project. Before we go for an update,
    we have to be sure that the existing e2e tests are successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `e2e` test in a separate console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, everything passes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading the existing project](graphics/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with the top-down approach. The goal was
    to elaborate on end-to-end testing based on what we had learned. We had the user
    scenario clear, we went through the tests, and our scenario passed our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we only covered end-to-end testing. So, in this chapter,
    we'll cover unit tests as much as we can.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the previous chapter, we mostly looked at Angular routes and navigation.
    So now, as a logical extension, we will look at how to test Angular routes and
    navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go ahead with the component test, we should discuss some points about testing
    Angular components. We already have a basic idea: in Angular, everything is a
    combination of some components. So it would be great for us to learn in more detail
    about Angular component testing.'
  prefs: []
  type: TYPE_NORMAL
- en: We can test a component in various ways, based on its behavior and use case.
    We could even have test specs for multiple components when they work together
    as an application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at some of the ways of testing components.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Isolated testing, also known as solo testing, is named so because this type
    of test can run without the need to compile components according to test specs.
    If it doesn't compile, it will not have the compiled template in the test spec;
    only the component class and its methods. This means that if a component's features
    are not very DOM dependent, it can be tested in an isolated manner.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated testing is mostly used for complex feature or calculation testing,
    where it just initiates the component class and calls all the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the unit tests of [Chapter 6](ch06.html "Chapter 6. The
    First Step"), *The First Step*, where `AppComponent` was responsible for adding
    comments and increasing their likes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Shallow testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Isolated testing sometimes fulfills the requirements of the test spec, but not
    always. Most of the time, components have DOM dependent features. In such cases,
    it is important to render the component's template in the test specs so that we
    have the compiled template in the scope and test specs are able to interact with
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to write a basic unit test for our `AppComponent`, which
    is mostly DOM dependent as there is no method in the component class, then we
    just need to compile the component and check that it is defined. In addition,
    we can have a test spec if the component's template has the correct text inside
    the `<h1>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Integration testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some key points on integration testing:'
  prefs: []
  type: TYPE_NORMAL
- en: The name *integration testing* should give us some idea of what kind of test
    it is. It is similar to shallow testing as it also needs to compile the component
    with the template and interact with the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will next look at our route and navigation test suite, where we will integrate
    the `AppComponent`, router, and navigation test suites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a test suite ready for `AppComponent`, as it includes the `navbar` component
    and `router-outlet` component. All of these together work to fulfill the routing
    specs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, to get a confident test spec for a router, we should go with integration
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at an example of router testing with a detailed explanation in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main difference between integration testing and shallow testing is that
    integration testing works for the test suite of the complete application, or a
    small portion of the application, where multiple components work together to solve
    some purpose. It shares some similarities with end-to-end testing, but with a different
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Karma configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, the default Karma configuration was used, but no explanation
    about this default configuration has been given yet. **File watching** is a useful
    default behavior that will now be reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: File watching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: "File watching is enabled by default when the Karma `init` command is used.\
    \ \LFile watching in Karma is configured with the following definition in the\
    \ \L`karma.conf.js` file:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The file watching feature works as expected and watches the files defined in
    the configuration's `files` array. When a file is updated, changed, or deleted,
    Karma responds by rerunning the tests. From a TDD perspective, this is a great
    feature, as tests will continue to run without any manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main point to watch out for is the addition of files. If the file being
    added doesn''t match the criteria in the `files` array, the `autoWatch` parameter
    won''t respond to the change. As an example, let''s consider that the files are
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this is the case, the watcher will find all the files and subdirectory files
    ending in `.js`. If a new file is in a different directory, not in `dir1`, then
    the watcher will not be able to respond to the new file because it is in a different
    directory from what it was configured in.
  prefs: []
  type: TYPE_NORMAL
- en: Testing routers and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were introduced to Angular routers and navigation alongside the general components
    in [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed the different types of tests for Angular components, routers
    and navigation, we will look at integration testing. For that, we will use our
    application component test, that is, our base component, and we will then integrate
    navigation and `router-outlet` component tests with the application component
    to test the router.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the app component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go ahead with router testing, we will get ready with our application
    component tests. In the app component test, we will test whether the component
    is defined and initiated correctly, and then we will test the page title by selecting
    the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned about shallow testing in previous sections; when we interact with
    DOM elements, we need shallow testing. The same goes here: as we will have to
    deal with DOM elements, we will use shallow testing as our application component
    test.'
  prefs: []
  type: TYPE_NORMAL
- en: For shallow testing, we will need to depend on the `TestBed` Angular test API
    from Angular core testing, which will be used to compile and initiate the components
    in the test suite. Besides that, we will have to depend on the `ComponentFixture`
    module from core testing. We will need two more modules, named `By` and `DebugElement`,
    from the Angular core and platform APIs to interact with DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app component test will be located at `spec/unit/app.component.ts` and
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this test, we will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our application component test is ready now; next, we will perform a router
    test, including `router-outlet` and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular router is not part of Angular core; it's a separate module that
    has to be imported before being used. It has some directives, such as `RouterOutlet`
    and `RouterLink`, which play an active role in fulfilling router activities. To
    test the router, first we will test these directives, in order to prepare the
    platform for testing the complete router.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can test the router using the actual router module, but sometimes it creates
    some complexity for the entire routing system. Due to this, test specs may fail
    without providing an accurate error. To avoid this, it's recommended to create
    router stubs and use those for router testing.
  prefs: []
  type: TYPE_NORMAL
- en: Router stubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I had the router stubs idea from Angular's official testing docs. I liked the
    idea about the routing stubs and copied the `router-stubs` file from `angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts`
    in Angular's GitHub repository. The first router stubs directive is `RouterStubLinksDirective`,
    which is responsible for hosting the element or anchor link (`<a>`) to perform
    the `click` event for the directive's `onClick()` method. The URL bound to the
    `[routerLink]` attribute flows to the directive's `linkParams` property. When
    the anchor link (`<a>`) is clicked on, it should trigger the `onClick()` method,
    and it will set to the tentative `navigateTo` property.
  prefs: []
  type: TYPE_NORMAL
- en: This `router-stubs` file has a dependency on the Angular router and relevant
    directives, including `RouterLink` and `RouterOutlet`, so we will need to import
    those.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the router stubs will be located at `spec/unit/stub/router-stub.ts`, and
    the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Beside the `RouterLinkStubDirective`, this stub should contain the `RouterOutletStubComponent`
    to support the `router-outlet` directive, and `RouterStub` to support the main
    router module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The router-outlet and navigation test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we know, the `router-outlet` and navigation (`RouterLink`) menus work together
    with the application landing page, that is, our application component. The testing
    mechanism will be of the same form. This means that we will test both of these
    modules with the application component.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned a bit earlier, we will use an integration test here for `router-outlet`
    testing. We have our application component test suite ready; now it's time to
    integrate `router-outlet` and navigation (`RouterLink`), and we will have our
    integration test suite for the application component along with `router-outlet`
    and `RouterLink`.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `navbar` component, which is basically a navigation component that contains
    the `RouterLink` to navigate through the router. We will have to import that component
    to our test suite for it to perform correctly. Besides the actual router module,
    we will have to import the `RouterStub` that we have created. To reiterate, `router-stubs`
    contains the `RouterOutletStubComponent` and `RouterLinkStubDirective` components.
  prefs: []
  type: TYPE_NORMAL
- en: After importing all the required components, we will have to declare them in
    the `TestBed` configuration. And, as a part of the setup, we will get all the
    `navLinks` from the `RouterLinkStubDirective` in the test suite's scope to test
    and bind `click` events to the `linkParams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test suite''s setup will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For the test specs, first we will test the link parameters in the navigation
    menu. We have the `navLinks`, and we will match them with the `linkParams` of
    the `navLinks`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will test the expected navigation while clicking on the navigation
    menu items. We will test that with the help of the `navigatedTo` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test specs will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, we can say that this will cover the tests for `router-outlet` and routerLink,
    which will confirm that the router links are working as expected, and that we
    are able to navigate though the expected router after clicking on the navigation
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an integration test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our test specs are ready. We have been planning for an integrated test, and
    we can perform one now. Here, we are combining the app component and `navbar`
    component, along with `router-outlet` and `routerLink`, to test the route and
    navigation. We have to interact with DOM elements with the help of the `debugElement`
    module from the browser platform API.
  prefs: []
  type: TYPE_NORMAL
- en: The test suite is ready--time to run the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And all the test specs pass as expected. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: More tests...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just added some tests that will cover a few of the features that we have
    developed so far, mostly focused on the router (`router-outlet` and `routerLink`).
  prefs: []
  type: TYPE_NORMAL
- en: We will add more tests for members and the search feature, but we will update
    the behavior of the existing features of searching and member listing. Besides
    that, our current code base does not have proper decoupling between the components'
    features, which will make it complex to test features individually.
  prefs: []
  type: TYPE_NORMAL
- en: We already have the end-to-end test, which will verify the output we expect
    from our components, but for unit testing, we will need to refactor the code and
    decouple them. We will cover the tests for the rest of the features after we update
    the behavior and refactor the correct code base.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of the application behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a quick overview of the search application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our search application invokes the Members component in the DOM. It contains
    two major parts: the search area and the result area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the search area, we type a search query and submit it to get the expected
    result in the result area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting area lists down the member list based on the search query. We
    may have figured out that we get all the data during the initialization of the
    `Members` component; that's because we call the Members component's `search()`
    method with `ngOnInit()`, and it returns all the data as our logic has been set
    to return all data when no search query is set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By clicking on a member's name, we can see the detailed information about that
    member on the details page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the application behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the previous specification, it seems we have some incorrect behavior
    in the search feature. Right now, we are calling `search()` when initializing
    the members of the search component. This seems a bit wrong; we should start the
    search after entering the search query and/or clicking on the **Search** button.
  prefs: []
  type: TYPE_NORMAL
- en: The expected behavior is that it will first load all the member data and then,
    after starting the search, the data list will be updated based on the search query.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, let's update the `ngOnInit()` method in `members.component.ts` and
    add a new method, `getMember()`, to have the entire data list during component
    initiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected change will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Identifying the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the existing code, it seems we have defined the `getData()` method
    twice, in `members.component.ts` and `person.component.ts,` because in both the
    components, we had to call the JSON data source to get the member dataset.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the problem with that? It's bad practice as it duplicates code, and
    duplication of code is hard to manage when the application becomes large and complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, now we have the following method twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we have to to change the data source URL or API, we will have to change this
    method in two places. It's not so tough to change it twice, but what about 10-12
    times, or even more for a larger application?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it's a problem, and it needs a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve identified the problem, which is code duplication. We know the solution:
    we have to write the method in a common place and use it in both components. In
    short, we have to make this method reusable so that every component can share
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: It seems simple, but we have to do it in the Angular way. We can't just move
    the method to a separate file and import that.
  prefs: []
  type: TYPE_NORMAL
- en: Angular introduced services for such situations. We'll now look at some of those
    services with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Angular services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular services were introduced to write code shareable among components. So
    if we need a piece of code for many components, it's recommended to create a single
    reusable service, and wherever we need that piece of code, we can just inject
    that service to the component and use its methods as needed.
  prefs: []
  type: TYPE_NORMAL
- en: "Services are used to abstract application logic. They are used to provide a\
    \ single responsibility for a particular action. Single responsibility allows\
    \ components to \Lbe easily tested and changed. This is because the focus is on\
    \ one component and \Lnot all the inner dependencies."
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, a service acts as the data source of any application. Whenever we need
    a piece of code to communicate with the server to get data (mostly JSON), we use
    a service.
  prefs: []
  type: TYPE_NORMAL
- en: This is because most components need to access data, and everyone can inject
    the common service as required. So, we have a commonly used piece of code, which
    is actually the data layer for our application. We should move those parts to
    a service to make our application smart so that we can tell the world we are not
    duplicating code in any way.
  prefs: []
  type: TYPE_NORMAL
- en: We have service now?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As planned, we have moved the `getData()` method from the `members.component.ts`
    and `person.component.ts` components to a new file so that we can get rid of code
    duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new file at `app/services/members.service.ts`, make a new class
    to export, called `MembersService`, and move the `getData()` method there. Besides
    moving the method, we will have to import `{ Http, Response }` from the Angular
    HTTP module as `getData` has a dependency on HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have a service now, and we can start using it. Let's import and use it in
    the Members component.
  prefs: []
  type: TYPE_NORMAL
- en: Wait; before that, we will have to import the service into the application module
    to have identification of it. As long as it's a service, we will have to identify
    it as a provider; the service will act as a service provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `app.module.ts` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, to use the service in our component, we have to import and inject it into
    our MembersComponents with the service name `MembersService`. As long as we inject
    the service as the constructor of the component, we will have the service available
    to the entire component. To access the method, we need to call it `this.membersService.getData()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our Members component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Time to run and look at the output and see how the service works with the Members
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Lets point the browser to `http://localhost:3000/members`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! What happened? We are getting an error in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the error, we have made a mistake: `SystemJS` (used as the module
    loaded) can''t inject `MembersService` as we missed adding something to the service
    to make it perfect. In Angular, we have to mention in every service whether it will
    be injectable; without doing so, we will not be able to inject that service into
    any component.'
  prefs: []
  type: TYPE_NORMAL
- en: And, for that, we will have to use the Angular **Injectable** decorator. We
    will take a look at it in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Injectable services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Injectable decorator is a part of the Angular core library, used when creating
    injectable services. Without defining it as injectable, it's not possible to identify
    the dependency of a service. To define it as injectable, we will have to use `@Injectable()`
    at the top of the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have made the service injectable. Now, we should be fine to inject it into
    the Members component and point our browser to `http://localhost:3000/members`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hurray! No more errors, and we are getting the expected data list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injectable services](graphics/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Seems like our service is injectable and working fine. It's time to implement
    it in the `PersonComponent`, as we need the data service on that component as
    well. The same as the Members component, let's import and inject it into the `PersonComponent`
    with the service name `membersService`. Again, we will have to access the data
    service method with `this.membersService.getData()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PersonComponent` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Time to run and look at the output of how the service is working with the Members
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our e2e test, which will confirm that everything is going well with
    the new changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, everything passes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injectable services](graphics/chapter_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yay! Our code refactoring hasn't affected our expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Services will serve you more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To reap the complete benefits of services, we will move two more methods from
    the Members and Person components. Before that, those methods were component specific;
    now, by adding them to a service, those methods can be used from any component
    just by injecting the service.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps we will benefit later from this change but want to keep these methods
    decoupled from the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly added code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Testing the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal behind the code decoupling and separation was to make the code testable.
    We did so, and we have separated the data retrieval part from the Members component
    and made a service so that it will be easy to test. The service is injectable;
    other than that, it's similar to an angular component. So, to perform unit testing,
    we will test the methods that the service contains.
  prefs: []
  type: TYPE_NORMAL
- en: Testing service injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other Angular components, we can test whether the service is defined well.
    But the main difference is that, as long as the service is injectable, we will
    need to inject it in the test specs to get the instance to test.
  prefs: []
  type: TYPE_NORMAL
- en: For a sample test spec, we can set it up so that it will import the `TestBed`
    and `inject`, and then configure the `TestingModule` using MembersService as the
    provider. Then, in the test spec, we will inject the service and check whether the
    service is defined as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sample test suite will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For this test, the expected result will be true.
  prefs: []
  type: TYPE_NORMAL
- en: Testing HTTP requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To have a unit test for HTTP requests, we will have to use the async technique
    to keep the HTTP call asynchronous, and in Angular testing, we will use the `fakeAsync`
    module, which is an async module to use with mock HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, "mock"?
  prefs: []
  type: TYPE_NORMAL
- en: Well yes; to test HTTP requests in an Angular test suite, we don't need to make
    actual HTTP requests. To achieve the effect of an HTTP request, we can mock out
    our HTTP services; Angular has provided a mock service called **MockBackend**.
  prefs: []
  type: TYPE_NORMAL
- en: '`MockBackend` is a class that can be configured to provide mock responses for
    HTTP mock requests, and it will work exactly the same as HTTP services but without
    making the actual network requests.'
  prefs: []
  type: TYPE_NORMAL
- en: After we have configured the `MockBackend`, it can be injected into HTTP. So,
    from our service where we used `http.get`, we'll have the expected data returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test suite with the HTTP request will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, at first, besides importing the `MockBackend`, we are importing the `MockConnection`,
    which is used to subscribe to the backend connection and provide the connected
    data to the next steps. Then, we configure the `MockBackend`, which will return
    the HTTP object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will get ready with our test specs by injecting `MockBackend` and
    `MembersService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the test spec, we have injected `MockBackend`, in addition to the MembersService.
    `MockBackend` will subscribe to the `backend` service with the MockConnection object.
    MockConnection will create a new `ResponseOptions` object, where, with a `ResponseOptions`
    object we can configure our response properties.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we just set the `body` property of the response object and set the `body`
    value to a predefined `mockData` object.
  prefs: []
  type: TYPE_NORMAL
- en: Service stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can test the service with stub data as well. For example, we can make a stubbed
    version of our `MembersService` called `MembersServiceSpy`, which will fake all
    the necessary features of that service.
  prefs: []
  type: TYPE_NORMAL
- en: This fake service will return a resolved `Promise` with mock data, so we can
    just use this stubbed method for testing. It will create a spy for all of the
    methods we have in the service and return a separate `Promise` for every single
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stubbed service will be located at `spec/unit/stub/members.service.stub.ts`,
    and it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Service test with stubbed data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will test the `MembersService` with stubbed data. To do so, we will
    need to import the stubbed service. And with the `TestBed` configuration, we will
    have to provide `MemberServiceSpy` as a service instead of an actual member service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MembersService` test suite''s code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Combining and running the service's tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two test suites for the Members service here. We can bring both together
    and run the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full test suite''s code will look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The test suite for the Members service is ready to run. Let''s run it with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All the test specs pass as expected. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Communicating through the power of events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has more powerful event-handling capabilities compared to Angular 1.x.
    Angular 1.x has two-way data binding, whereas Angular doesn't recommend that.
    Angular handles the communication between data and templates through the power
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: Angular projects stand on the combination of some components. To function, these
    components need to communicate with each other to share data and events. Mostly,
    components need to communicate when they have a parent-child relationship. There
    are a few ways in which Angular can communicate between parent and child components.
    The best is by handling custom events. We will look at details about custom events
    and see how they work with our search application.
  prefs: []
  type: TYPE_NORMAL
- en: Angular events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Angular recommends one-way data binding, which means only from components
    to DOM elements. This is unidirectional data flow, and it is how Angular works.
    What about when we need data flow in the other direction--from DOM elements to
    components? Doing so depends on different events, such as clicks, keystrokes,
    mouseover, and touch. These events will bind with DOM elements to listen to user
    action and pass that action to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event binding syntax consists of the target event with parentheses to the
    left-hand side of the equals sign. The component contains the target event as
    a method, so whenever the event triggers, it will call the method from the component.
    Let''s look at the event that we have in the search form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Any element's events are the common targets, but it's a bit different with Angular,
    as Angular at first checks whether the target name matches with the event property
    of any known directives or components.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom events are raised by directives or components with Angular `EventEmitter`.
    Directives create an `EventEmitter` object and expose themselves as its property
    to be passed via the `@Output` decorator. We will look at details of `@Output`
    decorator next. After exposing an `EventEmitter` object as a property, the directives
    will call `EventEmitter.emit(value)` to fire the event and pass the value to the
    parent directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom directive/component class will define the custom event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Parent directives will listen for the event by binding to this property and
    will receive the value through the `$event` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent directive/component will contain the custom directive as follows,
    where it will contain the custom event as `someCustomEvent`, which will trigger
    the `doSomething()` method of the parent directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent directive/component will contain the `doSomething()` method, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The Output and EventEmitter APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Output is a decorator class from the Angular core that is used to pass custom
    events from a child to a parent component. To use it, we need to import it from
    `@angular/core`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we set a custom event as `@Output`, that event will be available to listen
    to in the parent component. This decorator will be placed inside the class, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`EventEmitter` is also a core class of Angular. When we need to use it, we
    will have to import it from `@angular/core`. The `EventEmitter` API is used to
    notify the parent component by calling `EventEmitter.emit(value)` whenever the
    value changes in the child component. As we know, the parent component always
    listens to the custom event.'
  prefs: []
  type: TYPE_NORMAL
- en: Planning further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The search application we have so far is a simple search application. But we
    can make it better by keeping it as simple as it is. What I mean is, we can do
    this in the best way, like we were trying to decouple the data logic by separating
    the reusable code in the new service.
  prefs: []
  type: TYPE_NORMAL
- en: We still have a few more things to improve. It seems our application has not
    yet decoupled perfectly. Our components have not decoupled as we'd expected. We
    are talking about the `MembersComponent`, which contains the search feature and
    member listing feature.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow the single responsibility principle here, which means every component
    should have a single responsibility. Here, `MembersComponent` has two. So we should
    break down this component to two separate components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's break it down to two separate components, called `MembersComponent` and
    `SearchComponent`. In fact, we just made a plan for a new component called `SearchComponent`
    and brought the search feature over there from the Members component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make a plan for the behavior expected from both components:'
  prefs: []
  type: TYPE_NORMAL
- en: The search component will have the responsibility of taking the user input as
    a search query and getting the expected search result using the service we have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then pass the search result to the Members component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Members component will get the search result from the search component and
    will bind the data list to the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both components will communicate and exchange data using events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plan is to make this simple app perfect by following best practices and
    using the built-in powers of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The search component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As planned, we will have to separate the search feature from the Members component.
    To do that, let's create a new component called `SearchComponent` at `app/search/search.component.ts`
    and create the search component's template file. The template file will simply
    contain the search form.
  prefs: []
  type: TYPE_NORMAL
- en: The search component file will have to import and inject the `MembersService`,
    as that will be used to perform the search based on the search query. The component
    will have the search query and will request the service for search and get the
    search result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search component''s code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The template of the search component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As long as our application output doesn't break, we will have to bind the search
    component to the members list page, as it was before. So, we will have to append
    the search component to the template of the Members component. In that case, it
    will become the child component of the Members component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template of the Members component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Enabling sharing between components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have two separate components, the search and Members components. The
    search component has been appended to the Members component, but search results
    are not available in the Members component.
  prefs: []
  type: TYPE_NORMAL
- en: Search and Members are separate components, and there is no bridge between them.
    Both have an isolated scope to contain their elements and variables.
  prefs: []
  type: TYPE_NORMAL
- en: To share data between components, we need to enable communication between them.
    As explained before, Angular events will come to our rescue for us to enable communication
    between the search and Members component. From the search component, we will need
    to use Angular custom events to communicate with its parent component, `MembersComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the parent component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search component is the child component of the Members component. They need
    to communicate with each other to share data. We will need to use custom events
    with the help of the Angular `EventEmiiter` API so that we can emit the search
    result from the search component after getting the result. And besides that, we
    will need to use the `@OutPut` decorator to set the search result as the output
    to use for the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: To use both, we will need to import both from Angular core. Then, we will need
    to set `@Output` searchResult to a new instance of EventEmitter. This `@Output`
    decorator makes the `searchResult` property available as an event binding.
  prefs: []
  type: TYPE_NORMAL
- en: When the search component updates the search result, we would like to tell the
    parent component that the `searchResult` event has happened. To do so, we will
    need to call `emit(data)` with the `searchResult` we have declared as the Emitter
    object with the Output decorator. The `emit()` method is used to notify every
    time the result has been passed via a custom event.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the Members component can fetch the `$event` object, as we've passed it
    into the template using `(searchRessult)="anyMethod($event);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating with `EventEmitter`, the search component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to communicate with the `MembersComponent`. Let's declare the
    `onSearch()` method in the member component, which will accept the event as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Members component will change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we are appending the search component from the members template, let's hook
    the `onSearch` function to the search component tag. We will call this `(searchResult)`--with
    parentheses around it--to tell Angular that this is an event binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template of the search component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Check output after refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search application will be rebranded into a store application instead of
    rewriting the search functionality that has already been written. In order to
    leverage the existing search project, it will be copied into a new project file.
    Then, the new project will use the tests to drive the development changes and
    refactoring. The refactoring steps have been left out, but a review of the code
    will show how the code and tests were modified to create the product application.
  prefs: []
  type: TYPE_NORMAL
- en: Time to run it and see how the service works with the Members component. Let's
    point our browser to `http://localhost:3000/members`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Check output after refactoring](graphics/chapter_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have the e2e test, which will confirm that everything''s going well with
    the new changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, we can see that everything passes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Check output after refactoring](graphics/chapter_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes! Our code refactoring hasn't affected our expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Current project directory**'
  prefs: []
  type: TYPE_NORMAL
- en: We have updated and refactored the code, for which we have some new components,
    services, and so on. Now, we will have a new project structure, separating the
    logic and decoupling the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current directory structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Check output after refactoring](graphics/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, I have tried to cover the topics to a certain level so that anyone
    can start with test-driven development based on Angular. But there are a lot of
    things we have skipped, most importantly, rxJS.
  prefs: []
  type: TYPE_NORMAL
- en: rxJS is a separate module based on reactive programming. So, we will need to
    be familiar with reactive programming to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP requests by default return observables as responses in Angular instead
    of resolved promises. Since we didn't look at rxJS here, we skipped observables
    and converted the responses to promises. But we should learn how observables work
    with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and subscribing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Publishing and subscribing messages is a powerful tool, but as with anything,
    when used the wrong way, it can lead to a mess.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which messages can be published: emit or broadcast. It
    is important to know the difference, as both work slightly differently and they
    may affect the performance of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. A callback function refers to a function that is called after an asynchronous
    function completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q2\. Asynchronous functions always complete in the order in which they were
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q3\. There is a module called `MockBackend` to fake HTTP calls in Angular for unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q4\. In Angular, the `EventEmitter` API is used for component communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored services in Angular and the power of events. We
    also saw some examples of the separation of code with services and events.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we looked at different types of testing for Angular components
    and wrote unit tests for the Angular router, and we integrated it with application
    components and navigation. We also explored further configuration of Karma in
    order to use its features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're at the end of the book, it's time to apply our knowledge in the real
    world. Before leaving, let's have a quick recap of what we have learned. We learned
    about TDD, how TDD works with JavaScript context, and the available testing tools,
    techniques, and frameworks. We learned about Karma and Protractor with real Angular
    projects. And now we know how to write unit and e2e tests for Angular projects.
  prefs: []
  type: TYPE_NORMAL
- en: This book showed you the path to practicing TDD; now it's your job to keep learning,
    improve on this knowledge, and practice more with complex projects to be more
    confident with TDD.
  prefs: []
  type: TYPE_NORMAL

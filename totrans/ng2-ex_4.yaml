- en: Chapter 4.  Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Personal Trainer The 7 Minute Workout app has been an excellent opportunity
    for us to learn about Angular. Working through the app, we have covered a number
    of Angular constructs. Still, there are areas such as Angular form support and
    client server communication that remain unexplored. This is partially due to the
    fact that 7 Minute Workout from a functional standpoint had limited touchpoints
    with the end user. Interactions were limited to starting, stopping, and pausing
    the workout. Also, the app neither consumes, nor produces any data (except workout
    history).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans that we already have.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and model-driven. We''re working with both template-driven and model-driven forms
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ngModel**: This provides two-way databinding for template driven forms and
    allows us to track changes and validate form input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model Driven Form Controls**: These include the form builder, form control,
    form group, and form array. These are used to construct forms programmatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Personal Trainer app - the problem scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *7 Minute Workout* app is good, but what if we could create an app that
    allows us to build more such workout routines customized to our fitness level
    and intensity requirements? With this flexibility, we can build any type of workout
    whether it is 7 minutes, 8 minutes, 15 minutes, or any other variations. The opportunities
    are limitless.
  prefs: []
  type: TYPE_NORMAL
- en: With this premise, let's embark on the journey of building our own *Personal
    Trainer* app that helps us to create and manage training/workout plans according
    to our specific needs. Let's start with defining the requirements for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new *Personal Trainer* app will now encompass the existing *7 Minute Workout*
    app. The component that supports workout creation will be referred to as `Workout
    Builder`. The *7 Minute Workout* app itself will also be referred to as `Workout
    Runner`. In the coming chapters, we will fix *Workout Runner*, allowing it to
    run any workout created using *Workout Builder*.
  prefs: []
  type: TYPE_NORMAL
- en: Personal Trainer requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to list all available workouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add/remove multiple exercises for workouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to order exercises in the workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to save workout data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to list all available exercises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add pictures for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add related videos for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add audio clues for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the requirements seem to be self-explanatory; hence, let's start with the
    design of the application. As customary, we first need to think about the model
    that can support these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The Personal Trainer model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No surprises here! The Personal Trainer model itself was defined when we created
    the *7 Minute Workout* app. The two central concepts of workout and exercise hold
    good for *Personal Trainer* too.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem with the existing workout model is that it is in the directory
    for workout-runner. This means that in order to use it, we will have to import
    it from that directory. It makes more sense to move the model into the `service`
    folder so that it is clear that it can be used across features.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand how we can share the model across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the workout model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to share the workout model as a **service**. As mentioned in the
    previous chapter, a **service** has no particular definition. Basically, it is
    a class that holds functionality that might be useful to have in multiple locations
    throughout our application. Since it will be used in both Workout Runner and Workout
    Builder, our workout model fits that definition. There is not much ceremony involved
    in making our model into a **service** - so let's get started by doing that.
  prefs: []
  type: TYPE_NORMAL
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is available on GitHub [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: **GitHub Branch: checkpoint4.1**. If you are
    not using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the layout and styles of the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/components`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get back to defining the model.
  prefs: []
  type: TYPE_NORMAL
- en: The model as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we dedicated a complete section to learning about Angular
    services, and one thing we found out was that services are useful for sharing
    data across controllers and other Angular constructs. We essentially do not have
    any data but a blueprint that describes the shape of the data. The plan, hence,
    is to use services to expose the model structure. Open the `model.ts` file present
    in the `services` folder under `app`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `model.ts` file has been moved into the `services` folder as the service
    is shared across the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1`
    we have updated the import statements in `workout-runner.component.ts`, `workout-audio.component.ts`
    and `workout-audio0.component.ts` in the `workout-runner` folder under `trainer/src/components`
    to reflect this change.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*, we reviewed the class definitions in the model file: `Exercise`, `ExercisePlan`,
    and `WorkoutPlan`. As we then mentioned, these three classes constitute our base
    model. We will now start using this base model in our new app.
  prefs: []
  type: TYPE_NORMAL
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  prefs: []
  type: TYPE_NORMAL
- en: The Personal Trainer layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Personal Trainer layout](../Images/image00452.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top Nav**: This contains the app branding title and history link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub Nav**: This has navigation elements that change based on the active component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left Nav**: This contains elements that are dependent upon the active component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Area**: This is where the main view for our component will display.
    This is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/components`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  prefs: []
  type: TYPE_NORMAL
- en: Personal Trainer navigation with routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder` | This just redirects to **builder/workouts**. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder*. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workout/new` | This creates a new workout. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercises` | This lists all the available exercises. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercise/new` | This creates a new exercise. |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID. |'
  prefs: []
  type: TYPE_TB
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, if you look at the route configuration in `app.routes.ts` in
    the `src/components/app` folder, you will find one new route definition - `builder`
    **:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And if you run the application, you will see that the start screen shows another
    link: **Create a Workout:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](../Images/image00453.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Behind the scenes, we have added another router link for this link into `start.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you click on this link, you will be taken to the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](../Images/image00454.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again behind the scenes, we have added a `WorkoutBuilderComponent` in the `trainer/src/components/workout-builder`
    folder with the following related template in `workout-builder.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.ts` view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have wrapped this component in a new module named `workout-builder.module.ts:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids our importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So nothing surprising here. These are the basic component building and routing
    patterns that we introduced in the previous chapters. Following these patterns,
    we should now begin to think about adding the additional navigation outlined previously
    for our new feature. However, before we jump into doing that, there are a couple
    of things we need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: First, if we start adding our routes to the `app.routes.ts` file then the number
    of routes stored there will grow. These new routes for *Workout Builder* will
    also be intermixed with the routes for *Workout Runner.* While the number of routes
    we are now adding might seem insignificant, over time this could get to be a maintenance
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to take into consideration that our application now consists
    of two features - *Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, we want **loose-coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the first chapter, we emphasized that this ability to separate
    our components from each other is one of the key advantages of using the **component
    design pattern** that Angular implements. Fortunately, Angular's router gives
    us the ability to separate out our routing into logically organized **routing
    configurations** that closely match the features in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to accomplish this separation, Angular allows us to use **child routing**
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing child routes to Workout Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as-is to show the before and after comparison):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing child routes to Workout Builder](../Images/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started by adding child routing to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from checkpoint 4.2 in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `app.css` in the `trainer/static/css` folder that are part
    of this checkpoint since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) and workout(s) from the `trainer/src/components/workout-builder`
    folder in the repository. At this stage these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.2**. . If you are not using Git, download
    the snapshot of Checkpoint 4.2 (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the child routing component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routes.ts`
    with the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `ModuleWithProviders` from the
    Angular core module and `Routes` and `RouterModule` from the Angular router module.
    These imports will give us the ability to add and export child routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then add the following route configuration to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first configuration, path: ''builder'', sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following `export` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This export registers our child routes with the router and is very similar
    to the one in app.routes.ts, with one difference: instead of `RouterModule.forRoot`
    we are using `RouterModule.forChild`. The reason for the difference may seem self-explanatory: we
    are creating child routes, not the routes in the root of the application, and
    this is how we signify that. Under the hood, however, there is a significant difference.
    This is because we cannot have more than one router service active in our application.
    `forRoot` creates the router service but `forChild` does not.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the WorkoutBuilder component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `selector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the reference to a `templateUrl` with a `template` reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `<sub-nav>` custom element to the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `<router-outlet>` tag to the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The decorator should now look like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are removing the selector because the `WorkoutBuilderComponent` will not
    be embedded in the application root: `app.component.ts`. Instead, it will be reached
    from `app.routes.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will in turn be routing them to the other components
    contained in the Workout Builder feature.
  prefs: []
  type: TYPE_NORMAL
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are also swapping out the `templateUrl`
    for an inline template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file. The separate HTML
    file allows you to use an HTML editor with features such as color coding and tag
    completion. In contrast, an inline template is simply a string within a TypeScript
    file and the editor does not give you these benefits.
  prefs: []
  type: TYPE_NORMAL
- en: We are also adding a `<sub-nav>` element that will be used to create a secondary
    top-level menu for navigating within the *Workout Builder* feature. We'll discuss
    that a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Workout Builder module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's update `WorkoutBuilderModule`. This is going to involve some significant
    changes since we will be turning this module into a feature module. So this module
    will import all the components that we will be using for building a workout. We
    won't cover all those imports here, but be sure to add them from `workout-builder.ts`
    in the `trainer/src/components/workout-builder` folder in `checkpoint 4.2` of
    the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'One import that is worth highlighting is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It imports the child routing that we just set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update the `@NgModule` decorator to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Updating app.routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last step: return to `app.routes.ts` and remove the import of the `WorkoutBuilderComponent`
    and its route from that file.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the previous chapter, we already know how to set up root routing for our
    application. But now what we have instead of root routing is area or feature routing
    that contains child routes. We have been able to achieve the separation of concerns
    we discussed earlier, so that all the routes related to the *Workout Builder*
    are now separately contained in their own routing configuration. This means that
    we can manage all the routing for *Workout Builder* in the `WorkoutBuilderRoutes`
    component without affecting other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](../Images/image00456.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    takes us to this location?
  prefs: []
  type: TYPE_NORMAL
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app.routes.ts` for the `builder` path because that file contains the configuration
    for the root routes in our application. The router does not find that path because
    we have removed it from the routes in that file.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the `WorkoutBuilderComponent` has been imported into our `AppModule`
    and that component in turn imports `workoutBuilderRouting` from `workout-builder-routes.ts`.The
    latter file contains the child routes that we just configured. The router finds
    that `builder` is the parent route in that file and so it uses that route. It
    also finds the default setting that redirects to the child path `workouts` in
    the event that the `builder` path ends with an empty string, which it does in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workout-builder.routes.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of route resolution is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](../Images/image00457.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its `parent` component, `app.component.ts`
    (as we mentioned earlier, the `<selector>` tag has been removed, so the `Workout
    Builder` component is not being embedded in the root component). This means that
    we have successfully encapsulated `Workout Builder` (and all of the components
    that it imports) in a way that will allow us to move all of it elsewhere in the
    application or even into a new application.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `app.css` file, which we are not discussing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.3** (folder - `trainer`). If you are not
    using Git, download the snapshot of Checkpoint 4.3 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading of routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we roll out our application, we expect that our users will be accessing
    the **Workout Runner** every day (and we know that this will be the case for you!).
    But we anticipate that they will only occasionally be using the *Workout Builder*
    to construct their exercises and workout plans. It would therefore be nice if
    we could avoid the overhead of loading the **Workout Builder** when our users
    are just doing their exercises in the **Workout Runner**. Instead, we would prefer
    to load *Workout Builder* only on demand when a user wants to add to or update
    their exercises and workout plans. This approach is called **lazy loading**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under the hood, Angular uses SystemJS to accomplish this lazy loading. It allows
    us to employ an asynchronous approach when loading our modules. This means that
    we can load just what is required to get the application started and then load
    other modules as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the **Sources** tab, start up the application; when the start page
    appears in your browser, you see that all the files in the application have loaded,
    including both the *Workout Runner* and *Workout Builder* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of routes](../Images/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not **need** the *Workout Builder* when
    the application is first loaded. Instead, we would like to load those resources
    only when the user decides that they want to add or change a workout or exercise.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started with making that happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify the `app.routes.ts` to add the following separate route configuration
    for our `workoutBuilderRoutes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `loadChildren` property is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This configuration provides the information that will be needed to load and
    instantiate our component. Pay particular attention to the file path; it points
    to the location of our code in the `dist` folder when it is deployed as a JavaScript
    file and not to the folder where the TypeScript version of that file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the `Routes` configuration to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we have added a reference to `WorkoutBuilderRoutes`, which
    we just configured and prepended with three dots. With the three dots we are using
    the ES2015 spread operator to insert an array of routes - specifically the routes
    for the `WorkoutBuilder` feature. These routes will be contained in `WorkoutBuilderRoutes`
    and will be maintained separately and apart from the routes in the root of our
    application. Finally , remove the import of the `WorkoutBuilderComponent` from
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next go back to `workout-builder.routes.ts` and change the `path` property
    to an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are making this change because we are now setting the path ('`builder`')
    to the `WorkoutBuilderRoutes` in the new configuration for them that we added
    in `app.routes.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally go back to the `app-module.ts` and remove the `WorkoutBuilderModule`
    import in the `@NgModule` configuration in that file. What this means is that
    instead of loading the **Workout Builder** feature when the application first
    starts, we only load it when a user accesses the route to *Workout Builder*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back and run the application again keeping the **Sources** tab open
    in the Chrome developer tools. When the application begins and the start page
    loads, only the files related to the *Workout Runner* appear and not those related
    to the *Workout Builder*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of routes](../Images/image00459.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if we clear the **Network** tab and click on the **Create a Workout link**,
    we''ll see only the files related to the *Workout Builder* load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of routes](../Images/image00460.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the files that are now loaded all relate to the *Workout Builder.*
    This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to *have our cake and eat it too*. On one hand, we can build single-page
    applications with powerful client-side navigation, while on the other hand we
    can also encapsulate features in separate child routing components and load them
    only on demand.
  prefs: []
  type: TYPE_NORMAL
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to creating the sub-level and left navigation; this
    will enable us to use this routing. The next sections cover implementing this
    navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating sub- and side-level navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-level navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavComponent` into the *Workout Builder*. But currently
    it is just displaying placeholder content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sub-level navigation](../Images/image00461.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll now replace that content with three router links: **Home**, **New Workout**,
    and **New Exercise**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `sub-nav.component.html` file and change the HTML in it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now rerun the application and you will see the three navigation links. If we
    click on the **New Exercise** link button, we will be routed to `ExerciseComponent`
    and its view will appear in the **Router Outlet** in the *Workout Builder* view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sub-level navigation](../Images/image00462.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **New Workout** link button will work in a similar fashion; when clicked
    on, it will take the user to the `WorkoutComponent` and display its view in the
    router outlet. Clicking on the **Home** link button will return the user to the
    `WorkoutsComponent` and view.
  prefs: []
  type: TYPE_NORMAL
- en: Side navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Side level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the **Workouts** screen because the `WorkoutsComponent`'s
    route is the default route for the *Workout Builder*. That component will need
    side navigation; it will allow us to select to view a list of workouts or a list
    of exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  prefs: []
  type: TYPE_NORMAL
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Side navigation](../Images/image00463.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won't show the code for these two menus here but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/components` in `checkpoint 4.3` of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the menu for the **Workouts** screen, the steps are the same except that
    you should change `left-nav-exercises.component.html` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing workout and exercise lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even before we start implementing the **Workout** and **Exercise** list pages,
    we need a data store for exercise and workout data. The current plan is to have
    an in-memory data store and expose it using an Angular service. In [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*,
    where we talk about server interaction, we will move this data to a server store
    for long-term persistence. For now, the in-memory store will suffice. Let's add
    the store implementation.
  prefs: []
  type: TYPE_NORMAL
- en: WorkoutService as a workout and exercise repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder
    - `trainer`). If you are not using Git, download the snapshot of Checkpoint 4.4
    (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `app.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate `workout-service.ts` in the `trainer/src/services` folder. The code
    in that file should look like the following except for the implementation of the
    two methods `setupInitialExercises` and `setupInitialWorkouts`, which we have
    left out because of their length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` to support injecting it throughout our application. In the
    class definition, we first create two arrays: one for `Workouts` and one for `Exercises`.
    These arrays are of types `WorkoutPlan` and `Exercise` respectively, and we therefore
    need to import `WorkoutPlan` and `Exericse` from `model.ts` to get the type definitions
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor calls two methods to set up the **Workouts** and **Services
    List**. At the moment, we are just using an in-memory store that populates these
    lists with data.
  prefs: []
  type: TYPE_NORMAL
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing we need to do to make the service available to be injected
    throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `services.module.ts` in the same folder, and then import `WorkoutService` and
    add it as a provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This registers `WorkoutService` as a provider with Angular's **Dependency Injection**
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Time to add the components for the workout and exercise lists!
  prefs: []
  type: TYPE_NORMAL
- en: Workout and exercise list components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/components/workout-builder/workouts`
    folder and update the imports as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This new code imports `OnInit` from the Angular core as well as `Router`, `WorkoutService`
    and the `WorkoutPlan` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next replace the class definition with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a constructor into which we are injecting the `WorkoutService`
    and the `Router`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList` array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of Workout plans that will display in the `Workouts` component's view.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    an `ngOnInit` method. We want to avoid placing this code in the constructor. Eventually,
    we will be replacing the in-memory store that this service uses with a call to
    an external data store and we do not want the instantiation of our component to
    be affected by this call. Adding these method calls to the constructor would also
    complicate testing the component.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's lifecycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way we rely on Angular
    to call this method in a predictable way that does not affect the instantiation
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Next we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because it so similar to what we just showed you for the `Workouts` component,
    we won't show that code here. Just add it from the `workout-builder/exercises`
    folder `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Workout and exercise list views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to implement the list views that have so far been empty!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will be updating the code from `checkpoint 4.3` with what
    is found in `checkpoint 4.4`. So if you are coding along with us, simply follow
    the steps laid out in this section. If you want to see the finished code, then
    just copy the files from `checkpoint 4.4` into your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Workouts list views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement
    we assign `workout` as a local variable that we use to iterate through the worklist
    and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This sets up navigation to the workout detail page. This navigation happens
    when we double-click on an item in the workout list. The selected workout name
    is passed as part of the route/URL to the workout detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the **Workout** screen and the workout name `7MinWorkout` will appear at the
    end of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Workouts list views](../Images/image00464.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises list views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view. Except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (that will display when
    user navigates to the `Workouts` component to create/edit a workout).'
  prefs: []
  type: TYPE_NORMAL
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So we
    won't show that code here. Just add the files for `exercise.conponent.ts` and
    `exercise.component.html` from `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: When you are done copying the files, click on the **Exercises** link in the
    left navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Double-clicking on an item in the exercises list takes us to the exercise
    detail page. The selected exercise name is passed as part of the route/URL to
    the exercise detail page.
  prefs: []
  type: TYPE_NORMAL
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Again we won't show that code here. Just add the
    files for `left-nav-exercises.component.ts` and `left-nav-exercises.component.html`
    from the `trainer/src/components/navigation` folder in `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done copying those files, click on the **New Workout** button on
    the sub-navigation menu in the *Workout Builder* and you will now see a list of
    exercises, displayed in the left navigation menu exercises that we have already
    configured in `WorkoutService`.
  prefs: []
  type: TYPE_NORMAL
- en: Time to add the ability to load, save, and update exercise/workout data!
  prefs: []
  type: TYPE_NORMAL
- en: Building a workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once complete, the *Workout Builder* page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a workout](../Images/image00465.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  prefs: []
  type: TYPE_NORMAL
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This page operates in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**/**New**: This mode is used for creating a new workout. The URL is
    `#/ builder/workout/new`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit**: This mode is used for editing the existing workout. The URL is `#/
    builder/workout/:id`, where `:id` maps to the name of the workout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  prefs: []
  type: TYPE_NORMAL
- en: Finishing left nav
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrownext to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now we will go ahead and do that.
  prefs: []
  type: TYPE_NORMAL
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic, and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  prefs: []
  type: TYPE_NORMAL
- en: So we introduce a new service into the picture: the `WorkoutBuilderService`.
    The ultimate aim of the `WorkoutBuilderService` service is to co-ordinate between
    the `WorkoutService` (which retrieves and persists the workout) and the components
    (such as `LeftNavExercisesComponent` and others we will add later), while the
    workout is being built, hence reducing the amount of code in `WorkoutComponent`
    to the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Adding WorkoutBuilderService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` tracks the state of the workout being built. It:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracks the current workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads the existing workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves the workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/components` in `checkpoint 4.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.5** (folder - `trainer`). If you are not
    using Git, download the snapshot of Checkpoint 4.5 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `app.css` file, which we are not discussing here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we will register it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the relevant parts of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `Exercise`,
    and `WorkoutService`, so we import these into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService` **:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  prefs: []
  type: TYPE_NORMAL
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to left nav and implement the remaining functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding exercises using ExerciseNav
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add exercises to the workout we are building, we just need to import and
    inject `WorkoutBuilderService` into the `LeftNavExercisesComponent` and call its
    `addExercise` method, passing the selected exercise as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  prefs: []
  type: TYPE_NORMAL
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Workout` component is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Workout` component is associated with two routes/views, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  prefs: []
  type: TYPE_NORMAL
- en: How is this done? `WorkoutComponent` is associated with two routes, namely `/builder/workout/new`
    and `/builder/workout/:id`. The difference in these two routes lies in what is
    at the end of these routes; in one case, it is `/new`, and in the other` /:id`.
    These are called **route parameters.** The `:id` in the second route is a token
    for a route parameter. The router will convert the token to the ID for the workout
    component. As we saw earlier, this means that the URL that will be passed to the
    component in the case of *7 Minute Workout* will be `/builder/workout/7MinuteWorkout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the **Workout** tiles
    on the **Workouts** screen that takes us to the **Workout** screen, we designated
    the workout name as the parameter for the ID, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are constructing the route using the programmatic interface for the
    router (we covered routing in detail in the previous chapter, so we won't go over
    that again here). The `router.navigate` method accepts an array. This is called
    the **link parameters array**. The first item in the array is the path of the
    route, and the second is a route parameter that specifies the ID of the workout.
    In this case, we set the `id` parameter to the workout name. From our discussion
    of routing in the previous chapter, we know that we can also construct the same
    type of URL as part of a router link or simply enter it in the browser to get
    to the **Workouts** screen and edit a particular workout.
  prefs: []
  type: TYPE_NORMAL
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  prefs: []
  type: TYPE_NORMAL
- en: Route guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead we want to have
    the user redirected to another page or back to where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine if the navigation
    to the component needs to be cancelled or not. And all of this is done before
    the component loads so it is never seen if the routing is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`. At this point we are interested in
    the first of these these hooks: `CanActivate`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CanActivate route guard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CanActivate` guard permits navigation to proceed or stops it based on the
    conditions that we set up in the implementation that we provide. In our case,
    what we want to do is use `CanActivate` to check the validity of any id that is
    passed for an existing workout. Specifically, we will run a check on that ID by
    making a call to the `WorkoutService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will let the navigation proceed; if not we will stop
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `workout.guard.ts` from the workout-builder/workout folder under `trainer/src/components`
    in `checkpoint 4.5` and you will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the guard is an injectable class that implements the `CanActivate`
    interface. We implement the interface with the `CanActivate` method. The `CanActivate`
    method accepts two parameters; the `ActivatedRouteSnapshot` and the `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters. This
    parameter contains a `params` array from which we extract the id parameter for
    the route.
  prefs: []
  type: TYPE_NORMAL
- en: The `CanActivate` method can return either a simple `boolean` value or an `Observable<boolean>`.
    The latter is useful if we have to make an asynchronous call as part of the method.
    If we return an `Observable`, the router will wait until the asynchronous call
    is resolved before proceeding with navigation. In this case, however, we are not
    making such an asynchronous call, as we are using a local in-memory data store.
    So we are just returning a simple true/false `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, when we start using the HTTP module to make asynchronous
    calls to an external data store, we will refactor this code to return an `Observable<boolean>`.
  prefs: []
  type: TYPE_NORMAL
- en: This code injects the `WorkoutService` into the guard. The `CanActivate` method
    then calls the `GetWorkout` method of the `WorkoutService` using the parameter
    supplied in the route. If the workout exists, then `canActivate` returns true
    and the navigation proceeds; if not, it re-routes the user to the workouts page
    and returns false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in implementing `WorkoutGuard` is to add it to the route configuration
    for `WorkoutComponent`. So update `workout-builder.routes.ts` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, we are assigning `WorkoutGuard` to the `canActivate`
    property of the route for `WorkoutComponent`. This means that `WorkoutGuard` will
    be called prior to the router navigating to `WorkoutComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout component continued...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under trainer/src/components in
    `checkpoint 4.5`. (Also copy `workout-builder.module.ts` from the `workout-builder`
    folder. We'll discuss the changes in this file a little later when we get to Angular
    forms.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have added the following `ngOnInit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The method subscribes to the route parameters and extracts the `id` parameter
    for the workout. If no ID is found, then we treat it as a new workout since `workout/new`
    is the only path that is configured in `WorkoutBuilderRoutes` that we allow to
    reach this screen without an ID. In that case, we provide an empty string as a
    parameter in the call to the `StartBuilding` method of the `WorkoutBuilderService`, which
    will cause it to return a new Workout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are subscribing to the route parameters because they are `Observables`, which
    can change during the lifetime of the component. This gives us the ability to
    reuse the same component instance with different parameters even though the `OnInit`
    life cycle event for that component is called only once. We'll cover `Observables`
    in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/components` in `checkpoint 4.5`. Run the app, navigate
    to `/builder/workouts`, and double-click on the *7 Minute Workout* tile. This
    should load the *7 Minute Workout* details with a view similar to the one shown
    at the start of the *Building a workout* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    **GitHub repository: Branch: checkpoint4.5** (folder - `trainer`).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  prefs: []
  type: TYPE_NORMAL
- en: The Delete button to delete the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reorder buttons to move the exercise up and down the list as well as to the
    top and bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration and a button
    to save workout changes.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So what are these
    capabilities?
  prefs: []
  type: TYPE_NORMAL
- en: Angular forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think carefully, any form of interaction boils down to:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating those inputs against business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting the data to the backend server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular has something to offer for all the preceding use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides constructs to validate the input before it can be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, Angular provides `http` services for client-server interaction and persisting
    data to the server. We'll cover those services in [Chapter 5](part0056.xhtml#aid-1LCVG2
    "Chapter 5.  Supporting Server Data Persistence"), *Supporting Server Data Persistence*.
  prefs: []
  type: TYPE_NORMAL
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven and model-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular offers two types of forms: **template-driven** and **model-driven**.
    We''ll be discussing both types of form in this chapter. Because the Angular team
    is indicating that many of us will primarily use **template-driven forms**, that
    is what we will start with in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form-inputs,
    data validation, saving, and updating-in form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way databinding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, e-mail not in the right format, and
    so on).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configurations. First, open the `systemjs.config.js` file in the
    `trainer` folder in `checkpoint 4.5` and add forms to the `ngPackageNames` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, SystemJS will download this module for use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the copy of `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/components` in `checkpoint 4.5`. You will see that it
    adds the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that we will be using the forms module. Once we make this change,
    we will not have to do any further imports related to forms in the `Workout` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings in all the directives that we will need to implement our form including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NgForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start using these to build our form.
  prefs: []
  type: TYPE_NORMAL
- en: Using NgForm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our template, we have added the following `form` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `#f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  prefs: []
  type: TYPE_NORMAL
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was **not** triggered by our assigning `ngForm`
    to a local variable. Instead, it happened *auto-magically* because we imported
    the forms module into `workout-builder.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of the `NgForm` directive are now available to use with the form. These include
    the `ngSubmit` event, which signals when a user has triggered a form submission
    and provides the ability to validate the entire form before submitting it.
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the fundamental building blocks for template-driven forms is `ngModel`
    **,** and you will find it being used throughout our form. One of the primary
    roles of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    This is also due to the fact that `ngModel` is only applied to elements that allow
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, we already have a model that we are using for the **Workout**
    page-`WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `WorkoutPlan` model we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have decorated both model classes with `@Injectable`. This is
    used so that TypeScript will generate the necessary metadata for the entire object
    hierarchy, in this case the nested classes `ExercisePlan` within `WorkoutPlan`
    and `Exercise` within `ExercisePlan`. What this means is that we can create complex
    hierarchies of models that can all be data-bound within our form using `NgModel`.
  prefs: []
  type: TYPE_NORMAL
- en: So throughout the form, whenever we need to update one of the values in a `WorkoutPlan`
    or an `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model
    will be represented by a local variable named `workout` in the following examples).
  prefs: []
  type: TYPE_NORMAL
- en: Using ngModel with input and textarea
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open `workout-component.html` and look for `ngModel.` Here too, it has only
    been applied to HTML elements that allow user data input. These include input,
    textarea, and select. The workout name input setup looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  prefs: []
  type: TYPE_NORMAL
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textarea` element works the same as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression against any of the linked inputs such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Open the **Workout** page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ngModel with input and textarea](../Images/image00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using ngModel with select
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at how select has been set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `ngFor` component will loop over the array and populate the dropdown values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation -- `{{duration.title}}`. And `[(ngModel)]` then
    binds the drop-down selection to the `exercisePlan.duration` in the model. Notice
    here that we are binding to the nested model: `ExercisePlan`. This is powerful
    stuff that enables us to create complicated forms with nested models, all of which
    can use `ngModel` for databinding**.**
  prefs: []
  type: TYPE_NORMAL
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch the model
    updated instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add validation to our form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: **GitHub Branch: checkpoint4.6** (folder - `trainer`). Or if you are
    not using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `app.css` file, which we are not discussing here.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the saying goes, *Never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern as well as custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control. The workout name `input` tag should now
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also add the required attribute for all the required fields.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular model state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touched`: This is `true` if the control ever had focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pristine`\`dirty` or `touched`\`untouched` are useful properties that can
    help us decide when error labels are shown.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular CSS classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-valid`: This is used if the model is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: This is used if the model is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: This is used if the model is pristine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: This is used if the model is dirty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: This is used when the input is never visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-touched`: This is used when the input has focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the tag, add the following label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the application and click on the **New Workout** link in the *Workout
    Builder*. Before touching anything on the screen, you will see the following displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular CSS classes](../Images/image00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add some content into the **Name** input box and tab away from it. The label
    changes to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular CSS classes](../Images/image00468.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This draws a red border around any input control that has invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  prefs: []
  type: TYPE_NORMAL
- en: Workout validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The workout data needs to be validated for a number of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel`tracks changes in the state of these controls and how it toggles the
    CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying appropriate validation messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now the input needs to have a value; otherwise, the validation fails. But how
    can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We are showing the validation message in the event that the name is not provided
    **and** the control has not been touched. To check the first condition, we retrieve
    the `hasError` property of the control and see if the error type is `required`.
    We check to see if the name input has been `touched` because we do not want the
    message to display when the form first loads for a new workout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying appropriate validation messages](../Images/image00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding more validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular provides four out-of-the-box validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve seen how the `required` validator works. Now let''s look at two of the
    other out-of-the-box validators: `minLength` and `maxLength`. In addition to making
    it required, we want the title of the workout to be between 5 and 20 characters
    (we''ll look at the `pattern` validator a little later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add another label with a message that will display when this validation
    is not met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Managing multiple validation messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not `scale` for more complicated scenarios. Some inputs contain a lot of
    validations and controlling when a validation message shows up can become complex.
    As the expressions for handling the various displays get more complicated, we
    may want to refactor and move them into a custom directive. Creating a custom
    directive will be covered in detail in [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6. 
    Angular 2 Directives in Depth"), *Angular 2 Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation messages for an exercise
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will attach a validation message to it similar to what we just did
    with our other validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the new Workout page, add an exercise, and remove it; we should see the
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom validation messages for an exercise](../Images/image00470.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives
    in Depth"), *Angular 2 Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the remove method we will set that value to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next will add `removeTouched` to our validation message conditions, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the workout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutService` needs two new methods: `addWorkout` and `updateWorkout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `save` method calls either `addWorkout`, or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  prefs: []
  type: TYPE_NORMAL
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at - `NgForm` in more detail, let''s add the save method to
    `Workout` to save the workout when the `Save` button is clicked on. Add this code
    to the `Workout` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  prefs: []
  type: TYPE_NORMAL
- en: More on NgForm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The `novalidate` attribute
    on the form directive tells the browser not to do inbuilt input validations (this
    is not Angular-specific but is an HTML 5 attribute).
  prefs: []
  type: TYPE_NORMAL
- en: The standard form behavior of posting data to the server using full-page post-back
    does not make sense with an SPA framework such as Angular. In Angular, all server
    requests are made through asynchronous invocations originating from directives
    or services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking validation errors at the form or control level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute,
    but this will definitely cause a full-page refresh. We'll explore the specifics
    of the `NgForm` API a little later in this chapter when we look at saving the
    form and implementing validation.
  prefs: []
  type: TYPE_NORMAL
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more issue before we finish this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the saving of forms and validation messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open a new Workout page and directly click on the **Save** button. Nothing
    is saved as the form is invalid, but validations on individual form input do not
    show up at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Remember that earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of `Workout`
    class definition and set its initial value to `false`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable will be set to true on the `Save` button click. Update the save
    implementation by adding the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Nonetheless, how does this help? Well, there is another part to this fix that
    requires us to change the error message for each of the controls we are validating.
    The expression now changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now open the new **Workout** page and click on the **Save** button, we
    should see all validation messages on the input controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the saving of forms and validation messages](../Images/image00471.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Model-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other type of form that Angular supports is called **model-driven** forms.
    As the name implies **model-driven forms** start with a model that is constructed
    in a component class. With this approach, we use the **form builder API** to create
    a form in code and associate it with a model.
  prefs: []
  type: TYPE_NORMAL
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using model-driven forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  prefs: []
  type: TYPE_NORMAL
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using model-driven forms we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant advantage of model-driven forms, is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Model-driven forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    model-driven forms (although it can be used). The overall approach is a cleaner
    and less cluttered template with more focus on the code that drives the form.
    Let''s get started with building a model-driven form.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with model-driven forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll make use of model-driven forms to build the form to add and edit **Exercises**.
    Among other things this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective model-driven forms can be in developing more
    complex forms. Here is how the form will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with model-driven forms](../Images/image00472.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`ReactiveFormsModule` contains what we will need to build model-driven forms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/components` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add it as an additional provider to the providers array in that same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice here that we also have added `ExerciseGuard` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder.routes.ts`, which adds it as
    a route guard for the navigation to `ExerciseComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `exercise.component.ts` and add the following import statement at
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings in the following, which we will use to construct our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FormBuilder API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FormBuilder` API is the foundation for model-driven forms. You can think
    of it as a factory for turning out the forms we are constructing in our code.
    Go ahead and add the `ngOnInit` lifecycle hook to your class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When `ngOnInit` fires it will call a method for building our form (in addition
    to setting up the exercise we are building). So, at this stage of the component
    lifecycle, we are starting the process of constructing our form in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the `buildExerciseForm` method by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls with setting them up outside
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can not only build up `FormControls` in our form this way, but also add
    `FormControlGroups` and `FormControlArray` that contain `FormControls` within
    them. This means we can create complex forms that contain nested input controls.
    In our case, as we have mentioned, we are going to need to accommodate the possibility
    of our users adding multiple videos to an exercise. We can do this by adding the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the form model to our HTML view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Within the tag we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later). Finally we turn
    off the browser's form validation using `novalidate`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding form controls to our form inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next we start constructing the inputs for our form. We''ll start with the input
    for the name of our exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait a minute! How can we validate this input? Haven''t we have removed
    the required attribute from our tag? This is where the control mappings that we
    added in our code come into play. If you look back at the code for the form model,
    you can see the following mapping for the `name` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamic form controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the **Exercise** form that we are building requires
    that we allow the user to add one or more videos to the exercise. Since we don''t
    know how many videos the user may want to add, we will have to build the `input`
    fields for these videos dynamically as the user clicks on the **Add Video** button.
    Here''s how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding dynamic form controls](../Images/image00473.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have already seen the code in our component class that we use to do this.
    Now let's take a look at how it is implemented in our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `ngFor` to loop through our list of videos. Then we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop we do three things. First, we add a button to allow the user
    to delete a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we dynamically add a video `input` field for each of the videos currently
    in our exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We then add a validation message for each of the video `input` fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final step in building out our model-driven form is to handle saving the
    form. When we constructed the form tag earlier, we bound the `ngSubmit` event
    to the following `onSubmit` method in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  prefs: []
  type: TYPE_NORMAL
- en: We hope this makes it clear; model-driven forms offer many advantages when we
    are trying to build more complicated forms. They allow programming logic to be
    removed from the template. They permit validators to be added to the form programmatically.
    And they support building forms dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our model-driven form validation by building custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`; then add the following class to that
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a custom validator into our forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So how do we plug our custom validator into our form? If we are using model-driven
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating a custom validator into our forms](../Images/image00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we hope you can see, model-driven forms give us the ability to add custom
    validators to our forms in a straightforward manner that allows us to maintain
    the validation logic in our code and easily integrate it into our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in [Chapter
    6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives in Depth"), *Angular
    2 Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by defining the new app requirements. Then, we designed
    the model as a shared service.
  prefs: []
  type: TYPE_NORMAL
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and model-driven forms. We also explored Angular validation
    in depth, and implemented a custom validator.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  prefs: []
  type: TYPE_NORMAL

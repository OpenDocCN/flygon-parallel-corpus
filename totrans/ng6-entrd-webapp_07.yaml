- en: Create a Router-First Line-of-Business App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Line-of-Business (**LOB**) applications are the bread and butter of the software
    development world. As defined in Wikipedia, LOB is a general term, which refers
    to a product or a set of related products that serve a particular customer transaction
    or business need. LOB apps present a good opportunity to demonstrate a variety
    of features and functionality without getting into contorted or specialized scenarios
    that large enterprise applications usually require. In a sense, they are the 80-20
    learning experience. I must, however, point out a curious thing about LOB apps—if
    you end up building a semi-useful LOB app, the demand for it will grow uncontrollably,
    and you will quickly become the victim of your own success. This is why you should
    treat the start of every new project as an opportunity, a coding-kata if you will, to
    get better at creating more flexible architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter and the remaining chapters, we’ll set up a new application with
    rich features that can meet the demands of an LOB application with a scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the Router-first
    design pattern, relying on reusable components to create a grocery store LOB named
    LemonMart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Effectively use CLI to create major Angular Components and CLI Scaffolds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to build Router-first Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branding, Custom and Material Iconography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug complicated apps with Augury
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable lazy loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a walking skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: For Chapters 2 to 6, LocalCast Weather at [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Chapters 7 to 12, LemonMart at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular cheat sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive in to creating our LOB app, I have included a cheat sheet for
    you to familiarize yourself with common Angular syntax and CLI commands, because
    going forward, this syntax and these commands will be used without their purpose
    explicitly explained. Take some time to review and orient yourself with new Angular
    syntax, major components, CLI scaffolds, and common pipes. You may find the list
    especially useful if your background is with AngularJS, since you will need to
    unlearn some old syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binding, or data binding, refers to an automatic, one or two-way connection
    between a variable in code and a value displayed or input in an HTML template
    or another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Syntax ** | **Data direction** |'
  prefs: []
  type: TYPE_TB
- en: '| Interpolation Property'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute
  prefs: []
  type: TYPE_NORMAL
- en: Class
  prefs: []
  type: TYPE_NORMAL
- en: Style | `{{expression}}``[target]="expression"``bind-target="expression"` |
    One-way from data source
  prefs: []
  type: TYPE_NORMAL
- en: to view target |
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | `(target)="statement"` `on-target="statement"` | One-way from view
    target'
  prefs: []
  type: TYPE_NORMAL
- en: to data source |
  prefs: []
  type: TYPE_NORMAL
- en: '| Two-way | `[(target)]="expression"` `bindon-target="expression"` | Two-way
    |'
  prefs: []
  type: TYPE_TB
- en: Source: [https://angular.io/guide/template-syntax#binding-syntax-an-overview](https://angular.io/guide/template-syntax#binding-syntax-an-overview)
  prefs: []
  type: TYPE_NORMAL
- en: Built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directives encapsulate coded behaviors that can be applied as attributes to
    HTML elements or other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Syntax ** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| Structural Directives | `*ngIf``*ngFor``*ngSwitch` | Controls structural
    layout of the HTML and if elements get added or removed from the DOM |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute Directives | `[class]``[style]``[(model)]` | Listens to and modifies
    the behavior of other HTML elements, attributes, properties, and components, such
    as CSS classes, HTML styles, and HTML form elements |'
  prefs: []
  type: TYPE_TB
- en: Structural Directives Source: [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Directives Source: [https://angular.io/guide/template-syntax#built-in-attribute-directives](https://angular.io/guide/template-syntax#built-in-attribute-directives)
  prefs: []
  type: TYPE_NORMAL
- en: Common pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes modify how a data-bound value is displayed in the HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Purpose** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| Date | Formats a date according to locale rules | `{{date_value &#124; date[:format]}}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Text Transformation | Transforms text to uppercase, lowercase, or title case
    | `{{value &#124; uppercase}}``{{value &#124; lowercase}}``{{value &#124; titlecase
    }}` |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal | Formats a number according to locale rules | `{{number &#124; number[:digitInfo]}}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Percent | Formats a number as a percentage according to locale rules | `{{number
    &#124; percent[:digitInfo]}}` |'
  prefs: []
  type: TYPE_TB
- en: '| Currency | Formats a number as currency with currency code and symbol according
    to locale rules | `{{number &#124; currency[:currencyCode [:symbolDisplay[:digitInfo]]]}}`
    |'
  prefs: []
  type: TYPE_TB
- en: Pipes Source: [https://angular.io/guide/pipes](https://angular.io/guide/pipes)
  prefs: []
  type: TYPE_NORMAL
- en: Starter commands, major components, and CLI scaffolds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starter commands help generate new projects or add dependencies. Angular CLI
    commands help create major components by automatically generating boilerplate
    scaffolding code with ease. For the list of full set of commands, visit [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Purpose ** | **CLI Command** |'
  prefs: []
  type: TYPE_TB
- en: '| New | Creates a new Angular application with initialized git repository,
    package.json, and routing already configured. Run from parent folder. | `npx @angular/cli
    new project-name --routing` |'
  prefs: []
  type: TYPE_TB
- en: '| Update | Updates Angular, RxJS, and Angular Material dependencies. Rewrites
    code, if necessary, to maintain compatibility. | `npx ng update` |'
  prefs: []
  type: TYPE_TB
- en: '| Add Material | Installs and configures Angular Material dependencies. | `npx
    ng add @angular/material` |'
  prefs: []
  type: TYPE_TB
- en: '| Module | Creates a new  `@NgModule` class. Uses `--routing` to add routing
    for submodules. Optionally, import new module into a parent module using `--module`.
    | `ng g module new-module` |'
  prefs: []
  type: TYPE_TB
- en: '| Component | Creates a new `@Component` class. Uses `--module` to specify
    parent module. Optionally, use `--flat` to skip directory creation, `-t` for an
    inline template, and `-s` for an inline style. | `ng g component new-component`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Directive | Creates a new `@Directive` class. Optionally, uses `--module`
    to scope directives for a given submodule. | `ng g directive new-directive` |'
  prefs: []
  type: TYPE_TB
- en: '| Pipe | Creates a new `@Pipe` class. Optionally, use `--module` to scope pipes
    for a given submodule. | `ng g pipe new-pipe` |'
  prefs: []
  type: TYPE_TB
- en: '| Service | Creates a new `@Injectable` class. Uses `--module` to provide a 
    service for a given submodule. Services are not automatically imported to a module.
    Optionally use `--flat` false to create service under a directory. | `ng g service
    new-service` |'
  prefs: []
  type: TYPE_TB
- en: '| Guard | Creates a new `@Injectable` class, which implements the Route lifecycle
    hook `CanActivate`. Uses `--module` to provide a guard for a given submodule.
    Guards are not automatically imported to a module. | `ng g guard new-guard` |'
  prefs: []
  type: TYPE_TB
- en: '| Class | Creates a bare-bones class. | `ng g class new-class` |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | Creates a bare-bones interface. | `ng g interface new-interface`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | Creates a bare-bones enum. | `ng g enum new-enum` |'
  prefs: []
  type: TYPE_TB
- en: In order to properly scaffold some of the components listed earlier under a
    custom module, such as `my-module`, you can prepend the module name before the
    name of what you intend to generate, for example, `ng g c my-module/my-new-component`.
    Angular CLI will properly wire up and place the new component under the `my-module` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Configure Angular CLI autocomplete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You get an autocomplete experience when working with Angular CLI. Execute the
    appropriate command for your `*nix` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For bash shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For zsh shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows users using git bash shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Router-first architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular router, shipped in the `@angular/router` package, is a central and
    critical part of building **single-page-applications** (**SPAs**) that act and
    behave like regular websites that are easy to navigate using browser controls
    or the zoom or microzoom controls.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Router has advanced features such as lazy loading, router outlets, auxiliary
    routes, smart active link tracking, and the ability to be expressed as an `href`,
    which enables a highly flexible Router-first app architecture leveraging stateless
    data-driven components using RxJS `SubjectBehavior`.
  prefs: []
  type: TYPE_NORMAL
- en: Large teams can work against a single-code base, with each team responsible
    of a module's development, without stepping on each other's toes, while enabling
    easy continuous integration. Google, with its billions of lines of code, works
    against a single code base for a very good reason. Integration, after the fact,
    is very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Small teams can remix their UI layouts on the fly to quickly respond to changes
    without having to rearchitect their code. It is easy to underestimate the amount
    of time wasted due to late game changes in layout or navigation. Such changes
    are easier to absorb by larger teams but a costly endeavor for small teams.
  prefs: []
  type: TYPE_NORMAL
- en: With lazy-loading, all developers benefit from sub-second first meaningful paints,
    because the file size of the core user experience that's delivered to the browser
    is kept at a minimum at build time. The size of a module impacts download and
    loading speed, because the more a browser has to do, the longer it will take for
    a user to see the first screen of the app. By defining lazy-loaded modules, each
    module can be packaged as separated files, which can be downloaded and loaded
    individually and as needed. Smart active link tracking results in a superior developer
    and user experience, making it very easy to implement highlighting features to
    indicate to the user the current tab or portion of the app that is currently active.
    Auxiliary routes maximize the reuse of components and help pull off complicated
    state transitions with ease. With auxiliary routes, you can render multiple master
    and detail views using only a single outer template. You can also control how
    the route is displayed to the user in the browser's URL bar and compose routes
    using `routerLink`, in templates, and `Router.navigate`, in code, driving complicated
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pull off a router-first implementation, you need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Define user roles early on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design around major data components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User roles normally indicate the job function of a user, such as a manager or
    data-entry specialist. In technical terms, they can be thought of as a group of
    actions that a particular class of user is allowed to execute. Defining user roles
    help identify sub modules that can then be configured to be lazy loaded. After
    all, a data-entry specialist won't ever see most of the screens that a manager
    can, so why deliver those assets to those users and slow down their experience? Lazy
    loading is critical in creating a scalable application architecture, not only
    from an application perspective, but also from a high-quality and efficient development
    perspective. Configuring lazy loading can be tricky, which is why it is important
    to nail down a walking-skeleton navigation experience early on.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying major data components that your users will work with, such as invoice
    or people objects, will help you avoid over-engineering your application. Designing
    around major data components will inform API design early on and help define `BehaviorSubject`
    data anchors that you will use to achieve a stateless, data-driven design to ensure
    a decoupled component architecture, as detailed in [Chapter 6](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml),
    *Reactive Forms and Component Interaction*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, identify self-contained user controls that encapsulate unique behaviors
    that you wish to create for your app. User controls will likely be created as
    directives or components that have data-binding properties and tightly-coupled
    controller logic and templates. Components, on the other hand, will leverage router
    life cycle events to parse parameters and perform CRUD operations on data. Identifying
    these component reuses early on will result in creating more flexible components
    that can be reused in multiple contexts as orchestrated by the router, maximizing
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Creating LemonMart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app with routing and
    Angular Material configured from the get go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Router-first app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Router-first approach, we will want to enable routing early on in
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the new application with routing already configured by executing
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that `@angular/cli` is not installed globally, or you may run into errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `AppRoutingModule` file has been created for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will be defining routes inside the routes array. Note that routes array is
    passed in to be configured as the root routes for the application, the default
    root route being `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When configuring your `RouterModule`, you can pass in additional options to
    customize the default behavior of the Router, such as when you attempt to load
    a route that is already being displayed, instead of taking no action, you can
    force a reload of the component. To enable this behavior, create your router like `RouterModule.forRoot(routes,
    { onSameUrlNavigation: ''reload'' })`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `AppRoutingModule` is registered with `AppModule`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Angular.json and Package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a quick summary of configuration steps covered in Chapters 2-6\. If
    you''re unfamiliar with a step, refer to prior chapters. You should complete these
    steps before moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `angular.json` and `tslint.json` to enforce your settings and coding
    standards
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `npm i -D prettier`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `prettier` settings to `package.json`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your development serve port to other than `4200`, such as `5000`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `standardize` script and update `start` and `build` scripts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add npm Scripts for Docker to `package.json`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish dev norms and document it in your project, `npm i -D dev-norms` then
    `npx dev-norms create`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use VS Code, set up the `extensions.json` and `settings.json` files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may configure the TypeScript Hero extension to auto organize and prune
    import statements, but adding `"typescriptHero.imports.organizeOnSave": true`
    to `settings.json`. If combined with the setting `"files.autoSave": "onFocusChange"`
    you may find that the tool aggressively cleans unused imports as you are trying
    to type them out. Ensure that this setting works for you and doesn''t collide
    with any other tools or VS Code''s own import organization feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm run standardize`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to [Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml),*Prepare Angular
    App for Production Release*, for further configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the npm Scripts for Docker at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker) and
    npm Scripts for AWS at [bit.ly/npmScriptsForAWS](http://bit.ly/npmScriptsForAWS).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Material and Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will also need to set up Angular Material and configure a theme to use,
    as covered in [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance
    Angular App with Angular Material*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Angular Material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Import and export `MatButtonModule`, `MatToolbarModule`, and `MatIconModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your default theme and register other Angular dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add common css to `styles.css` as shown below,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance Angular
    App with Angular Material*, for further configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: Designing LemonMart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to build a rudimentary road map to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision well understood
    by all members of the team. This is easier said than done, and there are volumes
    of books written on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: In engineering, there's no one right answer to a problem, so it is important
    to remember that no one person can ever have all the answers nor a crystal clear
    vision. It is important that technical and non-technical leaders create a safe
    space with opportunities for open discussion and experimentation as part of the
    culture. The humility and empathy that comes along with being able to court such
    uncertainty as a team is as important as any single team member's technical capabilities.
    Every team member must be comfortable with checking their egos out at the door,
    because our collective goal will be to grow and evolve an application to ever-changing
    requirements during the development cycle. You will know that you have succeeded
    if individual parts of the software you created is easily replaceable by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying user roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step of our design will be to think about you using the application
    and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'We envision four user states or roles for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated, any authenticated user would have access to their profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cashier, whose sole role is to check out customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clerk, whose sole role is to perform inventory-related functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager, who can perform all actions a cashier and a clerk can perform but also
    have access to administrative functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, we can start a high-level design of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying high-level modules with site map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Develop a high-level site map of your application, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/87ef861d-200d-4e44-bed9-807ca9b3e2c4.png)Landing pages for usersI
    used MockFlow.com''s SiteMap tool to create the site map'
  prefs: []
  type: TYPE_NORMAL
- en: shown at [https://sitemap.mockflow.com](https://sitemap.mockflow.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  prefs: []
  type: TYPE_NORMAL
- en: Point of Sale (POS)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cashier will only have access to the POS module and component. The Clerk will
    only have access to the Inventory module, which will include additional screen
    for Stock Entry, Products, and Categories management components.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b7feb50e-d0cd-403a-8f50-9f68ad8737cd.png)Inventory pages'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Manager will be able to access all three modules with the Manager
    module, including User management and Receipt lookup components.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a5aee264-31a6-4403-9d1a-4f71820a93f4.png)Manager pages'
  prefs: []
  type: TYPE_NORMAL
- en: There's great benefit to enable lazy-loading for all three modules, since cashiers
    and clerks will never use components belonging to other user roles, there's no
    reason to send those bytes down to their devices. This means as the Manager module
    gains more advanced reporting features or new roles are added to the application,
    the POS module will be unaffected by the bandwidth and memory impact of an otherwise
    growing application. This means less support calls and consistent performance
    on the same hardware for a much longer period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Generating router-enabled modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our high-level components defined as Manager, Inventory, and
    POS, we can define them as modules. These modules will be different from the ones
    you''ve created so far, for routing and Angular Material. We can create the user
    profile as a component on the app module; however, note that user profile will
    only ever be used for already authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app''s first payload remains as minimal as possible. In addition,
    we will create a Home component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their
    target module and routing capabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in [Chapter 1](ff3bb319-cb7a-49d8-9f23-aa9a3727122c.xhtml),* Setting
    Up Your Development Environment*, if you have configured `npx` to automatically
    recognize `ng` as a command, you can save some more keystrokes so that you won't
    have to append `npx` to your commands every time. Do not globally install `@angular/cli`.
    Note the abbreviate command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  prefs: []
  type: TYPE_NORMAL
- en: Verify that you don't have CLI errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that using `npx` on Windows may encounter an error such as Path must be
    a string. Received undefined. This error doesn't seem to have any effect on the
    successful operation of the command, which is why it is critical to always inspect
    what the CLI tool generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the folder and the files are created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Examine how `ManagerModule` has been wired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A child module implements an `@NgModule` similar to `app.module`. The biggest
    difference is that a child module does not implement the `bootstrap` property,
    which is required for your root module, to initialize your Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have specified the `-m` option, the module has been imported into
    `app.module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, because we also specified the `--routing` option, a routing module
    has been created and imported into `ManagerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to `forRoot`,
    which was the case for the `AppRouting` module. This way, the router understands
    the proper relationship between routes defined in different modules' contexts
    and can correctly prepend `/manager` to all child routes in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI doesn't respect your `tslint.json` settings. If you have correctly configured
    your VS Code environment with prettier, your Code Styling preferences will be
    applied as you work on each file or, globally, when you run the prettier command.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the home route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/07e577f7-b81e-4f2a-8fbe-df27bafba4bd.png)LemonMart Landing Experience'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `LocalCastWeather` app, we don't want all this markup to be in the `App`
    component. The `App` component is the root element of your entire application;
    therefore, it should only contain elements that will persistently appear throughout
    your application. In the following annotated mock-up, the toolbar marked as 1
    will be persistent throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The area marked as 2 will house the home component, which itself will contain
    a login user control, marked as 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/791d4e08-a0ab-4976-ace6-00e9a9680d9c.png)LemonMart Layout Structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logic executed in every page, but it also results in a more flexible architecture
    when utilizing the router:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the `home` component with inline template and styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are ready to configure the router.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up default routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with setting up a simple route for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure your `home` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first define a path for `'home'` and inform the router to render `HomeComponent`
    by setting the component property. Then, we set the default path of the application
    `''` to be redirected to `'/home'`. By setting the `pathMatch` property, we always
    ensure that this very specific instance of the home route will be rendered as
    the landing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `pageNotFound` component with an inline template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure a wildcard route for `PageNotFoundComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This way, any route that is not matched will be directed to the `PageNotFoundComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: RouterLink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    redirected to the `HomeComponent` using the `RouterLink` direction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement an inline template to link back to home using `routerLink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in your `index.html`. However, we must manually define where
    we would like `HomeComponent` to render, to finalize the router configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Router outlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routing.module`, which allows us to define outlets within this root element
    to dynamically load any content we wish using the `<router-outlet>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure `AppComponent` to use inline template and styles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the toolbar for your application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `<router-outlet>` for the content to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, the contents of home will render inside `<router-outlet>`.
  prefs: []
  type: TYPE_NORMAL
- en: Branding, Custom, and Material Icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to construct an attractive and intuitive toolbar, we must introduce
    some iconography and branding to the app so that the users can easily navigate
    through the app with the help of familiar icons.
  prefs: []
  type: TYPE_NORMAL
- en: Branding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of branding, you should ensure that your web app should have custom
    color palette and integrate with desktop and mobile browser features to bring
    forward your app's name and iconography.
  prefs: []
  type: TYPE_NORMAL
- en: Color palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pick a color palette using the Material Color tool, as discussed in [Chapter
    5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance Angular App with Angular
    Material*. Here''s the one I picked for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implementing browser manifest and icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to ensure that the browser shows the correct title text and icon in
    a Browser tab. Further, a manifest file should be created that implements specific
    icons for various mobile operating systems, so that if a user pins your website,
    a desirable icon is displayed similar to other app icons on a phone. This will
    ensure that if a user favorites or pin your web app on their mobile device''s
    home screen, they''ll get a native-looking app icon:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or obtain an SVG version of your website's logo from a designer or site
    like [https://www.flaticon.com](https://www.flaticon.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, I will be using a particular lemon image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ba4618d3-21b7-4b40-b2e7-a4243495bb5a.jpg)LemonMart''s signature
    logoWhen using images you find on the internet, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  prefs: []
  type: TYPE_NORMAL
- en: Generate `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust settings for iOS, Android, Windows Phone, macOS, and Safari to your liking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you set a version number, favicons can be notorious with caching;
    a random version number will ensure that users always get the latest version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and extract the generated `favicons.zip` file into your `src` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the generated code in the `<head>` section of your `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that your new favicon displays correctly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To further your branding, consider configuring a custom Material theme and leveraging
    [https://material.io/color](https://material.io/color/), as discussed in *Chapter
    5, Enhance Angular App with Angular Material*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s add your custom branding inside your Angular app. You will need
    the svg icon you used to create your favicon:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the image under `src/app/assets/img/icons`, named `lemon.svg`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `HttpClientModule` to `AppComponent` so that the `.svg` file can be requested
    over HTTP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `AppComponent` to register the new svg file as an icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the icon to the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now let's add the remaining icons for menu, user profile, and logout.
  prefs: []
  type: TYPE_NORMAL
- en: Material icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Material works out of the box with Material Design icons, which can
    be imported into your app as a web font in your `index.html`. It is possible to
    self-host the font; however, if you go down that path, you also don't get the
    benefit of the user's browser having already cached the font when they visited
    another website, saving the speed and latency of downloading a 42-56 KB file in
    the process. The complete list of icons can be found at [https://material.io/icons/](https://material.io/icons/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update the toolbar with some icons and setup the home page with
    a minimal template for a fake login button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure Material icons `<link>` tag has been added to `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Instructions on how to self-host can be found under the Self Hosting section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  prefs: []
  type: TYPE_NORMAL
- en: Once configured, working with Material icons is easy.
  prefs: []
  type: TYPE_NORMAL
- en: Update the toolbar to place a Menu button to the left of the title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `fxFlex` so that the remaining icons are right aligned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add user profile and logout icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a minimal template for a login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app should look similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2af6a8ec-e862-4438-aedb-17741cc1c0af.png)LemonMart with minimal
    login'
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user's authentication status. We
    will cover this functionality in [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml),
    *Design Authentication and Authorization*. Now that you've set up basic routing
    for your app, you need to learn how to debug your Angular app before we move on
    to setting up lazily loaded modules with subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Augury
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Augury is a Chrome Dev Tools extension for debugging and profiling Angular
    applications. It is a purpose-built tool to help developers visually navigate
    the component tree, inspect the state of the router, and enable break point debugging
    by source-mapping between the generated JavaScript code and the TypeScript code
    that the developer coded in. You can download Augury from [augury.angular.io](http://augury.angular.io).
    Once installed, when you open Chrome Dev Tools for your Angular app, you''ll note
    a new tab for Augury, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a1606151-2a70-4096-8584-6a92f3a908fe.png)Chrome Dev Tools Augury'
  prefs: []
  type: TYPE_NORMAL
- en: 'Augury provides useful and critical information in understanding how your Angular
    app is behaving at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Current Angular version is listed, in this case, as version 5.1.2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component Tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Router Tree shows all the routes that have been configured in the app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NgModules shows the `AppModule` and Sub-Modules of the app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Component Tree tab shows how all app components are related and how they
    interact with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a particular component, such as `HomeComponent`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/9149a7d0-d849-4eb5-a669-d1a34a27b6ac.png)Augury Component Tree'
  prefs: []
  type: TYPE_NORMAL
- en: The Properties tab on the right-hand side will display a link called View Source,
    which you can use to debug your component. Further below, you will be able to
    observe the state of properties of the component, such as the displayLogin boolean,
    including services that you have injected into the component and their state.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the value of any property by double-clicking on the value. For
    example, if you would like to change the value of displayLogin to `false`, simply
    double-click on the blue box that contains the true value and type in false. You
    will be able to observe the effects of your changes in your Angular app.
  prefs: []
  type: TYPE_NORMAL
- en: In order to observe the runtime component hierarchy of `HomeComponent`, you
    can observe the Injector Graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Injector Graph tab, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/7a070a59-28ee-47dd-9537-c6abf5dfd6a9.png)Augury Injector Graph'
  prefs: []
  type: TYPE_NORMAL
- en: This view shows how your selected component came to be rendered. In this case,
    we can observe that `HomeComponent` was rendered within `AppComponent`. This visualization
    can be very helpful in tracking down the implementation of a particular component
    in an unfamiliar code base or where a deep component tree exists.
  prefs: []
  type: TYPE_NORMAL
- en: Break point debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me restate, for the record, that `console.log` statements shall never be
    checked in to your repository. In general, they are a waste of your time, because
    it requires editing code and later cleaning up your code. Furthermore, Augury
    already provides the state of your components, so in straightforward cases, you
    should be able to leverage it observe or coerce state.
  prefs: []
  type: TYPE_NORMAL
- en: There are some niche use cases, where `console.log` statements can be useful. These
    are mostly asynchronous workflows that operate in parallel and are dependent on
    timely user interaction. In these cases, console logs can help you better understand
    the flow of events and interaction between various components.
  prefs: []
  type: TYPE_NORMAL
- en: Augury is not yet sophisticated enough to resolve asynchronous data or data
    returned via functions. There are other common cases, where you would like to
    observe the state of properties as they are being set, and even be able to change
    their values on the fly to force your code to execute branching logic in `if`-`else`
    or `switch` statements. For these cases, you should be using break point debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s presume that some basic logic exists on `HomeComponent`, which sets
    a `displayLogin` `boolean`, based on an `isAuthenticated` value retrieved from
    an `AuthService`, as demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now observe the state of the value of `displayLogin` and the `isAuthenticated`
    function as they are being set, then observe the change in the value of `displayLogin`:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the View Source link on `HomeComponent`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop a break point on the first line inside the `ngOnInit` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chrome Dev Tools will switch over to the Source tab, and you''ll see your break
    point hit, as highlighted in blue here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/f5c756b8-0127-47e6-bbe3-b838ed2b9af7.png)Chrome Dev Tools break
    point debugging'
  prefs: []
  type: TYPE_NORMAL
- en: Hover over `this.displayLogin` and observe that its value is set to `true`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If hovering over `this.authService.isAuthenticated()`, you will not be able
    to observe its value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While your break point is hit, you can access the current scope of the state
    in the console, which means you can execute the function and observe its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `isAuthenticated()` in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You'll observe that it returns `true`, which is what `this.displayLogin` is
    set to. You can still coerce the value of `displayLogin` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `displayLogin` to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the value of `displayLogin`, either by hovering over it or retrieving
    it from the control, you'll see that the value is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging break point debugging basics, you can debug complicated scenarios
    without changing your source code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Router Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Router Tree tab will display the current state of the router. This can
    be a very helpful tool in visualizing the relationship between routes and components,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/31dc905e-b0e8-43af-bf4f-4354bc30a8ce.png)Augury Router Tree'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding router tree demonstrates a deeply nested routing structure with
    master-detail views. You can see the absolute path and parameters required to
    render a given component by clicking on the circular node.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, for `PersonDetailsComponent`, it can get complicated to determine,
    exactly, the set of parameters needed to render this detail portion of a master-detail
    view.
  prefs: []
  type: TYPE_NORMAL
- en: NgModules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NgModules tab displays the `AppModule` and any other submodule that is
    currently loaded into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the `/home` route of the app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the NgModules tab, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c0304718-ed0f-45b5-95a0-e2b33ce8641e.png)Augury NgModules'
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that only the `AppModule` is loaded. However, since our application
    has a lazy-loaded architecture, none of our other modules are yet loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to a page in the `ManagerModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to a page in the `UserModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, navigate back to the `/home` route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the NgModules tab, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/08d7ca69-7989-459b-bdff-77b76691b3d9.png)Augury NgModules with Three
    Modules'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you'll observe that three modules have been loaded into memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NgModules is an important tool to visualize the impact of your design and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Submodules with lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy loading allows the Angular build process, powered by webpack, to separate
    our web application into different JavaScript files called chunks. By separating
    out portions of the application into separate submodules, we allow these modules
    and their dependencies to be bundled into separate chunks, thus keeping the initial JavaScript
    bundle size to a minimum. As the application grows, the time to first meaningful
    paint remains a constant, instead of consistently increasing over time. Lazy loading
    is critical to achieving a scalable application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We will now go over how to set up a submodule with components and routes. We
    will also use Augury to observe the effects of our various router configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring submodules with components and routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7dae93fc-fe0e-4ca2-a439-3e58106c8bb9.png)Manager''s DashboardLet''s
    start by creating the home screen for the `ManagerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ManagerHome` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In order to create the new component under the `manager` folder, we must prefix
    `manager/` in front of the component name. In addition, we specify that the component
    should be imported and declared with the `ManagerModule`. Since this is another
    landing page, it is unlikely to be complicated enough to require separate HTML
    and CSS files. You can use `--inline-style` (alias `-s`) and/or `--inline-template`
    (alias `-t`) to avoid creating additional files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that your folder structure looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the `ManagerHome` component''s route with `manager-routing.module`,
    similar to how we configured the `Home` component with `app-route.module`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You will note that `http://localhost:5000/manager` doesn't actually resolve
    to a component yet, because our Angular app isn't aware that `ManagerModule` exists.
    Let's first try the brute-force, eager-loading approach to import `manager.module`
    and register the manager route with our app.
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is purely an exercise to demonstrate how the concepts we have
    learned so far in importing and registering routes doesn''t result in a scalable
    solution, regardless of eagerly or lazily loading components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `manager.module` to `app.module`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You will note that `http://localhost:5000/manager` still doesn't render its
    home component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Augury to debug the router state, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/f0329219-b967-45ca-b949-33b7bab07308.png)Router Tree with Eager
    Loading'
  prefs: []
  type: TYPE_NORMAL
- en: It seems as if the `/manager` path is correctly registered and pointed at the
    correct component, `ManagerHomeComponent`. The issue here is that the `rootRouter` configured
    in `app-routing.module` isn't aware of the `/manager` path, so the `**` path is
    taking precedence and rendering the `PageNotFoundComponent` instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a final exercise, implement the `''manager''` path in `app-routing.module`
    and assign `ManagerHomeComponent` to it as you would normally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You'll now note that `http://localhost:5000/manager` renders correctly, by displaying
    `manager-home works!`; however, if you debug the router state through Augury,
    you will note that the `/manager` is registered twice.
  prefs: []
  type: TYPE_NORMAL
- en: This solution doesn't scale well, because it forces all developers to maintain
    a single master file to import and configure every module. It is ripe for merge
    conflicts and frustration, hoping that team members do not register the same route
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to engineer a solution to divide up the modules into multiple
    files. Instead of the standard `*-routing.module`, you can implement the Route
    array in `manager.module` and export it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'These files will then need to be individually imported into `app-routing.module`
    and configured using the `children` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution will work and it is a correct solution, as demonstrated by the
    Augury Router tree here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5ca66d17-bbea-47b3-ae9d-2ce7bb069aaf.png)Router Tree with children
    routes'
  prefs: []
  type: TYPE_NORMAL
- en: There are no duplicate registrations, because we removed `manager-routing.module`.
    In addition, we don't have to import `ManagerHomeComponent` outside of `manager.module`,
    resulting in a much better scalable solution. However, as the app grows, we must
    still register modules with `app.module`, and the submodules are still coupled
    to the parent `app.module` in potentially unpredictable ways. Further, this code
    can't be chunked, because any code that is imported using import is viewed as
    a hard dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how eager-loading of modules work, you will be able
    to better understand the code we are about to write, which may otherwise seem
    like black-magic, and magical (aka misunderstood) code always leads to spaghetti
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now evolve the eager-loading solution to be a lazy-loading one. In
    order to load routes from a different module, we know we can''t simply import
    them, otherwise they will be eagerly loaded. The answer lies in configuring a
    route using the `loadChildren` attribute with string informing the Router how
    to load a submodule in `app-routing.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that any module you intend to lazy load is *not* imported in ``app.module``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any routes added to `ManagerModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that `ManagerRoutingModule` is imported into `ManagerModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement or update the manager path with the `loadChildren` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Lazy loading is achieved via a clever trick that avoids using an `import` statement.
    A string literal with two parts is defined, where the first part defines the location
    of the module file, such as `app/manager/manager.module`, and the second part
    defines the class name of the module. A string can be interpreted during the build
    process and at runtime, to dynamically create chunks, load the right module and
    instantiate the correct class. `ManagerModule` then acts as if its own Angular
    app and manages all of its children dependencies and routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `manager-routing.module` routes, considering that manager is now
    their root route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won't clash with the one found in `app-routing.module`,
    because in this context, `'home'` resolves to `'manager/home'` and, similarly,
    where path is empty, the URL will look like `http://localhost:5000/manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that lazy loading is working by looking at Augury, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/cefe01e3-4052-4e6f-913d-cd3d872cbfa0.png)Router Tree with lazy loadingThe
    root node for `ManagerHomeComponent` is now named `manager [Lazy]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the walking skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the site map, we have created for LemonMart, from earlier in the chapter,
    we need to complete the walking skeleton navigation experience for the app. In
    order to create this experience, we will need to create some buttons to link all
    modules and components together. We will go at this module by module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, update the login button on `home.component` to link to the
    `Manager` module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Manager module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we already enabled lazy loading for `ManagerModule`, let's go ahead and
    complete the rest of the navigational elements for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the current setup, `ManagerHomeComponent` renders in the `<router-outlet>`
    defined in `app.component`, so when the user navigates from `HomeComponent` to
    `ManagerHomeComponent`, the toolbar implemented in `app.component` remains a constant.
    If we implement a similar toolbar that persists throughout `ManagerModule`, we
    can create a consistent UX for navigating subpages across modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we need to replicate the parent-child relationship between
    `app.component` and `home/home.component`, where the parent implements the toolbar
    and a `<router-outlet>` so that children elements can be rendered in there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the base `manager` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `app.component` residing directly under
    the `app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a navigational toolbar with `activeLink` tracking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It must be noted that submodules don't automatically have access to services
    or components created in parent modules. This is an important default behavior
    to preserve a decoupled architecture. However, there are certain cases where it
    is desirable to share some amount of code. In this case, `mat-toolbar` needs to
    be reimported. Since the `MatToolbarModule` is already loaded in `src/app/material.module.ts`,
    we can just import this module into `manager.module.ts` and there will not be
    a performance or memory penalty for doing so.
  prefs: []
  type: TYPE_NORMAL
- en: '`ManagerComponent` should be imported into `ManagerModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create components for the subpages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the parent/children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to target the `<router-outlet>` defined in `manager.component`, we
    need to create a parent route first and then specify routes for the subpages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to navigate through the app. When you click on the Login
    as Manager button, you will be taken to the page shown here. The clickable targets
    are highlighted, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16f4d60a-a3a9-4f65-9f74-992c704c63f2.png)Manager''s Dashboard with
    clickable targets highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on LemonMart, you will be taken to the home page. If you click
    on Manager's Dashboard, User Management or Receipt Lookup, you will be navigated
    to the corresponding subpage, while active link will be bold and underlined on
    the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: User module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon login, users will be able to access their profiles and view a list of
    actions they can access in the LemonMart app through a side navigation menu. In
    [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml), *Design Authentication
    and Authorization*, when we implement authentication and authorization, we will
    be receiving the role of the user from the server. Based on the role of the user,
    we will be able to automatically navigate or limit the options users can see.
    We will implement these components in this module so that they will only be loaded
    once a user is logged in. For the purpose of completing the walking skeleton,
    we will ignore authentication-related concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement routing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with implementing the lazy loading in `app-routing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that  `PageNotFoundComponent` route is always the last route in `app-routing.module`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now implement the child routes in `user-routing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We are implementing routing for `NavigationMenuComponent`, because it'll be
    directly used as an HTML element. In addition, since `userModule` doesn't have
    a landing page, there's no default path defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wire up the user and logout icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In
    order for tooltips to work, switch from the `mat-icon-button` directive to the `mat-mini-fab`
    directive and ensure that you import `MatTooltipModule` in `material.module`.
    In addition, ensure that you add `aria-label` for icon only buttons so that users
    with disabilities relying on screen readers can still navigate your web application.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the app works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll note that the two buttons are too close to each other, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/daf74636-eb0d-4688-bca3-2305ebb2ecc3.png)Toolbar with icons'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/83d825ac-5e6f-474f-913f-c5773d0780ab.png)Toolbar with padded icons'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6bcb1dd7-d85d-479a-ae80-8eb0e03656e3.png)Toolbar with grouped and
    padded elements'
  prefs: []
  type: TYPE_NORMAL
- en: This is a more desirable from a UX perspective as well; now users can go back
    to the home page by clicking on the lemon as well.
  prefs: []
  type: TYPE_NORMAL
- en: POS and inventory modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all components we are about to create, we need to enable the manager to be able
    to access pos and inventory modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `ManagerComponent` with two new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that these router links will navigate use out of `ManagerModule`, so it
    is normal for the toolbar to disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it'll be up to you to implement the last two remaining modules.
  prefs: []
  type: TYPE_NORMAL
- en: POS module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POS module is very similar to the user module, except that `PosComponent` will
    be the default route. This will be a complicated component with some subcomponents,
    so ensure that it is created with a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `PosComponent`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register `PosComponent` as the default route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `PosModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the app works
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inventory module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inventory module is very similar to `ManagerModule`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a2721b96-90be-449b-b50e-5988fb751ee1.png)Inventory Dashboard mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: Create a base `Inventory` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the `MaterialModule`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Inventory Dashboard, Stock Entry, Products, and Categories components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure parent-children routes in `inventory-routing.module`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for ``InventoryModule``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that app works, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/f88c694c-8e92-47c3-bc73-c713a735534c.png)LemonMart Inventory Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the router tree to ensure that lazy loading has been configured correctly and
    module aren't unintentionally being eager loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect router tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the base route of the app and use Augury to inspect the router
    tree, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/23455131-eadf-44ea-b937-3f331d03b588.png)Router Tree with eager
    loading mistakes'
  prefs: []
  type: TYPE_NORMAL
- en: Everything, but initially required components, should be denoted with the [Lazy]
    attribute. If, for some reason, routes are not denoted with [Lazy], chances are
    that they are mistakenly being imported in `app.module` or some other component.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you may note that `ProfileComponent` and `LogoutComponent`
    are eagerly loaded, whereas the `user` module is correctly labeled as [Lazy].
    Even multiple visual inspections through the tooling and the code base may leave
    you searching for the culprit. However, if you run a global search for `UserModule`,
    you'll quickly discover that it was being imported into `app.module`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be on the safe side make sure to remove any import statements for modules
    in `app.module` and your file should look like the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the corrected router tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a0e0138e-e2be-48a1-8e2c-c8a86f7b2ca0.png)Router Tree with lazy loadingEnsure
    that `npm test` and `npm run e2e` executes without errors before moving on.'
  prefs: []
  type: TYPE_NORMAL
- en: Common Testing Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each spec file individually. For this purpose, I
    recommend creating a common testing module to contain generic configuration that
    you can reuse across the board.
  prefs: []
  type: TYPE_NORMAL
- en: First start by creating a new `.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Create `common/common.testing.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate it with common testing providers, fakes and modules, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have provided fake implementations of `ObservableMedia`, `MatIconRegistry`,
    `DomSanitizer`, along with arrays for `commonTestingProviders` and `commonTestingModules`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see a sample use of this shared configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Most other modules will just need `commonTestingModules` to be imported.
  prefs: []
  type: TYPE_NORMAL
- en: Don't move on until all your tests are passing!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered how to effectively use Angular CLI to create major
    Angular components and scaffolds. You created the branding of your app, leveraging
    custom and built-in Material iconography. You learned how to debug complicated
    Angular apps with Augury. Finally, you began building Router-first apps, defining
    user roles early on, designing with lazy loading in mind and nailing down a walking-skeleton
    navigation experience early on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, in order to pull off a Router-first implementation, you need to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Define user roles early on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design around major data components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, you executed steps 1-3; in the next three chapters, you will
    execute steps 4-7\. In [Chapter 8](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml),
    *Continuous Integration and API Design, *we will go over designing around major
    data components and enable Continuous Integration to ensure a high-quality deliverable.
    In [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml), *Design Authentication
    and Authorization*, we will deep dive into security considerations and design
    a conditional navigation experience. In [Chapter 10](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml),
    *Angular App Design and Recipes*, we will tie everything together by sticking
    to a decoupled component architecture, smartly choosing between creating user
    controls versus components and maximizing code reuse with various TypeScript,
    RxJS, and Angular coding techniques.
  prefs: []
  type: TYPE_NORMAL

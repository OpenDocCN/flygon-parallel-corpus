- en: Setting Up Node.js
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Node.js
- en: Before getting started with using Node.js, you must set up your development
    environment. While it's very easy to set up, there are a number of considerations
    to think about, including whether to install Node.js using the package management
    system, satisfying the requirements for installing native code Node.js packages,
    and deciding what the best editor is to use with Node.js. In the following chapters,
    we'll use this environment for development and non-production deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Node.js之前，您必须设置好开发环境。虽然设置非常简单，但有许多考虑因素，包括是否使用包管理系统安装Node.js，满足安装本地代码Node.js包的要求，以及决定使用什么编辑器最好与Node.js一起使用。在接下来的章节中，我们将使用这个环境进行开发和非生产部署。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to install Node.js from source and prepackaged binaries on Linux, macOS,
    or Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux、macOS或Windows上从源代码和预打包的二进制文件安装Node.js
- en: How to install **node package manager** (**npm**) and some other popular tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装**node包管理器**（**npm**）和其他一些流行的工具
- en: The Node.js module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js模块系统
- en: Node.js and JavaScript language improvements from the ECMAScript committee
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和ECMAScript委员会的JavaScript语言改进
- en: System requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统要求
- en: Node.js runs on POSIX-like OSes, various UNIX derivatives (Solaris, for example),
    and UNIX-workalike OSes (such as Linux, macOS, and so on), as well as on Microsoft
    Windows. It can run on machines both large and small, including tiny ARM devices,
    such as Raspberry Pi—a microscale embeddable computer for DIY software/hardware
    projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以在类似POSIX的操作系统、各种UNIX衍生系统（例如Solaris）和UNIX兼容的操作系统（如Linux、macOS等），以及Microsoft
    Windows上运行。它可以在各种大小的计算机上运行，包括像树莓派这样的微型ARM设备，树莓派是一个用于DIY软件/硬件项目的微型嵌入式计算机。
- en: Node.js is now available via package management systems, limiting the need to
    compile and install from the source.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js现在可以通过包管理系统获得，无需从源代码编译和安装。
- en: Because many Node.js packages are written in C or C++, you must have a C compiler
    (such as GCC), Python 2.7 (or later), and the `node-gyp` package. Since Python
    2 will be end-of-lifed by the end of 2019, the Node.js community is rewriting
    its tools for Python 3 compatibility. If you plan on using encryption in your
    networking code, you will also need the OpenSSL cryptographic library. Modern
    UNIX derivatives almost certainly come with this and Node.js's configure script—used
    when installing from the source—will detect their presence. If you need to install
    it, Python is available at [http://python.org](http://python.org) and OpenSSL is
    available at [http://openssl.org](http://openssl.org).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多Node.js包是用C或C++编写的，您必须有C编译器（如GCC）、Python 2.7（或更高版本）和`node-gyp`包。由于Python
    2将在2019年底停止维护，Node.js社区正在为Python 3兼容性重写其工具。如果您计划在网络编码中使用加密，还需要OpenSSL加密库。现代UNIX衍生系统几乎肯定会自带这些内容，Node.js的配置脚本（在从源代码安装时使用）将检测它们的存在。如果您需要安装它，Python可以在[http://python.org](http://python.org)获取，OpenSSL可以在[http://openssl.org](http://openssl.org)获取。
- en: Now that we have covered the requirements for running Node.js, let's learn how
    to install it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了运行Node.js的要求，让我们学习如何安装它。
- en: Installing Node.js using package managers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包管理器安装Node.js
- en: The preferred method for installing Node.js is to use the versions available
    in package managers, such as `apt-get`, or MacPorts. Package managers make your
    life easier by helping to maintain the current version of the software on your
    computer, ensuring to update dependent packages as necessary, all by typing a
    simple command, such as `apt-get update`. Let's go over installation from a package
    management system first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js的首选方法是使用包管理器中提供的版本，比如`apt-get`或MacPorts。包管理器通过输入简单的命令，如`apt-get update`，来帮助您在计算机上维护软件的当前版本，并确保更新依赖包，从而让您的生活更加轻松。让我们首先来看一下如何从包管理系统进行安装。
- en: For the official instructions on installing from package managers, go to [https://nodejs.org/en/download/package-manager/.](https://nodejs.org/en/download/package-manager/)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有关从包管理器安装的官方说明，请访问[https://nodejs.org/en/download/package-manager/.](https://nodejs.org/en/download/package-manager/)
- en: Installing Node.js on macOS with MacPorts
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在macOS上使用MacPorts安装Node.js
- en: 'The MacPorts project ([http://www.macports.org/](http://www.macports.org/))
    has been packaging a long list of open-source software packages for macOS for
    years and they have packaged Node.js. The commands it manages are, by default,
    installed on `/opt/local/bin`. After you have installed MacPorts using the installer
    on their website, installing Node.js is very simple, making the Node.js binaries
    available in the directory where MacPorts installs commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MacPorts项目（[http://www.macports.org/](http://www.macports.org/)）多年来一直在为macOS打包大量开源软件包，他们已经打包了Node.js。它默认管理的命令安装在`/opt/local/bin`上。安装MacPorts后，安装Node.js非常简单，可以在MacPorts安装命令的目录中找到Node.js二进制文件：
- en: '[PRE0]js\1'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: 'Then, install like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像这样安装：
- en: '[PRE1]js\1'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: This proves Node.js has been installed and the installed version matched what
    you asked for.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明Node.js已经安装，并且安装的版本与您要求的版本相匹配。
- en: Of course, macOS is only one of many operating systems we might use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，macOS只是我们可能使用的众多操作系统之一。
- en: Installing Node.js on Linux, *BSD, or Windows from package management systems
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从包管理系统在Linux、*BSD或Windows上安装Node.js
- en: Node.js is now available through most package management systems. Instructions
    on the Node.js website currently list packaged versions of Node.js for a long
    list of Linux, as well as FreeBSD, OpenBSD, NetBSD, macOS, and even Windows. Visit
    [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    for more information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js现在可以通过大多数包管理系统获得。Node.js网站上的说明目前列出了Node.js的打包版本，适用于长列表的Linux，以及FreeBSD，OpenBSD，NetBSD，macOS，甚至Windows。访问[https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)获取更多信息。
- en: 'For example, on Debian and other Debian-based Linux distributions (such as
    Ubuntu), use the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Debian和其他基于Debian的Linux发行版（如Ubuntu）上，使用以下命令：
- en: '[PRE2]js\1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: The commands will be installed in `/usr/bin` and we can test whether the version
    downloaded is what we asked for.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将安装在`/usr/bin`中，我们可以测试下载的版本是否符合我们的要求。
- en: Windows is starting to become a place where Unix/Linux geeks can work, thanks
    to a new tool called the **Windows subsystem for Linux** (**WSL**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一种名为**Windows子系统Linux**（**WSL**）的新工具，Windows正开始成为Unix/Linux极客可以工作的地方。
- en: Installing Node.js in WSL
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在WSL中安装Node.js
- en: '**WSL** lets you install Ubuntu, openSUSE, or SUSE Linux Enterprise on Windows.
    All three are available via the store built into Windows 10\. You may need to
    update your Windows device for the installation to work. For the best experience,
    install WSL2, which is a major overhaul of WSL, offering an improved integration
    between Windows and Linux.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**WSL**允许您在Windows上安装Ubuntu、openSUSE或SUSE Linux Enterprise。所有这三个都可以通过内置到Windows
    10中的商店获得。您可能需要更新Windows设备才能进行安装。为了获得最佳体验，请安装WSL2，这是WSL的一次重大改进，提供了Windows和Linux之间更好的集成。'
- en: Once installed, the Linux-specific instructions will install Node.js in the
    Linux subsystem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Linux特定的说明将在Linux子系统中安装Node.js。
- en: To install WSL, see [https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装WSL，请参阅[https://msdn.microsoft.com/en-us/commandline/wsl/install-win10](https://msdn.microsoft.com/en-us/commandline/wsl/install-win10)。
- en: To learn about and install WSL2, see [https://docs.microsoft.com/en-us/windows/wsl/wsl2-index](https://docs.microsoft.com/en-us/windows/wsl/wsl2-index).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解并安装WSL2，请参阅[https://docs.microsoft.com/en-us/windows/wsl/wsl2-index](https://docs.microsoft.com/en-us/windows/wsl/wsl2-index)。
- en: The process may require elevated privileges on Windows.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，该过程可能需要提升的权限。
- en: Opening an administrator-privileged PowerShell on Windows
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上打开具有管理员特权的PowerShell
- en: Some of the commands that you'll run while installing tools on Windows are to
    be executed in a PowerShell window with elevated privileges. We are mentioning this
    because during the process of enabling WSL, a command will need to be run in a
    PowerShell window.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装工具时，您将运行一些命令需要在具有提升权限的PowerShell窗口中执行。我们提到这一点是因为在启用WSL的过程中，需要在PowerShell窗口中运行一个命令。
- en: 'The process is simple:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单：
- en: In the Start menu, enter `PowerShell` in the application's search box. The resulting
    menu will list PowerShell.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“开始”菜单中，在应用程序的搜索框中输入`PowerShell`。生成的菜单将列出PowerShell。
- en: Right-click the PowerShell entry.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击PowerShell条目。
- en: The context menu that comes up will have an entry called Run as Administrator.
    Click on that.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出的上下文菜单将有一个名为“以管理员身份运行”的条目。点击它。
- en: 'The resulting command window will have administrator privileges and the title
    bar will say Administrator: Windows PowerShell.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的命令窗口将具有管理员特权，并且标题栏将显示管理员：Windows PowerShell。
- en: In some cases, you will be unable to use Node.js from package management systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您将无法使用软件包管理系统中的Node.js。
- en: Installing the Node.js distribution from nodejs.org
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从nodejs.org安装Node.js发行版
- en: 'The [https://nodejs.org/en/](https://nodejs.org/en/) website offers built-in
    binaries for Windows, macOS, Linux, and Solaris. We can simply go to the website,
    click on the Install button, and run the installer. For systems with package managers,
    such as the ones we''ve just discussed, it''s better to use the package management
    system. That''s because you''ll find it easier to stay up to date with the latest
    version. However, that doesn''t serve all people because of the following reasons:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en/](https://nodejs.org/en/)网站提供了Windows、macOS、Linux和Solaris的内置二进制文件。我们只需转到该网站，单击安装按钮，然后运行安装程序。对于具有软件包管理器的系统，例如我们刚刚讨论的系统，最好使用软件包管理系统。这是因为您会发现更容易保持最新版本。但是，由于以下原因，这并不适用于所有人：'
- en: Some will prefer to install a binary rather than deal with the package manager.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人更喜欢安装二进制文件，而不是使用软件包管理器。
- en: Their chosen system doesn't have a package management system.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们选择的系统没有软件包管理系统。
- en: The Node.js implementation in their package management system is out of date.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的软件包管理系统中的Node.js实现已经过时。
- en: 'Simply go to the Node.js website and you''ll see something as in the following
    screenshot. The page does its best to determine your OS and supply the appropriate
    download. If you need something different, click on the DOWNLOADS link in the
    header for all possible downloads:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只需转到Node.js网站，您将看到以下屏幕截图中的内容。该页面会尽力确定您的操作系统并提供适当的下载。如果您需要其他内容，请单击标题中的DOWNLOADS链接以获取所有可能的下载：
- en: '![](img/63b156b2-8046-4789-a277-04a59cc77f3f.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63b156b2-8046-4789-a277-04a59cc77f3f.png)'
- en: For macOS, the installer is a `PKG` file that gives the typical installation
    process. For Windows, the installer simply takes you through the typical install
    wizard process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，安装程序是一个`PKG`文件，提供了典型的安装过程。对于Windows，安装程序只需按照典型的安装向导过程进行。
- en: Once you are finished with the installer, you have command-line tools, such
    as `node` and `npm`, which you can run Node.js programs with. On Windows, you're
    supplied with a version of the Windows command shell preconfigured to work nicely
    with Node.js.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序完成后，您将拥有命令行工具，例如`node`和`npm`，您可以使用它们来运行Node.js程序。在Windows上，您将获得一个预配置为与Node.js良好配合工作的Windows命令外壳版本。
- en: As you have just learned, most of us will be perfectly satisfied with installing
    prebuilt packages. However, there are times when we must install Node.js from
    a source.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚刚了解的，我们大多数人将完全满意于安装预构建的软件包。但是，有时我们必须从源代码安装Node.js。
- en: Installing from the source on POSIX-like systems
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类似POSIX的系统上从源代码安装
- en: 'Installing the prepackaged Node.js distributions is the preferred installation
    method. However, installing Node.js from a source is desirable in a few situations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装预打包的Node.js发行版是首选的安装方法。但是，在一些情况下，从源代码安装Node.js是可取的：
- en: It can let you optimize the compiler settings as desired.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让您根据需要优化编译器设置。
- en: It can let you cross-compile, say, for an embedded ARM system.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让您交叉编译，比如为嵌入式ARM系统。
- en: You might need to keep multiple Node.js builds for testing.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要保留多个Node.js版本进行测试。
- en: You might be working on Node.js itself.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能正在处理Node.js本身。
- en: Now that you have a high-level view, let's get our hands dirty by mucking around
    in some build scripts. The general process follows the usual `configure`, `make`,
    and `make install` routine that you may have already performed with other open
    source software packages. If not, don't worry, we'll guide you through the process.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一个高层次的视图，让我们通过一些构建脚本来动手。一般的过程遵循您可能已经用其他开源软件包执行过的`configure`、`make`和`make
    install`例程。如果没有，不用担心，我们会指导您完成这个过程。
- en: The official installation instructions are in `README.md`, contained in the
    source distribution at [https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 官方安装说明在源分发的`README.md`中，位于[https://github.com/nodejs/node/blob/master/README.md](https://github.com/nodejs/node/blob/master/README.md)。
- en: Installing prerequisites
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: 'There are three prerequisites: a C compiler, Python, and the OpenSSL libraries.
    The Node.js compilation process checks for their presence and will fail if the
    C compiler or Python is not present. These sorts of commands will check for their
    presence:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个先决条件：C编译器、Python和OpenSSL库。Node.js编译过程会检查它们的存在，如果C编译器或Python不存在，将会失败。这些命令将检查它们的存在：
- en: '[PRE3]js\1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: 'This installs the Xcode command-line tools:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Xcode命令行工具：
- en: '![](img/d8c5d5a8-8f7e-40e0-8f9d-3e8e892f2204.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8c5d5a8-8f7e-40e0-8f9d-3e8e892f2204.png)'
- en: For additional information, visit [http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问[http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/](http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/)。
- en: Now that we have the required tools installed, we can proceed with compiling
    the Node.js source.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所需的工具，我们可以继续编译Node.js源代码。
- en: Installing from the source for all POSIX-like systems
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为所有类POSIX系统从源代码安装
- en: 'Compiling Node.js from the source follows this familiar process:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译Node.js遵循以下熟悉的过程：
- en: Download the source from [http://nodejs.org/download.](http://nodejs.org/download)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://nodejs.org/download.](http://nodejs.org/download)下载源代码。
- en: Configure the source for building using `./configure`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`./configure`配置源代码进行构建。
- en: Run `make`, then `make install`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`make`，然后运行`make install`。
- en: 'The source bundle can be downloaded through your browser or as follows, substituting
    your preferred version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包可以通过浏览器下载，或者按照以下步骤进行替换您喜欢的版本：
- en: '[PRE4]js\1'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: 'To cause the installation to land in your `home` directory, run it this way:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使安装到您的`home`目录中，以这种方式运行它：
- en: '[PRE5]js\1'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: A simpler way to install multiple Node.js versions is by using the `nvm` script,
    which will be described later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 安装多个Node.js版本的更简单方法是使用`nvm`脚本，稍后将进行描述。
- en: If you want to install Node.js in a system-wide directory, simply leave off
    the `--prefix` option and it will default to installing in `/usr/local`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在系统范围的目录中安装Node.js，只需省略`--prefix`选项，它将默认安装在`/usr/local`中。
- en: After a moment, it'll stop and will likely have successfully configured the
    source tree for installation in your chosen directory. If this doesn't succeed,
    the error messages that are printed will describe what needs to be fixed. Once
    the configure script is satisfied, you can move on to the next step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 过一会儿，它会停止，并且很可能已经成功地配置了源树，以便在您选择的目录中进行安装。如果这不成功，打印出的错误消息将描述需要修复的内容。一旦配置脚本满意，您就可以继续下一步。
- en: 'With the configure script satisfied, you compile the software:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本满意后，您可以编译软件：
- en: '[PRE6]js\1'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: 'Once installed, you should make sure that you add the installation directory
    to your `PATH` variable, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您应该确保将安装目录添加到您的`PATH`变量中，如下所示：
- en: '[PRE7]js\1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: 'When the build is installed, it creates a directory structure, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，它会创建一个目录结构，如下所示：
- en: '[PRE8]js\1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: 'It starts to get a little tedious maintaining this after a while. For each
    release, you have to set up Node.js, npm, and any third-party modules you desire
    in your Node.js installation. Also, the command shown to change `PATH` is not
    quite optimal. Inventive programmers have created several version managers to
    simplify managing multiple Node.js/npm releases and provide commands to change `PATH`
    the smart way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间后，维护这个变得有点乏味。对于每个发布，您都必须在Node.js安装中设置Node.js、npm和任何第三方模块。此外，显示更改`PATH`的命令并不是最佳的。富有创造力的程序员已经创建了几个版本管理器，以简化管理多个Node.js/npm版本，并提供智能更改`PATH`的命令：
- en: Node version manager: [https://github.com/tj/n](https://github.com/tj/n)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node版本管理器：[https://github.com/tj/n](https://github.com/tj/n)
- en: Node version manager: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node版本管理器：[https://github.com/creationix/nvm](https://github.com/creationix/nvm)
- en: Both maintain multiple, simultaneous versions of Node.js and let you easily
    switch between versions. Installation instructions are available on their respective
    websites.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都维护多个同时版本的Node.js，并且让你可以轻松切换版本。安装说明可以在它们各自的网站上找到。
- en: 'For example, with `nvm`, you can run commands such as these:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`nvm`，您可以运行这样的命令：
- en: '[PRE9]js\1'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: This is done in a temporary directory, so you can delete it afterward. If your
    system does not have the tools installed to compile native code modules, you'll
    see error messages. Otherwise, you'll see a `node-gyp` execution in the output,
    followed by many lines of text obviously related to compiling C/C++ files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在临时目录中完成的，所以之后可以删除它。如果您的系统没有安装编译本地代码模块的工具，您将看到错误消息。否则，您将看到`node-gyp`的执行输出，然后是许多明显与编译C/C++文件相关的文本行。
- en: 'The `node-gyp` tool has prerequisites similar to those for compiling Node.js
    from the source—namely, a C/C++ compiler, a Python environment, and other build
    tools, such as Git. For Unix, macOS, and Linux systems, those are easy to come
    by. For Windows, you should install the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-gyp`工具具有与从源代码编译Node.js相似的先决条件，即C/C++编译器、Python环境和其他构建工具，如Git。对于Unix、macOS和Linux系统，这些都很容易获得。对于Windows，您应该安装以下内容：'
- en: Visual Studio build tools: [https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio构建工具：[https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017)
- en: Git for Windows: [http://git-scm.com/download/win](http://git-scm.com/download/win)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows的Git：[http://git-scm.com/download/win](http://git-scm.com/download/win)
- en: Python for Windows: [https://www.python.org/](https://www.python.org/)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows的Python：[https://www.python.org/](https://www.python.org/)
- en: Normally, you don't need to worry about installing `node-gyp`. That's because
    it is installed behind the scenes as part of npm. That's done so that npm can
    automatically build native code modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不需要担心安装`node-gyp`。这是因为它作为npm的一部分在后台安装。这样做是为了让npm可以自动构建本地代码模块。
- en: Its GitHub repository contains documentation; go to [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它的GitHub存储库包含文档；转到[https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)。
- en: Reading the `node-gyp` documentation in its repository will give you a clearer
    understanding of the compilation prerequisites discussed previously and of developing
    native code modules.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`node-gyp`存储库中的文档将让您更清楚地了解之前讨论的编译先决条件和开发本地代码模块。
- en: This is an example of a non-explicit dependency. It is best to explicitly declare
    all the things that a software package depends on. In Node.js, dependencies are
    declared in `package.json` so that the package manager (`npm` or `yarn`) can download
    and set up everything. But these compiler tools are set up by the OS package management
    system, which is outside the control of `npm` or `yarn`. Therefore, we cannot
    explicitly declare those dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非显式依赖的示例。最好明确声明软件包依赖的所有内容。在Node.js中，依赖关系在`package.json`中声明，以便包管理器（`npm`或`yarn`）可以下载和设置所有内容。但是这些编译器工具是由操作系统包管理系统设置的，这是`npm`或`yarn`无法控制的。因此，我们无法明确声明这些依赖关系。
- en: We've just learned that Node.js supports modules written not just in JavaScript,
    but also in other programming languages. We've also learned how to support the
    installation of such modules. Next, we will learn about Node.js version numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到Node.js不仅支持用JavaScript编写的模块，还支持其他编程语言。我们还学会了如何支持这些模块的安装。接下来，我们将了解Node.js版本号。
- en: Choosing Node.js versions to use and the version policy
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择要使用的Node.js版本和版本策略
- en: We just threw around so many different Node.js version numbers in the previous
    section that you may have become confused about which version to use. This book
    is targeted at Node.js version 14.x and it's expected that everything we'll cover
    is compatible with Node.js 10.x and any subsequent release.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到了许多不同的Node.js版本号，您可能会对要使用哪个版本感到困惑。本书针对的是Node.js版本14.x，并且预计我们将涵盖的所有内容都与Node.js
    10.x和任何后续版本兼容。
- en: Starting with Node.js 4.x, the Node.js team has followed a dual-track approach.
    The even-numbered releases (4.x, 6.x, 8.x, and so on) are what they're calling
    **long term support** (**LTS**), while the odd-numbered releases (5.x, 7.x, 9.x,
    and so on) are where current new feature development occurs. While the development
    branch is kept stable, the LTS releases are positioned as being for production
    use and will receive updates for several years.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从Node.js 4.x开始，Node.js团队采用了双轨道方法。偶数版本（4.x、6.x、8.x等）被称为**长期支持**（**LTS**），而奇数版本（5.x、7.x、9.x等）是当前新功能开发的地方。虽然开发分支保持稳定，但LTS版本被定位为用于生产使用，并将在几年内接收更新。
- en: At the time of writing, Node.js 12.x is the current LTS release; Node.js 14.x
    has been released and will eventually become the LTS release.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Node.js 12.x是当前的LTS版本；Node.js 14.x已发布，最终将成为LTS版本。
- en: A major impact of each new Node.js release, beyond the usual performance improvements
    and bug fixes, is the bringing in of the latest V8 JavaScript engine release.
    In turn, this means bringing in more of the ES2015/2016/2017 features as the V8
    team implements them. In Node.js 8.x, the `async/await` functions arrived and
    in Node.js 10.x, support for the standard ES6 module format has arrived. In Node.js
    14.x that module format will be completely supported.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的Node.js发布的主要影响，除了通常的性能改进和错误修复之外，还包括引入最新的V8 JavaScript引擎发布。反过来，这意味着引入更多的ES2015/2016/2017功能，因为V8团队正在实现它们。在Node.js
    8.x中，`async/await`函数到达，在Node.js 10.x中，支持标准的ES6模块格式到达。在Node.js 14.x中，该模块格式将得到完全支持。
- en: A practical consideration is whether a new Node.js release will break your code.
    New language features are always being added as V8 catches up with ECMAScript
    and the Node.js team sometimes makes groundbreaking changes to the Node.js API.
    If you've tested on one Node.js version, will it work on an earlier version? Will
    a Node.js change break some assumptions we made?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的考虑是新的Node.js发布是否会破坏您的代码。新的语言功能总是在V8赶上ECMAScript的过程中添加，Node.js团队有时会对Node.js
    API进行重大更改。如果您在一个Node.js版本上进行了测试，它是否会在较早的版本上工作？Node.js的更改是否会破坏我们的一些假设？
- en: What npm does is ensure that our packages execute on the correct Node.js version.
    This means that we can specify the compatible Node.js versions for a package in
    the `package.json` file (which we'll explore in [Chapter 3](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml),
    *Exploring Node.js Modules)*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: npm的作用是确保我们的软件包在正确的Node.js版本上执行。这意味着我们可以在`package.json`文件中指定软件包的兼容Node.js版本（我们将在[第3章](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml)，*探索Node.js模块*中探讨）。
- en: 'We can add an entry to `package.json` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`package.json`中添加条目如下：
- en: '[PRE10]js\1'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: That was a lot of output but don't study it too closely. The key takeaway is
    that `node --help` provides a lot of useful information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出很多，但不要过于仔细研究。关键是`node --help`提供了很多有用的信息。
- en: Note that there are options for both Node.js and V8 (not shown in the previous
    command line). Remember that Node.js is built on top of V8; it has its own universe
    of options that largely focus on details of bytecode compilation or garbage collection
    and heap algorithms. Enter `node --v8-options` to see the full list of these options.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Node.js和V8都有选项（在上一个命令行中未显示）。请记住Node.js是建立在V8之上的；它有自己的选项宇宙，主要关注字节码编译、垃圾回收和堆算法的细节。输入`node
    --v8-options`以查看这些选项的完整列表。
- en: On the command line, you can specify options, a single script file, and a list
    of arguments to that script. We'll discuss script arguments further in the following
    section, *Running a simple script with Node.js*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上，您可以指定选项、单个脚本文件和该脚本的参数列表。我们将在下一节*使用Node.js运行简单脚本*中进一步讨论脚本参数。
- en: 'Running Node.js with no arguments drops you in an interactive JavaScript shell:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有参数的情况下运行Node.js会将您放在一个交互式JavaScript shell中：
- en: '[PRE11]js\1'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: 'Next, run it by typing the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过输入以下命令来运行它：
- en: '[PRE12]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: The `man` command, of course, lets you read manual pages and section `3` covers
    the C library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`man`命令让你阅读手册页，第`3`节涵盖了C库。
- en: Inside the function body, we read the directory and print its contents. Using
    `require('fs').promises` gives us a version of the `fs` module (filesystem functions)
    that returns Promises; it, therefore, works well in an async function. Likewise,
    the ES2015 `for..of` loop construct lets us loop over entries in an array in a
    way that works well in `async` functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，我们读取目录并打印其内容。使用`require('fs').promises`给我们提供了一个返回Promise的`fs`模块（文件系统函数）的版本；因此，在异步函数中它可以很好地工作。同样，ES2015的`for..of`循环构造让我们能够以一种适合在`async`函数中工作的方式循环遍历数组中的条目。
- en: By default, the `fs` module functions use the callback paradigm originally created
    for Node.js. As a result, most Node.js modules use the callback paradigm. Within
    `async` functions, it is more convenient if functions return Promises instead
    so that the `await` keyword can be used. The `util` module provides a function, `util.promisify`,
    which generates a wrapper function for old-style callback-oriented functions so
    it instead returns a Promise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`fs`模块函数使用最初为Node.js创建的回调范式。因此，大多数Node.js模块使用回调范式。在`async`函数中，如果函数返回Promise，那么更方便使用`await`关键字。`util`模块提供了一个函数，`util.promisify`，它为旧式的面向回调的函数生成一个包装函数，因此它返回一个Promise。
- en: This script is hardcoded to list files in the current directory. The real `ls`
    command takes a directory name, so let's modify the script a little.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是硬编码为列出当前目录中的文件。真正的`ls`命令需要一个目录名，所以让我们稍微修改一下脚本。
- en: 'Command-line arguments land in a global array named `process.argv`. Therefore,
    we can modify `ls.js`, copying it as `ls2.js` (as follows) to see how this array
    works:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数会落入一个名为`process.argv`的全局数组中。因此，我们可以修改`ls.js`，将其复制为`ls2.js`（如下所示）来看看这个数组是如何工作的：
- en: '[PRE13]js\1'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: 'We simply checked whether a command-line argument was present, `if (process.argv[2])`.
    If it was, we override the value of the `dir` variable, `dir = process.argv[2]`,
    and we then use that as the `readdir` argument:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是检查了命令行参数是否存在，`if (process.argv[2])`。如果存在，我们会覆盖`dir`变量的值，`dir = process.argv[2]`，然后将其用作`readdir`的参数：
- en: '[PRE14]js\1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: You can use this anywhere; for example, the function can be assigned to a variable
    or it can be passed as a callback to another function. When used with the `async`
    keyword, the body of the arrow function has all of the `async` function's behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方使用这个；例如，该函数可以被分配给一个变量，或者它可以作为回调传递给另一个函数。当与`async`关键字一起使用时，箭头函数的主体具有所有`async`函数的行为。
- en: 'For the purpose of these examples, an async arrow function can be wrapped for
    immediate execution:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这些示例的目的，可以将异步箭头函数包装为立即执行：
- en: '[PRE15]js\1'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: Whether this or the previous style is preferable is perhaps a matter of taste.
    However, you will find both styles in use and it is necessary to understand how
    both work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这种风格或者之前的风格更可取。然而，你会发现这两种风格都在使用中，了解这两种风格的工作方式是必要的。
- en: When invoking an async function at the top level of a script, it is necessary
    to capture any errors and report them. Failure to catch and report errors can
    lead to mysterious problems that are hard to pin down. For the original version
    of this example, the errors were explicitly caught with a `try/catch` block. In
    this version, we catch errors using a `.catch` block.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶层调用异步函数时，有必要捕获任何错误并报告它们。未能捕获和报告错误可能导致难以解决的神秘问题。在这个示例的原始版本中，错误是通过`try/catch`块明确捕获的。在这个版本中，我们使用`.catch`块捕获错误。
- en: Before we had async functions, we had the Promise object and before that, we
    had the callback paradigm. All three paradigms are still used in Node.js, meaning
    you'll need to understand each.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有异步函数之前，我们有Promise对象，而在那之前，我们有回调范式。所有三种范式在Node.js中仍在使用，这意味着你需要理解每一种。
- en: Converting to async functions and the Promise paradigm
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为异步函数和Promise范式
- en: In the previous section, we discussed `util.promisify` and its ability to convert
    a callback-oriented function into one that returns a Promise. The latter plays
    well with async functions and therefore, it is preferable for functions to return
    a Promise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了`util.promisify`及其将面向回调的函数转换为返回Promise的能力。后者与异步函数很好地配合，因此，最好让函数返回一个Promise。
- en: To be more precise, `util.promisify` is to be given a function that uses the
    error-first-callback paradigm. The last argument of such functions is a callback
    function, whose first argument is interpreted as an error indicator, hence the
    phrase error-first-callback. What `util.promisify` returns is another function
    that returns a Promise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，`util.promisify`应该给出一个使用错误优先回调范式的函数。这些函数的最后一个参数是一个回调函数，其第一个参数被解释为错误指示器，因此有了错误优先回调这个短语。`util.promisify`返回的是另一个返回Promise的函数。
- en: The Promise serves the same purpose as error-first-callback. If an error is
    indicated, the Promise resolves to the rejected status, while if success is indicated,
    the Promise resolves to a success status. As we see in these examples, the Promise
    is handled very nicely within an `async` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Promise的作用与错误优先回调相同。如果指示了错误，则Promise解析为拒绝状态，而如果指示了成功，则Promise解析为成功状态。正如我们在这些示例中看到的那样，Promise在`async`函数中处理得非常好。
- en: The Node.js ecosystem has a large body of functions that use error-first-callback.
    The community has began a conversion process where functions will return a Promise
    and possibly also take an error-first-callback for API compatibility.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js生态系统拥有大量使用错误优先回调的函数。社区已经开始了一个转换过程，其中函数将返回一个Promise，并可能还会接受一个错误优先回调以实现API兼容性。
- en: One of the new features in Node.js 10 is an example of such a conversion. Within
    the `fs` module is a submodule, named `fs.promises`, with the same API but producing
    Promise objects. We wrote the previous examples using that API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 10中的一个新功能就是这样的转换的一个例子。在`fs`模块中有一个名为`fs.promises`的子模块，具有相同的API，但产生Promise对象。我们使用该API编写了前面的示例。
- en: Another choice is a third-party module, `fs-extra`. This module has an extended
    API beyond the standard `fs` module. On one hand, its functions return a Promise
    if no callback function is provided or else invokes the callback. In addition,
    it includes several useful functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是第三方模块`fs-extra`。该模块具有超出标准`fs`模块的扩展API。一方面，如果没有提供回调函数，它的函数会返回一个Promise，否则会调用回调函数。此外，它还包括几个有用的函数。
- en: In the rest of this book, we will often use `fs-extra` because of those additional functions.
    For documentation on the module, go to [https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们经常使用`fs-extra`，因为它具有额外的功能。有关该模块的文档，请访问[https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)。
- en: The `util` module has another function, `util.callbackify`, which does as the
    name implies—it converts a function that returns a Promise into one that uses
    a callback function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`模块还有另一个函数`util.callbackify`，它的功能与其名称暗示的一样——它将返回Promise的函数转换为使用回调函数的函数。'
- en: Now that we've seen how to run a simple script, let's look at a simple HTTP
    server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何运行一个简单的脚本，让我们来看一个简单的HTTP服务器。
- en: Launching a server with Node.js
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node.js启动服务器
- en: Many scripts that you'll run are server processes; we'll be running lots of
    these scripts later on. Since we're still trying to verify the installation and
    get you familiar with using Node.js, we want to run a simple HTTP server. Let's
    borrow the simple server script on the Node.js home page ([http://nodejs.org](http://nodejs.org)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你将运行许多服务器进程的脚本；我们稍后将运行许多这样的脚本。由于我们仍在尝试验证安装并让你熟悉使用Node.js，我们想要运行一个简单的HTTP服务器。让我们借用Node.js首页上的简单服务器脚本([http://nodejs.org](http://nodejs.org))。
- en: 'Create a file named `app.js`, containing the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`app.js`的文件，其中包含以下内容：
- en: '[PRE16]js\1'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: 'This is the simplest of web servers you can build with Node.js. If you''re
    interested in how it works, flip forward to [Chapter 4](a883aeee-aa28-44c6-a02e-8238829cea90.xhtml),
    *HTTP Servers and Clients*, [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml),
    *Your First Express Application*, and [Chapter 6](db8b0ab8-181f-4d8d-9088-a9962ec461b8.xhtml),
    *Implementing the Mobile-First Paradigm*. But for now, just type `http://127.0.0.1:8124`
    in your browser to see the Hello, World! message:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以用Node.js构建的最简单的网络服务器。如果你对它的工作原理感兴趣，请翻到[第4章](a883aeee-aa28-44c6-a02e-8238829cea90.xhtml)，*HTTP服务器和客户端*，[第5章](582d3898-0135-430c-8b6e-8326f287e18b.xhtml)，*你的第一个Express应用程序*，和[第6章](db8b0ab8-181f-4d8d-9088-a9962ec461b8.xhtml)，*实现移动优先范式*。但现在，只需在浏览器中键入`http://127.0.0.1:8124`，就可以看到Hello,
    World!的消息：
- en: '![](img/fec4c888-fe02-4660-b3a3-ed7810a88ef1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fec4c888-fe02-4660-b3a3-ed7810a88ef1.png)'
- en: A question to ponder is why this script didn't exit when `ls.js` did. In both
    cases, execution of the script reaches the end of the file; the Node.js process
    does not exit in `app.js`, while it does in `ls.js`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得思考的问题是为什么这个脚本在`ls.js`退出时没有退出。在两种情况下，脚本的执行都到达了文件的末尾；Node.js进程在`app.js`中没有退出，而在`ls.js`中退出了。
- en: The reason for this is the presence of active event listeners. Node.js always
    starts up an event loop and in `app.js`, the `listen` function creates an event, `listener`,
    that implements the HTTP protocol. This `listener` event keeps `app.js` running
    until you do something, such as press *Ctrl* + *C* in the terminal window. In
    `ls.js`, there is nothing there to create a long-running `listener` event, so
    when `ls.js` reaches the end of its script, the `node` process will exit.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为存在活动事件监听器。Node.js始终启动一个事件循环，在`app.js`中，`listen`函数创建了一个实现HTTP协议的事件`listener`。这个`listener`事件会一直保持`app.js`运行，直到你做一些事情，比如在终端窗口中按下*Ctrl*
    + *C*。在`ls.js`中，没有任何内容来创建一个长时间运行的`listener`事件，所以当`ls.js`到达脚本的末尾时，`node`进程将退出。
- en: To carry out more complex tasks with Node.js, we must use third-party modules.
    The npm repository is the place to go.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Node.js执行更复杂的任务，我们必须使用第三方模块。npm存储库是去的地方。
- en: Using npm, the Node.js package manager
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用npm，Node.js包管理器
- en: Node.js, being a JavaScript interpreter with a few interesting asynchronous
    I/O libraries, is by itself a pretty basic system. One of the things that makes
    Node.js interesting is the rapidly growing ecosystem of third-party modules for
    Node.js.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js作为一个具有一些有趣的异步I/O库的JavaScript解释器，本身就是一个相当基本的系统。使Node.js有趣的事情之一是不断增长的用于Node.js的第三方模块生态系统。
- en: At the center of that ecosystem is the npm module repository. While Node.js
    modules can be downloaded as source and assembled manually for use with Node.js
    programs, that's tedious to do and it's difficult to implement a repeatable build
    process. npm gives us a simpler method; npm is the de facto standard package manager
    for Node.js and it greatly simplifies downloading and using these modules. We
    will talk about npm at length in the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The sharp-eyed among you will have noticed that npm is already installed via
    all the installation methods discussed previously. In the past, npm was installed
    separately, but today it is bundled with Node.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `npm` installed, let''s take it for a quick spin. The **hexy** program
    is a utility used for printing hex dumps of files. That''s a very 1970s thing
    to do, but it is still extremely useful. It serves our purpose right now as it
    gives us something to quickly install and try out:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]js\1'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed, you''ll be able to run the newly–installed program this
    way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]js\1'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Under the covers, `npx` uses `npm` to download the package to a cache directory,
    unless the package is already installed in the current project directory. Because
    the package is then in a cache directory, it is only downloaded once.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of interesting options to this tool; to learn more, go to
    [https://www.npmjs.com/package/npx](https://www.npmjs.com/package/npx).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We have learned a lot in this section about the command-line tools delivered
    with Node.js, as well as ran a simple script and HTTP server. Next, we will learn
    how advances in the JavaScript language affect the Node.js platform.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Advancing Node.js with ECMAScript 2015, 2016, 2017, and beyond
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2015, the ECMAScript committee released a long-awaited major update of the
    JavaScript language. The update brought in many new features to JavaScript, such
    as Promises, arrow functions, and class objects. The language update sets the
    stage for improvement since it should dramatically improve our ability to write
    clean, understandable JavaScript code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The browser makers are adding those much-needed features, meaning the V8 engine
    is adding those features as well. These features are making their way to Node.js,
    starting with version 4.x.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the current status of ES2015/2016/2017/and so on in Node.js,
    visit [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the ES2015, 2016, and 2017 features that V8 considers stable
    are enabled by Node.js. Further features can be enabled with command-line options.
    The almost-complete features are enabled with the `--es_staging` option. The website
    documentation gives more information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The Node green website ([http://node.green/](http://node.green/)) has a table
    that lists the status of a long list of features in Node.js versions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The ES2019 language spec is published at [https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The TC-39 committee does its work on GitHub at [https://github.com/tc39](https://github.com/tc39).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The ES2015 (and later) features make a big improvement to the JavaScript language.
    One feature, the `Promise` class, should mean a fundamental rethinking of common
    idioms in Node.js programming. In ES2017, a pair of new keywords, `async` and
    `await`, simplifies writing asynchronous code in Node.js, which should encourage
    the Node.js community to further rethink the common idioms of the platform.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: There's a long list of new JavaScript features but let's quickly go over the
    two of them that we'll use extensively.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is a lighter-weight function syntax called the arrow function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]js\1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to understand the code; it's just an outline of what happens
    in practice as we use callbacks. Depending on how many steps are required for
    a specific task, a code pyramid can get quite deep. Promises will let us unravel
    the code pyramid and improve reliability because error handling is more straightforward
    and easily captures all errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Promise` class is created as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]js\1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This works because the `Promise` class supports chaining if a `then` function
    returns a `Promise` object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async/await` feature implements the promise of the `Promise` class to
    simplify asynchronous coding. This feature becomes active within an `async` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how much of an improvement the `async` function paradigm gives us, let''s
    recode the earlier example as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]js\1'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates having an object with three fields but only extracting two
    of the fields.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: To continue our exploration of advances in JavaScript, let's take a look at
    Babel.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Using Babel to use experimental JavaScript features
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Babel transpiler is the leading tool for using cutting-edge JavaScript features
    or experimenting with new JavaScript features. Since you've probably never seen
    the word **transpiler**, it means to rewrite source code from one language to
    another. It is like a **compiler** in that Babel converts computer source code
    into another form, but instead of directly executable code, Babel produces JavaScript.
    That is, it converts JavaScript code into JavaScript code, which may not seem
    useful until you realize that Babel's output can target older JavaScript releases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Put more simply, Babel can be configured to rewrite code with ES2015, ES2016,
    ES2017 (and so on) features into code conforming to the ES5 version of JavaScript.
    Since ES5 JavaScript is compatible with practically every web browser on older
    computers, a developer can write their frontend code in modern JavaScript then
    convert it to execute on older browsers using Babel.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Babel, go to [https:// babeljs.io](https://%20babeljs.io).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The Node Green website makes it clear that Node.js supports pretty much all
    of the ES2015, 2016, and 2017 features. Therefore, as a practical matter, we no
    longer need to use Babel for Node.js projects. You may possibly be required to
    support an older Node.js release and you can use Babel to do so.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: For web browsers, there is a much longer time lag between a set of ECMAScript
    features and when we can reliably use those features in browser-side code. It's
    not that the web browser makers are slow in adopting new features as the Google,
    Mozilla, and Microsoft teams are proactive about adopting the latest features.
    Apple's Safari team seems slow to adopt new features, unfortunately. What's slower,
    however, is the penetration of new browsers into the fleet of computers in the
    field.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, modern JavaScript programmers need to familiarize themselves with
    Babel.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: We're not ready to show example code for these features yet, but we can go ahead
    and document the setting up of the Babel tool. For further information on setup
    documentation, visit [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/) and
    click on the CLI button.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: To get a brief introduction to Babel, we'll use it to transpile the scripts
    we saw earlier to run on Node.js 6.x. In those scripts, we used async functions,
    a feature that is not supported on Node.js 6.x.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'In the directory containing `ls.js` and `ls2.js`, type these commands:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]js\1'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We have the same example we looked at earlier, but with a couple of changes.
    The `fs_readdir` function creates a Promise object then calls `fs.readdir`, making
    sure to either `reject` or `resolve` the Promise based on the result we get. This
    is more or less what the `util.promisify` function does.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Because `fs_readdir` returns a Promise, the `await` keyword can do the right
    thing and wait for the request to either succeed or fail. This code should run
    as is on Node.js releases, which support `async` functions. But what we're interested
    in—and the reason why we added the `fs_readdir` function—is how it works on older
    Node.js releases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`fs_readdir`返回一个Promise，所以`await`关键字可以做正确的事情，并等待请求成功或失败。这段代码应该在支持`async`函数的Node.js版本上运行。但我们感兴趣的是，也是我们添加`fs_readdir`函数的原因是它在旧的Node.js版本上是如何工作的。
- en: The pattern used in `fs_readdir` is what is required to use a callback-oriented
    function in an `async` function context.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs_readdir`中使用的模式是在`async`函数上下文中使用基于回调的函数所需的。'
- en: 'Next, create a file named `.babelrc`, containing the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`.babelrc`的文件，其中包含以下内容：
- en: '[PRE24]js\1'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: 'To transpile your code, run the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要转译您的代码，请运行以下命令：
- en: '[PRE25]js\1'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: This code isn't meant to be easy to read for humans. Instead, it means that
    you edit the original source file and then convert it for your target JavaScript
    engine. The main thing to notice is that the transpiled code uses a Generator
    function (the notation `function*` indicates a generator function) in place of
    the `async` function and the `yield` keyword in place of the `await` keyword.
    What a generator function is—and precisely what the `yield` keyword does—is not
    important; the only thing to note is that `yield` is roughly equivalent to `await` and
    that the `_asyncToGenerator` function implements functionality similar to async
    functions. Otherwise, the transpiled code is fairly clean and looks rather similar
    to the original code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是为了人类易读。相反，它意味着你编辑原始源文件，然后将其转换为目标JavaScript引擎。要注意的主要事情是转译后的代码使用了生成器函数（`function*`表示生成器函数）代替`async`函数，使用`yield`关键字代替`await`关键字。生成器函数是什么，以及`yield`关键字的确切作用并不重要；唯一需要注意的是`yield`大致相当于`await`，而`_asyncToGenerator`函数实现了类似于async函数的功能。否则，转译后的代码相当清晰，看起来与原始代码相似。
- en: 'The transpiled script is run as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 转译后的脚本运行如下：
- en: '```js\1'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '```js\1'
- en: In other words, it runs the same as the `async` version but on an older Node.js
    release. Using a similar process, you can transpile code written with modern ES2015
    (and so on) constructions so it can run in an older web browser.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它在旧的Node.js版本上运行与`async`版本相同。使用类似的过程，您可以转译使用现代ES2015（等等）构造编写的代码，以便在旧的Web浏览器中运行。
- en: In this section, we learned about advances in the JavaScript language, especially
    async functions, and then learned how to use Babel to use those features on older
    Node.js releases or in older web browsers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了JavaScript语言的进展，特别是async函数，然后学习了如何使用Babel在旧的Node.js版本或旧的Web浏览器上使用这些功能。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about installing Node.js using its command-line
    tools and running a Node.js server. We also breezed past a lot of details that
    will be covered later in this book, so be patient.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了使用Node.js的命令行工具安装Node.js并运行Node.js服务器。我们也匆匆忽略了很多细节，这些细节将在本书的后面进行详细介绍，所以请耐心等待。
- en: Specifically, we covered downloading and compiling the Node.js source code,
    installing Node.js—either for development use in your home directory or for deployment
    in system directories—and installing npm, the de facto standard package manager
    used with Node.js. We also saw how to run Node.js scripts or Node.js servers.
    We then took a look at the new features in ES2015, 2016, and 2017\. Finally, we
    looked at how to use Babel to implement those features in your code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了下载和编译Node.js源代码，安装Node.js（无论是在家目录中用于开发还是在系统目录中用于部署），以及安装npm，这是与Node.js一起使用的事实上的标准包管理器。我们还看到了如何运行Node.js脚本或Node.js服务器。然后我们看了ES2015、2016和2017的新功能。最后，我们看了如何使用Babel在您的代码中实现这些功能。
- en: Now that we've seen how to set up a development environment, we're ready to
    start working on implementing applications with Node.js. The first step is to
    learn the basic building blocks of Node.js applications and modules, meaning taking
    a more careful look at Node.js modules, how they are used, and how to use npm
    to manage application dependencies. We will cover all of that in the next chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何设置开发环境，我们准备开始使用Node.js实现应用程序。第一步是学习Node.js应用程序和模块的基本构建模块，即更仔细地查看Node.js模块，它们是如何使用的，以及如何使用npm来管理应用程序的依赖关系。我们将在下一章中涵盖所有这些内容。
